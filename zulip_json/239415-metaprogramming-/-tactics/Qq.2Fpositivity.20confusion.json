[
    {
        "content": "<p>I've tried to write a positivity extension with Qq and I ran into a weird problem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Order.Group.PosPart</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Mathlib.Meta.Positivity</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Qq</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">LinearOrder</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">positivity</span> <span class=\"n\">PosPart.pos</span> <span class=\"n\">_</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">evalPosPart</span> <span class=\"o\">:</span> <span class=\"n\">PositivityExt</span> <span class=\"n\">where</span> <span class=\"n\">eval</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"n\">zα</span> <span class=\"n\">pα</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PosPart.pos</span> <span class=\"n\">_</span> <span class=\"bp\">$</span><span class=\"n\">inst1</span> <span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">instαLattice</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstanceQ</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Lattice</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">instαAddGroup</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstanceQ</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">AddGroup</span> <span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"n\">assertInstancesCommute</span>\n    <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">nonnegative</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">posPart_nonneg</span> <span class=\"bp\">$</span><span class=\"n\">α</span> <span class=\"bp\">$</span><span class=\"n\">instαLattice</span> <span class=\"bp\">$</span><span class=\"n\">instαAddGroup</span> <span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"not PosPart.pos\"</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Lattice</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddGroup</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"bp\">⁺</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">positivity</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Mathlib.Meta.Positivity</span>\n</code></pre></div>\n<p>The <code>return</code> fails with error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">posPart_nonneg</span> <span class=\"bp\">«$</span><span class=\"n\">a</span><span class=\"bp\">»</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"bp\">«$</span><span class=\"n\">a</span><span class=\"bp\">»⁺</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"bp\">«$</span><span class=\"n\">e</span><span class=\"bp\">»</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>even though the matching ensures that these two are equal. I don't know how to use the matching hypothesis to make Qq happy and I haven't seen a similar issue in any of the other positivity extensions</p>",
        "id": 422061931,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1708226629
    },
    {
        "content": "<p>You're using the wrong function?</p>",
        "id": 422082970,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708248566
    },
    {
        "content": "<p>See <a href=\"https://github.com/leanprover-community/mathlib4/pull/10256\">#10256</a></p>",
        "id": 422082992,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708248591
    },
    {
        "content": "<p>Anyway, I have those extensions written. I can PR them</p>",
        "id": 422083048,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708248607
    },
    {
        "content": "<p><code>set_option autoImplicit false</code> makes the error clearer (you're missing the import of <code>PositivityExt</code>)</p>",
        "id": 422086327,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708251623
    },
    {
        "content": "<p>To decode Yael's comment, you should be using <code>posPart</code> not <code>PosPart.pos</code></p>",
        "id": 422086688,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708251962
    },
    {
        "content": "<p>So this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">positivity</span> <span class=\"n\">posPart</span> <span class=\"n\">_</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">evalPosPart</span> <span class=\"o\">:</span> <span class=\"n\">PositivityExt</span> <span class=\"n\">where</span> <span class=\"n\">eval</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"n\">zα</span> <span class=\"n\">pα</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">posPart</span> <span class=\"n\">_</span> <span class=\"bp\">$</span><span class=\"n\">inst1</span> <span class=\"bp\">$</span><span class=\"n\">inst2</span> <span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">assertInstancesCommute</span>\n    <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">nonnegative</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">posPart_nonneg</span> <span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"not PosPart.pos\"</span>\n</code></pre></div>",
        "id": 422086729,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708251972
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/10681\">#10681</a></p>",
        "id": 422086779,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708252027
    },
    {
        "content": "<p>There is a bug here: <code>core q(inferInstance) q(inferInstance) a</code> fails instead of returning <code>none</code> when no <code>0 ≤ a</code> or <code>0 &lt; a</code> assumption is in context.</p>",
        "id": 422086867,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708252097
    },
    {
        "content": "<p>Thanks you. That was very silly of me.</p>",
        "id": 422093554,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1708258780
    },
    {
        "content": "<p>Yael there are at least two instance where <code>positivity</code> should be able to replace explicit calls to <code>posPart_nonneg</code> and a third one where one needs a <code>positivity</code>-extension for integrals (I wrote a PR for that)</p>",
        "id": 422093642,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1708258848
    },
    {
        "content": "<p>You mean two occurrences in mathlib? I didn't know <code>posPart</code> was used at all yet.</p>",
        "id": 422102437,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708267134
    },
    {
        "content": "<p>yes, in <code>MeasureTheory.Decomposition.Jordan</code> and <code>Probability.Martingale.Upcrossing</code></p>",
        "id": 422102722,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1708267397
    },
    {
        "content": "<p>this is how I found <code>posPart</code> in the first place: I was search&amp;replacing <code>integral_nonneg</code> and <code>Upcrossing</code> had these <code>posPart_nonneg</code> that we not used by <code>positivity</code>.</p>",
        "id": 422102942,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1708267598
    }
]