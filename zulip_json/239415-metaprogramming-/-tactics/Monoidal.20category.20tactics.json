[
    {
        "content": "<p>I was working on <a href=\"#narrow/stream/287929-mathlib4/topic/Braided.20left.20rigid.20categories.20are.20right.20rigid/near/446635020\">this</a>, and came across a bug and two tactic suggestions - I might try to (re)learn tactics and write it myself <del>if I feel like it...</del>, but maybe someone is interested too...</p>\n<p>Bug 1: <code>coherence</code> fails with \"no goals to solve\" when the proof is \"too trivial\".</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.RepresentationTheory.Character</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">BraidedCategory</span><span class=\"w\"> </span><span class=\"n\">MonoidalCategory</span>\n\n<span class=\"kd\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonoidalCategory</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BraidedCategory</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">coherence</span><span class=\"w\"> </span><span class=\"c1\">-- no</span>\n</code></pre></div>\n<p>I think it's missing some <code>try</code> somewhere?</p>\n<p>Feature 1: it would be great if theorems in monoidal categories can have their <code>monoidalComp</code> version automatically generated. Easiest example is look at <code>yang_baxter</code> and <code>yang_baxter'</code>. A TLDR is that <code>⊗≫</code> helps the user write cleaner equations by hiding associators and unitors, but as a result theorems that write out associators and units explicitly will duplicate it manually. So an attribute <code>@[...]</code> that generates it automatically would be great. Alternatively,</p>\n<p>Feature 2: have a feature that expands / contracts these associators and unitors. e.g. turn the goal / hypothesis <code>(β_ Y X).inv ▷ X ⊗≫ Y ◁ (β_ X X).inv</code> into <code>(β_ Y X).inv ▷ X ≫ (α_ Y X X).hom ≫ Y ◁ (β_ X X).inv</code> and vice versa. Keeping track of associators confuses my brain :(</p>\n<p>Hope this makes sense</p>",
        "id": 446644857,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1719242824
    },
    {
        "content": "<p>Actually for feature 2, it seems <code>simp [monoidalComp]</code> works well for monoidalComp -&gt; associators/unitors, but I don't think the other direction is there</p>",
        "id": 446690043,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1719254774
    },
    {
        "content": "<p>If you want to try sprinkling <code>try</code> to fix bug 1, I'll happily merge. :-)</p>",
        "id": 446752776,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719278654
    }
]