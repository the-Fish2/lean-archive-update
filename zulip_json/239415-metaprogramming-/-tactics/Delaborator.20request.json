[
    {
        "content": "<p>I'd love to have a delaborator which pretty-prints quantified statements </p>\n<ul>\n<li>with type annotations</li>\n<li>without parentheses</li>\n<li>paired up when relevant</li>\n</ul>\n<p>So, for example,</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>∃ a b : Nat, ∀ c : Nat, a + b = c\n</code></pre></div>\n<p>In the standard setup this pretty-prints as</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>∃ a b, ∀ (c : Nat), a + b = c\n</code></pre></div>\n<p>and with <code>set_option pp.funBinderTypes true</code> this pretty-prints as</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>∃ (a : Nat), ∃ (b : Nat), ∀ (c : Nat), a + b = c\n</code></pre></div>",
        "id": 411567612,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704601254
    },
    {
        "content": "<p>Something I'm hoping we can find a general solution for is giving pretty printer hints for unexpanders. Generally notations using binders use a lambda function, which means whether they get to pretty print with a binder is at the mercy of whether <code>pp.funBinderTypes</code> is set.</p>\n<p>Here's hack that we can use on a case-by-case basis to ensure binder types. This can be generalized to be a command to attach binder type information to a particular argument.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Lean.PrettyPrinter.Delaborator</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">PrettyPrinter.Delaborator</span> <span class=\"n\">SubExpr</span> <span class=\"k\">in</span>\n<span class=\"sd\">/-- \"Pre-delaborator\" for `Exists` that adds a `funBinderTypes` hint to its last argument. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">delab</span> <span class=\"n\">app.Exists</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">preDelabExists</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span> <span class=\"o\">:=</span>\n  <span class=\"n\">whenPPOption</span> <span class=\"n\">getPPNotation</span> <span class=\"bp\">&lt;|</span>\n  <span class=\"n\">whenPPOption</span> <span class=\"n\">getPPPiBinderTypes</span> <span class=\"bp\">&lt;|</span>\n  <span class=\"n\">whenNotPPOption</span> <span class=\"n\">getPPAnalysisSkip</span> <span class=\"bp\">&lt;|</span>\n  <span class=\"n\">withOptionAtCurrPos</span> <span class=\"bp\">`</span><span class=\"n\">pp.analysis.skip</span> <span class=\"n\">true</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">getExpr</span>\n    <span class=\"n\">guard</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">e.isAppOfArity</span> <span class=\"bp\">``</span><span class=\"n\">Exists</span> <span class=\"mi\">2</span>\n    <span class=\"k\">let</span> <span class=\"n\">optionsPerPos</span> <span class=\"bp\">←</span> <span class=\"n\">withAppArg</span> <span class=\"k\">do</span>\n      <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">read</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">optionsPerPos.setBool</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getPos</span><span class=\"o\">)</span> <span class=\"n\">pp.funBinderTypes.name</span> <span class=\"n\">true</span>\n    <span class=\"n\">withTheReader</span> <span class=\"n\">Context</span> <span class=\"o\">({</span><span class=\"bp\">·</span> <span class=\"k\">with</span> <span class=\"n\">optionsPerPos</span><span class=\"o\">})</span> <span class=\"n\">delab</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">∃ (x : ℕ), x = 0 : Prop</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c1\">-- Maybe this should be its own pp option, but I hooked it into `piBinderTypes`</span>\n<span class=\"c1\">-- since it seems to me that you want to control binders for everything quantifier-like.</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.piBinderTypes</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n<span class=\"k\">#check</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">∃ x, x = 0 : Prop</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c1\">-- The hack avoids setting `pp.funBinderTypes` globally:</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">fun x ↦ x + 1 : ℕ → ℕ</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 411640557,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704669152
    },
    {
        "content": "<p>The parentheses in the type ascription come from the core app unexpander. If you paste this version in, you can see it without parens:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">app_unexpander</span> <span class=\"n\">Exists</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">unexpandExists'</span> <span class=\"o\">:</span> <span class=\"n\">Lean.PrettyPrinter.Unexpander</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∃</span> <span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">:</span><span class=\"n\">binderIdent</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">:</span><span class=\"n\">binderIdent</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span>                     <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span>              <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"c1\">-- removed parens</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span>                                              <span class=\"bp\">=&gt;</span> <span class=\"n\">throw</span> <span class=\"o\">()</span>\n</code></pre></div>",
        "id": 411640723,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704669280
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Thanks for looking at this!  So to check that I'm following your directions: If I now use your </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">delab</span> <span class=\"n\">app.Exists</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">preDelabExists</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n<span class=\"kd\">@[</span><span class=\"n\">app_unexpander</span> <span class=\"n\">Exists</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">unexpandExists'</span> <span class=\"o\">:</span> <span class=\"n\">Lean.PrettyPrinter.Unexpander</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>and set <code>set_option pp.piBinderTypes true</code>, then I get a single existential to pretty-print exactly as I wanted:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"c1\">-- ∃ x : Nat, x = 0</span>\n</code></pre></div>\n<p>But double existentials still don't get merged:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"c1\">-- ∃ x : Nat, ∃ y : Nat, x = y</span>\n</code></pre></div>\n<p>and universal quantifiers still don't hide their parentheses:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"c1\">-- ∀ (x : Nat), x = 0</span>\n</code></pre></div>\n<p>Is this what you would expect?</p>",
        "id": 411673277,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704691338
    },
    {
        "content": "<p>Yes, that's right (with the understanding that piBinderTypes is true by default)</p>",
        "id": 411673694,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704691708
    }
]