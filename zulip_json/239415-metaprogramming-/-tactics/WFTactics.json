[
    {
        "content": "<p>I have a recursive definition that normalizes a <code>Option (List α)</code> where <code>α</code> is a tagged enum carrying a <code>Nat</code>.<br>\nI sort the list using a lexicographic order (with first by variant, then by value), then if the first variant-many contain the variants terminate out, otherwise prepend the first missing variant with a <code>0</code> value before recursing.<br>\nIn all other cases (detecting a variant twice in a row while iteratively matching for the sequence is all variants; <code>Option.none</code>), I terminate with <code>Option.none</code>.<br>\nClearly this can grow the list at most variant-count-many times before terminating the recursion.</p>\n<p>I'd love a tactic (or an extension to WFTactics) that can deal with this \"will grow only constant many times before terminating out\".<br>\nI'll provide the github later (not cleaned up yet, need to check licensing before uploading); it happened during my AoC2023 Day01 Part1 solution.<br>\nA band-aid was to slap <code>partial</code> on it, but that's both ugly and will prevent me from using proof-based programming for Part2.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>AoC 2023 Day02 solution</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>The shared problem instance/truth-valued function of part1 and part2 takes the second half of each input line (i.e., a <code>String</code>) plus a triple of <code>Nat</code>'s.<br>\nFor part1, the triple is fixed from the problem spec and you sum an extract (kinda turns out to be just a line number) from the first half of those lines where this function evaluates to <code>true</code>.<br>\nFor part2, you have to find the smallest triple for which the function with that <code>String</code> input evaluates to <code>true</code> (if no such triple exists, the <code>String</code> is ill-formed/there's a syntax error in the input), multiply the 3 numbers that make up said triple, and sum those products over all input lines.<br>\nTopologically the triple behaves like a product order lattice's <code>&lt;=</code> with a hidden derivate of the string on the left and the function argument triple on the right. (Is this discrete topology? Or is essentially nothing about that \"topology\"?)</p>\n<p>I'd have liked to use the elegant way of branching on whether a triple exists for which the function on the current string evaluates to <code>true</code> (bailing out if not), and then just asking for the smallest such triple (lexicographic order should work and is a total order so \"smallest\" is obviously well-defined, due to the existance of a global minimum (natural numbers!)).</p>\n<p>I know that's not really how Lean4 is supposed to be programmed with, but as I understand it, tactics are very much fair game for deriving a modified implementation that solves a related but different task, like automatic differentiation or here, using a region membership indicator function as input to derive a minimum/extremum search function.</p>\n<p>In a way I think of this approach as a sort of \"semantic macro\" that relates the desired function's behavior to an input function's behavior. Critically, without <em>necessarily</em> providing an implementation of the desired function.</p>\n<p>Should be very powerful when talking about abstract implementations, and attempting to reason about the correctness of any particular concrete implementation.</p>\n<p>Like, for example here, the concrete implementation of doing exponential search on first all members of the triple together, then binary search on the members individually. I'd love having Lean4 tell me that this would indeed deliver the smallest such triple.</p>\n</div></div>\n<p>Oh, and yes, of course, I'm aware that AoC is just an exercise.<br>\nBut last year it has shown itself to be a good exercise for me learning applied Futhark on AoC 2022. E.g., I managed to write an implementation for <a href=\"https://adventofcode.com/2022/day/5\">AoC 2022 Day5: crate stacker</a> that processes the lines in parallel. Not because that's a good approach here, but because a language targeting GPUs and GPU-like processors is to be used for parallel implementations, so I ought to learn how to write parallel code even when it's not easy to.</p>",
        "id": 417244289,
        "sender_full_name": "namibj",
        "timestamp": 1705934680
    }
]