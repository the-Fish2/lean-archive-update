[
    {
        "content": "<p>I would like to define a \"dependent\" notation for defining a functor <code>Σ_</code> that would output the functor <code>Over.map : Over I ⥤ Over J</code> or <code>Over.forget : Over I ⥤ C</code> depending on the input being an arrow <code>f : I ⟶ J</code> in <code>C</code> or just an object <code>I</code> in <code>C</code>. </p>\n<p>Is this even possible?</p>\n<p>The following is a mwe which does not work, but shows our thinking process. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Comma</span><span class=\"bp\">.</span><span class=\"n\">Over</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Category</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">ObjOrMor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ObjOrMor</span><span class=\"w\"> </span><span class=\"n\">C</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mor</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ObjOrMor</span><span class=\"w\"> </span><span class=\"n\">C</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">forgetOrMap</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ObjOrMor</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">Π</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Over</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">Π</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Over</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">Over</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Over</span><span class=\"bp\">.</span><span class=\"n\">forget</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mor</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Over</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- set_option quotPrecheck false</span>\n<span class=\"c1\">-- scoped notation \"Σ_\" =&gt; fun (x : ObjOrMor C) =&gt; match x with</span>\n<span class=\"c1\">--   | .obj I =&gt; (Over.forget I)</span>\n<span class=\"c1\">--   | .mor f =&gt; (Over.map f)</span>\n</code></pre></div>",
        "id": 446279095,
        "sender_full_name": "Sina H 𓃵",
        "timestamp": 1719067556
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"420917\">Sina H 𓃵</span> has marked this topic as resolved.</p>",
        "id": 446280034,
        "sender_full_name": "Notification Bot",
        "timestamp": 1719068252
    },
    {
        "content": "<p>We found the answer:  Lean already knows how to do this! </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"kn\">prefix</span><span class=\"o\">:</span><span class=\"mi\">70</span><span class=\"w\"> </span><span class=\"s2\">\" Σ_ \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Over</span><span class=\"bp\">.</span><span class=\"n\">map</span>\n\n<span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"kn\">prefix</span><span class=\"o\">:</span><span class=\"mi\">70</span><span class=\"w\"> </span><span class=\"s2\">\" Σ_ \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Over</span><span class=\"bp\">.</span><span class=\"n\">forget</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">}</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">Σ_</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">Σ_</span><span class=\"w\"> </span><span class=\"n\">I</span>\n\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 446280053,
        "sender_full_name": "Sina H 𓃵",
        "timestamp": 1719068279
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"420917\">Sina H 𓃵</span> has marked this topic as unresolved.</p>",
        "id": 446280157,
        "sender_full_name": "Notification Bot",
        "timestamp": 1719068360
    },
    {
        "content": "<p>If someone can comment on it, we are still interested to know the mechanism by which Lean can infer which notation it should use based on the type of the argument.</p>",
        "id": 446280257,
        "sender_full_name": "Sina H 𓃵",
        "timestamp": 1719068406
    },
    {
        "content": "<p>i think the mechanism is \"whichever produces compiling code first\"? i could quite possibly be wrong though.</p>",
        "id": 446281896,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1719068934
    },
    {
        "content": "<p>The \"right\" way to do this is to write an elaborator that matches against the type of the term being applied to the function. This way you wold have explicit control over everything.</p>",
        "id": 446283299,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1719069475
    },
    {
        "content": "<p>But if you can say what you want to use this for, that would be helpful (e.g. if you can assume that <code>C</code> has a terminal object, then you can just work with <code>Over.map</code> in both cases by identifying objects with morphisms to the terminal object; for categories with no terminal object you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.WithTerminal#doc\">docs#CategoryTheory.WithTerminal</a> )</p>",
        "id": 446284890,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1719069968
    },
    {
        "content": "<p>In <br>\n<a href=\"https://github.com/sinhp/Poly/blob/ecc17a377b121c50da0eb0411643e212b165b797/Poly/Polynomial.lean#L69C1-L71C33\">Polynomial Functor Formalization</a>, <br>\nI have defined polynomial functors as follows: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">functor</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">O</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MvPoly</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">O</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Over</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">Over</span><span class=\"w\"> </span><span class=\"n\">O</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Δ_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">Π_</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"bp\">Σ_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">t</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I want to use <code>Δ , Π, Σ</code> consistently  to prove things about them. I now write <code>Σ_ f</code>  for the functor <code>Over.map (f : J ⟶ I)</code> and  <code>Σ_ I</code> for the functor  <code>Over.forget I</code> which is isomorphic  to <code>Over.map (terminal.from I) ⋙ equivOverTerminal.inverse</code>. The</p>",
        "id": 446286621,
        "sender_full_name": "Sina H 𓃵",
        "timestamp": 1719070734
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/.22case.20split.22.20for.20notation.2Fmacro.3F/near/446283299\">said</a>:</p>\n<blockquote>\n<p>The \"right\" way to do this is to write an elaborator that matches against the type of the term being applied to the function. This way you wold have explicit control over everything.</p>\n</blockquote>\n<p>i have no idea how to do this, but this sounds right. Is there something similar in mathlib I can hack?</p>",
        "id": 446286875,
        "sender_full_name": "Sina H 𓃵",
        "timestamp": 1719070880
    },
    {
        "content": "<p>I can sketch a quick example of such an elaborator. I’m not sure if we have a good example in mathlib.</p>",
        "id": 446287922,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1719071469
    },
    {
        "content": "<p>If you’re proving things about these functors, then I do think working with <code>Over.map</code> consistently might make your life easier. For one, it would help avoid duplication. If you always have to prove things twice, once for objects and once for morphisms, it could get tedious</p>",
        "id": 446288308,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1719071671
    },
    {
        "content": "<p>that would be helpful! Even if not using such things in this project, I think it's useful to know how such an elaborator might look like. </p>\n<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/.22case.20split.22.20for.20notation.2Fmacro.3F/near/446287922\">said</a>:</p>\n<blockquote>\n<p>I can sketch a quick example of such an elaborator. I’m not sure if we have a good example in mathlib.</p>\n</blockquote>",
        "id": 446288865,
        "sender_full_name": "Sina H 𓃵",
        "timestamp": 1719072014
    },
    {
        "content": "<p>Here's a small example (the names are not meant to be suggestive in any way):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Over</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"c1\">-- just as an example.</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Over.forget</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Over</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Prod.fst</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Over.map</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Over</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Over</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Meta</span>\n<span class=\"n\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"Σ_ \"</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Term.elabTerm</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">tp</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Meta.inferType</span><span class=\"w\"> </span><span class=\"n\">t</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">tp</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``Over</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``Over.map</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">sort</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Meta.inferType</span><span class=\"w\"> </span><span class=\"n\">tp</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"ERROR\"</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``Over.forget</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"n\">tp</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Over</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span><span class=\"w\"> </span><span class=\"bp\">Σ</span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"k\">#check</span><span class=\"w\"> </span><span class=\"bp\">Σ</span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>",
        "id": 446289200,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1719072170
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/.22case.20split.22.20for.20notation.2Fmacro.3F/near/446288308\">said</a>:</p>\n<blockquote>\n<p>If you’re proving things about these functors, then I do think working with <code>Over.map</code> consistently might make your life easier. For one, it would help avoid duplication. If you always have to prove things twice, once for objects and once for morphisms, it could get tedious</p>\n</blockquote>\n<p>So far, I've been using stuff in mathlib about <code>Over.map</code> and <code>Over.forget</code> and the API support of the latter has been sufficient so that I could avoid using the equivalence of categories</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">equivOverTerminal</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasTerminal</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">≌</span><span class=\"w\"> </span><span class=\"n\">Over</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊤_</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 446289725,
        "sender_full_name": "Sina H 𓃵",
        "timestamp": 1719072432
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/.22case.20split.22.20for.20notation.2Fmacro.3F/near/446281896\">said</a>:</p>\n<blockquote>\n<p>i think the mechanism is \"whichever produces compiling code first\"? i could quite possibly be wrong though.</p>\n</blockquote>\n<p>It's \"elaborate both fully, and see which one succeed, but if both succeeded raise an \"ambiguous notation\" error\"</p>",
        "id": 446299327,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1719077156
    }
]