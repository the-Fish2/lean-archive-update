[
    {
        "content": "<p>Aesop has a feature where you can supply custom rules via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Aesop.TacGen#doc\">docs#Aesop.TacGen</a> (<a href=\"https://github.com/leanprover-community/aesop/blob/master/AesopTest/TacGen.lean\">example</a>) added by <span class=\"user-mention\" data-user-id=\"584504\">@Kaiyu Yang</span>.  It lets you add rules which are given in text form, making it useful for using AI models to suggest next steps.  But there isn't an easy way to pass information forward so that at the next goal, my tactic prediction function can see information from a previous TacGen call.  <em>Is there a way to put information in a goal?</em></p>\n<p>One coarse way is to add information to the goal is by using <code>let ___myvar___ := my_data</code>.  I'm wondering if there is any cleaner approaches.  Maybe hiding information into a hidden local context element or some other useful location linked by the goal metavariable.</p>",
        "id": 421534134,
        "sender_full_name": "Jason Rute",
        "timestamp": 1707945359
    },
    {
        "content": "<p>It is also very possible that if I just look back one step from TacGen, that it might be that Aesop itself has a nice way to do something like this where I don't even have to hide information in the goal.  I'd be more than happy with that.</p>",
        "id": 421534879,
        "sender_full_name": "Jason Rute",
        "timestamp": 1707945663
    },
    {
        "content": "<p>Rather than a <code>let</code>, another way is to wrap the target in some metadata.</p>\n<p>Or, you could add an implementation detail fvar that somehow encodes the data you want to store.</p>",
        "id": 421540820,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707948154
    },
    {
        "content": "<p>the two standard approaches are either using <code>.mdata</code> (like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.mkLHSGoalRaw#src\">src#Lean.mkLHSGoalRaw</a>) or an identity function (like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=optParam#src\">src#optParam</a>). You need an identity function if the data you want to store is or contains Exprs</p>",
        "id": 421571934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707966446
    },
    {
        "content": "<p>Unfortunately all of these approaches suck in different ways when you interact with arbitrary tactics (i.e., you don't control precisely which tactics are applied to your goals):</p>\n<ul>\n<li>There's no guarantee that <code>mdata</code> is preserved by anything. In fact, expressions that differ only in <code>mdata</code> are considered equal by, e.g., caches.</li>\n<li>Custom identity functions may be destroyed by <code>whnf</code> if <code>reducible</code>, or block computation if not.</li>\n<li><code>implDetail</code> hyps (which are hidden local hypotheses) can be turned into regular hyps by <code>revert</code>-based tactics such as <code>subst</code>, so are not guaranteed to remain hidden except if you put them at the top of the local context (but then they can't depend on anything).</li>\n<li>If you store the data externally somehow and it references local hypotheses (fvars), you have to update the <code>FVarIds</code> because tactics may change the <code>FVarId</code> of an fvar even if the fvar has remained \"the same\". Some tactics provide <code>FVarSubst</code>s to do this, but others don't.</li>\n</ul>\n<p>I've been struggling with this issue since Lean 3 and have yet to see a solution that works well for data with fvars. However, if you don't need to reference fvars, then the mentioned solutions should be fine.</p>",
        "id": 421627942,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1707994328
    },
    {
        "content": "<p>Should there be testing to guarantee that mdata is preserved as expected with tactics? Maybe that's wise to do from now on.</p>",
        "id": 421670989,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1708008759
    },
    {
        "content": "<p>There's no such expectation I think; as far as I know, not even core reliably preserves mdata. So it can only be used for heuristic stuff, e.g. pretty-printing (where it's not so important whether the heuristic fires), or when you can precisely control what happens with your expressions.</p>",
        "id": 421687403,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1708012971
    }
]