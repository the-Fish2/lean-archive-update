[
    {
        "content": "<p>My understanding is that Linters are triggered after each declaration.  I want to know if they can see the syntax of the declaration and not only the expressions.  In particular, can a linter see the tactic proofs.  I'm imagining a case, for example, where a linter is set up to gather online proof data about a declaration right after it is declared (for example each goalstate-tactic pair in the proof).  This data can be used for online AI tactics that occur later in the same file.</p>",
        "id": 422233990,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708349770
    },
    {
        "content": "<p>I think that linters can see the syntax, but, depending on the information that you want them to extract from the syntax, you may have to essentially re-parse the file.</p>\n<p>Here is an example of a \"linter\" that prints the current file as many times as there are declarations in the file.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.Lint.Frontend</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"o\">(</span><span class=\"n\">getEnv</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"sd\">/-- This linter shows that linters have access to the each file containing</span>\n<span class=\"sd\">a declaration. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">std_linter</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">Std.Tactic.Lint.printFile</span> <span class=\"o\">:</span> <span class=\"n\">Linter</span> <span class=\"n\">where</span>\n  <span class=\"n\">noErrorsFound</span> <span class=\"o\">:=</span> <span class=\"s2\">\"No declarations in this file.\"</span>\n  <span class=\"n\">errorsFound</span> <span class=\"o\">:=</span> <span class=\"s2\">\"Declarations found.\"</span>\n  <span class=\"n\">test</span> <span class=\"n\">declName</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"s2\">\"Std.Tactic.Lint.printFile\"</span><span class=\"bp\">.</span><span class=\"n\">isPrefixOf</span> <span class=\"n\">declName.toString</span> <span class=\"k\">then</span>\n      <span class=\"n\">return</span> <span class=\"n\">none</span>\n    <span class=\"k\">let</span> <span class=\"n\">currModule</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mainModule</span>\n    <span class=\"k\">let</span> <span class=\"n\">fPath</span> <span class=\"o\">:=</span> <span class=\"n\">Lean.modToFilePath</span> <span class=\"s2\">\"\"</span> <span class=\"n\">currModule</span> <span class=\"s2\">\"lean\"</span>\n    <span class=\"k\">let</span> <span class=\"n\">fPath</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">fPath.toString.drop</span> <span class=\"mi\">1</span><span class=\"o\">⟩</span>\n    <span class=\"n\">return</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"</span><span class=\"se\">\\n\\n</span><span class=\"s2\">{← IO.FS.readFile fPath}\"</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">printThisFile</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">intro</span>\n\n<span class=\"bp\">#</span><span class=\"n\">lint</span>\n</code></pre></div>\n<p>Since the linter runs inside the <code>MetaM</code> monad, it can do quite a bit of processing from the <code>.lean</code> file.</p>",
        "id": 422258401,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708356911
    },
    {
        "content": "<p>So I think you are saying is that I can do this if I relates the Lean file from the beginning.  Obviously not ideal, but good to know.</p>",
        "id": 422259170,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708357180
    },
    {
        "content": "<p>And just to give another example which I think the Mathlib folks would be more interested in, if say one wanted to make a linter to find non-terminal <code>simp</code> tactics would it have to work like this (regarding the whole file)?</p>",
        "id": 422259216,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708357200
    },
    {
        "content": "<p>Also, I guess there is also the issue that a Lean file might not be saved.</p>",
        "id": 422259406,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708357258
    },
    {
        "content": "<p>Yes, I would say that <code>Expr</code> information is \"readily avaiable\", since linters have access to the environment.  However, they also have access to whatever text you actually typed in the file and then they can run anything that <code>MetaM</code> can run.  So, I think that very little is out of scope.</p>",
        "id": 422259419,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708357262
    },
    {
        "content": "<p>Right, if the file is not saved, then what I wrote will not \"see\" it.  I do not know if you can see unsaved changes to a file.</p>",
        "id": 422259586,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708357316
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Can.20linters.20see.20tactic.20proofs.3F/near/422259216\">said</a>:</p>\n<blockquote>\n<p>And just to give another example which I think the Mathlib folks would be more interested in, if say one wanted to make a linter to find non-terminal <code>simp</code> tactics would it have to work like this (regarding the whole file)?</p>\n</blockquote>\n<p>I think that Scott has a repository that computes <em>a lot</em> of information from files, more than you find just in the environment.  I think that his tools give access to Syntax trees, but I have not explored it in detail.</p>",
        "id": 422259891,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708357399
    },
    {
        "content": "<p>Yes, I’ve seen it, but I’m brainstorming ways to use online information found in the same file.</p>",
        "id": 422260310,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708357529
    },
    {
        "content": "<p>This is the repository that I was thinking of: <a href=\"https://github.com/semorrison/lean-training-data\">https://github.com/semorrison/lean-training-data</a></p>",
        "id": 422260321,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708357533
    },
    {
        "content": "<p>I think that this is the usual \"only X can parse X\": you can probably get away with extracting some information quickly, but to \"do it right\", I suspect that you have no alternative but to parse the file.</p>",
        "id": 422260702,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708357673
    },
    {
        "content": "<p>Actually <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MonadFileMap.getFileMap#doc\">docs#Lean.MonadFileMap.getFileMap</a> is interesting.  It seems to access the current file in the editor even with unsaved changes.</p>",
        "id": 422265301,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708358868
    },
    {
        "content": "<p>That link does not work for me and suggests using <a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Data/Position.html#Lean.MonadFileMap.getFileMap\">https://leanprover-community.github.io/mathlib4_docs/Lean/Data/Position.html#Lean.MonadFileMap.getFileMap</a> instead.</p>",
        "id": 422271862,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708360310
    },
    {
        "content": "<p>Fixed</p>",
        "id": 422274243,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708360864
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> There are two linter frameworks, and now that they are both in lean core I can't call them \"lean linters\" and \"std/mathlib linters\" anymore, the replacement terminology is \"syntax linter\" and \"environment linter\". The linter framework used in <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> 's code block is an environment linter, and these do not have access to the syntax of the declaration. If you need the syntax you should be using a syntax linter, these are run automatically after each definition and report warnings directly on the definition (like the unused variables linter), and they are given access to both the syntax of the current command, as well as the info trees generated during elaboration of the command, so you can also cross reference the syntax to any generated expressions.</p>",
        "id": 422590080,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708512555
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Thanks for the clarification!  Do you have an example of a syntax linter, especially one that looks at tactics if it is available?</p>",
        "id": 422594993,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708514297
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/std4/blob/main/Std/Linter/UnreachableTactic.lean\">https://github.com/leanprover/std4/blob/main/Std/Linter/UnreachableTactic.lean</a></p>",
        "id": 422595078,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708514341
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Can CommandElabM access MetaM at the position of a tactic to see the state before the tactic was run?  I can use the info tree to find the goal mvid but I don’t know if I can run getType on that mvId.</p>",
        "id": 422694431,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708544947
    },
    {
        "content": "<p>if you have access to the infotree, you can traverse the tree and obtain the info context as well as the tactic info associated to that particular tactic invocation, then run MetaM using those.</p>",
        "id": 422696202,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1708545664
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.TacticInfo#doc\">docs#Lean.Elab.TacticInfo</a> has both the mvar context before and after the tactic</p>",
        "id": 422696425,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1708545756
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.ContextInfo.runMetaM#doc\">docs#Lean.Elab.ContextInfo.runMetaM</a> should also be useful here.</p>",
        "id": 422697324,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1708546119
    },
    {
        "content": "<p>Thanks!  I think I figured it out.</p>",
        "id": 422699448,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708547058
    },
    {
        "content": "<p>I also found Scott’s <a href=\"https://github.com/semorrison/lean-training-data\">https://github.com/semorrison/lean-training-data</a> helpful.</p>",
        "id": 422699704,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708547172
    },
    {
        "content": "<p>yeah I learned a lot from that repo :) Specifically my answer is essentially based on <a href=\"https://github.com/semorrison/lean-training-data/blob/e0072c48bd926e51c49a8d77667395d57fe076c0/TrainingData/InfoTree/TacticInvocation/Basic.lean#L34\">https://github.com/semorrison/lean-training-data/blob/e0072c48bd926e51c49a8d77667395d57fe076c0/TrainingData/InfoTree/TacticInvocation/Basic.lean#L34</a></p>",
        "id": 422699824,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1708547229
    }
]