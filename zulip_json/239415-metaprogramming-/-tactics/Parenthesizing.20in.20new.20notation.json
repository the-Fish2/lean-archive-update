[
    {
        "content": "<p>Is there any simple way of adjusting parenthesization in notation without going so far as to just write your own delaborator? I've written exactly one of those so far and it was less than trivial, so I'm really hoping there's an option or something I can invoke.</p>\n<p>The specific thing I want is, I've defined the following notations for comonadic <code>extract</code> and <code>extend</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Flipped `extend`. If `extract` is also defined, then if `f : w α → β`,</span>\n<span class=\"sd\">  `&lt;⇑&gt;f` is the lift of `f` along `extract`.`-/</span>\n  <span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">reducible</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">Extend.extend'</span> <span class=\"o\">[</span><span class=\"n\">Extend</span> <span class=\"n\">w</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">w</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">w</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">flip</span> <span class=\"n\">Extend.extend</span>\n\n  <span class=\"c1\">--Fancy notation: ∘ has lower precedence than &lt;$&gt;, =&gt;&gt; and → have higher</span>\n  <span class=\"c1\">--precedence than &lt;$&gt; so that `f→ &lt;$&gt; x` is parsed the only way it makes sense,</span>\n  <span class=\"c1\">--but we also want `x =&gt;&gt; f ∘ g` to be parsed as \"passing `x` to `f ∘ g`\" (which is</span>\n  <span class=\"c1\">--also the only way that makes sense). There's no solution to that precedence</span>\n  <span class=\"c1\">--order, so we specially handle the `f ∘ g` case in the notation.</span>\n\n  <span class=\"kd\">@[</span><span class=\"n\">inherit_doc</span> <span class=\"n\">Extend.extend</span><span class=\"kd\">]</span> <span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">«</span><span class=\"n\">term_</span><span class=\"bp\">=&gt;&gt;</span><span class=\"n\">_</span><span class=\"bp\">»</span><span class=\"o\">)</span>\n    <span class=\"n\">term</span><span class=\"o\">:</span><span class=\"mi\">108</span> <span class=\"s2\">\" =&gt;&gt; \"</span> <span class=\"n\">term</span><span class=\"o\">:</span><span class=\"mi\">109</span> <span class=\"n\">atomic</span><span class=\"o\">(</span><span class=\"s2\">\" ∘ \"</span> <span class=\"n\">term</span><span class=\"o\">:</span><span class=\"mi\">109</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n  <span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">=&gt;&gt;</span> <span class=\"bp\">$</span><span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"n\">Extend.extend</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">=&gt;&gt;</span> <span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"bp\">$</span><span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"n\">Extend.extend</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"bp\">$</span><span class=\"n\">g</span><span class=\"o\">))</span>\n\n  <span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">PrettyPrinter.Delaborator</span> <span class=\"n\">SubExpr</span> <span class=\"k\">in</span>\n  <span class=\"kd\">@[</span><span class=\"n\">delab</span> <span class=\"n\">app.Comonad.Extend.extend</span><span class=\"kd\">]</span>\n  <span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">delabExtend</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span> <span class=\"o\">:=</span> <span class=\"c1\">--...</span>\n\n  <span class=\"kd\">@[</span><span class=\"n\">inherit_doc</span><span class=\"kd\">]</span> <span class=\"kd\">prefix</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"&lt;⇑&gt;\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Extend.extend'</span>\n  <span class=\"kd\">@[</span><span class=\"n\">inherit_doc</span><span class=\"kd\">]</span> <span class=\"kd\">postfix</span><span class=\"o\">:</span><span class=\"mi\">108</span> <span class=\"s2\">\" →\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Extract.extract</span>\n</code></pre></div>\n<p>All well and good. However , all three notations share the complication that they are generally used with functions, and specifically frequently used with anonymous lambdas, producing unaesthetic and often unclear delaborations such as </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">&lt;⇑&gt;</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"c1\">-- Is this `extend' extract` with extract wrapped in a lambda, or `extract &lt;| extend' id `?</span>\n</code></pre></div>\n<p>Of course, the syntax is well defined and with a little thought you can, for example, exclude <code>extract &lt;| extend' id</code> on type grounds, but I'd rather not have to do that -- I'd rather just have the delaborator automatically parenthesize lambdas so the above becomes the unambiguous <code>&lt;⇑&gt;(fun x =&gt; x →)</code>. </p>\n<p>Is there a way I can do this by fiddling with options/attributes/maybe <code>notation3</code> which apparently automatically creates delaborators? Or will I have to write my own delab again?</p>",
        "id": 425749668,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710052782
    },
    {
        "content": "<p>In the pretty printing pipeline, delaborators are not supposed to be responsible for inserting parentheses, and instead it's the parenthesizers.</p>\n<p>There are very few examples parenthesizers, and I've never written one before, but here's one possibility: modify the <code>fun</code> parenthesizer to always insert parentheses around it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">prefix</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">extendStx</span><span class=\"o\">)</span> <span class=\"s2\">\"&lt;⇑&gt;\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">id</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">PrettyPrinter.Parenthesizer</span> <span class=\"n\">Syntax.MonadTraverser</span> <span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">parenthesizer</span> <span class=\"n\">Lean.Parser.Term.fun</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">funParens</span> <span class=\"o\">:</span> <span class=\"n\">Lean.PrettyPrinter.Parenthesizer</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"bp\">←</span> <span class=\"n\">getCur</span>\n  <span class=\"k\">if</span> <span class=\"n\">stx.getKind</span> <span class=\"bp\">!=</span> <span class=\"bp\">``</span><span class=\"n\">Lean.Parser.Term.paren</span> <span class=\"k\">then</span>\n    <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">((</span><span class=\"bp\">$</span><span class=\"o\">(⟨</span><span class=\"n\">stx</span><span class=\"o\">⟩)))</span>\n    <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"o\">:=</span> <span class=\"n\">stx.raw.setInfo</span> <span class=\"o\">(</span><span class=\"n\">SourceInfo.fromRef</span> <span class=\"n\">stx</span><span class=\"o\">)</span>\n    <span class=\"n\">setCur</span> <span class=\"n\">stx</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">&lt;⇑&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n<span class=\"c1\">-- &lt;⇑&gt;(fun x ↦ x + 1) : ℕ → ℕ</span>\n</code></pre></div>\n<p>That leads to more parentheses than necessary, but maybe it's ok for you?</p>\n<p><strong>Edit:</strong> <em>I wrote this wrong. It doesn't go and parenthesize its contents.</em></p>",
        "id": 425788514,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710090589
    },
    {
        "content": "<p>Maybe rather than trying to figure out parenthesizers, it's easiest here to write a delaborator (via an <code>app_unexpander</code>) and insert the parentheses.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Extend</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n\n<span class=\"kd\">prefix</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">extendStx</span><span class=\"o\">)</span> <span class=\"s2\">\"&lt;⇑&gt;\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Extend</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">app_unexpander</span> <span class=\"n\">Extend</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Extend.unexpander</span> <span class=\"o\">:</span> <span class=\"n\">Lean.PrettyPrinter.Unexpander</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">_</span> <span class=\"bp\">$</span><span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">&lt;⇑&gt;</span> <span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">f</span><span class=\"o\">))</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throw</span> <span class=\"o\">()</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">&lt;⇑&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span>\n<span class=\"c1\">-- &lt;⇑&gt;(fun x ↦ x + 2) : ℕ → ℕ</span>\n</code></pre></div>",
        "id": 425789336,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710091353
    },
    {
        "content": "<p>So, I'm trying to figure out parenthesizers after all, but I can't get the debug tools to respond. With the above notation, I can write myself a nice little stable of unit tests, but... </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"kd\">set_option</span> <span class=\"n\">trace.PrettyPrinter.parenthesize</span> <span class=\"n\">true</span>\n    <span class=\"k\">#check</span> <span class=\"n\">wα</span> <span class=\"bp\">=&gt;&gt;</span> <span class=\"n\">f</span>\n    <span class=\"k\">#check</span> <span class=\"n\">wα</span> <span class=\"bp\">=&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">mf</span>\n    <span class=\"k\">#check</span> <span class=\"n\">wα</span> <span class=\"bp\">=&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"bp\">→</span>\n    <span class=\"k\">#check</span> <span class=\"n\">wα</span> <span class=\"bp\">=&gt;&gt;</span> <span class=\"n\">f2</span> <span class=\"bp\">→</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">wβ</span>\n    <span class=\"k\">#check</span> <span class=\"n\">wα</span> <span class=\"bp\">=&gt;&gt;</span> <span class=\"n\">f2</span> <span class=\"bp\">&lt;*&gt;</span> <span class=\"n\">wβ</span>\n    <span class=\"k\">#check</span> <span class=\"n\">wf</span> <span class=\"bp\">&lt;*&gt;</span> <span class=\"n\">wα</span>\n    <span class=\"k\">#check</span> <span class=\"n\">wα</span> <span class=\"bp\">=&gt;&gt;</span> <span class=\"bp\">→</span>\n    <span class=\"k\">#check</span> <span class=\"n\">wα</span> <span class=\"bp\">=&gt;&gt;</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span><span class=\"o\">)</span>\n    <span class=\"k\">#check</span> <span class=\"n\">hf</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span><span class=\"o\">)</span>\n    <span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">∘</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">_</span> <span class=\"bp\">·</span><span class=\"o\">)</span>\n    <span class=\"k\">#check</span> <span class=\"bp\">&lt;⇑&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n    <span class=\"kd\">set_option</span> <span class=\"n\">trace.PrettyPrinter.parenthesize</span> <span class=\"n\">false</span>\n</code></pre></div>\n<p>... none of these actually print any additional messages. And I did check <code>stderr</code>, too.</p>",
        "id": 426044501,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710211454
    },
    {
        "content": "<p>As a side note, to my mild dismay, it seems the thing I'm trying to 'fix' is in fact an intentional design decision. From Parenthesizer.lean:</p>\n<blockquote>\n<p>Note that in case 2, it is also sufficient to parenthesize a <em>parent</em> node as long as the offending parser is still to<br>\nthe right of that node. For example, imagine the tree structure of <code>(f fun x =&gt; x) y</code> without parentheses. We need to<br>\ninsert <em>some</em> parentheses between <code>x</code> and <code>y</code> since the lambda body is parsed with precedence 0, while the identifier<br>\nparser for <code>y</code> has precedence <code>maxPrec</code>. But we need to parenthesize the <code>$</code> node anyway since the precedence of its<br>\nRHS (0) again is smaller than that of <code>y</code>. So it's better to only parenthesize the outer node than ending up with<br>\n<code>(f $ (fun x =&gt; x)) y</code>.</p>\n</blockquote>\n<p>My issue is apparently entirely down to my disagreement with this design decision -- I would prefer all anonymous lambdas to be parenthesized unconditionally, even when not required by precedence rules. In contrast, I don't see the need for the outer parentheses around <code>f ...</code>. Function application is already left-associating anyway and must be in order for currying to be natural: <code>f (fun x =&gt; x) y</code> must be interpreted as <code>(f (fun x =&gt; x)) y</code> if <code>f</code> is to have type <code>('a -&gt; 'a) -&gt; ('b -&gt; ('c))</code>.</p>",
        "id": 426045677,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710212404
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Parenthesizing.20in.20new.20notation/near/425788514\">said</a>:</p>\n<blockquote>\n<p>In the pretty printing pipeline, delaborators are not supposed to be responsible for inserting parentheses, and instead it's the parenthesizers.</p>\n<p>There are very few examples parenthesizers, and I've never written one before, but here's one possibility: modify the <code>fun</code> parenthesizer to always insert parentheses around it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">prefix</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">extendStx</span><span class=\"o\">)</span> <span class=\"s2\">\"&lt;⇑&gt;\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">id</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">PrettyPrinter.Parenthesizer</span> <span class=\"n\">Syntax.MonadTraverser</span> <span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">parenthesizer</span> <span class=\"n\">Lean.Parser.Term.fun</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">funParens</span> <span class=\"o\">:</span> <span class=\"n\">Lean.PrettyPrinter.Parenthesizer</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"bp\">←</span> <span class=\"n\">getCur</span>\n  <span class=\"k\">if</span> <span class=\"n\">stx.getKind</span> <span class=\"bp\">!=</span> <span class=\"bp\">``</span><span class=\"n\">Lean.Parser.Term.paren</span> <span class=\"k\">then</span>\n    <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">((</span><span class=\"bp\">$</span><span class=\"o\">(⟨</span><span class=\"n\">stx</span><span class=\"o\">⟩)))</span>\n    <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"o\">:=</span> <span class=\"n\">stx.raw.setInfo</span> <span class=\"o\">(</span><span class=\"n\">SourceInfo.fromRef</span> <span class=\"n\">stx</span><span class=\"o\">)</span>\n    <span class=\"n\">setCur</span> <span class=\"n\">stx</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">&lt;⇑&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n<span class=\"c1\">-- &lt;⇑&gt;(fun x ↦ x + 1) : ℕ → ℕ</span>\n</code></pre></div>\n<p>That leads to more parentheses than necessary, but maybe it's ok for you?</p>\n<p><strong>Edit:</strong> <em>I wrote this wrong. It doesn't go and parenthesize its contents.</em></p>\n</blockquote>\n<p>So, I started from this and started debugging. Here's what I've got:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">PrettyPrinter.Parenthesizer</span> <span class=\"n\">Syntax.MonadTraverser</span> <span class=\"k\">in</span>\n  <span class=\"kd\">@[</span><span class=\"n\">parenthesizer</span> <span class=\"n\">Lean.Parser.Term.fun</span><span class=\"kd\">]</span>\n  <span class=\"kd\">def</span> <span class=\"n\">funParens</span> <span class=\"o\">:</span> <span class=\"n\">Lean.PrettyPrinter.Parenthesizer</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"bp\">←</span> <span class=\"n\">getCur</span>\n    <span class=\"k\">let</span> <span class=\"n\">parent</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">get</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">stxTrav.parents.back</span>\n    <span class=\"n\">dbg_trace</span> <span class=\"s2\">\"before: {stx}\"</span>\n    <span class=\"n\">dbg_trace</span> <span class=\"s2\">\"children : {format stx.getArgs}\"</span>\n    <span class=\"c1\">-- dbg_trace \"parents: {parents.back}\"</span>\n    <span class=\"k\">if</span> <span class=\"n\">parent.getKind</span> <span class=\"bp\">!=</span> <span class=\"bp\">``</span><span class=\"n\">Lean.Parser.Term.paren</span> <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">((</span><span class=\"bp\">$</span><span class=\"o\">(⟨</span><span class=\"n\">stx</span><span class=\"o\">⟩)))</span>\n      <span class=\"c1\">-- dbg_trace \"after: {stx}\"</span>\n      <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"o\">:=</span> <span class=\"n\">stx.raw.setInfo</span> <span class=\"o\">(</span><span class=\"n\">SourceInfo.fromRef</span> <span class=\"n\">stx</span><span class=\"o\">)</span>\n      <span class=\"n\">setCur</span> <span class=\"n\">stx</span>\n    <span class=\"n\">visitArgs</span> <span class=\"k\">do</span>\n      <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">getCur</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getKind</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"n\">Term.basicFun</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">parenthesizerForKind</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Term.basicFun</span>\n      <span class=\"bp\">|</span> <span class=\"n\">stx</span><span class=\"bp\">@</span><span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">visitToken</span>\n</code></pre></div>\n<p>This <em>almost</em> works -- but, as I think you also ran into in your edit/PS, it doesn't recurse properly, it breaks parenthesization inside its children. I tried <code>term.parenthesizer 0</code> as well, but that didn't seem to work either. Any ideas?</p>",
        "id": 426458194,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710383102
    },
    {
        "content": "<p>-- oh, I just needed to replace <code> `Term.basicFun</code> with the full <code> `Lean.Parser.Term.basicFun</code>.</p>",
        "id": 426462040,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710385903
    },
    {
        "content": "<p>Thanks for the help!</p>",
        "id": 426462099,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710385926
    },
    {
        "content": "<p>Spoke a little too soon, that version <em>also</em> doesn't recurse properly all the time but I didn't notice in my test cases. Here's a working edition, for posterity:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">PrettyPrinter.Parenthesizer</span> <span class=\"n\">Syntax.MonadTraverser</span> <span class=\"k\">in</span>\n  <span class=\"kd\">@[</span><span class=\"n\">parenthesizer</span> <span class=\"n\">Lean.Parser.Term.fun</span><span class=\"kd\">]</span>\n  <span class=\"kd\">def</span> <span class=\"n\">funParens</span> <span class=\"o\">:</span> <span class=\"n\">Lean.PrettyPrinter.Parenthesizer</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">idx</span> <span class=\"bp\">←</span> <span class=\"n\">getIdx</span>\n    <span class=\"n\">visitArgs</span> <span class=\"k\">do</span>\n      <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">getCur</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getKind</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Term.basicFun</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"n\">parenthesizerForKind</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Term.basicFun</span>\n      <span class=\"bp\">|</span> <span class=\"n\">stx</span><span class=\"bp\">@</span><span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"n\">visitToken</span>\n    <span class=\"c1\">-- After visiting the arguments, by the traversal invariant we are now</span>\n    <span class=\"c1\">-- one node to the *left* of the original node, unless we were already</span>\n    <span class=\"c1\">-- at the leftmost child.</span>\n    <span class=\"n\">unless</span> <span class=\"n\">idx</span> <span class=\"bp\">==</span> <span class=\"mi\">0</span> <span class=\"k\">do</span> <span class=\"n\">goRight</span>\n    <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"bp\">←</span> <span class=\"n\">getCur</span>\n    <span class=\"n\">setCur</span> <span class=\"n\">stx</span>\n    <span class=\"k\">let</span> <span class=\"n\">parent</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">get</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">stxTrav.parents.back</span><span class=\"bp\">?</span>\n    <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"bp\">←</span> <span class=\"n\">getCur</span>\n    <span class=\"k\">let</span> <span class=\"n\">isParen</span> <span class=\"o\">:=</span> <span class=\"n\">stx.getKind</span> <span class=\"bp\">==</span> <span class=\"bp\">``</span><span class=\"n\">Lean.Parser.Term.paren</span>\n    <span class=\"k\">let</span> <span class=\"n\">st</span> <span class=\"bp\">←</span> <span class=\"n\">get</span>\n    <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"bp\">←</span>\n      <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">parent</span> <span class=\"o\">:=</span> <span class=\"n\">parent</span><span class=\"bp\">?</span> <span class=\"k\">then</span>\n        <span class=\"k\">if</span> <span class=\"bp\">!</span><span class=\"o\">(</span><span class=\"n\">isParen</span> <span class=\"bp\">||</span> <span class=\"n\">parent.getKind</span> <span class=\"bp\">==</span> <span class=\"bp\">``</span><span class=\"n\">Lean.Parser.Term.paren</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"k\">do</span>\n          <span class=\"k\">let</span> <span class=\"n\">stx'</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">((</span><span class=\"bp\">$</span><span class=\"o\">(⟨</span><span class=\"n\">stx</span><span class=\"o\">⟩)))</span>\n          <span class=\"n\">pure</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">stx'.raw.setInfo</span> <span class=\"o\">(</span><span class=\"n\">SourceInfo.fromRef</span> <span class=\"n\">stx</span><span class=\"o\">)</span>\n        <span class=\"k\">else</span>\n          <span class=\"n\">pure</span> <span class=\"n\">stx</span>\n      <span class=\"k\">else</span>\n        <span class=\"n\">pure</span> <span class=\"n\">stx</span>\n    <span class=\"n\">setCur</span> <span class=\"n\">stx</span>\n    <span class=\"n\">goLeft</span>\n    <span class=\"c1\">-- after parenthesization, this syntax now has max precedence (atomic); adjust state accordingly</span>\n    <span class=\"n\">modify</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">st</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"n\">st</span> <span class=\"k\">with</span> <span class=\"n\">contPrec</span> <span class=\"o\">:=</span> <span class=\"n\">Parser.maxPrec</span><span class=\"o\">,</span> <span class=\"n\">trailPrec</span> <span class=\"o\">:=</span> <span class=\"n\">none</span> <span class=\"o\">})</span>\n</code></pre></div>",
        "id": 427364033,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710745872
    }
]