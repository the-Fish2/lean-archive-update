[
    {
        "content": "<p>Is there a way to make an Aesop tactic rule that participates in <code>DiscrTree</code> filtering, so that it only costs significant time if the goal matches a certain pattern?  As an example, is it possible to make <code>decide</code> fire exactly if the goal looks like <code>a &lt; b</code> where <code>a b : Interval</code> (a computational interval analysis type)?</p>",
        "id": 421679486,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1708010841
    },
    {
        "content": "<p>Yes, see <a href=\"https://github.com/leanprover-community/aesop/blob/e4660fa21444bcfe5c70d37b09cc0517accd8ad7/Aesop/BuiltinRules/Ext.lean#L26\">here</a> for an example that fires on goals of the form <code>_ = _</code> (up to reducible defeq). For your use case, I guess the annotation would be <code>(index := [target (_ : Interval) &lt; (_ : Interval)])</code>.</p>",
        "id": 421688038,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1708013144
    },
    {
        "content": "<p>Perfect, thank you!</p>",
        "id": 421688172,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1708013174
    },
    {
        "content": "<p>You can also do this as a <code>simproc</code>, which would probably be even more efficient. Here's a similar simproc I wrote to run <code>decide</code> on equations of string literals:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.OpenPrivate</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std.Logic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Lean.Meta</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">eq_true_intro</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">True</span> <span class=\"o\">:=</span>\n  <span class=\"n\">propext</span> <span class=\"o\">(</span><span class=\"n\">iff_true_intro</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">eq_false_intro</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">False</span> <span class=\"o\">:=</span>\n  <span class=\"n\">propext</span> <span class=\"o\">(</span><span class=\"n\">iff_false_intro</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"kn\">private</span> <span class=\"n\">preprocessPropToDecide</span> <span class=\"k\">in</span> <span class=\"n\">Lean.Elab.Tactic.evalDecide</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Attempt to decide the proposition `prop`. If `prop` is decidable, return a proof</span>\n<span class=\"sd\">of either `prop` or `¬ prop`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"c1\">-- Inspired by Lean.Elab.Tactic.evalDecide</span>\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">decide</span> <span class=\"o\">(</span><span class=\"n\">prop</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">Sum</span> <span class=\"n\">Expr</span> <span class=\"n\">Expr</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">prop</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">←</span>\n    <span class=\"n\">try</span>\n      <span class=\"n\">preprocessPropToDecide</span> <span class=\"n\">prop</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span>\n    <span class=\"n\">catch</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">return</span> <span class=\"n\">none</span>\n  <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">decInst</span> <span class=\"bp\">←</span> <span class=\"n\">synthInstance</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Decidable</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">app</span> <span class=\"n\">prop</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n    <span class=\"k\">let</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"n\">mkApp2</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Decidable.decide</span> <span class=\"o\">[])</span> <span class=\"n\">prop</span> <span class=\"n\">decInst</span>\n    <span class=\"k\">let</span> <span class=\"n\">r</span> <span class=\"bp\">←</span> <span class=\"n\">whnfD</span> <span class=\"n\">d</span>\n    <span class=\"k\">if</span> <span class=\"n\">r.isConstOf</span> <span class=\"bp\">``</span><span class=\"n\">true</span> <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"n\">rflPrf</span> <span class=\"bp\">←</span> <span class=\"n\">mkEqRefl</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">true</span> <span class=\"o\">[])</span>\n      <span class=\"k\">let</span> <span class=\"n\">prf</span> <span class=\"o\">:=</span> <span class=\"n\">mkApp3</span> <span class=\"o\">(</span><span class=\"n\">Lean.mkConst</span> <span class=\"bp\">``</span><span class=\"n\">of_decide_eq_true</span><span class=\"o\">)</span> <span class=\"n\">prop</span> <span class=\"n\">decInst</span> <span class=\"n\">rflPrf</span>\n      <span class=\"n\">return</span> <span class=\"n\">some</span> <span class=\"bp\">$</span> <span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">prf</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">r.isConstOf</span> <span class=\"bp\">``</span><span class=\"n\">false</span> <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"n\">rflPrf</span> <span class=\"bp\">←</span> <span class=\"n\">mkEqRefl</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">false</span> <span class=\"o\">[])</span>\n      <span class=\"k\">let</span> <span class=\"n\">prf</span> <span class=\"o\">:=</span> <span class=\"n\">mkApp3</span> <span class=\"o\">(</span><span class=\"n\">Lean.mkConst</span> <span class=\"bp\">``</span><span class=\"n\">of_decide_eq_false</span><span class=\"o\">)</span> <span class=\"n\">prop</span> <span class=\"n\">decInst</span> <span class=\"n\">rflPrf</span>\n      <span class=\"n\">return</span> <span class=\"n\">some</span> <span class=\"bp\">$</span> <span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">prf</span>\n  <span class=\"n\">return</span> <span class=\"n\">none</span>\n\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">isStrLitEq</span> <span class=\"o\">(</span><span class=\"n\">prop</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"n\">withNewMCtxDepth</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">stringType</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">String</span> <span class=\"o\">[]</span>\n    <span class=\"k\">let</span> <span class=\"n\">lhs</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVar</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">stringType</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">rhs</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVar</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">stringType</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">pat</span> <span class=\"bp\">←</span> <span class=\"n\">mkEq</span> <span class=\"n\">lhs</span> <span class=\"n\">rhs</span>\n    <span class=\"k\">if</span> <span class=\"bp\">←</span> <span class=\"n\">isDefEq</span> <span class=\"n\">prop</span> <span class=\"n\">pat</span> <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"n\">lhs</span> <span class=\"bp\">←</span> <span class=\"n\">whnfD</span> <span class=\"n\">lhs</span>\n      <span class=\"k\">let</span> <span class=\"n\">rhs</span> <span class=\"bp\">←</span> <span class=\"n\">whnfD</span> <span class=\"n\">rhs</span>\n      <span class=\"n\">return</span> <span class=\"n\">lhs.isStringLit</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">rhs.isStringLit</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">return</span> <span class=\"n\">false</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Lean.Meta</span> <span class=\"k\">in</span>\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Decide equality between string literals.</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">simproc</span> <span class=\"n\">decideStrLitEq</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Eq</span> <span class=\"n\">String</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">prop</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">if</span> <span class=\"bp\">←</span> <span class=\"n\">isStrLitEq</span> <span class=\"n\">prop</span> <span class=\"k\">then</span>\n    <span class=\"k\">match</span> <span class=\"bp\">←</span> <span class=\"n\">decide</span> <span class=\"n\">prop</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">continue</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">propPrf</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">prf</span> <span class=\"o\">:=</span> <span class=\"n\">mkApp2</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">eq_true_intro</span> <span class=\"o\">[])</span> <span class=\"n\">prop</span> <span class=\"n\">propPrf</span>\n      <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">visit</span> <span class=\"o\">{</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">True</span> <span class=\"o\">[],</span> <span class=\"n\">proof</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"n\">prf</span> <span class=\"o\">}</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">notPropPrf</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">prf</span> <span class=\"o\">:=</span> <span class=\"n\">mkApp2</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">eq_false_intro</span> <span class=\"o\">[])</span> <span class=\"n\">prop</span> <span class=\"n\">notPropPrf</span>\n      <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">visit</span> <span class=\"o\">{</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">False</span> <span class=\"o\">[],</span> <span class=\"n\">proof</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"n\">prf</span> <span class=\"o\">}</span>\n  <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">continue</span>\n</code></pre></div>\n</div></div>",
        "id": 421691611,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1708014069
    },
    {
        "content": "<p>This might need a more recent Aesop than is currently in mathlib though.</p>",
        "id": 421691685,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1708014089
    },
    {
        "content": "<p>Hmm, actually I may need something more than this, since I also want to produce nice error messages: if I fail to prove <code>a &lt; b</code> using interval arithmetic I want to report what the intervals were, so that it's more obvious what went wrong.</p>\n<p>Is there some way to report error messages from inside Aesop, if I run a tactic and I know its failure means the rest of the search has to fail?  I think if I fail out of a <a href=\"https://github.com/leanprover-community/aesop/blob/e4660fa21444bcfe5c70d37b09cc0517accd8ad7/Aesop/RuleTac/Basic.lean#L87\"><code>RuleTac</code></a> it'll bury any error message in the search, but possibly there is a way out of that?</p>",
        "id": 421693550,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1708014566
    },
    {
        "content": "<p>No, I'm afraid this is not currently supported. I'll note it down as a feature request.</p>",
        "id": 421694895,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1708014907
    },
    {
        "content": "<p>I may just be doing something that is inappropriate for Aesop, and better for a custom DiscrTree thing.</p>",
        "id": 421695271,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1708014993
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/aesop/pull/109\">aesop#109</a></p>",
        "id": 421695972,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1708015178
    },
    {
        "content": "<p>I don't dislike this request. With another project, I've been exploring how Aesop could be used to build automation that doesn't necessarily close the goal but just makes some progress and then hands the reigns over to the user again. This feature fits nicely into that program.</p>",
        "id": 421696323,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1708015282
    }
]