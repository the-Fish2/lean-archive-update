[
    {
        "content": "<p>After some trouble, I've gotten a fiddly <code>elab_rule</code> for custom notation working, but the resulting type isn't terribly friendly. I'd like to throw <code>dsimp</code> at it at the end to get it into a nicer form; is this vaguely safe, and either way is there a better way of doing it?</p>",
        "id": 430373045,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1711789757
    },
    {
        "content": "<p>If it's just beta reduction that you need, mathlib has a <code>beta% e</code> that tries to beta reduce <code>e</code> on a best-effort basis</p>",
        "id": 430402756,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711816228
    },
    {
        "content": "<p>Thanks! </p>\n<p>By the way, I've been kind of working under the assumption that <code>dsimp</code> is much cheaper than <code>simp</code>, to the point where I can throw in <code>dsimp</code> \"for free\" but <code>simp</code> should be terminal. It occurs me to ask if this is in fact true. ^.^;</p>",
        "id": 430428133,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1711841728
    },
    {
        "content": "<p>I think that <code>dsimp</code> and <code>simp</code> have similar limitation performance-wise, but they use different pools of lemmas.  So, I imagine that the worst case scenarios are very similar for <code>dsimp</code> and <code>simp</code>, but I also think that <em>on average</em> <code>dsimp</code> is faster than <code>simp</code>.</p>\n<p>This is all heuristic and also biased by the fact that <code>dsimp</code> steps can usually be removed in final code, if the following tactic is \"flexible\" enough.</p>",
        "id": 430446624,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711861362
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/.60dsimp.60.20in.20.60elab_rule.60.3F/near/430402756\">said</a>:</p>\n<blockquote>\n<p>If it's just beta reduction that you need, mathlib has a <code>beta% e</code> that tries to beta reduce <code>e</code> on a best-effort basis</p>\n</blockquote>\n<p>Once I've <code>beta%</code>'d an expression, how do I actually update the type signature? <br>\nBy which I mean,  I've written a typeclass general enough to handle dependent functions; it still works with non-dependent functions, but the resulting type signature is unnecessarily messy (has a bunch of constant applications in it). I'm trying to clean it up, but no matter what I do to the expression, the resulting type in the infoview doesn't change.</p>\n<p>Here's a minimal-ish MWE</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Qq</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">assertTypeQ</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ty</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">typE</span> <span class=\"bp\">←</span> <span class=\"n\">checkTypeQ</span> <span class=\"n\">e</span> <span class=\"n\">ty</span>\n  <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">e'</span> <span class=\"o\">:=</span> <span class=\"n\">typE</span> <span class=\"k\">then</span> <span class=\"n\">pure</span> <span class=\"n\">e'</span>\n  <span class=\"k\">else</span> <span class=\"n\">throwError</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"expected type {ty}, got {←inferTypeQ e}\"</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">termBetaRec</span><span class=\"o\">)</span> <span class=\"s2\">\"betaRec% \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span> <span class=\"n\">Meta</span> <span class=\"n\">Core</span> <span class=\"n\">Qq</span> <span class=\"k\">in</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.rawOnError</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"n\">termBetaRec</span><span class=\"o\">,</span> <span class=\"n\">inherit_doc</span> <span class=\"n\">termBetaRec</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabTrace</span> <span class=\"o\">:</span> <span class=\"n\">TermElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">match</span> <span class=\"n\">stx</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">betaRec</span><span class=\"bp\">%</span> <span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"bp\">&lt;|&lt;-</span> <span class=\"n\">elabTerm</span> <span class=\"n\">t</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n      <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">eTy</span><span class=\"bp\">@</span><span class=\"o\">⟨</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">⟩⟩</span> <span class=\"o\">:</span> <span class=\"n\">TypeData</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">inferTypeQ</span> <span class=\"n\">e</span>\n      <span class=\"k\">let</span> <span class=\"n\">βty</span> <span class=\"bp\">←</span> <span class=\"n\">betaReduce</span> <span class=\"n\">T</span>\n      <span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">Elab.debug</span><span class=\"o\">]</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"betaReduce : {←ppExpr βty}\"</span>\n\n      <span class=\"c1\">--This doesn't work</span>\n      <span class=\"k\">let</span> <span class=\"n\">βstx</span> <span class=\"bp\">←</span> <span class=\"n\">βty.toSyntax</span>\n      <span class=\"n\">elabTermEnsuringTypeQ</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">eTy.1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">←`</span><span class=\"o\">((</span><span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">βstx</span><span class=\"o\">)))</span> <span class=\"n\">βty</span>\n\n      <span class=\"c1\">--Neither does this</span>\n      <span class=\"k\">let</span> <span class=\"n\">βty</span> <span class=\"bp\">←</span> <span class=\"n\">assertTypeQ</span> <span class=\"n\">βty</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n      <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"bp\">@</span><span class=\"n\">assertTypeQ</span> <span class=\"n\">u</span> <span class=\"n\">e</span> <span class=\"n\">βty</span> <span class=\"c1\">--; let βty := q(βty)</span>\n      <span class=\"n\">pure</span> <span class=\"n\">q</span><span class=\"o\">((</span><span class=\"bp\">$</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">βty</span><span class=\"o\">))</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">HasCurry</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">ν</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">((</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ν</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- Currying operator. The most generic use is to recursively curry. For instance `f : α × β × γ → δ`</span>\n<span class=\"sd\">   will be turned into `⇃f : α → β → γ → δ`. One can also add instances for other products.</span>\n\n<span class=\"sd\">  (In fact this is essentially a synonym of `HasUncurry`, renamed and given a new notation to avoid</span>\n<span class=\"sd\">  an infinite regress.)-/</span>\n  <span class=\"n\">curry</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}:</span> <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ν</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">σ</span> <span class=\"n\">γ</span> <span class=\"n\">m</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">quotPrecheck</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">inherit_doc</span> <span class=\"n\">HasCurry.curry</span><span class=\"kd\">]</span> <span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"⇃\"</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">arg</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">betaRec</span><span class=\"bp\">%</span> <span class=\"n\">HasCurry.curry</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">hasCurry_NDBase</span>  <span class=\"o\">:</span> <span class=\"n\">HasCurry</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span>  <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">γ</span> <span class=\"n\">a</span> <span class=\"n\">m</span> <span class=\"bp\">↦</span> <span class=\"n\">γ</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">m</span><span class=\"o\">⟩)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨(</span><span class=\"bp\">·</span> <span class=\"o\">⟨</span><span class=\"bp\">·</span><span class=\"o\">,</span> <span class=\"bp\">·</span><span class=\"o\">⟩)⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">hasCurry_NDInduction</span> <span class=\"o\">[</span><span class=\"n\">HasCurry</span> <span class=\"n\">β</span> <span class=\"n\">μ</span> <span class=\"n\">ν</span> <span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">HasCurry</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span>  <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">γ</span> <span class=\"n\">a</span> <span class=\"n\">m</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ν</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">σ</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">·</span><span class=\"o\">⟩)</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"bp\">⇃</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">·</span><span class=\"o\">⟩)⟩</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Elab.debug</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"k\">#check</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"bp\">⇃</span><span class=\"n\">f</span>\n<span class=\"c1\">--fun f =&gt;</span>\n<span class=\"c1\">--  HasCurry.curry</span>\n <span class=\"c1\">--   f : (ℕ × ℕ × ℕ × ℕ → Type u) → (m n n_1 n_2 : ℕ) → (fun x =&gt; (fun x =&gt; (fun a =&gt; Type u) (m, x)) (n, x)) (n_1, n_2)</span>\n<span class=\"c1\">--(could just be ℕ → ℕ → ℕ → ℕ → Type u)</span>\n</code></pre></div>",
        "id": 433192178,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713151247
    },
    {
        "content": "<p>I have also tried <code>beta%</code> in the same place, as well as embedding the code into the <code>term_elab</code> itself:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">inherit_doc</span> <span class=\"n\">HasCurry.curry</span><span class=\"kd\">]</span> <span class=\"n\">syntax</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"⇃\"</span> <span class=\"n\">term</span><span class=\"o\">:</span><span class=\"n\">arg</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span> <span class=\"n\">Meta</span> <span class=\"n\">Core</span> <span class=\"n\">Qq</span> <span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"bp\">«</span><span class=\"n\">term</span><span class=\"bp\">⇃</span><span class=\"n\">_</span><span class=\"bp\">»</span><span class=\"o\">,</span> <span class=\"n\">inherit_doc</span> <span class=\"bp\">«</span><span class=\"n\">term</span><span class=\"bp\">⇃</span><span class=\"n\">_</span><span class=\"bp\">»</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabCurry</span> <span class=\"o\">:</span> <span class=\"n\">TermElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">match</span> <span class=\"n\">stx</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">⇃$</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n        <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"bp\">&lt;|&lt;-</span> <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←``</span><span class=\"o\">(</span><span class=\"n\">HasCurry.curry</span> <span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n        <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">eTy</span><span class=\"bp\">@</span><span class=\"o\">⟨</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">⟩⟩</span> <span class=\"o\">:</span> <span class=\"n\">TypeData</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">inferTypeQ</span> <span class=\"n\">e</span>\n        <span class=\"k\">let</span> <span class=\"n\">βty</span> <span class=\"bp\">←</span> <span class=\"n\">assertTypeQ</span> <span class=\"o\">(</span><span class=\"n\">ty</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"bp\">&lt;|&lt;-</span> <span class=\"n\">betaReduce</span> <span class=\"n\">T</span>\n        <span class=\"c1\">-- let e ← @assertTypeQ u e βty</span>\n        <span class=\"c1\">-- pure q(($e : $βty))</span>\n        <span class=\"k\">let</span> <span class=\"n\">βstx</span> <span class=\"bp\">←</span> <span class=\"n\">βty.toSyntax</span>\n        <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←``</span><span class=\"o\">((</span><span class=\"n\">HasCurry.curry</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">βstx</span><span class=\"o\">)))</span> <span class=\"n\">βty</span>\n</code></pre></div>\n<p>Still no dice.</p>",
        "id": 433192209,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713151279
    },
    {
        "content": "<p>I can sometimes get this to work by inserting a <code>simp_only</code> in the right place, but I'd really rather not do that for a number of reasons, not least of which that <code>by let h := out; simp_only at h; exact h</code> is very clunky and often <em>also</em> shows up in the type signature <em>anyway.</em></p>",
        "id": 433192338,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713151368
    },
    {
        "content": "<p>By gratuitous use of <code>trace[Elab.debug]</code> I can check that the beta reduction on the type is indeed doing what I want it to, but somehow even when I outright transform the output into the syntax for an explicit type ascription of the new desired type, the infoview doesn't update.</p>",
        "id": 433192602,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713151565
    },
    {
        "content": "<p>Type ascriptions only ensure that the type is defeq to the given type, but they don't insert type hints.</p>\n<p>One solution is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.mkExpectedTypeHint#doc\">docs#Lean.Meta.mkExpectedTypeHint</a> to insert a type hint.</p>\n<p>Another is to write <code>(id $e : $βty)</code> to insert the type hint, or <code>@id $βty $e</code>. The idea is that <code>id</code>'s first argument has the type in the form you want it. The <code>mkExpectedTypeHint</code> function uses <code>id</code> in this way. (I didn't test these.)</p>",
        "id": 433195899,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713153951
    },
    {
        "content": "<p>Ah, <code>id</code> seems to work. <del>Does leave an extra <code>id</code> lying around so I'll try <code>mkExpectedTypeHint</code> in a moment.</del> Ah, it doesn't do anything special with the <code>id</code> it uses. That's fine, it's a whole lot less annoying than</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">n_1</span> <span class=\"n\">n2</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">n_1</span><span class=\"o\">,</span> <span class=\"n\">n_2</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Thanks!</p>",
        "id": 433196020,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713154056
    }
]