[
    {
        "content": "<p>What's the preferred way to get a list of all the entries from all modules associated with a persistent env extension? Do I just need to iterate over all modules and use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.PersistentEnvExtension.getModuleEntries#doc\">docs#Lean.PersistentEnvExtension.getModuleEntries</a> or are there some helper functions for this?</p>",
        "id": 429479772,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711389792
    },
    {
        "content": "<p>Do you mean all modules, even if they are not imported by the current file?</p>",
        "id": 429480588,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1711390060
    },
    {
        "content": "<p>no, just the ones that are imported.</p>",
        "id": 429480614,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711390073
    },
    {
        "content": "<p>Actually I may have misunderstood the question. Do you really mean entry and not state?</p>",
        "id": 429480975,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1711390209
    },
    {
        "content": "<p>Because the state is accessible by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.PersistentEnvExtension.getState#doc\">docs#Lean.PersistentEnvExtension.getState</a> and usually contains more information that the entries.</p>",
        "id": 429481139,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1711390261
    },
    {
        "content": "<p>oh yeah I see now. I'm juts misunderstanding what's actually hapenning with the state so I probably have another issue.</p>",
        "id": 429481507,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711390401
    },
    {
        "content": "<p>let me make things more precise. one sec.</p>",
        "id": 429481799,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711390514
    },
    {
        "content": "<p>Here's the situation: I have three files in a project <code>Test/Init.lean</code>, <code>Test/Basic.lean</code> and <code>Test.lean</code> with the following contents:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Test/Init.lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"n\">initialize</span> <span class=\"n\">testAttr</span> <span class=\"o\">:</span> <span class=\"n\">TagAttribute</span> <span class=\"bp\">←</span> <span class=\"n\">registerTagAttribute</span> <span class=\"bp\">`</span><span class=\"n\">test_attr</span> <span class=\"s2\">\"\"</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"foo\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">state</span> <span class=\"o\">:=</span> <span class=\"n\">testAttr.ext.getState</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getEnv</span><span class=\"o\">)</span>\n  <span class=\"n\">return</span> <span class=\"n\">mkNatLit</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">state.toList.length</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Test/Basic.lean</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">Test.Init</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">test_attr</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">foo</span> <span class=\"c1\">-- 1 (as expected)</span>\n</code></pre></div>\n<p>and </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Test.lean</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">Test.Basic</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">foo</span> <span class=\"c1\">-- 0</span>\n</code></pre></div>\n<p>I just want to understand how to get <code>1</code> from <code>foo</code> in <code>Test.lean</code>.</p>",
        "id": 429482831,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711390908
    },
    {
        "content": "<p>now, I can modify the elaborator for <code>foo</code> to pick up <code>a</code> by iterating through the imported modules as indicated in the original question.</p>",
        "id": 429483885,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711391310
    },
    {
        "content": "<p>See <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.TagAttribute.hasTag#doc\">docs#Lean.TagAttribute.hasTag</a>. The state of a tag attribute only stores tagged decls from the current module. Tagged decls from imported modules are stored in one sorted array per module, and to determine whether a decl from a module is tagged, you can do binary search on that module's array. To get the number of tagged decls, you can sum up the sizes of the module arrays.</p>",
        "id": 429484626,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1711391589
    },
    {
        "content": "<p>okay, what's exactly what I was trying to ask in the original question :)</p>",
        "id": 429484706,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711391619
    },
    {
        "content": "<p>is there no way to collect all names of constants which have been tagged without iterating through the modules?</p>",
        "id": 429484796,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711391644
    },
    {
        "content": "<p>Don't think so. It's a bit annoying, but this representation is much more efficient. (In particular, it has zero import overhead.)</p>",
        "id": 429484980,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1711391726
    },
    {
        "content": "<p>yeah, I figured it had to do with efficiency. It's a bit confusing that the env extension in <code>TagAttr</code> is a <code>PersistentEnvExtension</code>, but the state doesn't persist :(</p>",
        "id": 429485149,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711391787
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">TagAttribute</span> <span class=\"n\">where</span>\n  <span class=\"n\">attr</span> <span class=\"o\">:</span> <span class=\"n\">AttributeImpl</span>\n  <span class=\"n\">ext</span>  <span class=\"o\">:</span> <span class=\"n\">PersistentEnvExtension</span> <span class=\"n\">Name</span> <span class=\"n\">Name</span> <span class=\"n\">NameSet</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span>\n</code></pre></div>",
        "id": 429485214,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711391816
    },
    {
        "content": "<p>how do tactics like <code>simp</code> keep track of names of lemmas tagged with <code>simp</code>? Is there some custom env extension used?</p>",
        "id": 429485323,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711391861
    },
    {
        "content": "<p>Yes, <code>simp</code> uses <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.SimpTheorems#doc\">docs#Lean.Meta.SimpTheorems</a> (and now a similar structure for simprocs). There the state of the extension really contains all simp theorems registered in the current or imported modules.</p>",
        "id": 429485798,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1711392056
    },
    {
        "content": "<p>The extension for a tag attribute is still 'persistent' in the sense that its entries are written to the oleans for each module, rather than thrown away after the module has been checked. That's what technically distinguishes a persistent from a non-persistent env extension. How an extension represents its state, including imported entries, is for each extension to determine.</p>",
        "id": 429486217,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1711392224
    },
    {
        "content": "<p>okay, fair enough. So it's really about the implementation of <code>registerTagAttribute</code>, is that right?</p>",
        "id": 429486348,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711392267
    },
    {
        "content": "<p>Yes, that one defines exactly what happens with the entries at import/export and when a decl is tagged.</p>",
        "id": 429486452,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1711392308
    },
    {
        "content": "<p>I see now, the code for <code>addImportedFn</code> in this implementation is <code>addImportedFn   := fun _ _ =&gt; pure {}</code>.</p>",
        "id": 429486604,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711392365
    },
    {
        "content": "<p>This is indeed what prevents you from doing anything here.</p>",
        "id": 429486677,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1711392402
    },
    {
        "content": "<p>Related discussion (though it might not seem so by the name): <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4/topic/Label.20attribute.20improvements.3F\">#lean4 &gt; Label attribute improvements?</a> (Oops, realizing I’m late to this thread. But here it is in case anyone reads the thread later. :) )</p>",
        "id": 431150792,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1712168612
    }
]