[
    {
        "content": "<p>I just proved <a href=\"https://en.wikipedia.org/wiki/Jordan%27s_inequality\">Jordan's inequality</a> by computing derivatives. See <a href=\"https://github.com/YaelDillies/LeanAPAP/commit/a30cfb8c114082d374ca633a5a09f1ec026e88f1\">here</a>. This was way harder than it should.</p>",
        "id": 410568510,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703965712
    },
    {
        "content": "<p>I propose we make a new <code>differentiability</code> tactic which proves goals of the form <code>DifferentiableOn</code>, <code>Differentiable</code>, <code>HasDerivAt</code>, <code>HasDerivWithinAt</code>.</p>",
        "id": 410568634,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703965847
    },
    {
        "content": "<p>Such a tactic is <a href=\"#narrow/stream/287929-mathlib4/topic/.60aesop.60.20vs.20.60solve_by_elim.60.20for.20continuity.20tactic/near/402292090\">already being worked on</a></p>",
        "id": 410568845,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703966073
    },
    {
        "content": "<p>You type too fast, Eric!</p>",
        "id": 410568853,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703966085
    },
    {
        "content": "<p>I am aware of <a href=\"https://github.com/leanprover-community/mathlib4/pull/7892\">#7892</a>. However, I find a few problem with the <code>aesop</code> approach:</p>\n<ul>\n<li>There are still rough edges</li>\n<li>It doesn't support <code>DifferentiableOn</code> at all</li>\n<li>Even if it did, I want more complicated logic than what <code>aesop</code> can provide. Eg I want to be able to call <code>differentiability</code> on <code>Differentiable (fun x ↦ sin x / x)</code> and be left with the goal <code>DifferentiableAt (fun x ↦ sin x / x) 0</code> (or more realistically something like <code>∀ x ∉ {x : ℝ | x ≠ 0}, DifferentiableAt (fun x ↦ sin x / x) x</code>, which is still good enough since it can be further simplified)</li>\n</ul>",
        "id": 410568945,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703966173
    },
    {
        "content": "<p>Namely I would like the tactic to be able to handle domains.</p>",
        "id": 410569002,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703966252
    },
    {
        "content": "<p>See <a href=\"#narrow/stream/287929-mathlib4/topic/continuity.20and.20ContinuousOn/near/402068747\">here</a> for a similar discussion on <code>continuity</code>.</p>",
        "id": 410569367,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1703966533
    },
    {
        "content": "<p>Interesting discussion, but it's disjoint from my concerns.</p>",
        "id": 410570128,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703967309
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20evaluating.20derivatives/near/410568845\">said</a>:</p>\n<blockquote>\n<p>Such a tactic is <a href=\"#narrow/stream/287929-mathlib4/topic/.60aesop.60.20vs.20.60solve_by_elim.60.20for.20continuity.20tactic/near/402292090\">already being worked on</a></p>\n</blockquote>\n<p>As the one apparantly \"working\" on this, I should note that I'm still a beginner and don't know how to make progress from the situation described there :(</p>\n<p>Also it's hard to tell how good the tactic needs to be in order for it to make sense to be included. I don't currently see a straightforward way to make significant improvements. The things Yaël Dillies was asking for would probably require <em>a lot</em> of custom meta-programming, which I'm definitely not able to do.</p>",
        "id": 411598716,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1704632148
    },
    {
        "content": "<p>Since I've written that specification, I noticed a subtlety: <code>f</code> being differentiable on <code>s</code> and on <code>t</code> does <em>not</em> mean that <code>f</code> is differentiable on <code>s union t</code>. This is because differentiability on a set is differentiability <em>within</em> that set, not differentiability at every point of the set (which is the same if the set is open but not in general).</p>",
        "id": 411599469,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704632881
    },
    {
        "content": "<p>I don't really know how to solve that. The core issue is that <code>DifferentiableOn</code> does not respect enough set operations. My best bet is that we would need a new <code>DifferentiableWithinOn s t f</code> predicate which says that the function <code>f</code> is differentiable within a set <code>s</code> at every point of another set <code>t</code>. Then <code>DifferentiableOn s f</code> is the same as <code>DifferentiableWithinOn s s f</code> and we do have <code>DifferentiableWithinOn s t1 f -&gt; DifferentiableWithinOn s t2 f -&gt; DifferentiableWithinOn s (t1 union t2) f</code>.</p>",
        "id": 411599878,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704633358
    },
    {
        "content": "<p>But maybe <span class=\"user-mention silent\" data-user-id=\"210574\">Patrick Massot</span> will tell me this is a terrible idea</p>",
        "id": 411599928,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704633383
    },
    {
        "content": "<p>(can someone move this to <a class=\"stream\" data-stream-id=\"239415\" href=\"/#narrow/stream/239415-metaprogramming-.2F-tactics\">#metaprogramming / tactics</a> ?)</p>",
        "id": 411599961,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704633429
    },
    {
        "content": "<p>My personal opinion is that we should include some version of the <code>differentiability</code> tactic as soon as it's as good as <code>continuity</code>. I think that <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> has also said something to that effect.</p>\n<p>It can still be improved or replaced later. I fear that if we wait for all of these more advanced features, especially if they require changes/additions to the Differentiability API,  the effort may never complete. Having a useful but imperfect tactic might also attract more people to work on improving it.</p>\n<p>Debugging <a href=\"#narrow/stream/287929-mathlib4/topic/.60aesop.60.20vs.20.60solve_by_elim.60.20for.20continuity.20tactic/near/402292090\">the issues I'm currently looking at</a> might make a tactic that's as useful as <code>continuity</code> but I'm a bit stuck at the moment.</p>",
        "id": 411600635,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1704634057
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20evaluating.20derivatives/near/411599961\">said</a>:</p>\n<blockquote>\n<p>(can someone move this to <a class=\"stream\" data-stream-id=\"239415\" href=\"/#narrow/stream/239415-metaprogramming-.2F-tactics\">#metaprogramming / tactics</a> ?)</p>\n</blockquote>\n<p>From which message?</p>",
        "id": 411600725,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704634159
    },
    {
        "content": "<p>Maybe from Patrick's second message?</p>",
        "id": 411604972,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704638462
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> has marked this topic as unresolved.</p>",
        "id": 411659868,
        "sender_full_name": "Notification Bot",
        "timestamp": 1704682276
    },
    {
        "content": "<p>I think the case of having <code>DifferentiableOn</code> involving different sets in the same proof is pretty rare. I would rather have a tactic that works in the common cases than dreaming forever of the ultimate differentiability tactic.</p>",
        "id": 411660246,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1704682514
    },
    {
        "content": "<p>Here's a MWE with a derivative calculation that ought to be automatable, and a use case for said calculation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.SpecialFunctions.Trigonometric.Deriv</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Real</span> <span class=\"n\">Set</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">aux</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">HasDerivWithinAt</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">sin</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">cos</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">interior</span> <span class=\"o\">(</span><span class=\"n\">Ici</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n  <span class=\"o\">((</span><span class=\"n\">hasDerivAt_id</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sub</span> <span class=\"bp\">$</span> <span class=\"n\">hasDerivAt_sin</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hasDerivWithinAt</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">sin_le</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">sin</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">MonotoneOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">sin</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Ici</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">this</span> <span class=\"n\">left_mem_Ici</span> <span class=\"n\">hx</span> <span class=\"n\">hx</span>\n  <span class=\"n\">exact</span> <span class=\"n\">monotoneOn_of_hasDerivWithinAt_nonneg</span> <span class=\"o\">(</span><span class=\"n\">convex_Ici</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Continuous.continuousOn</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span>\n    <span class=\"n\">continuity</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">aux</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">cos_le_one</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 421435246,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707914049
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span>, can <code>fun_prop</code> handle goals containing metavariables? If so, one could use <code>fun_prop</code> to compute the derivative of the function above by doing</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">HasDerivWithinAt</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">sin</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">interior</span> <span class=\"o\">(</span><span class=\"n\">Ici</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fun_prop</span>\n</code></pre></div>",
        "id": 421435595,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707914194
    },
    {
        "content": "<p>Nope <code>fun_prop</code> is not designed to do that.</p>\n<p>I have started porting the <code>fun_trans</code> tactic that will transform <code>deriv fun x =&gt; x - sin x</code> to <code>fun x =&gt; 1 - cos x</code>.</p>",
        "id": 421436135,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707914419
    },
    {
        "content": "<p>What is actually the point of all the <code>HasDeriv</code> variants?</p>",
        "id": 421436469,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707914550
    },
    {
        "content": "<p>In very high generality, the derivative is not unique. In practice, the advantage is that you can use functions <code>f</code>, <code>f'</code>, <code>f''</code> rather than <code>f</code>, <code>deriv f</code>, <code>deriv (deriv f)</code>.</p>",
        "id": 421436767,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707914658
    },
    {
        "content": "<p>The key advantage of <code>HasDeriv</code> is that it combines <code>deriv</code> and <code>Differentiable</code> into a single proposition, so you don't have to do everything twice</p>",
        "id": 421437301,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707914848
    },
    {
        "content": "<p>I see,  now I think about it, in programming it will be useful too. As I can implement a function <code>gradient_descent (f f') (h : HasDeriv f f')</code> and keep everything computable.</p>",
        "id": 421437370,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707914876
    },
    {
        "content": "<p>This is similar to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasSum#doc\">docs#HasSum</a></p>",
        "id": 421437483,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707914906
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/differentiation.20tactic/near/421437301\">said</a>:</p>\n<blockquote>\n<p>The key advantage of <code>HasDeriv</code> is that it combines <code>deriv</code> and <code>Differentiable</code> into a single proposition, so you don't have to do everything twice</p>\n</blockquote>\n<p>Yeah that is what I always thought.It is a crutch and with good automation it might be obsolete.</p>\n<p>Once <code>fun_trans</code> is ported adapting it to <code>HasDeriv</code> will be easy as the proof of differentiability will be sitting somewhere in the simplifier's cache.</p>",
        "id": 421438064,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707915120
    },
    {
        "content": "<blockquote>\n<p>It is a crutch and with good automation it might be obsolete.</p>\n</blockquote>\n<p>Well, even if the human isn't doing everything twice, the automation still has to, as does the type-checker.</p>",
        "id": 421438320,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707915213
    },
    {
        "content": "<p>(It's perhaps worth remembering that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Differentiable#doc\">docs#Differentiable</a> is effectively defined in terms of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasDeriv#doc\">docs#HasDeriv</a> !)</p>",
        "id": 421438709,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707915349
    },
    {
        "content": "<p>Even in human mathematics HasDerivAt comes first. :)</p>",
        "id": 421444621,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707917319
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/differentiation.20tactic/near/421435595\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span>, can <code>fun_prop</code> handle goals containing metavariables? If so, one could use <code>fun_prop</code> to compute the derivative of the function above by doing</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">HasDerivWithinAt</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">sin</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">interior</span> <span class=\"o\">(</span><span class=\"n\">Ici</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fun_prop</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thanks for asking this question :) Previously, I had to deal with unknown data for <code>ContDiff ℝ n? f </code>, so it took only a small tweak to <code>fun_prop</code> and voilà it works. This (<a href=\"https://github.com/leanprover-community/mathlib4/blob/82d9e94805bb463f6a8223a5f08f098570e879af/test/fun_prop_dev.lean#L335\">test file</a>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"o\">((</span><span class=\"kd\">by</span> <span class=\"n\">fun_prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HasDeriv</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>prints </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">HasDeriv</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">dx</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">dx</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">dx</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">dx</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Right now, I tested it only with a spoofed version of <code>HasDeriv</code>. Once mathlib recompiles I will try it with the real stuff.</p>\n<p>PR: <a href=\"https://github.com/leanprover-community/mathlib4/pull/10593\">#10593</a></p>",
        "id": 421658143,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708005322
    },
    {
        "content": "<p>Ahah, that's great!</p>",
        "id": 421661388,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708006307
    },
    {
        "content": "<p>All I can say is thank you to Bhavik for having taught me the power of whining</p>",
        "id": 421661544,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708006338
    },
    {
        "content": "<p>Let me try to put together <code>compute_deriv</code> as a wrapper around <code>fun_prop</code></p>",
        "id": 421662165,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708006487
    },
    {
        "content": "<p>Great, it is working with the actual <code>HasFDerivAt</code>. The ergonomic is not the best as the field <code>𝕜</code> can't be inferred from <code>HasFDerivAt (fun x : ℝ =&gt; x * x) _ a</code>. </p>\n<p>Example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"o\">((</span><span class=\"kd\">by</span> <span class=\"n\">fun_prop</span> <span class=\"o\">(</span><span class=\"n\">disch</span><span class=\"o\">:=</span><span class=\"n\">assumption</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">HasFDerivAt</span> <span class=\"n\">ℝ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>prints horrendous</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">HasFDerivAt</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span>\n  <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">•</span>  <span class=\"n\">ContinuousLinearMap.comp</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"o\">((</span><span class=\"n\">ContinuousLinearMap.mulLeftRight</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">ContinuousLinearMap.id</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">ContinuousLinearMap.id</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">+</span>  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">•</span> <span class=\"n\">ContinuousLinearMap.id</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>  <span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>In SciLean, I have lambda notation for bundled morphisms <code>fun x =&gt;L[ℝ] x + 3•x</code>. Using that the result would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">HasFDerivAt</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span>\n     <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">dx</span> <span class=\"bp\">=&gt;</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"o\">(((</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">dx</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">dx</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span>  <span class=\"bp\">+</span>  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">•</span> <span class=\"n\">dx</span><span class=\"o\">)</span>\n     <span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which is much much nicer. It might be worth considering this for mathlib.</p>",
        "id": 421698447,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708015856
    },
    {
        "content": "<p>Also using simproc it should be easy to allow simplifier to simplify the function body of a bundled morphism and then call <code>fun_prop</code> to reprove the function property.</p>",
        "id": 421698810,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708015967
    },
    {
        "content": "<p>Here's my tactic idea (not yet PRed because <code>fun_prop</code> doesn't handle <code>HasDeriv</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A tactic to compute the derivative of a function. -/</span>\n<span class=\"n\">macro</span> <span class=\"s2\">\"compute_deriv \"</span> <span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"k\">have</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HasDerivAt</span> <span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fun_prop</span> <span class=\"o\">(</span><span class=\"n\">disch</span> <span class=\"o\">:=</span> <span class=\"n\">assumption</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 421729931,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708026934
    },
    {
        "content": "<p>This would not work as it would complain it can't infer the field <code>𝕜</code>. Also, what is <code>x</code>? You use it as a new identifier and also in the statement <code>HasDerivAt $f _ x</code>. Also what would be the use case for this? If a function expects <code>HasDerivAt</code> then you can just call <code>fun_prop</code> directly. I can imagine one would like to transform <code>fderiv 𝕜 f x</code> into the actual derivative and that would require more meta code.</p>",
        "id": 421730653,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708027189
    },
    {
        "content": "<p>A typical use case would be <a href=\"https://github.com/leanprover-community/mathlib4/pull/10525\">#10525</a>, where all I need is some derivative to exist. Then I can massage it into a form where I can show it's positive/nonnegative/whatever.</p>",
        "id": 421731495,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708027462
    },
    {
        "content": "<p>Ohh I understand the <code>have (x) : ... x := </code> syntax now!</p>",
        "id": 421731716,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708027550
    },
    {
        "content": "<p>Today's world is Lean 4's world <span aria-label=\"sunglasses\" class=\"emoji emoji-1f60e\" role=\"img\" title=\"sunglasses\">:sunglasses:</span> (with its fancy new syntax)</p>",
        "id": 421731997,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708027652
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/differentiation.20tactic/near/421731495\">said</a>:</p>\n<blockquote>\n<p>A typical use case would be <a href=\"https://github.com/leanprover-community/mathlib4/pull/10525\">#10525</a>, where all I need is some derivative to exist. Then I can massage it into a form where I can show it's positive/nonnegative/whatever.</p>\n</blockquote>\n<p>I see, but wouldn't you just call this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">refine</span> <span class=\"n\">monotoneOn_of_hasDerivWithinAt_nonneg</span> <span class=\"o\">(</span><span class=\"n\">convex_Icc</span> <span class=\"bp\">..</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"mi\">2</span> <span class=\"bp\">/</span> <span class=\"n\">π</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">cos</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">fun_prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">fun_prop</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"bp\">↦</span> <span class=\"n\">sub_nonneg.2</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n</code></pre></div>",
        "id": 421732701,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708027948
    },
    {
        "content": "<p>Hmm, because I hadn't thought of it. Let me try it again once <code>fun_prop</code> support for <code>HasDerivWithinAt</code> has magically appeared.</p>",
        "id": 421733156,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708028134
    }
]