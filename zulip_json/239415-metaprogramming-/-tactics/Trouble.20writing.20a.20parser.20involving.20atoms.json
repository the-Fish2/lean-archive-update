[
    {
        "content": "<p>I'm trying to define a syntax <code>f ⇑(op) g</code>, which expands to <code>fun x =&gt; op (f x) (g x)</code>. Unfortunately, it seems very difficult to work with atoms in syntax. So far, I've come up with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">liftFun</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">μ</span> <span class=\"bp\">→</span> <span class=\"n\">ν</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ν</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"n\">macro</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">coe_liftFun</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\" ⇑\"</span> <span class=\"n\">op</span><span class=\"o\">:(</span><span class=\"n\">noWs</span> <span class=\"n\">atom</span><span class=\"o\">)</span> <span class=\"n\">g</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">withFreshMacroScope</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">cdot</span> <span class=\"o\">:=</span> <span class=\"n\">Syntax.mkLit</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Term.cdot</span> <span class=\"s2\">\"·\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">oparen</span> <span class=\"o\">:=</span> <span class=\"n\">Syntax.mkLit</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Term.parenLeft</span> <span class=\"s2\">\"(\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">cparen</span> <span class=\"o\">:=</span> <span class=\"n\">Syntax.mkLit</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Term.parenRight</span> <span class=\"s2\">\")\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">opfun</span> <span class=\"o\">:=</span> <span class=\"n\">TSyntax.mk</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Syntax.node5</span> <span class=\"o\">(</span><span class=\"n\">SourceInfo.fromRef</span> <span class=\"n\">op</span><span class=\"o\">)</span> <span class=\"bp\">`</span><span class=\"n\">term</span> <span class=\"n\">oparen</span> <span class=\"n\">cdot</span> <span class=\"n\">op</span> <span class=\"n\">cdot</span> <span class=\"n\">cparen</span>\n  <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"n\">liftFun</span> <span class=\"bp\">$</span><span class=\"n\">opfun</span> <span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"bp\">$</span><span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which at least compiles, but it doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">⇑+</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"c1\">--unexpected token '+'; expected string literal or term</span>\n</code></pre></div>\n<p>Suggestions?</p>",
        "id": 424199198,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1709288413
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"359992\">@Robert Maxton</span> What is <code>atom</code> in your example (in <code>op:(noWs atom)</code>)? That is not a parser/syntax in the Lean core. Could you produce a richer <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 424266076,
        "sender_full_name": "Mac Malone",
        "timestamp": 1709306767
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac Malone</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Trouble.20writing.20a.20parser.20involving.20atoms/near/424266076\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"359992\">Robert Maxton</span> What is <code>atom</code> in your example (in <code>op:(noWs atom)</code>)? That is not a parser/syntax in the Lean core. Could you produce a richer <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Parser/Syntax.html\">Lean.Parser.Syntax.atom</a> ?</p>",
        "id": 424330290,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1709329365
    },
    {
        "content": "<p>There honestly isn't much more MWE I can give, the entire section aside from imports is just</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span> <span class=\"bp\">«</span><span class=\"kd\">notation</span><span class=\"bp\">»</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Parser</span> <span class=\"n\">Syntax</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">liftFun</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">μ</span> <span class=\"bp\">→</span> <span class=\"n\">ν</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ν</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Elab.definition</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"n\">macro</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">coe_liftFun</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\" ⟰\"</span> <span class=\"n\">op</span><span class=\"o\">:(</span><span class=\"n\">noWs</span> <span class=\"n\">atom</span><span class=\"o\">)</span> <span class=\"n\">g</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">withFreshMacroScope</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">cdot</span> <span class=\"o\">:=</span> <span class=\"n\">Syntax.mkLit</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Term.cdot</span> <span class=\"s2\">\"·\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">oparen</span> <span class=\"o\">:=</span> <span class=\"n\">Syntax.mkLit</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Term.parenLeft</span> <span class=\"s2\">\"(\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">cparen</span> <span class=\"o\">:=</span> <span class=\"n\">Syntax.mkLit</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Term.parenRight</span> <span class=\"s2\">\")\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">opfun</span> <span class=\"o\">:=</span> <span class=\"n\">TSyntax.mk</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Syntax.node5</span> <span class=\"o\">(</span><span class=\"n\">SourceInfo.fromRef</span> <span class=\"n\">op</span><span class=\"o\">)</span> <span class=\"bp\">`</span><span class=\"n\">term</span> <span class=\"n\">oparen</span> <span class=\"n\">cdot</span> <span class=\"n\">op</span> <span class=\"n\">cdot</span> <span class=\"n\">cparen</span>\n  <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"n\">liftFun</span> <span class=\"bp\">$</span><span class=\"n\">opfun</span> <span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"bp\">$</span><span class=\"n\">g</span><span class=\"o\">)</span>\n\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">⟰+</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"c1\">--unexpected token '+'; expected string literal</span>\n<span class=\"kd\">end</span> <span class=\"bp\">«</span><span class=\"kd\">notation</span><span class=\"bp\">»</span>\n</code></pre></div>\n<p>I changed from ⇑ to ⟰ to avoid collision with <code>CoeFn</code>; the new error message (which now insists on a string literal specifically) is a hint, I think.</p>",
        "id": 424331044,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1709329763
    },
    {
        "content": "<p>It looks like the definition of <code>atom</code> is <code>strLit</code>, so it would be expecting <code>(λ x =&gt; x) ⟰\"+\" (λ x =&gt; x)</code>.</p>\n<p>I don't think you can get this syntax to work the way you expect it to work. Best I can think of is either have it take a term and then you write something like <code>(λ x =&gt; x) ⟰(·+·) (λ x =&gt; x)</code>, or you define a <code>⟰+</code> type of operator for each operator you want to lift.</p>",
        "id": 424334743,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709331615
    },
    {
        "content": "<p>The issue is that you need to somehow map the token <code>+</code> to the right syntax kind. The <code>Syntax.node5</code> you have won't produce a <code>+</code> node.</p>\n<p>Take a look at this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Lean.MacroM</span> <span class=\"n\">Lean.Syntax</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"k\">#print</span> <span class=\"n\">foo</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">...</span>\n<span class=\"cm\">Lean.Syntax.node3 info `term_+_ (Lean.Syntax.node1 info `num (Lean.Syntax.atom info \"1\"))</span>\n<span class=\"cm\">  (Lean.Syntax.atom info \"+\") (Lean.Syntax.node1 info `num (Lean.Syntax.atom info \"2\"))</span>\n<span class=\"cm\">...</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>The kind happens to be called <code>term_+_</code>, not <code>term</code>. That name is generated by the <code>notation</code> command, and it's not something you're supposed to refer to in user code.</p>",
        "id": 424335057,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709331808
    },
    {
        "content": "<p>I mean, I think that bit is soluble? Worst case I can produce and then parse a string or a quotation or something, I think?</p>\n<p>The bigger issue is that Lean won't even recognize <code>⟰+</code> correctly to begin with; I'd need some way of matching \"a ⟰ followed by any number of any non-whitespace characters followed by a whitespace\", which I was hoping <code>atom</code> would do but apparently not.</p>",
        "id": 424336120,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1709332347
    },
    {
        "content": "<p>Parsing a non-whitespace characters is certainly possible, but before going down that path of constructing a string and then parsing something, do you have an idea of how wide of an array of binary operators you want to support?</p>\n<p>If it's not many, I would go with <code>⟰+</code>, <code>⟰-</code>, <code>⟰*</code>, <code>⟰/</code>, and the others that come up.</p>\n<p>It's also fairly straightforward to make a macro that generates notation, so you can <code>declare_lift_op \"+\"</code>, <code>declare_lift_op \"-\"</code>, etc.</p>",
        "id": 424338338,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709333614
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">liftFun</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">μ</span> <span class=\"bp\">→</span> <span class=\"n\">ν</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ν</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Macro</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"declare_lift_op \"</span> <span class=\"n\">op</span><span class=\"o\">:</span><span class=\"n\">str</span> <span class=\"s2\">\" =&gt; \"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">op'</span> <span class=\"o\">:=</span> <span class=\"n\">Syntax.mkStrLit</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\" ⇑{op.getString} \"</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">notation</span> <span class=\"n\">f</span> <span class=\"bp\">$</span><span class=\"n\">op'</span><span class=\"o\">:</span><span class=\"n\">str</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">liftFun</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n\n<span class=\"n\">declare_lift_op</span> <span class=\"s2\">\"+\"</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"bp\">·</span><span class=\"o\">)</span>\n<span class=\"n\">declare_lift_op</span> <span class=\"s2\">\"-\"</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">-</span> <span class=\"bp\">·</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">φ</span> <span class=\"bp\">⇑+</span> <span class=\"n\">ψ</span>\n<span class=\"c1\">-- liftFun (fun x x_1 ↦ x + x_1) φ ψ : Nat → Int</span>\n</code></pre></div>",
        "id": 424340631,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709334874
    },
    {
        "content": "<p>You could try synthesizing <code>t</code> from the <code>op</code> string by parsing <code>s!\"(· {op.getString} ·)\"</code> but that feels a little hacky to me.</p>",
        "id": 424340845,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709335035
    },
    {
        "content": "<p>With this, if you import <code>Mathlib.Mathport.Notation</code>, switch <code>notation</code> to <code>notation3</code>, and write <code>declare_lift_op \"+\" =&gt; HAdd.hAdd</code>, then <code>φ ⇑+ ψ</code> even pretty prints as <code>φ ⇑+ ψ</code>.</p>",
        "id": 424341076,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709335162
    },
    {
        "content": "<p>Here's another sort of solution:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">liftFun</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">μ</span> <span class=\"bp\">→</span> <span class=\"n\">ν</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ν</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Macro</span>\n\n<span class=\"n\">declare_syntax_cat</span> <span class=\"n\">binop</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"binop(\"</span> <span class=\"n\">binop</span> <span class=\"s2\">\")\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"n\">macro</span> <span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\" ⇑\"</span> <span class=\"n\">op</span><span class=\"o\">:</span><span class=\"n\">binop</span> <span class=\"n\">g</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">liftFun</span> <span class=\"n\">binop</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">op</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"bp\">$</span><span class=\"n\">g</span><span class=\"o\">)</span>\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"+\"</span> <span class=\"o\">:</span> <span class=\"n\">binop</span>\n<span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">binop</span><span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">((</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"bp\">·</span><span class=\"o\">))</span>\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"-\"</span> <span class=\"o\">:</span> <span class=\"n\">binop</span>\n<span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">binop</span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">((</span><span class=\"bp\">·</span> <span class=\"bp\">-</span> <span class=\"bp\">·</span><span class=\"o\">))</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">φ</span> <span class=\"bp\">⇑+</span> <span class=\"n\">ψ</span>\n<span class=\"c1\">-- liftFun (fun x x_1 ↦ x + x_1) φ ψ : Nat → Int</span>\n</code></pre></div>",
        "id": 424357893,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709348424
    },
    {
        "content": "<p>Hmmm... I sort of see. The issue is primarily that it's hard to even talk about the 'atom' part of the syntax in a way Lean will pay attention to. </p>\n<p>Okay, I might end up resorting to one of those options, then. Thanks.</p>",
        "id": 424391364,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1709368871
    },
    {
        "content": "<p>I'm quite sure you can write a <code>Parser</code> that steals an atom off the syntax stack, but this is not something any existing parser does currently</p>",
        "id": 424392765,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709369469
    },
    {
        "content": "<p>it would be somewhat abstraction breaking, e.g. you could pull a <code>(</code> and then what?</p>",
        "id": 424392854,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709369532
    },
    {
        "content": "<p>Mm. Ideally, <code>f ⇑(foo) g</code> would act exactly like you typed <code>liftFun (· (foo) ·) f g</code> for any <code>foo</code>, but of course I see that that wouldn't be covered by my simplistic \"just parse everything until the next whitespace\" spec in the case of parenthesized operators. And of course \"compound atoms\" would be a horrible contradiction in terms on the syntax design level.</p>",
        "id": 424393957,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1709370338
    },
    {
        "content": "<p>By the way, with this approach you can have it parse a term too:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">low</span><span class=\"o\">)</span> <span class=\"n\">term</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"o\">:</span> <span class=\"n\">binop</span>\n<span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">binop</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">t</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">φ</span> <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">/</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"n\">ψ</span>\n</code></pre></div>\n<p>I made that low-priority because there's a source of ambiguity in <code>⇑-</code>, whether the <code>-</code> is the beginning of a negation.</p>",
        "id": 424423518,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709395646
    },
    {
        "content": "<p>And one improvement to the syntax is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\" ⇑\"</span> <span class=\"n\">noWs</span> <span class=\"n\">op</span><span class=\"o\">:</span><span class=\"n\">binop</span> <span class=\"n\">g</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">liftFun</span> <span class=\"n\">binop</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">op</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"bp\">$</span><span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The <code>noWs</code> ensures it can't be used with whitespace after <code>⇑</code>.</p>",
        "id": 424423606,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709395699
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"359992\">Robert Maxton</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Trouble.20writing.20a.20parser.20involving.20atoms/near/424330290\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Parser/Syntax.html\">Lean.Parser.Syntax.atom</a> ?</p>\n</blockquote>\n<p>Oops! I missed that! For future reference, the <code>atom</code> here is the string literal in a <code>syntax</code> vommand. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"s2\">\"foo\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n    <span class=\"c1\">-- ^^^^^ this is an `atom`</span>\n</code></pre></div>",
        "id": 424434496,
        "sender_full_name": "Mac Malone",
        "timestamp": 1709404403
    }
]