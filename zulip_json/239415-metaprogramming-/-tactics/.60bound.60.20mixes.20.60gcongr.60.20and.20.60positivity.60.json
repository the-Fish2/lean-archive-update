[
    {
        "content": "<p>My <code>bound</code> tactic in <a href=\"https://github.com/girving/ray/blob/main/Ray/Tactic/Bound.lean\">https://github.com/girving/ray/blob/main/Ray/Tactic/Bound.lean</a> mixes <code>positivity</code> and <code>gcongr</code>-like behavior.  In practice, this goes in both directions:</p>\n<ol>\n<li><code>0 ≤ a - b</code> follows from <code>b ≤ a</code>, so the <code>positivity</code>-like behavior uses <code>gcongr</code>-like behavior (if <code>a</code> and <code>b</code> are complicated)</li>\n<li>If we use <code>mul_le_mul_of_nonneg_right</code> for <code>gcongr</code>-like behavior, we get a positivity assumption.</li>\n</ol>\n<p>In some cases we go back and forth between the two in the same <code>bound</code> invocation.</p>\n<p>I need to either replace my uses of <code>bound</code> with existing tactics or upstream something like <code>bound</code> if I want to be able to upstream more of <code>ray</code>.  What's the best way to proceed?</p>",
        "id": 412120380,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704885892
    },
    {
        "content": "<p>For the first point, note that I wanted to encode <code>b ≤ a → 0 ≤ a - b</code> as a <code>positivity</code> extension ages ago and it was rejected: <a href=\"https://github.com/leanprover-community/mathlib/pull/16632\">!3#16632</a></p>",
        "id": 412127056,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704888356
    },
    {
        "content": "<p>FWIW I still think we should do it, but maybe by adding a syntax like <code>positivity [h₀, h₁]</code> equivalent to <code>have := h₀; have := h₁; positivity</code> and only letting <code>positivity</code> look through <code>[h₀, h₁]</code> when looking for <code>a ≤ b</code>.</p>",
        "id": 412127501,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704888504
    },
    {
        "content": "<p>Complicated  syntax is not a sufficient solution: I’d like these cases to be handled by a single tactic.  Currently I can just do <code>bound</code> and it switches back and forth adaptively.</p>\n<p>Would upstreaming this tactic be reasonable if the existing tactics don’t want to do it?</p>",
        "id": 412128279,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704888833
    },
    {
        "content": "<p>I must say I don't really understand how this is supposed to be a back and forth.</p>",
        "id": 412128574,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704888956
    },
    {
        "content": "<p>Does your tactic have a well-defined scope?</p>",
        "id": 412128644,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704888977
    },
    {
        "content": "<p>It dispatches inequalities which are true “by structure”, in the sense that they follow via <code>apply_rules</code> (roughly) of a bunch of monotonicity and positivity lemmas that where useful assume that intermediate terms are nonnegative or positive as required.</p>",
        "id": 412129045,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704889148
    },
    {
        "content": "<p>I was initially hoping that this would be replaceable by <code>gcongr</code>, but unfortunately that doesn’t do any positivity.</p>\n<p>Here is an example of where it goes back and forth: <code>0 &lt;= a * c - b * c</code> where <code>c</code> is a manifestly positive expression (exp, say) and the hypotheses include <code>b &lt;= a</code>.</p>",
        "id": 412129310,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704889262
    },
    {
        "content": "<p>The “assume nonnegativity or positivity” is a key part of the scope: it lets us use a bunch of monotonicity lemmas that only work half the time.</p>",
        "id": 412130007,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704889554
    },
    {
        "content": "<p>To clarify, by “assume” I mean it applies an outer lemma that needs positivity of a subterm, then recurses on that positivity goal along with the rest.</p>",
        "id": 412131235,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704890071
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"514145\">Geoffrey Irving</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/.60bound.60.20mixes.20.60gcongr.60.20and.20.60positivity.60/near/412129310\">said</a>:</p>\n<blockquote>\n<p>I was initially hoping that this would be replaceable by <code>gcongr</code>, but unfortunately that doesn’t do any positivity.</p>\n</blockquote>\n<p>What if you make <code>a ≤ b → 0 ≤ a - b</code> a <code>gcongr</code> rule? Then I think everything could stay <code>gcongr</code>.</p>",
        "id": 412136611,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704892154
    },
    {
        "content": "<p><code>gcongr</code> only allows lemmas that look like <code>f x ~ f y</code>.  Positivity lemmas don't look like that.</p>",
        "id": 412136688,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704892188
    },
    {
        "content": "<p>Though if we’re open to removing that restriction and adding a ton of positivity lemmas to <code>gcongr</code> I can send PRs.  I’m not sure how specialized <code>gcongr</code> is for this symmetric case, though.</p>",
        "id": 412137378,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704892457
    },
    {
        "content": "<p>If instead there is a similar desire to keep <code>gcongr</code> scoped, I would love to upstream mine instead.  I think numerical inequalities are an important enough case to have a few different tactics if we can’t easily make a general one.</p>",
        "id": 412138265,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704892814
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span></p>",
        "id": 412140073,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1704893484
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> would you be happy with another tactic, rather than positivity, for proving these inequalities? We already have linarith and nlinarith, but my impression is that nlinarith isn't used much: maybe nlinarith can be extended to do the kind of stuff which you were hoping <code>positivity</code> would do, for example?</p>",
        "id": 412150349,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704896863
    },
    {
        "content": "<p>This isn't very related to <code>linarith</code> or <code>nlinarith</code>: <code>bound</code> does extremely nonlinear things like <code>exp (x + y) &lt; exp (x + z)</code> given <code>y &lt; z</code>.</p>",
        "id": 412150533,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704896922
    },
    {
        "content": "<p>nlinarith is also incredibly slow</p>",
        "id": 412151280,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704897147
    },
    {
        "content": "<p>Yes, the problem is that this <em>could</em> be in scope for <code>positivity</code>, but Mario and Heather are against it. I could write a new tactic <code>yael_positivity</code> which is a copy of <code>positivity</code> + <code>a ≤ b → 0 ≤ a - b</code>. Then there is no scope-creep, but it's a little bit silly.</p>",
        "id": 412152215,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704897445
    },
    {
        "content": "<p>I guess the worry is that it could go exponential</p>",
        "id": 412152922,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704897659
    },
    {
        "content": "<p>Well <code>nlinarith</code> is basically <code>linarith</code> + <code>0 &lt;= x^2</code>, so why not <code>yael_positivity</code>?</p>",
        "id": 412153010,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704897687
    },
    {
        "content": "<p>Does <code>positivity</code> do <code>exp x &lt; exp (x + 1)</code>?  (<code>bound</code> does.)</p>",
        "id": 412153159,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704897724
    },
    {
        "content": "<p>no</p>",
        "id": 412153216,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704897741
    },
    {
        "content": "<p>It seems like there will be a lot of other cases that <code>bound</code> handles that <code>positivity</code> does not.</p>",
        "id": 412153228,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704897746
    },
    {
        "content": "<p>positivity's scope is pretty much <code>0 (≤/&lt;/≠) _</code></p>",
        "id": 412153289,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704897766
    },
    {
        "content": "<p>And my impression from the comments on the PR Yael linked to is that people wanted it to stay that way (which is reasonable: it is a nice well-defined list of goals)</p>",
        "id": 412153374,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704897796
    },
    {
        "content": "<p>It seems reasonable to keep tight scope for <code>positivity</code> and <code>gcongr</code>, but then I really want something like my tactic too. :)</p>",
        "id": 412153584,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704897851
    },
    {
        "content": "<p>I think there is plenty of room for more tactics.</p>",
        "id": 412154694,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704898163
    },
    {
        "content": "<p>If others think this is reasonable, I am happy to clean it up and send a PR.  Some cleanups I need to do are</p>\n<ol>\n<li>Make the <code>bound</code> attribute dynamic in the normal way (currently you have to list all the lemmas prior to the <code>DiscrTree</code> creation, which is silly).</li>\n<li>Move tests into a separate file.</li>\n<li>Optionally, scatter <code>@[bound]</code> around the library instead of declaring them in a list (<a href=\"https://github.com/girving/ray/blob/be960a074f3937102b8be74f24306760f4057e5b/Ray/Tactic/Bound.lean#L96\">https://github.com/girving/ray/blob/be960a074f3937102b8be74f24306760f4057e5b/Ray/Tactic/Bound.lean#L96</a>).  I'm not sure about this one, since there are a few cases where the order is important: <code>sq_nonneg</code> needs to come before <code>pow_nonneg</code>, for example, since the former has fewer hypotheses.  Presumably the initial PR would not do this step, so that it only adds files?</li>\n</ol>",
        "id": 412155925,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704898505
    },
    {
        "content": "<p>But I'll wait for <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> and <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> at a minimum.</p>",
        "id": 412164621,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704900529
    },
    {
        "content": "<p>I'm at a workshop today but will try to circle back tonight.  By the way, have you seen the new <code>grw</code>? <a href=\"https://github.com/leanprover-community/mathlib4/pull/8167\">#8167</a></p>",
        "id": 412165104,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704900633
    },
    {
        "content": "<p>I had not seen <code>grw</code>!  How does the rewriting work if a positivity assumption is required?  E.g., if we have <code>h : x &lt; y</code> and the goal is <code>x * exp z &lt; y * exp z</code>, what happens with <code>grw [h]</code>?</p>",
        "id": 412166325,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704900931
    },
    {
        "content": "<p>It works!</p>",
        "id": 412180286,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704904749
    },
    {
        "content": "<p>Could you maybe provide an example which exhibits the algorithm in your tactic? In the same way that e.g. <code>(a1 + b)^3 * (c ^ 2 + 3) + d1 &lt; (a2 + b)^3 * (c ^ 2 + 3) + d2</code> is a typical <code>gcongr</code> goal.</p>",
        "id": 412183774,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704905962
    },
    {
        "content": "<p>Also: is it a mid-proof tactic (like <code>gcongr</code>) or a finishing tactic?</p>",
        "id": 412183996,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704906019
    },
    {
        "content": "<p>Also, a kind of diagnostic test: what happens if you tag all these lemmas as <code>aesop safe</code>, does <code>aesop</code> solve the goals you have in mind?</p>",
        "id": 412188431,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704907569
    },
    {
        "content": "<p>Here are some examples:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Real.exp</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">Real.exp</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">bound</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x0</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">bound</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xy</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">3</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">bound</span>\n</code></pre></div>",
        "id": 412190062,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704908154
    },
    {
        "content": "<p>It's a finishing tactic as I currently use it (though it would be easy to turn off the <code>failure</code> at the end).</p>",
        "id": 412190276,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704908231
    },
    {
        "content": "<p>My impression is that it would be bad to tag <code>mul_le_mul_of_nonneg_left</code> as aesop safe, because it assumes the thing on the left is nonnegative which is more specialized than <code>aesop</code>.</p>",
        "id": 412190396,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704908281
    },
    {
        "content": "<p>Looks like <code>gcongr</code> can do the first of those examples, but not the other two, so I guess it has some positivity support?</p>",
        "id": 412190692,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704908400
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"514145\">Geoffrey Irving</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/.60bound.60.20mixes.20.60gcongr.60.20and.20.60positivity.60/near/412190396\">said</a>:</p>\n<blockquote>\n<p>My impression is that it would be bad to tag <code>mul_le_mul_of_nonneg_left</code> as aesop safe, because it assumes the thing on the left is nonnegative which is more specialized than <code>aesop</code>.</p>\n</blockquote>\n<p>Sure, <code>gcongr</code> is also \"opinionated\" in this way. But I mean, can you do this as an experiment? Because that would be a possible implementation under the hood.</p>",
        "id": 412190796,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704908432
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"514145\">Geoffrey Irving</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/.60bound.60.20mixes.20.60gcongr.60.20and.20.60positivity.60/near/412190692\">said</a>:</p>\n<blockquote>\n<p>Looks like <code>gcongr</code> can do the first of those examples, so I guess it has some positivity support?</p>\n</blockquote>\n<p>Of course, that's the point!</p>",
        "id": 412190849,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704908459
    },
    {
        "content": "<p>Cool, I'll do the aesop experiment (but probably tomorrow).</p>\n<p>What's the boundary of <code>gcongr</code>'s positivity support?  In particular, it looks like it can't do <code>0 ≤ y - x</code> from <code>x ≤ y</code>.  That and <code>div_le_one_of_le</code> are the prototypical examples.  So if we could make these two work <code>gcongr</code> might be enough:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xy</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span> <span class=\"bp\">-</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">gcongr</span>  <span class=\"c1\">-- fails</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x0</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xy</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">/</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">gcongr</span>  <span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 412191614,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704908786
    },
    {
        "content": "<p><code>gcongr</code>'s positivity support is just what <code>positivity</code> can do: <code>gcongr</code> calls <code>positivity</code> (and in the future other tactics like <code>finiteness</code>) on the subgoals which are structurally \"side goals\".</p>",
        "id": 412194162,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704909817
    },
    {
        "content": "<p>Here are some inequalities I would like to be checked automatically by some tactics (no matter how are they called):</p>\n<ul>\n<li><code>x ≠ 0</code> in the absence of an order (call <code>positivity</code> if there is a partial order, otherwise apply <code>mul_ne_zero</code> etc);</li>\n<li><code>x &lt; 0</code> so that we can prove <code>(-ε) * δ &lt; 0</code> provided that <code>0 &lt; ε</code> and <code>0 &lt; δ</code></li>\n<li><code>0 &lt; ‖x‖</code> from <code>x ≠ 0</code> found by the previous tactic;</li>\n<li><code>x ≤ x + y</code> and <code>x ≤ y + x</code> from <code>0 ≤ y</code>;</li>\n<li><code>x₁ + y₁ + z₁ ≤ y₂ + z₂ + x₂</code> (possibly, with a help from the user);</li>\n<li><code>(a / b) * (c / d) * (b / c) ≤ a / d</code> in <code>ENNReal</code>s without extra assumptions (though this may be too special; naturally appeared a few times in <a href=\"https://github.com/leanprover-community/mathlib4/tree/YK-isO-TVS\">branch#YK-isO-TVS</a>)</li>\n</ul>",
        "id": 412199263,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704912035
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/.60bound.60.20mixes.20.60gcongr.60.20and.20.60positivity.60/near/412199263\">said</a>:</p>\n<blockquote>\n<ul>\n<li><code>x ≤ x + y</code> and <code>x ≤ y + x</code> from <code>0 ≤ y</code>;</li>\n</ul>\n</blockquote>\n<p>This one is simple, but, I think, underappreciated. I have a tactic <code>extra</code> for teaching which does this (it's not yet robust enough for mathlib)</p>",
        "id": 412199576,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704912181
    },
    {
        "content": "<p>eg <a href=\"https://hrmacbeth.github.io/math2001/06_Induction.html#induction-starting-point\">https://hrmacbeth.github.io/math2001/06_Induction.html#induction-starting-point</a></p>",
        "id": 412199910,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704912343
    },
    {
        "content": "<p>^ <code>bound</code> does this one.</p>",
        "id": 412201004,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704912793
    },
    {
        "content": "<p>The point I would want to solve before putting <code>extra</code> in mathlib is that it doesn't solve <code>a &lt; a + b + c</code>, because the rhs is actually <code>(a + b) + c</code>. A good implementation should handle associativity.</p>",
        "id": 412201810,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704913151
    },
    {
        "content": "<p>The general associativity case feels like quite a large jump in complexity, though.  I agree it would be nice, but it seems unlikely to arrive soon or perform similarly.</p>",
        "id": 412202906,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704913532
    },
    {
        "content": "<p>Really? It doesn't seem so hard to me. Parse LHS and RHS as lists, check LHS is a sublist of right, and apply <code>positivity</code> on the terms which appear only on RHS.</p>",
        "id": 412203193,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704913650
    },
    {
        "content": "<p>Generally, you should remove matching terms from LHS and RHS</p>",
        "id": 412203324,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704913694
    },
    {
        "content": "<p>UPD: no, this adds commutativity to the list of requirements.</p>",
        "id": 412203407,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704913737
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> That’s fair!  Though as a continuing aside I am a bit worried about always dispatching to positivity if <code>0 &lt; x - y</code> is deemed out of scope for positivity.</p>",
        "id": 412204505,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704914240
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/.60bound.60.20mixes.20.60gcongr.60.20and.20.60positivity.60/near/412203324\">said</a>:</p>\n<blockquote>\n<p>Generally, you should remove matching terms from LHS and RHS</p>\n</blockquote>\n<blockquote>\n<p>UPD: no, this adds commutativity to the list of requirements.</p>\n</blockquote>\n<p>I've thought about this and I don't have an opinion yet. Commutativity isn't a heavy requirement, but I think enforcing term order (i.e. not having a commutativity-dependent implementation) is probably also fine, because for psychological reasons users are most likely to give arguments preserving term order.</p>",
        "id": 412205481,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704914678
    },
    {
        "content": "<p>Things go from linear to quadratic time if we commute, which is worrisome.  Unless you can hash, of course, but I don’t think defeq works that way.</p>",
        "id": 412205583,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704914731
    },
    {
        "content": "<p>I don't think this is a major concern, it is very rare to be dealing with more than 10 things added together</p>",
        "id": 412207503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704915516
    },
    {
        "content": "<p>I agree, though to some extent that argument also says you handle it (up to 4, say) with a few more lemmas in the list.</p>",
        "id": 412207626,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704915587
    },
    {
        "content": "<p>It’s inelegant, but very simple.</p>",
        "id": 412207704,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704915607
    },
    {
        "content": "<p>what do you mean by \"a few more lemmas in the list\"?</p>",
        "id": 412207873,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704915682
    },
    {
        "content": "<p>positivity isn't a list of lemmas</p>",
        "id": 412207935,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704915708
    },
    {
        "content": "<p>E.g., <code>a &lt; a + b + c</code> can be a lemma.</p>",
        "id": 412207940,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704915711
    },
    {
        "content": "<p>Yes, but <code>bound</code> and <code>gcongr</code> are.</p>",
        "id": 412208024,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704915731
    },
    {
        "content": "<p>gcongr also isn't</p>",
        "id": 412208051,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704915743
    },
    {
        "content": "<p>you can implement them to some extent using <code>apply_rules</code> at the cost of worse performance, but the main reason not to do it this way is so that the result is predictable and there is no backtracking</p>",
        "id": 412208200,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704915810
    },
    {
        "content": "<p>If we ever implement commutativity, then I think that it should be done with <code>gcongr with ?a + ?b and ?b + ?a</code> turning <code>x + y ≤ a + b</code> into <code>x ≤ b</code> and <code>y ≤ a</code>.</p>",
        "id": 412225459,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704923591
    },
    {
        "content": "<p>Also, <code>?!a</code> could mean \"recurse into <code>?a</code></p>",
        "id": 412225497,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704923609
    },
    {
        "content": "<p>I was thinking of the commutativity feature for a different proposed tactic (the \"extra terms\" tactic), not for <code>gcongr</code>.</p>",
        "id": 412225885,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704923773
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> I finally got around to rewriting <code>bound</code> on top of <code>aesop</code>, and it was delightful: it's now much less code (no need to do my own <code>DiscrTree</code> stuff), and is more powerful (since I can take advantage of backtracking for <code>a &lt; max b c</code>, destructProducts, etc.).</p>\n<p>Here's the updated version: <a href=\"https://github.com/girving/ray/blob/main/Ray/Tactic/Bound.lean\">https://github.com/girving/ray/blob/main/Ray/Tactic/Bound.lean</a></p>",
        "id": 420890628,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707658941
    },
    {
        "content": "<p>Does this seem reasonable to submit as a PR?</p>",
        "id": 421132903,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707773426
    },
    {
        "content": "<p>Maybe, at least I would love to give it a try in my projects!</p>",
        "id": 421434290,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707913710
    },
    {
        "content": "<p>Could you try out <code>bound</code> in mathlib-world situations on a mathlib branch?</p>",
        "id": 421434372,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707913739
    },
    {
        "content": "<p>Yep, I’ll make a Mathlib branch.  The branch will include the tests; not sure if that’s sufficient for the latter request.</p>\n<p>Two questions:</p>\n<ol>\n<li>\n<p>Currently I use only <code>norm_num</code> as a closing tactic, but this means <code>bound</code> can’t prove <code>0 &lt; x</code> from <code>1 &lt; x</code>.  I can add <code>linarith</code> as another closing tactic if that seems reasonable, with lower score.</p>\n</li>\n<li>\n<p>Can Aesop use the forward direction of an iff as an apply rule?  If so, I can avoid stating a bunch of lemmas that are just the forward direction of iffs.</p>\n</li>\n</ol>",
        "id": 421435327,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707914086
    },
    {
        "content": "<ol>\n<li>used to work when you were using <code>positivity</code>, right?</li>\n</ol>",
        "id": 421435646,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707914221
    },
    {
        "content": "<p>Yes, positivity will also do it, but that won’t do 1 &lt; x from 2 &lt; x which is also pretty common (or rather, &lt;= versions of that).</p>",
        "id": 421435765,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707914281
    },
    {
        "content": "<p>1 &lt;= x and x &lt;= 1 occur all the time when bounding expressions involving powers.</p>",
        "id": 421435906,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707914327
    },
    {
        "content": "<p>linarith is more complementary to bound, so I’ll go with that (trying norm_num first).</p>",
        "id": 421436824,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707914680
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"514145\">Geoffrey Irving</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/.60bound.60.20mixes.20.60gcongr.60.20and.20.60positivity.60/near/421435327\">said</a>:</p>\n<blockquote>\n<ol start=\"2\">\n<li>Can Aesop use the forward direction of an iff as an apply rule?  If so, I can avoid stating a bunch of lemmas that are just the forward direction of iffs.</li>\n</ol>\n</blockquote>\n<p>Not atm, but this could be added. It would break the nice property that an <code>apply</code> rule is really just the <code>apply</code> tactic, and the current meaning of <code>@[aesop apply]</code> for <code>Iff</code> lemmas would become inexpressible (without adding further UI). So I'm not enthusiastic about this.</p>\n<p>Perhaps a nicer way to support this use case would be to add a command</p>\n<p><code>add_aesop_rules apply [...] [&lt;term&gt;, ...]</code></p>\n<p>where the <code>&lt;term&gt;</code> could be <code>your_lemma.mp</code>. I think I could hack this as a macro, in which case it shouldn't be much work.</p>",
        "id": 421445478,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1707917625
    },
    {
        "content": "<p>Yep, the term version would be excellent.  (Though as a correction it’d usually be .mpr)</p>",
        "id": 421445671,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707917686
    },
    {
        "content": "<p>Actually, you'd have to write <code>λ args, (your_lemma args).mp[r]</code>, which makes it less attractive.</p>",
        "id": 421445799,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1707917726
    },
    {
        "content": "<p>Well, you can do (lemma _ _).mpr.  I think it’s still fine.</p>",
        "id": 421445865,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707917753
    },
    {
        "content": "<p>But for now I’ll keep the explicit definitions, and we can strip them later if this feature appears.</p>",
        "id": 421446061,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707917804
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"514145\">Geoffrey Irving</span> <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/.60bound.60.20mixes.20.60gcongr.60.20and.20.60positivity.60/near/421445865\">said</a>:</p>\n<blockquote>\n<p>Well, you can do (lemma _ _).mpr.</p>\n</blockquote>\n<p>Not with the natural elaboration strategy, which would elaborate <code>(lemma _ _).mpr</code> as a term and fail to fill in the holes by unification. One could do a postprocessing step that lambda-binds postponed mvars (corresponding to the holes), but this is a bit magic and could unintentionally capture other mvars, though the capturing could perhaps be avoided by remembering which mvars correspond to holes. Anyway, it's not entirely trivial.</p>",
        "id": 421447003,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1707918111
    },
    {
        "content": "<p>It would be ideal if the syntax was the same as the “apply” tactic.</p>",
        "id": 421447177,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707918164
    },
    {
        "content": "<p>Ah, one more question: currently I have multiple pairs of “guessing” rules where exactly one of R0 and R1 is expected to work (if bound can work at all).  Currently I specify these as unsafe 50% rules, but this doesn’t reflect the coupling between the two rules.  Is there an alternative that would do this, so that aesop thinks it’s “safe that exactly one will work”?</p>",
        "id": 421448135,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707918483
    },
    {
        "content": "<p>The current way is working beautifully, I should say, I’m just wondering if there’s something more idiomatic that I’m missing.</p>",
        "id": 421448231,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707918506
    },
    {
        "content": "<p>The canonical example is <code>le_max_of_le_{left,right}</code>.</p>",
        "id": 421448346,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707918544
    },
    {
        "content": "<p>I would write a combined rule <code>a ≤ b \\or a ≤ c → a ≤ max b c</code>, which can then be safe (in the context of <code>bound</code>).</p>",
        "id": 421449602,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1707918914
    },
    {
        "content": "<p>Is the splitting on cases then builtin, or do I have to do something to enable it?</p>",
        "id": 421449847,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707918971
    },
    {
        "content": "<p>Issue for the command feature request so I don't forget: <a href=\"https://github.com/leanprover-community/aesop/pull/107\">aesop#107</a></p>",
        "id": 421449904,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1707918988
    },
    {
        "content": "<p>There's a builtin rule that splits on <code>Or</code> hypotheses.</p>",
        "id": 421449957,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1707919007
    },
    {
        "content": "<p>Two PRs:</p>\n<ol>\n<li><del>Two more triangle inequalities which bound knows about:</del> <a href=\"https://github.com/leanprover-community/mathlib4/pull/10561\">https://github.com/leanprover-community/mathlib4/pull/10561</a> (merged)</li>\n<li>The bound tactic: <a href=\"https://github.com/leanprover-community/mathlib4/pull/10562\">https://github.com/leanprover-community/mathlib4/pull/10562</a></li>\n</ol>",
        "id": 421538950,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707947383
    }
]