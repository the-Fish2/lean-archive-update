[
    {
        "content": "<p>I have been playing with some code for commutative algebras and ended up with (so far) something roughly to the effect of (<strong>this is pseudo-code</strong>; I've only kept definitions and statements, omitting proofs):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Algebraic structure typeclass</span>\n\n<span class=\"sd\">/-- A commutative algebra is an algebra (see `Algebra`) in which multiplication is</span>\n<span class=\"sd\">commutative. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">CommAlgebra</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n    <span class=\"kd\">extends</span> <span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- Multiplicative is commutative in a commutative algebra. -/</span>\n  <span class=\"n\">mul_comm</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"k\">in</span>\n<span class=\"sd\">/-- Any commutative algebra is a commutative semiring.</span>\n\n<span class=\"sd\">This is not marked as an instance; it must be manually used. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">toCommSemiring</span> <span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">CommAlgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CommSemiring</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">self</span> <span class=\"k\">with</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"k\">in</span>\n<span class=\"sd\">/-- Creating a commutative algebra from a morphism to a commutative semiring.</span>\n\n<span class=\"sd\">The function `RingHom.toAlgebra` creates an algebra, but in fact the algebra is</span>\n<span class=\"sd\">always a commutative algebra if `A` is a commutative semiring. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">RingHom.toCommAlgebra</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">CommAlgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n  <span class=\"n\">__</span> <span class=\"o\">:=</span> <span class=\"n\">f.toAlgebra</span>\n  <span class=\"n\">mul_comm</span> <span class=\"o\">:=</span> <span class=\"n\">CommSemiring.mul_comm</span>\n\n<span class=\"sd\">/-- A commutative R-algebra structure on a commutative A is equivalent to a ring hom `R →+* A`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">CommAlgebra.equiv_RingHom</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">CommAlgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"bp\">≃</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">toRingHom</span><span class=\"o\">)</span>\n  <span class=\"n\">invFun</span> <span class=\"o\">:=</span> <span class=\"n\">RingHom.toCommAlgebra</span>\n\n<span class=\"c1\">-- Category of commutative algebras</span>\n\n<span class=\"sd\">/-- The category of commutative R-algebras. -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">CommAlgebraCat</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n  <span class=\"n\">isSemiring</span> <span class=\"o\">:</span> <span class=\"n\">Semiring</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n  <span class=\"n\">isCommAlgebra</span> <span class=\"o\">:</span> <span class=\"n\">CommAlgebra</span> <span class=\"n\">R</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Category</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">Hom</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">A</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span>\n  <span class=\"n\">id</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">AlgHom.id</span> <span class=\"n\">R</span> <span class=\"n\">A</span>\n  <span class=\"n\">comp</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">g.comp</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ConcreteCategory</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">forget</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">CommAlgebraCat.carrier</span><span class=\"o\">,</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">toFun</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HasForget₂</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">CommSemiRingCat</span> <span class=\"n\">where</span>\n  <span class=\"n\">forget₂</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">CommSemiRingCat.of</span> <span class=\"bp\">·</span><span class=\"o\">),</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">AlgHom.toRingHom</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- The category of commutative R-algebras is isomorphic to the under-category</span>\n<span class=\"sd\">of R in the category of commutative semirings. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">IsoToUnderCommSemiRing</span> <span class=\"o\">:</span>\n    <span class=\"n\">Cat.of</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">≅</span> <span class=\"n\">Cat.of</span> <span class=\"o\">(</span><span class=\"n\">Under</span> <span class=\"o\">(</span><span class=\"n\">CommSemiRingCat.of</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">toUnder</span> <span class=\"o\">(</span><span class=\"n\">forget₂</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">CommSemiRingCat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">A</span> <span class=\"bp\">↦</span> <span class=\"n\">algebraMap</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"c1\">-- the map from R associated with each object</span>\n    <span class=\"n\">AlgHom.comp_algebraMap</span>    <span class=\"c1\">-- morphisms induce commutative triangles</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">A</span> <span class=\"bp\">↦</span> <span class=\"n\">CommAlgebraCat.of'</span> <span class=\"n\">A.hom.toCommAlgebra</span>\n      <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span>\n        <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">RingHom.congr_fun</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">B.hom</span> <span class=\"bp\">=</span> <span class=\"n\">f.comp</span> <span class=\"n\">A.hom</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- Upgrades when `R` is in fact a `CommRing` rather than a `CommSemiring`</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HasForget₂</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">CommRingCat</span> <span class=\"n\">where</span>\n  <span class=\"n\">forget₂</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">CommRingCat.of</span> <span class=\"bp\">·</span><span class=\"o\">),</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">AlgHom.toRingHom</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- The category of commutative R-algebras is isomorphic to the under-category</span>\n<span class=\"sd\">of R in the category of commutative rings when R is a commutative ring. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">IsoToUnderCommRing</span> <span class=\"o\">:</span>\n    <span class=\"n\">Cat.of</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">≅</span> <span class=\"n\">Cat.of</span> <span class=\"o\">(</span><span class=\"n\">Under</span> <span class=\"o\">(</span><span class=\"n\">CommRingCat.of</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">toUnder</span> <span class=\"o\">(</span><span class=\"n\">forget₂</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">CommSemiRingCat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">A</span> <span class=\"bp\">↦</span> <span class=\"n\">algebraMap</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"c1\">-- the map from R associated with each object</span>\n    <span class=\"n\">AlgHom.comp_algebraMap</span>    <span class=\"c1\">-- morphisms induce commutative triangles</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">A</span> <span class=\"bp\">↦</span> <span class=\"n\">CommAlgebraCat.of'</span> <span class=\"n\">A.hom.toCommAlgebra</span>\n      <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span>\n        <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">RingHom.congr_fun</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">B.hom</span> <span class=\"bp\">=</span> <span class=\"n\">f.comp</span> <span class=\"n\">A.hom</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n<span class=\"c1\">-- Proofs WIP for this last one</span>\n</code></pre></div>\n<p>Since I already have and am adding to the code anyway, is there any interest in putting this / a modified version of this / something similar to this in Mathlib? (I know that <code>CommRingCat</code> already exists and one could just work with <code>Under (CommRingCat.of R)</code>, so I'm not sure if this is wanted.)</p>",
        "id": 412396930,
        "sender_full_name": "Raghuram",
        "timestamp": 1704996870
    },
    {
        "content": "<p>I think <code>CommAlgebraCat</code> would be reasonable; you are not the first person to want this category:</p>\n<p><span class=\"user-mention\" data-user-id=\"118107\">@Amelia Livingston</span> <a href=\"#narrow/stream/116395-maths/topic/Monoidal.20instance.20on.20R-algebras/near/353176645\">said</a>:</p>\n<blockquote>\n<p>I do ultimately need this for <code>CommAlg R</code> (not in mathlib but I have it in a file), yeah. I didn't use <code>Mon_</code> to do this for <code>Algebra R</code> but I'll try using <code>CommMon_</code> for commutative algebras and see if it's easier</p>\n</blockquote>",
        "id": 412397133,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704996970
    },
    {
        "content": "<p>(note that <code>CommAlgebra</code> is <em>not</em> reasonable, it won't work with typeclass search)</p>",
        "id": 412397212,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704997006
    },
    {
        "content": "<p>I believe <span class=\"user-mention\" data-user-id=\"118107\">@Amelia Livingston</span>'s code is public, though I don't remember where and it's possibly for Lean 3</p>",
        "id": 412397287,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704997039
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Category.20of.20Commutative.20Algebras/near/412397133\">said</a>:</p>\n<blockquote>\n<p>I think <code>CommAlgebraCat</code> would be reasonable; you are not the first person to want this category:</p>\n</blockquote>\n<p>I'm sure of that <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span>; I wasn't sure if this way of doing it was desirable.<br>\nI very much don't know how to make design decisions when formalising things in Lean (in the sense of what will lead to less headaches to work with down the line).</p>",
        "id": 412397565,
        "sender_full_name": "Raghuram",
        "timestamp": 1704997158
    },
    {
        "content": "<p>The category <code>CommAlgCat</code> ( <span aria-label=\"cat\" class=\"emoji emoji-1f408\" role=\"img\" title=\"cat\">:cat:</span> ) is certainly something that we want!</p>",
        "id": 412397794,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1704997268
    },
    {
        "content": "<p>I think <code>IsoToUnderCommRing</code> should be stated in terms <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Equivalence#doc\">docs#CategoryTheory.Equivalence</a> instead?</p>",
        "id": 412399459,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1704998020
    },
    {
        "content": "<p>Yes, unless it's a definitional equality</p>",
        "id": 412399509,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1704998041
    },
    {
        "content": "<p>(which it won't be in this case)</p>",
        "id": 412399584,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1704998058
    },
    {
        "content": "<p>I tried to prove it was an isomorphism rather than an equivalence because it seemed like it was, well, an isomorphism rather than just an equivalence.<br>\nBut yeah, I don't know the best practices here.</p>",
        "id": 412400381,
        "sender_full_name": "Raghuram",
        "timestamp": 1704998404
    },
    {
        "content": "<p>Let me try an <code>Equivalence</code> and see if it's easier.</p>",
        "id": 412400410,
        "sender_full_name": "Raghuram",
        "timestamp": 1704998418
    },
    {
        "content": "<p>If the right simp lemmas are set up properly, then providing the equivalence should just be a matter of extracting the two functors you already defined and using the built-in automation to get the proofs \"for free\".</p>",
        "id": 412400623,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1704998519
    },
    {
        "content": "<p>well, I guess you have to provide the data of the natural isomorphism between the identify functors and the compositions, but that should be straightforward.</p>",
        "id": 412400737,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1704998561
    },
    {
        "content": "<p>and in any case, an equivalence is likely to have much better definitional properties</p>",
        "id": 412400819,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1704998590
    },
    {
        "content": "<p>I'm a bit clueless on how to come up with the components of the natural isomorphisms, since the identity and composition are in fact (i.e., mathematically rather than in Lean) equal and the natural transformation the identity map (but I don't know how to formalise that except by showing that they are equal and using <code>eqToHom</code>, which I'm guessing defeats the point, of having good definitional behaviour).</p>",
        "id": 412403878,
        "sender_full_name": "Raghuram",
        "timestamp": 1704999892
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.NatIso.ofComponents#doc\">docs#CategoryTheory.NatIso.ofComponents</a></p>",
        "id": 412404239,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1705000065
    },
    {
        "content": "<p>Thanks! That helps make the equivalence once I get the components.</p>",
        "id": 412404767,
        "sender_full_name": "Raghuram",
        "timestamp": 1705000298
    },
    {
        "content": "<p>If the isomorphisms needed for this natural isomorphism are indeed just \"identities\" then you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Iso.refl#doc\">docs#CategoryTheory.Iso.refl</a> to fill in those components</p>",
        "id": 412406773,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1705001063
    },
    {
        "content": "<p>And again, the automation should get the naturality proofs automatically. If not, then some API might be missing</p>",
        "id": 412406853,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1705001102
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Category.20of.20Commutative.20Algebras/near/412406773\">said</a>:</p>\n<blockquote>\n<p>If the isomorphisms needed for this natural isomorphism are indeed just \"identities\" then you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Iso.refl#doc\">docs#CategoryTheory.Iso.refl</a> to fill in those components</p>\n</blockquote>\n<p>They're morally identities, but the source and target are not definitionally equal (I think; otherwise the isomorphism I was trying to construct before should have been much easier).</p>",
        "id": 412407158,
        "sender_full_name": "Raghuram",
        "timestamp": 1705001236
    },
    {
        "content": "<p>I see, okay, but if the types are the same and the underlying map is indeed the identity, then it may work!</p>",
        "id": 412407223,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1705001271
    },
    {
        "content": "<p>Worth a shot in any case!</p>",
        "id": 412407284,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1705001285
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Category.20of.20Commutative.20Algebras/near/412407284\">said</a>:</p>\n<blockquote>\n<p>Worth a shot in any case!</p>\n</blockquote>\n<p>Didn't work unfortunately</p>",
        "id": 412407433,
        "sender_full_name": "Raghuram",
        "timestamp": 1705001354
    },
    {
        "content": "<p>Let me try to actually extract something readable to send here</p>",
        "id": 412407466,
        "sender_full_name": "Raghuram",
        "timestamp": 1705001364
    },
    {
        "content": "<blockquote>\n<p>They're morally identities</p>\n</blockquote>\n<p>Next you'll be telling us they're canonically isomorphic :-)</p>\n<p>Lean is quite fussy about this sort of thing :-/</p>",
        "id": 412408643,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705001841
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/VQyZUE7GLHWCEMI-DwQEaOuL/Basic.lean\">Basic.lean</a><br>\nAbove file defines <code>CommAlgebra</code> itself.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Basic</span> <span class=\"c1\">-- change accordingly</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Category.AlgebraCat.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span>\n<span class=\"kd\">universe</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- The category of commutative R-algebras. -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">CommAlgebraCat</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n  <span class=\"n\">isSemiring</span> <span class=\"o\">:</span> <span class=\"n\">Semiring</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n  <span class=\"n\">isCommAlgebra</span> <span class=\"o\">:</span> <span class=\"n\">CommAlgebra</span> <span class=\"n\">R</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">CommAlgebraCat.isSemiring</span> <span class=\"n\">CommAlgebraCat.isCommAlgebra</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CommAlgebraCat</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CoeSort</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">CommAlgebraCat.carrier</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">coe</span><span class=\"o\">]</span> <span class=\"n\">CommAlgebraCat.carrier</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">category</span> <span class=\"o\">:</span> <span class=\"n\">Category</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">Hom</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">A</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span>\n  <span class=\"n\">id</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">AlgHom.id</span> <span class=\"n\">R</span> <span class=\"n\">A</span>\n  <span class=\"n\">comp</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">g.comp</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">concreteCategory</span> <span class=\"o\">:</span> <span class=\"n\">ConcreteCategory</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">forget</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">CommAlgebraCat.carrier</span><span class=\"o\">,</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">toFun</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n  <span class=\"n\">forget_faithful</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">AlgHom.coe_fn_inj.mp</span><span class=\"o\">⟩</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">Of</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- The object in the category of commutative R-algebras associated to</span>\n<span class=\"sd\">a type with the structure of a commutative R-algebra. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">of</span> <span class=\"o\">[</span><span class=\"n\">CommAlgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"n\">A</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"k\">in</span>\n<span class=\"sd\">/-- The object in the category of commutative R-algebras associated to</span>\n<span class=\"sd\">a `CommAlgebra R` instance. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">of'</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">CommAlgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span> <span class=\"n\">where</span>\n  <span class=\"n\">isCommAlgebra</span> <span class=\"o\">:=</span> <span class=\"n\">inst</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Of</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">AlgebraicInstances</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">isCommSemiring</span> <span class=\"o\">:</span> <span class=\"n\">CommSemiring</span> <span class=\"n\">self.carrier</span> <span class=\"o\">:=</span>\n  <span class=\"n\">self.isCommAlgebra.toCommSemiring</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">isAlgebra</span> <span class=\"o\">:</span> <span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">self.carrier</span> <span class=\"o\">:=</span>\n  <span class=\"n\">self.isCommAlgebra.toAlgebra</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">AlgebraicInstances</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">hasForgetToCommSemiRing</span> <span class=\"o\">:</span> <span class=\"n\">HasForget₂</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">CommSemiRingCat</span> <span class=\"n\">where</span>\n  <span class=\"n\">forget₂</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">CommSemiRingCat.of</span> <span class=\"bp\">·</span><span class=\"o\">),</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">AlgHom.toRingHom</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- Locally redeclare R as a `CommRing`.</span>\n<span class=\"kn\">section</span> <span class=\"n\">CommRing</span> <span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">isCommRing</span> <span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"n\">self.carrier</span> <span class=\"n\">where</span>\n  <span class=\"n\">__</span> <span class=\"o\">:=</span> <span class=\"n\">Algebra.semiringToRing</span> <span class=\"n\">R</span>\n  <span class=\"n\">__</span> <span class=\"o\">:=</span> <span class=\"n\">self.isCommSemiring</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">hasForgetToCommRing</span> <span class=\"o\">:</span> <span class=\"n\">HasForget₂</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">CommRingCat</span> <span class=\"n\">where</span>\n  <span class=\"n\">forget₂</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">CommRingCat.of</span> <span class=\"bp\">·</span><span class=\"o\">),</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">AlgHom.toRingHom</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">EquivToUnderCommRing</span> <span class=\"o\">:</span>\n    <span class=\"n\">Equivalence</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Under</span> <span class=\"o\">(</span><span class=\"n\">CommRingCat.of</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">functor</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">toUnder</span> <span class=\"o\">(</span><span class=\"n\">forget₂</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">CommRingCat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">A</span> <span class=\"bp\">↦</span> <span class=\"n\">algebraMap</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"c1\">-- the map from R associated with each algebra</span>\n    <span class=\"n\">AlgHom.comp_algebraMap</span>    <span class=\"c1\">-- algebra morphisms induce commutative triangles</span>\n  <span class=\"n\">inverse</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">A</span> <span class=\"bp\">↦</span> <span class=\"n\">CommAlgebraCat.of'</span> <span class=\"n\">A.hom.toCommAlgebra</span>\n      <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span>\n        <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">RingHom.congr_fun</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">B.hom</span> <span class=\"bp\">=</span> <span class=\"n\">f.comp</span> <span class=\"n\">A.hom</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n  <span class=\"n\">unitIso</span> <span class=\"o\">:=</span>\n    <span class=\"n\">NatIso.ofComponents</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">A</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"gr\">sorry</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≅</span> <span class=\"n\">CommAlgebraCat.of'</span> <span class=\"o\">(</span><span class=\"n\">algebraMap</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toCommAlgebra</span><span class=\"o\">))</span>\n  <span class=\"n\">counitIso</span> <span class=\"o\">:=</span>\n    <span class=\"n\">NatIso.ofComponents</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"gr\">sorry</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">let</span> <span class=\"n\">A'</span> <span class=\"o\">:</span> <span class=\"n\">CommAlgebraCat</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat.of'</span> <span class=\"n\">f.toCommAlgebra</span><span class=\"o\">)</span>\n                                  <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">A'</span><span class=\"o\">,</span> <span class=\"n\">algebraMap</span> <span class=\"n\">R</span> <span class=\"n\">A'</span><span class=\"o\">⟩</span>\n                                 <span class=\"bp\">≅</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">⟩))</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">CommRing</span>\n<span class=\"kd\">end</span> <span class=\"n\">CommAlgebraCat</span>\n</code></pre></div>",
        "id": 412408903,
        "sender_full_name": "Raghuram",
        "timestamp": 1705001965
    },
    {
        "content": "<p><code>unknown package 'Basic'</code></p>",
        "id": 412408963,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1705002001
    },
    {
        "content": "<p>Yes, that's a local import, which I attached at the beginning.<br>\nWould it be better to concatenate the two as a message?</p>",
        "id": 412409097,
        "sender_full_name": "Raghuram",
        "timestamp": 1705002058
    },
    {
        "content": "<p>well, first one should take care of the issues Eric pointed out above.</p>",
        "id": 412409317,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1705002158
    },
    {
        "content": "<p>In this case we could just write </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"sd\">/-- The category of commutative R-algebras. -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">CommAlgebraCat</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n  <span class=\"n\">isCommSemiring</span> <span class=\"o\">:</span> <span class=\"n\">CommSemiring</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n  <span class=\"n\">isAlgebra</span> <span class=\"o\">:</span> <span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 412409348,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1705002174
    },
    {
        "content": "<p>I see</p>",
        "id": 412409561,
        "sender_full_name": "Raghuram",
        "timestamp": 1705002268
    },
    {
        "content": "<p>It's much better to have a term of type <code>CommSemiring R</code> than to have a term of type <code>Semiring R</code> and a proof of <code>a * b = b * a</code> kicking around, which you'll constantly have to be upgrading to a <code>CommSemiring</code> in order to use any lemmas about commutative semirings.</p>",
        "id": 412409637,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705002302
    },
    {
        "content": "<p>You could do this for example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">CommAlgebra</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n</code></pre></div>\n<p>but then this makes it clear that <code>CommAlgebra</code> is not adding anything: we \"have it already\". Every definition comes with a cost -- you have to make the API for that definition. So it's best to make no definition if you can avoid making a definition.</p>",
        "id": 412409726,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705002336
    },
    {
        "content": "<p>This <em>should</em> be working code except for the last definition, which has sorry's (and so obviously can't fill in the proofs about them):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Category.AlgebraCat.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span>\n<span class=\"kd\">universe</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- The category of commutative R-algebras. -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">CommAlgebraCat</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n  <span class=\"n\">isCommSemiring</span> <span class=\"o\">:</span> <span class=\"n\">CommSemiring</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n  <span class=\"n\">isAlgebra</span> <span class=\"o\">:</span> <span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">CommAlgebraCat.isCommSemiring</span> <span class=\"n\">CommAlgebraCat.isAlgebra</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CommAlgebraCat</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CoeSort</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">CommAlgebraCat.carrier</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">coe</span><span class=\"o\">]</span> <span class=\"n\">CommAlgebraCat.carrier</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">category</span> <span class=\"o\">:</span> <span class=\"n\">Category</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">Hom</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">A</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span>\n  <span class=\"n\">id</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">AlgHom.id</span> <span class=\"n\">R</span> <span class=\"n\">A</span>\n  <span class=\"n\">comp</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">g.comp</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">concreteCategory</span> <span class=\"o\">:</span> <span class=\"n\">ConcreteCategory</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">forget</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">CommAlgebraCat.carrier</span><span class=\"o\">,</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">toFun</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n  <span class=\"n\">forget_faithful</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">AlgHom.coe_fn_inj.mp</span><span class=\"o\">⟩</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">Of</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- The object in the category of commutative R-algebras associated to</span>\n<span class=\"sd\">a type with the structure of a commutative R-algebra. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">of</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"n\">A</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"k\">in</span>\n<span class=\"sd\">/-- The object in the category of commutative R-algebras associated to</span>\n<span class=\"sd\">a `CommAlgebra R` instance. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">of'</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span> <span class=\"n\">where</span>\n  <span class=\"n\">isAlgebra</span> <span class=\"o\">:=</span> <span class=\"n\">inst</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Of</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">hasForgetToCommSemiRing</span> <span class=\"o\">:</span> <span class=\"n\">HasForget₂</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">CommSemiRingCat</span> <span class=\"n\">where</span>\n  <span class=\"n\">forget₂</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">CommSemiRingCat.of</span> <span class=\"bp\">·</span><span class=\"o\">),</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">AlgHom.toRingHom</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- Locally redeclare R as a `CommRing`.</span>\n<span class=\"kn\">section</span> <span class=\"n\">CommRing</span> <span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">isCommRing</span> <span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"n\">self.carrier</span> <span class=\"n\">where</span>\n  <span class=\"n\">__</span> <span class=\"o\">:=</span> <span class=\"n\">Algebra.semiringToRing</span> <span class=\"n\">R</span>\n  <span class=\"n\">__</span> <span class=\"o\">:=</span> <span class=\"n\">self.isCommSemiring</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">hasForgetToCommRing</span> <span class=\"o\">:</span> <span class=\"n\">HasForget₂</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">CommRingCat</span> <span class=\"n\">where</span>\n  <span class=\"n\">forget₂</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">CommRingCat.of</span> <span class=\"bp\">·</span><span class=\"o\">),</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">AlgHom.toRingHom</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">EquivToUnderCommRing</span> <span class=\"o\">:</span>\n    <span class=\"n\">Equivalence</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Under</span> <span class=\"o\">(</span><span class=\"n\">CommRingCat.of</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">functor</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">toUnder</span> <span class=\"o\">(</span><span class=\"n\">forget₂</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">CommRingCat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">A</span> <span class=\"bp\">↦</span> <span class=\"n\">algebraMap</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"c1\">-- the map from R associated with each algebra</span>\n    <span class=\"n\">AlgHom.comp_algebraMap</span>    <span class=\"c1\">-- algebra morphisms induce commutative triangles</span>\n  <span class=\"n\">inverse</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">A</span> <span class=\"bp\">↦</span> <span class=\"n\">CommAlgebraCat.of'</span> <span class=\"n\">A.hom.toAlgebra</span>\n      <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span>\n        <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">RingHom.congr_fun</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">B.hom</span> <span class=\"bp\">=</span> <span class=\"n\">f.comp</span> <span class=\"n\">A.hom</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n  <span class=\"n\">unitIso</span> <span class=\"o\">:=</span>\n    <span class=\"n\">NatIso.ofComponents</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">A</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"gr\">sorry</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≅</span> <span class=\"n\">CommAlgebraCat.of'</span> <span class=\"o\">(</span><span class=\"n\">algebraMap</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toAlgebra</span><span class=\"o\">))</span>\n  <span class=\"n\">counitIso</span> <span class=\"o\">:=</span>\n    <span class=\"n\">NatIso.ofComponents</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">CommRing</span>\n<span class=\"kd\">end</span> <span class=\"n\">CommAlgebraCat</span>\n</code></pre></div>",
        "id": 412410256,
        "sender_full_name": "Raghuram",
        "timestamp": 1705002559
    },
    {
        "content": "<p>Sorry about the problematic code earlier.</p>",
        "id": 412410371,
        "sender_full_name": "Raghuram",
        "timestamp": 1705002603
    },
    {
        "content": "<p>Lean is hard! Knowing the maths is not good enough; there are all sorts of subtleties, which you only discover by writing code and trying stuff out and asking experts. Don't be sorry! Thanks for asking!</p>",
        "id": 412410732,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705002741
    },
    {
        "content": "<p>That's very true <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span><br>\nI meant the broken MWE though</p>",
        "id": 412410850,
        "sender_full_name": "Raghuram",
        "timestamp": 1705002797
    },
    {
        "content": "<p>Well, not exactly an MWE.</p>",
        "id": 412410881,
        "sender_full_name": "Raghuram",
        "timestamp": 1705002811
    },
    {
        "content": "<p>There are two non-defeq smuls:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">EquivToUnderCommRing</span> <span class=\"o\">:</span>\n    <span class=\"n\">Equivalence</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Under</span> <span class=\"o\">(</span><span class=\"n\">CommRingCat.of</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">functor</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">toUnder</span> <span class=\"o\">(</span><span class=\"n\">forget₂</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">CommRingCat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">A</span> <span class=\"bp\">↦</span> <span class=\"n\">algebraMap</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"c1\">-- the map from R associated with each algebra</span>\n    <span class=\"n\">AlgHom.comp_algebraMap</span>    <span class=\"c1\">-- algebra morphisms induce commutative triangles</span>\n  <span class=\"n\">inverse</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">A</span> <span class=\"bp\">↦</span> <span class=\"n\">CommAlgebraCat.of'</span> <span class=\"n\">A.hom.toAlgebra</span>\n      <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span>\n        <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">RingHom.congr_fun</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">B.hom</span> <span class=\"bp\">=</span> <span class=\"n\">f.comp</span> <span class=\"n\">A.hom</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n  <span class=\"n\">unitIso</span> <span class=\"o\">:=</span>\n    <span class=\"n\">NatIso.ofComponents</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">A</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span>\n        <span class=\"n\">cases'</span> <span class=\"n\">A</span> <span class=\"k\">with</span> <span class=\"n\">A</span> <span class=\"n\">i1</span> <span class=\"n\">i2</span>\n        <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">of'</span><span class=\"o\">,</span> <span class=\"n\">mk</span><span class=\"o\">]</span>\n        <span class=\"n\">convert</span> <span class=\"n\">CategoryTheory.Iso.refl</span> <span class=\"n\">_</span>\n        <span class=\"n\">cases'</span> <span class=\"n\">i2</span> <span class=\"k\">with</span> <span class=\"n\">i3</span> <span class=\"n\">i4</span> <span class=\"n\">h5</span> <span class=\"n\">h6</span>\n        <span class=\"n\">ext</span> <span class=\"n\">r</span> <span class=\"n\">x</span>\n        <span class=\"n\">dsimp</span>\n        <span class=\"n\">congr</span>\n        <span class=\"c1\">-- this is the problem I guess?</span>\n        <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n      <span class=\"gr\">sorry</span>\n  <span class=\"n\">counitIso</span> <span class=\"o\">:=</span>\n    <span class=\"n\">NatIso.ofComponents</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n      <span class=\"gr\">sorry</span>\n  <span class=\"n\">functor_unitIso_comp</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 412413726,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705003982
    },
    {
        "content": "<p>You need to use <code>h6</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">A</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span>\n        <span class=\"n\">cases'</span> <span class=\"n\">A</span> <span class=\"k\">with</span> <span class=\"n\">A</span> <span class=\"n\">i1</span> <span class=\"n\">i2</span>\n        <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">of'</span><span class=\"o\">,</span> <span class=\"n\">mk</span><span class=\"o\">]</span>\n        <span class=\"n\">convert</span> <span class=\"n\">CategoryTheory.Iso.refl</span> <span class=\"n\">_</span>\n        <span class=\"n\">rename_i</span> <span class=\"n\">foo</span> <span class=\"n\">bar</span>\n        <span class=\"n\">cases'</span> <span class=\"n\">i2</span> <span class=\"k\">with</span> <span class=\"n\">i3</span> <span class=\"n\">i4</span> <span class=\"n\">h5</span> <span class=\"n\">h6</span>\n        <span class=\"n\">ext</span> <span class=\"n\">r</span> <span class=\"n\">x</span>\n        <span class=\"n\">dsimp</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h6</span><span class=\"o\">]</span>\n        <span class=\"n\">rfl</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 412414304,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705004233
    },
    {
        "content": "<p>In the definition of <code>Algebra</code> we have the field <code>smul_def' : ∀ r x, r • x = toRingHom r * x</code> and of course the proof of this isn't <code>rfl</code>, but somehow buried in the diagram chase you end up with two actions of R on A and this is the reason they're equal. This is why you're in hell.</p>",
        "id": 412414604,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705004372
    },
    {
        "content": "<p>Right - if I'm understanding correctly, when we go from <code>CommAlgebraCat R</code> to <code>Under (CommRing.of R)</code>, we get the morphism <code>toRingHom : R -&gt;+* A</code>, and the reconstruction of the algebra structure uses <code>toRingHom r * x</code> for the <code>smul</code> (definitionally), unlike the original algebra where the <code>smul</code> is the same, but only propositionally.</p>",
        "id": 412414977,
        "sender_full_name": "Raghuram",
        "timestamp": 1705004534
    },
    {
        "content": "<p>I need to do other things now so can't check details but this sounds like exactly the sort of thing which might be happening.</p>",
        "id": 412415705,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705004869
    },
    {
        "content": "<p>I think one should make a constructor that makes an iso from an AlgEquiv, then use something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AlgEquiv.ofRingEquiv#doc\">docs#AlgEquiv.ofRingEquiv</a></p>",
        "id": 412428058,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1705010237
    },
    {
        "content": "<p>Presumably on the level of rings <code>RingEquiv.id</code> would work?</p>",
        "id": 412428105,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1705010262
    },
    {
        "content": "<p>Alternatively make a constructor that constructs an iso from an isomorphism on the level of rings together with a proof of compatibility with the scalar mult</p>",
        "id": 412428203,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1705010299
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Category.20of.20Commutative.20Algebras/near/412409726\">said</a>:</p>\n<blockquote>\n<p>You could do this for example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">CommAlgebra</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n</code></pre></div>\n<p>but then this makes it clear that <code>CommAlgebra</code> is not adding anything: we \"have it already\". Every definition comes with a cost -- you have to make the API for that definition. So it's best to make no definition if you can avoid making a definition.</p>\n</blockquote>\n<p>On the other hand, would there be useful to have a systematic way of introducing standard algebraic objects via an abbreviation. Say you write <code>[CommAlgebra R A]</code>, and the compiler translates it into <code>[CommSemiring A] [Module R A]</code>? And if some refactor suggest a better translation, then most of the files could remain the same.</p>",
        "id": 412589384,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1705080528
    },
    {
        "content": "<p>As an update, here's what I've gotten so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Category.AlgebraCat.Basic</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">Util</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Proved in https://github.com/leanprover-community/mathlib4/pull/9511. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Ring.toSemiring_injective</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">Function.Injective</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Ring.toSemiring</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">CommRing.toCommSemiring_injective</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">Function.Injective</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommRing.toCommSemiring</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩</span> <span class=\"o\">⟨⟩</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">congr</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">Ring.toSemiring_injective</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">injection</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Commutative analogue of Algebra.semiringToRing</span>\n<span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">Algebra.commSemiringToCommRing</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n  <span class=\"n\">__</span> <span class=\"o\">:=</span> <span class=\"n\">Algebra.semiringToRing</span> <span class=\"n\">R</span>\n  <span class=\"n\">mul_comm</span> <span class=\"o\">:=</span> <span class=\"o\">‹</span><span class=\"n\">CommSemiring</span> <span class=\"n\">A</span><span class=\"o\">›</span><span class=\"bp\">.</span><span class=\"n\">mul_comm</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Util</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span>\n<span class=\"kd\">universe</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n\n<span class=\"sd\">/-- The category of commutative R-algebras. -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">CommAlgebraCat</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n  <span class=\"n\">isCommSemiring</span> <span class=\"o\">:</span> <span class=\"n\">CommSemiring</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n  <span class=\"n\">isAlgebra</span> <span class=\"o\">:</span> <span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">CommAlgebraCat.isCommSemiring</span> <span class=\"n\">CommAlgebraCat.isAlgebra</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CommAlgebraCat</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">RSemiring</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CoeSort</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">CommAlgebraCat.carrier</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">coe</span><span class=\"o\">]</span> <span class=\"n\">CommAlgebraCat.carrier</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">category</span> <span class=\"o\">:</span> <span class=\"n\">Category</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">Hom</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">A</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span>\n  <span class=\"n\">id</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">AlgHom.id</span> <span class=\"n\">R</span> <span class=\"n\">A</span>\n  <span class=\"n\">comp</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">g.comp</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">concreteCategory</span> <span class=\"o\">:</span> <span class=\"n\">ConcreteCategory</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">forget</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">CommAlgebraCat.carrier</span><span class=\"o\">,</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">toFun</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n  <span class=\"n\">forget_faithful</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">AlgHom.coe_fn_inj.mp</span><span class=\"o\">⟩</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">Of</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- The object in the category of commutative R-algebras associated to</span>\n<span class=\"sd\">a type with the structure of a commutative R-algebra. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">of</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"n\">A</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"k\">in</span>\n<span class=\"sd\">/-- The object in the category of commutative R-algebras associated to</span>\n<span class=\"sd\">a `CommAlgebra R` instance. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">of'</span> <span class=\"o\">(</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span> <span class=\"n\">where</span>\n  <span class=\"n\">isAlgebra</span> <span class=\"o\">:=</span> <span class=\"n\">inst</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Of</span>\n\n<span class=\"c1\">-- Redeclare R as a `CommRing`.</span>\n<span class=\"kd\">end</span> <span class=\"n\">RSemiring</span> <span class=\"kn\">section</span> <span class=\"n\">RRing</span> <span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">isCommRing</span> <span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"n\">self.carrier</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Algebra.commSemiringToCommRing</span> <span class=\"n\">R</span> <span class=\"n\">self</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">hasForgetToCommRing</span> <span class=\"o\">:</span> <span class=\"n\">HasForget₂</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">CommRingCat</span> <span class=\"n\">where</span>\n  <span class=\"n\">forget₂</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">CommRingCat.of</span> <span class=\"bp\">·</span><span class=\"o\">),</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">AlgHom.toRingHom</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">lemma</span> <span class=\"n\">forget₂_commRing_obj</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">forget₂</span> <span class=\"n\">_</span> <span class=\"n\">CommRingCat</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">CommRingCat.of</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">lemma</span> <span class=\"n\">forget₂_commRing_map</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⟶</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">forget₂</span> <span class=\"n\">_</span> <span class=\"n\">CommRingCat</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f.toRingHom</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">equivToUnderCommRing</span> <span class=\"o\">:</span>\n    <span class=\"n\">Equivalence</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Under</span> <span class=\"o\">(</span><span class=\"n\">CommRingCat.of</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n  <span class=\"n\">functor</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">toUnder</span> <span class=\"o\">(</span><span class=\"n\">forget₂</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">CommRingCat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">algebraMap</span> <span class=\"n\">R</span> <span class=\"bp\">·</span><span class=\"o\">)</span>          <span class=\"c1\">-- map from R associated with each algebra</span>\n    <span class=\"n\">AlgHom.comp_algebraMap</span>    <span class=\"c1\">-- algebra morphisms induce commutative triangles</span>\n  <span class=\"n\">inverse</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">CommAlgebraCat.of'</span> <span class=\"bp\">·.</span><span class=\"n\">hom.toAlgebra</span><span class=\"o\">)</span>\n      <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨</span><span class=\"n\">f.right</span><span class=\"o\">,</span> <span class=\"n\">RingHom.congr_fun</span> <span class=\"n\">f.w.symm</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n  <span class=\"n\">unitIso</span> <span class=\"o\">:=</span> <span class=\"n\">NatIso.ofComponents</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">A</span> <span class=\"bp\">↦</span> <span class=\"n\">eqToIso</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">congrArg</span> <span class=\"n\">CommAlgebraCat.of'</span> <span class=\"bp\">&lt;|</span>\n                           <span class=\"c1\">-- We reconstructed the `smul`, but `smul_def` guarantees we get what we started with.</span>\n                           <span class=\"kd\">by</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">A.isAlgebra.smul_def</span><span class=\"o\">)</span>\n  <span class=\"n\">counitIso</span> <span class=\"o\">:=</span> <span class=\"n\">NatIso.ofComponents</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">A</span> <span class=\"bp\">↦</span> <span class=\"n\">eqToIso</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span>\n      <span class=\"c1\">-- Unwrap both sides to the form `⟨_, &lt;comm ring&gt;, &lt;morphism from R&gt;⟩`</span>\n      <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">Functor.toUnder</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rhs</span><span class=\"bp\">;</span> <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">StructuredArrow.eq_mk</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n      <span class=\"c1\">-- We reconstructed the `Neg` and `Sub`, but these are uniquely determined by the `Semiring` structure.</span>\n      <span class=\"n\">congr</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">CommRing.toCommSemiring_injective</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">RRing</span>\n</code></pre></div>\n<p>I've constructed the natural isomorphism components using the above help, but the auto-param <code>aesop_cat</code> proofs are not succeeding.<br>\n(I'm not sure if this is because the isomorphisms are constructed essentially by rewriting <code>CategoryTheory.Iso.refl</code> idenity maps using object equalities and that's \"evil\" (indeed, the object equalities can be used equally well for constructing an isomorphism of categories as I was doing earlier, and I get very similar naturality goals to what I have left now, so perhaps I'm not properly \"using\" the fact that I'm constructing an <code>Equivalence</code> to make the job easier?).<br>\nI've used <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToIso\"><code>eqToIso</code></a> because apparently it leads to less dependent type theory hell than literally rewriting, but maybe that wasn't enough?)</p>",
        "id": 412680632,
        "sender_full_name": "Raghuram",
        "timestamp": 1705127967
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Category.20of.20Commutative.20Algebras/near/412428058\">said</a>:</p>\n<blockquote>\n<p>I think one should make a constructor that makes an iso from an AlgEquiv, then use something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AlgEquiv.ofRingEquiv#doc\">docs#AlgEquiv.ofRingEquiv</a></p>\n</blockquote>\n<p>Were you suggesting this just as a possible way to construct the natural isomorphism components or also because it would be easier to prove things (specifically naturality, right now) about or otherwise superior to the other approach, consisting of rewriting by object equality and using <code>CategoryTheory.Iso.refl</code>?<br>\nIn the latter case, I can try to use this approach instead, but I don't know how to do it like this without again rewriting by an object equality (in which case it seems like I might as well just use the identity (iso)morphism any category provides).</p>",
        "id": 412682179,
        "sender_full_name": "Raghuram",
        "timestamp": 1705129279
    },
    {
        "content": "<p>Just to clarify the construction, and specifically what is definitionally and propositionally equal (to the best of my understanding):</p>\n<ul>\n<li>There are two categories, that of commutative R-algebras and that of commutative rings with a ring homomorphism from R, with functors between them forming an equivalence.</li>\n<li>For any commutative R-algebra, if we apply both functors, we get a commutative R-algebra which has:<ul>\n<li>the same type/carrier, definitionally</li>\n<li>the same <code>CommSemiRing</code> structure, again should be definitionally true</li>\n<li>the  same R-algebra structure, but now only <strong>propositionally</strong> (partly, some fields are definitionally equal)</li>\n</ul>\n</li>\n<li>\n<p>Similarly, for any commutative ring with morphism from R, if we apply both functors, we get another one which has:</p>\n<ul>\n<li>the same type/carrier, definitionally</li>\n<li>\n<p>the same CommRing structure, but now only <strong>propositionally</strong> (partly, the <code>CommSemiring</code> part of it is definitionally the same)<br>\n  (If we try to construct the analogous equivalence for R a <code>CommSemiRing</code> rather than <code>CommRing</code>, we actually do get definitional equality here.)</p>\n</li>\n<li>\n<p>the same ring homomorphism.<br>\n  This should be definitionally true as functions. Since <code>RingHom</code> only depends on <code>NonAssocSemiring</code>, they should in fact have the same type, so they might be definitionally equal or something close to it as <code>RingHom</code>s as well (using proof irrelevance).</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>Given all of this, the natural isomorphism components mathematically \"ought\" to be identity morphisms (which is why I tried to construct an isomorphism of categories rather than an equivalence originally), which is why right now they are constructed by rewriting object equalities / using <code>eqToIso</code>. But if there's a different way of defining them in Lean that makes it easier to construct the equivalence/isomorphism, that would be great too.</p>",
        "id": 412683707,
        "sender_full_name": "Raghuram",
        "timestamp": 1705130538
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Category.20of.20Commutative.20Algebras/near/412589384\">said</a>:</p>\n<blockquote>\n<p>Say you write <code>[CommAlgebra R A]</code>, and the compiler translates it into <code>[CommSemiring A] [Module R A]</code>? And if some refactor suggest a better translation, then most of the files could remain the same.</p>\n</blockquote>\n<p>(Note: a commutative R-algebra isn't equivalent to a commutative (semi)ring which is an R-module because the multiplication might not be R-linear, but is rather equivalent to a commutative (semi)ring with a ring homomorphism from R. I'm assuming that you meant something more like for <code>[CommAlgebra R A]</code> to abbreviate <code>[CommSemiring A] [&lt;what we currently call Algebra R A&gt;]</code>.)</p>\n<p>I think that if an abbreviation like that was sufficient, then (dropping the commutativeness to talk about something already in Mathlib) <code>Algebra R A</code> could have been defined as a structure extending <code>Semiring A</code> to begin with, rather than one taking a <code>Semiring A</code> as a parameter.<br>\nI don't know for sure why it isn't defined that way, but I would guess it's to make it possible to talk about something being an algebra over mutiple (semi)rings with (<em>definitionally</em>) the same (semi)ring structure.</p>\n<p>So (assuming such a use-case that prevents <code>Algebra R A</code> from extending <code>Semiring A</code>) in at least some use-cases you'll have to stop using the syntactic sugar that expands one declaration to two and write <code>[(Comm)Semiring A] [Algebra R A]</code> manually.</p>\n<p>On the other hand, as an abbreviation for the most common use-case, I think this would be quite convenient, and there are many more similarly useful abbreviations. (For example, most files dealing with modules probably just have a module over a specific ring, and might benefit from a <code>[Module' R M]</code> which expands to <code>[AddCommGroup M] [Module R M]</code> or even a <code>[ModulePair R M]</code> which expands to <code>[Ring R] [AddCommGroup M] [Module R M]</code>.)</p>\n<p>That would have a much wider scope than what this thread is about though.</p>",
        "id": 412685197,
        "sender_full_name": "Raghuram",
        "timestamp": 1705131860
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"501683\">Raghuram</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Category.20of.20Commutative.20Algebras/near/412680632\">said</a>:</p>\n<blockquote>\n<p>I've constructed the natural isomorphism components using the above help, but the auto-param <code>aesop_cat</code> proofs are not succeeding.</p>\n</blockquote>\n<p>Rereading the chat, I'm guessing that I need to prove some more <code>simp</code> lemmas to make <code>aesop_cat</code> succeed at the naturality proofs (and hopefully the half-adjunction one as well).<br>\nBut I'm not sure what kind of <code>simp</code>  lemmas to prove.</p>",
        "id": 412685471,
        "sender_full_name": "Raghuram",
        "timestamp": 1705132154
    },
    {
        "content": "<p>You can show us some goals and we can guess. :-) Usually you need to write <code>:= by aesop_cat</code>, look at the resulting failure, and guess what needs to be simplified! There's no shame in writing the proof by hand first, then adjusting it until <code>aesop</code> can reproduce it, and then finally deleting it.</p>",
        "id": 412690113,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1705136266
    },
    {
        "content": "<p>I don't think you should use <code>eqToIso</code> since it invloves casts and is not good to work with.</p>",
        "id": 412691100,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1705137022
    },
    {
        "content": "<p>There should be something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">simps</span><span class=\"bp\">!</span> <span class=\"n\">hom_apply</span> <span class=\"n\">inv_apply</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">CommAlgebraCat.isoOf</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≅</span> <span class=\"n\">B</span> <span class=\"n\">where</span>\n  <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"n\">e.toAlgHom</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"n\">e.symm.toAlgHom</span>\n  <span class=\"n\">hom_inv_id</span> <span class=\"o\">:=</span> <span class=\"n\">e.symm_comp</span>\n  <span class=\"n\">inv_hom_id</span> <span class=\"o\">:=</span> <span class=\"n\">e.comp_symm</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">AlgEquiv.refl'</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">inst₁</span> <span class=\"o\">:</span> <span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">inst₂</span> <span class=\"o\">:</span> <span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">inst₁</span> <span class=\"bp\">=</span> <span class=\"n\">inst₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">@</span><span class=\"n\">AlgEquiv</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">A</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">inst₁</span> <span class=\"n\">inst₂</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">AlgEquiv.mk</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">A</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">inst₁</span> <span class=\"n\">inst₂</span>\n    <span class=\"o\">(</span><span class=\"n\">Equiv.refl</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">e</span> <span class=\"bp\">▸</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>then aesop works for you in <code>unitIso</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unitIso</span> <span class=\"o\">:=</span> <span class=\"n\">NatIso.ofComponents</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">X</span> <span class=\"bp\">↦</span> <span class=\"n\">CommAlgebraCat.isoOf</span> <span class=\"o\">(</span><span class=\"n\">AlgEquiv.refl'</span> <span class=\"o\">(</span><span class=\"n\">Algebra.algebra_ext</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">rfl</span><span class=\"o\">))))</span>\n</code></pre></div>",
        "id": 412691264,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1705137147
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Category.20of.20Commutative.20Algebras/near/412690113\">said</a>:</p>\n<blockquote>\n<p>There's no shame in writing the proof by hand</p>\n</blockquote>\n<p>No shame, but work I was hoping to avoid ;)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Category.20of.20Commutative.20Algebras/near/412690113\">said</a>:</p>\n<blockquote>\n<p>You can show us some goals and we can guess. :-)</p>\n</blockquote>\n<p>The <code>sorry</code>s in the above code snippet; here's one of them explicitly (after <code>rintro _ _ (f : _ →ₐ[R] _); dsimp</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"n\">R</span>\n<span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span>\n<span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"n\">X</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"bp\">↑</span><span class=\"n\">Y</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">eqToHom</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">eqToHom</span> <span class=\"n\">_</span> <span class=\"bp\">≫</span> <span class=\"o\">{</span> <span class=\"n\">toRingHom</span> <span class=\"o\">:=</span> <span class=\"bp\">↑</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">commutes'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>The <code>eqToHom</code>s are components of the <code>eqToIso</code> isomorphisms I constructed, and the structure on the right is the image of <code>f</code> under the functor which I want to show is isomorphic to the identity.</p>\n<p>I'll get started on trying to decipher this and prove it by hand in a while...</p>",
        "id": 412691266,
        "sender_full_name": "Raghuram",
        "timestamp": 1705137149
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 412691395,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1705137251
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Category.20of.20Commutative.20Algebras/near/412691264\">said</a>:</p>\n<blockquote>\n<p>There should be something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">simps</span><span class=\"bp\">!</span> <span class=\"n\">hom_apply</span> <span class=\"n\">inv_apply</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">CommAlgebraCat.isoOf</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">CommAlgebraCat</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≅</span> <span class=\"n\">B</span> <span class=\"n\">where</span>\n  <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"n\">e.toAlgHom</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"n\">e.symm.toAlgHom</span>\n  <span class=\"n\">hom_inv_id</span> <span class=\"o\">:=</span> <span class=\"n\">e.symm_comp</span>\n  <span class=\"n\">inv_hom_id</span> <span class=\"o\">:=</span> <span class=\"n\">e.comp_symm</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">AlgEquiv.refl'</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">inst₁</span> <span class=\"o\">:</span> <span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">inst₂</span> <span class=\"o\">:</span> <span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">inst₁</span> <span class=\"bp\">=</span> <span class=\"n\">inst₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">@</span><span class=\"n\">AlgEquiv</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">A</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">inst₁</span> <span class=\"n\">inst₂</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">AlgEquiv.mk</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">A</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">inst₁</span> <span class=\"n\">inst₂</span>\n    <span class=\"o\">(</span><span class=\"n\">Equiv.refl</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">e</span> <span class=\"bp\">▸</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>then aesop works for you in <code>unitIso</code>:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unitIso</span> <span class=\"o\">:=</span> <span class=\"n\">NatIso.ofComponents</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">X</span> <span class=\"bp\">↦</span> <span class=\"n\">CommAlgebraCat.isoOf</span> <span class=\"o\">(</span><span class=\"n\">AlgEquiv.refl'</span> <span class=\"o\">(</span><span class=\"n\">Algebra.algebra_ext</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">rfl</span><span class=\"o\">))))</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>So is the idea that if we rewrite by the equality \"deeper\" inside, rather than rewriting <code>Iso.refl</code> or something, things become easier?</p>",
        "id": 412691430,
        "sender_full_name": "Raghuram",
        "timestamp": 1705137300
    },
    {
        "content": "<p>The key is to only rewrite equalities in <code>Prop</code> type goals if possible.</p>",
        "id": 412691484,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1705137351
    },
    {
        "content": "<p>Is there a PR for this? If not, are you still working on this <span class=\"user-mention\" data-user-id=\"501683\">@Raghuram</span>? Bumping this thread, because I need <code>CommAlgebraCat</code>.</p>",
        "id": 434688535,
        "sender_full_name": "Christian Merten",
        "timestamp": 1713774841
    },
    {
        "content": "<p>Maybe use <code>Under (CommRingCat.of R)</code> in the mean time? Unless the base ring is a semiring.</p>",
        "id": 434706476,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1713779962
    },
    {
        "content": "<p>Good idea, I'll inherit limit properties from <code>CommRingCat</code> right? So taking limits should be okay, probably comparing to the corresponding limit in <code>ModuleCat R</code> is painful? I am reluctant to write API for this, if it is to be replaced by <code>CommAlgebraCat</code> anyway.</p>",
        "id": 434710454,
        "sender_full_name": "Christian Merten",
        "timestamp": 1713781161
    },
    {
        "content": "<p>The existing API for general over categories should be enough I think.</p>",
        "id": 434712529,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1713781830
    },
    {
        "content": "<p>I'll give it a shot (if we stick with the explicit definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=adicCompletion#doc\">docs#adicCompletion</a>, I might not need it anyway).</p>",
        "id": 434712702,
        "sender_full_name": "Christian Merten",
        "timestamp": 1713781900
    },
    {
        "content": "<p>Maybe <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> has opinions on whether we should define a new <code>CommAlgebraCat</code>, or use what Andrew describes.</p>",
        "id": 434726508,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713786346
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Category.20of.20Commutative.20Algebras/near/434688535\">said</a>:</p>\n<blockquote>\n<p>Is there a PR for this? If not, are you still working on this <span class=\"user-mention silent\" data-user-id=\"501683\">Raghuram</span>? Bumping this thread, because I need <code>CommAlgebraCat</code>.</p>\n</blockquote>\n<p>Can't say what anyone else has done, but pretty much everything I have done is in this thread.</p>",
        "id": 437762525,
        "sender_full_name": "Raghuram",
        "timestamp": 1715224958
    }
]