[
    {
        "content": "<p>Is there some way of finding out \"how much of mathlib is needed\" to prove a given theorem?</p>\n<p>This could mean either </p>\n<ul>\n<li>(a) number of files in a minimal set of mathlib imports required to get the proof to work;</li>\n<li>(b) total lines of code in (a);</li>\n<li>(c) (probably much harder) total number of definitions / theorems needed, divided by the number in the <a href=\"https://leanprover-community.github.io/mathlib_stats.html\">stats page</a>. </li>\n</ul>\n<p>(Number theorists love to boast that their area uses just about every other area of pure mathematics as input at some stage, and I'm wondering if the statistics really bear this out.)</p>",
        "id": 425035933,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709715872
    },
    {
        "content": "<p>I think (c) is very doable these days. Tools like leaff and shake do much more complicated calculations.</p>\n<p>I remember that we computed (c) for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> and for <code>perfectoid_space</code>, and we discovered that perfectoid spaces are only 4x more complicated than real numbers.</p>",
        "id": 425036726,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1709716158
    },
    {
        "content": "<p>I did notice that my PhD thesis used results from 11 of the 12 courses I went to as a final year UG (logic was the only missing one) and one reason I was pushing in 2017 for mathlib to become what it's becoming was because I knew that FLT would need \"everything\". But I wonder whether we're high enough up to see this phenomenon yet. Given all this import pruning it's probably not too hard to figure out if all this L-function stuff we have now depends on topology by \"eyeballing\", but no doubt it's depending on a bunch of analysis and some algebra already.</p>",
        "id": 425036838,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709716198
    },
    {
        "content": "<p>I know there's logic and logic, but I still was taken aback a bit by your claim that you didn't need logic for your PhD thesis :)</p>",
        "id": 425037340,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1709716387
    },
    {
        "content": "<p>A creative work of pure aesthetic genius.</p>",
        "id": 425056644,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1709722095
    },
    {
        "content": "<p>I had some code that did exactly this, since I had been curious about this question already.  Unfortunately, the code is a little too slow to be really usable for \"complicated\" declarations, but it does provide some data:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"sd\">/-- `getExprsName e` takes as input an `Expr`ession `e`.</span>\n<span class=\"sd\">It returns a pair consisting of</span>\n<span class=\"sd\">* the list of all the maximal proper sub-expressions of `e`,</span>\n<span class=\"sd\">* the \"head\" `Name` associated to `e`, if it exists.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">getExprsName</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Expr</span> <span class=\"bp\">×</span> <span class=\"n\">Option</span> <span class=\"n\">Name</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"n\">declName</span> <span class=\"n\">_</span>            <span class=\"bp\">=&gt;</span> <span class=\"o\">([],</span> <span class=\"n\">some</span> <span class=\"n\">declName</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">fn</span> <span class=\"n\">arg</span>                  <span class=\"bp\">=&gt;</span> <span class=\"o\">([</span><span class=\"n\">fn</span><span class=\"o\">,</span> <span class=\"n\">arg</span><span class=\"o\">],</span> <span class=\"n\">none</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">lam</span> <span class=\"n\">_</span> <span class=\"n\">binderType</span> <span class=\"n\">body</span> <span class=\"n\">_</span>     <span class=\"bp\">=&gt;</span> <span class=\"o\">([</span><span class=\"n\">binderType</span><span class=\"o\">,</span> <span class=\"n\">body</span><span class=\"o\">],</span> <span class=\"n\">none</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">forallE</span> <span class=\"n\">_</span> <span class=\"n\">binderType</span> <span class=\"n\">body</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">([</span><span class=\"n\">binderType</span><span class=\"o\">,</span> <span class=\"n\">body</span><span class=\"o\">],</span> <span class=\"n\">none</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">letE</span> <span class=\"n\">_</span> <span class=\"n\">type</span> <span class=\"n\">value</span> <span class=\"n\">body</span> <span class=\"n\">_</span>    <span class=\"bp\">=&gt;</span> <span class=\"o\">([</span><span class=\"n\">type</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"n\">body</span><span class=\"o\">],</span> <span class=\"n\">none</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">mdata</span> <span class=\"n\">_</span> <span class=\"n\">expr</span>                <span class=\"bp\">=&gt;</span> <span class=\"o\">([</span><span class=\"n\">expr</span><span class=\"o\">],</span> <span class=\"n\">none</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">proj</span> <span class=\"n\">typeName</span> <span class=\"n\">_</span> <span class=\"n\">struct</span>      <span class=\"bp\">=&gt;</span> <span class=\"o\">([</span><span class=\"n\">struct</span><span class=\"o\">],</span> <span class=\"n\">some</span> <span class=\"n\">typeName</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">([],</span> <span class=\"n\">none</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- `getForallEs e` takes as input an expression `e`.</span>\n<span class=\"sd\">If `e` is of the form `∀ a₁, a₂,..., aₙ, &lt;something&gt;`, then it returns the names</span>\n<span class=\"sd\">of all the variables `a₁, a₂,..., aₙ`.</span>\n<span class=\"sd\">This is useful to extract (some of) the constructors of an inductive type. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">getForallEs</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Name</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">forallE</span> <span class=\"n\">name</span> <span class=\"n\">_</span> <span class=\"n\">body</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">name</span> <span class=\"o\">::</span> <span class=\"n\">getForallEs</span> <span class=\"n\">body</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n\n<span class=\"sd\">/-- `getConstructorsAux nm` takes as input a `Name` `nm`.</span>\n<span class=\"sd\">It returns the pair of lists of</span>\n<span class=\"sd\">* `Name`s of the constructors of `nm` obtained via `Lean.InductiveVal.ctors`,</span>\n<span class=\"sd\">  if `nm` is the `Name` of an inductive type -- typically `nm.mk`;</span>\n<span class=\"sd\">* `Name`s of the constructors that appear in the `nm.mk` function for `nm`, extracted</span>\n<span class=\"sd\">  via `getExprsName`.</span>\n\n<span class=\"sd\">The two projections are called `getConstructors'` and `getConstructors`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">getConstructorsAux</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadResolveName</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadEnv</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">nm</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">Name</span> <span class=\"bp\">×</span> <span class=\"n\">List</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">getEnv</span>\n  <span class=\"k\">if</span> <span class=\"bp\">!</span> <span class=\"n\">env.contains</span> <span class=\"n\">nm</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"o\">([],</span> <span class=\"o\">[])</span> <span class=\"k\">else</span>\n    <span class=\"k\">let</span> <span class=\"n\">decl</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">env.find</span><span class=\"bp\">?</span> <span class=\"n\">nm</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"bp\">!</span>\n    <span class=\"k\">if</span> <span class=\"bp\">!</span> <span class=\"n\">decl.isInductive</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"o\">([],</span> <span class=\"o\">[])</span> <span class=\"k\">else</span>\n      <span class=\"k\">let</span> <span class=\"n\">ctrs</span> <span class=\"o\">:=</span> <span class=\"n\">decl.inductiveVal</span><span class=\"bp\">!.</span><span class=\"n\">ctors</span>\n      <span class=\"k\">let</span> <span class=\"n\">decls</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ctrs.map</span> <span class=\"o\">(</span><span class=\"n\">env.find</span><span class=\"bp\">?</span> <span class=\"bp\">·</span> <span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">reduceOption</span>\n      <span class=\"k\">let</span> <span class=\"n\">types</span> <span class=\"o\">:=</span> <span class=\"n\">decls.map</span> <span class=\"n\">ConstantInfo.type</span>\n      <span class=\"k\">let</span> <span class=\"n\">ret</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">types.map</span> <span class=\"n\">getForallEs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">join</span>\n      <span class=\"k\">let</span> <span class=\"n\">withNamespace</span> <span class=\"bp\">←</span> <span class=\"n\">ret.mapM</span> <span class=\"o\">(</span><span class=\"n\">resolveGlobalName</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">nm.append</span> <span class=\"bp\">·</span><span class=\"o\">)</span>\n      <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">ctrs</span><span class=\"o\">,</span> <span class=\"n\">withNamespace.map</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x.getD</span> <span class=\"mi\">0</span> <span class=\"n\">default</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">run_cmd</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">Mul</span>\n  <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getConstructorsAux</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">!=</span> <span class=\"o\">([</span><span class=\"bp\">`</span><span class=\"n\">Mul.mk</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"n\">Mul</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">Mul.mul</span><span class=\"o\">])</span> <span class=\"k\">then</span>\n    <span class=\"n\">throwError</span> <span class=\"s2\">\"oh no! {← getConstructorsAux n}\"</span>\n\n<span class=\"sd\">/-- `getConstructors' nm` returns the list of constructors of `nm`, assuming that</span>\n<span class=\"sd\">it is the `Name` of an inductive type.</span>\n<span class=\"sd\">Often, this is `nm.mk`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">getConstructors'</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadResolveName</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadEnv</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">nm</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">ctrs</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">getConstructorsAux</span> <span class=\"n\">nm</span>\n  <span class=\"n\">return</span> <span class=\"n\">ctrs</span>\n\n<span class=\"sd\">/-- `getConstructors nm`  returns the list of `Name`s of the constructors of `nm`,</span>\n<span class=\"sd\">that appear in the `nm.mk` function for `nm`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">getConstructors</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadResolveName</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadEnv</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">nm</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">ctrs</span><span class=\"o\">,</span> <span class=\"n\">ns</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">getConstructorsAux</span> <span class=\"n\">nm</span>\n  <span class=\"n\">return</span> <span class=\"n\">ctrs</span> <span class=\"bp\">++</span> <span class=\"n\">ns</span>\n\n<span class=\"sd\">/-- `getConstsIn e` takes as input an `Expr`ession `e` and it returns the `Name`s of all the</span>\n<span class=\"sd\">constants recursively appearing in `e`.</span>\n<span class=\"sd\">The optional argument `hs` allows to increment `hs` by such constants, instead of starting</span>\n<span class=\"sd\">from scratch every time. -/</span>\n<span class=\"n\">partial</span>\n<span class=\"kd\">def</span> <span class=\"n\">getConstsIn</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"n\">Name</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">empty</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"n\">Name</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">hs</span> <span class=\"o\">:=</span> <span class=\"n\">hs</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">se</span><span class=\"o\">,</span> <span class=\"n\">na</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">getExprsName</span> <span class=\"n\">e</span>\n  <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">na</span> <span class=\"o\">:=</span> <span class=\"n\">na</span> <span class=\"k\">then</span> <span class=\"n\">hs</span> <span class=\"o\">:=</span> <span class=\"n\">hs.insert</span> <span class=\"n\">na</span>\n  <span class=\"n\">for</span> <span class=\"n\">s</span> <span class=\"k\">in</span> <span class=\"n\">se</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">nas</span> <span class=\"o\">:=</span> <span class=\"n\">getConstsIn</span> <span class=\"n\">s</span>\n    <span class=\"n\">for</span> <span class=\"n\">n</span> <span class=\"k\">in</span> <span class=\"n\">nas</span> <span class=\"k\">do</span>\n      <span class=\"k\">if</span> <span class=\"bp\">!</span> <span class=\"n\">hs.contains</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"n\">hs</span> <span class=\"o\">:=</span> <span class=\"n\">hs.insert</span> <span class=\"n\">n</span>\n  <span class=\"n\">return</span> <span class=\"n\">hs</span>\n\n<span class=\"sd\">/-- `getAll nm` takes as input a name `nm` and returns the `HashSet Name` of all the</span>\n<span class=\"sd\">non-blacklisted `Name`s that appear in `nm` and in all the constants that are implied</span>\n<span class=\"sd\">by `nm`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">getAll</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadResolveName</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadEnv</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">nm</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">HashSet</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">getEnv</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">boundary</span> <span class=\"o\">:=</span> <span class=\"n\">HashSet.empty.insert</span> <span class=\"n\">nm</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">tot</span> <span class=\"o\">:=</span> <span class=\"n\">HashSet.empty.insert</span> <span class=\"n\">nm</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">seenDecls</span> <span class=\"o\">:</span> <span class=\"n\">HashSet</span> <span class=\"n\">Name</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">empty</span>\n  <span class=\"n\">while</span> <span class=\"bp\">!</span> <span class=\"n\">boundary.isEmpty</span> <span class=\"k\">do</span>\n    <span class=\"n\">for</span> <span class=\"n\">new</span> <span class=\"k\">in</span> <span class=\"n\">boundary</span> <span class=\"k\">do</span>\n      <span class=\"n\">boundary</span> <span class=\"o\">:=</span> <span class=\"n\">boundary.erase</span> <span class=\"n\">new</span>\n      <span class=\"k\">let</span> <span class=\"n\">decl</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">env.find</span><span class=\"bp\">?</span> <span class=\"n\">new</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getD</span> <span class=\"n\">default</span>\n      <span class=\"k\">if</span> <span class=\"bp\">!</span> <span class=\"n\">seenDecls.contains</span> <span class=\"n\">decl.name</span> <span class=\"k\">then</span>\n        <span class=\"n\">seenDecls</span> <span class=\"o\">:=</span> <span class=\"n\">seenDecls.insert</span> <span class=\"n\">decl.name</span>\n        <span class=\"k\">let</span> <span class=\"n\">first</span> <span class=\"o\">:=</span> <span class=\"n\">getConstsIn</span> <span class=\"n\">decl.type</span>\n        <span class=\"n\">for</span> <span class=\"n\">d</span> <span class=\"k\">in</span> <span class=\"n\">first</span> <span class=\"k\">do</span>\n          <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">d.isBlackListed</span><span class=\"o\">))</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"bp\">!</span> <span class=\"n\">tot.contains</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n            <span class=\"n\">tot</span> <span class=\"o\">:=</span> <span class=\"n\">tot.insert</span> <span class=\"n\">d</span>\n            <span class=\"n\">boundary</span> <span class=\"o\">:=</span> <span class=\"n\">boundary.insert</span> <span class=\"n\">d</span>\n        <span class=\"k\">if</span> <span class=\"n\">decl.value</span><span class=\"bp\">?.</span><span class=\"n\">isSome</span> <span class=\"k\">then</span>\n          <span class=\"n\">for</span> <span class=\"n\">d</span> <span class=\"k\">in</span> <span class=\"n\">getConstsIn</span> <span class=\"n\">decl.value</span><span class=\"bp\">!</span> <span class=\"k\">do</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">d.isBlackListed</span><span class=\"o\">))</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"bp\">!</span> <span class=\"n\">tot.contains</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n              <span class=\"n\">tot</span> <span class=\"o\">:=</span> <span class=\"n\">tot.insert</span> <span class=\"n\">d</span>\n              <span class=\"n\">boundary</span> <span class=\"o\">:=</span> <span class=\"n\">boundary.insert</span> <span class=\"n\">d</span>\n        <span class=\"n\">for</span> <span class=\"n\">d</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getConstructors</span> <span class=\"n\">new</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getConstructors'</span> <span class=\"n\">new</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n          <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">d.isBlackListed</span><span class=\"o\">))</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"bp\">!</span> <span class=\"n\">tot.contains</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n            <span class=\"n\">tot</span> <span class=\"o\">:=</span> <span class=\"n\">tot.insert</span> <span class=\"n\">d</span>\n            <span class=\"n\">boundary</span> <span class=\"o\">:=</span> <span class=\"n\">boundary.insert</span> <span class=\"n\">d</span>\n  <span class=\"n\">return</span> <span class=\"n\">tot</span>\n\n<span class=\"sd\">/-- `moduleIdxPrefix env str` takes as input an environment `env` and a string `str`.</span>\n<span class=\"sd\">It returns the array of pairs `(name, moduleIdx)` consisting of a `Name` of a module</span>\n<span class=\"sd\">that begins with `str` and the `ModuleIdx` corresponding `name`.</span>\n<span class=\"sd\">This is essentially a dictionary between module names beginning with `str` and</span>\n<span class=\"sd\">their module indices. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">moduleIdxPrefix</span> <span class=\"o\">(</span><span class=\"n\">env</span> <span class=\"o\">:</span> <span class=\"n\">Environment</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">Name</span> <span class=\"bp\">×</span> <span class=\"n\">ModuleIdx</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">filt</span> <span class=\"o\">:=</span> <span class=\"n\">env.allImportedModuleNames.filter</span> <span class=\"o\">(</span><span class=\"n\">str.isPrefixOf</span> <span class=\"bp\">·.</span><span class=\"n\">toString</span><span class=\"o\">)</span>\n  <span class=\"n\">filt.map</span> <span class=\"k\">fun</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">env.getModuleIdx</span><span class=\"bp\">?</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getD</span> <span class=\"n\">default</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- `countDeclCmd id pathPrefix` is the main \"command\": it takes as input an identifier `id` and</span>\n<span class=\"sd\">a path string `pathPrefix` and returns the `HashSet Name` of all names of constants recursively</span>\n<span class=\"sd\">implied by the declaration determined by `id` and whose  -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">countDeclCmd</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadEnv</span> <span class=\"n\">m</span><span class=\"o\">][</span><span class=\"n\">MonadResolveName</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonadError</span> <span class=\"n\">m</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"n\">TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">ident</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pathPrefix</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">HashSet</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">nm</span> <span class=\"o\">:=</span> <span class=\"n\">id.getId</span>\n  <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">getEnv</span>\n  <span class=\"k\">let</span> <span class=\"n\">idxPrefix</span> <span class=\"o\">:=</span> <span class=\"n\">moduleIdxPrefix</span> <span class=\"n\">env</span> <span class=\"n\">pathPrefix</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">idx</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">idxPrefix.unzip</span>\n  <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">env.find</span><span class=\"bp\">?</span> <span class=\"n\">nm</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isNone</span> <span class=\"k\">then</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"unknown constant '{nm}'\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">rest</span> <span class=\"bp\">←</span> <span class=\"n\">getAll</span> <span class=\"n\">nm</span>\n  <span class=\"n\">for</span> <span class=\"n\">d</span> <span class=\"k\">in</span> <span class=\"n\">rest</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">env.getModuleIdxFor</span><span class=\"bp\">?</span> <span class=\"n\">d</span>\n    <span class=\"k\">if</span> <span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">c.getD</span> <span class=\"n\">default</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">idx</span> <span class=\"k\">then</span> <span class=\"n\">rest</span> <span class=\"o\">:=</span> <span class=\"n\">rest.erase</span> <span class=\"n\">d</span>\n  <span class=\"n\">return</span> <span class=\"n\">rest</span>\n\n<span class=\"sd\">/-- `#tally id` takes as input an identifier `id`.  It returns a tally of the number of</span>\n<span class=\"sd\">declarations recursively implied by `id`, where the tally is split by the first two folders</span>\n<span class=\"sd\">in the path to the file containing each declaration.</span>\n\n<span class=\"sd\">For example,</span>\n<span class=\"sd\">```lean</span>\n<span class=\"sd\">#tally Nat</span>\n<span class=\"sd\">/-</span>\n<span class=\"sd\">3  Init.Prelude</span>\n\n<span class=\"sd\">3  total</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">tally</span> <span class=\"n\">Int</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">3  Init.Data</span>\n<span class=\"cm\">3  Init.Prelude</span>\n<span class=\"cm\">1  [anonymous]</span>\n\n<span class=\"cm\">7  total</span>\n<span class=\"cm\">-/</span>\n<span class=\"bp\">```</span>\n <span class=\"bp\">-/</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"#tally \"</span> <span class=\"n\">tk</span><span class=\"o\">:(</span><span class=\"n\">noWs</span> <span class=\"s2\">\"!\"</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">getEnv</span>\n  <span class=\"k\">let</span> <span class=\"n\">filt</span> <span class=\"o\">:=</span> <span class=\"n\">env.allImportedModuleNames</span>\n  <span class=\"k\">let</span> <span class=\"n\">dict</span> <span class=\"o\">:=</span> <span class=\"n\">filt.map</span> <span class=\"k\">fun</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">((</span><span class=\"n\">env.getModuleIdx</span><span class=\"bp\">?</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getD</span> <span class=\"n\">default</span><span class=\"o\">,</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">dict</span> <span class=\"o\">:=</span> <span class=\"n\">dict.map</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">idx</span><span class=\"o\">,</span> <span class=\"n\">nm</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"o\">(</span><span class=\"n\">idx</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">nm.components.take</span> <span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">foldl</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">++</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"n\">default</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">dict</span> <span class=\"o\">:=</span> <span class=\"n\">dict.toList</span>\n  <span class=\"k\">let</span> <span class=\"n\">tot</span> <span class=\"bp\">←</span> <span class=\"n\">countDeclCmd</span> <span class=\"n\">id</span> <span class=\"s2\">\"\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">tal</span> <span class=\"o\">:</span> <span class=\"n\">HashMap</span> <span class=\"n\">Name</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">empty</span>\n  <span class=\"n\">for</span> <span class=\"n\">d</span> <span class=\"k\">in</span> <span class=\"n\">tot</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">didx</span> <span class=\"o\">:=</span> <span class=\"n\">env.getModuleIdxFor</span><span class=\"bp\">?</span> <span class=\"n\">d</span>\n    <span class=\"k\">let</span> <span class=\"n\">pair</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">dict.lookup</span> <span class=\"n\">didx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getD</span> <span class=\"n\">default</span>\n    <span class=\"k\">match</span> <span class=\"n\">tal.find</span><span class=\"bp\">?</span> <span class=\"n\">pair</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">tal</span> <span class=\"o\">:=</span> <span class=\"n\">tal.insert</span> <span class=\"n\">pair</span> <span class=\"mi\">1</span>\n      <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">tal</span> <span class=\"o\">:=</span> <span class=\"n\">tal.insert</span> <span class=\"n\">pair</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">ct</span> <span class=\"o\">:=</span> <span class=\"n\">tal.fold</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">t</span><span class=\"o\">))</span> <span class=\"mi\">0</span>\n  <span class=\"k\">let</span> <span class=\"n\">lth</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Nat.toDigits</span> <span class=\"mi\">10</span> <span class=\"n\">ct</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n  <span class=\"n\">for</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">tal.toArray.qsort</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n.1.toString</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m.1.toString</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">pad</span> <span class=\"o\">:=</span> <span class=\"n\">List.replicate</span> <span class=\"o\">(</span><span class=\"n\">lth</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">Nat.toDigits</span> <span class=\"mi\">10</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span> <span class=\"sc\">' '</span>\n    <span class=\"n\">dbg_trace</span> <span class=\"o\">(⟨</span><span class=\"n\">pad</span><span class=\"o\">⟩</span> <span class=\"bp\">++</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{t}  {m}\"</span><span class=\"o\">)</span>\n  <span class=\"n\">dbg_trace</span> <span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">{ct}  total\"</span>\n  <span class=\"k\">if</span> <span class=\"n\">tk.isSome</span> <span class=\"k\">then</span>\n    <span class=\"n\">dbg_trace</span> <span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">Declarations in '{id.getId}':</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span>\n    <span class=\"n\">for</span> <span class=\"n\">t</span> <span class=\"k\">in</span> <span class=\"n\">tot.toArray.qsort</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n.toString</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m.toString</span><span class=\"o\">)</span> <span class=\"k\">do</span> <span class=\"n\">dbg_trace</span> <span class=\"n\">t</span>\n</code></pre></div>",
        "id": 425213067,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1709777172
    },
    {
        "content": "<p>For instance, you get this, if you wait for a few seconds:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">tally</span> <span class=\"n\">Semiring</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">  1  Init.Core</span>\n<span class=\"cm\">  4  Init.Data</span>\n<span class=\"cm\">  1  Init.Meta</span>\n<span class=\"cm\">104  Init.Prelude</span>\n<span class=\"cm\"> 41  Mathlib.Algebra</span>\n<span class=\"cm\">  8  Mathlib.Init</span>\n<span class=\"cm\">  1  Std.Data</span>\n<span class=\"cm\">  1  [anonymous]</span>\n\n<span class=\"cm\">161  total</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"bp\">#</span><span class=\"n\">tally</span> <span class=\"n\">Real.sin</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">   9  Init.Classical</span>\n<span class=\"cm\">  25  Init.Control</span>\n<span class=\"cm\"> 132  Init.Core</span>\n<span class=\"cm\"> 489  Init.Data</span>\n<span class=\"cm\">   1  Init.Meta</span>\n<span class=\"cm\"> 317  Init.Prelude</span>\n<span class=\"cm\">  16  Init.PropLemmas</span>\n<span class=\"cm\">  51  Init.SimpLemmas</span>\n<span class=\"cm\">  13  Init.WF</span>\n<span class=\"cm\">1689  Mathlib.Algebra</span>\n<span class=\"cm\"> 471  Mathlib.Data</span>\n<span class=\"cm\">  28  Mathlib.GroupTheory</span>\n<span class=\"cm\"> 147  Mathlib.Init</span>\n<span class=\"cm\">  52  Mathlib.Logic</span>\n<span class=\"cm\"> 374  Mathlib.Order</span>\n<span class=\"cm\">   9  Mathlib.Tactic</span>\n<span class=\"cm\">   1  Mathlib.Topology</span>\n<span class=\"cm\">   5  Std.Classes</span>\n<span class=\"cm\"> 179  Std.Data</span>\n<span class=\"cm\">   2  Std.Logic</span>\n<span class=\"cm\">   1  [anonymous]</span>\n\n<span class=\"cm\">4011  total</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 425213091,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1709777192
    },
    {
        "content": "<p>Hi Damiano! That looks cool, but given the time it takes for <code>Real.sin</code>, I suspect <code>#tally hasSum_zeta_two</code> would probably be totally infeasible.</p>",
        "id": 425236540,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709793449
    },
    {
        "content": "<p>So maybe I was right to be pessimistic about (c), at least for the time being.</p>",
        "id": 425236688,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709793544
    },
    {
        "content": "<p>I think it is worth a shot. I would be surprised if it takes more than a few minutes</p>",
        "id": 425237029,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1709793750
    },
    {
        "content": "<p>It got there in the end (10 minutes or so). The final tally for <code>hasSum_zeta_two</code> is 19410. That's actually only about 10% of mathlib, I'm disappointed <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<p>I'd be curious to compare this with other heavyweight theorems in the library – can anyone find a single declaration with more than this many prerequisites?</p>",
        "id": 425239615,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709795097
    },
    {
        "content": "<p>I remember that we were initially quite disappointed to discover that perfectoid spaces were only four times as complex as real numbers! I would be tempted to try a theorem about group cohomology for this game. It wouldn't surprise me if it's pulling in a bunch of the algebra hierarchy and a bunch of category theory but right now I have no feeling for numbers.</p>\n<p>Actually perhaps the thing to do, now Mario has shaken mathlib, is to redo Scott's calculation of the longest pole and look in the leaf file. I found it very interesting that during the port the longest pole was changing between group cohomology and measure theory, it seemed like evidence that algebra and analysis were growing in complexity at similar rates.</p>",
        "id": 425240254,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709795487
    },
    {
        "content": "<p>With respect to speed: it is very likely that small tweaks could improve dramatically the running time.  I don't think that the code that I wrote is particularly efficient.</p>",
        "id": 425241866,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1709796283
    },
    {
        "content": "<p>I'll try running it on <code>groupCohomology.H1ofAutOnUnitsUnique</code> (Hilbert 90) and see how that compares.</p>",
        "id": 425242317,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709796459
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Counting.20prerequisites.20of.20a.20theorem/near/425242317\">said</a>:</p>\n<blockquote>\n<p>I'll try running it on <code>groupCohomology.H1ofAutOnUnitsUnique</code> (Hilbert 90) and see how that compares.</p>\n</blockquote>\n<p>Only 1611, so Hilbert 90 is \"easier\" than <code>Real.sin</code>. Just goes to show how little correlation there is between the order things are built from the axioms, and the order we teach them to students!</p>",
        "id": 425246398,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709798474
    },
    {
        "content": "<p>Ok, besides speed improvements, this answer on Hilbert 90 makes me wonder whether my code is missing anything.</p>",
        "id": 425247832,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1709799012
    },
    {
        "content": "<p>These are the declarations that it finds for H90.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>H90 -- first 400 lines</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>absurd\nAcc\nAcc.intro\nAction\nAction.forget\nAction.hasForgetToV\nAction.Hom\nAction.Hom.comm\nAction.Hom.comp\nAction.Hom.hom\nAction.Hom.id\nAction.Hom.mk\nAction.instCategoryAction\nAction.instConcreteCategoryActionInstCategoryAction\nAction.mk\nAction.V\nAction.ρ\nAdd\nAddAction\nAddAction.add_vadd\nAddAction.compHom\nAddAction.mk\nAddAction.orbit\nAddAction.orbitRel\nAddAction.toVAdd\nAddAction.zero_vadd\nAdd.add\nadd_assoc\nAddCancelMonoid\nAddCancelMonoid.add_right_cancel\nAddCancelMonoid.mk\nAddCancelMonoid.toAddLeftCancelMonoid\nAddCancelMonoid.toAddRightCancelMonoid\nadd_comm\nAddCommGroup\nAddCommGroup.add_comm\nAddCommGroup.intModule\nAddCommGroup.mk\nAddCommGroup.toAddCommMonoid\nAddCommGroup.toAddGroup\nAddCommGroup.toDivisionAddCommMonoid\nAddCommMagma\nAddCommMagma.add_comm\nAddCommMagma.mk\nAddCommMagma.toAdd\nAddCommMonoid\nAddCommMonoid.add_comm\nAddCommMonoid.mk\nAddCommMonoid.natModule\nAddCommMonoid.toAddCommSemigroup\nAddCommMonoid.toAddMonoid\nAddCommMonoidWithOne\nAddCommMonoidWithOne.add_comm\nAddCommMonoidWithOne.mk\nAddCommMonoidWithOne.toAddMonoidWithOne\nAddCommSemigroup\nAddCommSemigroup.add_comm\nAddCommSemigroup.mk\nAddCommSemigroup.toAddCommMagma\nAddCommSemigroup.toAddSemigroup\nAddCommute\nAddCommute.add_nsmul\nAddCommute.all\nAddCommute.eq\nAddCommute.nsmul_left\nAddCommute.nsmul_right\nAddCommute.right_comm\nAddCommute.symm\nAddEquiv\nAddEquiv.map_add&#39;\nAddEquiv.mk\nAddEquiv.refl\nAddEquiv.symm\nAddEquiv.symm_map_add\nAddEquiv.toAddHom\nAddEquiv.toEquiv\nAddEquiv.trans\nAddGroup\nAddGroup.add_left_neg\nAddGroup.int_smulCommClass\nAddGroup.mk\nAddGroup.toAddCancelMonoid\nAddGroup.toSubNegMonoid\nAddGroup.toSubtractionMonoid\nAddGroupWithOne\nAddGroupWithOne.add_left_neg\nAddGroupWithOne.intCast_negSucc\nAddGroupWithOne.intCast_ofNat\nAddGroupWithOne.mk\nAddGroupWithOne.sub_eq_add_neg\nAddGroupWithOne.toAddGroup\nAddGroupWithOne.toAddMonoidWithOne\nAddGroupWithOne.toIntCast\nAddGroupWithOne.toNeg\nAddGroupWithOne.toSub\nAddGroupWithOne.zsmul\nAddGroupWithOne.zsmul_neg&#39;\nAddGroupWithOne.zsmul_succ&#39;\nAddGroupWithOne.zsmul_zero&#39;\nAddHom\nAddHomClass\nAddHomClass.map_add\nAddHomClass.mk\nAddHom.funLike\nAddHom.inverse\nAddHom.map_add\nAddHom.map_add&#39;\nAddHom.mk\nAddHom.toFun\nAdditive\nAdditive.add\nAdditive.addCommGroup\nAdditive.addCommMonoid\nAdditive.addCommSemigroup\nAdditive.addGroup\nAdditive.addMonoid\nAdditive.addSemigroup\nAdditive.addZeroClass\nAdditive.neg\nAdditive.ofMul\nAdditive.sub\nAdditive.subNegMonoid\nAdditive.toMul\nAddLeftCancelMonoid\nAddLeftCancelMonoid.add_zero\nAddLeftCancelMonoid.mk\nAddLeftCancelMonoid.nsmul\nAddLeftCancelMonoid.nsmul_succ\nAddLeftCancelMonoid.nsmul_zero\nAddLeftCancelMonoid.toAddLeftCancelSemigroup\nAddLeftCancelMonoid.toZero\nAddLeftCancelMonoid.zero_add\nAddLeftCancelSemigroup\nAddLeftCancelSemigroup.add_left_cancel\nAddLeftCancelSemigroup.mk\nAddLeftCancelSemigroup.toAddSemigroup\nadd_left_neg\nAddMemClass\nAddMemClass.add_mem\nAddMemClass.mk\nAdd.mk\nAddMonoid\nAddMonoid.add_zero\nAddMonoid.End\nAddMonoid.End.instAddCommGroup\nAddMonoid.End.instAddCommMonoid\nAddMonoid.End.instRing\nAddMonoid.End.instSemiring\nAddMonoid.End.monoid\naddMonoidEndRingEquivInt\nAddMonoidHom\nAddMonoidHom.add\nAddMonoidHom.addCommGroup\nAddMonoidHom.addCommMonoid\nAddMonoidHomClass\nAddMonoidHomClass.mk\nAddMonoidHomClass.toAddHomClass\nAddMonoidHomClass.toZeroHomClass\nAddMonoidHom.comp\nAddMonoidHom.comp_assoc\nAddMonoidHom.comp_id\nAddMonoidHom.ext\nAddMonoidHom.id\nAddMonoidHom.id_comp\nAddMonoidHom.instAddMonoidHomClass\nAddMonoidHom.instDistribMulAction\nAddMonoidHom.instFunLike\nAddMonoidHom.instModule\nAddMonoidHom.instNegAddMonoidHomToAddZeroClassToAddMonoidToSubNegAddMonoidToAddGroup\nAddMonoidHom.instSubAddMonoidHomToAddZeroClassToAddMonoidToSubNegAddMonoidToAddGroup\naddMonoidHomLequivInt\nAddMonoidHom.map_add&#39;\nAddMonoidHom.map_zsmul\nAddMonoidHom.mk\nAddMonoidHom.mk&#39;\nAddMonoidHom.smulZeroClass\nAddMonoidHom.toIntLinearMap\nAddMonoidHom.toZeroHom\nAddMonoid.mk\nAddMonoid.nsmul\nAddMonoid.nsmul_succ\nAddMonoid.nsmul_zero\nAddMonoid.toAddSemigroup\nAddMonoid.toAddZeroClass\nAddMonoid.toNatSMul\nAddMonoid.toOppositeAddAction\nAddMonoid.toZero\nAddMonoidWithOne\nAddMonoidWithOne.mk\nAddMonoidWithOne.natCast_succ\nAddMonoidWithOne.natCast_zero\nAddMonoidWithOne.toAddMonoid\nAddMonoidWithOne.toNatCast\nAddMonoidWithOne.toOne\nAddMonoidWithOne.unary\nAddMonoid.zero_add\nAddOpposite\nAddOpposite.add\nAddOpposite.addGroup\nAddOpposite.addMonoid\nAddOpposite.addSemigroup\nAddOpposite.addZeroClass\nAddOpposite.neg\nAddOpposite.op\nAddOpposite.subNegMonoid\nAddOpposite.unop\nAddOpposite.zero\nAddRightCancelMonoid\nAddRightCancelMonoid.add_zero\nAddRightCancelMonoid.mk\nAddRightCancelMonoid.nsmul\nAddRightCancelMonoid.nsmul_succ\nAddRightCancelMonoid.nsmul_zero\nAddRightCancelMonoid.toAddRightCancelSemigroup\nAddRightCancelMonoid.toZero\nAddRightCancelMonoid.zero_add\nAddRightCancelSemigroup\nAddRightCancelSemigroup.add_right_cancel\nAddRightCancelSemigroup.mk\nAddRightCancelSemigroup.toAddSemigroup\nAddSemiconjBy\nAddSemiconjBy.add_right\nAddSemiconjBy.eq\nAddSemiconjBy.nsmul_right\nAddSemiconjBy.zero_right\nAddSemigroup\nAddSemigroup.add_assoc\nAddSemigroup.mk\nAddSemigroup.toAdd\nadd_smul\nAddSubgroup\nAddSubgroup.add\nAddSubgroupClass\nAddSubgroupClass.mk\nAddSubgroupClass.toAddSubmonoidClass\nAddSubgroupClass.toNegMemClass\nAddSubgroup.instAddAction\nAddSubgroup.instAddSubgroupClassAddSubgroupToSubNegAddMonoidInstSetLikeAddSubgroup\nAddSubgroup.instSetLikeAddSubgroup\nAddSubgroup.mk\nAddSubgroup.neg\nAddSubgroup.neg_mem&#39;\nAddSubgroup.nsmul\nAddSubgroup.op\nAddSubgroup.sub\nAddSubgroup.toAddCommGroup\nAddSubgroup.toAddGroup\nAddSubgroup.toAddSubmonoid\nAddSubgroup.zero\nAddSubgroup.zero_mem\nAddSubgroup.zsmul\nAddSubmonoid\nAddSubmonoid.add\nAddSubmonoid.addAction\nAddSubmonoidClass\nAddSubmonoidClass.mk\nAddSubmonoidClass.nSMul\nAddSubmonoidClass.toAddMemClass\nAddSubmonoidClass.toZeroMemClass\nAddSubmonoid.comap\nAddSubmonoid.instAddSubmonoidClassAddSubmonoidInstSetLikeAddSubmonoid\nAddSubmonoid.instBotAddSubmonoid\nAddSubmonoid.instSetLikeAddSubmonoid\nAddSubmonoid.instTopAddSubmonoid\nAddSubmonoid.map\nAddSubmonoid.mk\nAddSubmonoid.subtype\nAddSubmonoid.toAddCommMonoid\nAddSubmonoid.toAddMonoid\nAddSubmonoid.toAddSubsemigroup\nAddSubmonoid.toAddZeroClass\nAddSubmonoid.zero\nAddSubmonoid.zero_mem\nAddSubmonoid.zero_mem&#39;\nAddSubsemigroup\nAddSubsemigroup.add_mem&#39;\nAddSubsemigroup.carrier\nAddSubsemigroup.mk\nAdd.toHasOppositeVAdd\nadd_zero\nAddZeroClass\nAddZeroClass.add_zero\nAddZeroClass.mk\nAddZeroClass.toAdd\nAddZeroClass.toZero\nAddZeroClass.zero_add\nAlgebra\nAlgebra.commutes&#39;\nalgebraMap\nAlgebra.mk\nAlgebra.smul_def&#39;\nAlgebra.toModule\nAlgebra.toRingHom\nAlgebra.toSMul\nAlgEquiv\nAlgEquiv.aut\nAlgEquiv.commutes&#39;\nAlgEquiv.instEquivLikeAlgEquiv\nAlgEquiv.instFunLikeAlgEquiv\nAlgEquiv.instMulDistribMulActionAlgEquivUnitsToMonoidToMonoidWithZeroToMonoidToDivInvMonoidAutInstMonoid\nAlgEquiv.map_add&#39;\nAlgEquiv.map_mul&#39;\nAlgEquiv.mk\nAlgEquiv.refl\nAlgEquiv.symm\nAlgEquiv.toEquiv\nAlgEquiv.toRingEquiv\nAlgEquiv.trans\nAnd\nAnd.intro\nAnd.left\nAnd.right\n[anonymous]\nArray\nArray.data\nArray.mk\nautoParam\nBool\nBool.false\nBool.true\nBot\nBot.bot\nBot.mk\nCategoryTheory.Bundled\nCategoryTheory.BundledHom\nCategoryTheory.BundledHom.category\nCategoryTheory.BundledHom.comp\nCategoryTheory.BundledHom.comp_toFun\nCategoryTheory.BundledHom.hom_ext\nCategoryTheory.BundledHom.id\nCategoryTheory.BundledHom.id_toFun\nCategoryTheory.BundledHom.mk\nCategoryTheory.BundledHom.toFun\nCategoryTheory.Bundled.mk\nCategoryTheory.Bundled.of\nCategoryTheory.Bundled.str\nCategoryTheory.Bundled.α\nCategoryTheory.Category\nCategoryTheory.Category.assoc\nCategoryTheory.Category.comp_id\nCategoryTheory.Category.id_comp\nCategoryTheory.Category.mk\nCategoryTheory.CategoryStruct\nCategoryTheory.CategoryStruct.comp\nCategoryTheory.CategoryStruct.id\nCategoryTheory.CategoryStruct.mk\nCategoryTheory.CategoryStruct.toQuiver\nCategoryTheory.Category.toCategoryStruct\nCategoryTheory.ConcreteCategory\nCategoryTheory.ConcreteCategory.forget\nCategoryTheory.ConcreteCategory.forget_faithful\nCategoryTheory.ConcreteCategory.hasCoeToSort\nCategoryTheory.ConcreteCategory.mk\nCategoryTheory.End\nCategoryTheory.End.monoid\nCategoryTheory.End.mul\nCategoryTheory.End.one\nCategoryTheory.Faithful\nCategoryTheory.Faithful.map_injective\nCategoryTheory.Faithful.mk\nCategoryTheory.forget\nCategoryTheory.forget₂\nCategoryTheory.Functor\nCategoryTheory.Functor.comp\nCategoryTheory.Functor.map_comp\nCategoryTheory.Functor.map_id\nCategoryTheory.Functor.mk\nCategoryTheory.Functor.toPrefunctor\nCategoryTheory.HasForget₂\nCategoryTheory.HasForget₂.forget₂\nCategoryTheory.HasForget₂.forget_comp\nCategoryTheory.HasForget₂.mk\nCategoryTheory.LargeCategory\nCategoryTheory.types\nChar\nChar.mk\nChar.val\nChar.valid\ncoe_nat_zsmul\nCoeSort\nCoeSort.coe\nCoeSort.mk\nCommGroup\nCommGroup.mk\nCommGroup.mul_comm\nCommGroup.toCommMonoid\nCommGroup.toGroup\nCommGroupWithZero\nCommGroupWithZero.div_eq_mul_inv\nCommGroupWithZero.inv_zero\nCommGroupWithZero.mk\nCommGroupWithZero.mul_inv_cancel\nCommGroupWithZero.toCommMonoidWithZero\nCommGroupWithZero.toDiv\nCommGroupWithZero.toInv\nCommGroupWithZero.toNontrivial\nCommGroupWithZero.zpow\nCommGroupWithZero.zpow_neg&#39;\nCommGroupWithZero.zpow_succ&#39;\nCommGroupWithZero.zpow_zero&#39;\n</code></pre></div>\n</div></div>",
        "id": 425249438,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1709799394
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>second batch</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>CommMonoid\nCommMonoid.mk\nCommMonoid.mul_comm\nCommMonoid.toCommSemigroup\nCommMonoid.toMonoid\nCommMonoidWithZero\nCommMonoidWithZero.mk\nCommMonoidWithZero.mul_zero\nCommMonoidWithZero.toCommMonoid\nCommMonoidWithZero.toZero\nCommMonoidWithZero.zero_mul\nCommRing\nCommRing.mk\nCommRing.mul_comm\nCommRing.toCommMonoid\nCommRing.toCommSemiring\nCommRing.toNonUnitalCommRing\nCommRing.toRing\nCommSemigroup\nCommSemigroup.mk\nCommSemigroup.mul_comm\nCommSemigroup.toSemigroup\nCommSemiring\nCommSemiring.mk\nCommSemiring.mul_comm\nCommSemiring.toSemiring\ncongr\ncongrArg\nDecidable\nDecidable.decide\nDecidableEq\nDecidable.isFalse\nDecidable.isTrue\ndecide_eq_false\nDFunLike\nDFunLike.coe\nDFunLike.coe_injective&#39;\nDFunLike.ext\nDFunLike.mk\nDistrib\nDistrib.left_distrib\nDistrib.mk\nDistribMulAction\nDistribMulActionHom\nDistribMulActionHom.id\nDistribMulActionHom.map_add&#39;\nDistribMulActionHom.map_zero&#39;\nDistribMulActionHom.mk\nDistribMulActionHom.toMulActionHom\nDistribMulAction.mk\nDistribMulAction.smul_add\nDistribMulAction.smul_zero\nDistribMulAction.toAddMonoidHom\nDistribMulAction.toDistribSMul\nDistribMulAction.toMulAction\nDistrib.right_distrib\nDistribSMul\nDistribSMul.mk\nDistribSMul.smul_add\nDistribSMul.toAddMonoidHom\nDistribSMul.toSMulZeroClass\nDistrib.toAdd\nDistrib.toMul\nDiv\nDiv.div\ndiv_eq_mul_inv\nDivInvMonoid\nDivInvMonoid.div&#39;\nDivInvMonoid.div_eq_mul_inv\nDivInvMonoid.mk\nDivInvMonoid.toDiv\nDivInvMonoid.toInv\nDivInvMonoid.toMonoid\nDivInvMonoid.zpow\nDivInvMonoid.zpow_neg&#39;\nDivInvMonoid.zpow_succ&#39;\nDivInvMonoid.zpow_zero&#39;\nDivInvOneMonoid\nDivInvOneMonoid.inv_one\nDivInvOneMonoid.mk\nDivInvOneMonoid.toDivInvMonoid\nDivInvOneMonoid.toInvOneClass\nDivisionMonoid\nDivisionMonoid.inv_eq_of_mul\nDivisionMonoid.inv_inv\nDivisionMonoid.mk\nDivisionMonoid.mul_inv_rev\nDivisionMonoid.toDivInvMonoid\nDivisionMonoid.toDivInvOneMonoid\nDivisionRing\nDivisionRing.div_eq_mul_inv\nDivisionRing.inv_zero\nDivisionRing.mk\nDivisionRing.mul_inv_cancel\nDivisionRing.qsmul\nDivisionRing.qsmul_eq_mul&#39;\nDivisionRing.ratCast_mk\nDivisionRing.toDiv\nDivisionRing.toDivisionSemiring\nDivisionRing.toInv\nDivisionRing.toNontrivial\nDivisionRing.toRatCast\nDivisionRing.toRing\nDivisionRing.zpow\nDivisionRing.zpow_neg&#39;\nDivisionRing.zpow_succ&#39;\nDivisionRing.zpow_zero&#39;\nDivisionSemiring\nDivisionSemiring.div_eq_mul_inv\nDivisionSemiring.inv_zero\nDivisionSemiring.mk\nDivisionSemiring.mul_inv_cancel\nDivisionSemiring.toDiv\nDivisionSemiring.toInv\nDivisionSemiring.toNontrivial\nDivisionSemiring.toSemiring\nDivisionSemiring.zpow\nDivisionSemiring.zpow_neg&#39;\nDivisionSemiring.zpow_succ&#39;\nDivisionSemiring.zpow_zero&#39;\nDiv.mk\nEq\neq_false\neq_false&#39;\nEq.mp\nEq.mpr\neq_neg_of_add_eq_zero_left\nEq.propIntro\nEq.refl\neq_self\nEq.subst\nEq.symm\nEq.trans\neq_true\nEquiv\nEquivalence\nEquivalence.mk\nEquivalence.refl\nEquivalence.symm\nEquivalence.trans\nEquiv.instFunLikeEquiv\nEquiv.invFun\nEquiv.left_inv\nEquivLike\nEquivLike.coe\nEquivLike.coe_injective&#39;\nEquivLike.inv\nEquivLike.left_inv\nEquivLike.mk\nEquivLike.right_inv\nEquivLike.toFunLike\nEquiv.mk\nEquiv.refl\nEquiv.right_inv\nEquiv.symm\nEquiv.toFun\nEquiv.trans\nEuclideanDomain\nEuclideanDomain.mk\nEuclideanDomain.mul_left_not_lt\nEuclideanDomain.quotient\nEuclideanDomain.quotient_mul_add_remainder_eq\nEuclideanDomain.quotient_zero\nEuclideanDomain.r\nEuclideanDomain.remainder\nEuclideanDomain.remainder_lt\nEuclideanDomain.r_wellFounded\nEuclideanDomain.toCommRing\nEuclideanDomain.toNontrivial\nExists\nExists.intro\nFalse\nFalse.elim\nField\nField.div_eq_mul_inv\nField.inv_zero\nField.mk\nField.mul_inv_cancel\nField.qsmul\nField.qsmul_eq_mul&#39;\nField.ratCast_mk\nField.toCommRing\nField.toDiv\nField.toDivisionRing\nField.toEuclideanDomain\nField.toInv\nField.toNontrivial\nField.toRatCast\nField.toSemifield\nField.zpow\nField.zpow_neg&#39;\nField.zpow_succ&#39;\nField.zpow_zero&#39;\nFin\nFin.isLt\nFiniteDimensional\nFin.mk\nFinset\nFinset.instMembershipFinset\nFinset.mk\nFinset.nodup\nFinset.toSet\nFinset.val\nFin.val\nFunction.comp\nFunction.Injective\nFunction.Injective.addCommGroup\nFunction.Injective.addCommMagma\nFunction.Injective.addCommMonoid\nFunction.Injective.addCommSemigroup\nFunction.Injective.addGroup\nFunction.Injective.addMonoid\nFunction.Injective.addSemigroup\nFunction.Injective.addZeroClass\nFunction.Injective.subNegMonoid\nFunction.LeftInverse\nFunction.RightInverse\nFunction.Surjective\nfunext\nFunLike\nGE.ge\nGroup\ngroupCohomology.dOne\ngroupCohomology.dZero\ngroupCohomology.H1\ngroupCohomology.H1ofAutOnUnitsUnique\ngroupCohomology.oneCoboundaries\ngroupCohomology.oneCocycles\nGroup.mk\nGroup.mul_left_inv\nGroup.toDivInvMonoid\nGroup.toDivisionMonoid\nGT.gt\nHAdd\nHAdd.hAdd\nHAdd.mk\nHasQuotient\nHasQuotient.mk\nHasQuotient.quotient&#39;\nHasQuotient.Quotient\nHasSubset\nHasSubset.mk\nHasSubset.Subset\nHDiv\nHDiv.hDiv\nHDiv.mk\nHEq\nHEq.refl\nHMul\nHMul.hMul\nHMul.mk\nHPow\nHPow.hPow\nHPow.mk\nHSMul\nHSMul.hSMul\nHSMul.mk\nHSub\nHSub.hSub\nHSub.mk\nHVAdd\nHVAdd.hVAdd\nHVAdd.mk\nid\nIff\nIff.intro\nIff.mp\nIff.mpr\niInf\ninferInstance\ninferInstanceAs\nInfSet\nInfSet.mk\nInfSet.sInf\nInhabited\nInhabited.default\nInhabited.mk\ninstAddNat\ninstDecidableEqNat\ninstHAdd\ninstHDiv\ninstHMul\ninstHPow\ninstHSMul\ninstHSub\ninstHVAdd\ninstLENat\ninstLTNat\ninstMonCatLargeCategory\ninstMulNat\ninstNatCastInt\ninstNatPowNat\ninstOfNat\ninstOfNatNat\ninstPowNat\ninstSubNat\ninstTransEq\ninstZeroAdditive\ninstZeroAddMonoidHom\nInt\nInt.add\nInt.add_assoc\nInt.add_assoc.aux1\nInt.add_assoc.aux2\nInt.add_comm\nInt.add_left_neg\nInt.add_mul\nInt.add_zero\nInt.cast\nIntCast\nIntCast.intCast\nIntCast.mk\nInt.instAddInt\nInt.instCommRingInt\nInt.instCommSemiringInt\nInt.instHPowIntNat\nInt.instMulInt\nInt.instNegInt\nInt.instRingInt\nInt.instSemiringInt\nInt.instSubInt\nInt.mul\nInt.mul_add\nInt.mul_assoc\nInt.mul_comm\nInt.mul_one\nInt.mul_zero\nInt.natAbs\nInt.neg\nInt.negOfNat\nInt.negOfNat_add\nInt.negOfNat_eq_subNatNat_zero\nInt.negOfNat_mul_negSucc\nInt.negOfNat_mul_ofNat\nInt.neg_ofNat_succ\nInt.negSucc\nInt.negSucc.injEq\nInt.negSucc_mul_negOfNat\nInt.negSucc_mul_ofNat\nInt.negSucc_mul_subNatNat\nInt.ofNat\nInt.ofNat_eq_coe\nInt.ofNat_mul_negOfNat\nInt.ofNat_mul_subNatNat\nInt.ofNat_zero\nInt.one_mul\nInt.pow\nInt.sub\nInt.sub_eq_add_neg\nInt.subNatNat\nInt.subNatNat_add\nInt.subNatNat_add_add\nInt.subNatNat_add_left\nInt.subNatNat_add_negSucc\nInt.subNatNat_add_right\nInt.subNatNat_elim\nInt.subNatNat_of_le\nInt.subNatNat_of_lt\nInt.subNatNat_of_sub_eq_succ\nInt.subNatNat_of_sub_eq_zero\nInt.subNatNat_self\nInt.subNatNat_sub\nInt.zero_add\nInt.zero_mul\nInv\nInv.inv\nInv.mk\nInvolutiveNeg\nInvolutiveNeg.mk\nInvolutiveNeg.neg_neg\nInvolutiveNeg.toNeg\nInvOneClass\nInvOneClass.inv_one\nInvOneClass.mk\nInvOneClass.toInv\nInvOneClass.toOne\nIsScalarTower\nIsScalarTower.mk\nIsScalarTower.smul_assoc\nLE\nLean.Module\nLean.Module.commands\nLean.Module.header\nLean.Module.mk\nLean.Name\nLean.Name.anonymous\nLean.Name.num\nLean.Name.str\nLean.SourceInfo\nLean.SourceInfo.none\nLean.SourceInfo.original\nLean.SourceInfo.synthetic\nLean.Syntax\nLean.Syntax.atom\nLean.Syntax.ident\nLean.Syntax.missing\nLean.Syntax.node\nLean.SyntaxNodeKind\nLean.Syntax.Preresolved\nLean.Syntax.Preresolved.decl\nLean.Syntax.Preresolved.namespace\nLE.le\nLE.mk\nletFun\nLinearEquiv\nLinearEquiv.invFun\nLinearEquiv.left_inv\nLinearEquiv.mk\nLinearEquiv.right_inv\nLinearEquiv.toLinearMap\nLinearMap\nLinearMap.addCommMonoid\nLinearMap.codRestrict\nLinearMap.comp\nLinearMap.id\nLinearMap.instAddLinearMap\nLinearMap.instDistribMulActionLinearMapToAddMonoidAddCommMonoid\nLinearMap.instFunLike\nLinearMap.instMulEnd\nLinearMap.instOneEnd\nLinearMap.instSMulLinearMap\nLinearMap.instZeroLinearMap\nLinearMap.ker\nLinearMap.map_add\nLinearMap.map_smul&#39;\nLinearMap.map_zero\nLinearMap.mk\nLinearMap.module\nLinearMap.range\nLinearMap.semilinearMapClass\nLinearMap.toAddHom\nLinearMap.toAddMonoidHom\nList\nList.below\nList.cons\nList.head\nList.instMembershipList\nList.isSetoid\nList.Mem\nList.Mem.head\nList.Mem.tail\nList.nil\nList.Nodup\nList.Pairwise\nList.Pairwise.cons\nList.Pairwise.nil\nList.Perm\nList.Perm.cons\nList.Perm.eqv\nList.Perm.nil\nList.Perm.refl\nList.Perm.swap\nList.Perm.symm\nList.Perm.trans\nList.tail\nLT\nLT.lt\nLT.mk\nmap_add\nmap_add_eq_zero\nmap_neg\nmap_nsmul\nmap_zero\nmap_zsmul\nmap_zsmul&#39;\nMembership\nMembership.mem\nMembership.mk\nModule\nModule.add_smul\nModuleCat\nModuleCat.carrier\nModuleCat.isAddCommGroup\nModuleCat.isModule\nModuleCat.mk\nModuleCat.moduleCategory\nModuleCat.moduleConcreteCategory\nModuleCat.of\nModule.End\nModule.End.monoid\nModule.End.semiring\nModule.Finite\nModule.Finite.mk\nModule.Finite.out\nModule.mk\nModule.toDistribMulAction\nModule.toMulActionWithZero\nModule.zero_smul\nMonCat\nMonCat.AssocMonoidHom\nMonCat.bundledHom\nMonCat.instMonoidα\nMonCat.of\nMonoid\nMonoid.End\nMonoid.End.instMonoidEnd\nmonoidEndToAdditive\nMonoidHom\nMonoidHomClass\nMonoidHomClass.mk\n</code></pre></div>\n</div></div>",
        "id": 425249725,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1709799529
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>third batch</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>MonoidHomClass.toMonoidHom\nMonoidHomClass.toMulHomClass\nMonoidHomClass.toOneHomClass\nMonoidHom.comp\nMonoidHom.comp_assoc\nMonoidHom.comp_id\nMonoidHom.ext\nMonoidHom.id\nMonoidHom.id_comp\nMonoidHom.instFunLike\nMonoidHom.map_mul\nMonoidHom.map_mul&#39;\nMonoidHom.map_one\nMonoidHom.mk\nMonoidHom.mk&#39;\nMonoidHom.toAdditive\nMonoidHom.toOneHom\nMonoid.mk\nMonoid.mul_one\nMonoid.npow\nMonoid.npow_succ\nMonoid.npow_zero\nMonoid.one_mul\nMonoid.toMulOneClass\nMonoid.toNatPow\nMonoid.toOne\nMonoid.toSemigroup\nMonoidWithZero\nMonoidWithZeroHomClass\nMonoidWithZeroHomClass.mk\nMonoidWithZeroHomClass.toMonoidHomClass\nMonoidWithZeroHomClass.toZeroHomClass\nMonoidWithZero.mk\nMonoidWithZero.mul_zero\nMonoidWithZero.toMonoid\nMonoidWithZero.toZero\nMonoidWithZero.zero_mul\nmt\nMul\nMulAction\nMulActionHom\nMulActionHom.id\nMulActionHom.map_smul&#39;\nMulActionHom.mk\nMulActionHom.toFun\nMulAction.mk\nMulAction.mul_smul\nMulAction.one_smul\nMulAction.toSMul\nMulActionWithZero\nMulActionWithZero.mk\nMulActionWithZero.smul_zero\nMulActionWithZero.toMulAction\nMulActionWithZero.toSMulWithZero\nMulActionWithZero.zero_smul\nmul_assoc\nMulDistribMulAction\nMulDistribMulAction.mk\nMulDistribMulAction.smul_mul\nMulDistribMulAction.smul_one\nMulDistribMulAction.toMonoidEnd\nMulDistribMulAction.toMonoidHom\nMulDistribMulAction.toMulAction\nMulEquiv\nMulEquiv.instEquivLikeMulEquiv\nMulEquiv.map_mul&#39;\nMulEquiv.mk\nMulEquiv.refl\nMulEquiv.symm\nMulEquiv.symm_map_mul\nMulEquiv.toEquiv\nMulEquiv.toMulHom\nMulEquiv.trans\nMulHom\nMulHomClass\nMulHomClass.map_mul\nMulHomClass.mk\nMulHomClass.toMulHom\nMulHom.comp\nMulHom.funLike\nMulHom.inverse\nMulHom.map_mul\nMulHom.map_mul&#39;\nMulHom.mk\nMulHom.toFun\nmul_left_inv\nMul.mk\nMul.mul\nmul_one\nMulOneClass\nMulOneClass.mk\nMulOneClass.mul_one\nMulOneClass.one_mul\nMulOneClass.toMul\nMulOneClass.toOne\nMultiplicative\nMultiplicative.ofAdd\nMultiset\nMultiset.instMembershipMultiset\nMultiset.Mem\nMultiset.Nodup\nMulZeroClass\nMulZeroClass.mk\nMulZeroClass.mul_zero\nMulZeroClass.toMul\nMulZeroClass.toSMulWithZero\nMulZeroClass.toZero\nMulZeroClass.zero_mul\nMulZeroOneClass\nMulZeroOneClass.mk\nMulZeroOneClass.mul_zero\nMulZeroOneClass.toMulOneClass\nMulZeroOneClass.toZero\nMulZeroOneClass.zero_mul\nNat\nNat.add\nNat.add_assoc\nNat.add_comm\nNat.add_le_add_left\nNat.add_left_comm\nNat.add_lt_add_left\nNat.add_right_comm\nNat.add_sub_add_left\nNat.add_sub_add_right\nNat.add_sub_assoc\nNat.add_sub_cancel\nNat.add_sub_cancel_left\nNat.add_sub_of_le\nNat.add_succ\nNat.add_zero\nNat.below\nNat.beq\nNat.cast\nNatCast\nNatCast.mk\nNatCast.natCast\nNat.commSemiring\nNat.Coprime\nNat.decEq\nNat.eq_of_beq_eq_true\nNat.eq_or_lt_of_le\nNat.eq_zero_or_pos\nNat.gcd\nNat.gt_of_not_le\nNat.isValidChar\nNat.le\nNat.le_add_left\nNat.le_add_right\nNat.le_antisymm\nNat.le.dest\nNat.left_distrib\nNat.le.intro\nNat.le_of_lt\nNat.le_of_sub_eq_zero\nNat.le_of_succ_le\nNat.le_of_succ_le_succ\nNat.le.refl\nNat.le_refl\nNat.le.step\nNat.le_step\nNat.le_succ\nNat.le_succ_of_le\nNat.le_trans\nNat.lt\nNat.lt_irrefl\nNat.lt_of_le_of_lt\nNat.lt_of_lt_of_le\nNat.lt_of_sub_eq_succ\nNat.lt_of_sub_ne_zero\nNat.lt_of_sub_pos\nNat.lt_of_succ_le\nNat.lt_of_succ_lt_succ\nNat.lt_or_ge\nNat.lt_trans\nNat.monoid\nNat.mul\nNat.mul_assoc\nNat.mul_comm\nNat.mul_le_mul_left\nNat.mul_lt_mul_of_pos_left\nNat.mul_one\nNat.mul_pred_left\nNat.mul_sub_left_distrib\nNat.mul_sub_right_distrib\nNat.mul_succ\nNat.mul_zero\nNat.ne_of_beq_eq_false\nNat.ne_of_gt\nNat.ne_of_lt\nNat.not_le\nNat.not_le_of_gt\nNat.not_lt_zero\nNat.not_succ_le_self\nNat.not_succ_le_zero\nNat.one_mul\nNat.pos_iff_ne_zero\nNat.pos_of_ne_zero\nNat.pow\nNatPow\nNatPow.mk\nNatPow.pow\nNat.pow_succ\nNat.pow_succ&#39;\nNat.pow_zero\nNat.pred\nNat.pred_le_pred\nNat.pred_succ\nNat.right_distrib\nNat.semiring\nNat.sub\nNat.sub_add_cancel\nNat.sub_eq_iff_eq_add\nNat.sub_eq_zero_of_le\nNat.sub_ne_zero_of_lt\nNat.sub_pos_of_lt\nNat.sub_self\nNat.sub_self_add\nNat.sub_sub\nNat.sub_succ\nNat.sub_zero\nNat.succ\nNat.succ_add\nNat.succ_le_of_lt\nNat.succ_le_succ\nNat.succ_mul\nNat.succ_pos\nNat.succ_pred\nNat.succ_pred_eq_of_pos\nNat.succ_sub\nNat.succ_sub_succ\nNat.succ_sub_succ_eq_sub\nNat.unaryCast\nNat.zero\nNat.zero_add\nNat.zero_le\nNat.zero_lt_succ\nNat.zero_mul\nNat.zero_sub\nNe\nNeg\nneg_add_self\nneg_eq_of_add_eq_zero_left\nneg_eq_of_add_eq_zero_right\nNegMemClass\nNegMemClass.mk\nNegMemClass.neg_mem\nNeg.mk\nneg_neg\nNeg.neg\nneg_one_smul\nneg_smul\nnegSucc_zsmul\nNegZeroClass\nNegZeroClass.mk\nNegZeroClass.neg_zero\nNegZeroClass.toNeg\nNegZeroClass.toZero\nNe.symm\nne_true_of_eq_false\nNonAssocRing\nNonAssocRing.intCast_negSucc\nNonAssocRing.intCast_ofNat\nNonAssocRing.mk\nNonAssocRing.mul_one\nNonAssocRing.natCast_succ\nNonAssocRing.natCast_zero\nNonAssocRing.one_mul\nNonAssocRing.toIntCast\nNonAssocRing.toNatCast\nNonAssocRing.toNonUnitalNonAssocRing\nNonAssocRing.toOne\nNonAssocSemiring\nNonAssocSemiring.mk\nNonAssocSemiring.mul_one\nNonAssocSemiring.natCast_succ\nNonAssocSemiring.natCast_zero\nNonAssocSemiring.one_mul\nNonAssocSemiring.toAddCommMonoidWithOne\nNonAssocSemiring.toMulZeroOneClass\nNonAssocSemiring.toNatCast\nNonAssocSemiring.toNonUnitalNonAssocSemiring\nNonAssocSemiring.toOne\nNontrivial\nNontrivial.exists_pair_ne\nNontrivial.mk\nNonUnitalCommRing\nNonUnitalCommRing.mk\nNonUnitalCommRing.mul_comm\nNonUnitalCommRing.toNonUnitalNonAssocCommRing\nNonUnitalCommRing.toNonUnitalRing\nNonUnitalNonAssocCommRing\nNonUnitalNonAssocCommRing.mk\nNonUnitalNonAssocCommRing.mul_comm\nNonUnitalNonAssocCommRing.toNonUnitalNonAssocRing\nNonUnitalNonAssocRing\nNonUnitalNonAssocRing.left_distrib\nNonUnitalNonAssocRing.mk\nNonUnitalNonAssocRing.mul_zero\nNonUnitalNonAssocRing.right_distrib\nNonUnitalNonAssocRing.toAddCommGroup\nNonUnitalNonAssocRing.toMul\nNonUnitalNonAssocRing.toNonUnitalNonAssocSemiring\nNonUnitalNonAssocRing.zero_mul\nNonUnitalNonAssocSemiring\nNonUnitalNonAssocSemiring.left_distrib\nNonUnitalNonAssocSemiring.mk\nNonUnitalNonAssocSemiring.mul_zero\nNonUnitalNonAssocSemiring.right_distrib\nNonUnitalNonAssocSemiring.toAddCommMonoid\nNonUnitalNonAssocSemiring.toDistrib\nNonUnitalNonAssocSemiring.toMul\nNonUnitalNonAssocSemiring.toMulZeroClass\nNonUnitalNonAssocSemiring.zero_mul\nNonUnitalRing\nNonUnitalRingHom\nNonUnitalRingHom.comp\nNonUnitalRingHom.map_add&#39;\nNonUnitalRingHom.map_zero&#39;\nNonUnitalRingHom.mk\nNonUnitalRingHom.toAddMonoidHom\nNonUnitalRingHom.toMulHom\nNonUnitalRing.mk\nNonUnitalRing.mul_assoc\nNonUnitalRing.toNonUnitalNonAssocRing\nNonUnitalSemiring\nNonUnitalSemiring.mk\nNonUnitalSemiring.mul_assoc\nNonUnitalSemiring.toNonUnitalNonAssocSemiring\nNot\nnot_false_eq_true\nnpowRec\nnsmul_add\nof_decide_eq_true\nof_eq_true\nOfNat\nOfNat.mk\nOfNat.ofNat\nOne\nOneHom\nOneHomClass\nOneHomClass.map_one\nOneHomClass.mk\nOneHomClass.toOneHom\nOneHom.map_one&#39;\nOneHom.mk\nOneHom.toFun\nOne.mk\none_mul\nOne.ofOfNat1\nOne.one\none_smul\nOne.toOfNat1\noptParam\nOr\nOr.elim\nOr.inl\nOr.inr\nOr.resolve_left\nOr.resolve_right\noutParam\nPi.addCommGroup\nPi.addCommMonoid\nPi.addCommSemigroup\nPi.addGroup\nPi.addMonoid\nPi.addSemigroup\nPi.addZeroClass\nPi.distribMulAction\nPi.distribSMul\nPi.instAdd\nPi.instNeg\nPi.instSMul\nPi.instSub\nPi.instZero\nPi.module\nPi.mulAction\nPi.subNegMonoid\nPow\nPow.mk\nPow.pow\nPProd\nPProd.fst\nPProd.mk\nPProd.snd\nPrefunctor\nPrefunctor.map\nPrefunctor.mk\nPrefunctor.obj\nPreOpposite\nPreOpposite.op&#39;\nPreOpposite.unop&#39;\nProd\nProd.fst\nProd.mk\nProd.snd\npropext\nPSigma\nPSigma.fst\nPSigma.mk\nPSigma.snd\nPUnit\nPUnit.unit\nQuiver\nQuiver.Hom\nQuiver.mk\nQuot\nQuotient\nQuotientAddGroup.leftRel\nQuotient.mk&#39;&#39;\nQuot.lift\nQuot.liftOn\nQuot.mk\nQuot.sound\nRat\nRat.cast\nRatCast\nRatCast.mk\nRatCast.ratCast\nRat.den\nRat.den_nz\nRat.mk&#39;\nRat.num\nRat.reduced\nRep\nRep.instAddCommGroupCoeRepToRingTypeInstCoeSortRepToRingType\nRep.instCoeSortRepToRingType\nRep.instModuleCoeRepToRingTypeInstCoeSortRepToRingTypeToSemiringToCommSemiringToAddCommMonoidInstAddCommGroupCoeRepToRingTypeInstCoeSortRepToRingType\nRep.of\nRep.ofAlgebraAutOnUnits\nRep.ofMulDistribMulAction\nRepresentation\nRepresentation.ofMulDistribMulAction\nRep.ρ\nrfl\nRing\nRing.add_left_neg\nRingAut\nRingAut.instGroupRingAut\nRingEquiv\nRingEquiv.instEquivLikeRingEquiv\nRingEquiv.map_add&#39;\nRingEquiv.map_mul&#39;\nRingEquiv.mk\nRingEquiv.refl\nRingEquiv.symm\nRingEquiv.toAddEquiv\nRingEquiv.toEquiv\nRingEquiv.toMulEquiv\nRingEquiv.trans\nRingHom\nRingHomClass\nRingHomClass.mk\nRingHomClass.toAddMonoidHomClass\nRingHomClass.toMonoidHomClass\nRingHomClass.toMonoidWithZeroHomClass\nRingHom.comp\nRingHomCompTriple\nRingHomCompTriple.comp_eq\nRingHomCompTriple.mk\nRingHom.id\nRingHom.instFunLike\nRingHom.instRingHomClass\nRingHomInvPair\nRingHomInvPair.comp_eq\nRingHomInvPair.comp_eq₂\nRingHomInvPair.ids\nRingHomInvPair.mk\nRingHom.map_add&#39;\nRingHom.map_zero&#39;\nRingHom.mk\nRingHomSurjective\nRingHomSurjective.is_surjective\nRingHomSurjective.mk\nRingHom.toMonoidHom\nRingHom.toNonUnitalRingHom\nRing.intCast_negSucc\nRing.intCast_ofNat\nRing.mk\nRing.sub_eq_add_neg\nRing.toAddCommGroup\nRing.toAddGroupWithOne\nRing.toIntCast\nRing.toNeg\nRing.toNonAssocRing\nRing.toSemiring\nRing.toSub\nRing.zsmul\nRing.zsmul_neg&#39;\nRing.zsmul_succ&#39;\nRing.zsmul_zero&#39;\nSemifield\nSemifield.div_eq_mul_inv\nSemifield.inv_zero\nSemifield.mk\nSemifield.mul_inv_cancel\nSemifield.toCommGroupWithZero\nSemifield.toCommSemiring\nSemifield.toDiv\nSemifield.toDivisionSemiring\nSemifield.toInv\n</code></pre></div>\n</div></div>",
        "id": 425249823,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1709799571
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>final batch</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>Semifield.toNontrivial\nSemifield.zpow\nSemifield.zpow_neg&#39;\nSemifield.zpow_succ&#39;\nSemifield.zpow_zero&#39;\nSemigroup\nSemigroup.mk\nSemigroup.mul_assoc\nSemigroup.toMul\nSemilinearMapClass\nSemilinearMapClass.instAddMonoidHomClass\nSemilinearMapClass.map_smulₛₗ\nSemilinearMapClass.mk\nSemilinearMapClass.toAddHomClass\nSemiring\nSemiring.mk\nSemiring.mul_one\nSemiring.natCast_succ\nSemiring.natCast_zero\nSemiring.npow\nSemiring.npow_succ\nSemiring.npow_zero\nSemiring.one_mul\nSemiring.toMonoidWithZero\nSemiring.toNatCast\nSemiring.toNonAssocSemiring\nSemiring.toNonUnitalSemiring\nSemiring.toOne\nSet\nSet.iInter\nSet.image\nSet.instHasSubsetSet\nSet.instInfSetSet\nSet.instLESet\nSet.instMembershipSet\nSet.instSingletonSet\nSetLike\nSetLike.coe\nSetLike.coe_injective&#39;\nSetLike.instMembership\nSetLike.mk\nSet.Mem\nsetOf\nSetoid\nSetoid.iseqv\nSetoid.mk\nSetoid.r\nSet.preimage\nSet.range\nSet.singleton\nSet.Subset\nSet.univ\nSingleton\nSingleton.mk\nSingleton.singleton\nSMul\nSMulCommClass\nSMulCommClass.mk\nSMulCommClass.smul_comm\nSMul.mk\nsmul_mul&#39;\nSMul.smul\nSMulWithZero\nSMulWithZero.mk\nSMulWithZero.toSMulZeroClass\nSMulWithZero.zero_smul\nSMulZeroClass\nSMulZeroClass.mk\nSMulZeroClass.smul_zero\nSMulZeroClass.toSMul\nSMulZeroClass.toZeroHom\nString\nString.data\nString.mk\nString.Pos\nString.Pos.byteIdx\nString.Pos.mk\nSub\nSub.mk\nSubmodule\nSubmodule.addCommGroup\nSubmodule.addCommMonoid\nSubmodule.addSubgroupClass\nSubmodule.addSubmonoidClass\nSubmodule.comap\nSubmodule.copy\nSubmodule.FG\nSubmodule.hasQuotient\nSubmodule.instBotSubmodule\nSubmodule.instInfSetSubmodule\nSubmodule.instTopSubmodule\nSubmodule.map\nSubmodule.mk\nSubmodule.module\nSubmodule.module&#39;\nSubmodule.neg_mem\nSubmodule.Quotient.instZeroQuotientSubmoduleToSemiringToAddCommMonoidHasQuotient\nSubmodule.quotientRel\nSubmodule.setLike\nSubmodule.smul_mem&#39;\nSubmodule.span\nSubmodule.toAddSubgroup\nSubmodule.toAddSubmonoid\nSubmodule.toSubMulAction\nSubMulAction\nSubMulAction.carrier\nSubMulAction.instSetLikeSubMulAction\nSubMulAction.mk\nSubMulAction.mulAction&#39;\nSubMulAction.neg_mem\nSubMulAction.smul&#39;\nSubMulAction.smul_mem\nSubMulAction.smul_mem&#39;\nSubNegMonoid\nSubNegMonoid.mk\nSubNegMonoid.SMulInt\nSubNegMonoid.sub&#39;\nSubNegMonoid.sub_eq_add_neg\nSubNegMonoid.toAddMonoid\nSubNegMonoid.toNeg\nSubNegMonoid.toSub\nSubNegMonoid.zsmul\nSubNegMonoid.zsmul_neg&#39;\nSubNegMonoid.zsmul_succ&#39;\nSubNegMonoid.zsmul_zero&#39;\nSubNegZeroMonoid\nSubNegZeroMonoid.mk\nSubNegZeroMonoid.neg_zero\nSubNegZeroMonoid.toNegZeroClass\nSubNegZeroMonoid.toSubNegMonoid\nSubstring\nSubstring.mk\nSubstring.startPos\nSubstring.stopPos\nSubstring.str\nSub.sub\nSubtractionCommMonoid\nSubtractionCommMonoid.add_comm\nSubtractionCommMonoid.mk\nSubtractionCommMonoid.toSubtractionMonoid\nSubtractionMonoid\nSubtractionMonoid.mk\nSubtractionMonoid.neg_add_rev\nSubtractionMonoid.neg_eq_of_add\nSubtractionMonoid.neg_neg\nSubtractionMonoid.toInvolutiveNeg\nSubtractionMonoid.toSubNegMonoid\nSubtractionMonoid.toSubNegZeroMonoid\nSubtype\nSubtype.mk\nSubtype.property\nSubtype.val\nsucc_nsmul\nTop\nTop.mk\nTop.top\nTrans\nTrans.mk\nTrans.trans\ntrivial\nTrue\nTrue.intro\nUInt32\nUInt32.isValidChar\nUInt32.mk\nUInt32.size\nUInt32.toNat\nUInt32.val\nUnique\nUnique.mk\nUnique.toInhabited\nUnique.uniq\nUnit\nUnits\nUnits.instCommGroupUnits\nUnits.instGroup\nUnits.instInv\nUnits.instMonoid\nUnits.instMulOneClass\nUnits.inv\nUnits.inv_val\nUnits.map\nUnits.mk\nUnits.val\nUnits.val_inv\nVAdd\nVAdd.comp.vadd\nVAdd.mk\nVAdd.vadd\nWellFounded\nWellFounded.intro\nZero\nzero_add\nZeroHom\nZeroHomClass\nZeroHomClass.map_zero\nZeroHomClass.mk\nZeroHom.map_zero&#39;\nZeroHom.mk\nZeroHom.toFun\nZeroMemClass\nZeroMemClass.mk\nZeroMemClass.zero_mem\nZero.mk\nzero_nsmul\nZero.ofOfNat0\nzero_smul\nZero.toOfNat0\nZero.zero\nzero_zsmul\nzpowRec\n</code></pre></div>\n</div></div>",
        "id": 425249955,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1709799612
    },
    {
        "content": "<p>Kevin: you know this part of the code, and I don't – is there anything here that's missing? It definitely seems strange that Hilbert 90 only seems to touch five other declarations under <code>groupCohomology</code>.</p>",
        "id": 425255136,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709801788
    },
    {
        "content": "<p>If it helps with the debugging, I added a <code>!</code> flag to <code>#tally</code> (I edited the code above):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">tally</span><span class=\"bp\">!</span> <span class=\"n\">Int</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">3  Init.Data</span>\n<span class=\"cm\">3  Init.Prelude</span>\n<span class=\"cm\">1  [anonymous]</span>\n\n<span class=\"cm\">7  total</span>\n\n<span class=\"cm\">Declarations in 'Int':</span>\n\n<span class=\"cm\">Int</span>\n<span class=\"cm\">Int.negSucc</span>\n<span class=\"cm\">Int.ofNat</span>\n<span class=\"cm\">Nat</span>\n<span class=\"cm\">Nat.succ</span>\n<span class=\"cm\">Nat.zero</span>\n<span class=\"cm\">[anonymous]</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>This prints the (sorted) list of declarations that it found.</p>",
        "id": 425256687,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1709802322
    },
    {
        "content": "<p>I tried it on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingOfIntegers.isPrincipalIdealRing_of_abs_discr_lt#doc\">docs#RingOfIntegers.isPrincipalIdealRing_of_abs_discr_lt</a> that uses most of the algebraic number theory in Mathlib (except units) and got a score of 29220. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"mi\">1</span>  <span class=\"n\">Aesop.BuiltinRules</span>\n    <span class=\"mi\">7</span>  <span class=\"n\">Init.ByCases</span>\n   <span class=\"mi\">18</span>  <span class=\"n\">Init.Classical</span>\n    <span class=\"mi\">3</span>  <span class=\"n\">Init.Coe</span>\n   <span class=\"mi\">31</span>  <span class=\"n\">Init.Control</span>\n  <span class=\"mi\">244</span>  <span class=\"n\">Init.Core</span>\n  <span class=\"mi\">906</span>  <span class=\"n\">Init.Data</span>\n    <span class=\"mi\">2</span>  <span class=\"n\">Init.Ext</span>\n    <span class=\"mi\">1</span>  <span class=\"n\">Init.Meta</span>\n    <span class=\"mi\">4</span>  <span class=\"n\">Init.MetaTypes</span>\n  <span class=\"mi\">121</span>  <span class=\"n\">Init.Omega</span>\n  <span class=\"mi\">370</span>  <span class=\"n\">Init.Prelude</span>\n   <span class=\"mi\">65</span>  <span class=\"n\">Init.PropLemmas</span>\n   <span class=\"mi\">71</span>  <span class=\"n\">Init.SimpLemmas</span>\n    <span class=\"mi\">4</span>  <span class=\"n\">Init.SizeOf</span>\n   <span class=\"mi\">30</span>  <span class=\"n\">Init.WF</span>\n <span class=\"mi\">4665</span>  <span class=\"n\">Mathlib.Algebra</span>\n    <span class=\"mi\">6</span>  <span class=\"n\">Mathlib.AlgebraicGeometry</span>\n <span class=\"mi\">2467</span>  <span class=\"n\">Mathlib.Analysis</span>\n <span class=\"mi\">5171</span>  <span class=\"n\">Mathlib.Data</span>\n   <span class=\"mi\">33</span>  <span class=\"n\">Mathlib.Dynamics</span>\n  <span class=\"mi\">251</span>  <span class=\"n\">Mathlib.FieldTheory</span>\n  <span class=\"mi\">838</span>  <span class=\"n\">Mathlib.GroupTheory</span>\n  <span class=\"mi\">281</span>  <span class=\"n\">Mathlib.Init</span>\n <span class=\"mi\">1443</span>  <span class=\"n\">Mathlib.LinearAlgebra</span>\n  <span class=\"mi\">644</span>  <span class=\"n\">Mathlib.Logic</span>\n <span class=\"mi\">3105</span>  <span class=\"n\">Mathlib.MeasureTheory</span>\n  <span class=\"mi\">153</span>  <span class=\"n\">Mathlib.NumberTheory</span>\n <span class=\"mi\">2727</span>  <span class=\"n\">Mathlib.Order</span>\n <span class=\"mi\">1182</span>  <span class=\"n\">Mathlib.RingTheory</span>\n  <span class=\"mi\">377</span>  <span class=\"n\">Mathlib.SetTheory</span>\n  <span class=\"mi\">180</span>  <span class=\"n\">Mathlib.Tactic</span>\n <span class=\"mi\">3355</span>  <span class=\"n\">Mathlib.Topology</span>\n    <span class=\"mi\">5</span>  <span class=\"n\">Std.Classes</span>\n  <span class=\"mi\">447</span>  <span class=\"n\">Std.Data</span>\n   <span class=\"mi\">11</span>  <span class=\"n\">Std.Logic</span>\n    <span class=\"mi\">1</span>  <span class=\"o\">[</span><span class=\"n\">anonymous</span><span class=\"o\">]</span>\n\n<span class=\"mi\">29220</span>  <span class=\"n\">total</span>\n</code></pre></div>\n<p>And <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsCyclotomicExtension.Rat.three_pid#doc\">docs#IsCyclotomicExtension.Rat.three_pid</a> should even get more but I don't have time to test it now...</p>",
        "id": 425260006,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1709803555
    },
    {
        "content": "<p>By manual inspection, I think that there are definitely more declarations in the <code>groupCohomology</code> namespace that it should have found.  I'm investigating why it is not recursing properly.</p>",
        "id": 425260178,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1709803603
    },
    {
        "content": "<p>To go a bit into the internals, the code omits declarations that are <code>blackListed</code>: these should essentially be the declarations that lean uses internally to fill in some gaps, but I do not think that pruning them they should be responsible for the inconsistencies that seem to be present.</p>",
        "id": 425260736,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1709803789
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"488648\">Xavier Roblot</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Counting.20prerequisites.20of.20a.20theorem/near/425260006\">said</a>:</p>\n<blockquote>\n<p>I tried it on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingOfIntegers.isPrincipalIdealRing_of_abs_discr_lt#doc\">docs#RingOfIntegers.isPrincipalIdealRing_of_abs_discr_lt</a> that uses most of the algebraic number theory in Mathlib (except units) and got a score of 29220. </p>\n</blockquote>\n<p>Ah, the Minkowski bound! I wondered why that needed quite so much analysis / topology, but it looks like the dependence goes via <code>MeasureTheory.Measure.Lebesgue.VolumeOfBalls</code>. This may well be the \"commanding height\" of mathlib – I wonder if anyone can beat that score?</p>",
        "id": 425265754,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709805317
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsCyclotomicExtension.Rat.three_pid#doc\">docs#IsCyclotomicExtension.Rat.three_pid</a> should beat it since it actually uses that function. Note that it tooks more than 30mn to compute this tally on my M1 laptop. Anyway, I am not in my office right now so somebody else will have to try <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 425266951,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1709805708
    },
    {
        "content": "<p>I guess this is because the definition of the cyclotomic polynomials uses complex roots of unity (this is my fault, I am to lazy to do an algebraic refactor)</p>",
        "id": 425271128,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1709806999
    },
    {
        "content": "<p>There is also a bunch of topology / analysis involved  in the proof that two complex embeddings define the same infinite place iff they are complex conjugate.</p>",
        "id": 425273362,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1709807652
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Counting.20prerequisites.20of.20a.20theorem/near/425255136\">said</a>:</p>\n<blockquote>\n<p>Kevin: you know this part of the code, and I don't – is there anything here that's missing? It definitely seems strange that Hilbert 90 only seems to touch five other declarations under <code>groupCohomology</code>.</p>\n</blockquote>\n<p>I was expecting a lot more category theory and topology -- but looking at the code I see I'd misguessed what was going on. <code>H1</code> is defined concretely as 1-cocycles over 1-coboundaries, rather than <code>H n</code> for <code>n = 1</code>, so all the general group cohomology machinery (which uses a bunch of resolutions, which uses a bunch of topology...) is not used. In short <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=groupCohomology.isoH1#doc\">docs#groupCohomology.isoH1</a> is not <code>rfl</code>, so it was my guess which was lousy, not Damiano's code.</p>",
        "id": 425277826,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709809111
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Counting.20prerequisites.20of.20a.20theorem/near/425277826\">said</a>:</p>\n<blockquote>\n<p>In short <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=groupCohomology.isoH1#doc\">docs#groupCohomology.isoH1</a> is not <code>rfl</code>, so it was my guess which was lousy, not Damiano's code.</p>\n</blockquote>\n<p>Oh, I assure you, Damiano's code has a very high chance of being lousy!</p>",
        "id": 425278625,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1709809352
    },
    {
        "content": "<p>I finally had the time to test <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsCyclotomicExtension.Rat.three_pid#doc\">docs#IsCyclotomicExtension.Rat.three_pid</a>, the tally is 31083</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"mi\">1</span>  <span class=\"n\">Aesop.BuiltinRules</span>\n    <span class=\"mi\">8</span>  <span class=\"n\">Init.ByCases</span>\n   <span class=\"mi\">18</span>  <span class=\"n\">Init.Classical</span>\n    <span class=\"mi\">3</span>  <span class=\"n\">Init.Coe</span>\n   <span class=\"mi\">31</span>  <span class=\"n\">Init.Control</span>\n  <span class=\"mi\">247</span>  <span class=\"n\">Init.Core</span>\n  <span class=\"mi\">953</span>  <span class=\"n\">Init.Data</span>\n    <span class=\"mi\">2</span>  <span class=\"n\">Init.Ext</span>\n    <span class=\"mi\">1</span>  <span class=\"n\">Init.Meta</span>\n    <span class=\"mi\">4</span>  <span class=\"n\">Init.MetaTypes</span>\n  <span class=\"mi\">147</span>  <span class=\"n\">Init.Omega</span>\n  <span class=\"mi\">371</span>  <span class=\"n\">Init.Prelude</span>\n   <span class=\"mi\">69</span>  <span class=\"n\">Init.PropLemmas</span>\n   <span class=\"mi\">72</span>  <span class=\"n\">Init.SimpLemmas</span>\n    <span class=\"mi\">4</span>  <span class=\"n\">Init.SizeOf</span>\n   <span class=\"mi\">30</span>  <span class=\"n\">Init.WF</span>\n <span class=\"mi\">5094</span>  <span class=\"n\">Mathlib.Algebra</span>\n    <span class=\"mi\">6</span>  <span class=\"n\">Mathlib.AlgebraicGeometry</span>\n <span class=\"mi\">2483</span>  <span class=\"n\">Mathlib.Analysis</span>\n <span class=\"mi\">5774</span>  <span class=\"n\">Mathlib.Data</span>\n   <span class=\"mi\">39</span>  <span class=\"n\">Mathlib.Dynamics</span>\n  <span class=\"mi\">368</span>  <span class=\"n\">Mathlib.FieldTheory</span>\n  <span class=\"mi\">916</span>  <span class=\"n\">Mathlib.GroupTheory</span>\n  <span class=\"mi\">283</span>  <span class=\"n\">Mathlib.Init</span>\n <span class=\"mi\">1483</span>  <span class=\"n\">Mathlib.LinearAlgebra</span>\n  <span class=\"mi\">649</span>  <span class=\"n\">Mathlib.Logic</span>\n <span class=\"mi\">3105</span>  <span class=\"n\">Mathlib.MeasureTheory</span>\n  <span class=\"mi\">239</span>  <span class=\"n\">Mathlib.NumberTheory</span>\n <span class=\"mi\">2735</span>  <span class=\"n\">Mathlib.Order</span>\n <span class=\"mi\">1517</span>  <span class=\"n\">Mathlib.RingTheory</span>\n  <span class=\"mi\">384</span>  <span class=\"n\">Mathlib.SetTheory</span>\n  <span class=\"mi\">193</span>  <span class=\"n\">Mathlib.Tactic</span>\n <span class=\"mi\">3355</span>  <span class=\"n\">Mathlib.Topology</span>\n    <span class=\"mi\">5</span>  <span class=\"n\">Std.Classes</span>\n  <span class=\"mi\">482</span>  <span class=\"n\">Std.Data</span>\n   <span class=\"mi\">11</span>  <span class=\"n\">Std.Logic</span>\n    <span class=\"mi\">1</span>  <span class=\"o\">[</span><span class=\"n\">anonymous</span><span class=\"o\">]</span>\n\n<span class=\"mi\">31083</span>  <span class=\"n\">total</span>\n</code></pre></div>",
        "id": 425363920,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1709834350
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> As you suspected, the code can be written more simply and a lot faster by reusing the code of <code>#print axioms</code>, which is already doing basically all of this work. (You can also copy and paste it, it's not that complicated, but it so happens that we can actually use the core function unmodified in this case.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"#tally \"</span> <span class=\"n\">tk</span><span class=\"o\">:(</span><span class=\"n\">noWs</span> <span class=\"s2\">\"!\"</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">getEnv</span>\n  <span class=\"k\">let</span> <span class=\"n\">decl</span> <span class=\"bp\">←</span> <span class=\"n\">Elab.resolveGlobalConstNoOverloadWithInfo</span> <span class=\"n\">id</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">visited</span><span class=\"o\">,</span> <span class=\"bp\">..</span> <span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"n\">Elab.Command.CollectAxioms.collect</span> <span class=\"n\">decl</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getEnv</span><span class=\"o\">)</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"o\">{}</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">truncate</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">tk.isSome</span> <span class=\"k\">then</span>\n    <span class=\"n\">env.header.moduleNames</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">env.header.moduleNames.map</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Name.fromComponents</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">n.components.take</span> <span class=\"mi\">2</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">out</span> <span class=\"o\">:=</span> <span class=\"n\">mkRBMap</span> <span class=\"n\">Name</span> <span class=\"n\">Nat</span> <span class=\"n\">Name.cmp</span>\n  <span class=\"n\">for</span> <span class=\"n\">d</span> <span class=\"k\">in</span> <span class=\"n\">visited</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">idx</span> <span class=\"o\">:=</span> <span class=\"n\">env.getModuleIdxFor</span><span class=\"bp\">?</span> <span class=\"n\">d</span> <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">truncate</span><span class=\"o\">[</span><span class=\"n\">idx.toNat</span><span class=\"o\">]</span><span class=\"bp\">!</span>\n      <span class=\"n\">out</span> <span class=\"o\">:=</span> <span class=\"n\">out.insert</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">out.findD</span> <span class=\"n\">n</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">msg</span> <span class=\"o\">:=</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">total</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">for</span> <span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">out</span> <span class=\"k\">do</span>\n    <span class=\"n\">total</span> <span class=\"o\">:=</span> <span class=\"n\">total</span> <span class=\"bp\">+</span> <span class=\"n\">n</span>\n    <span class=\"n\">msg</span> <span class=\"o\">:=</span> <span class=\"n\">msg</span> <span class=\"bp\">++</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{(toString n).leftpad 8 ' '}  {name}</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span>\n  <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{msg}</span><span class=\"se\">\\n</span><span class=\"s2\">{(toString total).leftpad 8 ' '}  total\"</span>\n</code></pre></div>",
        "id": 425370265,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709836596
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">tally</span> <span class=\"n\">IsCyclotomicExtension.Rat.three_pid</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>       <span class=\"mi\">1</span>  <span class=\"n\">Aesop.BuiltinRules</span>\n      <span class=\"mi\">16</span>  <span class=\"n\">Init.ByCases</span>\n      <span class=\"mi\">32</span>  <span class=\"n\">Init.Classical</span>\n       <span class=\"mi\">3</span>  <span class=\"n\">Init.Coe</span>\n      <span class=\"mi\">20</span>  <span class=\"n\">Init.Control</span>\n     <span class=\"mi\">331</span>  <span class=\"n\">Init.Core</span>\n    <span class=\"mi\">1511</span>  <span class=\"n\">Init.Data</span>\n       <span class=\"mi\">3</span>  <span class=\"n\">Init.Ext</span>\n       <span class=\"mi\">1</span>  <span class=\"n\">Init.Meta</span>\n     <span class=\"mi\">172</span>  <span class=\"n\">Init.Omega</span>\n     <span class=\"mi\">497</span>  <span class=\"n\">Init.Prelude</span>\n     <span class=\"mi\">156</span>  <span class=\"n\">Init.PropLemmas</span>\n      <span class=\"mi\">99</span>  <span class=\"n\">Init.SimpLemmas</span>\n       <span class=\"mi\">9</span>  <span class=\"n\">Init.SizeOf</span>\n      <span class=\"mi\">45</span>  <span class=\"n\">Init.WF</span>\n    <span class=\"mi\">8646</span>  <span class=\"n\">Mathlib.Algebra</span>\n       <span class=\"mi\">9</span>  <span class=\"n\">Mathlib.AlgebraicGeometry</span>\n    <span class=\"mi\">4591</span>  <span class=\"n\">Mathlib.Analysis</span>\n       <span class=\"mi\">5</span>  <span class=\"n\">Mathlib.Combinatorics</span>\n    <span class=\"mi\">9588</span>  <span class=\"n\">Mathlib.Data</span>\n      <span class=\"mi\">64</span>  <span class=\"n\">Mathlib.Dynamics</span>\n     <span class=\"mi\">637</span>  <span class=\"n\">Mathlib.FieldTheory</span>\n    <span class=\"mi\">2084</span>  <span class=\"n\">Mathlib.GroupTheory</span>\n     <span class=\"mi\">408</span>  <span class=\"n\">Mathlib.Init</span>\n    <span class=\"mi\">3142</span>  <span class=\"n\">Mathlib.LinearAlgebra</span>\n    <span class=\"mi\">1209</span>  <span class=\"n\">Mathlib.Logic</span>\n    <span class=\"mi\">4749</span>  <span class=\"n\">Mathlib.MeasureTheory</span>\n     <span class=\"mi\">444</span>  <span class=\"n\">Mathlib.NumberTheory</span>\n    <span class=\"mi\">4425</span>  <span class=\"n\">Mathlib.Order</span>\n    <span class=\"mi\">2980</span>  <span class=\"n\">Mathlib.RingTheory</span>\n     <span class=\"mi\">666</span>  <span class=\"n\">Mathlib.SetTheory</span>\n     <span class=\"mi\">254</span>  <span class=\"n\">Mathlib.Tactic</span>\n    <span class=\"mi\">5234</span>  <span class=\"n\">Mathlib.Topology</span>\n       <span class=\"mi\">5</span>  <span class=\"n\">Std.Classes</span>\n     <span class=\"mi\">925</span>  <span class=\"n\">Std.Data</span>\n      <span class=\"mi\">17</span>  <span class=\"n\">Std.Logic</span>\n\n   <span class=\"mi\">52978</span>  <span class=\"n\">total</span>\n</code></pre></div>",
        "id": 425370335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709836616
    },
    {
        "content": "<blockquote>\n<p>As you suspected, the code can be written more simply and a lot faster by reusing the code of #print axioms, which is already doing basically all of this work</p>\n</blockquote>\n<p>It gets – simply and a lot faster – to a very different answer! For <code>Rat.three_PID</code>, Mario's code gives an answer of  52978 while Damiano's gives 31083. I wonder how the difference arises?</p>",
        "id": 425373888,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709837884
    },
    {
        "content": "<p>Mario, that is fantastic!  I did not really know what print axioms did, so it hadn't even occurred to me to recycle it!</p>",
        "id": 425375216,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1709838289
    },
    {
        "content": "<p>I've done a little bit of investigating and I think that the discrepancy between the numbers may be due to the fact that my code was removing <code>blackListed</code> declarations (which I was doing in the hope of speeding up the computation).</p>\n<p>Besides that, in terms of programming abilities, there are probably very few wider chasms than the one separating Mario and myself, so that should explain why his code works, while mine is, at best, shaky.</p>\n<p>Finally, I see that Mario reinterpreted the value of the <code>!</code> flag to mean \"tally by whole path instead of 2-step truncated paths\".  What I had intended the <code>!</code> flag to be was to actually print all the declarations found.  If you want that behaviour, below I adapt minimally Mario's code from above.</p>\n<p>So, now you can do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">tally</span> <span class=\"n\">CovariantClass</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">       3  Mathlib.Algebra</span>\n\n<span class=\"cm\">       3  total</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"bp\">#</span><span class=\"n\">tally</span><span class=\"bp\">!</span> <span class=\"n\">CovariantClass</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">       3  Mathlib.Algebra.CovariantAndContravariant</span>\n\n<span class=\"cm\">       3  total</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"bp\">#</span><span class=\"n\">tally</span> <span class=\"n\">CovariantClass</span> <span class=\"n\">all</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">       3  Mathlib.Algebra</span>\n\n<span class=\"cm\">       3  total</span>\n\n<span class=\"cm\">[Covariant, CovariantClass, CovariantClass.mk]</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"bp\">#</span><span class=\"n\">tally</span><span class=\"bp\">!</span> <span class=\"n\">CovariantClass</span> <span class=\"n\">all</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">       3  Mathlib.Algebra.CovariantAndContravariant</span>\n\n<span class=\"cm\">       3  total</span>\n\n<span class=\"cm\">[Covariant, CovariantClass, CovariantClass.mk]</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"#tally \"</span> <span class=\"n\">tk</span><span class=\"o\">:(</span><span class=\"n\">noWs</span> <span class=\"s2\">\"!\"</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"n\">all</span><span class=\"bp\">?</span><span class=\"o\">:(</span><span class=\"s2\">\" all\"</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">getEnv</span>\n  <span class=\"k\">let</span> <span class=\"n\">decl</span> <span class=\"bp\">←</span> <span class=\"n\">Elab.resolveGlobalConstNoOverloadWithInfo</span> <span class=\"n\">id</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">visited</span><span class=\"o\">,</span> <span class=\"bp\">..</span> <span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"n\">Elab.Command.CollectAxioms.collect</span> <span class=\"n\">decl</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getEnv</span><span class=\"o\">)</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"o\">{}</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">truncate</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">tk.isSome</span> <span class=\"k\">then</span>\n    <span class=\"n\">env.header.moduleNames</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">env.header.moduleNames.map</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Name.fromComponents</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">n.components.take</span> <span class=\"mi\">2</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">out</span> <span class=\"o\">:=</span> <span class=\"n\">mkRBMap</span> <span class=\"n\">Name</span> <span class=\"n\">Nat</span> <span class=\"n\">Name.cmp</span>\n  <span class=\"n\">for</span> <span class=\"n\">d</span> <span class=\"k\">in</span> <span class=\"n\">visited</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">idx</span> <span class=\"o\">:=</span> <span class=\"n\">env.getModuleIdxFor</span><span class=\"bp\">?</span> <span class=\"n\">d</span> <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">truncate</span><span class=\"o\">[</span><span class=\"n\">idx.toNat</span><span class=\"o\">]</span><span class=\"bp\">!</span>\n      <span class=\"n\">out</span> <span class=\"o\">:=</span> <span class=\"n\">out.insert</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">out.findD</span> <span class=\"n\">n</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">msg</span> <span class=\"o\">:=</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">total</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">for</span> <span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">out</span> <span class=\"k\">do</span>\n    <span class=\"n\">total</span> <span class=\"o\">:=</span> <span class=\"n\">total</span> <span class=\"bp\">+</span> <span class=\"n\">n</span>\n    <span class=\"n\">msg</span> <span class=\"o\">:=</span> <span class=\"n\">msg</span> <span class=\"bp\">++</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{(toString n).leftpad 8 ' '}  {name}</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">pmsg</span> <span class=\"o\">:=</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{msg}</span><span class=\"se\">\\n</span><span class=\"s2\">{(toString total).leftpad 8 ' '}  total\"</span>\n  <span class=\"n\">logInfo</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">pmsg</span> <span class=\"bp\">++</span> <span class=\"k\">match</span> <span class=\"n\">all</span><span class=\"bp\">?</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"\"</span>\n      <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"</span><span class=\"se\">\\n\\n</span><span class=\"s2\">{visited.toArray.qsort (·.toString &lt; ·.toString)}\"</span>\n</code></pre></div>",
        "id": 425483341,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1709891417
    },
    {
        "content": "<p>Can part of this code be used to find <em>unused</em> declarations to get to a specific theorem? For example, in <code>flt-regular</code> we have a clear target (FLT for regular primes!), but I am sure we have a lot of useless code. It would be nice to get a list of useless things, to check it they just deserve to be removed.</p>",
        "id": 436944860,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1714763960
    },
    {
        "content": "<p>Std/Batteries has <code>#show_unused</code>, although it only works within a single file</p>",
        "id": 436945931,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1714764369
    },
    {
        "content": "<p>it could work across files but it would need a different interface</p>",
        "id": 436946008,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1714764398
    },
    {
        "content": "<p>I recall a discussion not long back about a script intended to automatically produce MWE's for some failing declaration. That's the same problem as here, in some sense. I can't remember who was working on the auto-MWE script though – <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> was it you?</p>",
        "id": 436995786,
        "sender_full_name": "David Loeffler",
        "timestamp": 1714802663
    },
    {
        "content": "<p>No, it wasn't me.</p>",
        "id": 436998408,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1714805588
    },
    {
        "content": "<p>It was <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span></p>",
        "id": 436998574,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1714805754
    },
    {
        "content": "<p>See <a href=\"#narrow/stream/270676-lean4/topic/Bug.20causing.20stack.20overflow\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Bug.20causing.20stack.20overflow</a></p>",
        "id": 436998644,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1714805815
    },
    {
        "content": "<p>I <em>think</em> the bottom line was that the automation wasn't yet good enough. I would love progress on this front.</p>\n<p>There are a lot of tricks to effectively minimizing from deep inside Mathlib.</p>\n<p>To begin, you need a good set of <code>#guard_msgs</code> statements (or sometimes hand-rolled checks of the errors messages) that ensure that you have red iff you've over-minimized.</p>\n<p>After that, you iteratively:</p>\n<ul>\n<li>move the contents of an import into the current file (I find it helpful to wrap it in a section named after the file)</li>\n<li>delete all unneeded declarations (<code>#show_unused in X</code> is super helpful)</li>\n<li>further minimizing the remaining declarations (replace all proofs with sorry, remove structure fields -- hard to automate as you often need downstream fixes, try changing definitions to sorry (sometimes this doesn't work but changing the definition to be something \"simpler\" does), weakening extends statements or typeclass arguments...)</li>\n<li>minimize imports (try removing imports, and other replacing each by its own imports: <code>shake</code> can help here)</li>\n</ul>\n<p>If you go through the <code>@[to_additive]</code> parts of the library removing that dependency can be painfully manual.</p>",
        "id": 436999659,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1714806939
    },
    {
        "content": "<p>Here's the main thread for the script: <a href=\"#narrow/stream/113488-general/topic/Minimizer.20script\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Minimizer.20script</a></p>",
        "id": 437005361,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1714813102
    },
    {
        "content": "<p>It essentially tries doing all the steps Kim suggests but by brute force, simply doing a search cutting out whole lines and paragraphs without any guidance from Lean. So it's not particularly effective at actually finding what can be dropped, nor does it do any downstream fixing.</p>",
        "id": 437005457,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1714813213
    },
    {
        "content": "<p>In practice it means it is way too slow and way too ineffective for any use on Mathlib. :(</p>",
        "id": 437005492,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1714813248
    },
    {
        "content": "<p>Out of curiosity, I tallied all lemmas: these are the top 10 using the most declarations</p>\n<table>\n<thead>\n<tr>\n<th>Declaration</th>\n<th>Depends on</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NumberField.Units.unitLattice_rank</td>\n<td>51024</td>\n</tr>\n<tr>\n<td>NumberField.hermiteTheorem.finite_of_discr_bdd_of_isReal</td>\n<td>51088</td>\n</tr>\n<tr>\n<td>NumberField.hermiteTheorem.finite_of_discr_bdd_of_isComplex</td>\n<td>51103</td>\n</tr>\n<tr>\n<td>NumberField.finite_of_discr_bdd</td>\n<td>51121</td>\n</tr>\n<tr>\n<td>NumberField.Units.rank_modTorsion</td>\n<td>51201</td>\n</tr>\n<tr>\n<td>NumberField.Units.basisModTorsion</td>\n<td>51211</td>\n</tr>\n<tr>\n<td>NumberField.Units.fun_eq_repr</td>\n<td>51214</td>\n</tr>\n<tr>\n<td>NumberField.Units.exist_unique_eq_mul_prod</td>\n<td>51219</td>\n</tr>\n<tr>\n<td>IsCyclotomicExtension.Rat.three_pid</td>\n<td>53083</td>\n</tr>\n<tr>\n<td>IsCyclotomicExtension.Rat.five_pid</td>\n<td>53084</td>\n</tr>\n</tbody>\n</table>",
        "id": 442617034,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1717532014
    },
    {
        "content": "<p>I feel like you should only list declarations that are not themselves used in other declarations!</p>",
        "id": 442669815,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1717551000
    },
    {
        "content": "<p>I agree, but I need to think about how to do that with finite resources!  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 442696677,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1717564391
    }
]