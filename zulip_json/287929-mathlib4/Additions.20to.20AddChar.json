[
    {
        "content": "<p>Hi! As I've said in <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/github.20permission\">#mathlib4 &gt; github permission</a> , I've been working on a few theorems for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddChar#doc\">docs#AddChar</a>, and I want to contribute them. This is what I proved (I'm aware some of these names are terrible, I'd love better ideas):</p>\n<ul>\n<li><code>equiv_addChar (h : R ≃+ R₂) : AddChar R R' ≃* AddChar R₂ R'</code>: there is an isomorphism between characters on isomorphic groups.</li>\n<li><code>map_sum_prod (ψ : AddChar R R') (f : l → R) : ψ (∑ x, f x) = ∏ x, (ψ (f x))</code>: an extension of <code>map_add_mul</code> for finite sums and products.</li>\n<li><code>equiv_directSum_addChar : AddChar (⨁ i, f i) R' ≃ Π i, AddChar (f i) R'</code>: <code>AddChar</code> distributes over direct sum. This is actually an isomorphism, but direct product doesn't seem to be defined for multiplicative groups, so I'm not sure how to state that.</li>\n<li><code>zmod_equiv_addChar (n : ℕ+) (h : 1 &lt; n) : AddChar (ZMod n) R' ≃* rootsOfUnity n R'</code>: this is an extension of <code>zmodChar</code> which also provides the other direction.</li>\n<li><code>card_AddChar [Fact (∀ n : ℕ+, Fintype.card (rootsOfUnity n R') = n)] : Nat.card (AddChar R R') = Nat.card R</code>: the additive characters from a finite commutative group to a domain with full roots of unity have the same cardinality as the group.</li>\n<li><code>noncomputable def embed [Fact (∀ n : ℕ+, Fintype.card (rootsOfUnity n R') = n)] : R ≃ (AddChar R R')</code>: under the above conditions, there is a (noncomputable) equivalence between characters of a group and elements of it.</li>\n<li><code>noncomputable instance fintype: Fintype (AddChar R R')</code> : There is a finite number of characters from a finite commutative group to a domain.</li>\n<li><code>orthogonality (h : ψ ≠ φ) : ∑ a, ψ a * φ⁻¹ a = 0</code></li>\n<li><code>norm : ∑ a, ψ a * ψ⁻¹ a = Fintype.card R</code></li>\n<li><code>sum_chars_ne [Fact (∀ n : ℕ+, Fintype.card (rootsOfUnity n R') = n)] [Invertible (Fintype.card R : R')] (h : x ≠ y) : ∑ χ : AddChar R R', χ x * χ⁻¹ y = 0</code> (I'm not sure if the cardinality being invertible is required, but my proof needs it)</li>\n<li><code>sum_chars_eq : ∑ χ : AddChar R R', χ x * χ⁻¹ x = Fintype.card (AddChar R R')</code></li>\n</ul>",
        "id": 424229615,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1709297841
    },
    {
        "content": "<p>I also want to prove a few results about Fourier analysis on finite groups. Where should these be placed?</p>",
        "id": 424364054,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1709354606
    },
    {
        "content": "<ul>\n<li><code>equiv_addChar</code> should be <code>equivAddChar</code> by naming convention, but I think <code>AddEquiv.addCharCongr</code> is a better name.</li>\n<li>We should provide List, Multiset, and Finset versions of <code>map_sum_prod</code> to make a complete API. Maybe call them AddChar.map_list_sum, AddChar.map_multiset_sum, AddChar.map_finset_sum (I think it's also common to omit <code>finset_</code>); the Fintype version should be subsumed by the Finset version.</li>\n<li><code>equiv_directSum_addChar</code> (better name: AddChar.directSumEquiv): there are instances <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Pi.monoid#doc\">docs#Pi.monoid</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Pi.group#doc\">docs#Pi.group</a> on the direct product, maybe you're just missing imports?</li>\n<li><code>zmod_equiv_addChar</code> (better name: AddChar.zmodEquiv): why require <code>1 &lt; n</code>?</li>\n<li>capitalization of <code>card_AddChar</code> should be <code>card_addChar</code> by naming convention. The condition for all <code>n : ℕ+</code> is too restrictive, for example no fields of positive characteristic p could possibly satisfy it, because there's only one pth root of unity. However, it suffices to require the equality for n = exponent of R.</li>\n<li><code>embed</code>: <code>AddChar R R'</code> is canonically isomorphic to the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PontryaginDual#doc\">docs#PontryaginDual</a> of R (if you give R the discrete topology). May be we should define the canonical MulEquiv between <code>AddChar R R'</code> and <code>AddChar R circle</code>?</li>\n<li><code>orthogonality</code>: mathlib might prefer a more descriptive name like <code>AddChar.sum_apply_mul_inv_apply_eq_zero</code>.</li>\n<li><code>norm</code>: maybe <code>sum_apply_mul_inv_apply_eq_card</code>.</li>\n<li><code>sum_chars_ne</code> (maybe <code>sum_eval_mul_inv_eval_eq_zero</code>): you can rewrite the summand as <code>χ (x - y)</code> and notice that evaluation at <code>x - y</code> is a homomorphism from <code>AddChar R R'</code> to <code>R'</code>, so the sum is equal to the cardinality of the kernel times the sum of the image. If the image isn't {1} then its sum is zero (I can imagine proving this via Vieta's formula or by summing geometric series; not sure which approach you took). So indeed the <code>Invertible</code> condition shouldn't be required.</li>\n<li><code>sum_chars_eq</code>: maybe <code>sum_eval_mul_inv_eval_eq_card</code>.<br>\n(Note that I'm establishing a convention that <code>apply</code> refers to a sum in which the same character(s) are applied to different elements, while <code>eval</code> refers to a sum over characters applied to the same elements.)</li>\n</ul>",
        "id": 424371369,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1709361990
    },
    {
        "content": "<p>Thanks for the feedback!</p>\n<ul>\n<li><code>zmodEquiv</code>: You're right, it isn't needed</li>\n<li>Regarding <code>card_addChar</code>, would it be better to require the equality of the cardinality for <code>exponent R</code>, or require giving an <code>exponent R</code>-th primitive root?</li>\n<li>For <code>embed</code>, I'm not exactly sure what you mean, could you please clarify?</li>\n<li><code>sum_eval_mul_inv_eval_eq_zero</code>: I proved it by creating two matrices <code>A i j = (embed i) j</code>, <code>A* i j = (embed j)⁻¹ i</code>, showing (using <code>sum_apply_mul_inv_apply_eq_zero</code> and <code>sum_apply_mul_inv_apply_eq_card</code>) that <code>A A* = card I</code>, and then using <code>mul_eq_one_comm</code> after rewriting it as <code>(A / card) A* = I</code>. Do you know any references for a proof that doesn't require the invertibility?</li>\n</ul>",
        "id": 424401453,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1709376605
    },
    {
        "content": "<p>I recommend contributing a few of these at a time, rather than all of them at once</p>",
        "id": 424402582,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709377653
    },
    {
        "content": "<p><code>map_sum_prod</code> and friends feel like they're rather foundational, so might make sense to do first</p>",
        "id": 424402599,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709377677
    },
    {
        "content": "<p>Sorry, I have basically all of this material <a href=\"https://github.com/YaelDillies/LeanAPAP/tree/master/LeanAPAP/Prereqs/AddChar\">in LeanAPAP</a> already, and I am about to open a bunch of PRs to add it to mathlib.</p>",
        "id": 424406358,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709381326
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Additions.20to.20AddChar/near/424406358\">said</a>:</p>\n<blockquote>\n<p>Sorry, I have basically all of this material <a href=\"https://github.com/YaelDillies/LeanAPAP/tree/master/LeanAPAP/Prereqs/AddChar\">in LeanAPAP</a> already, and I am about to open a bunch of PRs to add it to mathlib.</p>\n</blockquote>\n<p>Oh, ok. Please ping me when you open these PRs. I see you have also defined and proven some results on DFT, which is also the application I needed it for. Have you proven Vazirani’s XOR lemma (a bound on the non-trivial Fourier coefficients of a distribution implies a bound on its statistical distance from the uniform distribution), by any chance?</p>",
        "id": 424408869,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1709383811
    },
    {
        "content": "<p>Never heard of Vazirani's XOR lemma, no!</p>",
        "id": 424409028,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709383937
    },
    {
        "content": "<p>Ok, then I'll prove it, and I guess I'll depend on LeanAPAP until it's added to mathlib</p>",
        "id": 424409531,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1709384400
    },
    {
        "content": "<p>Sorry that this is taking so long (I wrote most of this code this summer) but upstreaming 170 files is no easy task.</p>",
        "id": 424409661,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709384515
    },
    {
        "content": "<p>(there's roughly 60 left right now)</p>",
        "id": 424409728,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709384551
    },
    {
        "content": "<ul>\n<li>Re: <code>card_addChar</code>: #(rootsOfUnity n R')=n is equivalent to the existence of a primitive nth root of unity in a domain, so either should be fine. Maybe it's better to introduce a predicate (typeclass?) HasPrimitiveRoot and use it everywhere ...</li>\n<li>Re <code>embed</code>: please ignore what I said; there isn't actually a canonical isomorphism between <code>AddChar R R'</code> and <code>AddChar R circle</code> since <code>R'</code> doesn't have distinguished primitive roots of unity.</li>\n<li>Re <code>sum_eval_mul_inv_eval_eq_zero</code>: I think you can just apply <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IntegralDomain.html#doc\">docs#IntegralDomain.html</a>#sum_hom_units_eq_zero to the evaluation homomorphism (at <code>x - y</code>). The homomorphism is not 1 since <code>x - y</code> is not 0 (for this you need that for every prime p dividing the exponent (equivalently, cardinality) of R, there exists a primitive pth root of unity, but it's not necessary that there exists a primitive (exponent R)-th root of unity).</li>\n</ul>",
        "id": 424428319,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1709399626
    }
]