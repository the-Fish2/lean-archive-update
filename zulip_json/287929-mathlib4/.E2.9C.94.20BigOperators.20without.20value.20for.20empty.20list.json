[
    {
        "content": "<p>I'm trying to learn the class inference system and establish some basic definitions to work with <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Lattice.html#SemilatticeSup\">SemilatticeSup</a> without a bottom element. I want to be able to use the Big Join operator in this setting. However, the definition of Multiset.sup requires the semilattice to have a bottom element, as it makes use of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Finset/Finset.html#Finset.fold\">List.fold</a>, which requires a value to return when the input list is empty.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Supremum of a multiset: `sup {a, b, c} = a ⊔ b ⊔ c` -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">sup</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">s.fold</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">⊔</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"bp\">⊥</span>\n</code></pre></div>\n<p>I've noticed that the Big Operators in Mathlib are generally defined in this way.</p>\n<p>What would be the best way to go around this? Thanks!</p>",
        "id": 411761375,
        "sender_full_name": "David Méndez",
        "timestamp": 1704727812
    },
    {
        "content": "<p>What do you want the sup of the empty set to be?</p>",
        "id": 411762209,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704728049
    },
    {
        "content": "<p>I don't need it to be defined.</p>",
        "id": 411762913,
        "sender_full_name": "David Méndez",
        "timestamp": 1704728257
    },
    {
        "content": "<p>I'm a bit confused by what you mean by the \"Big Sup\" operator. What happens if you feed this operator the empty set? Does that make sense?</p>",
        "id": 411763152,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704728324
    },
    {
        "content": "<p>Oh, sorry, I should be saying big join instead of big sup.</p>",
        "id": 411763900,
        "sender_full_name": "David Méndez",
        "timestamp": 1704728565
    },
    {
        "content": "<p>What is the type of the function you're talking about? I still think we're talking at cross purposes or something.</p>",
        "id": 411764896,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704728844
    },
    {
        "content": "<p>For a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SemilatticeSup#doc\">docs#SemilatticeSup</a> you can take the join or sup of two things. But by \"big sup\" I understood \"sup of a set of things\" and so I'm asking what happens if you feed this function the empty set.</p>",
        "id": 411765161,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704728930
    },
    {
        "content": "<p>Essentially what I want is to be able to take the join of any non-empty subset of elements in the semilattice, which we could call big join. Since the structures I'm working with don't have a bottom element, I want to define it in such  a way that you can't feed it the non-empty set, as there wouldn't be a canonical element to choose as that output.</p>",
        "id": 411766337,
        "sender_full_name": "David Méndez",
        "timestamp": 1704729293
    },
    {
        "content": "<p>You can't divide by 0 in mathematics, but in Lean we decided to let users divide by 0 anyway, and just return a junk value. You could also do this here (i.e. use <code>SupSet.sSup</code>), if your structures are guaranteed nonempty: it would probably be easier than making a new structure which explicitly excludes the empty set as an input.</p>",
        "id": 411768506,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704729894
    },
    {
        "content": "<p>This will probably not be fun to use, but you could build something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">List.foldr_</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fs</span> <span class=\"o\">:</span> <span class=\"n\">α</span>  <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"bp\">≠</span> <span class=\"o\">[])</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span>     <span class=\"bp\">=&gt;</span> <span class=\"n\">absurd</span> <span class=\"n\">rfl</span> <span class=\"n\">h</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">fs</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">foldr_</span> <span class=\"n\">f</span> <span class=\"n\">fs</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foldr</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fs</span> <span class=\"o\">:</span> <span class=\"n\">α</span>  <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">LeftCommutative</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">):</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Quot.liftOn</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">List.foldr_</span> <span class=\"n\">f</span> <span class=\"n\">fs</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"gr\">sorry</span><span class=\"o\">))</span> <span class=\"k\">fun</span> <span class=\"n\">_l₁</span> <span class=\"n\">_l₂</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fold</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">IsCommutative</span> <span class=\"n\">α</span> <span class=\"n\">op</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">IsAssociative</span> <span class=\"n\">α</span> <span class=\"n\">op</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">foldr</span> <span class=\"n\">op</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">left_comm</span> <span class=\"n\">_</span> <span class=\"n\">hc.comm</span> <span class=\"n\">ha.assoc</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"n\">h</span>\n\n<span class=\"sd\">/-- Supremum of a multiset: `sup {a, b, c} = a ⊔ b ⊔ c` -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">sup</span>  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">SemilatticeSup</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OrderBot</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">fold</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">⊔</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 411769425,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1704730229
    },
    {
        "content": "<p>Thanks to both of you! I'll see what I can do</p>",
        "id": 411770244,
        "sender_full_name": "David Méndez",
        "timestamp": 1704730497
    },
    {
        "content": "<p>You should just use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sup%27#doc\">docs#Finset.sup'</a></p>",
        "id": 411773891,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704731663
    },
    {
        "content": "<p>Doh</p>",
        "id": 411774994,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1704732004
    },
    {
        "content": "<p>This is only for finsets. I explicitly asked David to write down the type of the function they were talking about but they didn't.</p>",
        "id": 411788553,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704735996
    },
    {
        "content": "<p>I know, but if you click on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sup%27#doc\">docs#Finset.sup'</a> and look up enough definitions, you will know how to do it for lists.</p>",
        "id": 411788982,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704736149
    },
    {
        "content": "<p>Sure, but they wrote \"any nonempty subset\" so right now I think it's clear that we still don't know what the question is</p>",
        "id": 411789087,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704736201
    },
    {
        "content": "<p>The objects I'm working with right now are finite, so with the ideas laid out here I'm sure I can get something working. Sorry for the vagueness in the question and thanks again!</p>",
        "id": 411789695,
        "sender_full_name": "David Méndez",
        "timestamp": 1704736444
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"663127\">David Méndez</span> has marked this topic as resolved.</p>",
        "id": 411804285,
        "sender_full_name": "Notification Bot",
        "timestamp": 1704742745
    }
]