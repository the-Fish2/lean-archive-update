[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ZMod</span> <span class=\"mi\">10</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">fin_cases</span> <span class=\"n\">x</span>\n  <span class=\"c1\">-- note at how ugly stuff appears in the infoview</span>\n  <span class=\"n\">all_goals</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">fin_cases</span> <span class=\"n\">hx</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  tactic 'cases' failed, nested error:</span>\n<span class=\"cm\">  dependent elimination failed, failed to solve equation</span>\n<span class=\"cm\">    Decidable.rec (fun h ↦ (fun x ↦ [1, 2]) h) (fun h ↦ (fun x ↦ [2]) h) (instDecidableEqBool (List.elem 1 [2]) true) =</span>\n<span class=\"cm\">      x :: as✝</span>\n<span class=\"cm\">  at case List.Mem.head</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>\n<p>These are two things I've noticed using <code>fin_cases</code> lately; from glancing at the code, it just works by running <code>cases</code> a _lot_ on the <code>a \\in (x : Finset ...)</code> instance, which can mess things up when things seem to be inductive types (I guess the first case, it's trying to do <code>cases</code> on a quotient instead). Is there any hope to rewrite this in a nicer way?</p>",
        "id": 411050417,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704302458
    },
    {
        "content": "<p>Sorry for hijacking this thread, but maybe the following fits under the title:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.FinCases</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">({</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">fin_cases</span> <span class=\"n\">hx</span>\n<span class=\"c\">/-</span><span class=\"cm\"> tactic 'cases' failed, nested error:</span>\n<span class=\"cm\">dependent elimination failed, failed to solve equation</span>\n<span class=\"cm\">  Decidable.rec (fun h =&gt; (fun x =&gt; [a, b]) h) (fun h =&gt; (fun x =&gt; [b]) h)</span>\n<span class=\"cm\">      (instDecidableEqBool (List.elem a [b]) true) =</span>\n<span class=\"cm\">    x :: as✝</span>\n<span class=\"cm\">at case List.Mem.head</span>\n<span class=\"cm\">-/</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Is this known? This makes <code>fin_cases</code> pretty much unusable with concrete <code>Finset</code>s.</p>",
        "id": 412701089,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705144451
    },
    {
        "content": "<p>For a workaround, are you lucky enough to be able to use <code>cases hx</code> here?</p>",
        "id": 412703916,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705146741
    },
    {
        "content": "<p><code>cases hx</code> produces the same error message (which comes from <code>cases</code> anyway...).</p>",
        "id": 412704843,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705147525
    },
    {
        "content": "<p>As far as I understand, fin_cases is something like <code>repeat cases h</code> for like everything that comes out of h</p>",
        "id": 412712916,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1705155135
    },
    {
        "content": "<p><code>  simp only [Finset.mem_insert, Finset.mem_singleton] at hx </code> works in this case</p>",
        "id": 412713132,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705155368
    },
    {
        "content": "<p>I know (see the <a href=\"#narrow/stream/287929-mathlib4/topic/simp.3F.20missing.20lemmas/near/412710900\">other thread</a>), but this was not the question.</p>",
        "id": 412714670,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705156856
    },
    {
        "content": "<p>To un-#xy:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsDomain</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hω</span> <span class=\"o\">:</span> <span class=\"n\">ω</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">ω</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">ω</span><span class=\"o\">,</span> <span class=\"n\">ω</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">S_closed</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"n\">ω</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"n\">ω</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"n\">ω</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">hω₃</span> <span class=\"o\">:</span> <span class=\"n\">ω</span> <span class=\"bp\">*</span> <span class=\"n\">ω</span> <span class=\"bp\">*</span> <span class=\"n\">ω</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">·</span> <span class=\"n\">linear_combination</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">hω</span>\n  <span class=\"n\">intro</span> <span class=\"n\">r</span> <span class=\"n\">hr</span> <span class=\"n\">s</span> <span class=\"n\">hs</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_insert</span><span class=\"o\">,</span> <span class=\"n\">mem_singleton</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hr</span> <span class=\"n\">hs</span>\n  <span class=\"k\">have</span> <span class=\"n\">hr'</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">ω</span><span class=\"o\">,</span> <span class=\"n\">ω</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">List.mem_cons</span><span class=\"o\">,</span> <span class=\"n\">List.mem_singleton</span><span class=\"o\">,</span> <span class=\"n\">List.not_mem_nil</span><span class=\"o\">,</span> <span class=\"n\">or_false</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"n\">hs'</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">ω</span><span class=\"o\">,</span> <span class=\"n\">ω</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">List.mem_cons</span><span class=\"o\">,</span> <span class=\"n\">List.mem_singleton</span><span class=\"o\">,</span> <span class=\"n\">List.not_mem_nil</span><span class=\"o\">,</span> <span class=\"n\">or_false</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">]</span>\n  <span class=\"n\">fin_cases</span> <span class=\"n\">hr'</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">fin_cases</span> <span class=\"n\">hs'</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sq</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">hω₃</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I would have expected to <em>not</em> have to turn <code>Finset</code>s into <code>List</code>s in order for <code>fin_cases</code> to work...</p>",
        "id": 412714781,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705156935
    },
    {
        "content": "<p>Here's a question about <code>fin_cases</code>. Right now its interface is that it tries to create exactly one goal per element of the <code>Finset</code>. Would it be OK if it accidentally creates too many?</p>\n<p>The problem is that <code>{0, 1, ω, ω ^ 2}</code> a priori has at most four elements, but you'd need to evaluate the <code>DecidableEq R</code> instance (or otherwise write a proof) to figure out that it has exactly four. The <code>fin_cases</code> tactic operates by trying to evaluate the underlying <code>List</code> of unique elements.</p>",
        "id": 412731541,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705170525
    },
    {
        "content": "<p>In particular, suppose <code>hx : x ∈ ({a, a} : Finset α)</code>. Would it be acceptible if <code>fin_cases hx</code> produced two goals?</p>",
        "id": 412731570,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705170568
    },
    {
        "content": "<p>I think that I would like it to produce two goals for x\\in {a,b} regardless of whether a=b because i can quite imagine situations where I don't know myself whether a=b at this point</p>",
        "id": 412731811,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705170798
    },
    {
        "content": "<p>I think this makes sense. I think we could make the evaluation core of <code>fin_cases</code> produce a list that merely covers the finset, without necessarily deduplicating. That would let it handle <code>insert</code> without needing to evaluate the <code>DecidableEq</code> instance. (Recall: <code>{a,b,c}</code> notation is syntactic sugar for <code>insert a (insert b (singleton c))</code>.)</p>",
        "id": 412732194,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705171172
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, just to not duplicate work - you're not actively working on this, right?</p>",
        "id": 417637279,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706100253
    },
    {
        "content": "<p>I'm not, go ahead if you want</p>",
        "id": 417669615,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706110293
    }
]