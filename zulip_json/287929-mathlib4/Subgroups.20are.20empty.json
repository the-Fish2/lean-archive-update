[
    {
        "content": "<p>Trust Lean!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Group.Submonoid.Operations</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Submonoid</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">One</span> <span class=\"n\">G</span> <span class=\"c1\">-- `Monoid.toOne`</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">One</span> <span class=\"n\">H</span> <span class=\"c1\">-- `H.one`</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">Nonempty</span> <span class=\"n\">G</span> <span class=\"c1\">-- `One.instNonempty`</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">Nonempty</span> <span class=\"n\">H</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">failed to synthesize</span>\n<span class=\"cm\">  Nonempty ↥H</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 438826688,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715785831
    },
    {
        "content": "<p>Works fine on Lean 4.9.0.</p>",
        "id": 438830559,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1715786845
    },
    {
        "content": "<p>The trace is</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>[Meta.synthInstance] ❌ Nonempty ↥H ▼\n  [] new goal Nonempty ↥H ▼\n    [instances] #[@Zero.instNonempty, @One.instNonempty, infSet_to_nonempty, supSet_to_nonempty, top_nonempty, bot_nonempty, @Nontrivial.to_nonempty, @instNonemptyOfInhabited, @instNonemptyOfMonad, @nonempty_lt, @Set.univ.nonempty, @Set.instNonemptyElemInsert, @Set.instNonemptyElemImage, @Set.instNonemptyRange, @Set.nonempty_Ici_subtype, @Set.nonempty_Iic_subtype, @Set.nonempty_Ioi_subtype, @Set.nonempty_Iio_subtype]\n  [] ❌ apply @Set.nonempty_Iio_subtype to Nonempty ↥H ▶\n  [] ❌ apply @Set.nonempty_Ioi_subtype to Nonempty ↥H ▶\n  [] ❌ apply @Set.nonempty_Iic_subtype to Nonempty ↥H ▶\n  [] ❌ apply @Set.nonempty_Ici_subtype to Nonempty ↥H ▶\n  [] ❌ apply @Set.instNonemptyRange to Nonempty ↥H ▶\n  [] ❌ apply @Set.instNonemptyElemImage to Nonempty ↥H ▶\n  [] ❌ apply @Set.instNonemptyElemInsert to Nonempty ↥H ▶\n  [] ❌ apply @Set.univ.nonempty to Nonempty ↥H ▶\n  [] ❌ apply @nonempty_lt to Nonempty ↥H ▶\n  [] ❌ apply @instNonemptyOfMonad to Nonempty ↥H ▶\n  [] ✅ apply @instNonemptyOfInhabited to Nonempty ↥H ▼\n    [tryResolve] ✅ Nonempty ↥H ≟ Nonempty ↥H\n    [] new goal Inhabited ↥H ▼\n      [instances] #[@Unique.instInhabited, @instInhabitedOfMonad, @Subtype.instInhabited]\n  [] ✅ apply @Subtype.instInhabited to Inhabited ↥H ▼\n    [tryResolve] ✅ Inhabited ↥H ≟ Inhabited ↥H\n  [resume] propagating (x_0 : G) → x_0 ∈ H → Inhabited ↥H to subgoal Inhabited ↥H of Nonempty ↥H ▼\n    [] size: 1\n    [] skip answer containing metavariables instNonemptyOfInhabited\n</code></pre></div>\n<p>I don't really know what the last message means, but it seems to lead to a failure even though there are several <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span>s and no <span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span>s in the last part of the trace, (EDIT:) even though there are further instances that can be tried. I would think that \"skipping\" <code>instNonemptyOfInhabited</code> should cause it to consider the next available instance in the list and not to give up altogether.</p>",
        "id": 438854236,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1715794412
    },
    {
        "content": "<p>In the case of <code>G</code>, the trace is fairly long (going via boolean algebras and biheyting algebras among other stuff; the usual order detours...), but finally reaches the <code>One.instNonempty</code> instance and then eventually finds a <code>One</code> for <code>G</code>. (The relevant instance <code>Monoid.toOne</code> is only the sixth that is tried.)</p>",
        "id": 438855192,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1715794779
    },
    {
        "content": "<p>BTW, <code>Zero.instNonempty</code> and <code>One.instNonemtpy</code> have very low priority (20) and so are tried last. Is there a reason behind that?</p>",
        "id": 438855630,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1715794941
    },
    {
        "content": "<p>I assume that's exactly the same reason as to why you tried to decouple the algebraic order hierarchy from the algebraic hierarchy: <code>One</code> is algebraic while <code>Nonempty</code> is not</p>",
        "id": 438855829,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715795016
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/4055\">lean#4055</a> is sufficient to fix this right? <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/Nonempty.20regression\">#mathlib4 &gt; Nonempty regression</a></p>",
        "id": 438855832,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1715795017
    },
    {
        "content": "<p>Oh right, it's the same issue</p>",
        "id": 438856026,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715795079
    },
    {
        "content": "<p>Still, I wonder why instance sythesis fails when trying <code>Subtype.instInhabited</code> rather than backtracking.</p>",
        "id": 438856705,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1715795341
    },
    {
        "content": "<p>You can make it work without removing the instance by inserting </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>      <span class=\"k\">if</span> <span class=\"n\">answer.result.numMVars</span> <span class=\"bp\">!=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span>\n        <span class=\"n\">return</span> <span class=\"o\">()</span>\n      <span class=\"k\">else</span>\n</code></pre></div>\n<p>into <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.SynthInstance.resume#doc\">docs#Lean.Meta.SynthInstance.resume</a> at L598.</p>",
        "id": 438870614,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1715800804
    },
    {
        "content": "<p>Should this be turned into an issue?</p>",
        "id": 438871007,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1715801000
    },
    {
        "content": "<p>Someone can ask about it in office hours but I imagine that the answer will be: \"You put poorly formed instances into the machine at your own risk.\"</p>",
        "id": 438875388,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1715802911
    },
    {
        "content": "<p>Mathlib seems to be building fine as-is with the change but <strong>seems</strong> slower to my eye</p>",
        "id": 438875550,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1715802972
    },
    {
        "content": "<p>Just as I said that </p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>error:<span class=\"w\"> </span>././././Mathlib/Topology/UniformSpace/Pi.lean:145:9-145:45:<span class=\"w\"> </span>failed<span class=\"w\"> </span>to<span class=\"w\"> </span>synthesize<span class=\"w\"> </span>instance\n<span class=\"w\">  </span>UniformSpace<span class=\"w\"> </span><span class=\"o\">(</span>ι<span class=\"w\"> </span>→<span class=\"w\"> </span>X<span class=\"o\">)</span>\n</code></pre></div>",
        "id": 438875623,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1715803008
    },
    {
        "content": "<p>Here is the list of all times this code branch is hit: <a href=\"https://gist.github.com/mattrobball/374f5c2951fbb92e129d59b7e92fa9f1\">https://gist.github.com/mattrobball/374f5c2951fbb92e129d59b7e92fa9f1</a></p>",
        "id": 438904418,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1715816892
    },
    {
        "content": "<p>After <a href=\"https://github.com/leanprover/lean4/pull/4055\">lean#4055</a>, <a href=\"https://gist.github.com/mattrobball/df5a9fa5d1b3130c0892d5d0f1753086\">https://gist.github.com/mattrobball/df5a9fa5d1b3130c0892d5d0f1753086</a></p>",
        "id": 438909880,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1715821077
    },
    {
        "content": "<p>Actually I think at least the message should be modified to reflect that you skip the whole branch instead of just that node.</p>",
        "id": 439226620,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1715953511
    },
    {
        "content": "<p>This is very interesting. What do you think for example of the first instance that is flagged by this, of the form:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">Finset.decidableForallOfDecidableSSubsets</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">t</span> <span class=\"bp\">⊂</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">⊂</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">h</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n    <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">⊂</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It has a very unusual form, and I am not sure it can ever fire. Should we just remove the instance?</p>",
        "id": 439227685,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1715953829
    },
    {
        "content": "<p>I think that is a good experiment</p>",
        "id": 439227890,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1715953895
    },
    {
        "content": "<p>Is it that unusual? Or do you mean the fact that it's a dependent function in <code>h : t ⊂ s</code> is unusual?</p>",
        "id": 439228138,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715953965
    },
    {
        "content": "<p>Yes, the fact that it's a dependent function is unusual -- how would typeclass inference check this assumption?</p>",
        "id": 439228537,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1715954099
    },
    {
        "content": "<p>Oh actually you're right. I found out that instances about Prop-dependent functions never apply</p>",
        "id": 439228779,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715954175
    },
    {
        "content": "<p>I don't really understand <em>why</em> though. <code>(∀ i : ι, Group (G i)) → Group (∀ i, G i)</code> works fine if <code>ι : Type*</code> even though TC inference can't \"find\" <code>i</code></p>",
        "id": 439229033,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715954256
    },
    {
        "content": "<p>I confirm that mathlib builds fine without this instance. <a href=\"https://github.com/leanprover-community/mathlib4/pull/12987\">#12987</a>.</p>",
        "id": 439237624,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1715956997
    },
    {
        "content": "<p>I am happy to send this off but will wait a bit for anyone to comment</p>",
        "id": 439238126,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1715957168
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Subgroups.20are.20empty/near/439228779\">said</a>:</p>\n<blockquote>\n<p>Oh actually you're right. I found out that instances about Prop-dependent functions never apply</p>\n</blockquote>\n<p>Sounds like some un-intended consequences of proof irrelevance casing</p>",
        "id": 439238496,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1715957290
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sébastien Gouëzel</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Subgroups.20are.20empty/near/439227685\">said</a>:</p>\n<blockquote>\n<p>This is very interesting. What do you think for example of the first instance that is flagged by this, of the form:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">Finset.decidableForallOfDecidableSSubsets</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">t</span> <span class=\"bp\">⊂</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">⊂</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">h</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n    <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">⊂</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It has a very unusual form, and I am not sure it can ever fire. Should we just remove the instance?</p>\n</blockquote>\n<p>Actually, the problems from this instance seem to come from using <code>refine'</code> in place of <code>refine</code></p>",
        "id": 439286350,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1715977083
    },
    {
        "content": "<p>Quite a few of the remaining ones do</p>",
        "id": 439286722,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1715977243
    },
    {
        "content": "<p>Either that or <code>convert</code></p>",
        "id": 439287812,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1715977835
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Subgroups.20are.20empty/near/438909880\">said</a>:</p>\n<blockquote>\n<p>After <a href=\"https://github.com/leanprover/lean4/pull/4055\">lean#4055</a>, <a href=\"https://gist.github.com/mattrobball/df5a9fa5d1b3130c0892d5d0f1753086\">https://gist.github.com/mattrobball/df5a9fa5d1b3130c0892d5d0f1753086</a></p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/12997\">#12997</a> replaces some <code>refine'</code>'s with <code>refine</code>'s guided by this list</p>",
        "id": 439292022,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1715980115
    },
    {
        "content": "<p>Should we forbid <code>refine'</code> in new contributions?</p>",
        "id": 439319897,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1716002005
    },
    {
        "content": "<p>There is only ~11192 occurrences left in mathlib master <span aria-label=\"oops\" class=\"emoji emoji-1f643\" role=\"img\" title=\"oops\">:oops:</span> <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 439319940,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1716002043
    },
    {
        "content": "<p>I like the more declarative syntax by default</p>",
        "id": 439570819,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716210637
    },
    {
        "content": "<p>I did encounter one instance where the straightforward <code>refine</code> replacement failed but <code>refine'</code> was ok.</p>",
        "id": 439571378,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716210829
    },
    {
        "content": "<p>I expect that is bad sign (for that instance)</p>",
        "id": 439571496,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716210859
    },
    {
        "content": "<p>I was very much against <code>refine</code> originally because it was less convenient to use than <code>refine'</code>. Looking back, it seems that my issue with it was mostly with the highlighting being janky. Now that the ununifyable holes get properly highlighted, it's actually very nice to use.</p>",
        "id": 439571632,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1716210910
    },
    {
        "content": "<p>I think there are certainly some use case for <code>refine'</code> (really <code>refine!</code>?) but it is very much overused right now</p>",
        "id": 439571864,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716210975
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Subgroups.20are.20empty/near/439319897\">said</a>:</p>\n<blockquote>\n<p>Should we forbid <code>refine'</code> in new contributions?</p>\n</blockquote>\n<p>If you've been following my recent posts, you might think that I would propose a linter for this (btw, there is already one for flagging <code>refine'</code>, suggesting to use <code>refine</code>).  However, for this usage, maybe there could be a CI action that looks at the diff and greps <code>refine'</code>, adding a label if it finds any.</p>",
        "id": 439575284,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716212107
    },
    {
        "content": "<p>I have! Completely separate question: are there any proto-autoformaters out there?</p>\n<p>Here:</p>\n<ul>\n<li>swap <code>refine'</code> for <code>refine</code></li>\n<li>capture errors and if the syntax is <code>_</code> replace with <code>?_</code></li>\n<li>if this fails, leave it changed and keep going</li>\n</ul>",
        "id": 439576708,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716212591
    },
    {
        "content": "<p>I think that you might even have the linter (with more work) output the positions of the <code>_</code> that require a <code>?</code> and then feed that to something like <code>sed</code> for the final replacement.</p>",
        "id": 439577002,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716212693
    },
    {
        "content": "<p>The final catching of errors would be a little more brittle...</p>",
        "id": 439577076,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716212722
    },
    {
        "content": "<p>Oh. That’s a good point. I was thinking of something written in Lean</p>",
        "id": 439577126,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716212743
    },
    {
        "content": "<p>Though, with the MetaTesting experiment, there was a way to try out new syntax replacing the old one, so maybe that too can be automated on top of that PR...</p>",
        "id": 439577217,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716212766
    },
    {
        "content": "<p>You may not even need to do the flagging first: you could get a CI cycle to try, for each <code>refine'</code>, a replacement of it by the correct <code>?_</code> and, only when it works, output the change.</p>",
        "id": 439577439,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716212837
    },
    {
        "content": "<p>I am not sure how to handle at once a chain of several <code>refine'</code>s in the same <code>tacticSeq</code> -- it might be quite expensive to make it try all subsets...</p>",
        "id": 439577553,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716212881
    },
    {
        "content": "<p>The errors seem to have the correct reference from the language server after doing the swap</p>",
        "id": 439577807,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716212950
    },
    {
        "content": "<p>So, here is a proposal: the linter detects <code>refine'</code> and the locations of the <code>_</code> that should become <code>?_</code>, produces the syntax using <code>?_</code> and runs <code>elabCommand</code> on that.  If successful, report success.</p>",
        "id": 439577811,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716212951
    },
    {
        "content": "<p>I think that <code>Try this:</code> cannot be used by linters, but once you know what to change, <code>sed</code> can finish up for you.</p>",
        "id": 439577948,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716213001
    },
    {
        "content": "<p>In fact, maybe as a first attempt you could even just replace all \"full\" <code>_</code>s in <code>refine'</code> by <code>?_</code> and think about cleaning up the unnecessary one later.</p>",
        "id": 439578216,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716213081
    },
    {
        "content": "<p>I remember that the very first <code>refine'</code> that the linter flagged was a <code>refine'</code> that did <em>not</em> have any <code>_</code>...</p>",
        "id": 439578283,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716213106
    },
    {
        "content": "<p>I imagine that capture error + auto-rewrite using pure Lean will come up again in the future. Is there no existing mechanism to approach this?</p>",
        "id": 439578288,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716213108
    },
    {
        "content": "<p>capture error -- ok, obviously.</p>",
        "id": 439578389,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716213129
    },
    {
        "content": "<p>auto-rewrite, you can probably do it by rewriting the whole file, looking at positions and doing surgical replacements.</p>",
        "id": 439578492,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716213162
    },
    {
        "content": "<p>Using the output of <code>logInfo</code>s is a no-go, in my experience, for essentially anything: it changes too much of the entering <del>syntax</del>formatting.</p>",
        "id": 439578666,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716213217
    },
    {
        "content": "<p>Yeah. Without stepping outside the current process would be nice</p>",
        "id": 439578690,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716213227
    },
    {
        "content": "<p>Can we change the elaboration of <code>refine'</code> itself?</p>",
        "id": 439578987,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716213306
    },
    {
        "content": "<p>The slight problem with rewriting the file is that you then have to wait for .oleans.</p>",
        "id": 439578994,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716213308
    },
    {
        "content": "<p>The linters go sequentially, so I think that you would need a CI cycle for the flagging and then one for the rewriting (at least).</p>",
        "id": 439579119,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716213348
    },
    {
        "content": "<p>I tried (quite successfully) this for the <code>theorem --&gt; lemma</code> substitution.</p>",
        "id": 439579211,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716213365
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Subgroups.20are.20empty/near/439578987\">said</a>:</p>\n<blockquote>\n<p>Can we change the elaboration of <code>refine'</code> itself?</p>\n</blockquote>\n<p>Very likely!  It was implemented for the port, right?  So it should be in Mathlib even, which would make it easy to change.</p>",
        "id": 439579362,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716213411
    },
    {
        "content": "<p>I’m mainly thinking about the clearing the existing 11000+ uses in bulk as much as possible</p>",
        "id": 439579518,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716213462
    },
    {
        "content": "<p>How frequent is it that, in a proof, there is a <code>refine'</code> downstream an earlier <code>refine'</code>?</p>",
        "id": 439579869,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716213560
    },
    {
        "content": "<p>Too frequent but not that frequent overall (pure feelings here)</p>",
        "id": 439579943,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716213588
    },
    {
        "content": "<p>Anyway, <code>refine</code> flags <code>_</code> that it cannot solve, so getting that information should be relatively easy.</p>",
        "id": 439580152,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716213647
    },
    {
        "content": "<p>After that, you can have a CI cycle to prep for bulk replacement of the first layer of <code>refine'</code>s.</p>",
        "id": 439580231,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716213678
    },
    {
        "content": "<p>There may even be a temporary <code>refine''</code> for the <code>refine'</code>s that cannot be directly converted to <code>refine'</code>s and that should be skipped by iterations of the previous steps.</p>",
        "id": 439580475,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716213762
    },
    {
        "content": "<p>I think 66-75% are just one <code>_ =&gt; ?_</code></p>",
        "id": 439580495,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716213771
    },
    {
        "content": "<p>Oh, with the multigoal linter you would know if there are more than 1!</p>",
        "id": 439580545,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716213791
    },
    {
        "content": "<p>And 95%+ should be amenable to the naive fix</p>",
        "id": 439580739,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716213852
    },
    {
        "content": "<p>So, actually, if you have `^ *refine' [^_]*_[^_]*$ you could try replacing and maybe it works a lot...</p>",
        "id": 439580777,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716213866
    },
    {
        "content": "<p>Out of curiosity, I am trying out this simple \"<code>refine'</code> with one <code>_</code>\" replacement: <a href=\"https://github.com/leanprover-community/mathlib4/pull/13059\">#13059</a>.</p>",
        "id": 439585459,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716215444
    },
    {
        "content": "<p>I am benching it, but it builds!</p>",
        "id": 439612446,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716223760
    }
]