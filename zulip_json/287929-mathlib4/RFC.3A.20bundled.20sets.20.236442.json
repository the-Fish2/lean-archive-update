[
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib4/pull/6442\">#6442</a>, I started implementing <a href=\"https://github.com/leanprover-community/mathlib4/pull/2202\">#2202</a> for sets (not maps yet). Generic definitions are in <code>Data/BundledSet/*</code>. I adjusted parts of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subsemigroup#doc\">docs#Subsemigroup</a> to the new API, then stopped for now. Before I put more work into this, I would prefer to get some feedback about design choices.</p>",
        "id": 412640510,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705104539
    },
    {
        "content": "<p>I'm not yet convinced that things like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">BotPred</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">bot</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">b</span>\n  <span class=\"n\">bot_subset</span> <span class=\"o\">{</span><span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">⊆</span> <span class=\"n\">t</span>\n</code></pre></div>\n<p>are the right design, and am a bit worried about asking Lean to find a typeclass indexed by a function type. But I need to think about this more probably</p>",
        "id": 412641775,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705105077
    },
    {
        "content": "<p>Note that <code>p</code> will be always something like <code>IsSubsemigroup</code> or <code>IsOpen</code>, not something you can unfold.</p>",
        "id": 412641915,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705105128
    },
    {
        "content": "<p>I do think that the part of your design that changes</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Submonoid</span> <span class=\"n\">where</span>\n   <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">M</span>\n   <span class=\"n\">one_mem</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">\\</span><span class=\"n\">mem</span> <span class=\"n\">carrier</span>\n</code></pre></div>\n<p>to something analogous to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Submonoid</span> <span class=\"n\">where</span>\n   <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">M</span>\n   <span class=\"n\">isSubmonoid</span> <span class=\"o\">:</span> <span class=\"n\">IsSubmonoid</span> <span class=\"n\">carrier</span>\n</code></pre></div>\n<p>is a good idea (in particularly, that design works much better with <span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span>'s <code>fprop</code>-like tactics than what we have today)</p>",
        "id": 412641984,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705105176
    },
    {
        "content": "<p>I don't know if it's worth trying to go through this intermediate state first</p>",
        "id": 412642013,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705105195
    },
    {
        "content": "<p>There is an exception for instances designed to automatically prove <code>SetInterPred</code> for algebraic subobjects but we can move them to a <code>deriving</code> handler.</p>",
        "id": 412642111,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705105220
    },
    {
        "content": "<p>Do you suggest</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Submonoid</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">M</span>\n  <span class=\"n\">isSubmonoid</span> <span class=\"o\">:</span> <span class=\"n\">IsSubmonoid</span> <span class=\"n\">carrier</span>\n</code></pre></div>\n<p>as you write above or</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">BundledSet</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span>\n  <span class=\"n\">prop</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">carrier</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span> <span class=\"o\">(</span><span class=\"n\">attr</span> <span class=\"o\">:=</span> <span class=\"n\">reducible</span><span class=\"o\">)</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Submonoid</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">OneMulClass</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">BundledSet</span> <span class=\"n\">M</span> <span class=\"n\">IsSubmonoid</span>\n</code></pre></div>\n<p>as I use?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>\n</code></pre></div>",
        "id": 412643499,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705105715
    },
    {
        "content": "<p>With my approach, you can prove generic theorems like <code>mem_weaken</code> or <code>weaken_weaken</code> that argue about different predicates.</p>",
        "id": 412643563,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705105747
    },
    {
        "content": "<p>I think your version is a more ambitious version of what I write above, and as such comes with more potential pitfalls to think about.</p>",
        "id": 412644182,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705105972
    },
    {
        "content": "<p>That's why I decided to take a pause and ask for feedback.</p>",
        "id": 412644310,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705106024
    },
    {
        "content": "<p>Note that for my suggestion above to work with dot notation, you actually need to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Zulip</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">WithCarrier</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">IsSubmonoid</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">one_mem</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span>\n  <span class=\"n\">mul_mem</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span>\n\n<span class=\"c1\">-- `WithCarrier` is a hack to make `mul_mem` dot notation work;</span>\n<span class=\"c1\">-- we need the `IsSubmonoid ` to be seen as a parent structure,</span>\n<span class=\"c1\">-- not just a field; and so `carrier` needs to come before the extends</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Submonoid</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">WithCarrier</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">IsSubmonoid</span> <span class=\"n\">carrier</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Submonoid</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">S.mul_mem</span>  <span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 412645014,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705106279
    },
    {
        "content": "<p>My goal is to replace <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SetLike#doc\">docs#SetLike</a> with a single structure and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MulMemClass#doc\">docs#MulMemClass</a> etc with <code>[BundledSet.Implies _ _]</code> so that we can have generic theorems and don't search for <code>SetLike</code> every time.</p>",
        "id": 412646505,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705106735
    },
    {
        "content": "<p>The main concern I have right now is that this doesn't work for things like <code>SetLike Finset</code> (which admittedly I think we currently don't use); or in general, any set-like objects that carry extra computational data</p>",
        "id": 412646922,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705106859
    },
    {
        "content": "<p>But you should take my comments above as skepticism/hesitation, and not as an objection</p>",
        "id": 412647224,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705106966
    },
    {
        "content": "<p>I think that having common data for all algebraic subobjects is already a big improvement.</p>",
        "id": 412648728,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705107548
    },
    {
        "content": "<p>My goal is to have it for algebra and topology.</p>",
        "id": 412649219,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705107793
    },
    {
        "content": "<p>Indeed, <code>Finset</code> won't fit this scheme.</p>",
        "id": 412649238,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705107807
    },
    {
        "content": "<p>This issue becomes more important for functions because we want to cover <code>Equiv</code>s.</p>",
        "id": 412649381,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705107872
    },
    {
        "content": "<p>I'm OK with having a common structure for <code>*Hom</code> and a different structure for <code>Finsupp</code> but I want to have <code>map_add</code> that works for <code>Hom</code>s and <code>Equiv</code>s.</p>",
        "id": 412649495,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705107939
    },
    {
        "content": "<p>Of course, this is what <strong>I</strong> am OK with. I will need to convince more people to push this change.</p>",
        "id": 412649609,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705107993
    },
    {
        "content": "<p>I think that this is a sufficiently large and important refactor to tag all <span class=\"user-group-mention\" data-user-group-id=\"2494\">@maintainers</span> here.</p>",
        "id": 412653567,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705110203
    },
    {
        "content": "<p>I'm excited to see you take this forward! Finding a uniform representation is a good step towards taming the complexity of the current subobject setup.</p>",
        "id": 412706135,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1705148594
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/287929-mathlib4/topic/RFC.3A.20bundled.20sets.20.236442/near/412646505\">said</a>:</p>\n<blockquote>\n<p>so that we can have generic theorems and don't search for <code>SetLike</code> every time.</p>\n</blockquote>\n<p>Is this really an issue in Lean 4? As far as I can tell, since there are very few classes <code>extend</code>ing SetLike (I believe the actual number is 0) and everything is handled with \"unbundled inheritance\", keyed matching will reject most instances almost directly. That is the main motivation for <a href=\"https://github.com/leanprover-community/mathlib4/pull/8386\">#8386</a>.</p>",
        "id": 412706322,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1705148753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/RFC.3A.20bundled.20sets.20.236442/near/412646922\">said</a>:</p>\n<blockquote>\n<p>The main concern I have right now is that this doesn't work for things like <code>SetLike Finset</code> (which admittedly I think we currently don't use); or in general, any set-like objects that carry extra computational data</p>\n</blockquote>\n<p>This could be fixed by relaxing the predicate from <code>Set α → Prop</code> to <code>Set α → Sort*</code>. Although I suppose we'd lose the properties deriving from <code>SetLike.coe_injective</code>. So maybe it should look like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">BundledSet</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">Subsingleton</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span>\n  <span class=\"n\">prop</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">carrier</span>\n</code></pre></div>\n<p>(I can't say if the typeclass system would work well with the ∀, or whether we should have an <code>EverywhereSubsingleton p := ∀ x, Subsingleton (p x)</code> class instead, like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DecidablePred#doc\">docs#DecidablePred</a> corresponds to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Decidable#doc\">docs#Decidable</a>.)</p>",
        "id": 412706828,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1705149213
    },
    {
        "content": "<p>I'm also somewhat worried about the consequence of losing the <code>Submonoid</code> / <code>Subring</code> etc namespaces to put declarations under; it's great when we can unify a bunch of things as a single declaration under <code>BundledSet</code>, but things will become messy when we can't</p>",
        "id": 412707025,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705149409
    },
    {
        "content": "<p>We can still have <code>Submonoid</code>/<code>Subring</code> namespaces.</p>",
        "id": 412718526,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705160011
    },
    {
        "content": "<p><code>DecidablePred</code> is reducible, so it doesn't matter.</p>",
        "id": 412721837,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705162806
    },
    {
        "content": "<p>So, is there any conclusion?</p>",
        "id": 412854718,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705274402
    },
    {
        "content": "<p>I just came up with an interesting remark: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subgroup#doc\">docs#Subgroup</a> won't be eligible for your <code>BundledSet</code> approach once we have refactored it to work over monoids</p>",
        "id": 413023709,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705350007
    },
    {
        "content": "<p>Currently, the definition is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Subgroup</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">Submonoid</span> <span class=\"n\">G</span> <span class=\"n\">where</span>\n  <span class=\"n\">inv_mem'</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span>\n</code></pre></div>\n<p>which is one data field (<code>carrier : Set G</code>) and many Prop fields (which for <code>BundledSet</code> purposes would be merged into a single <code>prop : IsSubgroup carrier</code> field). If we want to generalize subgroups to monoids in a defeq-sensible way, we need something along the lines of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Subgroup</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">Submonoid</span> <span class=\"n\">G</span> <span class=\"n\">where</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">carrier</span>\n  <span class=\"n\">mul_left_inv</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 413024162,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705350290
    },
    {
        "content": "<p>Since most bundled sets in algebra build on <code>Subgroup</code>, your <code>BundledSet</code> approach (as currently proposed, at least) would apply to barely anything. And in turn merging your current <code>BundledSet</code> approach would make refactoring <code>Subgroup</code> much harder later. I think this is a pretty serious concern.</p>",
        "id": 413024537,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705350466
    },
    {
        "content": "<p>I am mentioning <code>Subgroup</code> here, but the same argument applies to subobjects of any structure that has Type-valued fields which can be uniquely determined by the other ones (I offer we call these \"propositionally redundant fields\"), eg <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sublattice#doc\">docs#Sublattice</a>, whose two data fields can be recovered from <code>≤</code> alone.</p>",
        "id": 413024914,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705350624
    },
    {
        "content": "<p>Do we have intentions to refactor <code>Subgroup</code> to be apply to <code>Monoid</code>s?</p>",
        "id": 413025106,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1705350742
    },
    {
        "content": "<p>Current <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sublattice#doc\">docs#Sublattice</a> doesn't have any extra data fields.</p>",
        "id": 413025364,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705350904
    },
    {
        "content": "<p>BTW, the <code>Subsingleton</code> approach mentioned above covers this.</p>",
        "id": 413025394,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705350927
    },
    {
        "content": "<p>Though we won't have nice <code>SetInterPred</code> etc.</p>",
        "id": 413025423,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705350954
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/RFC.3A.20bundled.20sets.20.236442/near/413025106\">said</a>:</p>\n<blockquote>\n<p>Do we have intentions to refactor <code>Subgroup</code> to be apply to <code>Monoid</code>s?</p>\n</blockquote>\n<p>This has been discussed before, see <a href=\"#narrow/stream/116395-maths/topic/Multiplicative.20subgroups.20of.20a.20ring\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiplicative.20subgroups.20of.20a.20ring</a></p>",
        "id": 413025433,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705350961
    },
    {
        "content": "<p>Do we really care about definitional equalities?</p>",
        "id": 413025536,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705351019
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/287929-mathlib4/topic/RFC.3A.20bundled.20sets.20.236442/near/413025364\">said</a>:</p>\n<blockquote>\n<p>Current <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sublattice#doc\">docs#Sublattice</a> doesn't have any extra data fields.</p>\n</blockquote>\n<p>No my point is that it technically makes sense to talk about sublattices of a preorder (well, maybe partial order to ensure unicity).</p>",
        "id": 413025543,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705351024
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/287929-mathlib4/topic/RFC.3A.20bundled.20sets.20.236442/near/413025536\">said</a>:</p>\n<blockquote>\n<p>Do we really care about definitional equalities?</p>\n</blockquote>\n<p>I would think for cases like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=circle#doc\">docs#circle</a> we do, at least remotely.</p>",
        "id": 413025588,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705351052
    },
    {
        "content": "<p>What's wrong with having <code>Inv.inv</code> defined using <code>Classical.choice</code> on a <code>Subgroup</code>? Do we (plan to) have dependent types that need this definitional equality?</p>",
        "id": 413025712,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705351115
    },
    {
        "content": "<p>That sounds pretty annoying to me; I don't want the additive subgroup of <code>ℕ × ℤ</code> for <code>.fst = 0</code>  to have non-computable negation</p>",
        "id": 413037611,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705357492
    },
    {
        "content": "<p>Note that basic operations like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sup.sup#doc\">docs#Sup.sup</a> will lead to noncomputable inverse for subgroups of monoids.</p>",
        "id": 413038767,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705358116
    },
    {
        "content": "<p>So, is there any conclusion about bundled sets?</p>",
        "id": 418880306,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706633386
    },
    {
        "content": "<p>Let me cross-link an alternative proposal: <a href=\"#narrow/stream/287929-mathlib4/topic/Bundled.20sets.2Ffunctions.20with.20even.20more.20classes\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Bundled.20sets.2Ffunctions.20with.20even.20more.20classes</a></p>",
        "id": 418995797,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706692585
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/287929-mathlib4/topic/RFC.3A.20bundled.20sets.20.236442/near/412706828\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/RFC.3A.20bundled.20sets.20.236442/near/412646922\">said</a>:</p>\n<blockquote>\n<p>The main concern I have right now is that this doesn't work for things like <code>SetLike Finset</code> (which admittedly I think we currently don't use); or in general, any set-like objects that carry extra computational data</p>\n</blockquote>\n<p>This could be fixed by relaxing the predicate from <code>Set α → Prop</code> to <code>Set α → Sort*</code>. Although I suppose we'd lose the properties deriving from <code>SetLike.coe_injective</code>. So maybe it should look like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">BundledSet</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">Subsingleton</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span>\n  <span class=\"n\">prop</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">carrier</span>\n</code></pre></div>\n<p>(I can't say if the typeclass system would work well with the ∀, or whether we should have an <code>EverywhereSubsingleton p := ∀ x, Subsingleton (p x)</code> class instead, like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DecidablePred#doc\">docs#DecidablePred</a> corresponds to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Decidable#doc\">docs#Decidable</a>.)</p>\n</blockquote>\n<p>This change seems indeed to work well:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">BundledSet</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">Subsingleton</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n    <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span>\n  <span class=\"kn\">protected</span> <span class=\"n\">prop</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">carrier</span>\n</code></pre></div>",
        "id": 421282152,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1707842126
    },
    {
        "content": "<p>Some experiments later and it looks like <code>Finset</code> can be practically implemented with the <code>Sort</code>-valued <code>BundledSet</code> as well.</p>",
        "id": 421287140,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1707843734
    },
    {
        "content": "<p>This seems like a very big proposal, so IMO we should cut it into separate steps to see which ones are worth it.</p>\n<ul>\n<li>What I'll call the first step: I see no reason that replacing <code>structure Submonoid</code> with <code>@[reducible] def Submonoid := BundledSet IsSubmonoid</code> won't work. This would essentially reintegrate the deprecated unbundled subobjects into the main hierarchy. On the other hand, we shouldn't expect too many gains from this switch, and it will be quite disruptive (although we'd be able to switch over each definition one by one). Perhaps automation/tactics are helped by the uniformity of <code>BundledSet</code>.</li>\n<li>Simultaneously we could redefine <code>MulMemClass M S</code> as <code>∀ (s : S), IsMulMem M s</code>. I expect that this brings some deduplication but otherwise is not too exciting.</li>\n<li>Then we can define new classes such as <code>Implies</code> to make generic operators such as the empty set and intersection. This seems like an obvious advantage in expressivity, so if it works correctly (which I believe it likely will), this would make the previous step pay off.</li>\n<li>The next step is to use the <code>Implies</code> class to automate generic declarations, instead of the current variety of <code>___MemClass</code>es. I don't see why \"so that we can have generic theorems and don't search for <code>SetLike</code> every time\" is a convincing argument for this: the discrimination tree matching makes this very fast (just like <a href=\"https://github.com/leanprover-community/mathlib4/pull/8386\">#8386</a> did for <code>FunLike</code>). If anything, it seems like the search will be more expensive since <code>Implies IsMulMem _ _ =?= Implies IsOneMem _ _</code> is slower to fail than not considering <code>IsOneMem</code> at all.</li>\n</ul>",
        "id": 421290680,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1707844933
    },
    {
        "content": "<p>So in conclusion: I am cautiously optimistic that going ahead with the first three steps will prove to be worth it. I am not convinced about the last one, but I'd like very much to be proven wrong!</p>",
        "id": 421291081,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1707845085
    },
    {
        "content": "<p>We can use generic <code>Implies</code> only for forgetful functors.</p>",
        "id": 421302367,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707849296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/287929-mathlib4/topic/RFC.3A.20bundled.20sets.20.236442/near/412706828\">said</a>:</p>\n<blockquote>\n<p>This could be fixed by relaxing the predicate from <code>Set α → Prop</code> to <code>Set α → Sort*</code>. Although I suppose we'd lose the properties deriving from <code>SetLike.coe_injective</code>. So maybe it should look like:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">BundledSet</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">Subsingleton</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span>\n  <span class=\"n\">prop</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">carrier</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I wonder if that typeclass parameter would cause performance issues since it would mean that <code>inferInstance : ∀ x, Subsingleton (p x)</code> appears in the definitions of so many <code>abbrev</code>s, e.g. <code>abbrev Submonoid M [Monoid M] := @BundledSet M IsSubmonoid inferInstance</code>.</p>\n<p>Would any of these alternatives be an improvement?</p>\n<ul>\n<li>Using <code>Trunc</code>:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">BundledSet</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span>\n  <span class=\"n\">prop'</span> <span class=\"o\">:</span> <span class=\"n\">Trunc</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">carrier</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">Subsingleton</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">s</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">BundledSet.prop</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">BundledSet</span> <span class=\"n\">α</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">s.carrier</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Trunc.recOnSubsingleton</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">p</span> <span class=\"n\">s.carrier</span><span class=\"o\">)</span> <span class=\"n\">s.prop'</span> <span class=\"n\">id</span>\n</code></pre></div>\n<ul>\n<li>Using a <code>Subsingleton</code> field:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">BundledSet</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span>\n  <span class=\"n\">prop</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">carrier</span>\n  <span class=\"o\">[</span><span class=\"n\">subsingleton</span> <span class=\"o\">:</span> <span class=\"n\">Subsingleton</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">carrier</span><span class=\"o\">)]</span>\n</code></pre></div>\n<ul>\n<li>Adding the <code>[∀ s, Subsingleton (p s)]</code> hypothesis only when you need the coercion to <code>Set α</code> to be injective.</li>\n</ul>",
        "id": 428230021,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711060940
    },
    {
        "content": "<p>I was up to asking why not having bundled functions, as well as bundled sets, and I'd probably ask the question in the other direction—Why not copying for set the funlike classes? (So there would be SubmonoidClass, SubgroupClass, SubmoduleClass, etc.)</p>",
        "id": 428234563,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1711063705
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MulMemClass#doc\">docs#MulMemClass</a></p>",
        "id": 428234657,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1711063773
    },
    {
        "content": "<p>I think about ways to reduce code duplications without loss of generality/speed.</p>",
        "id": 428234751,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1711063814
    },
    {
        "content": "<p>Also, it would be nice to have polymorphic lemmas like <code>map_map</code> for any compatible <code>FunLike</code>s and <code>SetLike</code>s.</p>",
        "id": 428234799,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1711063851
    },
    {
        "content": "<p>What do people do in other proof assistants?</p>",
        "id": 428237009,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1711065310
    },
    {
        "content": "<p>this seems like a bit of a lean-specific problem, so it's difficult to compare with other systems</p>",
        "id": 428237799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711065832
    },
    {
        "content": "<p>Let me come back to this and <a href=\"#narrow/stream/287929-mathlib4/topic/Bundled.20sets.2Ffunctions.20with.20even.20more.20classes\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Bundled.20sets.2Ffunctions.20with.20even.20more.20classes</a></p>\n<h1>What issues I want to be solved</h1>\n<ul>\n<li>code duplication between various <code>SetLike</code> and <code>DFunLike</code> objects;</li>\n<li>unpredictable holes in API;</li>\n<li>inconsistent names;</li>\n<li>no way to talk about a type which is an <code>AddMonoidHomClass</code> with pointwise addition; the actual example I want to have is \"an outer measure-like type with pointwise bottom and order\"</li>\n</ul>\n<h1>Possible approaches</h1>\n<h2>Uniform structures with generic instances</h2>\n<p>... as described above and in <a href=\"https://github.com/leanprover-community/mathlib4/pull/2202\">#2202</a></p>\n<p>The main disadvantage of this approach is that in some cases, a bundled homomorphism/bundled set may need to use different order or multiplication.<br>\nE.g., <code>1</code> can be the bundled version of \"cons _ 1<code> or </code>id`, but there are more examples, see <a href=\"#narrow/stream/287929-mathlib4/topic/Order.20on.20measures\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Order.20on.20measures</a> for examples about order</p>\n<p>While this is the approach I originally suggested, I see no way to accomodate for these special cases.</p>\n<h2>[PointwiseAdd] etc classes</h2>\n<p>Suggested by <span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span> in <a href=\"#narrow/stream/287929-mathlib4/topic/Bundled.20sets.2Ffunctions.20with.20even.20more.20classes\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Bundled.20sets.2Ffunctions.20with.20even.20more.20classes</a></p>\n<p>Instead of imposing any restrictions on the types, we define typeclasses saying that various operations (order, algebraic operations, inf/sInf for bundled sets) agree with pointwise operations.</p>\n<p>I see two disadvantages compared to status quo:</p>\n<ol>\n<li>\n<p>Generic lemmas are never <code>dsimp</code>, even if they are <code>dsimp</code> for 95% of the actual types.<br>\n  Thus, <strong>if we care</strong> about <code>dsimp</code> lemmas, then we need to formulate them for all types anyway;</p>\n</li>\n<li>\n<p>If we add generic instances like <code>[FunLike F α M] [Monoid M] [Mul F] [One F] [SMul Nat F] [PointwiseOne F] [PointwiseMul F] [PointwiseSMul Nat F] : Monoid F</code>, then we may get huge instance terms, especially once we start talking about types like <code>(E →L[K] F) →L[K] (F →L[K] G) →L[K] (E →L[K] G)</code>. I have no data here.</p>\n</li>\n</ol>\n<h2>Meta programming</h2>\n<p>We can have a meta program that specializes some generic theory to each bundled hom/set type. Maybe we can even build some kind of \"hierarchy builder\" that takes a file with all morphisms we care about and declares the corresponding types, theorems, and projections.</p>\n<p>The main advantage of this approach is that we can get consistent naming and we can have autogenerated <code>dsimp</code> lemmas.</p>\n<p>The main disadvantages I see:</p>\n<ol>\n<li>This approach requires a lot of careful meta-programming, so fewer people can implement it and fewer people will understand how it works.</li>\n<li>We still don't get a way to generalize <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.Measure.ae#doc\">docs#MeasureTheory.Measure.ae</a> to outer measures and have lemmas like <code>ae_mono</code> without code duplication.</li>\n</ol>",
        "id": 434567368,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1713684389
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> <span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span> What do you think?<br>\n<span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> You may be interested since you're working on dropping some generic instances<br>\n<span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Are my concerns about blowup of the size of instances seem valid? If yes, any ideas how to avoid it?</p>",
        "id": 434593193,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1713710092
    },
    {
        "content": "<p>I think it would be interesting to investigate the third approach in more detail. And maybe we should even see if we can use actual Hierarchy Builder to help with this job.</p>",
        "id": 434701433,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1713778542
    },
    {
        "content": "<p>Does <span class=\"user-mention\" data-user-id=\"110193\">@Cyril Cohen</span> have some opinion about this question?</p>",
        "id": 435061705,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1713903404
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  How would you formulate a lemma about any <code>OuterMeasure</code>-like bundled map with pointwise order/addition/... (depending on a lemma)?</p>",
        "id": 435061977,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1713903513
    },
    {
        "content": "<p>Assuming that meta code can build us a hierarchy with basic stuff.</p>",
        "id": 435062055,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1713903550
    },
    {
        "content": "<p>Ooh, I don't claim that I can address any of the disadvantages you point out in any of your suggested approaches.</p>",
        "id": 435098555,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1713927153
    },
    {
        "content": "<p>Of course, we can create \"generic\" instances + autodeclare all relevant instances for each specific class to speed up search.</p>",
        "id": 435098685,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1713927229
    }
]