[
    {
        "content": "<p>I'm curious if there's a community consensus on the following issue:</p>\n<blockquote>\n<p>If a goal can be proved either by a sophisticated one-shot tactic (<code>nlinarith</code>, <code>field_simp</code>, <code>continuity</code> etc), or by a longer hand-tailored argument (explicitly invoking a chain of low-level lemmas), which should one use for library code?</p>\n</blockquote>\n<p>The \"big hammer\" tactics tend to be significantly slower than hand-written arguments (some more than others); but on the other hand they frequently result in shorter and more human-readable proofs, and big-hammer proofs are probably more robust and maintainable in the long run than fiddly hand-tailored arguments. So it's a tradeoff – how much do we value CPU power vs. human brainpower?</p>\n<p>(This came up because of a PR I was reviewing, which had four <code>nlinarith</code>s and four <code>field_simp</code>s all within a single ~20-line proof. I proposed a far faster hand-rolled argument – which almost immediately broke, because one of the lemmas it used got renamed overnight. Perhaps one should live with slowness for the sake of easier maintainability?)</p>",
        "id": 429201045,
        "sender_full_name": "David Loeffler",
        "timestamp": 1711285887
    },
    {
        "content": "<p>I think breakage due to lemma renaming is something that we should try to resolve with better renaming tools, rather than by trying to avoid ever mentioning lemma names</p>",
        "id": 429201947,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711286531
    },
    {
        "content": "<p>What lemma was it?</p>",
        "id": 429202025,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711286570
    },
    {
        "content": "<p>I think there are two sides to easy maintainability here; chance of being broken by changes elsewhere in the library, vs ease of future refactoring (lemma reordering, typeclass generalizations) due to the argument being more explicit</p>",
        "id": 429202101,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711286629
    },
    {
        "content": "<p>The CPU vs human brainpower tradeoff is supposed to be solved by <code>says</code>, which lets the CPU cost be spent upfront rather than for every editor of the file; though this comes with its own maintenance burdens.</p>",
        "id": 429202231,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711286702
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  <code>says</code> is specifically for <code>simp</code>, right? I don't think one can do <code>linarith says x</code>.</p>",
        "id": 429203161,
        "sender_full_name": "David Loeffler",
        "timestamp": 1711287030
    },
    {
        "content": "<p>I think it supports a few other tactics, but indeed not <code>linarith</code></p>",
        "id": 429203270,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711287063
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/To.20automate.20or.20not.20to.20automate.3F/near/429202025\">said</a>:</p>\n<blockquote>\n<p>What lemma was it?</p>\n</blockquote>\n<p>As you probably guessed it was one of the renames from <a href=\"https://github.com/leanprover-community/mathlib4/pull/11530\">#11530</a>, specifically <code>add_sub_cancel'</code>. Having deprecation tools which tell you what changes need to be made is already a big advance; but the current tooling doesn't cover many other kinds of change, like adjusting the arguments to an existing lemma, or swapping two pre-existing names.</p>",
        "id": 429204005,
        "sender_full_name": "David Loeffler",
        "timestamp": 1711287325
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/To.20automate.20or.20not.20to.20automate.3F/near/429203270\">said</a>:</p>\n<blockquote>\n<p>I think it supports a few other tactics, but indeed not <code>linarith</code></p>\n</blockquote>\n<p>Could one perhaps make this functionality available for arbitrary tactics by adapting the existing <code>show_term</code> command somehow? That will usually result in impossibly long proof terms, but perhaps the resulting term can be compressed or stored externally, and then regenerated if it stops working.</p>",
        "id": 429209039,
        "sender_full_name": "David Loeffler",
        "timestamp": 1711289475
    },
    {
        "content": "<p>Would linarith be amenable to generating certificates like polyrith?</p>",
        "id": 429209376,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1711289716
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/287929-mathlib4/topic/To.20automate.20or.20not.20to.20automate.3F/near/429209376\">said</a>:</p>\n<blockquote>\n<p>Would linarith be amenable to generating certificates like polyrith?</p>\n</blockquote>\n<p>I've not played with <code>polyrith</code> much, but I'm sceptical whether generating and/or verifying certificates for <code>linarith</code> can be done any quicker than re-running the algorithm. </p>\n<p>I'm thinking here of really easy cases of <code>linarith</code>, like proving <code>1 + a &lt; 1 + b</code> when <code>a &lt; b</code> is known – of course this is immediate from <code>add_lt_add_left</code>, but using <code>linarith</code> instead saves you (and later readers) the trouble of memorising a whole catalogue of lemma names.</p>",
        "id": 429211797,
        "sender_full_name": "David Loeffler",
        "timestamp": 1711290502
    },
    {
        "content": "<p>I think probably <code>gcongr</code> is more appropriate as a middle ground here</p>",
        "id": 429213810,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711291367
    },
    {
        "content": "<p>Generally I'm in favor of more automated proofs.</p>",
        "id": 429235680,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1711305669
    },
    {
        "content": "<p>Some of the tactics mentioned above are in dire need of a rewrite.</p>",
        "id": 429235689,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1711305686
    },
    {
        "content": "<p>Field_simps in particular which badly abuses the discharger mechanism.</p>",
        "id": 429235791,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1711305793
    },
    {
        "content": "<p>Also I suspect the linarith could adopt the main shortcut omega uses to terminate early. (Index both upper and lower bounds together, according to the coefficients, and stop if they contradict even before you finish eliminating variables.)</p>\n<p>Generally, a rewrite of linarith with a non-Mathlib specific typeclass would be great.</p>",
        "id": 429235933,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1711305946
    },
    {
        "content": "<p>This is the kind of task which is very unlikely to happen organically, I would imagine. You're more likely to get more mathlib theorems formalised by people working on projects than you are to get tactics appearing out of nowhere -- right now it seems that mathematicians are easily able to find projects which keep them occupied, but I'm not sure it's the same with tactics. Could this sort of rewrite be done by a CS masters student or are you better off just paying someone to do it?</p>",
        "id": 429236307,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711306210
    },
    {
        "content": "<p>linarith is only used in Mathlib currently, and omega covers most of the programming applications of this corner of tactic space, so indeed linarith may be orphaned.</p>",
        "id": 429236623,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1711306460
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/To.20automate.20or.20not.20to.20automate.3F/near/429235680\">said</a>:</p>\n<blockquote>\n<p>Generally I'm in favor of more automated proofs.</p>\n</blockquote>\n<p>So in my example – showing <code>1 + a &lt; 1 + b</code> with <code>a &lt; b</code> in the context – would you favour <code>linarith</code>, or an appeal to the specific lemma? For the sake of argument, let's keep this to <code>linarith</code> as it currently exists, not a hypothetical optimised rewrite.</p>",
        "id": 429237581,
        "sender_full_name": "David Loeffler",
        "timestamp": 1711307152
    },
    {
        "content": "<p>For that one I'd prefer <code>gcongr</code></p>",
        "id": 429237668,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711307198
    },
    {
        "content": "<p>OK OK, let's say something that can't be <code>gcongr</code>'d, like <code>2 * a + b &lt; a + 2 * b</code> given <code>a &lt; b</code>.</p>",
        "id": 429237810,
        "sender_full_name": "David Loeffler",
        "timestamp": 1711307295
    },
    {
        "content": "<p>Then I'd personally prefer <code>linarith</code> because it's easier to write and easier to read</p>",
        "id": 429237827,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711307331
    },
    {
        "content": "<p>We really really need to get the overhead (de Bruijn) factor down if we want to make serious progress with maths in Lean. Just because we have already suffered through writing maths without enough automation doesn't mean we should impose this on others. :-)</p>",
        "id": 429238350,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1711307788
    },
    {
        "content": "<p>Personally, I think that the only reason <em>not</em> to use automation is \"painful slow-downs\" and this should only be an incentive to make automation more efficient, not to write more detailed proofs.</p>",
        "id": 429238972,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711308375
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> \"If\"?!</p>",
        "id": 429241347,
        "sender_full_name": "David Loeffler",
        "timestamp": 1711309984
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/To.20automate.20or.20not.20to.20automate.3F/near/429235933\">said</a>:</p>\n<blockquote>\n<p>Generally, a rewrite of linarith with a non-Mathlib specific typeclass would be great.</p>\n</blockquote>\n<p>Upstreaming LinearOrderedSemiring out of mathlib sounds like it will create a lot of work</p>",
        "id": 429241454,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711310066
    },
    {
        "content": "<p>My work untangling dependencies (eg <a href=\"https://github.com/leanprover-community/mathlib4/pull/11633\">#11633</a>) will help for that, FWIW</p>",
        "id": 429241530,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711310131
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/To.20automate.20or.20not.20to.20automate.3F/near/429236623\">said</a>:</p>\n<blockquote>\n<p>linarith is only used in Mathlib currently, and omega covers most of the programming applications of this corner of tactic space, so indeed linarith may be orphaned.</p>\n</blockquote>\n<p>Keep in mind that omega is not a replacement for linarith: Omega works for nat and int, while linarith works on linearly ordered rings. You can't use omega on most of the goals in mathlib that use linarith currently, for more than skin-deep reasons like the names of typeclasses.</p>",
        "id": 429242153,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711310506
    },
    {
        "content": "<p>I think Scott rather meant that nobody has a natural incentive to make linarith better because the people using it (= mathematicians) are also the ones who are the least capable of doing so</p>",
        "id": 429242251,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711310591
    },
    {
        "content": "<p>And in particular the shortcuts that omega can take over Int (rounding coefficients in the favorable direction) plays into its ability to shortcut early. When you're working over Rat you don't as often get lucky with early contradictions.</p>",
        "id": 429242341,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1711310664
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/To.20automate.20or.20not.20to.20automate.3F/near/429242153\">said</a>:</p>\n<blockquote>\n<p>Keep in mind that omega is not a replacement for linarith: Omega works for nat and int, while linarith works on linearly ordered rings. You can't use omega on most of the goals in mathlib that use linarith currently, for more than skin-deep reasons like the names of typeclasses.</p>\n</blockquote>\n<p>I think that was exactly the point: that there are lots of things which linarith can do but omega can't, <em>but</em> those are mostly things which mathematicians care about and computer scientists don't, so the people with the skillset to make <code>linarith</code> better don't have the incentive to do so.</p>",
        "id": 429242342,
        "sender_full_name": "David Loeffler",
        "timestamp": 1711310667
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/To.20automate.20or.20not.20to.20automate.3F/near/429238350\">said</a>:</p>\n<blockquote>\n<p>We really really need to get the overhead (de Bruijn) factor down if we want to make serious progress with maths in Lean. Just because we have already suffered through writing maths without enough automation doesn't mean we should impose this on others. :-)</p>\n</blockquote>\n<p>I claim that while reducing the de Bruijn factor is super important for users and so we need the tools to exist, but amenability to refactors is more important within mathlib and so that doesn't necessarily meant we should use those tools.</p>",
        "id": 429242433,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711310727
    },
    {
        "content": "<p>(for instance, using norm_num in a proof about division currently prevents it being generalized to semifields)</p>",
        "id": 429242513,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711310767
    },
    {
        "content": "<p>But often higher automation makes refactoring and maintenance easier! It's not a one way street.</p>",
        "id": 429242536,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1711310794
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/To.20automate.20or.20not.20to.20automate.3F/near/429242536\">said</a>:</p>\n<blockquote>\n<p>But often higher automation makes refactoring and maintenance easier! It's not a one way street.</p>\n</blockquote>\n<p>Indeed, that was exactly the point I raised at the start of this conversation :-)</p>",
        "id": 429242584,
        "sender_full_name": "David Loeffler",
        "timestamp": 1711310852
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/To.20automate.20or.20not.20to.20automate.3F/near/429242536\">said</a>:</p>\n<blockquote>\n<p>But often higher automation makes refactoring and maintenance easier! It's not a one way street.</p>\n</blockquote>\n<p>I would say <strong>robust</strong> automation which I don’t see as the same</p>",
        "id": 429242798,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711310957
    },
    {
        "content": "<p>I think it is reasonably plausible that ring will get a non-Mathlib implementation in the medium term. And we plan to completely reimplement omega in the medium term, and expanding scope to include Rat (or maybe even more) would be plausible. That would then eat even more of the current linarith's scope.</p>",
        "id": 429242815,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1711310982
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/To.20automate.20or.20not.20to.20automate.3F/near/429242433\">said</a>:</p>\n<blockquote>\n<p>I claim that while reducing the de Bruijn factor is super important for users and so we need the tools to exist, but we need the tools to exist, but amenability to refactors is more important within mathlib and so that doesn't necessarily meant we should use those tools.</p>\n</blockquote>\n<p>I feel this is a bit of a false distinction, because in some sense \"mathlib has no users, only contributors\". I learned pretty early on that there was absolutely no point in writing code that uses mathlib unless I contributed that code to mathlib, because otherwise it would bitrot in a matter of days! Unless the mathlib development model changes very radically indeed, there's really no point in distinguishing between what is important for \"us\" (=contributors) and what is important for \"users\".</p>",
        "id": 429243234,
        "sender_full_name": "David Loeffler",
        "timestamp": 1711311249
    },
    {
        "content": "<p>Maybe a better framing would be \"towards the core\" vs \"towards the leaves\"</p>",
        "id": 429243329,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711311350
    },
    {
        "content": "<p>Certainly I am also a mathlib contributor, but I have a very different contribution profile to you, David</p>",
        "id": 429243407,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711311415
    },
    {
        "content": "<p>Yes, well, I guess I'm a pretty leafy sort of contributor. <span aria-label=\"leaves\" class=\"emoji emoji-1f343\" role=\"img\" title=\"leaves\">:leaves:</span></p>\n<p>It looks like there's a consensus here that <em>at least in the outer foliage of mathlib</em> it is preferable to use the automated tactics whenever possible, unless they're causing really serious slowdowns (maybe more than a 2x factor). Thanks everyone for the interesting remarks!</p>",
        "id": 429244178,
        "sender_full_name": "David Loeffler",
        "timestamp": 1711312102
    },
    {
        "content": "<p>I'm hoping within the next year or so we may regain theorem level parallelism, which should take some of the pain out of slower tactics, too.</p>",
        "id": 429245463,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1711312924
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/stream/287929-mathlib4/topic/To.20automate.20or.20not.20to.20automate.3F/near/429244178\">said</a>:</p>\n<blockquote>\n<p>really serious slowdowns (maybe more than a 2x factor)</p>\n</blockquote>\n<p>This is a very conservative notion of serious slowdown. It implies that Aesop, for example, can do hardly any search since its performance is dominated by <code>simp</code>, which has roughly constant cost per goal. So Aesop would usually be used as <code>aesop? says ...</code>. Other search-based automation, such as <code>duper</code>, will probably also struggle to meet this performance requirement, and there it's much harder to output a certificate that can be checked quickly. Also, what about decision procedures such as <code>omega</code>; are they fast enough by this metric?</p>\n<p>On the wider question, my impression is that Coq and Isabelle users tolerate much bigger slowdowns. I also believe that, in the long term, more automation is required to broaden the appeal of ITP beyond a few academic niches (and within those niches). So I think it might be a strategic error to choke off automation development by putting strict performance limits on it. (Obviously, these points are somewhat self-serving.)</p>\n<p>Btw, as Scott says, Lean currently makes the user experience of slow tactics much worse than it needs to be. If tactic scripts were elaborated incrementally, rather than all at once, that would help a lot. Additionally, Lean could parallelise tactic scripts in certain cases, e.g. <code>suffices T by simp; tacs</code> could execute <code>simp</code> and <code>tacs</code> in parallel. Changes like these would substantially boost interactivity. I believe the FRO is already working in this direction, so hopefully in future slow tactics will be more tolerable.</p>\n<p>In any case, discussions like these are very helpful for tool developers like me, so thank you very much!</p>",
        "id": 429386897,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1711370832
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/287929-mathlib4/topic/To.20automate.20or.20not.20to.20automate.3F/near/429386897\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/stream/287929-mathlib4/topic/To.20automate.20or.20not.20to.20automate.3F/near/429244178\">said</a>:</p>\n<blockquote>\n<p>really serious slowdowns (maybe more than a 2x factor)</p>\n</blockquote>\n<p>This is a very conservative notion of serious slowdown. [...] Other search-based automation, such as <code>duper</code>, will probably also struggle to meet this performance requirement, and there it's much harder to output a certificate that can be checked quickly. Also, what about decision procedures such as <code>omega</code>; are they fast enough by this metric?</p>\n</blockquote>\n<p>I really hope nobody thought I was suggesting that automated tactics were somehow \"useless\" if they didn't match some arbitrary speed requirement! I was just looking for a rough style guideline for when they should/shouldn't be used in contributions to the mathlib library. </p>\n<p>I'd also like to clarify that my \"&gt; 2x speedup\" rule of thumb for eliminating automatic tactics was meant to mean a 2x speedup <em>in the entire proof of the theorem</em> – not just in that single step of the proof. The example at hand was <a href=\"https://github.com/leanprover-community/mathlib4/blob/aae9d296f859fb97923157dc9ae60fbaf718af8a/Mathlib/Analysis/Convex/SpecificFunctions/Basic.lean#L107-L136\">one_add_mul_self_lt_rpow_one_add</a>, which takes about 4-5 seconds to compile, and which can be got down to 0.5s by using (short) hand-written proofs for the subgoals currently handled by <code>field_simp</code> and <code>nlinarith</code>.</p>\n<hr>\n<blockquote>\n<p>It implies that Aesop, for example, can do hardly any search since its performance is dominated by <code>simp</code>, which has roughly constant cost per goal. So Aesop would usually be used as <code>aesop? says ...</code>. </p>\n</blockquote>\n<p>This is actually not so far from the way that <code>simp</code> currently gets used in (some parts of) mathlib, where it's routine practice to squeeze all <code>simp</code>'s into <code>simp only</code>'s before anything gets merged into the library. </p>\n<p>I have the impression that you see it as a bad thing if aesop (or other search-based tactics) are getting used as <code>foo says ...</code> – why? To me this sounds like getting the best of both worlds (ease of use + compilation speed).</p>",
        "id": 429409762,
        "sender_full_name": "David Loeffler",
        "timestamp": 1711374333
    },
    {
        "content": "<p>A thought that came to my mind, but of which I'm not entirely sure if it is feasible in practice, is a meta kind of tactic, let's call it <code>tactic_q</code>(as I have a terrible lack of naming-inspiration at this point) which takes two arguments: a proof <code>a</code> and a tactic, <code>t</code>. (please bear with me...)</p>\n<p>If the proof <code>a</code> closes the goal, <code>tactic_q</code> succeeds with this proof. If not, but the tactic <code>t</code> closes the goal, <code>tactic_q</code> succeeds as well, using <code>t</code>. Now the idea would be to have automation at some step (e.g. CI, but I'm not sure if that will be too slow), such that whenever <code>a</code> fails but <code>t</code> succeeds, we replace (in the code!) <code>a</code> by a proof that we extract from <code>t</code>. </p>\n<p>Intuitively, the point of <code>tactic_q</code> is to tell Mathlib that we have a \"fallback tactic\" <code>t</code> that can solve the goal (and is robust to some changes in naming etc) but might be slow. So, Mathlib extracts from this a proof <code>a</code> that it will use, unless it fails, in which case it uses <code>t</code> and overwrites <code>a</code> with the proof obtained from <code>t</code>. I'm still working through FPIL and need to go over meta-programming afterwards, so I have no idea if this will work, but I feel that this may be a nice way to increase speed on proofs that take a lot of time, but are vulnerable to breakage.</p>",
        "id": 429414236,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1711375181
    },
    {
        "content": "<p>Is that not basically <code>says</code>?</p>",
        "id": 429414758,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711375302
    },
    {
        "content": "<p>You're right, I forgot about that one!</p>",
        "id": 429416182,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1711375666
    },
    {
        "content": "<p>(As has been remarked above, <code>says</code> is currently only available for certain specific tactics, and it would be great if it could be generalised.)</p>",
        "id": 429417698,
        "sender_full_name": "David Loeffler",
        "timestamp": 1711376036
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/stream/287929-mathlib4/topic/To.20automate.20or.20not.20to.20automate.3F/near/429409762\">said</a>:</p>\n<blockquote>\n<p>I'd also like to clarify that my \"&gt; 2x speedup\" rule of thumb for eliminating automatic tactics was meant to mean a 2x speedup <em>in the entire proof of the theorem</em> – not just in that single step of the proof.</p>\n</blockquote>\n<p>Oh okay, I didn't get that. That obviously makes a big difference. (And fwiw I agree that this particular refactor is good, given the current state of things.)</p>\n<blockquote>\n<p>I have the impression that you see it is a bad thing if aesop (or other search-based tactics) are getting used as <code>foo says ...</code> – why? To me this sounds like getting the best of both worlds (ease of use + compilation speed).</p>\n</blockquote>\n<p>I agree that this can be a good compromise, but:</p>\n<ul>\n<li>The <code>says</code> solution is less easily applicable to auto params, which account for a good amount of Aesop use in parts of Mathlib.</li>\n<li>The <code>says</code> scripts clutter the proof, though this could be hidden with better editor support.</li>\n<li>It's annoying busywork to update <code>foo? says</code> after a refactor of <code>foo?</code> or of the library, when <code>foo</code> would have solved the goal before and after, though in an ideal world this could be automated.</li>\n<li>There are other automation methods where it's less easy to generate reasonable certificates that can be used for <code>says</code>. We can always fall back to proof terms, but these are large and very brittle.</li>\n</ul>",
        "id": 429425311,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1711377809
    },
    {
        "content": "<p>I think it's a mistake to focus on the slowdown factor. David's example above is excellent:</p>\n<blockquote>\n<p>The example at hand was one_add_mul_self_lt_rpow_one_add, which takes about 4-5 seconds to compile, and which can be got down to 0.5s by using (short) hand-written proofs for the subgoals currently handled by field_simp and nlinarith.</p>\n</blockquote>\n<p>because it points at the real culprit: <code>field_simp</code> is badly broken.</p>\n<p>No one should be removing uses of <code>field_simp</code> because they are slow. We need to fix <code>field_simp</code>!</p>",
        "id": 429427778,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1711378419
    },
    {
        "content": "<p>Re: <code>says</code>, I don't think (despite being an early advocate) that it has been particularly successful. Our implementation carries an annoying maintenance burden (because you need to turn on special settings to see the failures). I'm not saying we should get rid of it, but it deserves a rethink before anyone tries rolling it out really widely.</p>",
        "id": 429428300,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1711378509
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/To.20automate.20or.20not.20to.20automate.3F/near/429427778\">said</a>:</p>\n<blockquote>\n<p>because it points at the real culprit: <code>field_simp</code> is badly broken.</p>\n</blockquote>\n<p>I'm actually very fond of <code>field_simp</code> and use it quite heavily in my projects, but only for goals exceeding a certain degree of complication. IIRC, the<code>field_simp</code>s in the example were proving things like <code>1 / (1 + x - 1) = 1 / x</code> – stuff that <code>ring</code> could also have handled – and <code>field_simp</code> really doesn't excel at ticking off the easy stuff quickly.</p>",
        "id": 429448998,
        "sender_full_name": "David Loeffler",
        "timestamp": 1711382359
    },
    {
        "content": "<p>Scott is not saying <code>field_simp</code> is not needed, he wants a better one.</p>",
        "id": 429458490,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1711384286
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/To.20automate.20or.20not.20to.20automate.3F/near/429414758\">said</a>:</p>\n<blockquote>\n<p>Is that not basically <code>says</code>?</p>\n</blockquote>\n<p>No, because says always reruns.</p>",
        "id": 429468650,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1711386562
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/287929-mathlib4/topic/To.20automate.20or.20not.20to.20automate.3F/near/429209376\">said</a>:</p>\n<blockquote>\n<p>Would linarith be amenable to generating certificates like polyrith?</p>\n</blockquote>\n<p>Yes, it would.  I think this is on a lot of people's mid-term to-do list, including <span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span>' and mine (indeed anyone who wants a mid-level tactic project could volunteer to do this).  The idea would be to generalize <code>linear_combination</code> to handle inequalities and then provide a <code>linarith?</code> which outputs an appropriate <code>linear_combination</code> (with the coefficients obtained by the backend work <code>linarith</code> is already doing).</p>",
        "id": 429481779,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1711390503
    },
    {
        "content": "<p>In many cases a user could see by eye what the right <code>linear_combination</code> is, so it wouldn't even be necessary to go through the <code>linarith?</code> process to construct it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"bp\">/</span><span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linear_combination</span> <span class=\"n\">h</span><span class=\"bp\">/</span><span class=\"mi\">2</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linear_combination</span> <span class=\"n\">h</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linear_combination</span> <span class=\"n\">h1</span> <span class=\"bp\">+</span> <span class=\"n\">h2</span>\n</code></pre></div>",
        "id": 429482142,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1711390633
    },
    {
        "content": "<p>The above examples are ones where I always feel a bit guilty writing a <code>linarith</code> call, since it seems so much like overkill -- so it would be good to have more lightweight automation to perform it.</p>",
        "id": 429482452,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1711390762
    },
    {
        "content": "<p>Here's how this <code>linear_combination</code> tactic would work under the hood:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- linear_combination h1 + h2</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">sub_neg</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">convert</span> <span class=\"n\">add_neg</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"n\">using</span> <span class=\"mi\">1</span>\n  <span class=\"n\">ring</span>\n</code></pre></div>",
        "id": 429482932,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1711390942
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/stream/287929-mathlib4/topic/To.20automate.20or.20not.20to.20automate.3F/near/429237810\">said</a>:</p>\n<blockquote>\n<p>OK OK, let's say something that can't be <code>gcongr</code>'d, like <code>2 * a + b &lt; a + 2 * b</code> given <code>a &lt; b</code>.</p>\n</blockquote>\n<p>This example would also very much be in scope:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linear_combination</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 429485575,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1711391964
    },
    {
        "content": "<p>It might be useful to have a performance wish list for tactics i.e. proofs in which we expect the tactic to solve quickly but currently doesn't. Rewriting <code>field_simp</code> without a target to aim for is perhaps a bit daunting to anyone who isn't already very familiar with all the ways it is used within mathlib.</p>",
        "id": 429486635,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1711392376
    },
    {
        "content": "<p><code>field_simp</code> currently has a quick'n'dirty implementation.  As I understand it, the issue isn't just with speed -- the implementation also doesn't cover some situations which ideally would be in scope.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hb</span><span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">b</span> <span class=\"bp\">/</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">/</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">field_simp</span>\n  <span class=\"n\">ring1</span> <span class=\"c1\">-- fails</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hb</span><span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">b</span> <span class=\"bp\">/</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">/</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">mul_div_assoc</span><span class=\"o\">,</span> <span class=\"n\">div_div</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">div_div</span><span class=\"o\">,</span> <span class=\"n\">div_self</span> <span class=\"n\">hb</span><span class=\"o\">]</span>\n  <span class=\"n\">ring1</span> <span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 429488428,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1711393053
    },
    {
        "content": "<blockquote>\n<p>As I understand it, the issue isn't just with speed</p>\n</blockquote>\n<p>I completely agree. Is it really <code>field_simp</code>'s job to deal with easy cases quickly? To me it's much more important that it deal with hard cases eventually; I'm more than happy to use other, more lightweight tactics for the easier cases. </p>\n<p>My # 1 wish with <code>field_simp</code> would be for it to give some warning about what it's missing: \"I'd be able to get further if you gave me a proof that <code>a ≠ 0</code>\", or something. Sometimes I end up just using a string of <code>sorry</code>'s to chuck a whole bunch of vaguely-relevant-looking non-vanishing statements into the context until <code>field_simp</code> does what I want, then deleting them one-by-one until I get a minimal set and filling in the <code>sorry</code>'s; automating that step away would be very welcome indeed.</p>",
        "id": 429490088,
        "sender_full_name": "David Loeffler",
        "timestamp": 1711393667
    },
    {
        "content": "<p>See also <a href=\"#narrow/stream/113488-general/topic/Help.20with.20.60nightly-testing.60/near/424206307\">here</a> ...</p>",
        "id": 429497781,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711396625
    }
]