[
    {
        "content": "<p>Now that <code>fun_prop</code> is in mathlib it would be worth considering adopting lambda notation for bundled morphisms e.g. <code>fun x =&gt;L[ℝ] x + 3•x</code>. When we get <code>fun_prop</code> compiled my hope is that the additional overhead of reproving function property would be minimal. </p>\n<p><code>fun_prop</code> can compute derivatives via <code>HasFDerivAt</code>, consider this example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"o\">((</span><span class=\"kd\">by</span> <span class=\"n\">fun_prop</span> <span class=\"o\">(</span><span class=\"n\">disch</span><span class=\"o\">:=</span><span class=\"n\">assumption</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">HasFDerivAt</span> <span class=\"n\">ℝ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>which results in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">HasFDerivAt</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span>\n  <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">•</span>  <span class=\"n\">ContinuousLinearMap.comp</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"o\">((</span><span class=\"n\">ContinuousLinearMap.mulLeftRight</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">ContinuousLinearMap.id</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">ContinuousLinearMap.id</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">+</span>  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">•</span> <span class=\"n\">ContinuousLinearMap.id</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>  <span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>using lambda notation for bundled morphisms this would become</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">HasFDerivAt</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span>\n     <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">dx</span> <span class=\"bp\">=&gt;</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"o\">(((</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">dx</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">dx</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span>  <span class=\"bp\">+</span>  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">•</span> <span class=\"n\">dx</span><span class=\"o\">)</span>\n     <span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I'm curious in people's opinion if this should be pursuit or not. The <a href=\"https://github.com/leanprover-community/mathlib4/pull/2202\">#2202</a> would be quite relevant for this, but likely a lot of work.</p>",
        "id": 421700928,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708016601
    },
    {
        "content": "<p>That lambda notation is quite nice.  Currently I solve this with a huge number of abbreviation defs, which is way messier.</p>",
        "id": 421726488,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1708025698
    },
    {
        "content": "<p>Do you end up with something like APL :) ? Point free notation is nice until it isn't.</p>",
        "id": 421728732,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708026510
    },
    {
        "content": "<p>No, it’s not really point free: <a href=\"https://github.com/girving/ray/blob/48d737369e856f925aa050a317d10ae95726804a/Ray/AnalyticManifold/Inverse.lean#L139\">https://github.com/girving/ray/blob/48d737369e856f925aa050a317d10ae95726804a/Ray/AnalyticManifold/Inverse.lean#L139</a></p>",
        "id": 421734030,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1708028501
    },
    {
        "content": "<p>Just naming all the intermediate linear maps.</p>",
        "id": 421734085,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1708028523
    },
    {
        "content": "<p>I mean, it’s not point-free if you consider “dx” a “point”.</p>",
        "id": 421734310,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1708028610
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"514145\">@Geoffrey Irving</span>, are you aware of <code>∘L</code> notation for composition?</p>",
        "id": 421767325,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708044298
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span>: is there any hope of this working for bi- or tri-linear maps, perhaps with nested binders?</p>",
        "id": 421767450,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708044374
    },
    {
        "content": "<p>I definitely had it at some point, you could write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span>  <span class=\"o\">:</span>  <span class=\"n\">K</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">K</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">K</span>\n</code></pre></div>",
        "id": 421768279,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708044927
    },
    {
        "content": "<p>I think it boils down to providing this theorem</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">fun_prop</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">clm_mk'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hf₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">IsLinearMap</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">·</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hf₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">IsLinearMap</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">·</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsContinuousLinearMap</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 421768599,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708045119
    },
    {
        "content": "<p>On notation side I just used <code>expandExplicitBinders</code></p>",
        "id": 421769405,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708045646
    },
    {
        "content": "<p>This looks promising. It only needs to use <code>↦</code> to become usable.</p>",
        "id": 421780721,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1708054083
    },
    {
        "content": "<p>No problem :)</p>",
        "id": 421780795,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708054130
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Lambda.20notation.20for.20bundled.20morphisms/near/421767325\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"514145\">Geoffrey Irving</span>, are you aware of <code>∘L</code> notation for composition?</p>\n</blockquote>\n<p>I was not!  Thank you!</p>",
        "id": 421802901,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1708067797
    }
]