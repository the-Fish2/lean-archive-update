[
    {
        "content": "<p>One thing I’ve noticed from looking at regressions with the left to right semantics is the following pattern </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">NonUnitalSeminormedRing</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Norm</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">NonUnitalRing</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n  <span class=\"n\">PseudoMetricSpace</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- The distance is induced by the norm. -/</span>\n  <span class=\"n\">dist_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"sd\">/-- The norm is submultiplicative. -/</span>\n  <span class=\"n\">norm_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">norm</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">norm</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>which itself is ok. But becomes problematic when using existing instances to construct new ones. </p>\n<p>Here many instances come from “Analysis-land” which means they involve <code>Norm</code> and <code>PseudoMetricSpace</code> fields and often involve some algebraic fields (e.g. <code>Add</code>)  </p>\n<p>When one builds the instance as </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">{</span> <span class=\"n\">mainlyAnalysisButSomeAlg</span><span class=\"o\">,</span> <span class=\"n\">purelyAlg</span> <span class=\"k\">with</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>we end up doing some deep eta expansions on <code>NonUnitalRing</code> to use the algebraic fields from the first instance. </p>\n<p>What should be done here? </p>\n<ul>\n<li>Be more disciplined?</li>\n<li>Move the algebra instances to the front? (for the <code>class</code> itself also?) </li>\n<li>Something else?</li>\n</ul>",
        "id": 419920463,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1707164057
    },
    {
        "content": "<p>Probably the depth of the nesting for a class should play a large factor in the ordering of parent classes (unless it is all data)</p>",
        "id": 419920681,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1707164153
    },
    {
        "content": "<p>Has anyone written a tool for listing the classes in mathlib by depth of extension?</p>",
        "id": 419921071,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1707164300
    },
    {
        "content": "<p><a href=\"http://speed.lean-fro.org/mathlib4/compare/917c35cd-a528-43f1-a89c-cd8bd7242c56/to/0a70caf9-1e49-4e33-a913-23e1ebbc505c\">Here</a> is some positive evidence for this ordering - from <a href=\"https://github.com/leanprover-community/mathlib4/pull/10287\">#10287</a></p>",
        "id": 419951058,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1707178111
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/ordering.20of.20parents/near/419920463\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Something else?</li>\n</ul>\n</blockquote>\n<p>One thing I've been keen on, but has met with some resistance in the past, is to separate the data fields in the algebraic hierarchy from those in the analysis hierarchy (almost) entirely, and then have mixins for the interactions between the two.</p>\n<p>I think <span class=\"user-mention\" data-user-id=\"110050\">@Sébastien Gouëzel</span>'s usual rejoinder is something like (please forgive me if I get it wrong): but <code>(Nontrivially)NormedField</code>s are soooo common that it's better if we have an explicit class for these. In that case, I agree, and we can have a <em>few</em> overlaps (primarily just <code>NormedField</code> and variations thereof). But I think having all the duplication of <code>{NonUnital}{Semi}Normed{Comm}Ring</code> is overkill (especially because at some point I'm sure we'll want <code>NonAssoc</code> variants), and it certainly makes it harder to change assumptions.</p>\n<p>This would have the benefit that you should in general be able to build these instances as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">{</span> <span class=\"n\">purelyAnalysisData</span><span class=\"o\">,</span> <span class=\"n\">purelyAlgData</span><span class=\"o\">,</span> <span class=\"n\">interactionProps</span> <span class=\"k\">with</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 419964659,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1707187186
    },
    {
        "content": "<p>A more general approach would be to separate the data fields from the prop fields. Within a hierarchy, the data fields basically never change (eg in the algebraic hierarchy we get at most <code>zero</code>, <code>one</code>, <code>add</code>,  <code>sub</code>, <code>neg</code>,  <code>mul</code>, <code>div</code>, <code>inv</code>, <code>nsmul</code>, <code>zsmul</code>,  <code>qsmul</code>, <code>natCast</code>, <code>intCast</code>, <code>ratCast</code>) while the prop fields accumulate in complicated ways.</p>",
        "id": 419998521,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707208797
    },
    {
        "content": "<p>I'm claiming it's more general because if you apply this principle to analytic algebraic objects, you get something like <code>(purelyAnalyticData, purelyAlgebraicData), (purelyAnalyticProps, purelyAlgebraicProps, interactionProps)</code> and I think the resulting classes will be small enough that inference will be fast. If they are not, we can split them up into <code>purelyAnalyticData, purelyAlgebraicData, (purelyAnalyticProps, purelyAlgebraicProps, interactionProps)</code> or even <code>purelyAnalyticData, purelyAlgebraicData, purelyAnalyticProps, purelyAlgebraicProps, interactionProps</code> (this last case is like an \"unbundled mixin\" and has the advantage of not forcing us to write tons and tons of classes about all possible interactions).</p>",
        "id": 419999117,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707209031
    },
    {
        "content": "<p>The problem with this approach of course is that <code>variable</code> declarations become longer. But since any given <code>purelyAlgebraicProps</code> class requires exactly one specific <code>purelyAlgebraicData</code> (by which I mean it's defined as <code>class purelyAlgebraicProps (α) [purelyAlgebraicData α] ...</code>), the <code>variable</code> declaration could automagically figure out the supremum of all <code>purelyAlgebraicData</code> assumptions needed by the <code>purelyAlgebraicProps</code> present within it, and add that supremum as an assumption.</p>",
        "id": 419999550,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707209210
    },
    {
        "content": "<p>Probably for simplicity we'll need to tag <code>purelyAlgebraicProps</code> classes with the <code>purelyAlgebraicData</code> class they need.</p>",
        "id": 419999647,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707209244
    },
    {
        "content": "<p>We might be able to make more use of <code>variable!</code> to hide the issues, if this ends up spiraling out of control</p>",
        "id": 420032654,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707221161
    },
    {
        "content": "<p>Or notation for a collection of variables, i.e., <code>instanceNotation Foo A := {Bar A, Baz A}</code> and that <code>variable [Foo A]</code> is internally unfolded to <code>variable [Bar A] [Baz A]</code> (but printed as <code>[Foo A]</code> in the info view). That would also make something like <code>[IsROrC k] [HilbertSpace k E]</code> possible.</p>",
        "id": 420165763,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1707269948
    },
    {
        "content": "<p><code>variable!</code> supports something like that, but it eliminates itself: <a href=\"https://github.com/leanprover-community/mathlib4/blob/49212605e40e9d9fcbcd9968ce362f91dad303ca/test/Variable.lean#L149-L160\">https://github.com/leanprover-community/mathlib4/blob/49212605e40e9d9fcbcd9968ce362f91dad303ca/test/Variable.lean#L149-L160</a></p>\n<p>Core has something called <code>class abbrev</code> that's sort of like what you're saying, and it's implemented as a class that can synthesize instances itself from instances for everything it extends.</p>",
        "id": 420166324,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707270367
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/7873\">#7873</a> seems to follow the “Deeper structure first” philosophy and does clearly improve performance</p>",
        "id": 420322721,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1707332618
    },
    {
        "content": "<p>Is there any way to do a <em>small-ish</em> test to see whether separating the data and prop fields as mentioned above would help or hinder performance? It would likely be a ton of work to do it across the whole library, but I'm not sure what a reliable proxy would be.</p>",
        "id": 420337069,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1707337791
    },
    {
        "content": "<p>We probably want a slim mathlib repo for testing things like this</p>",
        "id": 420337314,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1707337869
    }
]