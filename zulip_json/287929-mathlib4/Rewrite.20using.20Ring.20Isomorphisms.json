[
    {
        "content": "<p>Hello, how do I \"rewrite\" using <code>f</code> here?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.RingQuot</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.Ideal.IsPrimary</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.Ideal.LocalRing</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Polynomial</span> <span class=\"n\">Ideal</span> <span class=\"n\">Quotient</span> <span class=\"n\">LocalRing</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">≃+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsDomain</span> <span class=\"n\">R</span> <span class=\"bp\">↔</span> <span class=\"n\">IsDomain</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 435958412,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1714368935
    },
    {
        "content": "<p>If this is not already in the library (maybe for injective rather than equiv) you can add it, it should be rather easy.</p>",
        "id": 435958860,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1714369186
    },
    {
        "content": "<p>I realised that <code>IsDomain</code> is actually a mix-in. Should this lemma still be written like this?</p>",
        "id": 435959039,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1714369282
    },
    {
        "content": "<p>Or should I use typeclasses</p>",
        "id": 435959047,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1714369289
    },
    {
        "content": "<p>This is failing: for \"cannot find synthesization order for instance @instIsDomainToSemiringToCommSemiring with type\"</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>  <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">≃+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsDomain</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsDomain</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 435959069,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1714369305
    },
    {
        "content": "<p><code>infer_instance</code> cannot use <code>f</code>, so there is no hope it works automatically. You can prove it by hand (noting that injectivity is enough)</p>",
        "id": 435959414,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1714369482
    },
    {
        "content": "<p>Something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsPrincipalIdealRing.of_surjective#doc\">docs#IsPrincipalIdealRing.of_surjective</a></p>",
        "id": 435959630,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1714369620
    },
    {
        "content": "<p>I will do it for isomorphism first, then try to use my brain later (x) Thanks!</p>",
        "id": 435959750,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1714369685
    },
    {
        "content": "<p>I have another question <a href=\"#narrow/stream/113489-new-members/topic/Compiler.20IR.20check.20failed/near/435953320\">here</a>, if you don't mind to take a look</p>",
        "id": 435959788,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1714369708
    },
    {
        "content": "<p>I am on my phone, the other one needs a computer I am afraid</p>",
        "id": 435959830,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1714369742
    },
    {
        "content": "<p>What is the syntax for injective ringhom?</p>",
        "id": 436195975,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1714454983
    },
    {
        "content": "<p>Also I'm pretty sure it doesn't work with just a injective ring homomorphism? <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo>↪</mo><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">⟨</mo><msup><mi>X</mi><mn>2</mn></msup><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z} \\hookrightarrow \\mathbb{Z}[X]/\\langle X^2 \\rangle</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6999em;vertical-align:-0.011em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↪</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span><span class=\"mord\">/</span><span class=\"mopen\">⟨</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">⟩</span></span></span></span> for example. Sorry for the terrible example...<br>\nBut I got it for an isomorphism. I'll use that for now :D</p>",
        "id": 436198190,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1714456070
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">IsDomain.of_equiv</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">≃+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsDomain</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsDomain</span> <span class=\"n\">S</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul_left_cancel_of_ne_zero</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> Prove that ab=ac -&gt; a=0 or b=c by f^-1 (surjectivity) and R is ID -/</span>\n    <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">ha</span> <span class=\"n\">h</span>\n    <span class=\"n\">apply_fun</span> <span class=\"n\">f.symm</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">f.symm.map_mul</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h</span>\n  <span class=\"n\">mul_right_cancel_of_ne_zero</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">ha</span> <span class=\"n\">h</span>\n    <span class=\"n\">apply_fun</span> <span class=\"n\">f.symm</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">f.symm.map_mul</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h</span>\n  <span class=\"n\">exists_pair_ne</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">Nontrivial.exists_pair_ne</span> <span class=\"n\">R</span> <span class=\"n\">_</span>\n    <span class=\"n\">use</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">h'</span> <span class=\"bp\">↦</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">f.injective</span> <span class=\"n\">h'</span><span class=\"o\">)</span> <span class=\"c\">/-</span><span class=\"cm\"> Prove that S is nontrivial using injectivity: |S| &gt;= |R| -/</span>\n</code></pre></div>",
        "id": 436198433,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1714456195
    },
    {
        "content": "<p>You should be able to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.Injective.nontrivial#doc\">docs#Function.Injective.nontrivial</a> for that last field</p>",
        "id": 436198775,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714456350
    },
    {
        "content": "<p>And <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.Injective.noZeroDivisors#doc\">docs#Function.Injective.noZeroDivisors</a> for the other two</p>",
        "id": 436198821,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714456383
    },
    {
        "content": "<p>Or just use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.Injective.isDomain#doc\">docs#Function.Injective.isDomain</a> for the whole thing!</p>",
        "id": 436198900,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714456436
    },
    {
        "content": "<p>Wait hmm why does my example fail then</p>",
        "id": 436198904,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1714456438
    },
    {
        "content": "<p>Oops should’ve searched harder, thanks</p>",
        "id": 436198974,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1714456460
    },
    {
        "content": "<p>No the isDomain is flipped</p>",
        "id": 436199047,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1714456502
    },
    {
        "content": "<p>Sure, but you have an equiv so you can flip that</p>",
        "id": 436199102,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714456529
    },
    {
        "content": "<p>Ah yea with an equiv yes</p>",
        "id": 436199130,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1714456542
    },
    {
        "content": "<p>It’s very hard to find the instances I need, eg given the equiv f, what dot notations are accessible</p>",
        "id": 436199242,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1714456579
    },
    {
        "content": "<p>Wish there’s a way like dir(f) in Python to list them</p>",
        "id": 436199274,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1714456598
    },
    {
        "content": "<p>Auto complete sometimes helps</p>",
        "id": 436199311,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714456612
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> RingEquiv _ _ |- _</p>",
        "id": 436199431,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714456674
    },
    {
        "content": "<p><span aria-label=\"exclamation\" class=\"emoji emoji-2757\" role=\"img\" title=\"exclamation\">:exclamation:</span> &lt;input&gt;:1:14: expected end of input</p>",
        "id": 436199433,
        "sender_full_name": "loogle",
        "timestamp": 1714456675
    },
    {
        "content": "<p>Well, without the |- _ that would have worked</p>",
        "id": 436199525,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714456710
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">IsDomain.of_equiv</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">≃+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsDomain</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsDomain</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n  <span class=\"n\">f.symm.injective.isDomain</span> <span class=\"n\">f.symm.toRingHom</span>\n</code></pre></div>\n<p>yay!</p>",
        "id": 436262458,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1714480767
    },
    {
        "content": "<p>Probably not worth having in mathlib though, since it's just a special case of the more general injective case</p>",
        "id": 436265211,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714481684
    },
    {
        "content": "<p>Oh, I guess the <code>iff</code> version is</p>",
        "id": 436265271,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714481705
    },
    {
        "content": "<p>Yeah definitely. For iff do you mean IsDomain R iff IsDomain S (given an equiv)?</p>",
        "id": 436266049,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1714481981
    },
    {
        "content": "<p>Ah well in that case you don't need an equiv either you just need a bijective function</p>",
        "id": 436273447,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1714484160
    },
    {
        "content": "<p>probably</p>",
        "id": 436273454,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1714484162
    },
    {
        "content": "<p>All bijective ring homs are equivalences anyway, right?</p>",
        "id": 436273826,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714484271
    },
    {
        "content": "<p>Think so, oops<br>\nIt's just RingEquiv.ofBijective</p>",
        "id": 436274189,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1714484382
    },
    {
        "content": "<p>my bad</p>",
        "id": 436274194,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1714484384
    },
    {
        "content": "<p>In topology, bijective continuous maps aren't necessarily homeomorphisms, but in algebra this sort of thing is essentially always true.</p>",
        "id": 436276791,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1714485137
    }
]