[
    {
        "content": "<p><code>linarith [t1, t2, t3]</code> means <code>linarith</code> with the additional terms <code>t1, t2, t3</code>. This is quite useful.<br>\nWould it be possible for <code>positivity [t1, t2, t3]</code> to mean <code>positivity</code> with the additional terms <code>t1, t2, t3</code>?<br>\n(I suppose the same question could be asked for other tactics, like <code>continuity</code>, as well.)</p>\n<p>As an example use case, here is my solution to an exercise in chapter 6 of Mathematics in Lean, which asks to define the weighted average operation on the standard 2-simplex. I would prefer to say <code>positivity [a.x_nonneg, b.x_nonneg]</code> rather than the ugly <code>have := a.x_nonneg; have := b.x_nonneg; positivity</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">weightedAverage</span> <span class=\"o\">(</span><span class=\"n\">lambda</span> <span class=\"o\">:</span> <span class=\"n\">Real</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">lambda_nonneg</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">lambda</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">lambda_le</span> <span class=\"o\">:</span> <span class=\"n\">lambda</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">StandardTwoSimplex</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">StandardTwoSimplex</span> <span class=\"o\">:=</span>\n      <span class=\"n\">let_fun</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">lambda</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"bp\">;</span>\n      <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">lambda</span> <span class=\"bp\">*</span> <span class=\"n\">a.x</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">lambda</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">b.x</span><span class=\"o\">,</span>\n        <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">lambda</span> <span class=\"bp\">*</span> <span class=\"n\">a.y</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">lambda</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">b.y</span><span class=\"o\">,</span>\n        <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">lambda</span> <span class=\"bp\">*</span> <span class=\"n\">a.z</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">lambda</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">b.z</span><span class=\"o\">,</span>\n        <span class=\"n\">x_nonneg</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">a.x_nonneg</span><span class=\"bp\">;</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">b.x_nonneg</span><span class=\"bp\">;</span> <span class=\"n\">positivity</span><span class=\"o\">,</span>\n        <span class=\"n\">y_nonneg</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">a.y_nonneg</span><span class=\"bp\">;</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">b.y_nonneg</span><span class=\"bp\">;</span> <span class=\"n\">positivity</span><span class=\"o\">,</span>\n        <span class=\"n\">z_nonneg</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">a.z_nonneg</span><span class=\"bp\">;</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">b.z_nonneg</span><span class=\"bp\">;</span> <span class=\"n\">positivity</span><span class=\"o\">,</span>\n        <span class=\"n\">sum_eq</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linear_combination</span> <span class=\"n\">lambda</span> <span class=\"bp\">*</span> <span class=\"n\">a.sum_eq</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">lambda</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">b.sum_eq</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 425224559,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1709784985
    },
    {
        "content": "<p>I think it's good to have composable tactics, over giving tactics custom syntax in a piecemeal fashion.</p>\n<p>Introducing a number of facts into the local context in a convenient way could be a tactic. Imagine something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">by</span> <span class=\"k\">have</span> <span class=\"o\">[</span><span class=\"n\">a.x_nonneg</span><span class=\"o\">,</span> <span class=\"n\">b.x_nonneg</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">positivity</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 425225655,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709785872
    },
    {
        "content": "<p>Yes I am working on this</p>",
        "id": 425254860,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709801702
    }
]