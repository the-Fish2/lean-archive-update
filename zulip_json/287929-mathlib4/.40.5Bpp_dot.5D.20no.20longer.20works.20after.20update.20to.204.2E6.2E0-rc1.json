[
    {
        "content": "<p>In the example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.ProjectionNotation</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Parent</span> <span class=\"n\">where</span>\n  <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">pp_dot</span><span class=\"o\">]</span> <span class=\"n\">Parent.a</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Child</span> <span class=\"kd\">extends</span> <span class=\"n\">Parent</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Child</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x.a</span> <span class=\"mi\">5</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>when using mathlib commit <code>86ecbac93d1ab0e23016a1c513269df8ac034507</code>, the last commit on Lean 4.5.0, the tactic state is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">Child</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">x.a</span> <span class=\"mi\">5</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>but when using <code>490d2d4820d3ed2dea34f47f3cdfe9d72b8fbc80</code>, the first commit on Lean 4.6.0-rc1 (cf. <a href=\"https://github.com/leanprover-community/mathlib4/pull/10176\">#10176</a>), then the tactic state is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">Child</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">x.toParent.a</span> <span class=\"mi\">5</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>Is this a known issue? It causes <code>F.map</code> to be delaborated to <code>F.toPrefunctor.map</code> in the category theory library.</p>",
        "id": 421001626,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1707734975
    },
    {
        "content": "<p>I'd argue that is is perhaps a feature (though one that probably should be configurable)</p>",
        "id": 421002233,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707735144
    },
    {
        "content": "<p>If <code>def Child.a</code> also existed (with a different definition), then it's useful to be able to tell apart <code>c.a</code> and <code>c.toParent.a</code></p>",
        "id": 421002445,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707735214
    },
    {
        "content": "<p>You could argue that, but I think that the previous behavior is a much better default (at least in the parts of mathlib that I'm familiar with) and the fact that this silently changed when updating Lean feels like a bug/regression to me.</p>",
        "id": 421003718,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1707735571
    },
    {
        "content": "<p>Maybe there can be a little up arrow before the dot or something of the like to signal to the end user \"hey, there's an implicit projection here\"</p>",
        "id": 421007582,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1707736757
    },
    {
        "content": "<p>I should also mention that the regression only affects situations where <code>pp_dot</code> actually makes a difference, for example for function types. If <code>Parent.a</code> is a <code>Nat</code> instead of <code>Nat → Nat</code>, then a statement like <code>x.a = 5</code> is delaborated without the parent projection on both commits.</p>",
        "id": 421016523,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1707739911
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.40.5Bpp_dot.5D.20no.20longer.20works.20after.20update.20to.204.2E6.2E0-rc1/near/421007582\">said</a>:</p>\n<blockquote>\n<p>Maybe there can be a little up arrow before the dot or something of the like to signal to the end user \"hey, there's an implicit projection here\"</p>\n</blockquote>\n<p>To me that feels like sacrificing readability to fix a problem that no one actually has (at least as far as we know).</p>",
        "id": 421016747,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1707739991
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.40.5Bpp_dot.5D.20no.20longer.20works.20after.20update.20to.204.2E6.2E0-rc1/near/421002445\">said</a>:</p>\n<blockquote>\n<p>If <code>def Child.a</code> also existed (with a different definition), then it's useful to be able to tell apart <code>c.a</code> and <code>c.toParent.a</code></p>\n</blockquote>\n<p>This is a problem that mathlib actually has, with <code>LinearEquiv.symm</code> vs <code>LinearEquiv.toAddEquiv.symm</code></p>",
        "id": 421016940,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707740064
    },
    {
        "content": "<p>We had that discussion many times before and I still agree with Markus. The default should be the legible version, with Eric's version as a debugging option.</p>",
        "id": 421019256,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1707740904
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.40.5Bpp_dot.5D.20no.20longer.20works.20after.20update.20to.204.2E6.2E0-rc1/near/421016940\">said</a>:</p>\n<blockquote>\n<p>This is a problem that mathlib actually has, with <code>LinearEquiv.symm</code> vs <code>LinearEquiv.toAddEquiv.symm</code></p>\n</blockquote>\n<p>I think that the delaborator already handles this case correctly. If I do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">true</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">pp_dot</span><span class=\"o\">]</span> <span class=\"n\">LinearEquiv.symm</span> <span class=\"n\">AddEquiv.symm</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">e.toAddEquiv.symm</span>\n  <span class=\"k\">let</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">e.symm</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>then I get the tactic state</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">u</span><span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">e.symm</span>\n<span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">≃+</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">LinearEquiv.toAddEquiv</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>\n<p>It only gets confusing if I also declare <code>LinearEquiv.toAddEquiv</code> as <code>pp_dot</code>.</p>",
        "id": 421019376,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1707740956
    },
    {
        "content": "<p>I'd argue that it would be nice to have <code>toAddEquiv</code> as pp_dot, but without the collapsing mechanics</p>",
        "id": 421019450,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707740990
    },
    {
        "content": "<p>I guess this is a bad example because <code>toAddEquiv</code> is not a parent projection</p>",
        "id": 421019533,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707741008
    },
    {
        "content": "<p>I think we can have pp_dot and collapsing mechanics and still tell them apart: the delaborator can tell when this would produce the wrong result and clarify, just like it does for full names when opens are ambiguous</p>",
        "id": 421020221,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707741258
    }
]