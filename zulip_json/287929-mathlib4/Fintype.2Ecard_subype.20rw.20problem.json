[
    {
        "content": "<p>Recently I came across the following problem.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Perm.Cycle.Type</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">φ_end</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">Set.BijOn</span> <span class=\"n\">φ</span> <span class=\"n\">s.toSet</span> <span class=\"n\">s.toSet</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Function.End</span> <span class=\"n\">s.toSet</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span>\n      <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">φ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hs.mapsTo</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">help₃</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">Set.BijOn</span> <span class=\"n\">φ</span> <span class=\"n\">s.toSet</span> <span class=\"n\">s.toSet</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">φ_end</span> <span class=\"n\">hs</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">help_fix</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">Set.BijOn</span> <span class=\"n\">φ</span> <span class=\"n\">s.toSet</span> <span class=\"n\">s.toSet</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Function.fixedPoints</span> <span class=\"o\">(</span><span class=\"n\">φ_end</span> <span class=\"n\">hs</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">card_s</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">Set.BijOn</span> <span class=\"n\">φ</span> <span class=\"n\">s.toSet</span> <span class=\"n\">s.toSet</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">Equiv.Perm.card_fixedPoints_modEq</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">help₃</span> <span class=\"n\">hs</span>\n  <span class=\"c1\">-- simplify right hand side of congruence to zero:</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">coe_sort_coe</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card_subtype</span><span class=\"o\">,</span> <span class=\"n\">help_fix</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card_of_isEmpty</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"c1\">-- now try to change left hand side to `s.card`</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Fintype.card_subtype</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"c1\">-- tactic 'rewrite' failed, did not find instance of the pattern in the target expression</span>\n  <span class=\"c1\">--   Fintype.card { x // ?p x }</span>\n  <span class=\"c1\">-- F: Type u_1</span>\n  <span class=\"c1\">-- inst✝: DecidableEq F</span>\n  <span class=\"c1\">-- s: Finset F</span>\n  <span class=\"c1\">-- hs: Set.BijOn φ ↑s ↑s</span>\n  <span class=\"c1\">-- this: Fintype.card { x // x ∈ s } ≡ 0 [MOD 3]</span>\n  <span class=\"c1\">--</span>\n  <span class=\"c1\">-- In `this`: @Fintype.card { x // x ∈ s } (FinsetCoe.fintype s) : ℕ</span>\n  <span class=\"c1\">-- Expected: @Fintype.card { x // ?p x } (Subtype.fintype fun x =&gt; ?p x) : ℕ</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Note that rewriting with <code>Fintype.card_subtype</code> works on the right hand side of the congruence.<br>\nI found a way around this, but I wanted to ask whether there is a recommended way of dealing with / avoiding this problem. I must admit I have no idea where the two different <code>Fintype</code> instances are coming from. I do realize that <code>Fintype</code> carries data (a <code>Finset</code> that contains all elements), which is probably the reason why the two do not get unified. On the other hand, <code>#synth Subsingleton (Fintype F)</code> does work, so I wonder why this is not resolved by subsingleton elemination?</p>",
        "id": 416056046,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705505643
    },
    {
        "content": "<p><code>card_subtype</code> can't work here because <code>F</code> is not finite</p>",
        "id": 416058954,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705506419
    },
    {
        "content": "<p>Adding <code>[Fintype F]</code> does not change the problem (I guess I minimized too much). (Now added above.)</p>",
        "id": 416059059,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705506449
    },
    {
        "content": "<p>You're looking for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.card_coe#doc\">docs#Fintype.card_coe</a> (which doesn't mention <code>univ</code>). <code>Fintype.card_subtype</code> is for when working with a subtype of a finite type, which is not what you're doing.</p>",
        "id": 416059164,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705506479
    },
    {
        "content": "<p><code>convert</code> will use subsingleton facts but not <code>rw</code>. We have <code>Finite</code> if you don't want to get bogged down with constructive stuff</p>",
        "id": 416059480,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705506559
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.Perm.card_fixedPoints_modEq#doc\">docs#Equiv.Perm.card_fixedPoints_modEq</a> needs <code>Fintype</code>s, however...</p>",
        "id": 416059569,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705506591
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Fintype.2Ecard_subype.20rw.20problem/near/416059164\">said</a>:</p>\n<blockquote>\n<p>You're looking for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.card_coe#doc\">docs#Fintype.card_coe</a> (which doesn't mention <code>univ</code>). <code>Fintype.card_subtype</code> is for when working with a subtype of a finite type, which is not what you're doing.</p>\n</blockquote>\n<p>Still, it is rather confusing that there are two different lemmas for \"the same\" thing. Could this be avoided?</p>",
        "id": 416059818,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705506651
    },
    {
        "content": "<p>Yeah but you'll be able to prove a noncomputable <code>Finite</code> version of this by using the <code>Fintype</code> version and then PR it and make everyone's lives better.</p>",
        "id": 416059835,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705506653
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Fintype.2Ecard_subype.20rw.20problem/near/416059818\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Fintype.2Ecard_subype.20rw.20problem/near/416059164\">said</a>:</p>\n<blockquote>\n<p>You're looking for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.card_coe#doc\">docs#Fintype.card_coe</a> (which doesn't mention <code>univ</code>). <code>Fintype.card_subtype</code> is for when working with a subtype of a finite type, which is not what you're doing.</p>\n</blockquote>\n<p>Still, it is rather confusing that there are two different lemmas for \"the same\" thing. Could this be avoided?</p>\n</blockquote>\n<p>They're not really the same thing though; the RHS is different</p>",
        "id": 416059891,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705506668
    },
    {
        "content": "<p>It's like how there are two lemmas with <code>(x * y)\\inv</code> on the RHS, depending on whether you want to assume that the multiplication is commutative</p>",
        "id": 416059986,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705506693
    },
    {
        "content": "<p>The RHS of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.card_subtype#doc\">docs#Fintype.card_subtype</a> simplifies when <code>p = (· ∈ s)</code>to the RHS of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.card_coe#doc\">docs#Fintype.card_coe</a>, though.<br>\nAnyway, in my use case, it looked like <code>{x // f x = r}</code>, and so <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.card_coe#doc\">docs#Fintype.card_coe</a> does not apply.<br>\nMaybe I should un-M my MWE a bit...</p>",
        "id": 416060837,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705506915
    },
    {
        "content": "<p>The RHS of <code>card_subtype</code> is a type error without <code>Fintype F</code> though, because there is no <code>univ</code>. The same is not true of <code>card_coe</code></p>",
        "id": 416061046,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705506967
    },
    {
        "content": "<p>Ah, I now realize that <code>simp</code> first simplified <code>Fintype.card { x // x ∈ univ.filter (f · = r)}</code> to <code>Fintype.card { x //  f x = r}</code> and then got stuck. This seems to be another non-confluence problem with <code>simp</code>...<br>\nBut anyway, it <em>should</em> be possible to get <code>simp</code> or <code>rw</code> to change <code>Fintype.card { x //  f x = r}</code> to <code>(univ.filter (f · = r)).card</code> (assuming we have <code>[Fintype F]</code> around).</p>",
        "id": 416061806,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705507187
    },
    {
        "content": "<p>Can you make a mwe for <em>that</em> statement?</p>",
        "id": 416062654,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705507416
    },
    {
        "content": "<p>My impression is that the problem is caused by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.card_subtype#doc\">docs#Fintype.card_subtype</a> using a specific <code>Fintype</code> instance, which is different from the one showing up on the LHS of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.Perm.card_fixedPoints_modEq#doc\">docs#Equiv.Perm.card_fixedPoints_modEq</a> . I guess I should look into how the latter comes about...</p>",
        "id": 416062828,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705507462
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Perm.Cycle.Type</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">φ_end</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">Set.BijOn</span> <span class=\"n\">φ</span> <span class=\"n\">s.toSet</span> <span class=\"n\">s.toSet</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Function.End</span> <span class=\"n\">s.toSet</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span>\n      <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">φ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hs.mapsTo</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">help₃</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">Set.BijOn</span> <span class=\"n\">φ</span> <span class=\"n\">s.toSet</span> <span class=\"n\">s.toSet</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">φ_end</span> <span class=\"n\">hs</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">card_fix</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">Set.BijOn</span> <span class=\"n\">φ</span> <span class=\"n\">s.toSet</span> <span class=\"n\">s.toSet</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">s.card</span> <span class=\"bp\">≡</span>  <span class=\"mi\">0</span> <span class=\"o\">[</span><span class=\"n\">MOD</span> <span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">H₁</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">Equiv.Perm.card_fixedPoints_modEq</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Subtype.fintype</span> <span class=\"bp\">..</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"mi\">3</span> <span class=\"mi\">1</span> <span class=\"n\">_</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">help₃</span> <span class=\"n\">hs</span>\n  <span class=\"k\">have</span> <span class=\"n\">H₂</span> <span class=\"o\">:=</span> <span class=\"n\">Equiv.Perm.card_fixedPoints_modEq</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">help₃</span> <span class=\"n\">hs</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Fintype.card_subtype</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H₁</span>\n  <span class=\"c1\">-- (filter (fun x =&gt; x ∈ ↑s) univ).card ≡ Fintype.card ↑(Function.fixedPoints (φ_end hs)) [MOD 3]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Fintype.card_subtype</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H₂</span>\n  <span class=\"c1\">-- Fintype.card ↑↑s ≡ (filter (fun x =&gt; x ∈ Function.fixedPoints (φ_end hs)) univ).card [MOD 3]</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>It is a bit strange that <code>Fintype.card_subtype</code> works <em>either</em> on the left <em>or</em> on the right, depending on which <code>Fintype</code> instance <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.Perm.card_fixedPoints_modEq#doc\">docs#Equiv.Perm.card_fixedPoints_modEq</a> uses, but <em>not on both</em>.</p>",
        "id": 416067288,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705508271
    },
    {
        "content": "<p>A variant:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Perm.Cycle.Type</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">φ_end</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">Set.BijOn</span> <span class=\"n\">φ</span> <span class=\"n\">s.toSet</span> <span class=\"n\">s.toSet</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Function.End</span> <span class=\"n\">s.toSet</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span>\n      <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">φ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hs.mapsTo</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">help₃</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">Set.BijOn</span> <span class=\"n\">φ</span> <span class=\"n\">s.toSet</span> <span class=\"n\">s.toSet</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">φ_end</span> <span class=\"n\">hs</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">card_fix</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">Set.BijOn</span> <span class=\"n\">φ</span> <span class=\"n\">s.toSet</span> <span class=\"n\">s.toSet</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">s.card</span> <span class=\"bp\">≡</span>  <span class=\"mi\">0</span> <span class=\"o\">[</span><span class=\"n\">MOD</span> <span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">H₁</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">Equiv.Perm.card_fixedPoints_modEq</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Subtype.fintype</span> <span class=\"bp\">..</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"mi\">3</span> <span class=\"mi\">1</span> <span class=\"n\">_</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">help₃</span> <span class=\"n\">hs</span>\n  <span class=\"k\">have</span> <span class=\"n\">H₂</span> <span class=\"o\">:=</span> <span class=\"n\">Equiv.Perm.card_fixedPoints_modEq</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">help₃</span> <span class=\"n\">hs</span>\n  <span class=\"n\">simp</span><span class=\"bp\">?</span> <span class=\"o\">[</span><span class=\"n\">Fintype.card_subtype</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H₁</span>\n       <span class=\"n\">says</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Finset.mem_coe</span><span class=\"o\">,</span> <span class=\"n\">Finset.coe_sort_coe</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card_subtype</span><span class=\"o\">,</span>\n      <span class=\"n\">Finset.filter_congr_decidable</span><span class=\"o\">,</span> <span class=\"n\">Finset.filter_univ_mem</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card_ofFinset</span><span class=\"o\">,</span>\n      <span class=\"n\">Function.mem_fixedPoints</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H₁</span>\n  <span class=\"c1\">-- s.card ≡ (Finset.filter (fun x =&gt; Function.IsFixedPt (φ_end hs) x) Finset.univ).card [MOD 3]</span>\n  <span class=\"n\">simp</span><span class=\"bp\">?</span> <span class=\"o\">[</span><span class=\"n\">Fintype.card_subtype</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H₂</span>\n       <span class=\"n\">says</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Finset.coe_sort_coe</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card_coe</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card_subtype</span><span class=\"o\">,</span>\n      <span class=\"n\">Function.mem_fixedPoints</span><span class=\"o\">,</span> <span class=\"n\">Finset.univ_eq_attach</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H₂</span>\n  <span class=\"c1\">-- s.card ≡ (Finset.filter (fun x =&gt; Function.IsFixedPt (φ_end hs) x) (Finset.attach s)).card [MOD 3]</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>We end up at slightly different statements.</p>",
        "id": 416071578,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705509117
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Fintype.2Ecard_subype.20rw.20problem/near/416062828\">said</a>:</p>\n<blockquote>\n<p>My impression is that the problem is caused by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.card_subtype#doc\">docs#Fintype.card_subtype</a> using a specific <code>Fintype</code> instance</p>\n</blockquote>\n<p>This is indeed a problem. That means <code>Fintype.card_subtype</code> is misstated. It should take a <code>[Fintype {x // p x}]</code> argument.</p>",
        "id": 416079070,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705511000
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Fintype.2Ecard_subype.20rw.20problem/near/416059569\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.Perm.card_fixedPoints_modEq#doc\">docs#Equiv.Perm.card_fixedPoints_modEq</a> needs <code>Fintype</code>s, however...</p>\n</blockquote>\n<p>So because I think <code>Fintype</code> is evil (precisely because of all the pain you're going through above) I just thought I'd mention explicitly how to avoid all this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Equiv.Perm.cycleType'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Equiv.Perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Multiset</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">classical</span>\n    <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.ofFinite</span> <span class=\"n\">α</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Equiv.Perm.cycleType</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Equiv.Perm.cycleFactorsFinset'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Equiv.Perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Equiv.Perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">classical</span>\n    <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.ofFinite</span> <span class=\"n\">α</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Equiv.Perm.cycleFactorsFinset</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Equiv.Perm.cycleType_mul_inv_mem_cycleFactorsFinset_eq_sub'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Equiv.Perm</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">∈</span> <span class=\"n\">Equiv.Perm.cycleFactorsFinset'</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Equiv.Perm.cycleType'</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">f</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Equiv.Perm.cycleType'</span> <span class=\"n\">g</span> <span class=\"bp\">-</span> <span class=\"n\">Equiv.Perm.cycleType'</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">classical</span>\n    <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.ofFinite</span> <span class=\"n\">α</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Equiv.Perm.cycleType_mul_inv_mem_cycleFactorsFinset_eq_sub</span> <span class=\"n\">hf</span>\n</code></pre></div>\n<p>You use the primed version of everything and all your problems disappear.</p>",
        "id": 416337939,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705526515
    },
    {
        "content": "<p>In fact I guess all this could be done by some <code>[to_Finite]</code> attribute.</p>",
        "id": 416338163,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705526616
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Fintype.2Ecard_subype.20rw.20problem/near/416079070\">said</a>:</p>\n<blockquote>\n<p>This is indeed a problem. That means <code>Fintype.card_subtype</code> is misstated. It should take a <code>[Fintype {x // p x}]</code> argument.</p>\n</blockquote>\n<p>In particular, there is an instance diamond here between \"sets that are finite because their elements belong to a finite type\" and \"set that are finite because their elements satisfy a finite predicate\". I don't think \"use the most general <code>Fintype</code> argument possible\" is a good idea in general, because it makes the library weird; but in cases where a diamond like this is present, it's the right choice.</p>",
        "id": 416339425,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705527151
    },
    {
        "content": "<p>The statement I <em>really</em> want is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">card_fixedPoints_modEq</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Set.MapsTo</span> <span class=\"n\">f</span> <span class=\"n\">s.toSet</span> <span class=\"n\">s.toSet</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Nat.Prime</span> <span class=\"n\">p</span><span class=\"o\">)]</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Set.EqOn</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">id</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">s.card</span> <span class=\"bp\">≡</span> <span class=\"o\">(</span><span class=\"n\">s.filter</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">[</span><span class=\"n\">MOD</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>or something along these lines.</p>\n<p>While trying to put together a proof of that, I found that there is not much API to speak of for <code>Function.End</code>. Why is that?</p>\n<p>Anyway, my attempt currently looks like this.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Perm.Cycle.Type</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Function.End.ext</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Function.End</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">funext</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Function.End.of_mapsTo</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Set.MapsTo</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Function.End</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Function.End.of_mapsTo_id</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">of_mapsTo</span> <span class=\"o\">(</span><span class=\"n\">Set.mapsTo_id</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Function.End.of_mapsTo_apply</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Set.MapsTo</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">of_mapsTo</span> <span class=\"n\">h</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span>  <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Function.End.of_mapsTo_apply_val</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Set.MapsTo</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">of_mapsTo</span> <span class=\"n\">h</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Function.End.of_mapsTo_apply'</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Set.MapsTo</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">of_mapsTo</span> <span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">f</span> <span class=\"n\">a.val</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">a.prop</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Function.End.of_mapsTo_apply'_val</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Set.MapsTo</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">of_mapsTo</span> <span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a.val</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Function.End.eq_of_eqOn</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Set.EqOn</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Set.MapsTo</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">Set.MapsTo</span> <span class=\"n\">g</span> <span class=\"n\">s</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">of_mapsTo</span> <span class=\"n\">hf</span> <span class=\"bp\">=</span> <span class=\"n\">of_mapsTo</span> <span class=\"n\">hg</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">a</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">of_mapsTo_apply'</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">a.prop</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Function.End.iterate</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Function.End</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction'</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Nat.zero_eq</span><span class=\"o\">,</span> <span class=\"n\">pow_zero</span><span class=\"o\">,</span> <span class=\"n\">one_def</span><span class=\"o\">,</span> <span class=\"n\">iterate_zero</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">pow_succ</span><span class=\"o\">,</span> <span class=\"n\">Function.iterate_succ'</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">mul_def</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Function.End.of_mapsTo_comp</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Set.MapsTo</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">Set.MapsTo</span> <span class=\"n\">g</span> <span class=\"n\">s</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">of_mapsTo</span> <span class=\"n\">hf</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">of_mapsTo</span> <span class=\"n\">hg</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">of_mapsTo</span> <span class=\"o\">(</span><span class=\"n\">Set.MapsTo.comp</span> <span class=\"n\">hf</span> <span class=\"n\">hg</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Function.End.of_mapsTo_pow</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Set.MapsTo</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">of_mapsTo</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">of_mapsTo</span> <span class=\"o\">(</span><span class=\"n\">Set.MapsTo.iterate</span> <span class=\"n\">h</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">iterate</span><span class=\"o\">]</span>\n  <span class=\"n\">induction'</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">hn</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Nat.zero_eq</span><span class=\"o\">,</span> <span class=\"n\">iterate_zero</span><span class=\"o\">]</span>\n    <span class=\"n\">ext</span> <span class=\"n\">a</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">id_eq</span><span class=\"o\">,</span> <span class=\"n\">of_mapsTo_apply'</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">ext</span> <span class=\"n\">a</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">iterate_succ</span><span class=\"o\">,</span> <span class=\"n\">hn</span><span class=\"o\">,</span> <span class=\"n\">comp_apply</span><span class=\"o\">,</span> <span class=\"n\">of_mapsTo_apply'</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Function.End</span> <span class=\"k\">in</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">card_fixedPoints_modEq</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Set.MapsTo</span> <span class=\"n\">f</span> <span class=\"n\">s.toSet</span> <span class=\"n\">s.toSet</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Nat.Prime</span> <span class=\"n\">p</span><span class=\"o\">)]</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Set.EqOn</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">id</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">s.card</span> <span class=\"bp\">≡</span> <span class=\"o\">(</span><span class=\"n\">s.filter</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">[</span><span class=\"n\">MOD</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"n\">of_mapsTo</span> <span class=\"n\">hf</span>\n  <span class=\"k\">have</span> <span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">of_mapsTo_pow</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">of_mapsTo_id</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">eq_of_eqOn</span> <span class=\"n\">h</span> <span class=\"bp\">..</span>\n  <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"n\">Equiv.Perm.card_fixedPoints_modEq</span> <span class=\"n\">hF</span>\n  <span class=\"n\">simp</span><span class=\"bp\">?</span> <span class=\"o\">[</span><span class=\"n\">Fintype.card_subtype</span><span class=\"o\">,</span> <span class=\"n\">Function.IsFixedPt</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H</span>\n       <span class=\"n\">says</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Finset.coe_sort_coe</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card_coe</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card_subtype</span><span class=\"o\">,</span>\n      <span class=\"n\">Function.mem_fixedPoints</span><span class=\"o\">,</span> <span class=\"n\">Function.IsFixedPt</span><span class=\"o\">,</span> <span class=\"n\">Finset.univ_eq_attach</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H</span>\n  <span class=\"n\">convert</span> <span class=\"n\">H</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq_comm</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"n\">Finset.card_congr</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">})</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">x.val</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">ha</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">SetCoe.ext</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"n\">hb</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Finset.mem_filter</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_attach</span><span class=\"o\">,</span> <span class=\"n\">Finset.coe_mem</span><span class=\"o\">,</span> <span class=\"n\">Subtype.ext_iff</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">]</span>\n      <span class=\"n\">using</span> <span class=\"n\">ha</span>\n  <span class=\"bp\">·</span> <span class=\"n\">refine</span> <span class=\"o\">⟨⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_of_mem_filter</span> <span class=\"n\">b</span> <span class=\"n\">hb</span><span class=\"o\">⟩,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Finset.mem_filter</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hb</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">of_mapsTo_apply'</span><span class=\"o\">,</span> <span class=\"n\">Finset.filter_congr_decidable</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_filter</span><span class=\"o\">,</span>\n      <span class=\"n\">Finset.mem_attach</span><span class=\"o\">,</span> <span class=\"n\">Subtype.mk.injEq</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hb.2</span>\n</code></pre></div>\n<p>I think it would make sense to have something like <code>card_fixedPoints_modEq</code> in Mathlib, to save the user from having to go through the <code>Function.End</code> clunkiness.</p>",
        "id": 416451527,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705528330
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Fintype.2Ecard_subype.20rw.20problem/near/416451527\">said</a>:</p>\n<blockquote>\n<p>While trying to put together a proof of that, I found that there is not much API to speak of for <code>Function.End</code>. Why is that?</p>\n</blockquote>\n<p>I proposed we add <code>Function.End</code> <a href=\"https://github.com/leanprover-community/mathlib/pull/8253#discussion_r668184484\">in !3#8253</a>, where we really only needed a small bit of API around <code>MulAction</code>; I agree that it could probably do with some more thought around the API</p>",
        "id": 416452398,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705528716
    },
    {
        "content": "<p>I guess I'm really asking why <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.Perm.card_fixedPoints_modEq#doc\">docs#Equiv.Perm.card_fixedPoints_modEq</a> is formulated in terms of <code>Function.End</code> (it's not even in the right namespace for that!).</p>",
        "id": 416452558,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705528797
    },
    {
        "content": "<p>I think that's a question for <code>git blame</code> :)</p>",
        "id": 416453980,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705529399
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Fintype.2Ecard_subype.20rw.20problem/near/416453980\">said</a>:</p>\n<blockquote>\n<p>I think that's a question for <code>git blame</code> :)</p>\n</blockquote>\n<p><code>git blame</code> can tell me who wrote it, but not why...</p>",
        "id": 416840126,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705688286
    },
    {
        "content": "<p>I have now produced a variant of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.Perm.card_fixedPoints_modEq#doc\">docs#Equiv.Perm.card_fixedPoints_modEq</a> that talks about functions leaving a <code>Finset</code> invariant. It looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Perm.Cycle.Type</span>\n\n<span class=\"c1\">-- A version of `Equiv.Perm.card_fixedPoints_modEq` for sub-`Finset`s and a function `f : α → α`.</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Finset</span>\n\n<span class=\"sd\">/-- If a function `f` maps a `Finset` into itself, all its iterates do so as well. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">iterate_mem</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction'</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Function.iterate_succ'</span><span class=\"o\">,</span> <span class=\"n\">Function.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Function</span> <span class=\"n\">Equiv</span> <span class=\"k\">in</span>\n<span class=\"sd\">/-- We can turn a function `f` that maps a `Finset` `s` into itself and has order dividing `n`</span>\n<span class=\"sd\">when restricted to `s` into an equivalence of `s` considered as a type. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">equivOfFiniteOrderOn</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Equiv</span> <span class=\"n\">s</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">hf</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">⟩,</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">iterate_mem</span> <span class=\"n\">hf</span> <span class=\"n\">_</span> <span class=\"n\">ha</span><span class=\"o\">⟩,</span>\n     <span class=\"n\">leftInverse_iff_comp.mpr</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">leftInverse_iff_comp.mpr</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">&lt;;&gt;</span>\n  <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">a</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">comp_apply</span><span class=\"o\">,</span> <span class=\"n\">id_eq</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">iterate_succ_apply</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">iterate_succ_apply'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"o\">),</span>\n      <span class=\"bp\">←</span> <span class=\"n\">Nat.succ_sub</span> <span class=\"n\">hn</span><span class=\"o\">,</span> <span class=\"n\">Nat.succ_sub_one</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h</span> <span class=\"n\">a.val</span> <span class=\"n\">a.prop</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">equivOf_apply</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">})</span> <span class=\"o\">:</span>\n    <span class=\"n\">equivOfFiniteOrderOn</span> <span class=\"n\">hf</span> <span class=\"n\">hn</span> <span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">f</span> <span class=\"n\">a.val</span><span class=\"o\">,</span> <span class=\"n\">hf</span> <span class=\"n\">a.val</span> <span class=\"n\">a.prop</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Function</span> <span class=\"n\">Equiv</span> <span class=\"k\">in</span>\n<span class=\"sd\">/-- The `m`th power of an equivalence on `s` obtained by restricting a function `f`</span>\n<span class=\"sd\">can be obtained by restricting the `m`th iterate of `f`. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">equivOf_pow_eq_iterate</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">})</span> <span class=\"o\">:</span>\n    <span class=\"o\">((</span><span class=\"n\">equivOfFiniteOrderOn</span> <span class=\"n\">hf</span> <span class=\"n\">hn</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">iterate_mem</span> <span class=\"n\">hf</span> <span class=\"n\">m</span> <span class=\"n\">a.prop</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction'</span> <span class=\"n\">m</span> <span class=\"k\">with</span> <span class=\"n\">m</span> <span class=\"n\">ih</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Nat.zero_eq</span><span class=\"o\">,</span> <span class=\"n\">pow_zero</span><span class=\"o\">,</span> <span class=\"n\">Perm.coe_one</span><span class=\"o\">,</span> <span class=\"n\">id_eq</span><span class=\"o\">,</span> <span class=\"n\">iterate_zero</span><span class=\"o\">,</span> <span class=\"n\">Subtype.coe_eta</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">pow_succ</span><span class=\"o\">,</span> <span class=\"n\">Perm.coe_mul</span><span class=\"o\">,</span> <span class=\"n\">comp_apply</span><span class=\"o\">,</span> <span class=\"n\">equivOf_apply</span><span class=\"o\">,</span> <span class=\"n\">Subtype.mk.injEq</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n      <span class=\"n\">iterate_succ_apply'</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Function</span> <span class=\"n\">Equiv</span> <span class=\"k\">in</span>\n<span class=\"sd\">/-- If `f` has order dividing `n` and maps a `Finset` `s` into itself, then the equivalence</span>\n<span class=\"sd\">on `s` obtained by restricting `f` also has order dividing `n`. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">equivOf_order</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">equivOfFiniteOrderOn</span> <span class=\"n\">hf</span> <span class=\"n\">hn</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">a</span>\n  <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">equivOf_pow_eq_iterate</span><span class=\"o\">,</span> <span class=\"n\">coe_one</span><span class=\"o\">,</span> <span class=\"n\">id_eq</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h</span> <span class=\"n\">a.val</span> <span class=\"n\">a.prop</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Function</span> <span class=\"n\">Equiv</span> <span class=\"n\">Perm</span> <span class=\"k\">in</span>\n<span class=\"sd\">/-- If `f : α → α` maps a `Finset` `s` to itself and its `p^n`th iterate is the identity on `s`,</span>\n<span class=\"sd\">where `p` is a prime number, then the cardinality of `s` is congruent mod `p` to the number of</span>\n<span class=\"sd\">fixed points of `f` on `s` . -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">card_fixedPoints_modEq</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"n\">p.Prime</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">s.card</span> <span class=\"bp\">≡</span> <span class=\"o\">(</span><span class=\"n\">s.filter</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">[</span><span class=\"n\">MOD</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">hpn</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">n.one_le_pow</span> <span class=\"n\">p</span> <span class=\"n\">hp.out.one_lt.le</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s.filter</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">support</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">equivOfFiniteOrderOn</span> <span class=\"n\">hf</span> <span class=\"n\">hpn</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">ᶜ.</span><span class=\"n\">card</span>\n  <span class=\"bp\">·</span> <span class=\"n\">convert</span> <span class=\"n\">Fintype.card_coe</span> <span class=\"n\">s</span> <span class=\"bp\">▸</span> <span class=\"o\">(</span><span class=\"n\">card_compl_support_modEq</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">equivOf_order</span> <span class=\"n\">hf</span> <span class=\"n\">hpn</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">card_congr</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">})</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">x.val</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">ha</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">SetCoe.ext</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">hb</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_compl</span><span class=\"o\">,</span> <span class=\"n\">Perm.mem_support</span><span class=\"o\">,</span> <span class=\"n\">coe_fn_mk</span><span class=\"o\">,</span> <span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"n\">not_not</span><span class=\"o\">,</span> <span class=\"n\">mem_filter</span><span class=\"o\">,</span> <span class=\"n\">coe_mem</span><span class=\"o\">,</span>\n      <span class=\"n\">true_and</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">ha</span> <span class=\"bp\">⊢</span>\n    <span class=\"n\">exact</span> <span class=\"n\">congr_arg</span> <span class=\"n\">Subtype.val</span> <span class=\"n\">ha</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_filter</span><span class=\"o\">,</span> <span class=\"n\">mem_compl</span><span class=\"o\">,</span> <span class=\"n\">Perm.mem_support</span><span class=\"o\">,</span> <span class=\"n\">equivOf_apply</span><span class=\"o\">,</span> <span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"n\">not_not</span><span class=\"o\">,</span>\n      <span class=\"n\">exists_prop</span><span class=\"o\">,</span> <span class=\"n\">Subtype.exists</span><span class=\"o\">,</span> <span class=\"n\">Subtype.mk.injEq</span><span class=\"o\">,</span> <span class=\"n\">exists_and_left</span><span class=\"o\">,</span> <span class=\"n\">exists_eq_right_right</span><span class=\"o\">]</span>\n      <span class=\"n\">using</span> <span class=\"n\">hb</span>\n\n<span class=\"sd\">/-- If `f : α → α` maps a `Finset` `s` to itself and its `p`th iterate is the identity on `s`,</span>\n<span class=\"sd\">where `p` is a prime number, then the cardinality of `s` is congruent mod `p` to the number of</span>\n<span class=\"sd\">fixed points of `f` on `s` . -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">card_fixedPoints_modEq_prime</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"n\">p.Prime</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">s.card</span> <span class=\"bp\">≡</span> <span class=\"o\">(</span><span class=\"n\">s.filter</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">[</span><span class=\"n\">MOD</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"n\">card_fixedPoints_modEq</span> <span class=\"n\">hf</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">pow_one</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">▸</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Finset</span>\n</code></pre></div>\n<p>Would this be welcome as a PR?</p>",
        "id": 416840751,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705688482
    },
    {
        "content": "<p><span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span> <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span></p>",
        "id": 416975782,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705743409
    },
    {
        "content": "<p>Your <code>equivOfFiniteOrderOn</code> is very close to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.Perm.subtypePerm#doc\">docs#Equiv.Perm.subtypePerm</a></p>",
        "id": 416976858,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705744405
    },
    {
        "content": "<p>Also this has nothing to do with this topic anymore, right?</p>",
        "id": 416976871,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705744421
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Fintype.2Ecard_subype.20rw.20problem/near/416976858\">said</a>:</p>\n<blockquote>\n<p>Your <code>equivOfFiniteOrderOn</code> is very close to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.Perm.subtypePerm#doc\">docs#Equiv.Perm.subtypePerm</a></p>\n</blockquote>\n<p>Not really: I do not want to assume that <code>f</code> is a permutation on <code>α</code>, only that it induces one on a (finite) subset.</p>",
        "id": 416980258,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705747444
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Fintype.2Ecard_subype.20rw.20problem/near/416976871\">said</a>:</p>\n<blockquote>\n<p>Also this has nothing to do with this topic anymore, right?</p>\n</blockquote>\n<p>It simplifies the application that originally led to the problem I encountered, which prompted this thread. But strictly speaking, you are right.</p>",
        "id": 416980358,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705747536
    },
    {
        "content": "<p>... which is why I said \"very close to\", not \"special case of\"</p>",
        "id": 416984920,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705751423
    },
    {
        "content": "<p>One could dispute the \"very\" <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> <br>\nBut what did you want to imply with this statement? I'm trying to decide whether it makes sense to submit a PR, and I can't tell whether to take this as en- or discouragement.</p>",
        "id": 416987216,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705753413
    },
    {
        "content": "<p>I don't know. It was a remark that I hoped would spark you to find a common abstraction, but I'm not sure there is one. At least, it should prompt you to harmonize the names.</p>",
        "id": 416987710,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705753868
    },
    {
        "content": "<p>Regarding the initial question, I think that for the same reason I switched from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.card#doc\">docs#Fintype.card</a> to #Nat.card in a proof, to be able to apply ‘congr‘ or something like that. — in <a href=\"https://github.com/leanprover-community/mathlib4/tree/ACL%2FConjClassCount\">branch#ACL/ConjClassCount</a></p>",
        "id": 417062756,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1705820597
    }
]