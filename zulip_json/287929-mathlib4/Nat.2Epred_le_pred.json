[
    {
        "content": "<p>I am encountering the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Nat.sub_one_le_sub_one</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">m</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.pred_le_pred</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">works</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p.Prime</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n   <span class=\"k\">calc</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n        <span class=\"n\">_</span>  <span class=\"bp\">≤</span> <span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.sub_one_le_sub_one</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Nat.pow_le_pow_of_le_right</span> <span class=\"n\">Nat.zero_lt_two</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Nat.Prime.two_le</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">does_not_work</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p.Prime</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n   <span class=\"k\">calc</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n        <span class=\"n\">_</span>  <span class=\"bp\">≤</span> <span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.pred_le_pred</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Nat.pow_le_pow_of_le_right</span> <span class=\"n\">Nat.zero_lt_two</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Nat.Prime.two_le</span> <span class=\"n\">h</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">type mismatch</span>\n<span class=\"cm\">  Nat.pred_le_pred (Nat.pow_le_pow_of_le_right Nat.zero_lt_two (Nat.Prime.two_le h))</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  (2 ^ 2).pred ≤ (2 ^ p).pred : Prop</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  2 ^ 2 - 1 ≤ 2 ^ p - 1 : Prop</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>I would have expected <code>Nat.pred_le_pred</code> to also work in the second proof. I didn't manage to trigger this outside of the <code>calc</code> tactic. Does this mean we should maybe add <code>Nat.sub_one_le_sub_one</code> in addition to <code>Nat.pred_le_pred</code>?</p>",
        "id": 438556597,
        "sender_full_name": "Moritz Firsching",
        "timestamp": 1715686547
    },
    {
        "content": "<p>I also get the error outside <code>calc</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">does_not_work</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p.Prime</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n   <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.pred_le_pred</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Nat.pow_le_pow_of_le_right</span> <span class=\"n\">Nat.zero_lt_two</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Nat.Prime.two_le</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>and it goes away with <code>exact</code> (leaving the goal <code>⊢ 1 &lt; 2 ^ p - 1</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">does_work</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p.Prime</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n   <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n     <span class=\"n\">exact</span> <span class=\"n\">Nat.pred_le_pred</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Nat.pow_le_pow_of_le_right</span> <span class=\"n\">Nat.zero_lt_two</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Nat.Prime.two_le</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 438611260,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1715703758
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 438611549,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1715703859
    },
    {
        "content": "<p>What about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.sub_le_sub_right#doc\">docs#Nat.sub_le_sub_right</a> ?</p>",
        "id": 438618818,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1715706322
    },
    {
        "content": "<p>I don't know why <code>Nat.pred_le_pred</code> works if you use <code>exact</code>, but I think it's probably best not to use it anyway.</p>",
        "id": 438619968,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1715706781
    },
    {
        "content": "<p>I think it's because <code>exact</code> has the conversion <code>pred</code> to/from <code>minus 1</code> in its repertoir. And sometimes you don't have <code>sub</code> lemmata, so you have to do with the <code>pred</code> ones. But not here, right.</p>",
        "id": 438623343,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1715708087
    },
    {
        "content": "<p>Just in case you think it's <code>exact</code> itself, <code>Nat.pred n</code> and <code>n - 1</code> are definitionally equal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n.pred</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>(I'm actually a bit surprised that they are!)</p>",
        "id": 438625175,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715708922
    },
    {
        "content": "<p>I suspect that the issue is that <code>Sub</code> is a function of 2 arguments, while <code>Pred</code> is a function of 1 and this is confusing Lean at some point.</p>",
        "id": 438625415,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1715709044
    },
    {
        "content": "<p>I think it would be good not to rely on <code>n.pred</code> being defeq to <code>n - 1</code> and to have analogues like <code>Nat.sub_one_le_sub_one</code>.</p>\n<p>Does <code>Nat.pred</code> need to exist? Is there a use of <code>Nat.pred</code> that can't be served by <code>(· - 1)</code>?</p>",
        "id": 438625712,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715709190
    },
    {
        "content": "<p>In NNG it exists to prove succ_inj (it's a one-sided inverse for succ) although in NNG <code>pred 0 = 37</code>.</p>",
        "id": 438629597,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1715710774
    },
    {
        "content": "<p>I agree that it is good not to use <code>Nat.pred</code> in mathematics, but I don't think there should be a theorem <code>Nat.sub_one_le_sub_one</code> because there's already <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.sub_le_sub_right#doc\">docs#Nat.sub_le_sub_right</a>.</p>",
        "id": 438635951,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1715713301
    },
    {
        "content": "<p>Why don't we have both?</p>",
        "id": 438636142,
        "sender_full_name": "Moritz Firsching",
        "timestamp": 1715713376
    },
    {
        "content": "<p>There's nothing special about subtracting the number 1 specifically.</p>",
        "id": 438636349,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1715713465
    },
    {
        "content": "<p>While I agree that mathematically there is not much special about subtracting 1 or some other number, in Lean there may be a difference.</p>\n<p>In general, <em>numerals</em> may get a different treatment than variables and among numerals, 0 and 1 are further special-cased.  Also, there is an <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.atLeastTwo#doc\">docs#Nat.atLeastTwo</a> typeclass for dealing \"with the rest\"!</p>",
        "id": 438636948,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1715713737
    },
    {
        "content": "<p>I guess <span class=\"user-mention\" data-user-id=\"695266\">@Mitchell Lee</span> has a point, at least we don't have <code>add_one_eq_add_one</code>, while we do have <code>succ_eq_succ</code>.</p>",
        "id": 438637049,
        "sender_full_name": "Moritz Firsching",
        "timestamp": 1715713789
    },
    {
        "content": "<p>(Note that I am not arguing in favour of <code>Nat.pred</code>, I am simply pointing out that the numerals 0 and 1 may be a little more special than others.)</p>",
        "id": 438637066,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1715713795
    },
    {
        "content": "<p>Historically the Nat API liked <code>succ</code> more than does now. This is still reflected in naming and the appearances or otherwise of lemmas, bit I hope further cleanup will continue.</p>",
        "id": 438662525,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1715722663
    },
    {
        "content": "<p>I haven't looked recently at how <code>pred</code> is used in the <code>lean4</code> repo, but generally I'm in favour of using it less when <code>n-1</code> suffices.</p>",
        "id": 438662733,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1715722728
    },
    {
        "content": "<p>I see, I should have looked at the definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.sub#doc\">docs#Nat.sub</a> before being surprised about the defeq. It's defined in terms of <code>Nat.pred</code> and is set up so that <code>Nat.sub a 1 = Nat.pred (Nat.sub a 0) = Nat.pred a</code>.</p>",
        "id": 438665660,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715723785
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"313038\">@Moritz Firsching</span> I've investigated a bit more, and the reason <code>does_not_work</code> doesn't work is that there are some unassignable metavariables. You can use <code>by exact</code> to defer until they're solved for. This might be a bug in <code>calc</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">does_not_work</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p.Prime</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n   <span class=\"k\">calc</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n        <span class=\"n\">_</span>  <span class=\"bp\">≤</span> <span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">Nat.pred_le_pred</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Nat.pow_le_pow_of_le_right</span> <span class=\"n\">Nat.zero_lt_two</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Nat.Prime.two_le</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 438666021,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715723914
    },
    {
        "content": "<p>If you give enough type annotations, then it also goes through:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">does_not_work</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p.Prime</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n   <span class=\"k\">calc</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n        <span class=\"n\">_</span>  <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.pred_le_pred</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Nat.pow_le_pow_of_le_right</span> <span class=\"n\">Nat.zero_lt_two</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Nat.Prime.two_le</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>These annotations give enough information for instance synthesis to complete.</p>",
        "id": 438666492,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715724075
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> note also that this used to work and is a regression somewhere between 9125a0936fd86f4bb74bebe27f0b1cd0c5a2b7cf and aad19d883960cbdd1807a3c31ef7a351c3f0c733</p>",
        "id": 438819001,
        "sender_full_name": "Moritz Firsching",
        "timestamp": 1715783919
    }
]