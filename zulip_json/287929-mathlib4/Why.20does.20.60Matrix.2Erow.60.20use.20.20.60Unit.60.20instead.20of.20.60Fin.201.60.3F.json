[
    {
        "content": "<p>In the following MWE, <code>Matrix.row ![1, 1]</code> yields the error \"expected <code>Unit</code> found <code>Fin 1</code>\". Why did we choose Unit in this definition and can this be made working somehow?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Matrix.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Matrix.Notation</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Matrix.RowCol</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Matrix</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">1</span> <span class=\"bp\">â‰ƒ</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">finOneEquiv</span>\n\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">type mismatch</span>\n<span class=\"cm\">  of ![![1, 1]]</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  Matrix (Fin 1) (Fin 2) ?m.224 : Type ?u.54</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  Matrix Unit (Fin (Nat.succ (Nat.succ 0))) ?m.55 : Type ?u.54</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Matrix.row</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"bp\">!!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 427758214,
        "sender_full_name": "Sina H ð“ƒµ",
        "timestamp": 1710864111
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"420917\">@Sina</span> following our conversation earlier, here is a PR that uses <code>Fin 1</code> instead of <code>Unit</code> in the definition of <code>Matrix.row</code> and <code>Matrix.col</code>:</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/11522\">#11522</a></p>\n<p>It does look like a very reasonable change to me. Obviously some <code>()</code> need to be replaced with <code>0</code>, but essentially there are no notable implications for Mathlib - except of course that now matrix-notation and <code>row</code>/<code>col</code> are more compatible.</p>",
        "id": 427834423,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1710895408
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>, <span class=\"user-mention\" data-user-id=\"387244\">@YaÃ«l Dillies</span>  you two commented about preferrably using a generic <code>Unique Î¹</code> instead of <code>Fin 1</code>, by which I assumed you meant the following: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">col</span> <span class=\"o\">{</span><span class=\"n\">Î¹</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Unique</span> <span class=\"n\">Î¹</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">â†’</span> <span class=\"n\">Î±</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">m</span> <span class=\"n\">Î¹</span> <span class=\"n\">Î±</span> <span class=\"o\">:=</span>\n  <span class=\"n\">of</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">w</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>but then an expression like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">col_apply</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">â†’</span> <span class=\"n\">Î±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">col</span> <span class=\"n\">w</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">w</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>gets stuck because it can't find which <code>Î¹</code> to use, i.e. it fails to synthesize \"Unique ?m.227\". This means one would need to write <code>col (Î¹ := Fin 1) w i j</code> each time.</p>\n<p>Did I misunderstand what you proposed?</p>",
        "id": 427938592,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1710944350
    },
    {
        "content": "<p>That's only a problem for generic lemmas. For specific lemmas, <code>Î¹</code> will be inferred through unification</p>",
        "id": 427938845,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1710944409
    },
    {
        "content": "<p>Also surely you mean</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">col_apply</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">â†’</span> <span class=\"n\">Î±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">Î¹</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">col</span> <span class=\"n\">w</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">w</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 427939031,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1710944462
    },
    {
        "content": "<p>Oh I see, we then need to extend basically all (generic) theorems involving <code>col</code> or <code>row</code> by this <code>Î¹</code> type.</p>\n<p>I'm not fully convinced that this is desirable and not just making the API harder to use. For sure it's going to be a larger diff on the PR, but I can look into it a bit more.</p>",
        "id": 427941203,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1710944976
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">YaÃ«l Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Why.20does.20.60Matrix.2Erow.60.20use.20.20.60Unit.60.20instead.20of.20.60Fin.201.60.3F/near/427938845\">said</a>:</p>\n<blockquote>\n<p>That's only a problem for generic lemmas. For specific lemmas, <code>Î¹</code> will be inferred through unification</p>\n</blockquote>\n<p>I think the question is whether this actually happens effectively</p>",
        "id": 427944054,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710945711
    },
    {
        "content": "<p>One thing we could do to make this less painful is add notation for the type <code>Matrix (Fin m) (Fin n) R</code></p>",
        "id": 427944205,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710945748
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Why.20does.20.60Matrix.2Erow.60.20use.20.20.60Unit.60.20instead.20of.20.60Fin.201.60.3F/near/427944205\">said</a>:</p>\n<blockquote>\n<p>One thing we could do to make this less painful is add notation for the type <code>Matrix (Fin m) (Fin n) R</code></p>\n</blockquote>\n<p>I don't think I understand yet what you're suggesting. How would that differ from <code>!![a,b;c,d]</code>?</p>\n<p>And I mean we do have concrete examples where we'd prefer <code>Fin 1</code> as the one-point-type. Are there cases anywhere where we would prefer anything else to be our \"canonical\" one-point-type?</p>",
        "id": 427946947,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1710946429
    },
    {
        "content": "<p>(I started doing the change at <a href=\"https://github.com/leanprover-community/mathlib4/pull/11536\">#11536</a>, but so far I don't see how the user will not be confronted with random <code>Unique</code> types <code>Î¹</code> appearing here and there which cannot be guessed by lean)</p>",
        "id": 427947399,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1710946541
    },
    {
        "content": "<p>I mean something like <code>(col v : R^mÃ—1)</code></p>",
        "id": 427949223,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710946972
    },
    {
        "content": "<p>I was thinking something like <code>M_[m, n][R]</code></p>",
        "id": 427949680,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1710947090
    },
    {
        "content": "<p>What's the motivation for wanting to use <code>row</code> and <code>col</code> for <code>Fin</code>? Can't we use <code>!![a; b]</code> and <code>!![a, b]</code> instead of <code>col ![a, b]</code> and <code>row ![a, b]</code>? It would be nice to see a slightly more realistic motivating example than <code>Matrix.row ![1, 1] = !![1, 1]</code>.</p>",
        "id": 429189754,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711280822
    },
    {
        "content": "<p>I guess the change runs into a recurring point of tension; do you define functions as generally as possible, or do you define them to operate on some universal object for which there are canonical maps to / from the general types?</p>",
        "id": 429190020,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711280946
    },
    {
        "content": "<p>(see also: Yael's <code>Finset.dens</code>(ity), FooHom vs FooHomClass, ...)</p>",
        "id": 429190047,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711280986
    },
    {
        "content": "<p>In the context of this thread, <code>Unique</code> is the general version, and <code>Unit</code> / <code>Fin 1</code> are fighting to be that universal object</p>",
        "id": 429190128,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711281047
    },
    {
        "content": "<p>4 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/Notation.20for.20Matrix.20.28Fin.20m.29.20.28Fin.20n.29.20R\">#mathlib4 &gt; Notation for Matrix (Fin m) (Fin n) R</a> by <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span>.</p>",
        "id": 433713881,
        "sender_full_name": "Notification Bot",
        "timestamp": 1713346698
    },
    {
        "content": "<p>Breaking changes like this one make me unhappy (not asking for anything; I'm just complaining).</p>",
        "id": 446558654,
        "sender_full_name": "Martin DvoÅ™Ã¡k",
        "timestamp": 1719220603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin DvoÅ™Ã¡k</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Why.20does.20.60Matrix.2Erow.60.20use.20.20.60Unit.60.20instead.20of.20.60Fin.201.60.3F/near/446558654\">said</a>:</p>\n<blockquote>\n<p>Breaking changes like this one make me unhappy (not asking for anything; I'm just complaining).</p>\n</blockquote>\n<p>What is the breaking change your referring to here?</p>",
        "id": 446562942,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719221520
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/11522\">#11522</a></p>",
        "id": 446563143,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1719221560
    },
    {
        "content": "<p>I think you mean <a href=\"https://github.com/leanprover-community/mathlib4/pull/11536\">#11536</a></p>",
        "id": 446564440,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1719221848
    },
    {
        "content": "<p>Oh, I see, that is interesting that you need to specify the <code>[Unique]</code> type that you want to index the row/column by. I'm sympathetic to Martin here. :-)</p>",
        "id": 446565052,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719222048
    },
    {
        "content": "<p>I still think <a href=\"https://github.com/leanprover-community/mathlib4/pull/11522\">#11522</a> would have been way less intrusive and nobody would have noticed that \"fix\", but it was decided by several reviewers that it's better to generalise the notion of a column/row matrix instead.</p>",
        "id": 446565786,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1719222280
    },
    {
        "content": "<p>I have maybe underestimated the pain of having to write <code>(Î¹ := ...)</code> a lot. On the other hand it is nice to have this degree of generality.</p>",
        "id": 446581774,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1719226193
    }
]