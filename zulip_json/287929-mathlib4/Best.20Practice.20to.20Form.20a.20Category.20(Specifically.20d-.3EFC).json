[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Category.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Functor.Basic</span>\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">d_to_FC</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"n\">D</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">‚•§</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">obj</span> <span class=\"n\">where</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Œ¥</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">F.obj</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">hom</span> <span class=\"o\">(</span><span class=\"n\">c_Œ¥</span> <span class=\"n\">c'_Œ¥'</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"n\">F</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"n\">c_Œ¥.c</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">c'_Œ¥'.c</span>\n  <span class=\"n\">comm</span> <span class=\"o\">:</span> <span class=\"n\">c_Œ¥.Œ¥</span> <span class=\"bp\">‚â´</span> <span class=\"n\">F.map</span> <span class=\"n\">Œ±</span> <span class=\"bp\">=</span> <span class=\"n\">c'_Œ¥'.Œ¥</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">c_Œ¥</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"n\">F</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">F</span> <span class=\"n\">d</span> <span class=\"n\">c_Œ¥</span> <span class=\"n\">c_Œ¥</span> <span class=\"n\">where</span>\n  <span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"mi\">ùüô</span> <span class=\"n\">c_Œ¥.c</span>\n  <span class=\"n\">comm</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">F.map_id</span><span class=\"o\">,</span> <span class=\"n\">Category.comp_id</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">comp</span> <span class=\"o\">{</span><span class=\"n\">c_Œ¥</span> <span class=\"n\">c'_Œ¥'</span> <span class=\"n\">c''_Œ¥''</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"n\">F</span> <span class=\"n\">d</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">F</span> <span class=\"n\">d</span> <span class=\"n\">c_Œ¥</span> <span class=\"n\">c'_Œ¥'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">F</span> <span class=\"n\">d</span> <span class=\"n\">c'_Œ¥'</span> <span class=\"n\">c''_Œ¥''</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"n\">F</span> <span class=\"n\">d</span> <span class=\"n\">c_Œ¥</span> <span class=\"n\">c''_Œ¥''</span> <span class=\"n\">where</span>\n  <span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"n\">f.Œ±</span> <span class=\"bp\">‚â´</span> <span class=\"n\">g.Œ±</span>\n  <span class=\"n\">comm</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">F.map_comp</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span><span class=\"n\">Category.assoc</span><span class=\"o\">,</span> <span class=\"n\">f.comm</span><span class=\"o\">,</span> <span class=\"n\">g.comm</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CategoryStruct</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"n\">F</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">Hom</span> <span class=\"n\">c_Œ¥</span> <span class=\"n\">c'_Œ¥'</span> <span class=\"o\">:=</span> <span class=\"n\">hom</span> <span class=\"n\">F</span> <span class=\"n\">d</span> <span class=\"n\">c_Œ¥</span> <span class=\"n\">c'_Œ¥'</span>\n  <span class=\"n\">id</span> <span class=\"n\">c_Œ¥</span> <span class=\"o\">:=</span> <span class=\"n\">id</span> <span class=\"n\">F</span> <span class=\"n\">d</span> <span class=\"n\">c_Œ¥</span>\n  <span class=\"n\">comp</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">comp</span> <span class=\"n\">F</span> <span class=\"n\">d</span> <span class=\"n\">f</span> <span class=\"n\">g</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Category</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"n\">F</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">id_comp</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n    <span class=\"n\">intros</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">f</span>\n    <span class=\"gr\">sorry</span> <span class=\"c1\">-- I'm getting stuck here</span>\n  <span class=\"o\">}</span>\n  <span class=\"n\">comp_id</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">assoc</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span> <span class=\"n\">d_to_FC</span>\n</code></pre></div>\n<p>This is a general question because I want to define categories that I can use inside of my theorems. This category I'm defining for example, the coreflections of an object d across a functor F are precisely the terminal objects of this category. So I want to have the actual datatype so i can type IsTerminal, but I'm not sure about best practices.<br>\n1, do I have to define a CategoryStruct then define a Category and prove id_comp etc, in it? If so, why is proving id_comp so hard and why does f think it's a quiver hom and not a hom from my category?<br>\n2, the object d and the functor F are fixed, but if I use brackets everything breaks again why is this?</p>\n<p>Thank you, if you enjoy questions like this feel free to answer this is merely something I'm doing on my own</p>",
        "id": 433010726,
        "sender_full_name": "Mason McBride",
        "timestamp": 1712978122
    },
    {
        "content": "<p>All the fancy notation in Lean is associated with specific typeclasses; when you type <code>f: ¬†X ‚ü∂ Y</code>, that's just syntactic sugar for <code>Quiver.Hom X Y</code>.</p>",
        "id": 433028835,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712998083
    },
    {
        "content": "<p>Doing it the way you're doing it will make you write down a bunch of lemmas showing that the names <code>hom</code>, <code>id</code>, <code>comp</code> have the meanings you've assigned them (which are all basically <code>by rfl</code> but are kind of annoying to write), so that you can substitute them in (as <code>unfold</code> will probably not do the thing you want here); you might also get away with making them <code>@[reducible]</code></p>",
        "id": 433028968,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712998227
    },
    {
        "content": "<p>also, for the record, this specific category already exists as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Comma#doc\">docs#CategoryTheory.Comma</a> if you want to use an existing structure</p>",
        "id": 433028997,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712998299
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"359992\">Robert Maxton</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Best.20Practice.20to.20Form.20a.20Category.20.28Specifically.20d-.3EFC.29/near/433028997\">said</a>:</p>\n<blockquote>\n<p>also, for the record, this specific category already exists as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Comma#doc\">docs#CategoryTheory.Comma</a> if you want to use an existing structure</p>\n</blockquote>\n<p>See also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.StructuredArrow#doc\">docs#CategoryTheory.StructuredArrow</a> for the specialization to your specific case.</p>",
        "id": 433029113,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1712998432
    },
    {
        "content": "<p>If you instead define your homs as <code>Subtype</code>s inline in the <code>Category</code> instance itself, then <code>aesop_cat</code> can handle the rest:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Category.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Functor.Basic</span>\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">d_to_FC</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"n\">D</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">‚•§</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">obj</span> <span class=\"n\">where</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Œ¥</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">F.obj</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Category</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"n\">F</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">Hom</span> <span class=\"n\">c_Œ¥</span> <span class=\"n\">c'_Œ¥'</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">c_Œ¥.c</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">c'_Œ¥'.c</span> <span class=\"bp\">//</span> <span class=\"n\">c_Œ¥.Œ¥</span> <span class=\"bp\">‚â´</span> <span class=\"n\">F.map</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">c'_Œ¥'.Œ¥</span><span class=\"o\">}</span>\n  <span class=\"n\">id</span> <span class=\"n\">c_Œ¥</span> <span class=\"o\">:=</span> <span class=\"o\">‚ü®</span><span class=\"mi\">ùüô</span> <span class=\"n\">c_Œ¥.c</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">‚ü©</span>\n  <span class=\"n\">comp</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"o\">‚ü®</span><span class=\"n\">f.val</span> <span class=\"bp\">‚â´</span> <span class=\"n\">g.val</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Functor.map_comp</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span><span class=\"n\">Category.assoc</span><span class=\"o\">,</span> <span class=\"n\">f.2</span><span class=\"o\">,</span> <span class=\"n\">g.2</span><span class=\"o\">]‚ü©</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">d_to_FC</span>\n</code></pre></div>",
        "id": 433029335,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712998649
    },
    {
        "content": "<p>(<code>Category</code> is defined so that all its proofs are <code>autoParam</code>s that attempt to discharge themselves with <code>by aesop_cat</code>; you only have to actually provide the proofs if <code>aesop_cat</code> fails.)</p>",
        "id": 433029473,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712998742
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"478516\">Mason McBride</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Best.20Practice.20to.20Form.20a.20Category.20.28Specifically.20d-.3EFC.29/near/433010726\">said</a>:</p>\n<blockquote>\n<p>2, the object d and the functor F are fixed, but if I use brackets everything breaks again why is this?</p>\n</blockquote>\n<p>Also, I'm not sure what you mean by \"brackets\" here. If you mean square brackets, that only works for typeclass instances; if you mean curly braces, that makes them implicit, which means Lean expects that you won't provide them and it'll have to infer them from other parameters, which is probably not what you're going for here.</p>",
        "id": 433029682,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712998903
    }
]