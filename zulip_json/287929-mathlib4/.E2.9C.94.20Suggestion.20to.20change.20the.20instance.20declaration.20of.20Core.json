[
    {
        "content": "<p>The idea is to make the declaration (f : X ⟶ Y) resolve to the groupoid instantiation of the morphism when X and Y is in Core C.<br>\nI started using Lean a month ago, so take my suggestion with a pinch of salt!</p>\n<p>Core is defined in CategoryTheory.Core.lean and described as follows:</p>\n<h1>The core of a category</h1>\n<p>The core of a category <code>C</code> is the (non-full) subcategory of <code>C</code> consisting of all objects,<br>\nand all isomorphisms. We construct it as a <code>CategoryTheory.Groupoid</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Core</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">C</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">coreCategory</span> <span class=\"o\">:</span> <span class=\"n\">Groupoid.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Core</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">Hom</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">X</span> <span class=\"bp\">≅</span> <span class=\"n\">Y</span>\n  <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Iso.refl</span> <span class=\"n\">X</span>\n  <span class=\"n\">comp</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">Iso.trans</span> <span class=\"n\">f</span> <span class=\"n\">g</span>\n  <span class=\"n\">inv</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">Iso.symm</span> <span class=\"n\">f</span>\n</code></pre></div>\n<p>The problem is that Hom takes two elements of C(and not Core C) and C is already an instance of Category, so if X Y : C<br>\nX ⟶ Y resolves to the morphism in Category C.</p>\n<p>So </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span><span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">Core</span> <span class=\"n\">C</span><span class=\"o\">)(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">):</span> <span class=\"n\">Iso</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"n\">f</span>\n</code></pre></div>\n<p>returns the error message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">f</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v₁</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">X</span> <span class=\"bp\">≅</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v₁</span>\n</code></pre></div>\n<p>One can manually instantiate the groupoid morphism by</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo1</span><span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span>  <span class=\"n\">C</span><span class=\"o\">)(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">coreCategory.Hom</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">):</span> <span class=\"n\">Iso</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">it</span> <span class=\"n\">doesn't</span> <span class=\"n\">work</span> <span class=\"k\">with</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span><span class=\"n\">Core</span>  <span class=\"n\">C</span><span class=\"o\">))</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>However, I wanted a solution where the right instance was derived automatically and where I could define (X Y : Core C) and not C.<br>\nI ended up with:</p>\n<p>def coerceCore(X : Core C) : C := X <br>\ninstance coreCategory : Groupoid.{v₁} (Core C) where<br>\n  Hom (X Y : Core C) := coerceCore X ≅ coerceCore Y<br>\n  id (X : Core C) := Iso.refl (coerceCore X)<br>\n  comp f g := Iso.trans f g<br>\n  inv {X Y} f := Iso.symm f<br>\nThe reason we need need coerceCore is to access the Category instance of C.<br>\nIt seems to work and I would appreciate any comment and if there is a more elegant solution.</p>",
        "id": 434019073,
        "sender_full_name": "Dan Synek",
        "timestamp": 1713437396
    },
    {
        "content": "<p>Seems reasonable. I'd just call it <code>ofCore</code>. It's probably even better to make <code>Core</code> a one-field structure wrapping <code>C</code>. (like we do with most other such synonyms at this point).</p>",
        "id": 434021071,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1713438152
    },
    {
        "content": "<p>As <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span>,  I think the best solution would be to introduce a structure like we do for the opposite category:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Groupoid</span>\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Core</span> <span class=\"n\">where</span>\n  <span class=\"n\">obj</span> <span class=\"o\">:</span> <span class=\"n\">C</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Groupoid</span> <span class=\"o\">(</span><span class=\"n\">Core</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">Hom</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"n\">X.obj</span> <span class=\"bp\">≅</span> <span class=\"n\">Y.obj</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"n\">Iso.symm</span>\n  <span class=\"n\">id</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">Iso.refl</span> <span class=\"n\">_</span>\n  <span class=\"n\">comp</span> <span class=\"o\">:=</span> <span class=\"n\">Iso.trans</span>\n</code></pre></div>",
        "id": 434034412,
        "sender_full_name": "Joël Riou",
        "timestamp": 1713443049
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span>  <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span>  I agree that introducing a structure is cleaner. It is a bit of a mystery to me when defintions are expanded in typechecking and that is avoided with a structure. I don't think I am ready yet to make changes to Mathlib, so for my application I will go with the minimal change, which is to do the coercion manually.</p>",
        "id": 434294032,
        "sender_full_name": "Dan Synek",
        "timestamp": 1713508179
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"698527\">Dan Synek</span> has marked this topic as resolved.</p>",
        "id": 434294046,
        "sender_full_name": "Notification Bot",
        "timestamp": 1713508194
    },
    {
        "content": "<p>It seems that you understand Lean better than when I first attempted to make additions to mathlib! I would like to encourage you to do so <a href=\"https://leanprover-community.github.io/contribute/index.html\">https://leanprover-community.github.io/contribute/index.html</a><br>\nIt seems that nothing in mathlib depends on this file <code>Core.lean</code>, so that the complexity of the pull request would be minimal, as it would change a single file.</p>",
        "id": 434298973,
        "sender_full_name": "Joël Riou",
        "timestamp": 1713510415
    },
    {
        "content": "<p>Ok <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> ! I will use the structure version of Core in my attempt to define Species of Structure(no pun intended) in Lean. If Core works in this example then I will contribute my version of it. Looking forward!</p>",
        "id": 434311204,
        "sender_full_name": "Dan Synek",
        "timestamp": 1713514499
    }
]