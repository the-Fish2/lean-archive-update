[
    {
        "content": "<p>Can someone explain these examples:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">tactic</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">split_ifs</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">done</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">split_ifs</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">done</span>\n</code></pre></div>\n<p>In the first proof, after the <code>split_ifs</code> the goal is <code>0 = 0</code>, and <code>rfl</code> completes the proof.  In the second proof, after <code>split_ifs</code> there are two <code>0 = 0</code> goals, one with the additional hypothesis <code>u = u</code> and one with the additional hypothesis <code>¬u = u</code>, so one needs two invocations of <code>rfl</code> to complete the proof.  Why the difference?  The tactic state when <code>split_ifs</code> is invoked appears to be the same in the two examples.</p>",
        "id": 445173774,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1718641513
    },
    {
        "content": "<p>This seems like a missing <code>withMainContext</code> in the implementation of <code>split_ifs</code> to me, but I'm not super knowledgable about these things.</p>",
        "id": 445177658,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1718642641
    },
    {
        "content": "<p>If you do <code>show_term split_ifs</code> you can see the difference in what it produces.</p>",
        "id": 445177750,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1718642663
    },
    {
        "content": "<p><del>I think split_ifs looks for hypotheses that match the condition to avoid creating pointless subgoals</del></p>",
        "id": 445178133,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1718642784
    },
    {
        "content": "<p>Right, but it should have found it in the second example, unless it didn't get the new context after the <code>have</code></p>",
        "id": 445178259,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1718642825
    },
    {
        "content": "<p>Oh sorry, I missed the <code>have</code></p>",
        "id": 445178354,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1718642860
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243791\">@David Renshaw</span> since you ported this tactic, maybe you see the problem here? It's not immediately obvious to me.</p>",
        "id": 445187861,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1718645780
    },
    {
        "content": "<p>Exceedingly often, weird tactic behaviour after <code>have</code> is due to the presence of metadata introduced by the <code>have</code>.</p>",
        "id": 445225515,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718658520
    },
    {
        "content": "<p>A quick look at the tactic makes me wonder whether there are a couple of <code>whnfR</code> missing in <code>getSplitCandidates</code>, around the <code>getMainTarget</code>s, but I'm not at a computer to be able to check.</p>",
        "id": 445226804,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718658921
    },
    {
        "content": "<p>This makes the behavior of the two versions match:</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gh\">diff --git a/Mathlib/Tactic/SplitIfs.lean b/Mathlib/Tactic/SplitIfs.lean</span>\n<span class=\"gh\">index d41c91ddab..7a408e2004 100644</span>\n<span class=\"gd\">--- a/Mathlib/Tactic/SplitIfs.lean</span>\n<span class=\"gi\">+++ b/Mathlib/Tactic/SplitIfs.lean</span>\n<span class=\"gu\">@@ -102,9 +102,11 @@ private def getNextName (hNames: IO.Ref (List (TSyntax `Lean.binderIdent))) : Me</span>\n<span class=\"w\"> </span>-/\n<span class=\"w\"> </span>private def valueKnown (cond : Expr) : TacticM Bool := do\n<span class=\"w\"> </span>  let hTypes ← (((← getLCtx).getFVarIds.map mkFVar).mapM inferType : MetaM _)\n<span class=\"gd\">-  let hTypes := hTypes.toList</span>\n<span class=\"w\"> </span>  let not_cond := mkApp (mkConst `Not) cond\n<span class=\"gd\">-  return (hTypes.contains cond) || (hTypes.contains not_cond)</span>\n<span class=\"gi\">+  for ht in hTypes do</span>\n<span class=\"gi\">+    if ← isDefEq cond ht then return true</span>\n<span class=\"gi\">+    if ← isDefEq not_cond ht then return true</span>\n<span class=\"gi\">+  return false</span>\n</code></pre></div>",
        "id": 445247805,
        "sender_full_name": "David Renshaw",
        "timestamp": 1718669803
    },
    {
        "content": "<p>(and causes some breakage in mathlib)</p>",
        "id": 445247841,
        "sender_full_name": "David Renshaw",
        "timestamp": 1718669836
    },
    {
        "content": "<p>Just doing <code>instantiateMVars</code> seems to works better...</p>",
        "id": 445249081,
        "sender_full_name": "David Renshaw",
        "timestamp": 1718670695
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gh\">diff --git a/Mathlib/Tactic/SplitIfs.lean b/Mathlib/Tactic/SplitIfs.lean</span>\n<span class=\"gh\">index d41c91ddab..13d9944826 100644</span>\n<span class=\"gd\">--- a/Mathlib/Tactic/SplitIfs.lean</span>\n<span class=\"gi\">+++ b/Mathlib/Tactic/SplitIfs.lean</span>\n<span class=\"gu\">@@ -101,10 +101,12 @@ private def getNextName (hNames: IO.Ref (List (TSyntax `Lean.binderIdent))) : Me</span>\n<span class=\"w\"> </span>/-- Returns `true` if the condition or its negation already appears as a hypothesis.\n<span class=\"w\"> </span>-/\n<span class=\"w\"> </span>private def valueKnown (cond : Expr) : TacticM Bool := do\n<span class=\"gd\">-  let hTypes ← (((← getLCtx).getFVarIds.map mkFVar).mapM inferType : MetaM _)</span>\n<span class=\"gd\">-  let hTypes := hTypes.toList</span>\n<span class=\"w\"> </span>  let not_cond := mkApp (mkConst `Not) cond\n<span class=\"gd\">-  return (hTypes.contains cond) || (hTypes.contains not_cond)</span>\n<span class=\"gi\">+  for h in ← getLocalHyps do</span>\n<span class=\"gi\">+    let ty ← instantiateMVars (← inferType h)</span>\n<span class=\"gi\">+    if cond == ty then return true</span>\n<span class=\"gi\">+    if not_cond == ty then return true</span>\n<span class=\"gi\">+  return false</span>\n</code></pre></div>",
        "id": 445249714,
        "sender_full_name": "David Renshaw",
        "timestamp": 1718671188
    },
    {
        "content": "<p>I opened a pull request with a fix:<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/pull/13916\">#13916</a></p>",
        "id": 445252055,
        "sender_full_name": "David Renshaw",
        "timestamp": 1718672805
    }
]