[
    {
        "content": "<p>Does the following alternative definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RootPairing#doc\">docs#RootPairing</a> seem reasonable?  I thought it might remove the necessity of choice when, e.g., considering the permutation action of the Weyl group on the type that indexes roots:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">RootPairing</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">PerfectPairing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">root</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">↪</span><span class=\"w\"> </span><span class=\"n\">M</span>\n<span class=\"w\">  </span><span class=\"n\">coroot</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">↪</span><span class=\"w\"> </span><span class=\"n\">N</span>\n<span class=\"w\">  </span><span class=\"n\">root_coroot_two</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toLin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">coroot</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"n\">reflection_perm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">reflection_perm_root</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">preReflection</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toLin</span><span class=\"bp\">.</span><span class=\"n\">flip</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">coroot</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">root</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">reflection_perm</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">reflection_perm_coroot</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">preReflection</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">coroot</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toLin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">coroot</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">coroot</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">reflection_perm</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 442468126,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1717488582
    },
    {
        "content": "<p>As far as I can tell, the two definitions are \"mathematically equivalent\". (edit 1 week later: this is wrong)</p>",
        "id": 442468855,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1717488795
    },
    {
        "content": "<p>Re \"I thought\"... do I understand correctly that you still think that?</p>",
        "id": 442468940,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1717488824
    },
    {
        "content": "<p>Nice question! Of course you can check that they're equivalent by checking you can write code which bijects the two structures :-)</p>",
        "id": 442468970,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717488839
    },
    {
        "content": "<p>So the \"new stuff\" is that you are explicitly registering <code>reflection_perm</code>, right? And afaict it should be easy to build an \"old\" root pairing from your new defn. And in the other direction, theory indicates that it works. But I don't think we have the permutation action of Weyl groups yet. So I'm not sure we can carry out Kevin's exercise...</p>",
        "id": 442469549,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1717488999
    },
    {
        "content": "<p>Yes, I still think that.</p>",
        "id": 442469574,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1717489007
    },
    {
        "content": "<p>Minor comment: do you need the <code>.toFun</code> bits in the last 2 axioms?</p>",
        "id": 442469738,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1717489059
    },
    {
        "content": "<p>Yes, I was writing API for the permutation action, and getting very frustrated.</p>",
        "id": 442469762,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1717489071
    },
    {
        "content": "<p>No, it seems <code>.toFun</code> was unnecessary.  Editing.</p>",
        "id": 442469900,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1717489104
    },
    {
        "content": "<p>Somewhat major question: can we easily convince ourselves that propositionally <code>reflection_perm</code> is determined by the other axioms?</p>",
        "id": 442470038,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1717489154
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> who probably has something to say about this thread (-;</p>",
        "id": 442470766,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1717489389
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RootPairing.bijOn_reflection_root#doc\">docs#RootPairing.bijOn_reflection_root</a> which says reflection induces bijections on the images under the injection <code>root</code>, but nothing about lifting the bijection to the indexing type (I'm still don't know an elegant way to do this - I used lots of <code>choose</code> and <code>choose_spec</code>).</p>",
        "id": 442471016,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1717489462
    },
    {
        "content": "<p>Maybe <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.Embedding.toEquivRange#doc\">docs#Function.Embedding.toEquivRange</a> can give a good spelling of the lift?</p>",
        "id": 442471867,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1717489743
    },
    {
        "content": "<p>Or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.ofInjective#doc\">docs#Equiv.ofInjective</a></p>",
        "id": 442471977,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1717489782
    },
    {
        "content": "<p>I think Scott's suggestion is excellent and very much in the spirit of the rest of the definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RootPairing#doc\">docs#RootPairing</a> in which I took the view that the most convenient thing to do was to include uniquely-determined data and provide extensionality lemmas in the case that someone needed to take advantage of this uniqueness.</p>\n<p>Of course it's not necessary to change the definitions, but I worked quite hard before I landed on the current design and my memory of previous iterations (which involved moderate use of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.choose_spec#doc\">docs#Classical.choose_spec</a> amongst other things) makes it easy to believe that this extension is a good idea.</p>",
        "id": 442611715,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1717530225
    },
    {
        "content": "<p>Unfortunately I do not have time to help with this refactor but I'd certainly be interested to see it attempted, and I would be surprised if it is not an improvement (even though I am already quite pleased with our current design).</p>",
        "id": 442612378,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1717530456
    },
    {
        "content": "<p>Thank you for the comments.  I will attempt a refactor.</p>",
        "id": 442627531,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1717535383
    },
    {
        "content": "<p>It turns out the two definitions are not mathematically equivalent - the condition <code>reflection_perm_coroot</code> does not necessarily follow from the old definition in general.<br>\nThey are equivalent for finite root systems in characteristic zero.<br>\nIn the infinite case, the affine sl2 root pairing gives a counterexample.  If we start with a pairing satisfying the new definition, then precomposing <code>coroot</code> with a suitable permutation of <code>ι</code> yields a structure that breaks the new definition but still satisfies the old definition.</p>",
        "id": 443945612,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1718094647
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"630477\">@Scott Carnahan</span> Interesting! I cannot infer from your message whether you think that is a feature or a bug of the new definition <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span> <br>\nOr should we have both?</p>",
        "id": 443964317,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1718100726
    },
    {
        "content": "<p>I think this means the new definition is preferable.  Alternatively, I was too careless making a PR that removed the finiteness hypothesis in the old definition.</p>",
        "id": 443970939,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1718102735
    },
    {
        "content": "<p>Ok, sounds good. I will happily review a PR that upgrades mathlib to the new definition.</p>",
        "id": 443993709,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1718110745
    },
    {
        "content": "<p>The new definition is definitely the \"right\" one if we want to support infinite and positive-characteristic root systems (which we do).</p>\n<p>With the benefit of hindsight, good evidence for this is the fact that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RootSystem.coroot_eq_coreflection_of_root_eq#doc\">docs#RootSystem.coroot_eq_coreflection_of_root_eq</a> demands <code>[Finte ι]</code> and <code>[CharZero R]</code>. Moreover, your affine-sl2-based example shows <code>[Finte ι]</code> is necessary (and it wouldn't be too hard to find an example showing <code>[CharZero R]</code> is too).</p>",
        "id": 444098538,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1718139044
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Thank you for offering! <a href=\"https://github.com/leanprover-community/mathlib4/pull/13917\">#13917</a> <br>\nPlease let me know if I am trying to do too much in one PR.</p>",
        "id": 445277578,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1718690590
    },
    {
        "content": "<p>Thanks for doing this. I'll review it this evening.</p>",
        "id": 445302176,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1718699693
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"630477\">@Scott Carnahan</span> I decided to push up a commit of my own to <a href=\"https://github.com/leanprover-community/mathlib4/pull/13917\">#13917</a>. I hope this is OK! Unfortunately this does mean we'll need a new reviewer to get this merged.</p>\n<p>My main motivation was to add the alternate constructor <code>RootPairing.mk'</code>.</p>\n<p>Mathematically, the main content is that if:</p>\n<ol>\n<li>the roots / coroots are finite, and</li>\n<li>we are in characteristic zero, and</li>\n<li>there is no torsion,</li>\n</ol>\n<p>then requiring that the root / coroots are stable under reflections / coreflections is sufficient to ensure that the _same family of permuations_ is induced on both roots and coroots.</p>\n<p>I've never seen root data / systems set up to require this _same family of permutations_ property by definition: it's always a corollary, so I think it is important to provide these additional constructors which show that your very nice definition which requires it by definition is equivalent in the presence of 1, 2, 3.</p>",
        "id": 446325114,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1719089788
    },
    {
        "content": "<p>I wonder has anyone worked these details out before. It seems root systems / data provide a good example of the phenomenon where naive weakening of the hypotheses leads to nonsense and axioms which are invisible in the usual cases need to be added to exclude pathologies in general.</p>",
        "id": 446325478,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1719090009
    },
    {
        "content": "<p>I will try to find time to review this today. (Sorry for the late responses, the past 10 days have been hectic.)</p>",
        "id": 447212246,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1719406400
    }
]