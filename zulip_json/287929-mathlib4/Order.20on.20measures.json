[
    {
        "content": "<p>Currently, <code>≤</code> on measures is defined as <code>∀ s, MeasurableSet s → μ s ≤ ν s</code>. I suggest that we redefine it as <code>∀ s, μ s ≤ ν s</code> (now available as a lemma) for the following reasons:</p>\n<ul>\n<li>this way it is defeq to <code>≤</code> on outer measures;</li>\n<li>if we decide to introduce a <code>Preorder</code>/<code>PartialOrder</code> on all <code>DFunLike</code> types <strong>and</strong> migrate measures to <code>FunLike</code>, then this is unavoidable;</li>\n<li>the current reasoning is \"it's slightly easier to prove <code>μ ≤ ν</code> this way\"; the counter-argument is \"it's slightly harder to apply <code>μ ≤ ν</code> this way\".</li>\n</ul>",
        "id": 422141665,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708302061
    },
    {
        "content": "<p>I'll try to PR it today or tomorrow</p>",
        "id": 422145628,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708305924
    },
    {
        "content": "<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/10714\">#10714</a> :: order on measures</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/10721\">#10721</a> :: generic <code>Preorder</code> and <code>PartialOrder</code> on <code>DFunLike</code></li>\n</ul>",
        "id": 422192065,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708334623
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> This is my motivation for <a href=\"https://github.com/leanprover-community/mathlib4/pull/10721\">#10721</a></p>",
        "id": 425723347,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1710023192
    },
    {
        "content": "<p>That explains why you want an order on measures, but that doesn't explain why you want to do it via a fun-like-generic instance</p>",
        "id": 425723399,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710023252
    },
    {
        "content": "<p>I want lemmas like <code>ae_mono</code> to work both for measures and outer measures</p>",
        "id": 425729507,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1710029813
    },
    {
        "content": "<p>/poll What should I do with <a href=\"https://github.com/leanprover-community/mathlib4/pull/10721\">#10721</a>?<br>\nLeave as is (introduce generic <code>Preorder</code> on <code>DFunLike</code>)<br>\nDefine an empty typeclass <code>[PointwiseOrder]</code> and enable this <code>Preorder</code> only if <code>[PointwiseOrder]</code> is present<br>\nDefine a typeclass <code>[PointwiseOrder]</code> saying that the order (defined elsewhere) is equivalent to the pointwise one</p>",
        "id": 426671021,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1710475919
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> I see your examples for <code>SetLike</code> (though I'm not sure that a few exceptions justify changes to <code>SetLike</code>; another option is not to use <code>SetLike</code> for these types - let's discuss this elsewhere). Do you have examples of <code>DFunLike</code>s that have a natural non-pointwise order?</p>",
        "id": 426671249,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1710476054
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span></p>",
        "id": 433070498,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1713034823
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> Is there a reason to not have a nice defeq for <code>le</code>?</p>",
        "id": 433073146,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1713037333
    },
    {
        "content": "<p>I think this could be annoying for the order on operators of a Hilbert Space. E.g for linear endomorphisms of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> the order you want is not the pointwise order.</p>",
        "id": 433073178,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1713037387
    },
    {
        "content": "<p>This explains why not option 1. Why not option 2?</p>",
        "id": 433073207,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1713037437
    },
    {
        "content": "<p>I guess I don't quite understand option 2, I thought it was \"make the instance localized\" but upon rereading it is not.</p>",
        "id": 433073290,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1713037514
    },
    {
        "content": "<p>It's about the following design (not copy+pasting from Lean, so may contain typos):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">DFunLike</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">PointwiseOrder</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span> <span class=\"c1\">-- empty tag</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">DFunLike</span> <span class=\"n\">F</span> <span class=\"n\">ι</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">LE</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">PointwiseOrder</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">LE</span> <span class=\"n\">F</span> <span class=\"n\">where</span>\n  <span class=\"n\">le</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">g</span> <span class=\"n\">i</span>\n</code></pre></div>",
        "id": 433073495,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1713037715
    },
    {
        "content": "<p>The main downside I see is that we can't do the same for <code>PointwiseSup</code>/<code>PointwiseInf</code>.</p>",
        "id": 433073544,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1713037775
    },
    {
        "content": "<p>I guess the question is \"are we likely to have orders which are propositionally the pointwise order but not definitionally\". Right now I can't think of any, so I'm fine with option 2.</p>",
        "id": 433073667,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1713037878
    },
    {
        "content": "<p>OK, I'll change my PR to option 2. We can migrate to option 3 later, if needed.</p>",
        "id": 433073748,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1713037948
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Order.20on.20measures/near/433073667\">said</a>:</p>\n<blockquote>\n<p>I guess the question is \"are we likely to have orders which are propositionally the pointwise order but not definitionally\". Right now I can't think of any</p>\n</blockquote>\n<p>One way it could show up is eg if we made <code>(iota -&gt; alpha) x (iota -&gt; beta)</code> be <code>FunLike iota (alpha x beta)</code>. The order is defined as <code>(\\forall i, f.1 i &lt;= g.1 i) \\and (\\forall i, f.2 i &lt;= g.2 i)</code>, which is not defeq to <code>\\forall i, (f.1 i, f.2 i) &lt;= (g.1 i, g.2 i)</code>.</p>",
        "id": 433104971,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713072255
    },
    {
        "content": "<p>Are we going to use <code>DFunLike</code> for something other than bundled morphisms?</p>",
        "id": 433105016,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1713072314
    },
    {
        "content": "<p>No, my example above is a toy example, but I am not yet convinced that bundled morphisms couldn't somehow disguise that example.</p>",
        "id": 433105133,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713072382
    },
    {
        "content": "<p>Anyway, I would prefer n°3 on the grounds that we shouldn't create data out of nowhere</p>",
        "id": 433105150,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713072423
    },
    {
        "content": "<p>A bundled morphism is a specific type. We define order instances specific to this type.</p>",
        "id": 433105168,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1713072433
    },
    {
        "content": "<p>and nicely enough n°3 is very close to what's in <a href=\"https://github.com/leanprover-community/mathlib/pull/16351\">!3#16351</a></p>",
        "id": 433105179,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713072462
    },
    {
        "content": "<p>There is a tradeoff between generality and availability of defeq lemmas...</p>",
        "id": 433105271,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1713072573
    },
    {
        "content": "<p>BTW, how much does this design pattern affect instance args term sizes?</p>",
        "id": 433105364,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1713072659
    },
    {
        "content": "<p>I mean, now we have just <code>MyType.preorder</code>, <code>MyType.lattice</code> etc, but with classes like <code>PointwiseOrder</code>, <code>PointwiseSup</code>, <code>PointwiseBot</code> etc, we'll get instances like <code>DFunLike.Lattice [DFunLike F ι α] [∀ i, Lattice (α i)] [LE F] [LT F] [PointwiseOrder F ι α] [PointwiseSup F ι α] [PointwiseInf F ι α] : Lattice F</code></p>",
        "id": 433105505,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1713072839
    },
    {
        "content": "<p>Is it better to have these generic instances, or a meta program that defines instances for each specific bundled hom?</p>",
        "id": 433105588,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1713072924
    },
    {
        "content": "<p>The downside of meta programming approach is that we can't prove generic lemmas that involve different bundled homs.</p>",
        "id": 433105677,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1713073023
    },
    {
        "content": "<p>How many generic lemmas are there?</p>",
        "id": 433111789,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713079379
    },
    {
        "content": "<p>Also surely you can still prove them if <code>PointwiseOrder</code> is a prop-valued mixin?</p>",
        "id": 433111808,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713079399
    },
    {
        "content": "<p>What I'm more worried about is that you are about to create an asymmetry between <code>∀ i, π i</code> and <code>α × β</code></p>",
        "id": 433111830,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713079436
    },
    {
        "content": "<p>Basically we're missing some idea here about how to deal with \"coordinates\" in types. See eg <a href=\"https://github.com/leanprover-community/mathlib4/pull/10565\">#10565</a> for a pain demonstration</p>",
        "id": 433111917,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713079510
    },
    {
        "content": "<p>Browsing the files didn't help me understand what you meant here. Specifically, what do you find annoying/what part would you have wished to be easier?</p>",
        "id": 433112782,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1713080266
    },
    {
        "content": "<p>All the lemmas ending in <code>_pi</code> are true for any product of copies of <code>ℝ</code> equipped with the pointwise order (eg <code>ℝ × ℝ</code>, <code>EuclideanSpace ι ℝ</code>), not just <code>ι → ℝ</code>.</p>",
        "id": 433116640,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713083871
    },
    {
        "content": "<p>Is it possible to have a predicate ‘IsProduct‘ that would allow to handle them simultaneously? This is kind of categorifying the library independently of the files on category theory, so might duplicate some work.</p>",
        "id": 433137798,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1713104341
    },
    {
        "content": "<p>I've been looking for something like that, yeah, but I haven't come with anything practical yet</p>",
        "id": 433137909,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713104428
    },
    {
        "content": "<p>We already have a few classes with instances for (conditionally complete) linear orders, pi types and products. E.g., <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CompactIccSpace#doc\">docs#CompactIccSpace</a></p>",
        "id": 433137942,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1713104476
    }
]