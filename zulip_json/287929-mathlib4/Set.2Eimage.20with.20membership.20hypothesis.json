[
    {
        "content": "<p>Is there a version of Set.image that accepts a function along with a hypothesis of membership? Something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Set.image'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">β</span>\n</code></pre></div>\n<p>In case this is an XY problem: I have a finite set of elements <code>U = {a₁, .., aₙ} : Set α</code>, and I have another set <code>K : Set (Set α)</code>. For each element in <code>U</code>, there exists an element in <code>K</code> containing it. That is, I have <code>hU : ∀ aᵢ ∈ U, ∃ Yᵢ ∈ K, aᵢ ∈ Yᵢ</code> (though there may be multiple <code>Yᵢ</code>s to choose from). I want to (noncomputably) produce a set <code>Ys : Set α</code> that is effectively selecting a <code>Yᵢ</code> for each <code>aᵢ</code>. Critically, however, I want a single <code>Yᵢ</code> for each <code>aᵢ</code>, as I have <code>Set.Finite U</code>, and want to have <code>Set.Finite Ys</code> as well. <code>K</code> is infinite and there may be infinitely many <code>Yᵢ</code> to choose from for each <code>aᵢ</code>.</p>\n<p>I tried to do something like <code>{Exists.choose (hU aᵢ) | aᵢ ∈ U}</code>, but <code>hU</code> requires a proof of <code>aᵢ ∈ U</code>.</p>",
        "id": 416646761,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705610743
    },
    {
        "content": "<p>You can use Set.attach</p>",
        "id": 416650286,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1705612184
    },
    {
        "content": "<p>Oh huh, that's an interesting idea. Let me play around with that</p>",
        "id": 416651363,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705612669
    },
    {
        "content": "<p>Also do you mean <code>Finset.attach</code>?</p>",
        "id": 416651446,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705612692
    },
    {
        "content": "<p>I think this will end up working, but definitely creates some nasty types b/c of the subtype.</p>",
        "id": 416662360,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705618068
    },
    {
        "content": "<p>I think the move is actually something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">Ys</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"o\">(</span><span class=\"n\">hU</span> <span class=\"n\">α</span><span class=\"bp\">ᵢ</span> <span class=\"n\">α</span><span class=\"bp\">ᵢ.</span><span class=\"n\">prop</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span> <span class=\"bp\">|</span> <span class=\"n\">α</span><span class=\"bp\">ᵢ</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 416681896,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705626764
    },
    {
        "content": "<p>Note the <code>αᵢ : U</code> instead of <code>αᵢ ∈ U</code></p>",
        "id": 416681937,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705626794
    },
    {
        "content": "<p>Nice, and is <code>Ys</code> <code>Finite</code>?<br>\nIf <code>U</code> is a <code>Finset</code>, you can write <code>U.attach.image fun u : ↥U =&gt; (hU u.val u.property).choose</code>, or come up with a <code>Function.Embedding</code> <code>e : ↥U ↪ K</code> and write <code>U.attach.map e</code> [untested (an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> would be useful)].</p>",
        "id": 416683201,
        "sender_full_name": "Richard Copley",
        "timestamp": 1705627457
    },
    {
        "content": "<p>This works on your original code sample:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Set.image'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">ha</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 416684244,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705627999
    },
    {
        "content": "<p>As does</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Set.image''</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Subtype.rec</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">univ</span>\n</code></pre></div>",
        "id": 416684520,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705628154
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400544\">Richard Copley</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Set.2Eimage.20with.20membership.20hypothesis/near/416683201\">said</a>:</p>\n<blockquote>\n<p>Nice, and is <code>Ys</code> <code>Finite</code>?</p>\n</blockquote>\n<p>Actually stuck on that now haha. I have <code>Set.Finite U</code>.</p>\n<p>The embedding is a good suggestion.</p>",
        "id": 416685586,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705628647
    },
    {
        "content": "<p>Let me put together a mwe, trying to prove some lemmas on chains needed for Lindenbaum's Lemma</p>",
        "id": 416686261,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705628946
    },
    {
        "content": "<p>Uh on second thought might do that (provide a mwe) later, the proof is a bit disorganized at the moment and I should reorganize it first. This has already been a big help :)</p>",
        "id": 416687236,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705629481
    },
    {
        "content": "<p>I have sort of a mwe. It's not as relevant to the question, but</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Finite</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Chain</span>\n\n<span class=\"kd\">variable</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)}</span>\n  <span class=\"o\">(</span><span class=\"n\">hK</span> <span class=\"o\">:</span> <span class=\"n\">IsChain</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">⊆</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U₀</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hU₀fin</span> <span class=\"o\">:</span> <span class=\"n\">Set.Finite</span> <span class=\"n\">U₀</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">α</span><span class=\"bp\">ᵢ</span> <span class=\"bp\">∈</span> <span class=\"n\">U₀</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">Y</span><span class=\"bp\">ᵢ</span> <span class=\"bp\">∈</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">α</span><span class=\"bp\">ᵢ</span> <span class=\"bp\">∈</span> <span class=\"n\">Y</span><span class=\"bp\">ᵢ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">U₀_supset</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">Y</span> <span class=\"bp\">∈</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">U₀</span> <span class=\"bp\">⊆</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>is essentially what I'm trying to prove. My initial thought (and what spawned my original question) was to map each <code>αᵢ ∈ U₀</code> to a <code>Yᵢ</code> using <code>map</code>. Then use <code>Finset.max</code> by showing a linear order since they are members of the chain <code>K</code>. I'm wondering now if there's a simpler solution, but that's beyond the scope of this thread :)</p>",
        "id": 416695957,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705632140
    },
    {
        "content": "<p>Maybe induction on the cardinality is simpler</p>",
        "id": 416696202,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705632302
    },
    {
        "content": "<p>just to close this out, while this can probably be golfed, I ended up solving it with induction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Finite</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Chain</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">chain_fin_subset_max</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">hKne</span> <span class=\"o\">:</span> <span class=\"n\">Set.Nonempty</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hKc</span> <span class=\"o\">:</span> <span class=\"n\">IsChain</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">⊆</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">U₀</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hU₀fin</span> <span class=\"o\">:</span> <span class=\"n\">Set.Finite</span> <span class=\"n\">U₀</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">α</span><span class=\"bp\">ᵢ</span> <span class=\"bp\">∈</span> <span class=\"n\">U₀</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">Y</span><span class=\"bp\">ᵢ</span> <span class=\"bp\">∈</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">α</span><span class=\"bp\">ᵢ</span> <span class=\"bp\">∈</span> <span class=\"n\">Y</span><span class=\"bp\">ᵢ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">Y</span> <span class=\"bp\">∈</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">U₀</span> <span class=\"bp\">⊆</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction'</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Set.ncard</span> <span class=\"n\">U₀</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">n_ih</span> <span class=\"n\">generalizing</span> <span class=\"n\">U₀</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.ncard_eq_zero</span> <span class=\"n\">hU₀fin</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n    <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">hY</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hKne</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">hY</span><span class=\"o\">,</span> <span class=\"n\">Set.empty_subset</span> <span class=\"n\">Y</span><span class=\"o\">⟩</span>\n\n  <span class=\"bp\">·</span> <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">αₙ</span><span class=\"o\">,</span> <span class=\"n\">U₀'</span><span class=\"o\">,</span> <span class=\"n\">hαₙnotin</span><span class=\"o\">,</span> <span class=\"n\">hαₙinsert</span><span class=\"o\">,</span> <span class=\"n\">hU₀'card</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">Set.eq_insert_of_ncard_eq_succ</span> <span class=\"n\">h</span>\n    <span class=\"k\">have</span> <span class=\"n\">hαₙ</span> <span class=\"o\">:</span> <span class=\"n\">αₙ</span> <span class=\"bp\">∈</span> <span class=\"n\">U₀</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hαₙinsert</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">Set.mem_insert</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n    <span class=\"k\">have</span> <span class=\"n\">hαₙinsert_sub</span> <span class=\"o\">:</span> <span class=\"n\">insert</span> <span class=\"n\">αₙ</span> <span class=\"n\">U₀'</span> <span class=\"bp\">⊆</span> <span class=\"n\">U₀</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hαₙinsert</span><span class=\"o\">]</span>\n    <span class=\"k\">have</span> <span class=\"n\">hU₀'sub</span> <span class=\"o\">:</span> <span class=\"n\">U₀'</span> <span class=\"bp\">⊂</span> <span class=\"n\">U₀</span> <span class=\"o\">:=</span> <span class=\"n\">Set.ssubset_iff_insert.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">αₙ</span><span class=\"o\">,</span> <span class=\"n\">hαₙnotin</span><span class=\"o\">,</span> <span class=\"n\">hαₙinsert_sub</span><span class=\"o\">⟩</span>\n    <span class=\"k\">have</span> <span class=\"n\">hU₀'fin</span> <span class=\"o\">:</span> <span class=\"n\">Set.Finite</span> <span class=\"n\">U₀'</span> <span class=\"o\">:=</span> <span class=\"n\">Set.Finite.subset</span> <span class=\"n\">hU₀fin</span> <span class=\"n\">hU₀'sub.left</span>\n    <span class=\"k\">have</span> <span class=\"n\">map'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">α</span><span class=\"bp\">ᵢ</span> <span class=\"bp\">∈</span> <span class=\"n\">U₀'</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">Y</span><span class=\"bp\">ᵢ</span> <span class=\"bp\">∈</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">α</span><span class=\"bp\">ᵢ</span> <span class=\"bp\">∈</span> <span class=\"n\">Y</span><span class=\"bp\">ᵢ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intro</span> <span class=\"n\">α</span><span class=\"bp\">ᵢ</span> <span class=\"n\">hα</span><span class=\"bp\">ᵢ</span>\n      <span class=\"n\">exact</span> <span class=\"n\">map</span> <span class=\"n\">α</span><span class=\"bp\">ᵢ</span> <span class=\"o\">(</span><span class=\"n\">Set.mem_of_subset_of_mem</span> <span class=\"n\">hU₀'sub.left</span> <span class=\"n\">hα</span><span class=\"bp\">ᵢ</span><span class=\"o\">)</span>\n    <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">Y'</span><span class=\"o\">,</span> <span class=\"n\">hY'memK</span><span class=\"o\">,</span> <span class=\"n\">hY'sup</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">n_ih</span> <span class=\"n\">U₀'</span> <span class=\"n\">hU₀'fin</span> <span class=\"n\">map'</span> <span class=\"n\">hU₀'card</span>\n    <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">Yₙ</span><span class=\"o\">,</span> <span class=\"n\">hYₙmemK</span><span class=\"o\">,</span> <span class=\"n\">hαₙmemYₙ</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">map</span> <span class=\"n\">αₙ</span> <span class=\"n\">hαₙ</span>\n\n    <span class=\"n\">wlog</span> <span class=\"n\">hneq</span> <span class=\"o\">:</span> <span class=\"n\">Y'</span> <span class=\"bp\">≠</span> <span class=\"n\">Yₙ</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"n\">not_not</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hneq</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Exists.intro</span> <span class=\"n\">Y'</span>\n      <span class=\"n\">apply</span> <span class=\"n\">And.intro</span> <span class=\"n\">hY'memK</span>\n      <span class=\"n\">intro</span> <span class=\"n\">α</span><span class=\"bp\">ᵢ</span> <span class=\"n\">hα</span><span class=\"bp\">ᵢ</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hαₙinsert</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hα</span><span class=\"bp\">ᵢ</span>\n      <span class=\"k\">match</span> <span class=\"n\">hα</span><span class=\"bp\">ᵢ</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Or.inl</span> <span class=\"n\">hα</span><span class=\"bp\">ᵢ</span><span class=\"n\">eqαₙ</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hα</span><span class=\"bp\">ᵢ</span><span class=\"n\">eqαₙ</span><span class=\"o\">,</span> <span class=\"n\">hneq</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">hαₙmemYₙ</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Or.inr</span> <span class=\"n\">hα</span><span class=\"bp\">ᵢ</span><span class=\"n\">memU₀'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">hY'sup</span> <span class=\"n\">hα</span><span class=\"bp\">ᵢ</span><span class=\"n\">memU₀'</span>\n\n    <span class=\"n\">apply</span> <span class=\"n\">Or.elim</span> <span class=\"o\">(</span><span class=\"n\">hKc</span> <span class=\"n\">hY'memK</span> <span class=\"n\">hYₙmemK</span> <span class=\"n\">hneq</span><span class=\"o\">)</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hY'subYₙ</span>\n      <span class=\"k\">suffices</span> <span class=\"n\">hU₀subYₙ</span> <span class=\"o\">:</span> <span class=\"n\">U₀</span> <span class=\"bp\">⊆</span> <span class=\"n\">Yₙ</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">Yₙ</span><span class=\"o\">,</span> <span class=\"n\">hYₙmemK</span><span class=\"o\">,</span> <span class=\"n\">hU₀subYₙ</span><span class=\"o\">⟩</span>\n      <span class=\"n\">intro</span> <span class=\"n\">α</span><span class=\"bp\">ᵢ</span> <span class=\"n\">hα</span><span class=\"bp\">ᵢ</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hαₙinsert</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hα</span><span class=\"bp\">ᵢ</span>\n      <span class=\"k\">match</span> <span class=\"n\">hα</span><span class=\"bp\">ᵢ</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Or.inl</span> <span class=\"n\">hα</span><span class=\"bp\">ᵢ</span><span class=\"n\">eqαₙ</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hα</span><span class=\"bp\">ᵢ</span><span class=\"n\">eqαₙ</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">hαₙmemYₙ</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Or.inr</span> <span class=\"n\">hα</span><span class=\"bp\">ᵢ</span><span class=\"n\">memU₀'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">hY'subYₙ</span> <span class=\"o\">(</span><span class=\"n\">hY'sup</span> <span class=\"n\">hα</span><span class=\"bp\">ᵢ</span><span class=\"n\">memU₀'</span><span class=\"o\">)</span>\n\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hYₙsub</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Exists.intro</span> <span class=\"n\">Y'</span>\n      <span class=\"n\">apply</span> <span class=\"n\">And.intro</span> <span class=\"n\">hY'memK</span>\n      <span class=\"n\">intro</span> <span class=\"n\">α</span><span class=\"bp\">ᵢ</span> <span class=\"n\">hα</span><span class=\"bp\">ᵢ</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hαₙinsert</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hα</span><span class=\"bp\">ᵢ</span>\n      <span class=\"k\">match</span> <span class=\"n\">hα</span><span class=\"bp\">ᵢ</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Or.inl</span> <span class=\"n\">hα</span><span class=\"bp\">ᵢ</span><span class=\"n\">eqαₙ</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hα</span><span class=\"bp\">ᵢ</span><span class=\"n\">eqαₙ</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">hYₙsub</span> <span class=\"n\">hαₙmemYₙ</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Or.inr</span> <span class=\"n\">hα</span><span class=\"bp\">ᵢ</span><span class=\"n\">memU₀'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">hY'sup</span> <span class=\"n\">hα</span><span class=\"bp\">ᵢ</span><span class=\"n\">memU₀'</span>\n</code></pre></div>",
        "id": 416794575,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705676122
    },
    {
        "content": "<p>I get the feeling starting with <code>induction U₀, hU₀fin using Set.Finite.dinduction_on with</code> would make the proof shorter</p>",
        "id": 416802064,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705678216
    },
    {
        "content": "<p>Can you explain your intuition a bit? I'm not used to using induction tactics other than <code>induction</code> and <code>induction'</code></p>",
        "id": 416803328,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705678612
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">chain_fin_subset_max</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">hKne</span> <span class=\"o\">:</span> <span class=\"n\">Set.Nonempty</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hKc</span> <span class=\"o\">:</span> <span class=\"n\">IsChain</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">⊆</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">U₀</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hU₀fin</span> <span class=\"o\">:</span> <span class=\"n\">Set.Finite</span> <span class=\"n\">U₀</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"bp\">ᵢ</span> <span class=\"bp\">∈</span> <span class=\"n\">U₀</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">Y</span><span class=\"bp\">ᵢ</span> <span class=\"bp\">∈</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"bp\">ᵢ</span> <span class=\"bp\">∈</span> <span class=\"n\">Y</span><span class=\"bp\">ᵢ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">Y</span> <span class=\"bp\">∈</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">U₀</span> <span class=\"bp\">⊆</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">U₀</span><span class=\"o\">,</span> <span class=\"n\">hU₀fin</span> <span class=\"n\">using</span> <span class=\"n\">Set.Finite.dinduction_on</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">H0</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">hY</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hKne</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">hY</span><span class=\"o\">,</span> <span class=\"n\">Set.empty_subset</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">@</span><span class=\"n\">H1</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">ya</span><span class=\"o\">,</span> <span class=\"n\">hyak</span><span class=\"o\">,</span> <span class=\"n\">haya</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">map</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">Set.mem_insert</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"n\">hyk</span><span class=\"o\">,</span> <span class=\"n\">hsys</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ih</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">ha</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">map</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">Set.mem_insert_of_mem</span> <span class=\"n\">_</span> <span class=\"n\">ha</span><span class=\"o\">)</span>\n    <span class=\"n\">obtain</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">hne</span> <span class=\"o\">:=</span> <span class=\"n\">eq_or_ne</span> <span class=\"n\">ya</span> <span class=\"n\">ys</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">ya</span><span class=\"o\">,</span> <span class=\"n\">hyak</span><span class=\"o\">,</span> <span class=\"n\">Set.insert_subset</span> <span class=\"n\">haya</span> <span class=\"n\">hsys</span><span class=\"o\">⟩</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hKc</span> <span class=\"n\">hyk</span> <span class=\"n\">hyak</span> <span class=\"n\">hne.symm</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">ya</span><span class=\"o\">,</span> <span class=\"n\">hyak</span><span class=\"o\">,</span> <span class=\"n\">Set.insert_subset</span> <span class=\"n\">haya</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">hsys.trans</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n    <span class=\"bp\">|</span> <span class=\"n\">inr</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"n\">hyk</span><span class=\"o\">,</span> <span class=\"n\">Set.insert_subset</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">haya</span><span class=\"o\">)</span> <span class=\"n\">hsys</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 416803870,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705678765
    },
    {
        "content": "<p>The <code>induction</code> tactic lets you pass a custom induction principle</p>",
        "id": 416803948,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705678791
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite.dinduction_on#doc\">docs#Set.Finite.dinduction_on</a> is the one that say \"a finite set can be built by adding one element at a time\"</p>",
        "id": 416804028,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705678807
    },
    {
        "content": "<p>dang that is much shorter. I'll have to look at the tactic definition a bit to understand why it's a theorem that you can pass to <code>induction</code>. I guess, I'm unsure what counts as an \"induction principle\". Had I seen <code>Set.Finite.dinduction_on</code> earlier, I would have tried to use it directly with <code>apply</code>.</p>",
        "id": 416804974,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705679100
    },
    {
        "content": "<p>Also, can you explain your preference with <code>obtain</code> and <code>refine</code> instead of <code>have</code> and <code>exact</code> (in the cases where they can be used instead, aka not the <code>obtain rfl | hne</code> constructs).</p>",
        "id": 416806148,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705679451
    },
    {
        "content": "<p>I think that's just me being sloppy, and leaning on Lean3 muscle memory</p>",
        "id": 416807764,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705679937
    },
    {
        "content": "<p>Probably <code>refine</code> should give an error saying \"use exact instead\"</p>",
        "id": 416807894,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705679977
    },
    {
        "content": "<p>Got it. Thanks a ton :) Honestly super impressive to see such a short proof composed so quickly haha</p>",
        "id": 416808402,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705680115
    },
    {
        "content": "<p>Well, you already wrote down the mathematical ideas first, which made it much easier</p>",
        "id": 416809010,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705680232
    },
    {
        "content": "<p>Also, i'm trying to understand this section</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">obtain</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">hne</span> <span class=\"o\">:=</span> <span class=\"n\">eq_or_ne</span> <span class=\"n\">ya</span> <span class=\"n\">ys</span>\n<span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">ya</span><span class=\"o\">,</span> <span class=\"n\">hyak</span><span class=\"o\">,</span> <span class=\"n\">Set.insert_subset</span> <span class=\"n\">haya</span> <span class=\"n\">hsys</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>it seems equivalent to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">wlog</span> <span class=\"n\">hne</span> <span class=\"o\">:</span> <span class=\"n\">Yₙ</span> <span class=\"bp\">≠</span> <span class=\"n\">Y'</span>\n<span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"n\">not_not</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hne</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">Yₙ</span><span class=\"o\">,</span> <span class=\"n\">hYₙmemK</span><span class=\"o\">,</span> <span class=\"n\">Set.insert_subset</span> <span class=\"n\">hαₙmemYₙ</span> <span class=\"o\">(</span><span class=\"n\">hne</span> <span class=\"bp\">▸</span> <span class=\"n\">hY'sup</span><span class=\"o\">)⟩</span>\n</code></pre></div>\n<p>But I can't seem to wrap my head around what <code>rfl</code> is being applied to, or what kind of pattern <code>rfl | hne</code> is.</p>\n<p>(sorry for the slightly renamed variables in my version)</p>",
        "id": 416810906,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705680547
    },
    {
        "content": "<p><code>obtain rfl | hne := eq_or_ne ya ys</code> is the same as <code>obtain heq | hne := eq_or_ne ya ys</code>, then <code>subst heq</code> on the branch that uses it</p>",
        "id": 416813282,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705681006
    },
    {
        "content": "<p>The pattern is matching against the <code>or</code>, and <code>rfl</code> is matching against the equality</p>",
        "id": 416813378,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705681032
    },
    {
        "content": "<p>I've not seen <code>wlog</code> used in that way before, but my spelling avoids the annoying <code>Not (Ne _ _)</code> that appears in yours</p>",
        "id": 416813476,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705681061
    },
    {
        "content": "<p>yeah absolutely, don't like the <code>rw</code> needed to transform the negative <code>¬ (Yₙ ≠ Y')</code>. Oh, <code>rfl</code> from the equality makes a bit more sense, thanks.</p>\n<p>Hmm I'll have to reread that a few times. I might try expanding the <code>obtains</code> to <code>rcases</code>, and see if I understand that better.</p>",
        "id": 416813804,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705681150
    },
    {
        "content": "<p>Oh I see this from the <a href=\"https://leanprover-community.github.io/mathlib4_docs/Std/Tactic/RCases.html#Std.Tactic.obtain\"><code>rcases docs</code></a>:</p>\n<blockquote>\n<p>The keyword <code>rfl</code>, which expects the hypothesis to be <code>h : a = b</code>, and calls <code>subst</code> on the hypothesis (which has the effect of replacing <code>b</code> with <code>a</code> everywhere or vice versa).</p>\n</blockquote>",
        "id": 416814861,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705681415
    },
    {
        "content": "<p><code>obtain $patt := $val</code> is pretty much identical to<code>rcases $val with $patt</code></p>",
        "id": 416817623,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705682088
    },
    {
        "content": "<p>So I doubt you will learn anything by rewriting <code>obtain</code> to <code>rcases</code> <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 416817721,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705682104
    },
    {
        "content": "<p>Yeah it's just weird (to me) to see the <code>patt</code> and <code>val</code> swap places, but yeah it's not that much insight... I think what really cleared it up is the fact that <code>rfl</code> is special grammar, and applies the equality to all of the hypotheses, and that two goals are created. Pretty clever</p>",
        "id": 416818947,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705682389
    }
]