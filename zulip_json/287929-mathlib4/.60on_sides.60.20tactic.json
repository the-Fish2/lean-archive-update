[
    {
        "content": "<p>Picking up from <a href=\"#narrow/stream/287929-mathlib4/topic/linting.20against.20.22multi-goal.20proofs.22/near/434777231\">this message</a>, here is a potential implementation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Elab.Tactic.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Convert</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span>\n\n<span class=\"n\">syntax</span> <span class=\"n\">tactic</span> <span class=\"s2\">\" using\"</span> <span class=\"n\">colGt</span> <span class=\"n\">tacticSeq</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">tac</span><span class=\"o\">:</span><span class=\"n\">tactic</span> <span class=\"n\">using</span> <span class=\"bp\">$</span><span class=\"n\">disch</span><span class=\"o\">:</span><span class=\"n\">tacticSeq</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">withMainContext</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">tag</span> <span class=\"bp\">←</span> <span class=\"n\">getMainTag</span>\n  <span class=\"n\">evalTactic</span> <span class=\"n\">tac</span>\n  <span class=\"k\">let</span> <span class=\"n\">mctx</span> <span class=\"bp\">←</span> <span class=\"n\">getMCtx</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">old</span><span class=\"o\">,</span> <span class=\"n\">sides</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getGoals</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">partition</span> <span class=\"k\">fun</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">decl</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">mctx.decls.find</span><span class=\"bp\">?</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getD</span> <span class=\"n\">default</span>\n    <span class=\"n\">tag</span> <span class=\"bp\">==</span> <span class=\"n\">decl.userName</span>\n  <span class=\"n\">setGoals</span> <span class=\"n\">sides</span>\n  <span class=\"n\">evalTactic</span> <span class=\"n\">disch</span>\n  <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getGoals</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">setGoals</span> <span class=\"n\">old</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwErrorAt</span> <span class=\"n\">disch</span> <span class=\"s2\">\"1 side goal is not yet solved!\"</span>\n    <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwErrorAt</span> <span class=\"n\">disch</span> <span class=\"s2\">\"{n} side goals are not yet solved!\"</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Tactic</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">silly</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.add_zero</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hmn</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn0</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hm0</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">silly</span><span class=\"o\">,</span> <span class=\"n\">silly</span><span class=\"o\">]</span> <span class=\"n\">using</span>\n    <span class=\"n\">all_goals</span> <span class=\"n\">assumption</span>\n  <span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 434803235,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713805895
    },
    {
        "content": "<p>Btw, in the other thread I said that the initial tactic could in fact be a tacticSeq: in the current implementation of <code>on_sides</code>, replacing the first <code>tactic</code> by <code>tacticSeq</code> actually crashes Lean.</p>",
        "id": 434806750,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713806974
    },
    {
        "content": "<p>I like this up to naming/syntax! :) (Of course this is proof-of-concept, but I’ll mention while I’m thinking about it that in a rigorous version we’d probably also want to (1) have good error messages if the side goals were not solved (2) make sure not to collect pre-existing side goals under this tactic (3) reset the goals at the end. Also maybe an empty discharger tactic sequence should error?)</p>\n<p>As for syntax/naming, here’s fun <del>unfortunately impossible</del> (entirely possible!) syntax:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">]</span>\n  <span class=\"bp\">╰</span> <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"mi\">0</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 434811791,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1713808570
    },
    {
        "content": "<p>Very neat the <del>im</del>possible syntax!</p>\n<p>Also, yes, the implementation above was quickly hacked up, mostly to help declutter the conversation on the linter in the other thread!  <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 434812635,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713808864
    },
    {
        "content": "<p>Btw, I used <code>on_sides</code> instead of <code>using</code> since I was worried of interactions with <code>convert ... using ...</code> and <code>simpa ... using ...</code>.</p>",
        "id": 434813203,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713809047
    },
    {
        "content": "<p>Can this work properly without help of the initial tactic? I’d assume that only <code>rw</code> knows reliably whether the last goal is a side condition (because <code>rfl</code> solved the main goal) or not.</p>",
        "id": 434816491,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713809564
    },
    {
        "content": "<p>I think that it should already work with tactics other than <code>rw</code>.</p>",
        "id": 434816698,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713809644
    },
    {
        "content": "<p>Are there other tactics that have a clear separation between side-conditions and left-over goals? <br>\nI can think of <code>have</code> and <code>suffice</code>, in a way…</p>",
        "id": 434816705,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713809647
    },
    {
        "content": "<p>I'm on a plane now, though...</p>",
        "id": 434816713,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713809651
    },
    {
        "content": "<p>No rush :-)</p>\n<p>I believe that your code does what it tries to do with any tactic. I just wonder if it will always do what it should do :-)<br>\nMaybe goal names are indeed sufficient.</p>",
        "id": 434816726,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713809657
    },
    {
        "content": "<p>I wonder if the TacticM state ought to have a secondary list of \"side goals\" that tactics can append to? Then you could wait until you want to deal with <em>all</em> of them at the end of some block.</p>\n<p>There could be a <code>defer</code> tactic that moves the current goal to the list of side goals. Maybe collections of side goals can be deferred to outside the current tactic block, and this is how goals can be threaded out through tactic blocks to deal with them later? (Yes yes, I know I need to read up on Procrastination. I still have a tab open with <a href=\"https://armael.github.io/coq-procrastination/manual/manual.pdf\">the manual</a>.)</p>",
        "id": 434819576,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713810670
    },
    {
        "content": "<p>By the way, here's a first pass at the syntax, though I'm not sure I've invoked the \"right\" pretty-printing no-ops:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Parser</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">onSideGoalsTk</span> <span class=\"o\">:=</span> <span class=\"n\">unicodeSymbol</span> <span class=\"s2\">\"- \"</span> <span class=\"s2\">\"╰ \"</span>\n<span class=\"c1\">-- What's a good ASCII equivalent of \"╰ \"?</span>\n<span class=\"c1\">-- Ideas: \"- \", \"`-\", \"` \", \"^ \", \"\\ \", \"L \"...</span>\n<span class=\"c1\">-- This would ideally become the (a) keyboard shortcut for `╰ ` too.</span>\n\n<span class=\"c1\">-- Enforce a line break and demand we start at the same column.</span>\n<span class=\"c1\">-- Note: `tacticSeqIndentGt` is what `·` uses.</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">onSideGoals</span><span class=\"o\">)</span> <span class=\"n\">tactic</span> <span class=\"n\">linebreak</span> <span class=\"n\">colEq</span>\n  <span class=\"n\">ppDedent</span><span class=\"o\">(</span><span class=\"n\">ppLine</span> <span class=\"n\">ppGroup</span><span class=\"o\">(</span><span class=\"n\">onSideGoalsTk</span> <span class=\"n\">tacticSeqIndentGt</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">linter.unusedVariables</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span>\n    <span class=\"bp\">$</span><span class=\"n\">tac</span><span class=\"o\">:</span><span class=\"n\">tactic</span>\n    <span class=\"bp\">╰</span> <span class=\"bp\">$</span><span class=\"n\">tacs</span><span class=\"o\">:</span><span class=\"n\">tacticSeq</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"c1\">-- Log info if we want to see what was parsed, but otherwise `skip`:</span>\n    <span class=\"c1\">-- logInfoAt tac m!\"{tac} &gt; {tacs}\"</span>\n    <span class=\"n\">pure</span> <span class=\"o\">()</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"bp\">=</span> <span class=\"n\">True</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">]</span>\n  <span class=\"bp\">╰</span> <span class=\"n\">exact</span> <span class=\"mi\">1</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">]</span>\n  <span class=\"bp\">╰</span> <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"mi\">1</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"mi\">2</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h2</span><span class=\"o\">]</span>\n  <span class=\"bp\">╰</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">]</span>\n    <span class=\"bp\">╰</span> <span class=\"n\">exact</span> <span class=\"mi\">3</span>\n\n<span class=\"c1\">-- Note: superfluous pretty-printed newline in last case still to work out.</span>\n<span class=\"k\">#eval</span> <span class=\"n\">PrettyPrinter.ppCategory</span> <span class=\"bp\">`</span><span class=\"n\">tactic</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Lean.Unhygienic.run</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"bp\">|</span><span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">]</span>\n  <span class=\"bp\">╰</span> <span class=\"n\">exact</span> <span class=\"mi\">1</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">]</span>\n  <span class=\"bp\">╰</span> <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"mi\">1</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"mi\">2</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h2</span><span class=\"o\">]</span>\n  <span class=\"bp\">╰</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">]</span>\n    <span class=\"bp\">╰</span> <span class=\"n\">exact</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n</code></pre></div>\n</div></div>",
        "id": 434830872,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1713814435
    },
    {
        "content": "<p>This seems like a good example of something that should genuinely be in core, but I'm curious how hard it is to build this \"<code>tactic</code> with extra state\" environment on top of the builtin <code>TacticM</code>.</p>",
        "id": 434834804,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713815789
    },
    {
        "content": "<p>So pretty!</p>",
        "id": 434840872,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713818113
    },
    {
        "content": "<p>(Btw, my code above does not actually work: I intended to use the <code>tag</code> of the main goal, but I used the <code>name</code>!  <span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span> </p>\n<p>As soon as I'm home, I'll update it with the \"correct\" one.)</p>",
        "id": 434842760,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713818756
    },
    {
        "content": "<p>[I updated the code above: I know that relying on <code>tag</code>s is not especially robust, but it was mostly to get something working!]</p>",
        "id": 434854040,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713822847
    },
    {
        "content": "<p>I think the <code>tag</code> is a fairly reasonable heuristic given the current infrastructure, given that most tactics will preserve the name on the main goal (I think?) if it's meant to be \"the same\", and I don't think we have much else to link old mvars to new ones.</p>\n<p>One issue might be that the tag is generally <code>.anonymous</code>; a refinement for an \"official\" version (of course, I realize this is the quick one! :) ) might involve renaming goal if it's <code>.anonymous</code> before evaluating the tactic, then resetting it if it got \"passed through\".</p>",
        "id": 434861406,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1713825648
    },
    {
        "content": "<p>(As far as I know, we have <code>FVarAlias</code>es, but nothing like <code>MVarAlias</code>es, right?)</p>",
        "id": 434861415,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1713825651
    },
    {
        "content": "<p>I think that you are right.  When I was writing the linter to prevent \"rigid\" tactics to follow \"flexible\" ones, I had to work quite a bit to track <code>MVarId</code>s around and identify which ones became which other ones.</p>",
        "id": 434861760,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713825771
    },
    {
        "content": "<p>(For completeness, another option is checking if we assigned the metavariable directly to another metavariable, but I'd worry this wouldn't cover all cases where we want to consider the new main goal the \"same\" goal...you probably have more experience with this in practice than me, though! :) )</p>",
        "id": 434862013,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1713825843
    },
    {
        "content": "<p>I think that I would leave this as is for the moment, and see how it performs in practice.  The tracking of <code>MVarId</code>s appears to work correctly almost out of the box: the whole MetavarContext seems to be already structured to track <code>MVarId</code>s, but there is no actual API around it.</p>",
        "id": 434862393,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713825980
    },
    {
        "content": "<p>The only thing that is slightly tricky is that you cannot rely on the <code>name</code> of an <code>MVarId</code>, but since they are created along a DAG, it is usually straightforward to figure out which one became which other one.</p>",
        "id": 434862605,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713826063
    },
    {
        "content": "<p>(Also, the tactics that are present in mathlib rarely do \"crazy\" things with metavars: they are usually fairly straightforward and they either act on a single goal or they permute them around.)</p>",
        "id": 434862824,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713826165
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60on_sides.60.20tactic/near/434819576\">said</a>:</p>\n<blockquote>\n<p>I wonder if the TacticM state ought to have a secondary list of \"side goals\" that tactics can append to? Then you could wait until you want to deal with <em>all</em> of them at the end of some block.</p>\n<p>There could be a <code>defer</code> tactic that moves the current goal to the list of side goals. Maybe collections of side goals can be deferred to outside the current tactic block, and this is how goals can be threaded out through tactic blocks to deal with them later?</p>\n</blockquote>\n<p>Such a <code>defer</code> tactic could be useful if you have a <code>calc</code> block for clarity/robustness, but want to solve the individual steps after the block, maybe even with <code>alll_goals</code> using some automation. Then just write <code>:= defer</code> everywhere and prove them later. (Or maybe <code>calc</code> could allow you to omit <code>:=</code> and then just leave these obligations as goals afterwards; that would work even now. Not crucial, but maybe nice sometimes.)</p>",
        "id": 437208088,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1714980236
    },
    {
        "content": "<p>You can already do <code>:= ?_</code>. But having the option of being more explicit about the intention could be nice.</p>",
        "id": 437223493,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1714986692
    }
]