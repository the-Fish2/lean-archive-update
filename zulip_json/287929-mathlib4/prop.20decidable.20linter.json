[
    {
        "content": "<p>I encountered some lemmas that use <code>Classical.PropDecidable</code> in their type instead of properly assuming decidability assumptions, e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=contDiff_update#doc\">docs#contDiff_update</a> (which - of course - I added myself).<br>\nTherefore I wrote a simple linter on <a href=\"https://github.com/leanprover-community/mathlib4/tree/fvd%2Fillegalpropdec\">branch#fvd/illegalpropdec</a> to find such theorems. The output on Mathlib is here:<br>\n<a href=\"https://gist.github.com/fpvandoorn/05cca028139e98bded9874169a1332d5\">https://gist.github.com/fpvandoorn/05cca028139e98bded9874169a1332d5</a><br>\nThere are probably false positives. E.g. assuming that <code>ℝ</code>  has decidable equality using <code>Classical.PropDecidable</code> is fine, assuming that a variable type has decidable equality is almost never fine.<br>\nIs someone willing to go through the list of the Gist and fix all theorems that need fixing. I might not have time for it myself in the near future.</p>",
        "id": 424101789,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709238326
    },
    {
        "content": "<blockquote>\n<p>assuming that <code>ℝ</code> has decidable equality using <code>Classical.PropDecidable</code> is fine</p>\n</blockquote>\n<p>Why? Is the distinction that <code>ℝ</code> is a concrete type that we know cannot have a computable <code>DecidableEq</code> instance? Why isn't there then an instance <code>DecidableEq ℝ := Classical.propDecidable</code>?</p>",
        "id": 424102677,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709238677
    },
    {
        "content": "<p>I will start going through the gist!</p>",
        "id": 424102872,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709238742
    },
    {
        "content": "<p>Yes, for fixed types it is fine. The problem is when instantiating variables in lemmas to types that suddenly do have decidable equality.<br>\nAnd the Real was just an example (and it turns out a bad one). In fact this instance does exist: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Real.decidableEq#doc\">docs#Real.decidableEq</a>.</p>",
        "id": 424102988,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709238789
    },
    {
        "content": "<p>Where should I record false positives for improving the lint?</p>",
        "id": 424103913,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709239123
    },
    {
        "content": "<p>You can do it in a comment here.</p>",
        "id": 424104833,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709239488
    },
    {
        "content": "<p>And thanks for doing this!</p>",
        "id": 424104868,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709239505
    },
    {
        "content": "<p>Or feel free to push <code>nolint</code> attributes to the linter branch. If you think that the linter can be improved to automatically recognize false positives, you can discuss that here (or improve the linter yourself :-) )</p>",
        "id": 424105349,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709239705
    },
    {
        "content": "<p>False positive:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Error</span><span class=\"o\">:</span> <span class=\"bp\">./././</span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Algebra</span><span class=\"bp\">/</span><span class=\"n\">DirectLimit.lean</span><span class=\"o\">:</span><span class=\"mi\">708</span><span class=\"o\">:</span><span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">Ring.DirectLimit.of.zero_exact_aux.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"kd\">theorem</span> <span class=\"n\">statement</span> <span class=\"n\">contains</span> <span class=\"bp\">`</span><span class=\"n\">Classical.propDecidable</span><span class=\"bp\">`.</span>\n</code></pre></div>\n<p>The missing decidable instance is <code>[DecidablePred (· ∈ s)]</code> where <code>s</code> is an existential variable in the conclusion.</p>",
        "id": 424106588,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709240161
    },
    {
        "content": "<p>False positives:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Error</span><span class=\"o\">:</span> <span class=\"bp\">./././</span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Algebra</span><span class=\"bp\">/</span><span class=\"n\">BigOperators</span><span class=\"bp\">/</span><span class=\"n\">Finprod.lean</span><span class=\"o\">:</span><span class=\"mi\">94</span><span class=\"o\">:</span><span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">finsum_def'.</span><span class=\"o\">{</span><span class=\"n\">u_8</span><span class=\"o\">,</span> <span class=\"n\">u_7</span><span class=\"o\">}</span> <span class=\"kd\">theorem</span> <span class=\"n\">statement</span> <span class=\"n\">contains</span> <span class=\"bp\">`</span><span class=\"n\">Classical.propDecidable</span><span class=\"bp\">`.</span>\n<span class=\"n\">Error</span><span class=\"o\">:</span> <span class=\"bp\">./././</span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Algebra</span><span class=\"bp\">/</span><span class=\"n\">BigOperators</span><span class=\"bp\">/</span><span class=\"n\">Finprod.lean</span><span class=\"o\">:</span><span class=\"mi\">100</span><span class=\"o\">:</span><span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">finprod_def'.</span><span class=\"o\">{</span><span class=\"n\">u_8</span><span class=\"o\">,</span> <span class=\"n\">u_7</span><span class=\"o\">}</span> <span class=\"kd\">theorem</span> <span class=\"n\">statement</span> <span class=\"n\">contains</span> <span class=\"bp\">`</span><span class=\"n\">Classical.propDecidable</span><span class=\"bp\">`.</span>\n</code></pre></div>\n<p>The <code>Classical.propDecidable</code> is occurring as the body of a definition, which is allowed, and then occurs in the statement of an <code>irreducible_def</code> definitional lemma, which seems unavoidable.</p>",
        "id": 424107531,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709240504
    },
    {
        "content": "<blockquote>\n<p>The missing decidable instance is [DecidablePred (· ∈ s)] where s is an existential variable in the conclusion.</p>\n</blockquote>\n<p>Ohh actually I think this is a true positive. The correct fix is to change <code>\\ex s, ...</code> to <code>\\ex s, \\forall [DecidablePred (. \\in s)], ...</code></p>",
        "id": 424108955,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709241030
    },
    {
        "content": "<p>Autogenerated by <code>@[simps]</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Mathlib.Algebra.Homology.DifferentialObject</span>\n<span class=\"n\">Error</span><span class=\"o\">:</span> <span class=\"bp\">./././</span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Algebra</span><span class=\"bp\">/</span><span class=\"n\">Homology</span><span class=\"bp\">/</span><span class=\"n\">DifferentialObject.lean</span><span class=\"o\">:</span><span class=\"mi\">88</span><span class=\"o\">:</span><span class=\"mi\">3</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">HomologicalComplex.dgoToHomologicalComplex_obj_d.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">,</span> <span class=\"n\">u_1</span><span class=\"o\">,</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"kd\">theorem</span> <span class=\"n\">statement</span> <span class=\"n\">contains</span> <span class=\"bp\">`</span><span class=\"n\">Classical.propDecidable</span><span class=\"bp\">`.</span>\n<span class=\"n\">Error</span><span class=\"o\">:</span> <span class=\"bp\">./././</span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Algebra</span><span class=\"bp\">/</span><span class=\"n\">Homology</span><span class=\"bp\">/</span><span class=\"n\">DifferentialObject.lean</span><span class=\"o\">:</span><span class=\"mi\">88</span><span class=\"o\">:</span><span class=\"mi\">3</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">HomologicalComplex.dgoToHomologicalComplex_map_f.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">,</span> <span class=\"n\">u_1</span><span class=\"o\">,</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"kd\">theorem</span> <span class=\"n\">statement</span> <span class=\"n\">contains</span> <span class=\"bp\">`</span><span class=\"n\">Classical.propDecidable</span><span class=\"bp\">`.</span>\n</code></pre></div>\n<p>Not necessarily a false positive, but it seems like way too big a pain to manually write the generated lemmas so I'm gonna hope we can improve <code>@[simps]</code> instead.</p>",
        "id": 424116270,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709243986
    },
    {
        "content": "<p>Is this related to Yury's <a href=\"https://github.com/leanprover-community/mathlib4/pull/10235\">#10235</a> as well?</p>",
        "id": 424122349,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1709246572
    },
    {
        "content": "<p>Yes, but that is the opposite linter. Each of these two linters checks one implication of<br>\n\"A decidable hypothesis should be part of a theorem if and only if that hypothesis is used in the type of the theorem\"</p>",
        "id": 424138170,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709254848
    },
    {
        "content": "<p>Why does <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniqueFactorizationMonoid.factors#doc\">docs#UniqueFactorizationMonoid.factors</a> take a <code>DecidableEq</code> instance when its definition uses <code>Classical.choice</code> anyway?</p>",
        "id": 424147655,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709258778
    },
    {
        "content": "<p>Here is an example of the kind of false positive you were predicting: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=isInternal_prime_power_torsion_of_is_torsion_by_ideal#doc\">docs#isInternal_prime_power_torsion_of_is_torsion_by_ideal</a> uses <code>factors</code> and <code>Multiset.toFinset</code> on <code>Multiset (Ideal R)</code>, so uses classical for <code>DecidableEq (Ideal R)</code>. <code>Ideal R</code> contains <code>Set R</code>, so can only have computable decidable equality if <code>Empty R</code>. I wonder if there should be an instance of <code>[Nonempty R] : DecidableEq (Set R)</code> or at least <code>DecidableEq (Ideal R)</code> for the canonical noncomputable instance. It would silence this linter, but I don't know if it has a lot of precedent in the library or if there's downsides to making such instances.</p>",
        "id": 424152226,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709262072
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"500038\">Timo Carlin-Burns</span> <a href=\"#narrow/stream/287929-mathlib4/topic/prop.20decidable.20linter/near/424147655\">said</a>:</p>\n<blockquote>\n<p>Why does <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniqueFactorizationMonoid.factors#doc\">docs#UniqueFactorizationMonoid.factors</a> take a <code>DecidableEq</code> instance when its definition uses <code>Classical.choice</code> anyway?</p>\n</blockquote>\n<p>There are quite a few matches my linter finds in that file because of these design decisions. IMHO, we should refactor this file but I had no time to do this.</p>",
        "id": 424174005,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1709278498
    },
    {
        "content": "<p>Timo, thanks for your work on this. I'd have to think how we avoid some of these false positives in the linter. But hopefully you also found some true positives, and if you could make a PR with those, that would be really great!</p>",
        "id": 424697055,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709569975
    },
    {
        "content": "<p>PR fixing a few true positives: <a href=\"https://github.com/leanprover-community/mathlib4/pull/11157\">#11157</a></p>",
        "id": 424744233,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709585213
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/287929-mathlib4/topic/prop.20decidable.20linter/near/424174005\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"500038\">Timo Carlin-Burns</span> <a href=\"#narrow/stream/287929-mathlib4/topic/prop.20decidable.20linter/near/424147655\">said</a>:</p>\n<blockquote>\n<p>Why does <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniqueFactorizationMonoid.factors#doc\">docs#UniqueFactorizationMonoid.factors</a> take a <code>DecidableEq</code> instance when its definition uses <code>Classical.choice</code> anyway?</p>\n</blockquote>\n<p>There are quite a few matches my linter finds in that file because of these design decisions. IMHO, we should refactor this file but I had no time to do this.</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/11158\">#11158</a></p>",
        "id": 424744322,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709585246
    }
]