[
    {
        "content": "<p>I recently ran once again into the hell that is function coercion for bundled maps. While <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> 's idea to fix this seems to be 'get rid of FunLike and SetLike` my idea was to use even more classes (in particular define operations on functions/sets using classes). Example is here: <a href=\"https://gist.github.com/mcdoll/0060646e3f6a413f3401cf9f62e3afe5\">https://gist.github.com/mcdoll/0060646e3f6a413f3401cf9f62e3afe5</a><br>\nIt is clear that this design immediately loses dot-notation and I have no idea whether performance would be an issue.<br>\nI am very much not an expert on these things, so there might be a very obvious reason why this idea is a bad idea.</p>\n<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> (congrats on the PhD) <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> </p>\n<p>Yury's proposal: <a href=\"#narrow/stream/287929-mathlib4/topic/RFC.3A.20bundled.20sets.20.236442\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/RFC.3A.20bundled.20sets.20.236442</a></p>",
        "id": 418995348,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1706692399
    },
    {
        "content": "<p>I tried a similar approach with functions in Lean 3. It didn't work but this is <strong>not an argument</strong> because typeclasses work differently in Lean 4.</p>",
        "id": 418995668,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706692543
    },
    {
        "content": "<p>Do you remember what exactly did not work?</p>",
        "id": 418996828,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1706692955
    },
    {
        "content": "<p>I don't remember, Lean failed to find some instances. But you can try with Lean 4.</p>",
        "id": 418996949,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706693003
    },
    {
        "content": "<p>Also, we had way too many <code>FunLike</code> superclasses back then.</p>",
        "id": 418996997,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706693022
    },
    {
        "content": "<p>In my example code all instances are found without any problems</p>",
        "id": 418997120,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1706693060
    },
    {
        "content": "<p>An obvious con of your approach is that we can no longer define generic functions (e.g., <code>Submonoid M → Subsemigroup M</code>)</p>",
        "id": 418997303,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706693125
    },
    {
        "content": "<p>But I don't know if this is an issue.</p>",
        "id": 418997435,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706693163
    },
    {
        "content": "<p>There is a funny thing happening: all the operators lose definitional equality, but retain proposition equality. A priori <code>[Inter S1 S2 S3 M]</code> and <code>[Inter S2 S1 S3 M]</code> give two different intersections if <code>S1 = S2</code>, but of course they are propositonally equal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.SetLike.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Basic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Zulip</span>\n\n<span class=\"sd\">/-- `a ∩ₛ b` is the intersection of `a` and `b`. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">Inter</span> <span class=\"o\">(</span><span class=\"n\">S1</span> <span class=\"n\">S2</span> <span class=\"n\">S3</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">SetLike</span> <span class=\"n\">S1</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SetLike</span> <span class=\"n\">S2</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SetLike</span> <span class=\"n\">S3</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">inter</span> <span class=\"o\">:</span> <span class=\"n\">S1</span> <span class=\"bp\">→</span> <span class=\"n\">S2</span> <span class=\"bp\">→</span> <span class=\"n\">S3</span>\n  <span class=\"n\">inter_coe</span> <span class=\"o\">(</span><span class=\"n\">s1</span> <span class=\"o\">:</span> <span class=\"n\">S1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s2</span> <span class=\"o\">:</span> <span class=\"n\">S2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">inter</span> <span class=\"n\">s1</span> <span class=\"n\">s2</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">s1</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">s2</span>\n\n<span class=\"sd\">/-- `a ∩ₛ b` is the intersection of `a` and `b`. -/</span>\n<span class=\"kd\">infixl</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"s2\">\" ∩ₛ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Inter.inter</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"n\">S1</span> <span class=\"n\">S2</span> <span class=\"n\">S3</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">SetLike</span> <span class=\"n\">S1</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SetLike</span> <span class=\"n\">S2</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SetLike</span> <span class=\"n\">S3</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Inter</span> <span class=\"n\">S1</span> <span class=\"n\">S2</span> <span class=\"n\">S3</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Inter</span> <span class=\"n\">S2</span> <span class=\"n\">S1</span> <span class=\"n\">S3</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">inter_comm</span> <span class=\"o\">(</span><span class=\"n\">s1</span> <span class=\"o\">:</span> <span class=\"n\">S1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s2</span> <span class=\"o\">:</span> <span class=\"n\">S2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s1</span> <span class=\"bp\">∩ₛ</span> <span class=\"n\">s2</span> <span class=\"o\">:</span> <span class=\"n\">S3</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s2</span> <span class=\"bp\">∩ₛ</span> <span class=\"n\">s1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">SetLike.coe_injective</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Inter.inter_coe</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Set.inter_comm</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 419021332,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1706701164
    },
    {
        "content": "<p>and I start to see why it does not work with Lean3</p>",
        "id": 419021584,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1706701263
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">i1</span> <span class=\"o\">:</span> <span class=\"n\">Inter</span> <span class=\"n\">S1</span> <span class=\"n\">S2</span> <span class=\"n\">S3</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">i2</span> <span class=\"o\">:</span> <span class=\"n\">Inter</span> <span class=\"n\">S1</span> <span class=\"n\">S2</span> <span class=\"n\">S3</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">inter_eq</span> <span class=\"o\">(</span><span class=\"n\">s1</span> <span class=\"o\">:</span> <span class=\"n\">S1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s2</span> <span class=\"o\">:</span> <span class=\"n\">S2</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Inter.inter</span> <span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:=</span> <span class=\"n\">i1</span><span class=\"o\">)</span> <span class=\"n\">s1</span> <span class=\"n\">s2</span> <span class=\"bp\">=</span> <span class=\"n\">Inter.inter</span> <span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:=</span> <span class=\"n\">i2</span><span class=\"o\">)</span> <span class=\"n\">s1</span> <span class=\"n\">s2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">SetLike.coe_injective</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Inter.inter_coe</span> <span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:=</span> <span class=\"n\">i1</span><span class=\"o\">),</span> <span class=\"n\">Inter.inter_coe</span> <span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:=</span> <span class=\"n\">i2</span><span class=\"o\">)]</span>\n</code></pre></div>",
        "id": 419022546,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1706701693
    },
    {
        "content": "<p><span aria-label=\"ping pong\" class=\"emoji emoji-1f3d3\" role=\"img\" title=\"ping pong\">:ping_pong:</span></p>",
        "id": 420468872,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1707402300
    },
    {
        "content": "<p>I mentioned both <a href=\"#narrow/stream/287929-mathlib4/topic/RFC.3A.20bundled.20sets.20.236442\">my</a> and your approach in my talk yesterday. Didn't work to attract attention.</p>",
        "id": 420496428,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707410110
    },
    {
        "content": "<p>Thanks for trying to push this forward! It's on my todo list to make this happen, and I'm reserving time next week to try this out and write up my experiences.</p>",
        "id": 420663535,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1707489083
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz Doll</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Bundled.20sets.2Ffunctions.20with.20even.20more.20classes/near/418995348\">said</a>:</p>\n<blockquote>\n<p>I recently ran once again into the hell that is function coercion for bundled maps. While <span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> 's idea to fix this seems to be 'get rid of FunLike and SetLike` my idea was to use even more classes (in particular define operations on functions/sets using classes). Example is here: <a href=\"https://gist.github.com/mcdoll/0060646e3f6a413f3401cf9f62e3afe5\">https://gist.github.com/mcdoll/0060646e3f6a413f3401cf9f62e3afe5</a><br>\nIt is clear that this design immediately loses dot-notation and I have no idea whether performance would be an issue.<br>\nI am very much not an expert on these things, so there might be a very obvious reason why this idea is a bad idea.</p>\n</blockquote>\n<p>I think we should see this as a gradual process rather than an all in one refactor. Here's how I see the steps:</p>\n<ul>\n<li>Current <code>SetLike</code> setup.</li>\n<li>Define a highly parametrized <code>Inter</code> class (Only in <span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span>'s proposal. Should be totally independent from what follows, although defining instances would be a hassle).</li>\n<li>Separating out <code>Is___Mem</code> predicates from the current bundled structures.</li>\n<li>Separating out <code>Is___Mem</code> predicates from the current bundled classes. (Not done in <span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span>'s proposal; unnecessary in <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>'s proposal.)</li>\n<li>Using the typeclass system to infer relations between the <code>Is___Mem</code> predicates. (Only in <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>'s proposal.)</li>\n<li>Replacing all traces of <code>SetLike</code> with the bundled approach.</li>\n</ul>",
        "id": 421284443,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1707842873
    },
    {
        "content": "<p>Going all out from <code>SetLike</code> to <code>BundledSet</code> would be an enormous headache, from my experience of originally setting up <code>SetLike</code>.</p>",
        "id": 421284602,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1707842921
    },
    {
        "content": "<p>Do you have opinion about which proposal should we aim for?</p>",
        "id": 421297983,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707847620
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Bundled.20sets.2Ffunctions.20with.20even.20more.20classes/near/421284443\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Separating out <code>Is___Mem</code> predicates from the current bundled classes. (Not done in <span class=\"user-mention silent\" data-user-id=\"412682\">Moritz Doll</span>'s proposal; unnecessary in <span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span>'s proposal.)</li>\n</ul>\n</blockquote>\n<p>I tried that and it was quite messy, I ran into problems unifying</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">IsOneMem</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"mi\">1</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">IsOneMem'</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SetLike</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">OneMemClass</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"kd\">extends</span> <span class=\"n\">SetLike</span> <span class=\"n\">S</span> <span class=\"n\">M</span> <span class=\"n\">where</span>\n  <span class=\"n\">one_mem</span> <span class=\"o\">:</span> <span class=\"n\">IsOneMem'</span> <span class=\"n\">M</span> <span class=\"n\">S</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">OneMem</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">M</span>\n  <span class=\"n\">one_mem'</span> <span class=\"o\">:</span> <span class=\"n\">IsOneMem</span> <span class=\"n\">carrier</span>\n</code></pre></div>\n<p>The problem is that one is <code>A -&gt; Prop</code> and the other one is <code>Prop</code>.</p>",
        "id": 421350076,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1707871458
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> is moving theorems from <code>FoobarMap</code> to <code>FoobarMapClass</code> a good idea at the moment? I continue to run into these problems where a theorem is stated for <code>a : FoobarMap</code>, but my use case is either a type synonym or a more specialized type. At the moment I only want to move theorems about 'internal' properties (properties of a single <code>a</code>) of <code>FoobarMap</code>, as opposed to my proposal above to also move external properties (stuff about the space <code>FoobarMap</code>, such as linearity)</p>",
        "id": 427617715,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1710821936
    },
    {
        "content": "<p>To give an example: we have lots of really weird projections such as <code>ContinuousLinearMap -&gt; LinearMap</code> and my proposal would be to replace them by adding a <code>ContinuousLinearMapClass.toContinuousLinearMap</code> etc and use that <code>ContinuousLinearMap</code> has an instance for <code>LinearMapClass</code> (automatically since it has an instance for <code>ContinuousLinearMapClass</code>).<br>\nThen if you have a type synonym on <code>ContinuousLinearMap</code> you get the instance by def-eq abuse and all the projections are already there, whereas without classes there is more boilerplate.</p>",
        "id": 427619469,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1710823361
    },
    {
        "content": "<p>In general it is a very good idea to move from <code>FoobarMap</code> to <code>FoobarMapClass</code> if you are expecting to consume, rather than produce, a foobar map. So <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMapClass#doc\">docs#LinearMapClass</a> is no good for stating that e.g. the endomorphisms of a vector space form a monoid, since there is nothing in <code>LinearMapClass F R M M</code> stating that <code>F</code> is closed under compositions. But if the theorem is given some linear map <code>f</code>, then the right thing to do is to say <code>[LinearMapClass F R M N] (f : F)</code>.</p>",
        "id": 427655288,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1710842214
    },
    {
        "content": "<p>(There are some caveats to this general statement: going to FoobarMapClass loses dot notation support, and <a href=\"https://github.com/leanprover/lean4/pull/3107\">leanprover/lean4#3107</a> means that for semilinear maps specifically we need to restate certain <code>@[simp]</code> lemmas.)</p>",
        "id": 427655540,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1710842297
    },
    {
        "content": "<p>I have 2 more use cases for this:</p>\n<ul>\n<li>generalize <code>ae_mono</code>, <code>ae_zero</code> etc to <code>OuterMeasureClass</code>;</li>\n<li>generalize translation number to <code>AddConstMapClass F Real Real 1 1</code> and lemmas about it to the same class + monoid/group structure with mul=comp.</li>\n</ul>",
        "id": 442075372,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1717347659
    },
    {
        "content": "<p>For the first use case, <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> argues that I'm overengineering in <a href=\"https://github.com/leanprover-community/mathlib4/pull/10721\">#10721</a>.</p>",
        "id": 442075639,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1717347769
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span> <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> What do you think?</p>",
        "id": 442075678,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1717347784
    },
    {
        "content": "<p>Ping here</p>",
        "id": 443365606,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1717790308
    },
    {
        "content": "<p>Ping here...</p>",
        "id": 444869296,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1718462601
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sébastien Gouëzel</span> What do you think?</p>",
        "id": 444889374,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1718473631
    },
    {
        "content": "<p>Ping here... I understand that this topic may seem unimportant but I don't see a way to generalize theorems like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CircleDeg1Lift.translationNumber_pow#doc\">docs#CircleDeg1Lift.translationNumber_pow</a> to a <code>*Class</code> without making a decision here.</p>",
        "id": 446338137,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1719096011
    },
    {
        "content": "<p>And I want to generalize them so that we can have one <code>translationNumber</code> (defined for any map <code>f : Real -&gt; Real</code>) and a bunch of theorems that apply to</p>\n<ul>\n<li>the lifts of monotone circle maps (now <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CircleDeg1Lift#doc\">docs#CircleDeg1Lift</a>, to be migrated to <code>AddConstOrderHom</code> once I add it);</li>\n<li>the lifts of orientation-preserving circle homeomorphisms (now <code>Units CircleDeg1Lift</code>, to be migrated to <code>AddConstEquiv</code>s from <a href=\"https://github.com/leanprover-community/mathlib4/pull/9726\">#9726</a>)</li>\n<li>the lifts of continuous monotone circle maps;</li>\n<li>the lifts of $C^r$ smooth monotone circle maps with finitely many critical points;</li>\n<li>the lifts of $C^r$ circle diffeomorphisms;</li>\n<li>the lifts of $C^r$ smooth monotone cirlce maps with finitely many break points.</li>\n<li>probably more classes.</li>\n</ul>",
        "id": 446338692,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1719096334
    },
    {
        "content": "<p>Sorry, Yury, did you mean to ping <a href=\"#narrow/stream/287929-mathlib4/topic/RFC.3A.20bundled.20sets.20.236442\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/RFC.3A.20bundled.20sets.20.236442</a> instead? I'm failing to understand what you're asking opinion on</p>",
        "id": 446389859,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1719131105
    },
    {
        "content": "<p>I think that migrating to \"common data structure for bundled maps + generic instances for this type\" is difficult, because (a) sometimes we want, e.g., a different order; (b) I don't see how to fit <code>*Equiv</code>s, so I'm talking about going forward with <a href=\"https://github.com/leanprover-community/mathlib4/pull/10721\">#10721</a> and, more generally, <span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span> 's proposal above (add <code>Pointwise*</code> classes).</p>",
        "id": 446419837,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1719149980
    },
    {
        "content": "<p>In particular, I want to have</p>\n<ul>\n<li><code>PointwiseLE</code> for <code>ae_mono</code>;</li>\n<li><code>CompMulClass</code> + <code>IdOneClass</code> for <code>*End</code> types</li>\n</ul>\n<p>or some other way to get generic <code>ae_mono</code>, <code>coe_mul_eq_comp</code>, and <code>coe_one_eq_id</code>.</p>",
        "id": 446420840,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1719150760
    },
    {
        "content": "<p>Personally, I would prefer to have a common data type so that these lemmas become <code>rfl</code> but I failed to come up with a design that works for (a) <code>*Hom</code>s and <code>*Equiv</code>s; (b) special cases like <code>*Hom</code> type with non-pointwise order.</p>",
        "id": 446420952,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1719150858
    }
]