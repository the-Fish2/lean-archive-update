[
    {
        "content": "<p>I'm cleaning up <code>Probability/Kernel/CondCdf</code> and was wondering what would be a good place for <br>\n<code>theorem Real.iUnion_Iic_rat : ⋃ r : ℚ, Iic (r : ℝ) = univ := ...</code><br>\nAny ideas?<br>\nor is there perhaps even a more general lemma lurking underneath here?</p>",
        "id": 418924183,
        "sender_full_name": "Moritz Firsching",
        "timestamp": 1706650551
    },
    {
        "content": "<p>Trivially generalizes to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">false</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Set</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrderedField</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Archimedean</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">iUnion_Iic_rat</span> <span class=\"o\">:</span> <span class=\"bp\">⋃</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">,</span> <span class=\"n\">Iic</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext1</span> <span class=\"n\">x</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_iUnion</span><span class=\"o\">,</span> <span class=\"n\">mem_Iic</span><span class=\"o\">,</span> <span class=\"n\">mem_univ</span><span class=\"o\">,</span> <span class=\"n\">iff_true_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">exists_rat_gt</span> <span class=\"n\">x</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">hr.le</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 418927682,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706652042
    },
    {
        "content": "<p>The rationals are dense in the reals, so many permutations of this theorem can be constructed (<code>Iio</code>, <code>Ici</code>, <code>Ioi</code>, etc.)<br>\nI wonder if this can't be made generic to dense sets, akin to <code>Dense.biUnion_uniformity_ball</code></p>",
        "id": 418927934,
        "sender_full_name": "Emilie (Shad Amethyst)",
        "timestamp": 1706652154
    },
    {
        "content": "<p>Yes, this will be true for any function with cobounded range</p>",
        "id": 418928936,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706652613
    },
    {
        "content": "<p>Expecting a fully general proof from Yaël in 3... 2...</p>",
        "id": 418928994,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706652652
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.iUnion_Iic_of_not_bddAbove_range</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">BddAbove</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">⋃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">eq_univ_iff_forall</span><span class=\"o\">,</span> <span class=\"n\">BddAbove</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hf</span>\n</code></pre></div>\n<p>(untested)</p>",
        "id": 418930259,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706653223
    },
    {
        "content": "<p>Simp ends up recommending</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"k\">in</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.iUnion_Iic_of_not_bddAbove_range</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">BddAbove</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"bp\">⋃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">OrderTop.bddAbove</span><span class=\"o\">,</span> <span class=\"n\">not_true_eq_false</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hf</span>\n</code></pre></div>\n<p>This does work, though:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"k\">in</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.iUnion_Iio_of_not_bddAbove_range</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">BddAbove</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"bp\">⋃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Iio</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">not_bddAbove_iff</span><span class=\"o\">,</span> <span class=\"n\">Set.eq_univ_iff_forall</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hf</span>\n</code></pre></div>",
        "id": 418931063,
        "sender_full_name": "Emilie (Shad Amethyst)",
        "timestamp": 1706653581
    },
    {
        "content": "<p>Wait no hold on</p>\n<p>I'm a dummy, <code>Set α</code> has a top element (<code>Set.univ</code>), so <code>f</code> must be bounded above if it maps to <code>Set α</code></p>",
        "id": 418931285,
        "sender_full_name": "Emilie (Shad Amethyst)",
        "timestamp": 1706653675
    },
    {
        "content": "<p>I can't seem to do better than this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"k\">in</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.iUnion_Iic_of_not_bddAbove_range</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">BddAbove</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"bp\">⋃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Iic</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Set.univ_subset_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">subset_trans</span> <span class=\"o\">(</span><span class=\"n\">subset_of_eq</span> <span class=\"o\">(</span><span class=\"n\">Set.iUnion_Iio_of_not_bddAbove_range</span> <span class=\"n\">hf</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span>\n  <span class=\"n\">gcongr</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Iio_subset_Iic_self</span>\n</code></pre></div>",
        "id": 418933814,
        "sender_full_name": "Emilie (Shad Amethyst)",
        "timestamp": 1706654835
    },
    {
        "content": "<p>Cool, this is great! The proof also uses the dualized version, which I did like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">Set.iInter_Iic_of_not_bddBelow_range</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">BddBelow</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"bp\">⋂</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Iic</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">not_bddBelow_iff</span><span class=\"o\">,</span> <span class=\"n\">Set.eq_empty_iff_forall_not_mem</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hf</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.iInter_Iio_of_not_bddBelow_range</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">BddBelow</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"bp\">⋂</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Iio</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">eq_empty_of_subset_empty</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Set.iInter_Iic_of_not_bddBelow_range</span> <span class=\"n\">hf</span><span class=\"o\">]</span>\n  <span class=\"n\">gcongr</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Iio_subset_Iic_self</span>\n</code></pre></div>\n<p>Would it also be useful to have </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">notBddAbove_coe</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">BddAbove</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)))</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>and </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">notBddBelow_coe</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">BddBelow</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)))</span> <span class=\"o\">:=</span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>as separate lemmas somewhere to connect the generalized version to the one actually needed in Probability/Kernel/CondCdf?</p>\n<p>Also one question remains:<br>\nWhat would be a good place for those lemmas?</p>",
        "id": 419463328,
        "sender_full_name": "Moritz Firsching",
        "timestamp": 1706882547
    },
    {
        "content": "<p>Made a pr with the best place I could find: <a href=\"https://github.com/leanprover-community/mathlib4/pull/10298\">https://github.com/leanprover-community/mathlib4/pull/10298</a></p>",
        "id": 420047400,
        "sender_full_name": "Moritz Firsching",
        "timestamp": 1707226212
    }
]