[
    {
        "content": "<p>This post is a short summary with some ideas about self-correcting Lean code.</p>\n<p>Since Mathlib changes so quickly, I think that it is important that Mathlib itself, and the projects that depend on it, can be automatically updated as much as possible.</p>",
        "id": 444456567,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718282618
    },
    {
        "content": "<p>My experience so far is limited, but promising:</p>\n<ul>\n<li>replacement of <code>refine'</code> with <code>refine</code>, where simply adding <code>?</code> in the right places was enough;</li>\n<li>removal of unnecessary <code>set_option ... in</code>;</li>\n<li>adding <code>(since \"YYYY-MM-DD\")</code> to <code>deprecated</code> that were missing it;</li>\n<li>renames after a deprecation.</li>\n</ul>",
        "id": 444456604,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718282632
    },
    {
        "content": "<p>In all of these cases, this is what the workflow has been.</p>\n<ul>\n<li>Plant code in <code>Mathlib</code> that guides where the changes are supposed to take place and what the change should be (e.g. a line/column number, some old-name/new-name pair, the more specific the better) -- this has been a linter in the cases above.</li>\n<li>Run <code>lake build</code> to retrieve all the information about the replacements.</li>\n<li>Write a parser for the output of <code>lake build</code> that takes the information that was planted and acts on it.</li>\n</ul>",
        "id": 444456625,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718282639
    },
    {
        "content": "<p>For this to work, the simplest is to have \"atomic\" changes: add <code>since ...</code>, shorten long lines, remove a <code>set_option ... in</code>.  The simplest the change, the higher the success rate.</p>",
        "id": 444456686,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718282645
    },
    {
        "content": "<p>Ideally, another tool (probably human for quite some time!), would compute something like the \"edit distance\" for a PR, that fragments it into a sequence of elementary changes that ideally fit well with the program above.  Such a tool could be an evolution of Alex Best's leaff (of which <code>move-decls</code> is a very primitive, text-based butchering).</p>",
        "id": 444456704,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718282651
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Had similar ideas for a <code>lake exe refactor</code>. I think it would be really great to have such a tool!</p>",
        "id": 444461677,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1718284117
    },
    {
        "content": "<p>I also just remembered about the replacement of <code>theorem</code> with <code>lemma</code>, whenever <code>theorem</code> does not have a doc-string.</p>",
        "id": 444462444,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718284352
    },
    {
        "content": "<p>In case anyone is feeling adventurous and wants to automate some deprecations, I would be very happy if they used <a href=\"https://github.com/adomani/UpdateDeprecations\">lake exe update_deprecations</a> (instructions in the repo) and reported back any short-comings/bugs!</p>",
        "id": 444463173,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718284579
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> An initial draft of <code>lake exe refactor</code> is ready at <a href=\"https://github.com/leanprover-community/mathlib4/pull/13973\">#13973</a> . It would be good to try using this to do one of those back burner refactorings like (what is left of) <code>refine</code> -&gt; <code>refine'</code>, and refine the interface a bit before merging.</p>",
        "id": 445714858,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718836842
    },
    {
        "content": "<p>also cc: <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> , maybe you have some linter ideas in the pipeline that can be expressed as refactors instead / in addition</p>",
        "id": 445717740,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718838340
    },
    {
        "content": "<p>Yes, the \"unnecessary <code>set_option ... in</code>\" linter is a good candidate (and I already wrote a self-corrector for it).</p>",
        "id": 445717888,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718838400
    },
    {
        "content": "<p>Btw, in the code that I was using, the analogue of your <code>Edit</code> also had a field for the <em>current</em> syntax, as a check and would perform the substitution only if the current syntax matches the expectation.  I could not see this in your code: have I not seen it?  Do you think that it would be useful?</p>",
        "id": 445718053,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718838484
    },
    {
        "content": "<p>We talked about having some constructors for <code>Edit</code>, which could do that kind of sanitization. I think that any <code>Edit</code> returned from <code>runRefactoring</code> should be considered as real edits, so that the edit application logic doesn't have to do parsing</p>",
        "id": 445718201,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718838573
    },
    {
        "content": "<p>More generally, any \"unnecessary/unused syntax\" linter is a good candidate.</p>",
        "id": 445718292,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718838610
    },
    {
        "content": "<p>Also, if you want to test your refactor tool, the <code>have</code> vs <code>let</code> linter has <em>a lot</em> of hits in mathlib.</p>",
        "id": 445718338,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718838639
    },
    {
        "content": "<p>(although it is silent by default.)</p>",
        "id": 445718348,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718838650
    },
    {
        "content": "<p>And the multigoal linter would be probably a good challenge!</p>",
        "id": 445718375,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718838664
    },
    {
        "content": "<p>is the multigoal linter auto-fixable?</p>",
        "id": 445718416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718838682
    },
    {
        "content": "<p>I am not sure that I tried to make it so, but I think that it <em>could</em> be made autofixable.  I need to think a little bit about it, though.</p>",
        "id": 445718515,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718838730
    },
    {
        "content": "<p>have / let sounds like the easiest one</p>",
        "id": 445718544,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718838748
    },
    {
        "content": "<p>I suspect that the same tracking logic for metavars that is used in the flexible vs rigid tactics can be used with the multigoal linter.  But that would be quite a bit of extra code.</p>",
        "id": 445718588,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718838777
    },
    {
        "content": "<p>you can import mathlib in <code>Refactor.Main</code> if you need</p>",
        "id": 445718628,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718838796
    },
    {
        "content": "<p>have / let is indeed easier, but not straightforward either if you want to have 100% success rate.</p>",
        "id": 445718639,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718838801
    },
    {
        "content": "<p>hopefully the flexible vs rigid linter can share code with the refactoring</p>",
        "id": 445718776,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718838872
    },
    {
        "content": "<p>Also, the current \"unnecessary <code>simpNF</code>\" could be adapted -- at least the case in which there is <code>nolint simpNF</code> and no more linters are disabled in that call.</p>",
        "id": 445718894,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718838940
    },
    {
        "content": "<p>Ah, \"<code>theorem</code> with no doc-string to <code>lemma</code>\" should be really straightforward!  I'm sure that you love this one...</p>",
        "id": 445719124,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718839067
    },
    {
        "content": "<p>For this one, there is also no need to worry about long lines: it is a simple translation.</p>",
        "id": 445719212,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718839107
    },
    {
        "content": "<p>I'm not sure I like the polarity of that auto-fix</p>",
        "id": 445719220,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718839115
    },
    {
        "content": "<p>I'd prefer the theorems get documentation</p>",
        "id": 445719230,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718839125
    },
    {
        "content": "<p>You mean that <code>refactor</code> should <em>add</em> doc-strings to undocumented <code>theorem</code>s?  <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 445719285,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718839158
    },
    {
        "content": "<p>But I guess you could autofix and then review the changes to undo and document theorems that should have been documented</p>",
        "id": 445719318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718839184
    },
    {
        "content": "<p>or I suppose you could call chat-gpt or something</p>",
        "id": 445719387,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718839207
    },
    {
        "content": "<p>Anyway, that one is a really straightforward text trasliteration that could be a good test, whether you want to keep the result or not.</p>",
        "id": 445719439,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718839242
    },
    {
        "content": "<p>and honestly a pretty cool / nontrivial application of a \"refactoring\"</p>",
        "id": 445719482,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718839265
    },
    {
        "content": "<p>That linter should be already ready.</p>",
        "id": 445719538,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718839288
    },
    {
        "content": "<p>Let me dig up the PR</p>",
        "id": 445719551,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718839293
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/12869\">#12869</a></p>",
        "id": 445719748,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718839362
    },
    {
        "content": "<p>The conflict is just the alphabetization of the \"import all\" files.</p>",
        "id": 445719807,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718839382
    },
    {
        "content": "<p>What about trying it with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">runRefactoring</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cmd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">`command</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommandElabM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Edit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cmd</span><span class=\"bp\">.</span><span class=\"n\">raw</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">isOfKind</span><span class=\"w\"> </span><span class=\"ss\">``Lean.Parser.Command.docComment</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">isNone</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cmd</span><span class=\"bp\">.</span><span class=\"n\">raw</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">isOfKind</span><span class=\"w\"> </span><span class=\"ss\">``Lean.Parser.Command.theorem</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">thm</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">[</span>\n<span class=\"w\">      </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">replacement</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"lemma\"</span>\n<span class=\"w\">        </span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">thm</span><span class=\"bp\">.</span><span class=\"n\">getHead?</span><span class=\"bp\">.</span><span class=\"n\">getD</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getRange?</span><span class=\"bp\">.</span><span class=\"n\">get!</span><span class=\"w\"> </span><span class=\"o\">}]</span>\n</code></pre></div>",
        "id": 445723049,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718841143
    },
    {
        "content": "<p>(Assuming that I understood correctly the meaning of <code>Edit</code>.)</p>",
        "id": 445723078,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718841169
    },
    {
        "content": "<p>Also, I am not sure that I have a use for <code>TSyntax</code> instead of a plain <code>Syntax</code>: after all, a plain <code>Syntax</code> is what you get our of <code>Linter.run</code> as well.</p>",
        "id": 445723221,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718841251
    },
    {
        "content": "<p>I tested this: it replaced</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Lemma</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">replaceMe</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n\n<span class=\"sd\">/-- i have a doc-string -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">doNotReplaceMe</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">doNotReplaceMeEither</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n</code></pre></div>\n<p>with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Lemma</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">replaceMe</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n\n<span class=\"sd\">/-- i have a doc-string -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">doNotReplaceMe</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">doNotReplaceMeEither</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n</code></pre></div>\n<p>Success!</p>",
        "id": 445725988,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718842456
    },
    {
        "content": "<p>I left <code>lake exe refactor</code> running in <a href=\"https://github.com/leanprover-community/mathlib4/pull/13979\">#13979</a> on all of Mathlib.</p>",
        "id": 445732563,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718845662
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> wonderful! I will surely be playing with this a lot!</p>",
        "id": 445751808,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1718854647
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Self-correcting.20code/near/445719230\">said</a>:</p>\n<blockquote>\n<p>I'd prefer the theorems get documentation</p>\n</blockquote>\n<p>A reminder that a bunch of machine generated docs are available at <a href=\"https://math.iisc.ac.in/~gadgil/descs/\">https://math.iisc.ac.in/~gadgil/descs/</a> (and more have been recently generated).</p>",
        "id": 445759316,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1718859201
    },
    {
        "content": "<p>At least one problem with the code above that I posted is that <code>refactor</code> climbs <em>up</em> in imports, so reaches quickly a file where <code>lemma</code> is not available.  I wonder whether climbing <em>down</em> should have a flag, so that you can guarantee the existence of some syntax.</p>",
        "id": 445759948,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718859705
    },
    {
        "content": "<p>The \"non-documented theorem to lemma\" via <code>refactor</code> was successfully build by CI: <a href=\"https://github.com/leanprover-community/mathlib4/pull/13979\">#13979</a>.</p>",
        "id": 445771184,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718866645
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Self-correcting.20code/near/445759948\">said</a>:</p>\n<blockquote>\n<p>At least one problem with the code above that I posted is that <code>refactor</code> climbs <em>up</em> in imports, so reaches quickly a file where <code>lemma</code> is not available.  I wonder whether climbing <em>down</em> should have a flag, so that you can guarantee the existence of some syntax.</p>\n</blockquote>\n<p>For tests like this, the easy thing to do is to check if the <code>lemma</code> declaration exists, or a module of interest is imported, and otherwise just <code>return []</code></p>",
        "id": 445955246,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718918226
    },
    {
        "content": "<p>I guess I should add a function which runs before any commands are processed since it might be possible to short-circuit before running the elaborator at all</p>",
        "id": 445955401,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718918295
    },
    {
        "content": "<p>Yes, this is what I ended up doing in the PR that successfully made the replacement.</p>",
        "id": 445955409,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718918298
    },
    {
        "content": "<p>In general, though, I still think that it is a fairly common situation where you want to refactor starting from a given module, rather than up to a given module.</p>",
        "id": 445955465,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718918340
    },
    {
        "content": "<p>the walking up is a necessity, you should just think of it as running over the whole project</p>",
        "id": 445955546,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718918378
    },
    {
        "content": "<p>it doesn't process the files in order</p>",
        "id": 445955563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718918388
    },
    {
        "content": "<p>Ok, in any case, the workaround is simple enough.</p>",
        "id": 445955654,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718918421
    },
    {
        "content": "<p>but I think what you want is to have that short circuit. There are two possible points at which it could be placed:</p>\n<ul>\n<li>Before running the subprocess: here we know only the name of the module and its direct imports</li>\n<li>After running the subprocess and processing the imports: here we know the module's recursive dependencies and also the list of declarations in the environment</li>\n</ul>",
        "id": 445956026,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718918597
    },
    {
        "content": "<p>either one would save you a lot of elaboration cost</p>",
        "id": 445956132,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718918644
    },
    {
        "content": "<p>I am not too good with performance aspects, but I did find that with the (probably very inefficient) code that I wrote, it took quite a long time to replace all doc-less theorems by lemmas.  Granted that it is a lot of operations, but I wonder whether maybe it might be a good test to perform \"quickly\".</p>",
        "id": 445956289,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718918730
    },
    {
        "content": "<p>keep in mind that <code>lake exe refactor</code> is necessarily lower bounded by the cost of building mathlib</p>",
        "id": 445956406,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718918769
    },
    {
        "content": "<p>even if you do nothing at all</p>",
        "id": 445956419,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718918779
    },
    {
        "content": "<p>although this is not completely true if you use the aforementioned short-circuit</p>",
        "id": 445956486,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718918822
    },
    {
        "content": "<p>But it does use <code>olean</code>s, if they are available?  Or not?</p>",
        "id": 445956554,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718918853
    },
    {
        "content": "<p>it uses them, but it's still basically equivalent to a full build of every file</p>",
        "id": 445956581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718918876
    },
    {
        "content": "<p>Ok, then it was probably not so bad, given that the refactor and the successful build took 1h20 (if I remember correctly).</p>",
        "id": 445956679,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718918917
    },
    {
        "content": "<p>Btw, is there a notion of just building the syntax trees?  I imagine not, due to the very flexible extensibility of the language, but you never know...  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 445956809,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718919000
    },
    {
        "content": "<p>I've been asking for this for a very long time. This project is the result of deciding that I can't wait on that forever</p>",
        "id": 445956905,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718919033
    },
    {
        "content": "<p>Is it \"theoretically\" possible to just parse the syntax though?  At least you should parse also syntax extensions, right?</p>",
        "id": 445957248,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718919213
    },
    {
        "content": "<p>see also <a href=\"#narrow/stream/270676-lean4/topic/quick.20and.20dirty.20mode\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/quick.20and.20dirty.20mode</a></p>",
        "id": 445957329,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718919244
    },
    {
        "content": "<p>Ok, yes, I have seen these discussions.  Let's hope that something happens along these lines!</p>",
        "id": 445957472,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718919333
    },
    {
        "content": "<p>I think that in the long run, it might make sense to abstract <code>runRefactoring</code> into an argument to <code>lake exe refactor</code>, so that we may then do <code>lake exe refactor deprecations</code> or <code>lake exe refactor unnecessary_syntax</code> or whatever and each calls <code>refactor</code> with the specialised <code>runRefactoring</code> function.</p>",
        "id": 446026092,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718956430
    },
    {
        "content": "<p>What would be the view of having certain \"self-correcting\" linters run on a schedule using <code>refactor</code>?  For instance, a good candidate for this could be the \"unused tactic\" linter, flagging tactics that do not change any metavariable (note that this is different from the unreachable tactic linter).  E.g., when I ran it several weeks ago it flagged a few <code>congr</code>s, some <code>norm_num</code>s maybe for which the list of metavariables before and after the tactic was unchanged.</p>\n<p>The linter could produce the metaprogram that feeds into refactor and then refactor could perform the replacements.</p>",
        "id": 446735415,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1719269140
    },
    {
        "content": "<p>In order to maximize self-referentiality, the linter could write a metaprogram that instructs <code>refactor</code> to modify <code>runRefactoring</code> inside its own file, in such a way that a second run of <code>refactor</code> would perform the removal of unused tactics.</p>",
        "id": 446735963,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1719269343
    },
    {
        "content": "<p>I don't think there is any need for self modifying code here (except insofar as any refactor is modifying code). The original idea was to have a small library of named refactors which can be selected either at the command line as you suggest, or via some easily editable script (i.e. <code>runRefactoring</code> is a one liner which calls a previously prepared refactoring function). For \"unused tactic\", we can just permanently have such a refactoring available but not called by default. There is no need for a linter to write the refactoring, they just share a common bit of code.</p>",
        "id": 446747201,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719275482
    }
]