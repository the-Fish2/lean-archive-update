[
    {
        "content": "<p>Hello, I'm a master student (new in Lean) trying to Re-proving First Isomorphism Theorem. I managed to give a proof of the First Isomorphism Theorem using the \"lift\" function and the code is the following </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Sylow</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Perm.Cycle.Concrete</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Perm.Subgroup</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.PresentedGroup</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Subgroup.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">QuotientGroup</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">first_isomorphism_theorem</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">f.ker</span><span class=\"o\">)</span> <span class=\"bp\">≃*</span> <span class=\"n\">f.range</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">--have h : f.ker.Normal := inferInstance -- Serve?  No, perché è un'istanza di Group, non di GroupWithZero</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f.ker</span> <span class=\"bp\">≤</span> <span class=\"n\">f.ker</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">exact</span> <span class=\"n\">le_rfl</span>\n    <span class=\"n\">done</span>\n  <span class=\"n\">set</span> <span class=\"n\">f'</span> <span class=\"o\">:=</span> <span class=\"n\">QuotientGroup.lift</span> <span class=\"n\">f.ker</span> <span class=\"n\">f</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">hf'</span>\n  <span class=\"k\">have</span> <span class=\"n\">f'_range</span> <span class=\"o\">:=</span> <span class=\"n\">MonoidHom.rangeRestrict_surjective</span> <span class=\"n\">f'</span> <span class=\"c1\">-- Set.rangeFactorization f'</span>\n  <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">f'.ker</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">eq_bot_iff_forall</span><span class=\"o\">]</span>\n    <span class=\"n\">intro</span> <span class=\"n\">x</span>\n    <span class=\"n\">intro</span> <span class=\"n\">hx</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">MonoidHom.mem_ker</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span>\n    <span class=\"k\">have</span> <span class=\"n\">hp</span> <span class=\"o\">:=</span> <span class=\"n\">QuotientGroup.mk'_surjective</span> <span class=\"n\">f.ker</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">Function.Surjective</span> <span class=\"n\">at</span> <span class=\"n\">hp</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">hp</span> <span class=\"n\">x</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">x'</span><span class=\"o\">,</span> <span class=\"n\">hx'</span><span class=\"o\">⟩</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"n\">f'</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hx'</span><span class=\"o\">]</span>\n      <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n      <span class=\"n\">done</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">MonoidHom.mem_ker</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n    <span class=\"k\">have</span> <span class=\"n\">x'_in_ker</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">QuotientGroup.mk'</span> <span class=\"n\">f.ker</span><span class=\"o\">)</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">coe_mk'</span><span class=\"o\">]</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq_one_iff</span><span class=\"o\">]</span>\n      <span class=\"n\">exact</span> <span class=\"n\">this</span>\n      <span class=\"n\">done</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hx'</span><span class=\"o\">,</span><span class=\"n\">x'_in_ker</span><span class=\"o\">]</span>\n    <span class=\"n\">done</span>\n  <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">MonoidHom.ker_eq_bot_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h'</span>\n  <span class=\"k\">have</span> <span class=\"n\">h''</span> <span class=\"o\">:</span> <span class=\"n\">f'.range</span> <span class=\"bp\">=</span> <span class=\"n\">f.range</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">ext</span> <span class=\"n\">y</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"c1\">-- sinistra -&gt; destra</span>\n    <span class=\"n\">intro</span> <span class=\"n\">hy</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">hy</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span>\n    <span class=\"k\">have</span> <span class=\"n\">hp'</span> <span class=\"o\">:=</span> <span class=\"n\">QuotientGroup.mk'_surjective</span> <span class=\"n\">f.ker</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">Function.Surjective</span> <span class=\"n\">at</span> <span class=\"n\">hp'</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">hp'</span> <span class=\"n\">x</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">x'</span><span class=\"o\">,</span> <span class=\"n\">hx'</span><span class=\"o\">⟩</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"n\">f'</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hx'</span><span class=\"o\">]</span>\n      <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n      <span class=\"n\">done</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">MonoidHom.mem_range</span><span class=\"o\">]</span>\n    <span class=\"n\">use</span> <span class=\"n\">x'</span>\n    <span class=\"c1\">-- destra -&gt; sinistra</span>\n    <span class=\"n\">intro</span> <span class=\"n\">hy</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">hy</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">y'</span><span class=\"o\">,</span> <span class=\"n\">hy'</span><span class=\"o\">⟩</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">MonoidHom.mem_range</span><span class=\"o\">]</span>\n    <span class=\"n\">use</span> <span class=\"n\">y'</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hy'</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n    <span class=\"n\">done</span>\n  <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">h''</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"n\">f''_inj</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Function.Injective</span> <span class=\"o\">(</span><span class=\"n\">MonoidHom.rangeRestrict</span> <span class=\"n\">f'</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">MonoidHom.rangeRestrict_injective_iff.mpr</span> <span class=\"n\">h'</span>\n  <span class=\"k\">have</span> <span class=\"n\">sp</span> <span class=\"o\">:</span> <span class=\"n\">Function.Surjective</span> <span class=\"o\">(</span><span class=\"n\">MonoidHom.rangeRestrict</span> <span class=\"n\">f'</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f'_range</span>\n  <span class=\"k\">have</span> <span class=\"n\">f''_iso</span> <span class=\"o\">:</span> <span class=\"n\">Function.Bijective</span> <span class=\"o\">(</span><span class=\"n\">MonoidHom.rangeRestrict</span> <span class=\"n\">f'</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">f''_inj</span><span class=\"o\">,</span> <span class=\"n\">sp</span><span class=\"o\">⟩</span>\n  <span class=\"n\">exact</span> <span class=\"n\">MulEquiv.ofBijective</span> <span class=\"o\">(</span><span class=\"n\">MonoidHom.rangeRestrict</span> <span class=\"n\">f'</span><span class=\"o\">)</span> <span class=\"n\">f''_iso</span>\n</code></pre></div>\n<p>As you see, everything is built around the lien <code>set f' := QuotientGroup.lift f.ker f h with hf'</code> and everything works perfectly. What I wanted to know is whether there is a way (although sub-optimal), and if yes how, to define without invoking any theorem f' as a group function from the quotient to the image and then proving that is well defined, and then using it as f' of theorem above (since  <code>set f' := QuotientGroup.lift f.ker f h with hf'</code>already does all this work for me).<br>\nAny help or even tip about my code would be appreciated, thank you for your time.</p>",
        "id": 409342561,
        "sender_full_name": "brokkilisoup",
        "timestamp": 1703149606
    },
    {
        "content": "<p>Imports are missing.</p>",
        "id": 409372862,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1703159942
    },
    {
        "content": "<p>I'm sorry youre right, these are my imports </p>\n<p>import Mathlib.GroupTheory.Sylow<br>\nimport Mathlib.GroupTheory.Perm.Cycle.Concrete<br>\nimport Mathlib.GroupTheory.Perm.Subgroup<br>\nimport Mathlib.GroupTheory.PresentedGroup<br>\nimport Mathlib.GroupTheory.Subgroup.Basic</p>",
        "id": 409373595,
        "sender_full_name": "brokkilisoup",
        "timestamp": 1703160174
    },
    {
        "content": "<p>I get \"unknown identifier 'eq_bot_iff_forall'\".</p>",
        "id": 409373941,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1703160313
    },
    {
        "content": "<p>Please edit your importants into your previous message so that the \"view in lean4 playground\" link works!</p>",
        "id": 409375538,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703160905
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/287929-mathlib4/topic/First.20Isomorphism.20Theorem/near/409373941\">ha scritto</a>:</p>\n<blockquote>\n<p>I get \"unknown identifier 'eq_bot_iff_forall'\".</p>\n</blockquote>\n<p>I don't know why, could be that I have an update version of Lean or? eq_bot_iff_forall is not a lemma I added, with #check I get </p>\n<blockquote>\n<p>Subgroup.eq_bot_iff_forall.{u_1} {G : Type u_1} [inst✝ : Group G] (H : Subgroup G) : H = ⊥ ↔ ∀ x ∈ H, x = 1</p>\n</blockquote>",
        "id": 409377832,
        "sender_full_name": "brokkilisoup",
        "timestamp": 1703161792
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/First.20Isomorphism.20Theorem/near/409375538\">ha scritto</a>:</p>\n<blockquote>\n<p>Please edit your importants into your previous message so that the \"view in lean4 playground\" link works!</p>\n</blockquote>\n<p>Done, thank you for the tip</p>",
        "id": 409378024,
        "sender_full_name": "brokkilisoup",
        "timestamp": 1703161854
    },
    {
        "content": "<p>Some superficial (i.e., without understanding the proof) refactoring for you (let diff be your code review):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Sylow</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Perm.Cycle.Concrete</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Perm.Subgroup</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.PresentedGroup</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Subgroup.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">QuotientGroup</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">first_isomorphism_theorem</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">f.ker</span><span class=\"o\">)</span> <span class=\"bp\">≃*</span> <span class=\"n\">f.range</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">--have h : f.ker.Normal := inferInstance -- Serve?  No, perché è un'istanza di Group, non di GroupWithZero</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f.ker</span> <span class=\"bp\">≤</span> <span class=\"n\">f.ker</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"n\">set</span> <span class=\"n\">f'</span> <span class=\"o\">:=</span> <span class=\"n\">QuotientGroup.lift</span> <span class=\"n\">f.ker</span> <span class=\"n\">f</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">hf'</span>\n  <span class=\"k\">have</span> <span class=\"n\">f'_range</span> <span class=\"o\">:=</span> <span class=\"n\">MonoidHom.rangeRestrict_surjective</span> <span class=\"n\">f'</span> <span class=\"c1\">-- Set.rangeFactorization f'</span>\n  <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">f'.ker</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">MonoidHom.ker_eq_bot_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h'</span>\n  <span class=\"k\">have</span> <span class=\"n\">h''</span> <span class=\"o\">:</span> <span class=\"n\">f'.range</span> <span class=\"bp\">=</span> <span class=\"n\">f.range</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">ext</span> <span class=\"n\">y</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"c1\">-- sinistra -&gt; destra</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hy</span>\n      <span class=\"n\">rcases</span> <span class=\"n\">hy</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span>\n      <span class=\"k\">have</span> <span class=\"n\">hp'</span> <span class=\"o\">:=</span> <span class=\"n\">QuotientGroup.mk'_surjective</span> <span class=\"n\">f.ker</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">Function.Surjective</span> <span class=\"n\">at</span> <span class=\"n\">hp'</span>\n      <span class=\"n\">rcases</span> <span class=\"n\">hp'</span> <span class=\"n\">x</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">x'</span><span class=\"o\">,</span> <span class=\"n\">hx'</span><span class=\"o\">⟩</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"n\">f'</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hx'</span><span class=\"o\">]</span>\n        <span class=\"n\">rfl</span>\n      <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n      <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">MonoidHom.mem_range</span><span class=\"o\">]</span>\n      <span class=\"n\">use</span> <span class=\"n\">x'</span>\n    <span class=\"c1\">-- destra -&gt; sinistra</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hy</span>\n      <span class=\"n\">rcases</span> <span class=\"n\">hy</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">y'</span><span class=\"o\">,</span> <span class=\"n\">hy'</span><span class=\"o\">⟩</span>\n      <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">MonoidHom.mem_range</span><span class=\"o\">]</span>\n      <span class=\"n\">use</span> <span class=\"n\">y'</span>\n      <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hy'</span><span class=\"o\">]</span>\n      <span class=\"n\">rfl</span>\n  <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">h''</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"n\">f''_inj</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Function.Injective</span> <span class=\"o\">(</span><span class=\"n\">MonoidHom.rangeRestrict</span> <span class=\"n\">f'</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">MonoidHom.rangeRestrict_injective_iff.mpr</span> <span class=\"n\">h'</span>\n  <span class=\"k\">have</span> <span class=\"n\">f''_iso</span> <span class=\"o\">:</span> <span class=\"n\">Function.Bijective</span> <span class=\"o\">(</span><span class=\"n\">MonoidHom.rangeRestrict</span> <span class=\"n\">f'</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">f''_inj</span><span class=\"o\">,</span> <span class=\"n\">f'_range</span><span class=\"o\">⟩</span>\n  <span class=\"n\">exact</span> <span class=\"n\">MulEquiv.ofBijective</span> <span class=\"o\">(</span><span class=\"n\">MonoidHom.rangeRestrict</span> <span class=\"n\">f'</span><span class=\"o\">)</span> <span class=\"n\">f''_iso</span>\n</code></pre></div>",
        "id": 409378665,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1703162114
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/287929-mathlib4/topic/First.20Isomorphism.20Theorem/near/409378665\">ha scritto</a>:</p>\n<blockquote>\n<p>Some superficial (i.e., without understanding the proof) refactoring for you (let diff be your code review):</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Sylow</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Perm.Cycle.Concrete</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Perm.Subgroup</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.PresentedGroup</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Subgroup.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">QuotientGroup</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">first_isomorphism_theorem</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">f.ker</span><span class=\"o\">)</span> <span class=\"bp\">≃*</span> <span class=\"n\">f.range</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">--have h : f.ker.Normal := inferInstance -- Serve?  No, perché è un'istanza di Group, non di GroupWithZero</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f.ker</span> <span class=\"bp\">≤</span> <span class=\"n\">f.ker</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"n\">set</span> <span class=\"n\">f'</span> <span class=\"o\">:=</span> <span class=\"n\">QuotientGroup.lift</span> <span class=\"n\">f.ker</span> <span class=\"n\">f</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">hf'</span>\n  <span class=\"k\">have</span> <span class=\"n\">f'_range</span> <span class=\"o\">:=</span> <span class=\"n\">MonoidHom.rangeRestrict_surjective</span> <span class=\"n\">f'</span> <span class=\"c1\">-- Set.rangeFactorization f'</span>\n  <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">f'.ker</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">MonoidHom.ker_eq_bot_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h'</span>\n  <span class=\"k\">have</span> <span class=\"n\">h''</span> <span class=\"o\">:</span> <span class=\"n\">f'.range</span> <span class=\"bp\">=</span> <span class=\"n\">f.range</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">ext</span> <span class=\"n\">y</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"c1\">-- sinistra -&gt; destra</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hy</span>\n      <span class=\"n\">rcases</span> <span class=\"n\">hy</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span>\n      <span class=\"k\">have</span> <span class=\"n\">hp'</span> <span class=\"o\">:=</span> <span class=\"n\">QuotientGroup.mk'_surjective</span> <span class=\"n\">f.ker</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">Function.Surjective</span> <span class=\"n\">at</span> <span class=\"n\">hp'</span>\n      <span class=\"n\">rcases</span> <span class=\"n\">hp'</span> <span class=\"n\">x</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">x'</span><span class=\"o\">,</span> <span class=\"n\">hx'</span><span class=\"o\">⟩</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"n\">f'</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hx'</span><span class=\"o\">]</span>\n        <span class=\"n\">rfl</span>\n      <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n      <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">MonoidHom.mem_range</span><span class=\"o\">]</span>\n      <span class=\"n\">use</span> <span class=\"n\">x'</span>\n    <span class=\"c1\">-- destra -&gt; sinistra</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hy</span>\n      <span class=\"n\">rcases</span> <span class=\"n\">hy</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">y'</span><span class=\"o\">,</span> <span class=\"n\">hy'</span><span class=\"o\">⟩</span>\n      <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">MonoidHom.mem_range</span><span class=\"o\">]</span>\n      <span class=\"n\">use</span> <span class=\"n\">y'</span>\n      <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hy'</span><span class=\"o\">]</span>\n      <span class=\"n\">rfl</span>\n  <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">h''</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"n\">f''_inj</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Function.Injective</span> <span class=\"o\">(</span><span class=\"n\">MonoidHom.rangeRestrict</span> <span class=\"n\">f'</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">MonoidHom.rangeRestrict_injective_iff.mpr</span> <span class=\"n\">h'</span>\n  <span class=\"k\">have</span> <span class=\"n\">f''_iso</span> <span class=\"o\">:</span> <span class=\"n\">Function.Bijective</span> <span class=\"o\">(</span><span class=\"n\">MonoidHom.rangeRestrict</span> <span class=\"n\">f'</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">f''_inj</span><span class=\"o\">,</span> <span class=\"n\">f'_range</span><span class=\"o\">⟩</span>\n  <span class=\"n\">exact</span> <span class=\"n\">MulEquiv.ofBijective</span> <span class=\"o\">(</span><span class=\"n\">MonoidHom.rangeRestrict</span> <span class=\"n\">f'</span><span class=\"o\">)</span> <span class=\"n\">f''_iso</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thanks, however I was asking whether I could skip \"lift\" usage and defining f' myself, showing that is well defined</p>",
        "id": 409390499,
        "sender_full_name": "brokkilisoup",
        "timestamp": 1703165874
    },
    {
        "content": "<p>If you want to do it \"from the basics\" for pedagogical reasons, you can use <code>Quotient.lift</code> instead of <code>QuotientGroup.lift</code></p>",
        "id": 409482822,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703202384
    }
]