[
    {
        "content": "<p>In a PR that was merged earlier, I introduced the notation <code>ùñ≤ùóâùñæùñº R</code> for <code>Scheme.Spec.obj (op R)</code>, but <span class=\"user-mention\" data-user-id=\"221921\">@Marc Huisinga</span> raised the point that it might cause confusion as it is almost indistinguishable from regular editor text. What do people think?</p>",
        "id": 446308519,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1719082069
    },
    {
        "content": "<p>It's worth pointing out that this is also about the question of whether we should add abbreviations like <code>\\spec</code> for <code>ùñ≤ùóâùñæùñº</code> (<a href=\"https://github.com/leanprover-community/vscode-lean4/pull/483\">vscode-lean4#483</a>).</p>",
        "id": 446309819,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1719082247
    },
    {
        "content": "<p>Is it possible to do this with a custom elaborator? Maybe even so that we can write <code>Spec R</code> and <code>Spec f</code> where <code>R</code> is a ring and <code>f</code> a ring hom?</p>",
        "id": 446314628,
        "sender_full_name": "Christian Merten",
        "timestamp": 1719084938
    },
    {
        "content": "<p>I'd prefer we don't introduce notations of this form. To me, the confusion of \"is this a weird font?\" outweighs saving keystrokes.</p>",
        "id": 446348307,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719104022
    },
    {
        "content": "<p>I'd say that the main gain is readability and not saving keystrokes, but I'm open to other options.</p>",
        "id": 446348529,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1719104152
    },
    {
        "content": "<p>I agree saving keystrokes is not the point. I should have said that even on readability I'm not convinced this is an improvement.</p>",
        "id": 446348696,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719104196
    },
    {
        "content": "<p>Do you think that having <code>Spec</code> (actual ascii text) instead of <code>ùñ≤ùóâùñæùñº</code> as notation would be better?<br>\nI thought it was misleading to have text as notations and it might not be robust, but maybe I'm plain wrong.</p>",
        "id": 446349235,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1719104382
    },
    {
        "content": "<p>Does it even need to be a notation? Could an <code>abbrev</code> work here?</p>",
        "id": 446349595,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719104474
    },
    {
        "content": "<p>I would like it to work on both rings and ring homs.</p>",
        "id": 446350033,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1719104614
    },
    {
        "content": "<p>Though the current approach (<code>Spec R</code> for rings, <code>Spec(f)</code> for ring homs) might be misleading as well?</p>",
        "id": 446350191,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1719104657
    },
    {
        "content": "<p>Okay something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Notation typeclass for `Spec`. -/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">HasSpec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">B</span>\n\n<span class=\"kn\">attribute</span><span class=\"o\">[</span><span class=\"n\">reducible</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">HasSpec</span><span class=\"bp\">.</span><span class=\"n\">spec</span>\n\n<span class=\"sd\">/-- Notation for `Spec`. See `Scheme.Spec` instead. -/</span>\n<span class=\"kn\">alias</span><span class=\"w\"> </span><span class=\"n\">Spec</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">HasSpec</span><span class=\"bp\">.</span><span class=\"n\">spec</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasSpec</span><span class=\"w\"> </span><span class=\"n\">CommRingCat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">Scheme</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Scheme</span><span class=\"bp\">.</span><span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommRingCat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasSpec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Spec</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Spec</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Scheme</span><span class=\"bp\">.</span><span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">op</span>\n</code></pre></div>\n<p>seem to work, though I'll have to test it downstream.</p>",
        "id": 446351247,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1719105106
    },
    {
        "content": "<p>A downside is <code>Spec f</code> cannot trigger the instances of the form <code>F.map f</code> (with <code>F</code> being <code>Scheme.Spec</code>) but I think only a few such instances are useful and can be duplicated manually.</p>",
        "id": 446353217,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1719106338
    },
    {
        "content": "<p>If you want it to work for both rings and ring homs, then please have people type <code>X.obj R</code> and <code>X.map f</code> (for some choice of X), just like for any other functor!</p>",
        "id": 446357523,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719110019
    },
    {
        "content": "<p>Obscuring this doesn't help anyone? (Disclaimer: I am amongst the most anti-notation people around...)</p>",
        "id": 446357594,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719110087
    },
    {
        "content": "<p>As Kim says, I don't think we should be treating <code>Spec</code> differently from any other (concrete) functor. I'm not against eventually having notation that would unify <code>.obj</code> and <code>.map</code>.</p>",
        "id": 446401945,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1719138726
    },
    {
        "content": "<p>All the <code>.obj</code> and <code>.map</code> and <code>op</code> (which is <code>{ unop := _ }</code> in infoview) and <code>unop</code> are mathematically unimportant (and also not really important to Lean) noise that makes the statements 4x longer and almost unreadable.</p>",
        "id": 446404645,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1719139604
    },
    {
        "content": "<p>Maybe I'll just make <code>Spec R</code> mean <code>Scheme.Spec.obj (op R)</code> and <code>SpecMap f</code> mean <code>Scheme.Spec.map f.op</code> as ordinary abbrevs to avoid these notations.</p>",
        "id": 446404650,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1719139606
    },
    {
        "content": "<p>I think <code>Spec.obj</code> and <code>Spec.map</code> would be fine on its own, the <code>op R</code> and <code>f.op</code> (and the even worse <code>{ unop := _}</code>) are the annoying bits. Is there a way to make Lean interpet <code>Spec.map f</code> as <code>Spec.map f.op</code> and also pretty print <code>Spec.map f.op</code> as <code>Spec.map f</code>?</p>",
        "id": 446407781,
        "sender_full_name": "Christian Merten",
        "timestamp": 1719141016
    },
    {
        "content": "<p>Can't we make Lean pretty-print custom-named constructors?</p>",
        "id": 446415618,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1719146747
    },
    {
        "content": "<p>I don't think we ever want the constructor notation for them</p>",
        "id": 446415716,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1719146806
    },
    {
        "content": "<p>I'm also thinking about eg <code>Rat.mk'</code></p>",
        "id": 446415737,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1719146825
    },
    {
        "content": "<p>And in fact it would be nice if we could control what constructor notation does by defining <code>.mk</code> separately</p>",
        "id": 446416093,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1719147086
    },
    {
        "content": "<p>I'll open an RFC soonish</p>",
        "id": 446416104,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1719147097
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"648495\">@Christian Merten</span> If you add <code>@[pp_using_anonymous_constructor]</code> to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Opposite#doc\">docs#Opposite</a> then at least <code>{ unop := x }</code> pretty prints as <code>‚ü®x‚ü©</code> instead. (This is a feature as of Lean 4.8.0)</p>",
        "id": 446449444,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1719164656
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span> If you're talking about a Lean 4 RFC, could you discuss what you have in mind on Zulip before writing one?</p>",
        "id": 446449582,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1719164757
    },
    {
        "content": "<p>I think the summary is \"allow ‚ü®x, y, z‚ü© to resolve to a user-defined function, just like how we now allow <code>induction xyz</code> to do so\"</p>",
        "id": 446452677,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1719166249
    },
    {
        "content": "<p>Yeah the RFC would be to resolve <code>(‚ü®‚ü© : MyStruct)</code> notation to <code>MyStruct.mk</code>, regardless of whether <code>MyStruct.mk</code> is the default constructor or an arbitrary function.</p>",
        "id": 446466374,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1719172272
    },
    {
        "content": "<p>That way, we both:</p>\n<ul>\n<li>stop translation functions for one-field structure type synonyms (and generally any constructor which is supposed to be an implementation detail, or whose status as the default constructor should be an implementation detail)</li>\n<li>get to choose which function the <code>‚ü®‚ü©</code> notation refers to</li>\n</ul>",
        "id": 446467055,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1719172707
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Notation.20with.20letter-like.20symbols/near/446404650\">said</a>:</p>\n<blockquote>\n<p>Maybe I'll just make <code>Spec R</code> mean <code>Scheme.Spec.obj (op R)</code> and <code>SpecMap f</code> mean <code>Scheme.Spec.map f.op</code> as ordinary abbrevs to avoid these notations.</p>\n</blockquote>\n<p>This is an improvement, but I still object to having <code>Spec</code> and <code>SpecMap</code> in the first place. They are parts of a functor, so should look like it!</p>\n<p>Moreover, <code>SpecMap</code> breaks the casing rules, and I think this makes it <em>less</em> rather than <em>more</em> readable.</p>",
        "id": 446489997,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719187645
    },
    {
        "content": "<p>I don't agree with \"They are parts of a functor, so should look like it!\". Localization is a functor but we have <code>Localization</code> + <code>Localization.map</code>.  Tensor product is a functor but we don't write <code>((TensorProduct R).obj M).obj N</code></p>",
        "id": 446490668,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1719188243
    },
    {
        "content": "<p>How about having <code>SpecMap</code> -&gt; <code>Spec.map</code> that (I think) conforms to the naming convention?</p>",
        "id": 446490698,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1719188275
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Notation.20with.20letter-like.20symbols/near/446490698\">said</a>:</p>\n<blockquote>\n<p>How about having <code>SpecMap</code> -&gt; <code>Spec.map</code> that (I think) conforms to the naming convention?</p>\n</blockquote>\n<p>Simply as an abbrev /alias this would clash with <code>Scheme.Spec.map</code> after <code>open Scheme</code> right? We could of course just rename the functor <code>Scheme.Spec</code></p>",
        "id": 446530541,
        "sender_full_name": "Christian Merten",
        "timestamp": 1719211484
    },
    {
        "content": "<p>The other issue with <code>ùñ≤ùóâùñæùñº</code> is that it often isn't rendered as a monospace characters leading to misaligned text.</p>",
        "id": 446622474,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1719237755
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Notation.20with.20letter-like.20symbols/near/446314628\">said</a>:</p>\n<blockquote>\n<p>Is it possible to do this with a custom elaborator? Maybe even so that we can write <code>Spec R</code> and <code>Spec f</code> where <code>R</code> is a ring and <code>f</code> a ring hom?</p>\n</blockquote>\n<p>I would be interested in an experiment with this idea. In Lean 3 we couldn't do this. But in Lean 4 we should definitely try. Not just for <code>Spec</code>, but for functors in general.</p>",
        "id": 446713102,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1719261393
    },
    {
        "content": "<p>My reading of Kim's message is that making <code>F.obj</code> and <code>F.map</code> have the same spelling is not a good thing to aim for?</p>",
        "id": 446713807,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1719261624
    },
    {
        "content": "<p>I read Kim‚Äôs message as only necessarily saying that functors should have consistent spelling, i.e. this one functor shouldn‚Äôt look different from the rest.</p>\n<p>I‚Äôm not sure what they think about a proposal to change how <em>every</em> functor application looks at once (hopefully they will tell us!), but I‚Äôm personally generally in favor of ‚Äúreflect math notation as long as Lean is essentially doing the same thing‚Äù. As such I think having analogues of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">Fa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">a</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">Ff</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> (and even maybe <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>Œ∑</mi></mrow><annotation encoding=\"application/x-tex\">F\\eta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">Œ∑</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Œ∑</mi></mrow><annotation encoding=\"application/x-tex\">\\eta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">Œ∑</span></span></span></span> a natural transformation, with its standard meaning) would be reasonable! :) (Presumably with a <code>pp</code> option to turn this sort of delaboration off if it ever gets confusing, and maybe this notation would be <code>scoped</code>.)</p>",
        "id": 446717359,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1719262759
    },
    {
        "content": "<p>I guess you start getting into trouble when it just so happens that <code>F f</code> could be (mathematically) interpreted as <code>@map Dom Range F C D f</code> or <code>@obj (C ‚ü∂ D) Range' F </code>, namely when the same functor polymorphically acts on both objects and morphisms</p>",
        "id": 446718609,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1719263130
    },
    {
        "content": "<p>I have no in principle objection to something that hides both the <code>.obj</code> and <code>.map</code>, except for my basic total lack of understanding why people like notation. :-)</p>",
        "id": 446753427,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719279073
    },
    {
        "content": "<p>Makes the lean code closer to what humans write?</p>",
        "id": 446780427,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1719293333
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Notation.20with.20letter-like.20symbols/near/446466374\">said</a>:</p>\n<blockquote>\n<p>Yeah the RFC would be to resolve <code>(‚ü®‚ü© : MyStruct)</code> notation to <code>MyStruct.mk</code>, regardless of whether <code>MyStruct.mk</code> is the default constructor or an arbitrary function.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, does this sound reasonable as an RFC?</p>",
        "id": 446868951,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1719318842
    },
    {
        "content": "<p>Here are things the RFC should address:</p>\n<ul>\n<li>What are a few case studies for user-specified anonymous constructors? What are concrete examples of things you could do that you couldn't before? Why is it worth implementing this feature rather than having users create custom notation per structure? (For example, <code>MyStruct‚ü®a,b,c‚ü©</code> could be user syntax, without a space before <code>‚ü®</code>.)</li>\n<li>What are some possible mechanisms to configure which function to use as the anonymous constructor? What are pros/cons of each, which one does the RFC recommend?</li>\n<li>Do user-specified anonymous constructors need to be usable for pattern matching? That is, should they need to be able to be used as a <code>@[match_pattern]</code>? If not, what can be done to help reduce confusion?</li>\n<li>If so, do they need to integrate into <code>rcases</code> patterns? How would that work? If not, how can you prevent confusing users that angle brackets do something different in <code>rcases</code> patterns for types with user-specified anonymous constructors?</li>\n<li>What can we do in the UI to be sure that users can see which function is being used for anonymous constructor notation? Hovers in the Infoview should automatically show the custom <code>MyStruct.mk</code> function, but to what extent should hovering in the source code show which function is being used?</li>\n</ul>\n<p>For strong RFCs, I find the <a href=\"https://github.com/rust-lang/rfcs/blob/master/0000-template.md\">Rust RFC template</a> to be useful.</p>",
        "id": 446957388,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1719338381
    }
]