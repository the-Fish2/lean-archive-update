[
    {
        "content": "<p>When I'm looking at a goal like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">SemigroupCat</span>\n<span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">‚Üë</span><span class=\"o\">({</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">S</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"n\">WithOne</span> <span class=\"bp\">‚Üë</span><span class=\"n\">S</span><span class=\"o\">),</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">WithOne.map</span> <span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"bp\">‚ä¢</span> <span class=\"o\">(</span><span class=\"n\">WithOne.map</span> <span class=\"o\">(</span><span class=\"mi\">ùüô</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>I want to start by reducing the <code>{ obj := ..., ... }.obj</code> in the type of <code>y</code> to the value of the <code>obj</code> field. </p>\n<p>I feel like I'm going crazy --- doesn't simp (or dsimp) usually do this out of the box?</p>",
        "id": 438994156,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1715858390
    },
    {
        "content": "<p>When I've seen this fail in the past it's due to a semireducible type synonym being partially unfolded somewhere in the statement.</p>",
        "id": 438994343,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715858445
    },
    {
        "content": "<p>I can use <code>simp only [Prefunctor.mk_obj] at y</code>, but I can't make <code>Prefunctor.mk_obj</code> a simp lemma, because its head is a variable (after whnfR)!</p>",
        "id": 438994385,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1715858466
    },
    {
        "content": "<p>Hmm, so far failing to see anything wrong even with <code>pp.all</code>.</p>\n<p>Here's the code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">adjoinOne'</span> <span class=\"o\">:</span> <span class=\"n\">SemigroupCat.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">‚•§</span> <span class=\"n\">MonCat.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">where</span>\n  <span class=\"n\">obj</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">MonCat.of</span> <span class=\"o\">(</span><span class=\"n\">WithOne</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">WithOne.map</span>\n  <span class=\"n\">map_id</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ext</span> <span class=\"n\">y</span><span class=\"bp\">;</span> <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"bp\">*;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Prefunctor.mk_obj</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">y</span><span class=\"bp\">;</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">map_comp</span> <span class=\"o\">:=</span> <span class=\"n\">WithOne.map_comp</span>\n</code></pre></div>",
        "id": 438995042,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1715858705
    },
    {
        "content": "<p>The <code>simp only</code> shouldn't be needed, I hope.</p>",
        "id": 438995107,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1715858734
    },
    {
        "content": "<p><code>simp only at y</code> works here (but only after the <code>dsimp</code>)</p>",
        "id": 438995354,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715858833
    },
    {
        "content": "<p>In fact, <code>dsimp at y ‚ä¢</code> works too, it's <code>dsimp at *</code> that fails</p>",
        "id": 438995548,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715858901
    },
    {
        "content": "<p>Okay, that is a bit weird.</p>",
        "id": 438995570,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1715858910
    },
    {
        "content": "<p>Just <code>simp at y</code> seems fine too.</p>",
        "id": 438995613,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1715858924
    },
    {
        "content": "<p>Well, this <a href=\"#narrow/stream/113488-general/topic/Proving.20FLT.20with.20norm_num/near/429746342\">wouldn't be the first time</a> that <code>*</code> behaves weirdly</p>",
        "id": 438995743,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715858975
    }
]