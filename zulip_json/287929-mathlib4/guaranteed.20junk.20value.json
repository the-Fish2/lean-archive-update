[
    {
        "content": "<p>I had to define a power series which in the textbook was an infinite sum of <code>F n</code> starting from 1 and using a function which didn't make mathematical sense for n=0 (as 0 has infinitely many divisors). But it seemed easier to start at 0 rather than 1 in lean so I went for it, and it turned it that the junk value was 0 and simp could prove it so I won. But then I realised -- can I guarantee that the junk value won't change? I think the real square root of -1 changed at least once in mathlib. Here the junk value is that the Finset <code>Nat.divisors 0</code> is empty (as opposed to not being finite, which wouldn't typecheck).</p>",
        "id": 433592154,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713296187
    },
    {
        "content": "<p>Is <code>Real.sqrt -1</code> undefined behaviour? Could it oscillate again between 0 and 1?</p>",
        "id": 433592340,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713296275
    },
    {
        "content": "<p>You could add a lemma that states the current value and add a comment \"Kevin depends on this\"</p>",
        "id": 433593092,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1713296581
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.divisorsAntidiagonal_zero#doc\">docs#Nat.divisorsAntidiagonal_zero</a> is a lemma that states precisely this.</p>",
        "id": 433593542,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1713296796
    },
    {
        "content": "<p>Right but if someone came along with some brilliant argument why things would be better if the divisors of 0 were {1} and then fixed all the lemmas which were no longer true then would this be OK to merge?</p>",
        "id": 433617863,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713306824
    },
    {
        "content": "<p>Personally, I would try to avoid creating data (theorems are okay) that depends on junk values which can't be guaranteed. For instance, we don't do this with <code>Field</code>, we <em>require</em> <code>inv 0 = 0</code>.</p>",
        "id": 433618593,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713307212
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/guaranteed.20junk.20value/near/433617863\">said</a>:</p>\n<blockquote>\n<p>Right but if someone came along with some brilliant argument why things would be better if the divisors of 0 were {1} and then fixed all the lemmas which were no longer true then would this be OK to merge?</p>\n</blockquote>\n<p>Another guardrail could be inserted in the directory <code>test/</code> so that it is rejected by CI. But then, what happens if the PR also changes this testfile?</p>",
        "id": 433719938,
        "sender_full_name": "JoÃ«l Riou",
        "timestamp": 1713348598
    },
    {
        "content": "<p>You could have perhaps some kind of automation/linter that posts a message to a dedicated Zulip channel any time a given test file is modified, to catch this on time and interact with the PR before it merges?</p>",
        "id": 433720460,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1713348780
    },
    {
        "content": "<p>This just sounds like the very definition of undefined behaviour</p>",
        "id": 433734142,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713353898
    },
    {
        "content": "<p>I guess one experiment I can do is to change my F to \"if zero then zero else F\" and see what code breaks.</p>",
        "id": 433734354,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713353987
    },
    {
        "content": "<p>There is no technical solution within mathlib that can stop us from changing mathlib. A comment near the relevant lemma that we'd hopefully catch in review is the only real solution here, I think</p>",
        "id": 433746166,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1713357611
    },
    {
        "content": "<p>I'll say it again: I don't think defining data based on uncontrolled junk values is a wise approach.</p>",
        "id": 433750011,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713358691
    },
    {
        "content": "<p>The control can just be a theorem that says the junk value though.</p>",
        "id": 433754194,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1713359844
    },
    {
        "content": "<p>I'm not sure I agree. I'll think on it.</p>",
        "id": 433756459,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713360399
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/287929-mathlib4/topic/guaranteed.20junk.20value/near/433754194\">said</a>:</p>\n<blockquote>\n<p>The control can just be a theorem that says the junk value though.</p>\n</blockquote>\n<p>One of the earlier objections was that someone could always come along and change a test: the same could happen with your theorem.</p>\n<p>Also, implicit in this discussion, is the assertion that <code>1/0</code> returns a junk value, whereas there is a \"true\" value to assign to <code>1/1</code>: someone might come at some point and realise that formalization of some results would be much easier if the inverses of <code>0</code> and <code>1</code> were both <code>0</code> and everything else has their \"true\" inverse.  So, they refactor mathlib with this better definition.  Which one is the junk value now?</p>",
        "id": 433761822,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713361801
    },
    {
        "content": "<p>I think that whenever this situation happens the value becomes a little less junk</p>",
        "id": 433765761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713362165
    },
    {
        "content": "<p>the specific choice of junk value should be the one that makes the most nice theorems true. So if you found one such nice theorem then that reinforces that the junk value should stay that way, and if it changes whoever makes the change will have to weigh the advantages of the new definition against the disadvantage of making your proof worse</p>",
        "id": 433766884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713362268
    },
    {
        "content": "<p>Arguably, this happens even in regular mathematics: for a while people weren't clear on whether 1 should be a prime or not, but as the theorems come it becomes clearer which \"junk value\" is more correct</p>",
        "id": 433767494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713362321
    },
    {
        "content": "<p>I like Mario's description. However, in that case, I think we should maintain a list (this doesn't have to be exhaustive), perhaps in the docstring of the junk value theorem, that indicates the <code>def</code>s in which this junk value is used advantageously.</p>",
        "id": 433770326,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713362632
    },
    {
        "content": "<p>That's quite a maintenance burden, I fear. If we can somehow automatically produce such lists, that would be much better.</p>",
        "id": 433771827,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1713362790
    },
    {
        "content": "<p>Note, I'm not asking for it to be exhaustive. If it gets out of date, oh well. The idea is just to provide some information regarding \"hey, this value is used in these places to positive effect, maybe think twice before trying to change it.\"</p>",
        "id": 433773552,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713362973
    },
    {
        "content": "<p>But of course, if we could produce them automatically somehow then that would be cool. I guess if we had an attribute <code>@[junk_value_thm]</code> we could then search for all the <code>def</code>s in which this theorem appears in the term to produce such a list.</p>",
        "id": 433774505,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713363087
    },
    {
        "content": "<p>It likely wouldn't be perfect, but it could be a start.</p>",
        "id": 433774653,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713363105
    },
    {
        "content": "<p>I think it's not necessary to do that. If someone tries to refactor the definition which directly or indirectly changes the value, they will see right away all the downstream effects of this, at least within mathlib</p>",
        "id": 433775906,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713363248
    },
    {
        "content": "<p>score 1 for formal verification</p>",
        "id": 433776005,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713363261
    },
    {
        "content": "<p>Yes, but then you have to break things to know that it was used lots of places. And you might not see all the downstream uses right away because they may be blocked by the build failing earlier.</p>",
        "id": 433777572,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713363437
    }
]