[
    {
        "content": "<p>For the past few weeks, I've been exploring the machinery that would let you write something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">linting_rules</span> <span class=\"o\">:</span> <span class=\"n\">deprecated</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"n\">test</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"don't use test!\"</span>\n</code></pre></div>\n<p>where the <code>return</code>ed message would be shown whenever <code>test</code> was used in a tactic. (This was inspired by the desire to deprecate \"old-style\" <code>have</code> and <code>tfae_have</code> syntax; currently only declarations can be deprecated. See <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/deprecate.20syntax.3F\">#mathlib4 &gt; deprecate syntax?</a>)</p>\n<p>But more generally, I was curious as to what it would take to implement <code>foo_rules</code> commands in general, and, for a hypothetical <code>linting_rules</code>, provide extensible categories (like <code>: deprecated</code> above).</p>\n<p>Keep in mind this is primarily just an exploration for exploration's sake! (I'm happy to contribute if there's interest and demand, but more on that later—all I'll say here is \"performance concerns\". [EDIT: actually, those seem to have been fixed!]) And if you're interested, read on. :)</p>\n<h3>Generic syntax rules</h3>\n<p>This involves, first, making a generic framework for implementing <code>foo_rules</code> commands.</p>\n<p>If you haven't looked at the internals, the way <code>macro_rules</code> and <code>elab_rules</code> work under the hood is by attaching an attribute to a declaration. For example,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">fooStx</span><span class=\"bp\">|</span><span class=\"n\">foo</span> <span class=\"bp\">$</span><span class=\"n\">id</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>expands to (more or less)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">tactic</span> <span class=\"n\">fooStx</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">auto.generated.name</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">→</span> <span class=\"n\">TacticM</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">fooStx</span><span class=\"bp\">|</span><span class=\"n\">foo</span> <span class=\"bp\">$</span><span class=\"n\">id</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">no_error_if_unused</span><span class=\"bp\">%</span> <span class=\"n\">throwUnsupportedSyntax</span>\n</code></pre></div>\n<p>Note that <code>fooStx</code> is the syntax nodekind. The <code>tactic</code> attribute is keyed by this nodekind, and later, when elaborating tactic syntax with nodekind <code>fooStx</code>, we retrieve all declarations tagged with <code>@[tactic fooStx]</code> (then evaluate each of them on the syntax until we don't get an unsupported syntax exception).</p>\n<p>So if we want to implement our own <code>foo_rules</code>, we'll need to provide</p>\n<ul>\n<li>an attribute (like <code>tactic</code>) which is keyed by syntax nodekinds (or a name derived from it)</li>\n<li>a type (like <code>Syntax → TacticM Unit</code>) that the tagged decl should have (in the form of a name for technical reasons; for example, <code>Syntax → TacticM Unit</code> is actually the abbrev <code>Lean.Elab.Tactic.Tactic</code> in reality)</li>\n<li>a way of turning the <code>matchAlts</code> into a term (here, we take <code>alts</code> to <code> `(term|fun $alts:matchAlt*)</code> (after we've added the <code>_</code> case to <code>alts</code>)).</li>\n</ul>\n<p>So the first part of this exploration bundles all that data together into <code>SyntaxRuleData</code> (name pending); provides a syntax category <code>syntaxRulesHeader</code> where you can register e.g. <code>\"foo_rules\" \":\" ident</code> as header syntax for <code>matchAlts</code>; and provides a way to supply rules for turning that header syntax into <code>SyntaxRuleData</code>. (These implementations of headers are recorded behind the scenes using an attribute.)</p>\n<p>It also implements a couple nice macros, such that this part of implementing a <code>foo_rules</code> command looks like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- register `foo_rules : ident` as a header for match alts</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">fooRulesStx</span><span class=\"o\">)</span> <span class=\"s2\">\"foo_rules\"</span> <span class=\"s2\">\":\"</span> <span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">syntaxRulesHeader</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> provide the implementation data to use when encountering `foo_rules : $id:ident` as</span>\n<span class=\"cm\">a header to matchAlts (note that this doesn't include the `alts`) -/</span>\n<span class=\"n\">syntax_rules_header</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">fooRulesStx</span><span class=\"bp\">|</span><span class=\"n\">foo_rules</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"bp\">...</span>\n  <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">data</span> <span class=\"o\">:</span> <span class=\"n\">SyntaxRuleData</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Under the hood, <code>syntax_rules_header</code>, likewise, attaches a <code>@[syntax_rules_header_impl fooStx]</code> attribute. That's how we keep track of generic implementations.</p>\n<p>You never need to declare <code>command</code> syntax directly (after the above, <code>foo_rules : id | alt1 =&gt; sorry | alt2 =&gt; sorry ...</code> will already parse as a command, and do what you expect).</p>\n<p>To implement this, we actually just have <code>$header:syntaxRulesHeader $alts*</code> macro-expand to <code>syntax_rules (header := $header) $alts*</code>, and then implement <em>that</em> by searching for implementations tagged with <code>@[syntax_rules_header_impl _]</code> that apply to <code>$header</code>'s specific nodekind. (After that, we mirror the structure of <code>elab_rules</code>/<code>macro_rules</code>.)</p>\n<p>Now, what you <em>do</em> with the attribute you've included in <code>SyntaxRuleData</code> is totally up to you. All this infrastructure does is infer the syntax nodekind your <code>alts</code> apply to, insert your data in all the right places to make a decl using those rules, and tag the resulting decls with your specified attribute keyed by that nodekind.</p>\n<p>This is the content of the draft PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/11519\">#11519</a>. (Functional, but many TODOs, and documentation not written yet, as I'm not sure if there's interest from the community.)</p>\n<h3>Moving on to <code>linting_rules</code></h3>\n<p>Now it's easy to implement the core of <code>linting_rules</code>! The next step is getting the extensible <code>linting_rules</code> categories like <code>deprecated</code> working. To do that, we demand a bundle of data come with each <code>linting_rules</code> category declaration, namely:</p>\n<ul>\n<li>the name of the category (of course)</li>\n<li>the return type the user should be providing for each rule (for instance, in the example at the top, we wanted to return <code>MessageData</code>, but a different category than <code>deprecated</code> might ask for a different type)</li>\n<li>a way to turn that return type into <code>CommandElabM LintingRuleStep</code> (where <code>LintingRuleStep</code> tells us how to move through syntax: continue or stop descending)</li>\n<li>what option turns this linting category on or off (via <code>set_option</code>), so we know whether to lint with it</li>\n<li>plus some extra <code>stop</code> and <code>start</code> functions to override behavior, which can be convenient (e.g. stop before entering quotations, or don't even start linting until you're within a certain tactic syntax)</li>\n</ul>\n<p>We bundle that data in a  structure <code>LintingRulesCat</code>, and keep track of these categories with a very simple attribute <code>@[linting_rules_cat]</code>.</p>\n<p>Due to some restrictions, we can't actually retrieve a structure that stores <code>Type</code>s like that and use it where we need to (namely, in <code>CommandElabM</code>). (See <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4/topic/Recover.20arbitrary.20type.20from.20attribute.20data\">#lean4 &gt; Recover arbitrary type from attribute data</a> .) So in reality, we create decls for the incompatible data, make a different structure <code>LintingRulesCatImpl</code> behind the scenes which holds the names of those decls, and tag <em>that</em> structure with <code>@[linting_rules_cat]</code>. [EDIT: If you look at the PR now, this will have changed, since I’m testing different options for performance.] Luckily someone making a <code>linting_rules</code> category never has to worry about all this, because:</p>\n<p>We define a command <code>register_linting_rules_cat &lt;catName&gt; := &lt;catData&gt;</code> for registering categories, so that you actually only need to provide the data: the conversion to <code>LintingRulesCatImpl</code>, the addition of <code>@[linting_rules_cat]</code>, and also the registration of a new option (if you didn't decide to use an existing option) is taken care of for you. For example, the entirety of registering <code>deprecated</code> is quite simple:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">register_linting_rules_cat</span> <span class=\"n\">deprecated</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">Out</span> <span class=\"o\">:=</span> <span class=\"n\">MessageData</span>\n  <span class=\"n\">resolve</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">msg</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">logWarning</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">.</span><span class=\"n\">tagged</span> <span class=\"bp\">``</span><span class=\"n\">deprecatedAttr</span> <span class=\"n\">msg</span>\n    <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">done</span>\n  <span class=\"n\">opt</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">existing</span> <span class=\"n\">linter.deprecated</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>And it all works out! This lets us lint (and, in this case, deprecate) syntax using match-style rules:</p>\n<p><a href=\"/user_uploads/3121/tP9jyTV6LcezLdmW6mYLsbd8/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/tP9jyTV6LcezLdmW6mYLsbd8/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/tP9jyTV6LcezLdmW6mYLsbd8/image.png\"></a></div><p><del>Well...it works out as long as you don't look at performance.</del> <code>linting_rules</code> is the content of the draft PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/11520\">#11520</a> (likewise, functional, but many cleanup TODOs, and all the code is currently in one big file), <del>and the bench results show an increase of around 12% in interpretation. (It might be possible to get this down, though—I'm not sure what the limiting factor is, but I benched a simple dummy syntax-traversing linter (<a href=\"https://github.com/leanprover-community/mathlib4/pull/11523\">#11523</a>), and I don't think it's intrinsic to traversing syntax.)</del> EDIT: it’s now down to “no significant changes!</p>\n<p>Just to reiterate, this is all simply an exploration. If people like it, I'd be happy to get it PR-ready, including adding extensive documentation/step-by-step instructions so that anyone can use it and extend it easily and systematically. <del>But the performance issue might admittedly be a dealbreaker. Though, as we develop (and change) more notation, maybe linting it might be worth it—I'm not sure.</del> Plus, even if organized better for a PR, it is a nontrivial amount of code, entailing nontrivial review. The domain of applicability is rather specialized, too—but there's always more stuff to do with syntax, whether it's linting it, transforming it, formatting it in new ways, identifying features for manipulation, etc.</p>\n<p>Either way, it was a great way to learn more about attributes and command elaboration, so feel free to ask questions about the implementation if you're interested and/or let me know if you think this would be useful to have somewhere. :)</p>",
        "id": 427995563,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1710960498
    },
    {
        "content": "<p>Actually, I believe I’ve fixed the performance issues! <a href=\"https://github.com/leanprover-community/mathlib4/pull/11520\">#11520</a> is now at “no significant changes” (~3% increase in interpretation time) according to the latest bench. So I’m considering cleaning this up and PRing it formally. Maybe it could even be optimized further. :)</p>",
        "id": 428016799,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1710969285
    },
    {
        "content": "<p>I do not understand the implementation, but I do think that it is important to have mechanisms that make the code guide through the changes that continuously happen!</p>",
        "id": 428017760,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710969736
    },
    {
        "content": "<p>It is a nontrivial amount of stuff going on in the implementation, but happy to answer questions! :)</p>\n<p>Also a big part of “cleaning this up” before formally PRing will be including detailed explanations of what’s happening in the docstrings/module docs, as I think that’s essential for maintenance and usability. So hopefully that will help make it understandable!</p>",
        "id": 428018180,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1710969955
    }
]