[
    {
        "content": "<p>I would like to show in mathlib a generalized version of Dedekind's linear independence of characters using the same structure of the mathlib4 version, called <code>linearIndependent_monoidHom</code>. The difference is that instead of actual result</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">linearIndependent_monoidHom</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">NoZeroDivisors</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">L</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I want something like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.LinearIndependent</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">linearIndependent_mulHom</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">NoZeroDivisors</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">L</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">→ₙ*</span> <span class=\"n\">L</span> <span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But, for the result to be true, I need to add the condition that the homs f should be non-zero (e.g. <code>∃ x, f x ≠ 0</code>), I don't know how to do it with that format of the theorem. I am not asking for a proof of the result... just the statement.</p>",
        "id": 410820766,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1704189171
    },
    {
        "content": "<p>This should work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">linearIndependent_mulHom</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NoZeroDivisors</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">LinearIndependent</span> <span class=\"n\">L</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→ₙ*</span> <span class=\"n\">L</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 410821960,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704189694
    },
    {
        "content": "<p>The direct answer to your question is \"add the condition by using a subtype\"</p>",
        "id": 410822007,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704189717
    },
    {
        "content": "<p><code>fun f =&gt; f</code> would still work instead of <code>·</code></p>",
        "id": 410822106,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704189738
    },
    {
        "content": "<p>What it is the difference between writing <code> {f : G →ₙ* L // ∃ x, f x ≠ 0} </code> and <code>{f : G →ₙ* L  | ∃ x, f x ≠ 0} </code>? Because I don't understand how to \"extract\"  from <code>g:{f : G →ₙ* L // ∃ x, f x ≠ 0}</code> the fact that <code>∃ x, g x ≠ 0</code> in the first case... (in the second I have <code>g∈ {f : G →ₙ* L // ∃ x, f x ≠ 0}</code>, which is a Proposition).</p>",
        "id": 410834228,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1704196009
    },
    {
        "content": "<p>I know that the first one is a subtype, and the second a subset.</p>",
        "id": 410834615,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1704196265
    },
    {
        "content": "<p><code>g.prop</code></p>",
        "id": 410834804,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1704196382
    },
    {
        "content": "<p>Aha, or g.2 also works...</p>",
        "id": 410834878,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1704196435
    }
]