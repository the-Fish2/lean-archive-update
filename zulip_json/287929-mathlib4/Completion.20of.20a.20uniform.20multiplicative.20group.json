[
    {
        "content": "<p>In <code>Topology.Algebra.GroupCompletion</code> (<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Algebra/GroupCompletion.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Algebra/GroupCompletion.html</a>) it is proved that the completion of a uniform additive group is itself a uniform additive group and that it satisfies various properties including functoriality. I would like to \"multiplicativize\" this file; that is, rewrite it in the multiplicative setting and recover the original results using <code>@[to_additive]</code>. Does anyone have any thoughts on whether I should do this? If so, are there any particular difficulties I should watch out for?</p>",
        "id": 430520586,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1711931743
    },
    {
        "content": "<p>Okay, I have found one reason why this might be difficult. In my first attempt to multiplicativize this file, I changed this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Neg</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Neg</span> <span class=\"o\">(</span><span class=\"n\">Completion</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">Completion.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"bp\">-</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)⟩</span>\n</code></pre></div>\n<p>to this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Inv</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Inv</span> <span class=\"o\">(</span><span class=\"n\">Completion</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">Completion.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)⟩</span>\n</code></pre></div>\n<p>Unfortunately, this yields the error message \"failed to compile definition, consider marking it as 'noncomputable' because it depends on '<a href=\"http://UniformSpace.Completion.map\">UniformSpace.Completion.map</a>', and it does not have executable code\", which I do not really understand. Even if I mark it as <code>noncomputable</code>, though, there is another problem: if <code>α</code> is a field, this conflicts with the following definition of inverse on the completion of <code>α</code>, from <code>Topology.Algebra.UniformField</code> line 101.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">instInvCompletion</span> <span class=\"o\">:</span> <span class=\"n\">Inv</span> <span class=\"o\">(</span><span class=\"n\">hat</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"n\">hatInv</span> <span class=\"n\">x</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>One option is to only instantiate <code>Inv (Completion α)</code> if <code>α</code> is a group under multiplication:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Inv</span> <span class=\"o\">(</span><span class=\"n\">Completion</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">Completion.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)⟩</span>\n</code></pre></div>\n<p>Mathlib does successfully build with this change, but I am worried that it might break something else at some point.</p>\n<p>Here is my progress: <a href=\"https://github.com/leanprover-community/mathlib4/compare/trivial1711-multiplicative-completion\">https://github.com/leanprover-community/mathlib4/compare/trivial1711-multiplicative-completion</a></p>",
        "id": 430543178,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1711947353
    },
    {
        "content": "<p>Perhaps I should give up and accept that Mathlib doesn't put a group structure on the completion of a uniform multiplicative group. It probably isn't going to come up very often anyway.</p>",
        "id": 430543568,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1711947656
    },
    {
        "content": "<p>I don't really see a reason why this shouldn't all work, and it should be a good exercise. Why do you need it, out of interest? The multiplicative theory will not be any more or less computable than the additive theory.</p>",
        "id": 430553292,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711955101
    },
    {
        "content": "<p>Recently, I multiplicativized several files in <code>Topology.Algebra.InfiniteSum</code>, so they work with infinite products now too.</p>\n<p>Now, I want to add a few lemmas to <code>Topology.Algebra.InfiniteSum.Group</code> that involve completion:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span> <span class=\"n\">UniformAddGroup</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">UniformSpace.Completion</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">UniformSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">UniformAddGroup</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- A function `f` has a sum in an uniform additive group `α` if and only if it has that sum in the</span>\n<span class=\"sd\">completion of `α`. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">hasSum_iff_hasSum_compl</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">):</span>\n    <span class=\"n\">HasSum</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">HasSum</span> <span class=\"o\">(</span><span class=\"n\">toCompl</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- A function `f` is summable in a uniform additive group `α` if and only if it is summable in</span>\n<span class=\"sd\">`Completion α` and its sum in `Completion α` lies in the image of `toCompl : α →+ Completion α`. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">summable_iff_summable_compl_and_tsum_mem</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Summable</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"n\">Summable</span> <span class=\"o\">(</span><span class=\"n\">toCompl</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"bp\">∑'</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">toCompl</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">Set.range</span> <span class=\"n\">toCompl</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- A function `f` is summable in a uniform additive group `α` if and only if the net of its partial</span>\n<span class=\"sd\">sums is Cauchy and its sum in `Completion α` lies in the image of `toCompl : α →+ Completion α`.</span>\n<span class=\"sd\">(The condition that the net of partial sums is Cauchy can be checked using</span>\n<span class=\"sd\">`cauchySeq_finset_iff_sum_vanishing` or `cauchySeq_finset_iff_tsum_vanishing`.) -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">summable_iff_cauchySeq_finset_and_tsum_mem</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Summable</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"n\">CauchySeq</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">β</span> <span class=\"bp\">↦</span> <span class=\"bp\">∑</span> <span class=\"n\">b</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n      <span class=\"bp\">∑'</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">toCompl</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">Set.range</span> <span class=\"n\">toCompl</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- If a function `f` is summable in a uniform additive group `α`, then its sum in `α` is the same</span>\n<span class=\"sd\">as its sum in `Completion α`. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Summable.toCompl_tsum</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Summable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∑'</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∑'</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">toCompl</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">UniformAddGroup</span>\n</code></pre></div>\n<p>I was able to prove all of these lemmas (see <a href=\"https://github.com/leanprover-community/mathlib4/compare/master...trivial1711-complete-sums\">https://github.com/leanprover-community/mathlib4/compare/master...trivial1711-complete-sums</a>), but now they are the only statements in the whole file that don't have a multiplicative analogue. And that annoys me. But unfortunately, I can't state the multiplicative analogue of these statements until <code>Topology.Algebra.GroupCompletion</code> is multiplicativized.</p>\n<p>I admit, however, that my own mild annoyance might not be a very good reason to want mathlib to recognize the completion of a uniform multiplicative group as a group.</p>",
        "id": 430561302,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1711960150
    },
    {
        "content": "<p>Also, <code>Topology.Algebra.GroupCompletion</code> already starts with <code>noncomputable section</code>, so I think those instances were already noncomputable. But it seems that if you put <code>@[to_additive]</code>on the instances, you have to declare them noncomputable again, even though they're in a <code>noncomputable section</code>.</p>",
        "id": 430565148,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1711962391
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>, this looks like a <code>to_additive</code> bug</p>",
        "id": 430574997,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711967977
    },
    {
        "content": "<p>Apart from completions of groups, I wonder if you'll need completions of groups with zero.</p>",
        "id": 430580538,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1711971545
    },
    {
        "content": "<p>This looks like <a href=\"https://github.com/leanprover/lean4/pull/2610\">lean4#2610</a>.</p>",
        "id": 430654336,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1712001418
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span></p>",
        "id": 430654671,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1712001563
    },
    {
        "content": "<p>You might just want <code>suppress_compilation</code> at the top of the file if you don't care about code generation for your completed groups.</p>",
        "id": 430656431,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1712002286
    },
    {
        "content": "<p>Okay, I've made the completion of a uniform multiplicative group into a PR: <a href=\"https://github.com/leanprover-community/mathlib4/pull/11837\">#11837</a></p>",
        "id": 430713834,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712034929
    },
    {
        "content": "<p>There's some slight awkwardness here with the definition of multiplication; this PR introduces</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Mul</span> <span class=\"o\">(</span><span class=\"n\">Completion</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">Completion.map₂</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">*</span> <span class=\"bp\">·</span><span class=\"o\">)⟩</span>\n</code></pre></div>\n<p>but we already have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">mul</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Mul</span> <span class=\"o\">(</span><span class=\"n\">Completion</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">curry</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">denseInducing_coe.prod</span> <span class=\"n\">denseInducing_coe</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">extend</span> <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">uncurry</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">*</span> <span class=\"bp\">·</span><span class=\"o\">))⟩</span>\n</code></pre></div>\n<p>Are these definitions compatible?</p>",
        "id": 430881395,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712095075
    },
    {
        "content": "<p>Thanks for catching that. I think this is actually a big problem. These are (propositionally) equal if multiplication is continuous, but if it isn't, then I am not sure.</p>",
        "id": 430885085,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712096664
    },
    {
        "content": "<p>Never mind, these are not even propositionally equal. <code>Completion.map₂</code> just returns some junk value if used on a function that isn't uniformly continuous. Such as multiplication on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>, for example. So the definition using <code>Completion.map₂</code> just doesn't work for rings at all.</p>",
        "id": 430887195,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712097808
    },
    {
        "content": "<p>A ring is never a group -- can you restrict to groups?</p>",
        "id": 430887527,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712097987
    },
    {
        "content": "<p>Yeah, that is the most obvious answer. Unfortunately, the zero ring is a group. I don't know if this would actually create a bad diamond, though, because it might not actually have a <code>Group</code> instance on it.</p>",
        "id": 430887823,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712098158
    },
    {
        "content": "<p>Also, I don't know if this bad diamond would actually matter.</p>",
        "id": 430888062,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712098291
    },
    {
        "content": "<p>I don't have a great understanding of the pitfalls of typeclass inference and how to avoid them.</p>",
        "id": 430888225,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712098392
    },
    {
        "content": "<p>Does the <code>Ring</code> definition of <code>*</code> make sense on groups? If the group version just has weird junk values, perhaps they can be changed to match the junk values used by rings.</p>",
        "id": 430888437,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712098516
    },
    {
        "content": "<p>I think the ring definition makes sense for groups. Some of the proofs in <code>Topology/Algebra/GroupCompletion</code> would have to be reworked, but that seems worth it.</p>",
        "id": 430888878,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712098776
    },
    {
        "content": "<p>Presumably the result would be that many of the results would generalize to uniform completions of monoids?</p>",
        "id": 430889128,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712098874
    },
    {
        "content": "<p>So we could just do this. I think.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kd\">instance</span> <span class=\"n\">mul</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Mul</span> <span class=\"o\">(</span><span class=\"n\">Completion</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">curry</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">denseInducing_coe.prod</span> <span class=\"n\">denseInducing_coe</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">extend</span> <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">uncurry</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">*</span> <span class=\"bp\">·</span><span class=\"o\">))⟩</span>\n</code></pre></div>",
        "id": 430889158,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712098885
    },
    {
        "content": "<p>Maybe some of the results could be generalized to monoids in which the multiplication is uniformly continuous. This is not currently a typeclass in mathlib, though.</p>",
        "id": 430889658,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712099146
    },
    {
        "content": "<p>(This is probably because every topological group has a canonical uniformity that makes it into a uniform group, but topological monoids do not.)</p>",
        "id": 430890113,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712099371
    },
    {
        "content": "<p>(Okay, maybe this is wrong; sorry.)</p>",
        "id": 430890930,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712099882
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"695266\">Mitchell Lee</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Completion.20of.20a.20uniform.20multiplicative.20group/near/430889158\">said</a>:</p>\n<blockquote>\n<p>So we could just do this. I think.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kd\">instance</span> <span class=\"n\">mul</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Mul</span> <span class=\"o\">(</span><span class=\"n\">Completion</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">curry</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">denseInducing_coe.prod</span> <span class=\"n\">denseInducing_coe</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">extend</span> <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">uncurry</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">*</span> <span class=\"bp\">·</span><span class=\"o\">))⟩</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I just did it: <a href=\"https://github.com/leanprover-community/mathlib4/tree/trivial1711-multiplicative-completion\">https://github.com/leanprover-community/mathlib4/tree/trivial1711-multiplicative-completion</a>. By \"it\", I mean this. Let <code>α</code> be a uniform space with an addition operation. I changed the definition of addition on <code>Completion α</code> to use <code>DenseInducing.extend</code> instead of <code>Completion.map₂</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Add</span> <span class=\"o\">(</span><span class=\"n\">Completion</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">curry</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">denseInducing_coe.prod</span> <span class=\"n\">denseInducing_coe</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">extend</span> <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">uncurry</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"bp\">·</span><span class=\"o\">))⟩</span>\n</code></pre></div>\n<p>Everything in mathlib still works, after a few tweaks to some of the proofs in <code>Mathlib/Topology/Algebra/GroupCompletion.lean</code>. If addition on<code>α</code> is uniformly continuous, then the new definition is propositionally equal to the old one. If addition on <code>α</code> is not uniformly continuous, then the new definition yields sensible values whereas the old definition yields junk values.</p>\n<p>With this new definition, everything can be multiplicativized. We end up with </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Mul</span> <span class=\"o\">(</span><span class=\"n\">Completion</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">curry</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">denseInducing_coe.prod</span> <span class=\"n\">denseInducing_coe</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">extend</span> <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">uncurry</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">*</span> <span class=\"bp\">·</span><span class=\"o\">))⟩</span>\n</code></pre></div>\n<p>which is the exact definition of multiplication on uniform rings currently in <code>Mathlib/Topology/Algebra/UniformRing.lean</code>. This gets rid of the bad diamond that <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span>  thankfully pointed out. And we can even delete the definition of multiplication on uniform rings in <code>Mathlib/Topology/Algebra/UniformRing.lean</code> because it's redundant.</p>\n<p>I will try to make a pull request soon.</p>",
        "id": 431229939,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712210229
    },
    {
        "content": "<p>Okay, here it is: <a href=\"https://github.com/leanprover-community/mathlib4/pull/11837\">#11837</a>.</p>",
        "id": 431236341,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712213515
    },
    {
        "content": "<p>Thanks so much for unraveling all this!</p>",
        "id": 431237910,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712214339
    },
    {
        "content": "<p>Is <code>map</code> / <code>map2</code> useful at all with the current definition? Should we redefine it to use <code>extend</code>?</p>",
        "id": 431241445,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712215456
    },
    {
        "content": "<p>The definition of <code>UniformSpace.Completion.map</code> already uses <code>denseInducing_coe.extend</code>.</p>\n<p><code>UniformSpace.Completion.map f</code> is equal to <code>denseInducing_coe.extend ((↑) ∘ f)</code> if <code>f</code> is uniformly continuous. Otherwise, it is just some arbitrary constant function. This is by design; it has the advantage that it is always continuous, no matter what <code>f</code> is. However, it is probably not the best choice for defining operations on a uniform space.</p>",
        "id": 431358156,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712248837
    },
    {
        "content": "<p>Hello, I have just run into a small problem. Recall the trick we use to define inversion and negation on uniform spaces. The idea is that we define negation on the completion of any uniform space that has a negation operation, but we define inversion on only the completion of a uniform space that has the structure of a multiplicative group. This avoids creating a bad diamond with the inversion operation on a uniform field. Here is a snippet that demonstrates this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">UniformSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Inv</span> <span class=\"o\">(</span><span class=\"n\">Completion</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n\n<span class=\"c1\">-- more general instance which is definitionally equal to the more specific one defined above</span>\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">UniformSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Neg</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Neg</span> <span class=\"o\">(</span><span class=\"n\">Completion</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>The problem is this. Suppose you prove a theorem about the inversion operation on <code>Completion α</code>, and you use <code>@[to_additive]</code> on that theorem. Then, the additivized version will have the possibly unnecessary assumption <code>[AdditiveGroup α]</code>. I made a comment here that describes this problem in detail: <a href=\"https://github.com/leanprover-community/mathlib4/pull/11837\">#11837</a></p>\n<p>Can anyone suggest how to work around this?</p>",
        "id": 431462489,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712302108
    }
]