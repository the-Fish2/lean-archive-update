[
    {
        "content": "<p>I'm wondering if people have any advice for dealing with <code>ᵒᵖ</code> when doing CategoryTheory in mathlib. I'm working with presheaves right now, so they show up all over the place. Are there tactics that are made to handle this?</p>\n<p>For example, right now I've got <code>X : Cᵒᵖ</code> in a premise and <code>unop X</code> showing up in a goal. Of course, I can pattern match on X, and then the <code>unop</code> will reduce, but doing this every time for every single ᵒᵖ seems cumbersome, and the exact kind of thing Lean's tactics are good at dealing with. And I'm sure I'm hardly the first person who's had to deal with <code>ᵒᵖ</code> a bunch.</p>\n<p>I'm not new to dependent types but I'm still very new to Lean and its tactics, so it's likely I'm missing something obvious.</p>",
        "id": 422447863,
        "sender_full_name": "Joey Eremondi",
        "timestamp": 1708444504
    },
    {
        "content": "<p>We tend to use the simplifier extensively in the CategoryTheory library. The simp lemmas should have been set up to make things as seamless as possible (although I concede that some pain points still exist when dealing with opposites).</p>",
        "id": 422448762,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1708444739
    },
    {
        "content": "<p>If you have an example illustrating some frustrations, please share it and we can try to give some advice about how to do things in an idiomatic way</p>",
        "id": 422448901,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1708444775
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> has marked this topic as resolved.</p>",
        "id": 422450250,
        "sender_full_name": "Notification Bot",
        "timestamp": 1708445121
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> has marked this topic as unresolved.</p>",
        "id": 422450270,
        "sender_full_name": "Notification Bot",
        "timestamp": 1708445125
    },
    {
        "content": "<p>Sorry, that was me wildly clicking in an attempt to move this thread to <a class=\"stream\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4\">#mathlib4</a> where it belongs (I've concluded that I can't do it).</p>",
        "id": 422450509,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708445188
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>  Here's an example of a goal I feel should be trivial that isn't (as far as I can see)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Types</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Category.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Opposite</span>\n\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span>\n<span class=\"kn\">open</span> <span class=\"n\">Opposite</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CCat</span> <span class=\"o\">:</span> <span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span>  <span class=\"n\">C</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">opMap</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"bp\">Γ</span> <span class=\"bp\">Δ</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">θ</span> <span class=\"o\">:</span> <span class=\"bp\">Δ</span> <span class=\"bp\">⟶</span> <span class=\"bp\">Γ</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">F</span> <span class=\"bp\">Γ</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">F</span> <span class=\"bp\">Δ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">Δ</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">θ</span> <span class=\"o\">:</span> <span class=\"bp\">Δ</span> <span class=\"bp\">⟶</span> <span class=\"bp\">Γ</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"bp\">Γ</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"bp\">Δ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intros</span> <span class=\"n\">a</span>\n    <span class=\"n\">aesop_cat</span> <span class=\"c1\">--fails</span>\n</code></pre></div>\n<p>Basically this is the first part of a \"constructor\" for a presheaf: you have a mapping from objects to sets (types), and a contravariant way to lift arrows into functions between sets. I want to show that this gives a way to take an arrow in <code>Cᵒᵖ</code> into an arrow in <code>Type</code>, like what the <code>map</code> field of <code>Functor</code> wants.</p>\n<p>It seems like it should be trivial, but the only way I can see to do it is pattern matching on <code>Γ</code> and <code>Δ</code>, which is very verbose, and isn't going to scale well as the number of objects in scope increases.</p>",
        "id": 422453300,
        "sender_full_name": "Joey Eremondi",
        "timestamp": 1708446004
    },
    {
        "content": "<p>can you please provide a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ?</p>",
        "id": 422453450,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1708446044
    },
    {
        "content": "<p>2 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4/topic/Dealing.20with.20.02klzzwxh.3A0000.03.20doing.20Category.20Theory.20in.20Mathlib\">#lean4 &gt; Dealing with <code>op</code> doing Category Theory in Mathlib</a> by <span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span>.</p>",
        "id": 422453633,
        "sender_full_name": "Notification Bot",
        "timestamp": 1708446093
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384488\">@Joey Eremondi</span> I moved your messages to the #mathlib4 stream which is more appropriate for this question, as Kevin mentions above.</p>",
        "id": 422453722,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1708446118
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> Sorry, I added the imports so it's now self-contained</p>",
        "id": 422453992,
        "sender_full_name": "Joey Eremondi",
        "timestamp": 1708446193
    },
    {
        "content": "<p>are you sure you don't need to flip the domain and codomain of theta?</p>",
        "id": 422454341,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1708446292
    },
    {
        "content": "<p>I mean, in this case it's quite straightforward and one shouldn't use a heavy tactic such as <code>aesop</code> anyway:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span> <span class=\"n\">Opposite</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span>  <span class=\"n\">C</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">opMap</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"bp\">Γ</span> <span class=\"bp\">Δ</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">θ</span> <span class=\"o\">:</span> <span class=\"bp\">Δ</span> <span class=\"bp\">⟶</span> <span class=\"bp\">Γ</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">F</span> <span class=\"bp\">Γ</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">F</span> <span class=\"bp\">Δ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">Δ</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">θ</span> <span class=\"o\">:</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⟶</span> <span class=\"bp\">Δ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"bp\">Γ</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"bp\">Δ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">opMap</span> <span class=\"n\">θ.unop</span>\n</code></pre></div>",
        "id": 422454611,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1708446375
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> Ah shoot you're right, I had it right in my actual version but messed it up making the MWE. Thanks.<br>\nAnd I missed that you can directly unop morphisms too. So I think I'm just (a) massively overthinking this and (b) still needing to read more docs.</p>\n<p>Thanks for the help and sorry for the foncusion</p>",
        "id": 422455512,
        "sender_full_name": "Joey Eremondi",
        "timestamp": 1708446636
    },
    {
        "content": "<p>I would say that in general the automation could have some issues with op/unop because many tactics work by looking at terms syntactically.</p>",
        "id": 422455692,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1708446694
    },
    {
        "content": "<p>For example in this case if there were no ops, then aesop_cat would(should?) be able to solve the goal (modulo flipping the domain/codomain of theta again). But it doesn't work with op, I think essentially for this reason.</p>",
        "id": 422455867,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1708446741
    },
    {
        "content": "<p>And yes, once you get used to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Opposite.op#doc\">docs#Opposite.op</a> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Opposite.unop#doc\">docs#Opposite.unop</a> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quiver.Hom.op#doc\">docs#Quiver.Hom.op</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quiver.Hom.unop#doc\">docs#Quiver.Hom.unop</a> (and the associated API) things do become much more manageable</p>",
        "id": 422456055,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1708446789
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> One more quick question since you're here and know your stuff, are there tactics for dealing with category-theoretic isomorphisms? E.g. that let you <code>rw</code> or <code>simp</code> by an isomorphism between objects? Or is the best thing just to call <code>.hom</code> on the isomorphism and explicitly apply that?</p>",
        "id": 422457499,
        "sender_full_name": "Joey Eremondi",
        "timestamp": 1708447212
    },
    {
        "content": "<p>You can't rewrite/simp with an isomorphism, but there are tools that help in constructing isomorphisms (like <code>calc</code> mode). Again, it would be helpful to see an example.</p>",
        "id": 422457845,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1708447340
    },
    {
        "content": "<p>Again, the simplifier is the key here. When you define an isomorphism and use <code>simps</code> that will automatically generate simp lemmas that let you work with the isomorphism using the simplifier.</p>",
        "id": 422457948,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1708447382
    },
    {
        "content": "<p>To rewrite with isomorphisms we'd likely need to implement something like this: <a href=\"https://cs.au.dk/~spitters/Emil.pdf\">https://cs.au.dk/~spitters/Emil.pdf</a> (congruence closure type stuff but with univalent equality instead of proof irrelevant equality)</p>",
        "id": 422506162,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1708465294
    }
]