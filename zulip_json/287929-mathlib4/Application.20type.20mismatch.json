[
    {
        "content": "<p>The following example is a bit long, since I need to introduce some definitions, so I am omitting the proofs. My question is about the last <code>have</code> in the code below. The Lean 3 version of this code worked, but in Lean 4 I get the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"bp\">@</span><span class=\"n\">isNonarchimedean_finset_image_add</span> <span class=\"bp\">?</span><span class=\"n\">m.281248</span> <span class=\"n\">K</span> <span class=\"n\">NormedRing.toRing</span> <span class=\"bp\">?</span><span class=\"n\">m.281251</span> <span class=\"bp\">?</span><span class=\"n\">m.281252</span> <span class=\"n\">hna</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">hna</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">IsNonarchimedean</span> <span class=\"n\">norm</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">IsNonarchimedean</span> <span class=\"bp\">⇑?</span><span class=\"n\">m.281252</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>My guess is that this is because<code>IsNonarchimedean</code> is defined for functions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>→</mo><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">R \\to \\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> while the theorem  <code>isNonarchimedean_finset_image_add</code> is stated in terms of <code>AddGroupSeminormClass</code>. Is this right? What would be the preferred way to fix this proof?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Normed.Ring.Seminorm</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Seminorm</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.NormedSpace.BoundedLinearMaps</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"sd\">/-- A function `f : R → ℝ≥0` is nonarchimedean if it satisfies the strong triangle inequality</span>\n<span class=\"sd\">  `f (r + s) ≤ max (f r) (f s)` for all `r s : R`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">IsNonarchimedean</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddGroup</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span>\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"sd\">/-- Given a nonarchimedean additive group seminorm `f` on `α`, a function `g : β → α` and a finset</span>\n<span class=\"sd\">  `t : finset β`, we can always find `b : β`, belonging to `t` if `t` is nonempty, such that</span>\n<span class=\"sd\">  `f (t.sum g) ≤ f (g b)` . -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">isNonarchimedean_finset_image_add</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddGroupSeminormClass</span> <span class=\"n\">F</span> <span class=\"n\">α</span> <span class=\"n\">ℝ</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hna</span> <span class=\"o\">:</span> <span class=\"n\">IsNonarchimedean</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hβ</span> <span class=\"o\">:</span> <span class=\"n\">Nonempty</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">t.Nonempty</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">t.sum</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedField</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- The function sending an element `x : L` to the maximum of the norms of its coefficients</span>\n<span class=\"sd\">  with respect to the `K`-basis `B` of `L`.-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Basis.norm</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Nonempty</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Basis</span> <span class=\"n\">ι</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">‖</span><span class=\"n\">B.equivFun</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">Classical.choose</span> <span class=\"o\">(</span><span class=\"n\">Finite.exists_max</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">‖</span><span class=\"n\">B.equivFun</span> <span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"bp\">‖</span><span class=\"o\">))</span><span class=\"bp\">‖</span>\n\n<span class=\"sd\">/-- Given a fintype `α`, a function `f : α → M` and a linear equivalence `g : M ≃ₛₗ[σ] N`, we have</span>\n<span class=\"sd\">  `g (∑ (i : α), f i) = ∑ (i : α), g (f i)`.  -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">LinearEquiv.map_finset_sum</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">σ'</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→+*</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">RingHomInvPair</span> <span class=\"n\">σ</span> <span class=\"n\">σ'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">RingHomInvPair</span> <span class=\"n\">σ'</span> <span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">S</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">≃ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- For any `K`-basis of `L`, `B.norm` is bounded with respect to multiplication. That is,</span>\n<span class=\"sd\">  `∃ (c : ℝ), c &gt; 0` such that ` ∀ (x y : L), B.norm (x * y) ≤ c * B.norm x * B.norm y`. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">norm_is_bdd</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Nonempty</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Basis</span> <span class=\"n\">ι</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hBi</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hna</span> <span class=\"o\">:</span> <span class=\"n\">IsNonarchimedean</span> <span class=\"o\">(</span><span class=\"n\">Norm.norm</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">B.norm</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">B.norm</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">B.norm</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">classical</span>\n  <span class=\"c1\">-- The bounding constant `c` will be the maximum of the products `B.norm (B i * B j)`.</span>\n  <span class=\"n\">set</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">Classical.choose</span> <span class=\"o\">(</span><span class=\"n\">Finite.exists_max</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">×</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">B.norm</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">i.1</span> <span class=\"bp\">*</span> <span class=\"n\">B</span> <span class=\"n\">i.2</span><span class=\"o\">))</span> <span class=\"k\">with</span> <span class=\"n\">hc_def</span>\n  <span class=\"k\">have</span> <span class=\"n\">hc</span> <span class=\"o\">:=</span> <span class=\"n\">Classical.choose_spec</span> <span class=\"o\">(</span><span class=\"n\">Finite.exists_max</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">×</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">B.norm</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">i.1</span> <span class=\"bp\">*</span> <span class=\"n\">B</span> <span class=\"n\">i.2</span><span class=\"o\">))</span>\n  <span class=\"n\">use</span> <span class=\"n\">B.norm</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">c.1</span> <span class=\"bp\">*</span> <span class=\"n\">B</span> <span class=\"n\">c.2</span><span class=\"o\">)</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"c1\">-- ∀ (x y : L), B.norm (x * y) ≤ B.norm (⇑B c.fst * ⇑B c.snd) * B.norm x * B.norm y</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n    <span class=\"c1\">-- `ixy` is an index for which `‖B.equivFun (x*y) i‖` is maximum.</span>\n    <span class=\"n\">set</span> <span class=\"n\">ixy</span> <span class=\"o\">:=</span> <span class=\"n\">Classical.choose</span> <span class=\"o\">(</span><span class=\"n\">Finite.exists_max</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">‖</span><span class=\"n\">B.equivFun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">i</span><span class=\"bp\">‖</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n      <span class=\"n\">hixy_def</span>\n    <span class=\"c1\">-- We rewrite the LHS using `ixy`.</span>\n    <span class=\"n\">conv_lhs</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Basis.norm</span><span class=\"o\">]</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hixy_def</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Basis.sum_equivFun</span> <span class=\"n\">B</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Basis.sum_equivFun</span> <span class=\"n\">B</span> <span class=\"n\">y</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sum_mul</span><span class=\"o\">,</span> <span class=\"n\">LinearEquiv.map_finset_sum</span><span class=\"o\">,</span> <span class=\"n\">sum_apply</span><span class=\"o\">]</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">smul_mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">LinearEquiv.map_smul</span><span class=\"o\">,</span> <span class=\"n\">mul_sum</span><span class=\"o\">,</span> <span class=\"n\">LinearEquiv.map_finset_sum</span><span class=\"o\">,</span>\n      <span class=\"n\">mul_smul_comm</span><span class=\"o\">,</span> <span class=\"n\">LinearEquiv.map_smul</span><span class=\"o\">]</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> Since the norm is nonarchimidean, the norm of a finite sum is bounded by the maximum of the</span>\n<span class=\"cm\">          norms of the summands. -/</span>\n    <span class=\"k\">have</span> <span class=\"n\">hk</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hk</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span> <span class=\"bp\">→</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">univ</span><span class=\"o\">),</span>\n        <span class=\"bp\">‖∑</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">B.equivFun</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"bp\">∑</span> <span class=\"n\">i_1</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">B.equivFun</span> <span class=\"n\">y</span> <span class=\"n\">i_1</span> <span class=\"bp\">•</span> <span class=\"n\">B.equivFun</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">B</span> <span class=\"n\">i_1</span><span class=\"o\">))</span> <span class=\"n\">ixy</span><span class=\"bp\">‖</span> <span class=\"bp\">≤</span>\n          <span class=\"bp\">‖</span><span class=\"o\">(</span><span class=\"n\">B.equivFun</span> <span class=\"n\">x</span> <span class=\"n\">k</span> <span class=\"bp\">•</span> <span class=\"bp\">∑</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">B.equivFun</span> <span class=\"n\">y</span> <span class=\"n\">j</span> <span class=\"bp\">•</span> <span class=\"n\">B.equivFun</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">k</span> <span class=\"bp\">*</span> <span class=\"n\">B</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"n\">ixy</span><span class=\"bp\">‖</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">apply</span> <span class=\"n\">isNonarchimedean_finset_image_add</span> <span class=\"n\">hna</span>\n        <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">B.equivFun</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"bp\">∑</span> <span class=\"n\">i_1</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">B.equivFun</span> <span class=\"n\">y</span> <span class=\"n\">i_1</span> <span class=\"bp\">•</span> <span class=\"n\">B.equivFun</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">B</span> <span class=\"n\">i_1</span><span class=\"o\">))</span> <span class=\"n\">ixy</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"c1\">-- error</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 416007124,
        "sender_full_name": "María Inés de Frutos Fernández",
        "timestamp": 1705490906
    },
    {
        "content": "<p>My guess: <code>hna</code> is a proof that <code>norm</code> is nonarchimedean, but apparently the function <code>isNonarchimedean_finset_image_add</code> which you're using wants a proof that <code>(⇑(something))</code> is nonarchimedean, and in Lean 3 there was some definitional abuse going on which made it work fine, but because coercions have changed this trick no longer works. </p>\n<p>So now let me show my ignorance: <code>norm</code> is this function <code>K -&gt; Real</code> coming from the <code>NormedField</code> instance, but what should the type <code>F</code> be such that the instance <code>AddGroupSeminormClass F K ℝ</code> exists and there's some term of type <code>F</code> which will coerce to <code>norm</code>?</p>",
        "id": 416088287,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705514241
    },
    {
        "content": "<p><code>F</code> could be <code>MulRingNorm K</code> (or <code>AddGroupSeminorm K</code>) and the term of type <code>F</code> that I want to use is <code>NormedField.toMulRingNorm K</code>. The problem is that, in Lean 4, even if I try to use an intermediate</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">hna'</span> <span class=\"o\">:</span> <span class=\"n\">IsNonarchimedean</span> <span class=\"o\">(</span><span class=\"n\">NormedField.toMulRingNorm</span> <span class=\"n\">K</span> <span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">hna</span>\n</code></pre></div>\n<p>this <code>hna'</code> is a proof of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">IsNonarchimedean</span> <span class=\"o\">(</span><span class=\"n\">NormedField.toMulRingNorm</span> <span class=\"n\">K</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toMulRingSeminorm.toAddGroupSeminorm.toFun</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>while the type of the corresponding Lean 3 version was indeed</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">is_nonarchimedean</span> <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">normed_field.to_mul_ring_norm</span> <span class=\"n\">K</span><span class=\"o\">)</span><span class=\"bp\">.</span>\n</code></pre></div>",
        "id": 416562874,
        "sender_full_name": "María Inés de Frutos Fernández",
        "timestamp": 1705581609
    },
    {
        "content": "<p>coercions in Lean 4 are still black magic to me, unfortunately :-(</p>",
        "id": 416641229,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705608366
    },
    {
        "content": "<p>I have managed to fix the proof by doing</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">hna'</span> <span class=\"o\">:</span> <span class=\"n\">IsNonarchimedean</span> <span class=\"o\">(</span><span class=\"n\">NormedField.toMulRingNorm</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">hna</span>\n<span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">AddGroupSeminorm.toFun_eq_coe</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hna'</span>\n</code></pre></div>\n<p>and then replacing <code>hna</code> by <code>hna'</code> in the call to <code>isNonarchimedean_finset_image_add</code>.</p>",
        "id": 416731442,
        "sender_full_name": "María Inés de Frutos Fernández",
        "timestamp": 1705653649
    },
    {
        "content": "<p>Nice! There is surely some more idiomatic way to do this but I don't know it</p>",
        "id": 416733175,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705654441
    }
]