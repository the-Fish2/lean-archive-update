[
    {
        "content": "<p>I've noticed the following \"issue\" when adding some API for <code>Cat</code>, see <a href=\"https://github.com/leanprover-community/mathlib4/blob/f79b385789c6b8bb0447bdd87676d7c9d996152c/Mathlib/CategoryTheory/Category/Cat.lean\">file</a>. For example the lemma <code>whiskerRight_left</code> is reduced by simp to something that follows from <code>Category.comp_id</code>, but simp is unable to close this final goal. So the following is a proof of the lemma (note that rfl also works, but thats beside my point here):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">whiskerRight_left</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">◁</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">▷</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">◁</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">▷</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">erw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category.comp_id</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>The final <code>erw</code> can not be replaced by <code>rw</code>. I would want this to be solvable by <code>simp</code> already. Is this an issue, or am I asking for too much since this is equalities of functors, which is bad?</p>",
        "id": 444645832,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1718352963
    },
    {
        "content": "<p>Can you make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ? I don't know how to get the triangles working.</p>",
        "id": 444686997,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1718367147
    },
    {
        "content": "<p>I'd be curious to hear what you're working on! I was trying to apply this theorem recently to prove that a certain pasting composite of natural transformations equals another pasting composite but got blocked because I needed to rewrite along an equality of functors. </p>\n<p>(Btw, what is \"erw\"? That's a tactic I don't know.)</p>\n<p>In case you're curious, the thing I was trying to prove were the left inverse and right inverse fields of <code>Mates</code> in this draft pull request (without appealing to <code>ext</code>):</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/13840\">https://github.com/leanprover-community/mathlib4/pull/13840</a></p>\n<p>That definition doesn't depend on anything else in this file, if you want to take it out and play around with it.</p>",
        "id": 444773173,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1718393209
    },
    {
        "content": "<p><code>erw</code> is “expensive” <code>rw</code> it tries to unfold definitions more than <code>rw</code>. Generally you see it when either something has been unfolded that should not have been or people are trying abuse defeq transparency settings</p>",
        "id": 444774075,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1718393491
    },
    {
        "content": "<p>Check what <code>simp</code> is applying here and what the full goal state is before the <code>erw</code> Generally this is a code smell</p>",
        "id": 444774364,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1718393578
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60comp_id.60.20in.20.60Cat.60/near/444773173\">said</a>:</p>\n<blockquote>\n<p>In case you're curious, the thing I was trying to prove were the left inverse and right inverse fields of <code>Mates</code> in this draft pull request (without appealing to <code>ext</code>):</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/13840\">https://github.com/leanprover-community/mathlib4/pull/13840</a></p>\n</blockquote>\n<p>In the context of bicategories, these compatibilities are the <code>sorry</code> in this draft PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/13539\">#13539</a><br>\n<a href=\"https://github.com/leanprover-community/mathlib4/pull/13539/files#diff-8ea08c49c175b8da759053d08c832a3eff7c7d378fb78322b43c06c73b261a26R80-R85\">https://github.com/leanprover-community/mathlib4/pull/13539/files#diff-8ea08c49c175b8da759053d08c832a3eff7c7d378fb78322b43c06c73b261a26R80-R85</a> and there we cannot use <code>ext</code>!</p>",
        "id": 444779073,
        "sender_full_name": "Joël Riou",
        "timestamp": 1718395366
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60comp_id.60.20in.20.60Cat.60/near/444686997\">said</a>:</p>\n<blockquote>\n<p>Can you make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ? I don't know how to get the triangles working.</p>\n</blockquote>\n<p>Yes, sorry about that! Here is one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.CategoryTheory.Category.Cat</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Bicategory</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">whiskerRight_left</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">◁</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">▷</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">◁</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">▷</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">erw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category.comp_id</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 444848610,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1718445777
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60comp_id.60.20in.20.60Cat.60/near/444773173\">said</a>:</p>\n<blockquote>\n<p>I'd be curious to hear what you're working on! I was trying to apply this theorem recently to prove that a certain pasting composite of natural transformations equals another pasting composite but got blocked because I needed to rewrite along an equality of functors. </p>\n<p>(Btw, what is \"erw\"? That's a tactic I don't know.)</p>\n<p>In case you're curious, the thing I was trying to prove were the left inverse and right inverse fields of <code>Mates</code> in this draft pull request (without appealing to <code>ext</code>):</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/13840\">https://github.com/leanprover-community/mathlib4/pull/13840</a></p>\n<p>That definition doesn't depend on anything else in this file, if you want to take it out and play around with it.</p>\n</blockquote>\n<p>I'm working on formalizing fibered categories right now, and this came up when trying to define the fibered category associated to a pseudofunctor. I don't know much about bicategories though, I'm basically learning this stuff as I'm formalizing :)</p>\n<p>I didn't know anything about <code>Mates</code> before, this looks like a very useful result! I had a look at the other thread about it now, but how come you want to avoid <code>ext</code>? Just because the proof would be cleaner without it?</p>",
        "id": 444850993,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1718446968
    },
    {
        "content": "<p>It is certainly reasonable to avoid <code>ext</code> in a human proof. We should try to get the <code>by ext; simp</code> strategy to work as well as possible, but only the automation has to follow this route.</p>",
        "id": 444851399,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1718447316
    },
    {
        "content": "<p>The rewrite seems to fail for the following reason (and you don't need <code>pp.all</code> to see it fortunately, because the terms are huge!). After <code>simp</code> the goal is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">◁</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">▷</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"mi\">𝟙</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">◁</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">▷</span><span class=\"w\"> </span><span class=\"n\">K</span>\n</code></pre></div>\n<p>which looks pretty innocuous enough, but if you hover over <code>F ◁ α ▷ K</code> you'll see that it has type <code>F ≫ G ≫ K ⟶ F ≫ H ≫ K</code>, so in fact the goal is in some sense not well-typed, because <code> F ≫ H ≫ K = F ≫ (H ≫ K)</code>, whereas the identity wants <code> (F ≫ H) ≫ K</code>. I'm not entirely sure how to fix this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">whiskerRight_left</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">◁</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">▷</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">◁</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">▷</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">assoc</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- motive is not type correct :-/</span>\n</code></pre></div>\n<p>and <code>simp_rw</code> etc don't work either. </p>\n<p>Hmm, in fact I think the reason we're in this mess might be that the statement of the lemma itself is abusing defeq. The type of the LHS <code>(F ◁ α) ▷ K</code> is <code>(F ≫ G) ≫ K ⟶ (F ≫ H) ≫ K</code> and the type of the RHS is <code>F ≫ G ≫ K ⟶ F ≫ H ≫ K</code>. So maybe the lemma is bad?</p>",
        "id": 444852547,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1718448370
    },
    {
        "content": "<p>Thanks for catching this! The point of adding this lemma was just to get bicategory notation working with the lemmas in <code>Whiskering.lean</code>. So this lemma already exists in mathlib as <code>CategoryTheory.whiskerRight_left</code>, but without the triangles as notation. Although now that I look it up I see that this lemma is actually used 0 times elsewhere in mathlib, so maybe it's not so good?</p>",
        "id": 444852997,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1718448698
    },
    {
        "content": "<p>So probably this lemma should be stated in terms of the associator, and I should add a dsimp lemma (somehow) saying that the associator is just eqToIso (now with correct domains and codomains!). Then I should be able to get more useful versions of these lemmas!</p>",
        "id": 444853133,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1718448805
    },
    {
        "content": "<p>Yeah hopefully! Thanks, I found this exercise pretty instructive. I would like to understand better when <code>rw</code> fails and <code>erw</code> works.</p>",
        "id": 444855480,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1718450991
    },
    {
        "content": "<p>What happens if you try to splice in the associator?</p>",
        "id": 444865691,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1718459908
    },
    {
        "content": "<p>I would hope that the bicategory simp lemmas will take care of the associator directly without a simp lemma saying that it’s <code>eqToIso</code></p>",
        "id": 444865752,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1718459965
    },
    {
        "content": "<p>Indeed it works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Bicategory</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">𝒞</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Bicategory</span><span class=\"w\"> </span><span class=\"n\">𝒞</span><span class=\"o\">]</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">whiskerRight_left</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">𝒞</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">α_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">◁</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">▷</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">◁</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">▷</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 444866294,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1718460251
    },
    {
        "content": "<p>But if you use <code>Cat</code>, there is a lemma that throws it off track, but this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Bicategory</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">whiskerRight_left</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">α_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">◁</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">▷</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">◁</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">▷</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">Strict.associator_eqToIso</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 444866404,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1718460329
    },
    {
        "content": "<p>To be honest, I think <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Bicategory.Strict.associator_eqToIso#doc\">docs#CategoryTheory.Bicategory.Strict.associator_eqToIso</a> should <em>not</em> be a simp lemma.</p>",
        "id": 444874080,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1718465608
    },
    {
        "content": "<p>(same goes for the <code>(left/right)Unitor</code> lemmas)</p>",
        "id": 444874205,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1718465660
    },
    {
        "content": "<p>On a related point does this lemma exist anywhere:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Naturality of β implies naturality of whiskering.</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">WhiskeringNaturality</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">whiskerRight</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">whiskerLeft</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">whiskerLeft</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">whiskerRight</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">whiskerLeft</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 444977085,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1718545047
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60comp_id.60.20in.20.60Cat.60/near/444977085\">said</a>:</p>\n<blockquote>\n<p>On a related point does this lemma exist anywhere:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Naturality of β implies naturality of whiskering.</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">WhiskeringNaturality</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">whiskerRight</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">whiskerLeft</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">whiskerLeft</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">whiskerRight</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">whiskerLeft</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Is this <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Bicategory.whisker_exchange#doc\">docs#CategoryTheory.Bicategory.whisker_exchange</a> ?</p>",
        "id": 444977446,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1718545352
    }
]