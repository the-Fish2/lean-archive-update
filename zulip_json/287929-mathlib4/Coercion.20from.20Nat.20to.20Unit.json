[
    {
        "content": "<p>I just found out that this type checks:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>Is this intended behaviour? I think it is confusing.</p>",
        "id": 426784580,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1710521696
    },
    {
        "content": "<p>Yes, it's intended, at least if the coercion it's finding is the the same as the one mine found. It's getting a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NatCast#doc\">docs#NatCast</a> instance from the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Semiring#doc\">docs#Semiring</a> instance for <code>Unit</code>.</p>",
        "id": 426785103,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710521848
    },
    {
        "content": "<p>complete example (the import is needed):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.PUnitInstances</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.all</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"k\">#print</span> <span class=\"n\">foo</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">def foo : Nat → Unit :=</span>\n<span class=\"cm\">fun (n : Nat) ↦</span>\n<span class=\"cm\">  @Nat.cast.{0} Unit</span>\n<span class=\"cm\">    (@Semiring.toNatCast.{0} Unit</span>\n<span class=\"cm\">      (@CommSemiring.toSemiring.{0} Unit (@CommRing.toCommSemiring.{0} Unit PUnit.commRing.{0})))</span>\n<span class=\"cm\">    n</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 426785843,
        "sender_full_name": "David Renshaw",
        "timestamp": 1710522059
    },
    {
        "content": "<p><code>import Mathlib.Algebra.PUnitInstances</code> is the minimal import</p>",
        "id": 426786009,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710522107
    },
    {
        "content": "<p>It seems like the constant <code>Semiring.toNatCast</code> doesn't have a definition anywhere.</p>",
        "id": 426786302,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1710522189
    },
    {
        "content": "<p>It's generated by the <code>extends</code> keyword in the definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Semiring#doc\">docs#Semiring</a></p>",
        "id": 426787737,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710522657
    },
    {
        "content": "<p>Although it's a little nonobvious to see why</p>",
        "id": 426787819,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710522687
    },
    {
        "content": "<p>Aha, but strangely ctrl+click doesn't work on <code>Semiring.toNatCast</code> for me.</p>",
        "id": 426788436,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1710522871
    },
    {
        "content": "<p>Technically, the line is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Semiring</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">NonUnitalSemiring</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">NonAssocSemiring</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">MonoidWithZero</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>but some of these classes share fields. As a result, Lean takes a <code>NonUnitalSemiring</code> as the sole \"true\" parent, and then takes the remaining fields from <code>NonAssocSemiring</code> and makes them fields of the new class. But one of the non-overlapping fields of <code>NonAssocSemiring</code> is <code>toNatCast</code></p>",
        "id": 426788519,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710522897
    },
    {
        "content": "<p>The same thing happens for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NonAssocSemiring#doc\">docs#NonAssocSemiring</a>, which is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">NonAssocSemiring</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">NonUnitalNonAssocSemiring</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">MulZeroOneClass</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n    <span class=\"n\">AddCommMonoidWithOne</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>And the same thing happens again with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddCommMonoidWithOne#doc\">docs#AddCommMonoidWithOne</a> until you get to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddMonoidWithOne#doc\">docs#AddMonoidWithOne</a> which has an honest-to-god <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NatCast#doc\">docs#NatCast</a> in its <code>extends</code> clause.</p>",
        "id": 426788842,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710523000
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/stream/270676-lean4/topic/Coercion.20from.20Nat.20to.20Unit/near/426788436\">said</a>:</p>\n<blockquote>\n<p>Aha, but strangely ctrl+click doesn't work on <code>Semiring.toNatCast</code> for me.</p>\n</blockquote>\n<p>I'm not sure about the reason for this.</p>",
        "id": 426789297,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710523147
    },
    {
        "content": "<p>when viewing the definition in the online documentation, I see</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Semiring</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">NonUnitalSemiring</span> <span class=\"o\">,</span> <span class=\"n\">One</span> <span class=\"o\">,</span> <span class=\"n\">NatCast</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n</code></pre></div>",
        "id": 426789533,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1710523219
    },
    {
        "content": "<p>Is that intended?</p>",
        "id": 426789882,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1710523337
    },
    {
        "content": "<p>Would it be worth it to make the group, ring, etc. instances of <code>Unit</code> scoped? In general I wouldn't want anything to coerce to a Unit or PUnit.</p>",
        "id": 426791243,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1710523794
    },
    {
        "content": "<p>I think it makes sense not having <code>Unit</code> itself be a semiring, or at least scoping it. I'd even be inclined to define <code>def ZeroSemiring := Unit</code> and giving this synonym the instances instead.</p>\n<p>(I'm moving this discussion to the mathlib stream)</p>",
        "id": 426791903,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710524029
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4/topic/Coercion.20from.20Nat.20to.20Unit\">#lean4 &gt; Coercion from Nat to Unit</a> by <span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span>.</p>",
        "id": 426791982,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710524051
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Coercion.20from.20Nat.20to.20Unit/near/426791903\">said</a>:</p>\n<blockquote>\n<p>I think it makes sense not having <code>Unit</code> itself be a semiring, or at least scoping it. I'd even be inclined to define <code>def ZeroSemiring := Unit</code> and giving this synonym the instances instead.</p>\n<p>(I'm moving this discussion to the mathlib stream)</p>\n</blockquote>\n<p>I don't mind keeping the current state. <br>\nIf we want to have a type synonym, then I think we should have a single type synonym (<code>TrivialStructure</code>?) that has all trivial algebraic structures, and not different synonyms for e.g. <code>TrivialGroup</code> and <code>TrivialRing</code>.</p>",
        "id": 426798319,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1710526526
    }
]