[
    {
        "content": "<p>I have started porting the <code>fprop</code> tactic from SciLean to mathlib. Can I please get write permission for the user name <code>lecopivo</code>? </p>\n<p>Right now, I do not have much to report on but once I will have some minimal version working I will share it here.</p>",
        "id": 413034072,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1705355704
    },
    {
        "content": "<p>bump <span class=\"user-group-mention\" data-user-group-id=\"2494\">@maintainers</span></p>",
        "id": 413034709,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1705356079
    },
    {
        "content": "<p>I'll send an invitation in a minute or two</p>",
        "id": 413036626,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705356927
    },
    {
        "content": "<p>Done.</p>",
        "id": 413036968,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705357136
    },
    {
        "content": "<p>I have initial version.</p>\n<p>To set up <code>fprop</code> you just mark the theorems and the function property, like <code>Continuous</code>, with <code>fprop</code> attribute.</p>\n<p>This <a href=\"https://github.com/leanprover-community/mathlib4/commit/b04ba8c62cb8012a5728f7241953f9fcc35b1fb3\">commit</a> does that for <code>Continuous</code> and automates few proofs in <code>Topology/Constructions.lean</code>.</p>\n<p>Here is a <a href=\"https://github.com/leanprover-community/mathlib4/blob/399bc8af3fd7ce7124de899ab021a1f589664f98/Mathlib/Tactic/FProp/Test.lean\">test file</a> I use to debug which does a minimal set up of <code>fprop</code>.</p>",
        "id": 413249733,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1705443856
    },
    {
        "content": "<p>I have a version that is ready to be tested! As a stress test, <code>fprop</code> can prove automatically this lemma from sphere eversion project:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">corrugation.contDiff'</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">Loop</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hγ_diff</span> <span class=\"o\">:</span> <span class=\"bp\">𝒞</span> <span class=\"n\">n</span> <span class=\"bp\">↿</span><span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">H</span> <span class=\"bp\">→</span> <span class=\"n\">E</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"bp\">𝒞</span> <span class=\"n\">n</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">H</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"bp\">𝒞</span> <span class=\"n\">n</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">𝒞</span> <span class=\"n\">n</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">𝒯</span> <span class=\"n\">N</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">g</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">corrugation</span>\n  <span class=\"n\">fprop</span>\n</code></pre></div>\n<p>From the trace you can see the steps taken by <code>fprop</code></p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"code\"><pre><span></span><code>[Meta.Tactic.fprop] [✅] 𝒞 n fun h ↦ (1 / N) • ∫ (t : ℝ) in 0 ..N * π (x h), (γ (g h) (x h)) t - Loop.average (γ (g h) (x h))\n  [Meta.Tactic.fprop] applicable theorems for HSMul.hSMul: [contDiff_smul,\n       ContDiff.smul,\n       contDiff_const_smul,\n       ContDiff.const_smul]\n  [Meta.Tactic.fprop] [✅] applying: ContDiff.const_smul\n    [Meta.Tactic.fprop] [✅] 𝒞 n fun y ↦ ∫ (t : ℝ) in 0 ..N * π (x y), (γ (g y) (x y)) t - Loop.average (γ (g y) (x y))\n      [Meta.Tactic.fprop] applicable theorems for intervalIntegral: [contDiff_parametric_primitive_of_contDiff]\n      [Meta.Tactic.fprop] [✅] applying: contDiff_parametric_primitive_of_contDiff\n        [Meta.Tactic.fprop] [✅] 𝒞 n fun x_1 ↦ (↿fun x_2 t ↦ (γ (g x_2) (x x_2)) t - Loop.average (γ (g x_2) (x x_2))) x_1\n          [Meta.Tactic.fprop] applicable theorems for Function.HasUncurry.uncurry: []\n          [Meta.Tactic.fprop] [❌] 𝒞 n fun x_1 ↦ hasUncurryInduction.1 (fun x_2 t ↦ (γ (g x_2) (x x_2)) t - Loop.average (γ (g x_2) (x x_2))) x_1\n            [Meta.Tactic.fprop] applicable theorems for Function.HasUncurry.uncurry: []\n          [Meta.Tactic.fprop] [✅] 𝒞 n fun x_1 ↦ (↿((fun x_2 t ↦ (γ (g x_2) (x x_2)) t - Loop.average (γ (g x_2) (x x_2))) x_1.1)) x_1.2\n            [Meta.Tactic.fprop] applicable theorems for Function.HasUncurry.uncurry: []\n            [Meta.Tactic.fprop] [❌] 𝒞 n fun x_1 ↦ hasUncurryBase.1 ((fun x_2 t ↦ (γ (g x_2) (x x_2)) t - Loop.average (γ (g x_2) (x x_2))) x_1.1) x_1.2\n              [Meta.Tactic.fprop] applicable theorems for Function.HasUncurry.uncurry: []\n            [Meta.Tactic.fprop] [✅] 𝒞 n fun x_1 ↦ (γ (g x_1.1) (x x_1.1)) x_1.2 - Loop.average (γ (g x_1.1) (x x_1.1))\n              [Meta.Tactic.fprop] applicable theorems for HSub.hSub: [ContDiff.sub]\n              [Meta.Tactic.fprop] [✅] applying: ContDiff.sub\n                [Meta.Tactic.fprop] [✅] 𝒞 n fun x_1 ↦ (γ (g x_1.1) (x x_1.1)) x_1.2\n                  [Meta.Tactic.fprop] [✅] applying: ContDiff.comp'\n                    [Meta.Tactic.fprop] [✅] 𝒞 n fun x0x1x2 ↦ (γ x0x1x2.1 x0x1x2.2.1) x0x1x2.2.2\n                      [Meta.Tactic.fprop] [✅] applying: hγ_diff : 𝒞 n ↿γ\n                    [Meta.Tactic.fprop] [✅] 𝒞 n fun x_1 ↦ (g x_1.1, x x_1.1, x_1.2)\n                      [Meta.Tactic.fprop] applicable theorems for Prod.mk: [ContDiff.prod]\n                      [Meta.Tactic.fprop] [✅] applying: ContDiff.prod\n                        [Meta.Tactic.fprop] [✅] 𝒞 n fun x ↦ g x.1\n                          [Meta.Tactic.fprop] [✅] applying: ContDiff.comp'\n                            [Meta.Tactic.fprop] [✅] 𝒞 n fun x ↦ g x\n                              [Meta.Tactic.fprop] [✅] applying: hg : 𝒞 n g\n                            [Meta.Tactic.fprop] [✅] 𝒞 n fun x ↦ x.1\n                              [Meta.Tactic.fprop] applicable theorems for Prod.fst: [contDiff_fst, ContDiff.fst]\n                              [Meta.Tactic.fprop] [✅] applying: ContDiff.fst\n                                [Meta.Tactic.fprop] [✅] 𝒞 n fun x ↦ x\n                                  [Meta.Tactic.fprop] [✅] applying: contDiff_id'\n                        [Meta.Tactic.fprop] [✅] 𝒞 n fun x_1 ↦ (x x_1.1, x_1.2)\n                          [Meta.Tactic.fprop] applicable theorems for Prod.mk: [ContDiff.prod]\n                          [Meta.Tactic.fprop] [✅] applying: ContDiff.prod\n                            [Meta.Tactic.fprop] [✅] 𝒞 n fun x_1 ↦ x x_1.1\n                              [Meta.Tactic.fprop] [✅] applying: ContDiff.comp'\n                                [Meta.Tactic.fprop] [✅] 𝒞 n fun x_1 ↦ x x_1\n                                  [Meta.Tactic.fprop] [✅] applying: hx : 𝒞 n x\n                            [Meta.Tactic.fprop] [✅] 𝒞 n fun x ↦ x.2\n                              [Meta.Tactic.fprop] applicable theorems for Prod.snd: [contDiff_snd, ContDiff.snd]\n                              [Meta.Tactic.fprop] [✅] applying: ContDiff.snd\n                [Meta.Tactic.fprop] [✅] 𝒞 n fun x_1 ↦ Loop.average (γ (g x_1.1) (x x_1.1))\n                  [Meta.Tactic.fprop] applicable theorems for Loop.average: [contDiff_average]\n                  [Meta.Tactic.fprop] [✅] applying: contDiff_average\n                    [Meta.Tactic.fprop] [✅] 𝒞 n fun x_1 ↦ (↿fun x_2 ↦ γ (g x_2.1) (x x_2.1)) x_1\n                      [Meta.Tactic.fprop] applicable theorems for Function.HasUncurry.uncurry: []\n                      [Meta.Tactic.fprop] [❌] 𝒞 n fun x_1 ↦ (hasUncurryLoop F).1 (fun x_2 ↦ γ (g x_2.1) (x x_2.1)) x_1\n                        [Meta.Tactic.fprop] applicable theorems for Function.HasUncurry.uncurry: []\n                      [Meta.Tactic.fprop] [✅] 𝒞 n fun x_1 ↦ (γ (g x_1.1.1) (x x_1.1.1)) x_1.2\n                        [Meta.Tactic.fprop] [✅] applying: ContDiff.comp'\n                          [Meta.Tactic.fprop] [✅] 𝒞 n fun x_1 ↦ (g x_1.1.1, x x_1.1.1, x_1.2)\n                            [Meta.Tactic.fprop] applicable theorems for Prod.mk: [ContDiff.prod]\n                            [Meta.Tactic.fprop] [✅] applying: ContDiff.prod\n                              [Meta.Tactic.fprop] [✅] 𝒞 n fun x ↦ g x.1.1\n                                [Meta.Tactic.fprop] [✅] applying: ContDiff.comp'\n                                  [Meta.Tactic.fprop] [✅] 𝒞 n fun x ↦ x.1.1\n                                    [Meta.Tactic.fprop] applicable theorems for Prod.fst: [contDiff_fst, ContDiff.fst]\n                                    [Meta.Tactic.fprop] [✅] applying: ContDiff.fst\n                                      [Meta.Tactic.fprop] [✅] 𝒞 n fun x ↦ x.1\n                                        [Meta.Tactic.fprop] applicable theorems for Prod.fst: [contDiff_fst,\n                                             ContDiff.fst]\n                                        [Meta.Tactic.fprop] [✅] applying: ContDiff.fst\n                                          [Meta.Tactic.fprop] [✅] 𝒞 n fun x ↦ x\n                                            [Meta.Tactic.fprop] [✅] applying: contDiff_id'\n                              [Meta.Tactic.fprop] [✅] 𝒞 n fun x_1 ↦ (x x_1.1.1, x_1.2)\n                                [Meta.Tactic.fprop] applicable theorems for Prod.mk: [ContDiff.prod]\n                                [Meta.Tactic.fprop] [✅] applying: ContDiff.prod\n                                  [Meta.Tactic.fprop] [✅] 𝒞 n fun x_1 ↦ x x_1.1.1\n                                    [Meta.Tactic.fprop] [✅] applying: ContDiff.comp'\n                                  [Meta.Tactic.fprop] [✅] 𝒞 n fun x ↦ x.2\n                                    [Meta.Tactic.fprop] applicable theorems for Prod.snd: [contDiff_snd, ContDiff.snd]\n                                    [Meta.Tactic.fprop] [✅] applying: ContDiff.snd\n        [Meta.Tactic.fprop] [✅] 𝒞 n fun x_1 ↦ N * π (x x_1)\n          [Meta.Tactic.fprop] applicable theorems for HMul.hMul: [contDiff_mul, ContDiff.mul]\n          [Meta.Tactic.fprop] [✅] applying: ContDiff.mul\n            [Meta.Tactic.fprop] [✅] 𝒞 n fun x ↦ N\n              [Meta.Tactic.fprop] [✅] applying: contDiff_const\n            [Meta.Tactic.fprop] [✅] 𝒞 n fun x_1 ↦ π (x x_1)\n              [Meta.Tactic.fprop] [✅] applying: ContDiff.clm_apply\n                [Meta.Tactic.fprop] [✅] 𝒞 n fun x ↦ π\n                  [Meta.Tactic.fprop] [✅] applying: contDiff_const\n</code></pre></div>\n</div></div>\n<p>The main features of <code>fprop</code> are:</p>\n<ul>\n<li>general tactic to prove stuff like Continuous, Differentiable, ContDiff, IsLinearMap etc.</li>\n<li>fast</li>\n<li>handles local hypothesis about n-ary functions i.e. can work with <code>(hf : Continuous fun (x,y) =&gt; f x y)</code></li>\n<li>handles bundled morphisms, in the example above notice that <code>γ</code> is actually function of three arguments and <code>hγ_diff</code> says it is jointly differentiable in all three arguments</li>\n</ul>\n<p>I would appreciate help from other people by:</p>\n<ul>\n<li>point out theorems in mathlib that could be automated</li>\n<li>testing it, it is available under the branch <code>lecopivo/fprop</code></li>\n<li>setting it up for other function properties like <code>Measurable</code>, soon I will write a guide how to set it up but for now you can follow my <a href=\"https://github.com/leanprover-community/mathlib4/blob/lecopivo/fprop/test/fprop_dev.lean\">test file</a></li>\n</ul>",
        "id": 417658741,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706107162
    },
    {
        "content": "<p>That trace looks really good! So I guess <code>show_term fprop</code> would also show a pretty nice proof term?</p>",
        "id": 417659135,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1706107283
    },
    {
        "content": "<p>The proof term of <code>corrugation.contDiff'</code> is:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"n\">ℝ</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">H</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"n\">ℝ</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"n\">π</span>\n    <span class=\"n\">N</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"n\">hγ_diff</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"n\">hx</span> <span class=\"o\">{</span><span class=\"n\">g</span><span class=\"o\">}</span> <span class=\"n\">hg</span> <span class=\"bp\">↦</span>\n  <span class=\"n\">_root_.id</span>\n    <span class=\"o\">(</span><span class=\"n\">ContDiff.const_smul</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">contDiff_parametric_primitive_of_contDiff</span>\n        <span class=\"o\">(</span><span class=\"n\">ContDiff.sub</span>\n          <span class=\"o\">(</span><span class=\"n\">ContDiff.comp'</span> <span class=\"n\">hγ_diff</span>\n            <span class=\"o\">(</span><span class=\"n\">ContDiff.prod</span> <span class=\"o\">(</span><span class=\"n\">ContDiff.comp'</span> <span class=\"n\">hg</span> <span class=\"o\">(</span><span class=\"n\">ContDiff.fst</span> <span class=\"n\">contDiff_id'</span><span class=\"o\">))</span>\n              <span class=\"o\">(</span><span class=\"n\">ContDiff.prod</span> <span class=\"o\">(</span><span class=\"n\">ContDiff.comp'</span> <span class=\"n\">hx</span> <span class=\"o\">(</span><span class=\"n\">ContDiff.fst</span> <span class=\"n\">contDiff_id'</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">ContDiff.snd</span> <span class=\"n\">contDiff_id'</span><span class=\"o\">))))</span>\n          <span class=\"o\">(</span><span class=\"n\">contDiff_average</span>\n            <span class=\"o\">(</span><span class=\"n\">ContDiff.comp'</span> <span class=\"n\">hγ_diff</span>\n              <span class=\"o\">(</span><span class=\"n\">ContDiff.prod</span> <span class=\"o\">(</span><span class=\"n\">ContDiff.comp'</span> <span class=\"n\">hg</span> <span class=\"o\">(</span><span class=\"n\">ContDiff.fst</span> <span class=\"o\">(</span><span class=\"n\">ContDiff.fst</span> <span class=\"n\">contDiff_id'</span><span class=\"o\">)))</span>\n                <span class=\"o\">(</span><span class=\"n\">ContDiff.prod</span> <span class=\"o\">(</span><span class=\"n\">ContDiff.comp'</span> <span class=\"n\">hx</span> <span class=\"o\">(</span><span class=\"n\">ContDiff.fst</span> <span class=\"o\">(</span><span class=\"n\">ContDiff.fst</span> <span class=\"n\">contDiff_id'</span><span class=\"o\">)))</span>\n                  <span class=\"o\">(</span><span class=\"n\">ContDiff.snd</span> <span class=\"n\">contDiff_id'</span><span class=\"o\">))))))</span>\n        <span class=\"o\">(</span><span class=\"n\">ContDiff.mul</span> <span class=\"n\">contDiff_const</span> <span class=\"o\">(</span><span class=\"n\">ContDiff.clm_apply</span> <span class=\"n\">contDiff_const</span> <span class=\"n\">hx</span><span class=\"o\">))</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n</code></pre></div>\n</div></div>\n<p>I guess that is somewhat reasonable</p>",
        "id": 417659736,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706107465
    },
    {
        "content": "<p>\"somewhat reasonable\" is a gross understatement. That's excellent!</p>",
        "id": 417660257,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1706107625
    },
    {
        "content": "<p>I wrote a short tutorial how to set up <code>fprop</code> for <code>Measureable</code>. It can be found as literate file <a href=\"https://github.com/leanprover-community/mathlib4/blob/lecopivo/fprop/test/fprop.lean\">here</a>.</p>",
        "id": 417965826,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706131294
    },
    {
        "content": "<p>Here is Zulip version:</p>\n<p>The first step in using <code>fprop</code> is to mark desired function property with <code>fprop</code> attribute.<br>\nIn this example we work with <code>Measurable</code>. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">fprop</span><span class=\"o\">]</span> <span class=\"n\">Measurable</span>\n</code></pre></div>\n<p>Now we can start marking theorems about <code>Measurable</code> with the attribute <code>@[fprop]</code>. It is best to start with the basic lambda calculus rules. There are five of these rules in total</p>\n<ul>\n<li>identity rule    <code>Measurable fun x =&gt; x</code></li>\n<li>constant rule    <code>Measurable fun x =&gt; y</code></li>\n<li>composition rule <code>Measurable f → Measurable g → Measurable fun x =&gt; f (g x)</code></li>\n<li>apply rule       <code>Measurable fun f =&gt; f x</code></li>\n<li>pi rule          <code>∀ i, Measurable (f · i) → Measurable fun x i =&gt; f x i</code></li>\n</ul>\n<p>You do not have to provide them all. For example <code>IsLinearMap</code> does not have the constant rule. However, to have any hope at using <code>fprop</code> successfully you need to at least provide identity and composition rule.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">fprop</span><span class=\"o\">]</span>\n  <span class=\"n\">measurable_id'</span>\n  <span class=\"n\">measurable_const</span>\n  <span class=\"n\">Measurable.comp'</span>\n  <span class=\"n\">measurable_pi_apply</span>\n  <span class=\"n\">measurable_pi_lambda</span>\n</code></pre></div>\n<p>Measurability also behaves nicely with respect to taking products. Let's mark the product constructor</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">fprop</span><span class=\"o\">]</span>\n  <span class=\"n\">Measurable.prod_mk</span> <span class=\"c1\">-- Measurable f → Measurable g → Measurable fun x =&gt; (f x, g x)</span>\n</code></pre></div>\n<p>When it comes to product projection, their properties are usually stated in two different ways</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">measurable_fst</span> <span class=\"o\">:</span> <span class=\"n\">Measurable</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Prod.fst</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>or </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Measurable.fst</span> <span class=\"o\">:</span> <span class=\"n\">Measurable</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">Measurable</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Prod.fst</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Tactic <code>fprop</code> can work with both versions and it should be sufficient to provide just one of them. It does not hurt to provide both of them though.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">fprop</span><span class=\"o\">]</span>\n  <span class=\"n\">measurable_fst</span>\n  <span class=\"n\">Measurable.fst</span>\n  <span class=\"n\">measurable_snd</span>\n  <span class=\"n\">Measurable.snd</span>\n</code></pre></div>\n<p>A silly example on which <code>measurability</code> fails and <code>fprop</code> succeeds. Let's turn on tracing to see what is going on</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.fprop</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Measurable</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Measurable</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">(</span><span class=\"n\">try</span> <span class=\"n\">measurability</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">fprop</span>\n</code></pre></div>\n<p>To give more complicated examples we mark theorems about arithmetic operations with `@[fprop]</p>\n<p>Again we mark both versions of theorems. Internally <code>fprop</code> says that theorems like <code>measurable_add</code> are in \"uncurried form\" and theorems like <code>Measurable.add</code> are in compositional form.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">fprop</span><span class=\"o\">]</span>\n  <span class=\"n\">measurable_add</span>\n  <span class=\"n\">measurable_mul</span>\n  <span class=\"n\">measurable_neg</span>\n  <span class=\"n\">measurable_div</span>\n  <span class=\"n\">measurable_smul</span>\n\n  <span class=\"n\">Measurable.add</span>\n  <span class=\"n\">Measurable.mul</span>\n  <span class=\"n\">Measurable.neg</span>\n  <span class=\"n\">Measurable.div</span>\n  <span class=\"n\">Measurable.smul</span>\n</code></pre></div>\n<p>An example of measurability of some arithmetic function</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Measurable</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fprop</span>\n</code></pre></div>\n<p>So far we talked about two types of theorems:</p>\n<ol>\n<li>theorems about basic lambda calculus terms </li>\n<li>theorems about defined functions</li>\n</ol>\n<p>There are two other kinds of theorems <code>fprop</code> can work with:</p>\n<ol start=\"3\">\n<li>transition theorems - theorems that imply e.g. measurability from continuity</li>\n<li>morphism theorems - theorems talking about bundles </li>\n</ol>\n<p>When you mark a theorem with <code>@[fprop]</code> attribute you can check the type of the theorem by turning on the option <code>trace.Meta.Tactic.fprop.attr</code>.</p>\n<p>Transition theorems prove one function property from another. We already mentioned that continuity implies measurability but there are many more. For example differentiability  implies continuity, linear map between finitely dimensional spaces is continuous etc.</p>\n<p>The theorem proving measurability from continuity is <code>Continuous.measurable</code> so let's mark it with <code>@[fprop]</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">fprop</span><span class=\"o\">]</span>\n  <span class=\"n\">Continuous.measurable</span> <span class=\"c1\">-- Continuous f → Measurable f</span>\n</code></pre></div>\n<p>Now we can prove one of the earlier examples assuming the function is continuous instead of measurable.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Measurable</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fprop</span>\n</code></pre></div>\n<p>To keep <code>fprop</code> performant it is important to keep these \"transition theorems\" in the form <code>P f → Q f</code> i.e. the conclusion has to talk about a single free variable <code>f</code>. Furthermore, the \"transition theorems\" should <strong>not</strong> form a cycle. </p>\n<p>Lastly there are \"morphism theorems\". These are really just theorems about the properties of <code>DFunLike.coe</code> and are treated somewhat specially.  </p>\n<p>Let's make continuous linear maps work with measurability. The function <code>DFunLike.coe</code> is  a function of two arguments <code>f : E →L[K] F</code> and <code>x : E</code>. Mathlib currently states  measurability of <code>DFunLike.coe</code> in <code>f</code> and <code>x</code> separately. </p>\n<p>The theorem <code>ContinuousLinearMap.measurable</code> states measurability in <code>x</code> in uncurried form.<br>\nThe theorem <code>ContinuousLinearMap.measurable_comp</code> states measurability in <code>x</code> in compositional form.<br>\nThe theorem <code>ContinuousLinearMap.measurable_apply</code> states measurability in <code>f</code> in uncurried form.<br>\nThe theorem <code>Measurable.apply_continuousLinearMap</code> states measurability in <code>f</code> in compositional form.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">fprop</span><span class=\"o\">]</span>\n  <span class=\"n\">ContinuousLinearMap.measurable</span>       <span class=\"c1\">-- Measurable fun (x : E) =&gt; DFunLike.coe L x</span>\n  <span class=\"n\">ContinuousLinearMap.measurable_comp</span>  <span class=\"c1\">-- Measurable φ → Measurable fun (x : E) =&gt; DFunLike.coe L (φ x)</span>\n  <span class=\"n\">ContinuousLinearMap.measurable_apply</span> <span class=\"c1\">-- Measurable fun (f : E →[K] F) =&gt; DFunLike.coe f x</span>\n  <span class=\"n\">Measurable.apply_continuousLinearMap</span> <span class=\"c1\">-- Measurable φ → Measurable fun (x : α) =&gt; DFunLike.coe (L x) v</span>\n</code></pre></div>\n<p>A silly example that everything works together as expected</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.fprop</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">ℝ</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">Measurable</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">/</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fprop</span>\n</code></pre></div>\n<p>In the current state of <code>fprop</code>, morphism theorems <strong>have to</strong> be stated in compositional form. Sometimes they might work in uncurried form but <code>fprop</code> is not designed that way right now.</p>\n<p>In other cases the function property of <code>DFunLike.coe</code> can be stated jointly in <code>f</code> and <code>x</code>. This is the case of <code>ContDiff n</code> and  continuous linear maps. The theorem is <code>ContDiff.clm_apply</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">ContDiff.clm_apply</span> <span class=\"c1\">-- {f : E → F →L[K] G} → {g : E → F} →  ContDiff K n f → ContDiff K n g → ContDiff K n fun x =&gt; DFunLike.coe (f x) (g x)</span>\n</code></pre></div>\n<p>If possible, <code>fprop</code> theorem about <code>DFunLike.coe</code> should be state in this way.</p>\n<p>That should be all about <code>fprop</code>, I hope you will enjoy using it :)</p>",
        "id": 417965846,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706131304
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> what about \"variants\" (e.g., <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousOn#doc\">docs#ContinuousOn</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousAt#doc\">docs#ContinuousAt</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousWithinAt#doc\">docs#ContinuousWithinAt</a>, etc., and similarly for differentiability, measurability, ...)? Are these capable of being handled with \"transition theorems\", or not because they don't satisfy the \"single free variable\" condition?</p>",
        "id": 417978325,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1706137176
    },
    {
        "content": "<p>I guess I'm wondering more generally:</p>\n<ol>\n<li>what are the limits of <code>fprop</code>?</li>\n<li>can these limits be circumvented (perhaps at the cost of performance)?</li>\n<li>if yes, can we turn that on optionally in order to have the best of both worlds?</li>\n</ol>",
        "id": 417978612,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1706137308
    },
    {
        "content": "<p>Right now the tactic is designed to prove property that is \"obvious\" like ... yeah yeah it is smooth just because it is a composition of smooth functions.</p>\n<p>Variants like <code>ContinuousAt</code> are not yet tested. I'm planning on providing custom discharger to prove assumptions like <code>x != 0</code>. Then I think <code>fprop</code> could work for it too.</p>\n<p>I would appreciate an example of some nontrivial proofs of e.g. <code>ContinuousAt</code> that you feel should be easy to automate.</p>\n<p>Another limitation is that <code>fprop</code> is not doing any kind of reduction (except beta, eta and sometimes iota).</p>",
        "id": 417993653,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706146892
    },
    {
        "content": "<p><a href=\"https://github.com/dwrensha/compfiles/blob/59a24c7b287048bd0efc89b2988fbe1ff8646454/Compfiles/Imo1974P5.lean#L78-L117\">Here</a>'s a continuity proof that ought to be possible to write more succiently with proper tactic support. It seems that the <code>continuity</code> tactic does not currently support <code>continuousOn</code>.</p>",
        "id": 417994148,
        "sender_full_name": "David Renshaw",
        "timestamp": 1706147212
    },
    {
        "content": "<p>Thank you, that is an excellent example! I need more theorems like that.</p>",
        "id": 417994617,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706147520
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/porting.20.60fprop.60.20tactic/near/417978325\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> what about \"variants\" (e.g., <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousOn#doc\">docs#ContinuousOn</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousAt#doc\">docs#ContinuousAt</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousWithinAt#doc\">docs#ContinuousWithinAt</a>, etc., and similarly for differentiability, measurability, ...)? Are these capable of being handled with \"transition theorems\", or not because they don't satisfy the \"single free variable\" condition?</p>\n</blockquote>\n<p>The single free variable is talking about the function argument only and not about other arguments like the set on which you want continuity. For example, you should not state that a composition of linear functions is continuous. That would break the single free variable condition as the conclusion is talking about function composition. Stating that <code>Continuous</code> implies <code>ContinuousOn</code> is fine.</p>",
        "id": 417995449,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706148093
    },
    {
        "content": "<p>The issue with <code>ContinuousOn</code> that I do not know if there is a tactic that would be able to prove the intermediate <code>(h : Set.MapsTo f s t)</code> coming from <code>ContinuousOn.comp</code>?</p>\n<p>But in any case, <code>fprop</code> can just try to prove the continuity anyway and pass all the <code>MapsTo</code> goals to the user.</p>",
        "id": 417996958,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706148994
    },
    {
        "content": "<p>I was thinking <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Continuous.comp#doc\">docs#Continuous.comp</a> maybe wouldn't be included, but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Continuous.comp_continuousOn#doc\">docs#Continuous.comp_continuousOn</a> would be. The canonical situation would be things involving <code>\\-1</code> or <code>log</code>. For instance, it would be cool if <code>fprop</code> could determine that <code>fun x =&gt; x * (Real.log x) ^ 2 - Real.exp x / x</code> is continuous on the complement of zero. (Artificial example)</p>",
        "id": 417998501,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1706150130
    },
    {
        "content": "<p>It should be enough to state most of the <code>ContinuousOn</code> theorems in the \"compositional form\". Then they are effectively specialized versions of <code>Continuous.comp_continuousOn</code> and the general composition theorem can still be <code>ContinuousOn.comp</code> for full power.</p>",
        "id": 417999241,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706150655
    },
    {
        "content": "<p>Tomorrow I will try to prove continuity <code>fun x =&gt; x * (Real.log x) ^ 2 - Real.exp x / x</code>. It should be doable.</p>",
        "id": 417999735,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706151028
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/287929-mathlib4/topic/porting.20.60fprop.60.20tactic/near/417993653\">said</a>:</p>\n<blockquote>\n<p>Another limitation is that <code>fprop</code> is not doing any kind of reduction (except beta, eta and sometimes iota).</p>\n</blockquote>\n<p>Most tactics work up to reducible defeq, so it would be really nice if <code>fprop</code> could support this as well.</p>",
        "id": 418042198,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1706176074
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/287929-mathlib4/topic/porting.20.60fprop.60.20tactic/near/418042198\">said</a>:</p>\n<blockquote>\n<p>Most tactics work up to reducible defeq, so it would be really nice if <code>fprop</code> could support this as well.</p>\n</blockquote>\n<p>Good point, I do some unfolding but I'm having a hard time getting it right. Likely because I do not use whnf as it destroys let bindings. Maybe I should try again as now we have <code>WhnfCoreConfig</code>.</p>",
        "id": 418104555,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706196492
    },
    {
        "content": "<p>That measurable test file looks <strong>amazing</strong>!</p>",
        "id": 418108170,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1706197557
    },
    {
        "content": "<p>I'm also very happy to hear that it doesn't unfold semireducible (default) definitions. I am skeptical that any other behavior can be fast in  \"real-world\" cases.</p>",
        "id": 418108710,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1706197640
    },
    {
        "content": "<p>Did you write refined discrimination trees yourself? It sounds like there are some ideas in there that would be useful for other tactics using discrimination trees. Link: <a href=\"https://github.com/leanprover-community/mathlib4/blob/lecopivo/fprop/Mathlib/Tactic/FProp/RefinedDiscrTree.lean\">https://github.com/leanprover-community/mathlib4/blob/lecopivo/fprop/Mathlib/Tactic/FProp/RefinedDiscrTree.lean</a></p>",
        "id": 418111868,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1706198541
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/287929-mathlib4/topic/porting.20.60fprop.60.20tactic/near/418111868\">said</a>:</p>\n<blockquote>\n<p>Did you write refined discrimination trees yourself? It sounds like there are some ideas in there that would be useful for other tactics using discrimination trees. Link: <a href=\"https://github.com/leanprover-community/mathlib4/blob/lecopivo/fprop/Mathlib/Tactic/FProp/RefinedDiscrTree.lean\">https://github.com/leanprover-community/mathlib4/blob/lecopivo/fprop/Mathlib/Tactic/FProp/RefinedDiscrTree.lean</a></p>\n</blockquote>\n<p>Oh no no, all the glory and fame for that goes to <span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span>, there is <a href=\"https://github.com/leanprover/std4/pull/394\">std4 PR 394</a> for it. It works wonderfully for this purpose.</p>",
        "id": 418113323,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706198956
    },
    {
        "content": "<p>You can now provide custom discharger and this works now</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">Real.log</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">Real.exp</span> <span class=\"n\">x</span> <span class=\"bp\">/</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fprop</span> <span class=\"o\">(</span><span class=\"n\">disch</span><span class=\"o\">:=</span><span class=\"n\">aesop</span><span class=\"o\">)</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span><span class=\"bp\">≠</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousAt</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">Real.log</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">Real.exp</span> <span class=\"n\">x</span> <span class=\"bp\">/</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fprop</span> <span class=\"o\">(</span><span class=\"n\">disch</span><span class=\"o\">:=</span><span class=\"n\">aesop</span><span class=\"o\">)</span>\n</code></pre></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>trace</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">Real.log</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">Real.exp</span> <span class=\"n\">x</span> <span class=\"bp\">/</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span>\n  <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"n\">applicable</span> <span class=\"n\">theorems</span> <span class=\"n\">for</span> <span class=\"n\">HSub.hSub</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">ContinuousOn.sub</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn.sub</span>\n    <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">Real.log</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span>\n      <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"n\">applicable</span> <span class=\"n\">theorems</span> <span class=\"n\">for</span> <span class=\"n\">HMul.hMul</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">ContinuousOn.mul</span><span class=\"o\">]</span>\n      <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn.mul</span>\n        <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span>\n          <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">continuousOn_id'</span>\n        <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">Real.log</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span>\n          <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"n\">applicable</span> <span class=\"n\">theorems</span> <span class=\"n\">for</span> <span class=\"n\">HPow.hPow</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">ContinuousOn.pow</span><span class=\"o\">]</span>\n          <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn.pow</span>\n            <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">Real.log</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span>\n              <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"n\">applicable</span> <span class=\"n\">theorems</span> <span class=\"n\">for</span> <span class=\"n\">Real.log</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">ContinuousOn.log</span><span class=\"o\">]</span>\n              <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn.log</span>\n    <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">Real.exp</span> <span class=\"n\">x</span> <span class=\"bp\">/</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span>\n      <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"n\">applicable</span> <span class=\"n\">theorems</span> <span class=\"n\">for</span> <span class=\"n\">HDiv.hDiv</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">ContinuousOn.div''</span><span class=\"o\">]</span>\n      <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn.div''</span>\n        <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">Real.exp</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span>\n          <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"n\">applicable</span> <span class=\"n\">theorems</span> <span class=\"n\">for</span> <span class=\"n\">Real.exp</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">ContinuousOn.exp</span><span class=\"o\">]</span>\n          <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn.exp</span>\n\n\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">ContinuousAt</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">Real.log</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">Real.exp</span> <span class=\"n\">x</span> <span class=\"bp\">/</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span>\n  <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"n\">applicable</span> <span class=\"n\">theorems</span> <span class=\"n\">for</span> <span class=\"n\">HSub.hSub</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">ContinuousAt.sub</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousAt.sub</span>\n    <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">ContinuousAt</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">Real.log</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">y</span>\n      <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"n\">applicable</span> <span class=\"n\">theorems</span> <span class=\"n\">for</span> <span class=\"n\">HMul.hMul</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">ContinuousAt.mul</span><span class=\"o\">]</span>\n      <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousAt.mul</span>\n        <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">ContinuousAt</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span>\n          <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">continuousAt_id'</span>\n        <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">ContinuousAt</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">Real.log</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">y</span>\n          <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"n\">applicable</span> <span class=\"n\">theorems</span> <span class=\"n\">for</span> <span class=\"n\">HPow.hPow</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">ContinuousAt.pow</span><span class=\"o\">]</span>\n          <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousAt.pow</span>\n            <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">ContinuousAt</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">Real.log</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span>\n              <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"n\">applicable</span> <span class=\"n\">theorems</span> <span class=\"n\">for</span> <span class=\"n\">Real.log</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">ContinuousAt.log</span><span class=\"o\">]</span>\n              <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousAt.log</span>\n    <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">ContinuousAt</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">Real.exp</span> <span class=\"n\">x</span> <span class=\"bp\">/</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span>\n      <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"n\">applicable</span> <span class=\"n\">theorems</span> <span class=\"n\">for</span> <span class=\"n\">HDiv.hDiv</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">ContinuousAt.div''</span><span class=\"o\">]</span>\n      <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousAt.div''</span>\n        <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">ContinuousAt</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">Real.exp</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span>\n          <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"n\">applicable</span> <span class=\"n\">theorems</span> <span class=\"n\">for</span> <span class=\"n\">Real.exp</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">ContinuousAt.exp</span><span class=\"o\">]</span>\n          <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousAt.exp</span>\n</code></pre></div>\n</div></div>\n<p>Here is the complete set up of <code>ContinuousAt</code> and <code>ContinuousOn</code>. I had to slightly reformulate certain theorems to a form <code>fprop</code> expects.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.FProp</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.SpecialFunctions.Exp</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.SpecialFunctions.Log.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Constructions</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Mathlib</span> <span class=\"n\">Qq</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span>\n\n\n<span class=\"kn\">section</span> <span class=\"n\">MissingTheorems</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">π</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">κ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">TopologicalSpace</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">π</span> <span class=\"n\">i</span><span class=\"o\">}</span>\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">continuousAt_id'</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousAt</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">continuousAt_id</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">continuousOn_id'</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">continuousOn_id</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ContinuousAt.comp'</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousAt</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousAt</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousAt</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">ContinuousAt.comp</span> <span class=\"n\">hg</span> <span class=\"n\">hf</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ContinuousOn.comp''</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousOn</span> <span class=\"n\">g</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousOn</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Set.MapsTo</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">ContinuousOn.comp</span> <span class=\"n\">hg</span> <span class=\"n\">hf</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">continuousOn_apply</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">π</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">Continuous.continuousOn</span> <span class=\"o\">(</span><span class=\"n\">continuous_apply</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">continuousAt_pi'</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">π</span> <span class=\"n\">i</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">ContinuousAt</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">ContinuousAt</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">continuousAt_pi.2</span> <span class=\"n\">hf</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">continuousOn_pi'</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">π</span> <span class=\"n\">i</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">ContinuousOn</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">continuousOn_pi.2</span> <span class=\"n\">hf</span>\n\n\n<span class=\"kn\">section</span> <span class=\"n\">div</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">G₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">GroupWithZero</span> <span class=\"n\">G₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">G₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">HasContinuousInv₀</span> <span class=\"n\">G₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ContinuousMul</span> <span class=\"n\">G₀</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">G₀</span><span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ContinuousAt.div''</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousAt</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousAt</span> <span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₀</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">ContinuousAt</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">/</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">ContinuousAt.div</span> <span class=\"n\">hf</span> <span class=\"n\">hg</span> <span class=\"n\">h₀</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ContinuousOn.div''</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousOn</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousOn</span> <span class=\"n\">g</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₀</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">/</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">ContinuousOn.div</span> <span class=\"n\">hf</span> <span class=\"n\">hg</span> <span class=\"n\">h₀</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">div</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MissingTheorems</span>\n\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">fprop</span><span class=\"o\">]</span>\n  <span class=\"n\">ContinuousAt</span>\n  <span class=\"n\">continuousAt_id'</span>\n  <span class=\"n\">continuousAt_const</span>\n  <span class=\"n\">ContinuousAt.comp'</span>\n  <span class=\"n\">continuousAt_apply</span>\n  <span class=\"n\">continuousAt_pi'</span>\n\n  <span class=\"n\">Continuous.continuousAt</span> <span class=\"c1\">-- transition from continuous</span>\n\n  <span class=\"n\">ContinuousAt.prod</span>\n  <span class=\"n\">ContinuousAt.fst</span>\n  <span class=\"n\">ContinuousAt.snd</span>\n\n  <span class=\"n\">ContinuousAt.add</span>\n  <span class=\"n\">ContinuousAt.sub</span>\n  <span class=\"n\">ContinuousAt.neg</span>\n  <span class=\"n\">ContinuousAt.mul</span>\n  <span class=\"n\">ContinuousAt.div''</span>\n  <span class=\"n\">ContinuousAt.inv</span>\n\n  <span class=\"n\">ContinuousAt.exp</span>\n  <span class=\"n\">ContinuousAt.log</span>\n  <span class=\"n\">ContinuousAt.pow</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">fprop</span><span class=\"o\">]</span>\n  <span class=\"n\">ContinuousOn</span>\n  <span class=\"n\">continuousOn_id'</span>\n  <span class=\"n\">continuousOn_const</span>\n  <span class=\"n\">ContinuousOn.comp''</span>\n  <span class=\"n\">continuousOn_apply</span>\n  <span class=\"n\">continuousOn_pi'</span>\n\n  <span class=\"n\">Continuous.continuousOn</span> <span class=\"c1\">-- transition from continuous</span>\n\n  <span class=\"n\">ContinuousOn.prod</span>\n  <span class=\"n\">ContinuousOn.fst</span>\n  <span class=\"n\">ContinuousOn.snd</span>\n\n  <span class=\"n\">ContinuousOn.add</span>\n  <span class=\"n\">ContinuousOn.sub</span>\n  <span class=\"n\">ContinuousOn.neg</span>\n  <span class=\"n\">ContinuousOn.mul</span>\n  <span class=\"n\">ContinuousOn.div''</span>\n  <span class=\"n\">ContinuousOn.inv</span>\n\n  <span class=\"n\">ContinuousOn.exp</span>\n  <span class=\"n\">ContinuousOn.log</span>\n  <span class=\"n\">ContinuousOn.pow</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.fprop</span> <span class=\"n\">true</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">Real.log</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">Real.exp</span> <span class=\"n\">x</span> <span class=\"bp\">/</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fprop</span> <span class=\"o\">(</span><span class=\"n\">disch</span><span class=\"o\">:=</span><span class=\"n\">aesop</span><span class=\"o\">)</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span><span class=\"bp\">≠</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousAt</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">Real.log</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">Real.exp</span> <span class=\"n\">x</span> <span class=\"bp\">/</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fprop</span> <span class=\"o\">(</span><span class=\"n\">disch</span><span class=\"o\">:=</span><span class=\"n\">aesop</span><span class=\"o\">)</span>\n</code></pre></div>\n</div></div>",
        "id": 418149067,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706210564
    },
    {
        "content": "<p><del>I have trouble proving</del></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">t</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fprop</span> <span class=\"o\">(</span><span class=\"n\">disch</span><span class=\"o\">:=</span><span class=\"n\">simp</span><span class=\"o\">)</span>\n</code></pre></div>\n<p><del>the subgoal is</del></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<p><del>which is provable on its own but when I run <code>simp</code> as part of <code>fprop</code> it is not doing the same stuff.</del></p>\n<p><del>I must be doing something wrong in running a tactic in meta code. I'm using this <a href=\"https://github.com/leanprover-community/mathlib4/blob/735c3b3fd5bf16c55c927ee4c470d5bf6338e624/Mathlib/Tactic/FProp/FPropDecl.lean#L122\">function</a> to turn <code>Syntax</code> to <code>Expr -&gt; MetaM (Option Expr)</code>. It is bastardized version of similar <a href=\"https://github.com/leanprover/lean4/blob/8293fd4e09d674d852c0bff54ea642e47cf694f7/src/Lean/Elab/Tactic/Simp.lean#L36\">function</a> I found in simp. What did I do wrong?</del></p>\n<p>edit: everything is ok, the standalone example accidentally talks about natural numbers and reals. Over reals it is not provable by simp.</p>",
        "id": 418154757,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706212697
    },
    {
        "content": "<p>In my most recent update, I made it so that the discrimination tree indexes <code>id</code> and <code>fun x =&gt; x</code> in the same way. I was thinking about doing something similar for composition, and more generally improve on indexing terms the same when a user would think of them as the same. Would that help with not requiring alternative forms of the theorems?</p>",
        "id": 418155310,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1706212872
    },
    {
        "content": "<p>I guess it would help a little but I can deal with it myself fairly easily. I'm not sure if such capability should be part discrimination tree or not.</p>",
        "id": 418157417,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706213670
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243791\">David Renshaw</span> <a href=\"#narrow/stream/287929-mathlib4/topic/porting.20.60fprop.60.20tactic/near/417994148\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/dwrensha/compfiles/blob/59a24c7b287048bd0efc89b2988fbe1ff8646454/Compfiles/Imo1974P5.lean#L78-L117\">Here</a>'s a continuity proof that ought to be possible to write more succiently with proper tactic support. It seems that the <code>continuity</code> tactic does not currently support <code>continuousOn</code>.</p>\n</blockquote>\n<p>Done :) just add this to the previous code that sets up <code>ContinuousAt</code> and <code>ContinousOn</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n    <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">+</span>\n    <span class=\"n\">c</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"n\">S</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">t</span><span class=\"o\">))</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousOn</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">T</span> <span class=\"n\">S</span>\n  <span class=\"n\">fprop</span> <span class=\"o\">(</span><span class=\"n\">disch</span><span class=\"o\">:=(</span><span class=\"n\">rintro</span> <span class=\"n\">x</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">⟩</span><span class=\"bp\">;</span> <span class=\"n\">nlinarith</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 418177609,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706223185
    },
    {
        "content": "<p>When you do not provide discharger the trace looks like:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>trace</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">❌</span><span class=\"o\">]</span> <span class=\"n\">ContinuousOn</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">t</span> <span class=\"bp\">↦</span>\n        <span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">t</span><span class=\"o\">))</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">t</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">t</span> <span class=\"bp\">+</span> <span class=\"n\">t</span> <span class=\"bp\">+</span> <span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">t</span><span class=\"o\">))</span> <span class=\"bp\">+</span>\n          <span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">t</span> <span class=\"bp\">+</span> <span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">t</span><span class=\"o\">)))</span>\n      <span class=\"o\">(</span><span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"n\">applicable</span> <span class=\"n\">theorems</span> <span class=\"n\">for</span> <span class=\"n\">HAdd.hAdd</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">ContinuousOn.add</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">❌</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn.add</span>\n    <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">❌</span><span class=\"o\">]</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)))</span>\n          <span class=\"o\">(</span><span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n      <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"n\">applicable</span> <span class=\"n\">theorems</span> <span class=\"n\">for</span> <span class=\"n\">HAdd.hAdd</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">ContinuousOn.add</span><span class=\"o\">]</span>\n      <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">❌</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn.add</span>\n        <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">❌</span><span class=\"o\">]</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n          <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"n\">applicable</span> <span class=\"n\">theorems</span> <span class=\"n\">for</span> <span class=\"n\">HAdd.hAdd</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">ContinuousOn.add</span><span class=\"o\">]</span>\n          <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">❌</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn.add</span>\n            <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">❌</span><span class=\"o\">]</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n              <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"n\">applicable</span> <span class=\"n\">theorems</span> <span class=\"n\">for</span> <span class=\"n\">HDiv.hDiv</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">ContinuousOn.div''</span><span class=\"o\">]</span>\n              <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">❌</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn.div''</span>\n                <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n                  <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">continuousOn_const</span>\n                <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n                  <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"n\">applicable</span> <span class=\"n\">theorems</span> <span class=\"n\">for</span> <span class=\"n\">HAdd.hAdd</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">ContinuousOn.add</span><span class=\"o\">]</span>\n                  <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn.add</span>\n                    <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n                      <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"n\">applicable</span> <span class=\"n\">theorems</span> <span class=\"n\">for</span> <span class=\"n\">HAdd.hAdd</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">ContinuousOn.add</span><span class=\"o\">]</span>\n                      <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn.add</span>\n                        <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n                          <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"n\">applicable</span> <span class=\"n\">theorems</span> <span class=\"n\">for</span> <span class=\"n\">HSub.hSub</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">ContinuousOn.sub</span><span class=\"o\">]</span>\n                          <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn.sub</span>\n                            <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n                              <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">continuousOn_id'</span>\n                    <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n                      <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"n\">applicable</span> <span class=\"n\">theorems</span> <span class=\"n\">for</span> <span class=\"n\">HMul.hMul</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">ContinuousOn.mul</span><span class=\"o\">]</span>\n                      <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn.mul</span>\n                <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">❌</span><span class=\"o\">]</span> <span class=\"n\">discharging</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span>\n              <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">❌</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn.comp''</span>\n          <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">❌</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn.comp''</span>\n      <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">❌</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn.comp''</span>\n  <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">❌</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn.comp''</span>\n</code></pre></div>\n</div></div>\n<p>You can clearly see what went wrong from:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">❌</span><span class=\"o\">]</span> <span class=\"n\">applying</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn.div''</span>\n   <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n     <span class=\"bp\">...</span>\n   <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">✅</span><span class=\"o\">]</span> <span class=\"n\">ContinuousOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n     <span class=\"bp\">...</span>\n   <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fprop</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">❌</span><span class=\"o\">]</span> <span class=\"n\">discharging</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 418178782,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706223911
    },
    {
        "content": "<p>I want more theorems to prove :) Any other theorems about continuity(differentiability, ... ) that should be automated? Maybe something involving bundled morphisms?</p>",
        "id": 418179293,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706224212
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> here's a real-world example from <a href=\"https://github.com/leanprover-community/mathlib4/pull/9767\">#9767</a>. Can <code>fprop</code> take care of proving <code>h₀</code> and <code>h₁</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas</span>\n\n<span class=\"kd\">variable</span>\n  <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SMulCommClass</span> <span class=\"bp\">𝕜</span> <span class=\"n\">R</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ContinuousConstSMul</span> <span class=\"n\">R</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">𝕜</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">𝕜</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">UniqueDiffOn</span> <span class=\"bp\">𝕜</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"bp\">𝕜</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">iteratedDeriv_const_smul</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">𝕜</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">ContDiff</span> <span class=\"bp\">𝕜</span> <span class=\"n\">n</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"bp\">𝕜</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">iteratedDeriv</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">c</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">•</span> <span class=\"n\">iteratedDeriv</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">funext</span> <span class=\"n\">x</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₀</span> <span class=\"o\">:</span> <span class=\"n\">DifferentiableAt</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">iteratedDeriv</span> <span class=\"n\">n</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n      <span class=\"n\">h.differentiable_iteratedDeriv</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">Nat.cast_lt.mpr</span> <span class=\"n\">n.lt_succ_self</span><span class=\"o\">)</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">differentiableAt</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">DifferentiableAt</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">iteratedDeriv</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Function.comp_def</span><span class=\"o\">]</span>\n      <span class=\"n\">apply</span> <span class=\"n\">DifferentiableAt.comp</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">h.differentiable_iteratedDeriv</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">Nat.cast_lt.mpr</span> <span class=\"n\">n.lt_succ_self</span><span class=\"o\">)</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">differentiableAt</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">differentiableAt_id'.const_mul</span> <span class=\"n\">_</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">iteratedDeriv_succ</span><span class=\"o\">,</span> <span class=\"n\">ih</span> <span class=\"n\">h.of_succ</span><span class=\"o\">,</span> <span class=\"n\">deriv_const_smul</span> <span class=\"n\">_</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">iteratedDeriv_succ</span><span class=\"o\">,</span>\n      <span class=\"bp\">←</span> <span class=\"n\">Function.comp_def</span><span class=\"o\">,</span> <span class=\"n\">deriv.scomp</span> <span class=\"n\">x</span> <span class=\"n\">h₀</span> <span class=\"o\">(</span><span class=\"n\">differentiableAt_id'.const_mul</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n      <span class=\"n\">deriv_const_mul</span> <span class=\"n\">_</span> <span class=\"n\">differentiableAt_id'</span><span class=\"o\">,</span> <span class=\"n\">deriv_id''</span><span class=\"o\">,</span> <span class=\"n\">smul_smul</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">,</span> <span class=\"n\">pow_succ'</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 418327456,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1706292803
    },
    {
        "content": "<p>Heh, I thought I recognised that lemma</p>",
        "id": 418328099,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706293063
    },
    {
        "content": "<p>I think that this lemma should be true without <code>ContDiff</code> assumption.</p>",
        "id": 418328260,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706293125
    },
    {
        "content": "<p>We should have a lemma about <code>iteratedDeriv n (f ∘ e)</code>, where <code>e</code> is a <code>ContinuousLinearEquiv</code>.</p>",
        "id": 418328341,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706293158
    },
    {
        "content": "<p>Also, it should work for <code>c : R</code>, not only <code>c : k</code> (possibly, this version requires <code>ContDiffAt</code>).</p>",
        "id": 418328408,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706293187
    },
    {
        "content": "<p>And here I just wanted a lemma about <code>exp</code></p>",
        "id": 418328611,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706293245
    },
    {
        "content": "<p>Please comment on the pr (preferably with proof) if you want those generalisations before I land it :)</p>",
        "id": 418329152,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706293455
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> I think we may only have API currently for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IteratedFDeriv#doc\">docs#IteratedFDeriv</a>. I found <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousLinearEquiv.iteratedFDerivWithin_comp_right#doc\">docs#ContinuousLinearEquiv.iteratedFDerivWithin_comp_right</a></p>",
        "id": 418331805,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1706294490
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/porting.20.60fprop.60.20tactic/near/418327456\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> here's a real-world example from <a href=\"https://github.com/leanprover-community/mathlib4/pull/9767\">#9767</a>. Can <code>fprop</code> take care of proving <code>h₀</code> and <code>h₁</code>?</p>\n</blockquote>\n<p>This is a very nice example! I had to modify <code>fprop</code> as it had hard time inferring  <code>m</code> when using the theorem <code>ContDiff.differentiable_iteratedDeriv</code>.  </p>\n<p>Also I do not know which tactic can prove <code>∀ {n : ℕ}, (n : ℕ∞) &lt; (n : ℕ∞) + 1</code> automatically so I just stated it as theorem <code>lt_succ_self'</code> and used  discharger <code>exact lt_succ_self'</code></p>\n<p>Here is complete setup </p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.FProp</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Mathlib</span> <span class=\"n\">Qq</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span>\n\n\n<span class=\"kn\">section</span> <span class=\"n\">Missing</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">K</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">K</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">K</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">DifferentiableAt.comp'</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">DifferentiableAt</span> <span class=\"n\">K</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">DifferentiableAt</span> <span class=\"n\">K</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">DifferentiableAt</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">DifferentiableAt.comp</span> <span class=\"n\">x</span> <span class=\"n\">hg</span> <span class=\"n\">hf</span>\n\n\n<span class=\"kd\">end</span> <span class=\"n\">Missing</span>\n\n<span class=\"kd\">variable</span>\n  <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">K</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SMulCommClass</span> <span class=\"n\">K</span> <span class=\"n\">R</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ContinuousConstSMul</span> <span class=\"n\">R</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">UniqueDiffOn</span> <span class=\"n\">K</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">}</span>\n\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">fprop</span><span class=\"o\">]</span>\n  <span class=\"n\">Differentiable</span>\n\n  <span class=\"n\">ContDiff.differentiable_iteratedDeriv</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">fprop</span><span class=\"o\">]</span>\n  <span class=\"n\">DifferentiableAt</span>\n\n  <span class=\"n\">differentiableAt_id'</span>\n  <span class=\"n\">differentiableAt_const</span>\n  <span class=\"n\">DifferentiableAt.comp'</span>\n\n  <span class=\"n\">DifferentiableAt.mul</span>\n\n  <span class=\"n\">Differentiable.differentiableAt</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">fprop</span><span class=\"o\">]</span>\n  <span class=\"n\">ContDiff</span>\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lt_succ_self'</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.cast_lt.mpr</span> <span class=\"n\">n.lt_succ_self</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">ContDiff</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">DifferentiableAt</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">iteratedDeriv</span> <span class=\"n\">n</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fprop</span> <span class=\"o\">(</span><span class=\"n\">disch</span><span class=\"o\">:=(</span><span class=\"n\">exact</span> <span class=\"n\">lt_succ_self'</span><span class=\"o\">))</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">ContDiff</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">DifferentiableAt</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">iteratedDeriv</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fprop</span> <span class=\"o\">(</span><span class=\"n\">disch</span><span class=\"o\">:=(</span><span class=\"n\">exact</span> <span class=\"n\">lt_succ_self'</span><span class=\"o\">))</span>\n</code></pre></div>\n</div></div>",
        "id": 418342530,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706298891
    },
    {
        "content": "<p>I meant that we should add this if we don't have it yet.</p>",
        "id": 418342555,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706298905
    },
    {
        "content": "<p>This also works</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">ContDiff</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">ContDiff</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">DifferentiableAt</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">iteratedDeriv</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fprop</span> <span class=\"o\">(</span><span class=\"n\">disch</span><span class=\"o\">:=(</span><span class=\"n\">exact</span> <span class=\"n\">lt_succ_self'</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>I'm not sure how to approach this when the level of differentiability is not the same, these currently fail</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">ContDiff</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">ContDiff</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">DifferentiableAt</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">iteratedDeriv</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fprop</span> <span class=\"o\">(</span><span class=\"n\">disch</span><span class=\"o\">:=(</span><span class=\"n\">exact</span> <span class=\"n\">lt_succ_self'</span><span class=\"o\">))</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">ContDiff</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">ContDiff</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">DifferentiableAt</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">iteratedDeriv</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fprop</span> <span class=\"o\">(</span><span class=\"n\">disch</span><span class=\"o\">:=(</span><span class=\"n\">exact</span> <span class=\"n\">lt_succ_self'</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 418343927,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706299491
    },
    {
        "content": "<p>You have two assumptions named <code>hf</code>. Apparently, <code>fprop</code> can access the shadowed one.</p>",
        "id": 418344598,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706299799
    },
    {
        "content": "<p>Ohh right I missed that. Tactic using shadowed variables is not a problem, no?</p>",
        "id": 418344768,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706299874
    },
    {
        "content": "<p>In writing tactic you really do not care about the names of variables.</p>",
        "id": 418344859,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706299918
    },
    {
        "content": "<p>It becomes a bit of a problem if you add <code>fprop?</code> version which prints the generated proof.</p>",
        "id": 418345017,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706299987
    },
    {
        "content": "<p>I see, <code>fprop?</code> can easily check if the proof has free variables with valid names and warn user about it.</p>",
        "id": 418345314,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706300122
    },
    {
        "content": "<p>I think for the purpose of automation the theorem <code>ContDiff.differentiable_iteratedDeriv</code> should be stated as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">ContDiff.differentiable_iteratedDeriv'</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">ContDiff</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Differentiable</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">iteratedDeriv</span> <span class=\"n\">n</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ContDiff.differentiable_iteratedDeriv</span> <span class=\"n\">n</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">Nat.cast_lt.mpr</span> <span class=\"n\">n.lt_succ_self</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and then I have to think about how to properly apply \"transition theorem\" </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">ContDiff.of_lt</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">ContDiff</span> <span class=\"n\">K</span> <span class=\"n\">m</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ContDiff</span> <span class=\"n\">K</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 418348426,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706301643
    },
    {
        "content": "<p>I have created a PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/10040\">#10040</a> I would appreciate feedback/review.</p>",
        "id": 418741454,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706572034
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span>, I left a few fairly superficial comments.</p>\n<p>This is a great contribution, and I think we should merge soon. I'm pretty happy if we plan to shake out any problems as they arise. The test files are really great, and despite not planning on reading the meta code in detail, I'm happy to merge within a week or so if no other reviews eventuate!</p>",
        "id": 418753535,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1706579316
    },
    {
        "content": "<p>If forgot to mention that <code>RefinedDiscrTree</code> and <code>StateList</code> are not really part of this PR. There is <a href=\"https://github.com/leanprover/std4/pull/394\">std4#394</a> for it by <span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span>. <code>fprop</code> might be a good motivation for having another discriminatory tree as that was a concern of that PR.</p>",
        "id": 418753975,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706579689
    },
    {
        "content": "<p>I think the consensus though is that the new DiscrTree variants (which are potentially really great!) should incubate first in Mathlib. So <a href=\"https://github.com/leanprover/std4/pull/394\">std4#394</a> is unlikely to move fast.</p>\n<p>The only question is whether you want to split it into a separate Mathlib PR, or just deal with it in this PR. (My comment above about wanting to merge applies in either case.)</p>",
        "id": 418754457,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1706580026
    },
    {
        "content": "<p>I'm ok having it in one PR and probably easier for me. However, it is <span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span>'s code so it is probably his call if he wants to move the std PR over to mathlib.</p>",
        "id": 418755204,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706580496
    },
    {
        "content": "<p>I'm fine with it either way.</p>",
        "id": 418755727,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1706580869
    },
    {
        "content": "<p>The easiest thing for me is just keep it in the <code>Mathlib.Tactic.FProp</code> namespace. We can always move it later on.</p>",
        "id": 418755893,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706580982
    },
    {
        "content": "<p>The tactic name <code>fprop</code> might not be the best, <code>fun_prop</code> or <code>funprop</code> might be more descriptive. Should I rename it? I'm open to any other name suggestions too.</p>",
        "id": 418757421,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706582242
    },
    {
        "content": "<p>/poll Name of the tactic<br>\n<code>fprop</code><br>\n<code>funprop</code><br>\n<code>fun_prop</code></p>",
        "id": 418757435,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706582252
    },
    {
        "content": "<p><code>fun_prop</code> seems inconsistent with <code>funext</code> (the tactic)</p>",
        "id": 418778046,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706598119
    },
    {
        "content": "<p>I don't really like the <code>prop</code> suffix, it's a bit ambiguous (proposition or property?) and also vague about what it does</p>",
        "id": 418780116,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706599387
    },
    {
        "content": "<p><code>fun_rules</code>?</p>",
        "id": 418780267,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706599492
    },
    {
        "content": "<p>How does this differ from <code>apply_rules</code>? Is it just strictly better?</p>",
        "id": 418780316,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706599531
    },
    {
        "content": "<p>I was also thinking about naming along the lines \"higher order <code>apply_rules</code>\"</p>",
        "id": 418780413,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706599590
    },
    {
        "content": "<p>Is this a tactic users are meant to use directly, or is it meant to be wrapped? That is, will it replace <code>measurability</code>, or will <code>measurability</code> be reimplemented as a macro tactic for it?</p>",
        "id": 418780537,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706599681
    },
    {
        "content": "<p>It is meant to be used directly.</p>",
        "id": 418781060,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706599994
    },
    {
        "content": "<p>I don't have much experience with <code>apply_rules</code> but <code>fprop</code> is way more specialized. In some way, it can work only with one argument functions and has specialized unification for them. Multi argument functions are handled via curring.</p>",
        "id": 418781997,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706600559
    },
    {
        "content": "<p>If I'm not mistaken, <code>apply_rule</code> uses Lean's unification. <code>fprop</code> has custom unification to apply composition rule.</p>",
        "id": 418783637,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706601454
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/porting.20.60fprop.60.20tactic/near/418780116\">said</a>:</p>\n<blockquote>\n<p>I don't really like the <code>prop</code> suffix, it's a bit ambiguous (proposition or property?) and also vague about what it does</p>\n</blockquote>\n<p>It can stand for either. It proves propositions about functions or it proves function properties.</p>",
        "id": 418784472,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706601821
    },
    {
        "content": "<p>I don't understand the <code>funprop</code> name at all</p>",
        "id": 418789541,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706604065
    },
    {
        "content": "<p>Whereas you completely understand the name <code>omega</code></p>",
        "id": 418794627,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706605999
    },
    {
        "content": "<p>So we just pick a Greek letter that isn't in use yet?</p>",
        "id": 418798195,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706607287
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/287929-mathlib4/topic/porting.20.60fprop.60.20tactic/near/418798195\">said</a>:</p>\n<blockquote>\n<p>So we just pick a Greek letter that isn't in use yet?</p>\n</blockquote>\n<p>In that case I propose <code>lambda</code></p>",
        "id": 418798608,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1706607439
    },
    {
        "content": "<p>Note that <code>omega</code> is named the way it is because the decision procedure it uses is named that way (for reasons unknown to me) not because the author applied this heuristic.</p>",
        "id": 418798703,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1706607477
    },
    {
        "content": "<p>Nice bike shedding, I will change it to <code>fun_prop</code> :)  (secretly I want to call it <code>duh</code> because all the proofs are \"duh, obviously\")</p>\n<p>I added minimal setup files for <a href=\"https://github.com/leanprover-community/mathlib4/blob/lecopivo/fprop/Mathlib/Tactic/FunProp/Continuous.lean\">Continuous</a>, <a href=\"https://github.com/leanprover-community/mathlib4/blob/lecopivo/fprop/Mathlib/Tactic/FunProp/Differentiable.lean\">Differentiable</a>, <a href=\"https://github.com/leanprover-community/mathlib4/blob/lecopivo/fprop/Mathlib/Tactic/FunProp/ContDiff.lean\">ContDiff</a> I'm expecting that as some point theorems will me marked directly but while I'm refining the tactic it is better to have it in a separate file.</p>\n<p>What other function property should I setup? <code>Measurable</code>, <code>IsLinearMap</code>, something else?</p>",
        "id": 418919659,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706648585
    },
    {
        "content": "<p>I think before going too far with IsLinearMap, we should consider changing Linear map (and every other morphism) to take such a proof as a field</p>",
        "id": 418920935,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706649128
    },
    {
        "content": "<p>Maybe AEMeasurable and variants too?</p>",
        "id": 418920986,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706649160
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/porting.20.60fprop.60.20tactic/near/418920935\">said</a>:</p>\n<blockquote>\n<p>I think before going too far with IsLinearMap, we should consider changing Linear map (and every other morphism) to take such a proof as a field</p>\n</blockquote>\n<p>Are you talking about <a href=\"https://github.com/leanprover-community/mathlib4/pull/2202\">#2202</a>?</p>",
        "id": 418921599,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706649453
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/2202\">#2202</a> is a superset of what I'm describing</p>",
        "id": 418921701,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706649486
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/287929-mathlib4/topic/porting.20.60fprop.60.20tactic/near/418919659\">said</a>:</p>\n<blockquote>\n<p>secretly I want to call it <code>duh</code> because all the proofs are \"duh, obviously\"</p>\n</blockquote>\n<p>Maybe you should reclaim the name <code>obviously</code>, then!</p>",
        "id": 418928761,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706652536
    },
    {
        "content": "<p>Too many of our tactics can be named <code>obviously</code>...</p>",
        "id": 418936568,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706656047
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/porting.20.60fprop.60.20tactic/near/418921701\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/2202\">#2202</a> is a superset of what I'm describing</p>\n</blockquote>\n<p>Current discussion of <a href=\"https://github.com/leanprover-community/mathlib4/pull/2202\">#2202</a> (the \"set\" part, not the \"function\" part) happens in <a href=\"#narrow/stream/287929-mathlib4/topic/RFC.3A.20bundled.20sets.20.236442\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/RFC.3A.20bundled.20sets.20.236442</a></p>",
        "id": 418936710,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706656092
    },
    {
        "content": "<p>maybe we need to follow the isabelle convention of tactics with violent-sounding names</p>",
        "id": 418936887,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706656168
    },
    {
        "content": "<p>Like what, for people who never used Isabelle?</p>",
        "id": 418936967,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706656201
    },
    {
        "content": "<p>I'm thinking things like <code>crush</code>, <code>blast</code>, <code>demolish</code> etc</p>",
        "id": 418937037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706656219
    },
    {
        "content": "<p>Then we should have an editor plugin that tries all these generically named tactics and suggests the right one.</p>",
        "id": 418937159,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706656278
    },
    {
        "content": "<p>In this case I think we can do better than that though, this is not a kitchen sink tactic</p>",
        "id": 418937283,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706656330
    },
    {
        "content": "<p><code>fprop</code> is not a terrible candidate for <code>hint</code></p>",
        "id": 418937411,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1706656401
    },
    {
        "content": "<p>(Public service announcement for those who haven't been using it: please do report your experiences with <code>hint</code>!)</p>",
        "id": 418937467,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1706656429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/porting.20.60fprop.60.20tactic/near/418937411\">said</a>:</p>\n<blockquote>\n<p><code>fprop</code> is not a terrible candidate for <code>hint</code></p>\n</blockquote>\n<p>That might be a good idea as it should fail immediately on non applicable goals.</p>",
        "id": 418961977,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706672236
    },
    {
        "content": "<p>A message was moved from this topic to <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/feedback.20on.20.02klzzwxh.3A0000.03\">#mathlib4 &gt; feedback on <code>hint</code></a> by <span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span>.</p>",
        "id": 419163059,
        "sender_full_name": "Notification Bot",
        "timestamp": 1706756195
    },
    {
        "content": "<p>How do I make <code>hint</code> suggest <code>fun_prop</code>? I can easily write a function that looks at a goal and decides this should be solvable by <code>fun_prop</code> or not without actually running the tactic.</p>",
        "id": 419275506,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1706802559
    },
    {
        "content": "<p>Just <code>register_hint fun_prop</code>.</p>",
        "id": 419604965,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1706963434
    },
    {
        "content": "<p><code>fun_prop</code> made the tactic execution time for <a href=\"https://github.com/dwrensha/compfiles/commit/0b64e4ae5dc5dff50471d884d9d1e9fdf7ead520\">this proof</a> (the same one I linked to above) go from 2 seconds to 0.25 seconds.<br>\n<span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 419743806,
        "sender_full_name": "David Renshaw",
        "timestamp": 1707091100
    },
    {
        "content": "<p>What's the TL DR; of fprop?</p>",
        "id": 419824313,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1707134920
    },
    {
        "content": "<p>It is merged to mathlib now, I announced it in <a href=\"#narrow/stream/113488-general/topic/.60fun_prop.60.20new.20tactic.20for.20Differentiable.2C.20Continuous.2C.20.2E.2E.2E\">general</a>. Is that enough tldr?</p>",
        "id": 419824959,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707135127
    },
    {
        "content": "<p>Oh sorry. Didn't see that thread.</p>",
        "id": 419825169,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1707135200
    }
]