[
    {
        "content": "<p>I made an <code>abbrev ZHat : Type := (_ : Subring (some explicit product of concrete groups))</code>, i.e. I defined it as a subring but, because of problems with slowdowns in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NumberField.RingOfIntegers#doc\">docs#NumberField.RingOfIntegers</a>, I then coerced it to a type. But it doesn't solve the RingOfIntegers slowdown problem; once the theory of normed fields is imported, typeclass search can't get <code>NonUnitalCommRing ZHat</code> from <code>CommRing ZHat</code> without timing out, because it keeps going down rabbitholes like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>      <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">647223</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">Subalgebra.seminormedCommRing</span> <span class=\"n\">to</span> <span class=\"n\">SeminormedCommRing</span> <span class=\"n\">ZHat2</span> <span class=\"bp\">▼</span>\n        <span class=\"o\">[</span><span class=\"n\">tryResolve</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">647166</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">SeminormedCommRing</span> <span class=\"n\">ZHat2</span> <span class=\"bp\">≟</span> <span class=\"n\">SeminormedCommRing</span> <span class=\"bp\">↥?</span><span class=\"n\">m.5971</span> <span class=\"bp\">▼</span>\n          <span class=\"o\">[</span><span class=\"n\">isDefEq</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">647150</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">SeminormedCommRing</span> <span class=\"n\">ZHat2</span> <span class=\"bp\">=?=</span> <span class=\"n\">SeminormedCommRing</span> <span class=\"bp\">↥?</span><span class=\"n\">m.5971</span> <span class=\"bp\">▼</span>\n            <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">647106</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">ZHat2</span> <span class=\"bp\">=?=</span> <span class=\"bp\">↥?</span><span class=\"n\">m.5971</span> <span class=\"bp\">▼</span>\n              <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">647081</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"bp\">↥</span><span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"bp\">|</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"n\">D</span> <span class=\"bp\">∣</span> <span class=\"bp\">↑</span><span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">ZMod.castHom</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">ZMod</span> <span class=\"bp\">↑</span><span class=\"n\">D</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">D</span><span class=\"o\">},</span>\n                      <span class=\"n\">mul_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">ZHat2.proof_2</span><span class=\"o\">,</span> <span class=\"n\">one_mem'</span> <span class=\"o\">:=</span> <span class=\"n\">ZHat2.proof_3</span><span class=\"o\">,</span> <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">ZHat2.proof_4</span><span class=\"o\">,</span>\n                      <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"n\">ZHat2.proof_5</span><span class=\"o\">,</span> <span class=\"n\">neg_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">ZHat2.proof_6</span> <span class=\"o\">}</span> <span class=\"bp\">=?=</span> <span class=\"bp\">↥?</span><span class=\"n\">m.5971</span> <span class=\"bp\">▶</span>\n</code></pre></div>\n<p>and then </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">900950</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">Subalgebra.normedCommRing</span> <span class=\"n\">to</span> <span class=\"n\">NormedCommRing</span> <span class=\"n\">ZHat2</span>\n</code></pre></div>\n<p>with the same sort of trace, and you're usually in trouble if the ring structure explodes. I've had to fix it with <code>def ZHat...</code> instead of <code>abbrev ZHat</code>.  Here's some code which indicates the problem.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.ZMod.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.Polynomial.Basic</span>\n<span class=\"c1\">--next import makes `#synth NonUnitalCommRing ZHat2` overflow</span>\n<span class=\"c1\">-- import Mathlib.Analysis.Normed.Field.Basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ZHat1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n<span class=\"o\">({</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">,</span> <span class=\"n\">ZMod</span> <span class=\"n\">M</span> <span class=\"bp\">|</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">∣</span> <span class=\"n\">N</span><span class=\"o\">),</span>\n    <span class=\"n\">ZMod.castHom</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">ZMod</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">D</span> <span class=\"o\">},</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">neg_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">one_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">mul_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Subring</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">,</span> <span class=\"n\">ZMod</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- works great</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"n\">ZHat1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">ZHat1</span><span class=\"bp\">;</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"c1\">-- works great, even with `import Mathlib`</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">NonUnitalCommRing</span> <span class=\"n\">ZHat1</span>\n\n<span class=\"c1\">-- now try with abbrev not def</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">ZHat2</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n<span class=\"o\">({</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">,</span> <span class=\"n\">ZMod</span> <span class=\"n\">M</span> <span class=\"bp\">|</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">∣</span> <span class=\"n\">N</span><span class=\"o\">),</span>\n    <span class=\"n\">ZMod.castHom</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">ZMod</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">D</span> <span class=\"o\">},</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">neg_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">one_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">mul_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Subring</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">,</span> <span class=\"n\">ZMod</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- works great</span>\n<span class=\"kd\">instance</span> <span class=\"n\">commRing2</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"n\">ZHat2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"c1\">-- but this is too slow with the normed field import</span>\n<span class=\"c1\">--set_option synthInstance.maxHeartbeats 40000 in</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">NonUnitalCommRing</span> <span class=\"n\">ZHat2</span>\n</code></pre></div>\n<p>For any kind of type coerced from a term, the algebra hierarchy is currently very fragile because of things like this (and of course, more imports make it worse)</p>",
        "id": 437169872,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1714950162
    },
    {
        "content": "<p>I think the whole point in the \"type not subring\" trick was to also make the type semireducible</p>",
        "id": 437170595,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714950923
    },
    {
        "content": "<p>If you make it reducible (an <code>abbrev</code>), then the choice of type vs subring has no performance impact</p>",
        "id": 437170607,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714950958
    },
    {
        "content": "<p>As an aside, note that <code>({ a := _ } : A)</code> can be written a little more concisely as <code>{ a := _ : A }</code></p>",
        "id": 437170753,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714951111
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Bitten.20by.20same.20problem.20as.20RingOfIntegers/near/437169872\">said</a>:</p>\n<blockquote>\n<p>because it keeps going down rabbitholes like</p>\n</blockquote>\n<p>I'm playing around with instance priorities in <a href=\"https://github.com/leanprover-community/mathlib4/pull/12680\">#12680</a>, maybe this helps here?</p>",
        "id": 437217835,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1714984429
    }
]