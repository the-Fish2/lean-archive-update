[
    {
        "content": "<p>In working on <a href=\"https://github.com/leanprover-community/mathlib4/pull/9372\">#9372</a>, I found that I could not fill in three <code>sorry</code>'s in the following, where each sorry revolves around the behaviour of Set.indicator:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Constructions.Prod.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Measure.MeasureSpace</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Measure</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">conv_int</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BorelSpace</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">ν</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Measure.ofMeasurable</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"n\">hs</span> <span class=\"bp\">↦</span> <span class=\"bp\">∫⁻</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∫⁻</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">s.indicator</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span> <span class=\"bp\">∂</span><span class=\"n\">ν</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.indicator_empty</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"n\">hfdis</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">MeasureTheory.lintegral_tsum</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">congr</span>\n      <span class=\"n\">ext</span> <span class=\"n\">x</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">MeasureTheory.lintegral_tsum</span><span class=\"o\">]</span>\n      <span class=\"bp\">·</span> <span class=\"n\">congr</span>\n        <span class=\"n\">ext</span> <span class=\"n\">y</span>\n        <span class=\"gr\">sorry</span>\n      <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">i</span>\n        <span class=\"gr\">sorry</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">i</span>\n      <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The first is due to that we only have things like <a href=\"https://github.com/leanprover-community/mathlib4/blob/8666bd82efec40b8b3a5abca02dc9b24bbdf2652/Mathlib/Algebra/IndicatorFunction.lean#L668-L668\">https://github.com/leanprover-community/mathlib4/blob/8666bd82efec40b8b3a5abca02dc9b24bbdf2652/Mathlib/Algebra/IndicatorFunction.lean#L668-L668</a> and not a countable version of this (we'd perhaps need non-negativity assumptions, but these are fine in my setting). <br>\nThe second and third seem very easy, but my various Loogle and Moogle searches have failed me so far...</p>",
        "id": 413183319,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1705419871
    },
    {
        "content": "<p>What's your goal? E.g., can you define the measure you're looking for using existing <code>prod</code>, <code>map</code>, and <code>withDensity</code> constructions?</p>",
        "id": 413188758,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705421243
    },
    {
        "content": "<p>Or some of these constructions need more assumptions about the original measures than you want to have here?</p>",
        "id": 413188860,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705421282
    },
    {
        "content": "<p>(e.g., can we assume that the measures are <code>SFinite</code>?)</p>",
        "id": 413189031,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705421332
    },
    {
        "content": "<p>So what I'm trying to do is to define a definition of the convolution of measures, different from the one in my PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/9372\">#9372</a>, to hopefully show (at one point) that they're equal, to add some more API to that PR (I feel that sometimes this definition may be easier to show certain properties of convolutions)</p>",
        "id": 413189439,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1705421461
    },
    {
        "content": "<p>The other definition, <code>conv</code> in <a href=\"https://github.com/leanprover-community/mathlib4/pull/9372\">#9372</a>, does not use <code>SFinite</code>. In the above problem, only one of the <code>sorry</code>'s has an integral, so I would want to avoid <code>SFinite</code> if possible.</p>",
        "id": 413189964,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1705421617
    },
    {
        "content": "<p>(I'm aware that naming the intro <code>f</code> is bad practice as it is a collection of sets, I'll rename that if I add it to the PR of course)</p>",
        "id": 413190167,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1705421664
    },
    {
        "content": "<p>The definition doesn't need <code>SFinite</code> but commutativity may need it.</p>",
        "id": 413194731,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705423021
    },
    {
        "content": "<p>What properties of the convolution need this definition and don't follow from the definition using <code>prod</code> and <code>map</code>?</p>",
        "id": 413194816,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705423052
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Three.20questions.20on.20Set.2Eindicator/near/413194816\">said</a>:</p>\n<blockquote>\n<p>What properties of the convolution need this definition and don't follow from the definition using <code>prod</code> and <code>map</code>?</p>\n</blockquote>\n<p>I'm not yet sure which definitions exactly, I would think that associativity may be easier through this channel. Besides that, it is a common way of writing convolution of measures, so I thought we'd like to have it anyway (as a definition or a theorem)?</p>",
        "id": 413195257,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1705423212
    },
    {
        "content": "<p>It may be easier to do it as a theorem.</p>",
        "id": 413196850,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705423696
    },
    {
        "content": "<p>We try to have only 1 definition of each notion and link other \"definitions\" by theorems.</p>",
        "id": 413197027,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705423750
    },
    {
        "content": "<p>Okay! I’ll rewrite it to that later today/this week and see whether my problems disappear!</p>",
        "id": 413197391,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1705423850
    },
    {
        "content": "<p>I've returned to this and tried to show the following, which I think is about the right way of writing that the <code>map</code>-based definition equals the integral-based one, but I just don't manage to simplify this further. I tried using <code>MeasureTheory.lintegral_prod</code>, but it doesn't seem to work.... </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Constructions.Prod.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Measure.MeasureSpace</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Measure</span>\n\n<span class=\"sd\">/-- Convolutions of measures. They are defined for arbitrary measures on a monoid M that is also</span>\n<span class=\"sd\">a measurable space. TODO: should get a to_additive version for AddMonoids -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">conv</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ν</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Measure</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">Measure.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">×</span> <span class=\"n\">M</span> <span class=\"bp\">↦</span> <span class=\"n\">x.1</span> <span class=\"bp\">*</span> <span class=\"n\">x.2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Measure.prod</span> <span class=\"n\">μ</span> <span class=\"n\">ν</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">convolution_eq_lintegral</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalGroup</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BorelSpace</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">ν</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">SFinite</span> <span class=\"n\">μ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SFinite</span> <span class=\"n\">ν</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hB</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSet</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">μ.conv</span> <span class=\"n\">ν</span><span class=\"o\">)</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"bp\">∫⁻</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∫⁻</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">B.indicator</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span> <span class=\"bp\">∂</span><span class=\"n\">ν</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">conv</span><span class=\"o\">]</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 417282329,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1705945170
    },
    {
        "content": "<p>I’m still trying to get the hang of map and lintegrals, so any pointers (or a solution) are highly appreciated!</p>",
        "id": 417284720,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1705945975
    },
    {
        "content": "<p>Probably the assumptions can be weakened, but I wanted to have a ‘nice’ setting first</p>",
        "id": 417284808,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1705946007
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/9372\">#9372</a> is a PR just introducing the definition of convolution of measures and some very basic results, any feedback on this is very welcome as well as API additions!</p>",
        "id": 419535226,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1706908060
    }
]