[
    {
        "content": "<p>I'm a relative newb but I've been playing around with some types/theorems involving <code>Nonempty</code> and have been finding that the simplifier chokes on them a lot because of <code>not_nonempty_iff</code>. It turns <code>Not Nonempty</code> into <code>IsEmpty</code>, then all of the automation that would normally handle inverted props stops working when I have expressions which involve both <code>Nonempty α</code> and <code>¬ Nonempty α</code>.</p>\n<p>My life improved a lot when I worked out that I could do <code>attribute [-simp] not_nonempty_iff</code>.  (By the way, <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/tactics.html\">https://leanprover.github.io/theorem_proving_in_lean4/tactics.html</a> doesn't mention this and in fact implies that it's impossible. It might be a good idea to change that?)</p>\n<p>Perhaps my trick of removing the attribute is the \"correct\" way to handle this, but I was wondering whether it was worth reconsidering whether <code>not_nonempty_iff</code> should be marked as <code>@[simp]</code>?</p>\n<p>I expect it adds value in other situations which outweigh this issue, but I thought I'd raise it just in case.</p>",
        "id": 424812852,
        "sender_full_name": "Sam",
        "timestamp": 1709625226
    },
    {
        "content": "<p>You can try to remove the <code>simp</code> attribute and see what happens. (You don't need to recompile everything by yourself, just open a PR and CI will do it).</p>",
        "id": 424818708,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1709627696
    },
    {
        "content": "<p>What kind of theorems are you proving though? In practice you don't really get <code>\\not Nonempty alpha</code>.</p>",
        "id": 424820459,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709628291
    },
    {
        "content": "<p>Also, are you aware that you can make a specific simp call not use a specific lemma? The syntax is <code>simp [-not_nonempty_iff]</code></p>",
        "id": 424820572,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709628346
    },
    {
        "content": "<p>Yeah it's quite possible that I'm doing something atypical or silly. I'm playing around with some quite trivial things for learning purposes. One of them is this, i.e. a bundling of types where either they're all nonempty or none of them are.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Badly named</span>\n<span class=\"kd\">structure</span> <span class=\"n\">EquivTypeSet</span> <span class=\"n\">where</span>\n  <span class=\"n\">types</span><span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- We use Not Nonempty instead of IsEmpty,</span>\n  <span class=\"c1\">-- because tactics have a hard type jumping between the two.</span>\n  <span class=\"n\">pred</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">α</span> <span class=\"bp\">∈</span> <span class=\"n\">types</span><span class=\"o\">,</span> <span class=\"n\">Nonempty</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">α</span> <span class=\"bp\">∈</span> <span class=\"n\">types</span><span class=\"o\">,</span> <span class=\"n\">Not</span> <span class=\"o\">(</span><span class=\"n\">Nonempty</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>A lot of my basic theorems on this then involve handling the empty and nonempty cases. Perhaps I should instead just look for a different way of defining it.</p>",
        "id": 424821407,
        "sender_full_name": "Sam",
        "timestamp": 1709628687
    },
    {
        "content": "<p>I'm aware of <code>simp [-not_nonempty_iff]</code>, but it's a little annoying to have to do that every time I want to quickly try <code>simp</code> and see where it gets me, and when using <code>hint</code>. Obviously nothing about this is a showstopper - it's just a small usability thing.</p>",
        "id": 424821747,
        "sender_full_name": "Sam",
        "timestamp": 1709628806
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/287929-mathlib4/topic/not_nonempty_iff.20can.20be.20annoying.20as.20a.20simp.20lemma/near/424818708\">said</a>:</p>\n<blockquote>\n<p>You can try to remove the <code>simp</code> attribute and see what happens. (You don't need to recompile everything by yourself, just open a PR and CI will do it).</p>\n</blockquote>\n<p>Yeah - I just thought it best to ask less formally here before bothering the repo with my potentially silly ideas!</p>",
        "id": 424821809,
        "sender_full_name": "Sam",
        "timestamp": 1709628838
    },
    {
        "content": "<p>Wouldn’t it be easier to use IsEmpty in your definition? There should be a result linking that directly to the negation of Nonempty, and I think we have much more API for IsEmpty</p>",
        "id": 424822232,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1709628979
    },
    {
        "content": "<p>Oh - like have them both use <code>IsEmpty</code>, i.e. switch the <code>Nonempty</code> to <code>Not Nonempty</code>? I haven't tried that - it could be an option!</p>\n<p>But having them both be the same is nice. For example the <code>tauto</code> here breaks if one is <code>Nonempty</code> and the other is <code>IsEmpty</code>. When they were opposites I was finding that I was rewriting them to be the same again and again.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kd\">theorem</span> <span class=\"n\">exists_nonempty</span> <span class=\"o\">{</span><span class=\"n\">ets</span><span class=\"o\">:</span> <span class=\"n\">EquivTypeSet</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">α</span> <span class=\"bp\">∈</span> <span class=\"n\">ets</span><span class=\"o\">,</span> <span class=\"n\">Nonempty</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">β</span> <span class=\"bp\">∈</span> <span class=\"n\">ets</span><span class=\"o\">,</span> <span class=\"n\">Nonempty</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">cases</span> <span class=\"n\">ets.pred</span>\n    <span class=\"n\">assumption</span>\n    <span class=\"n\">tauto</span>\n</code></pre></div>",
        "id": 424822928,
        "sender_full_name": "Sam",
        "timestamp": 1709629213
    },
    {
        "content": "<p>Oops - that example relies on this instance to work</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Membership</span> <span class=\"o\">(</span><span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">EquivTypeSet</span> <span class=\"n\">where</span>\n    <span class=\"n\">mem</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ets</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">ets.types</span>\n</code></pre></div>",
        "id": 424823219,
        "sender_full_name": "Sam",
        "timestamp": 1709629310
    },
    {
        "content": "<p>Yeah, it is a trade-off. We added Uncountable recently because carrying Not Countable was not convenient for some use-cases, I think it came at the cost of having to unfold the definition sometimes.</p>",
        "id": 424838151,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1709634549
    },
    {
        "content": "<p>Can you elaborate on why <code>pred : (∀ α ∈ types, Nonempty α) ∨ (∀ α ∈ types, IsEmpty α)</code> doesn't work for you?</p>",
        "id": 424842799,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709636124
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Sure - here's a self contained repro of the <code>exists_nonempty</code> issue mentioned above.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- This is needed to make aesop work on the easier Not Nonempty version</span>\n<span class=\"c1\">-- - Without it, aesop starts by simping into the harder version, then gets stuck</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">not_nonempty_iff</span>\n\n<span class=\"kd\">example</span>\n  <span class=\"o\">(</span><span class=\"n\">types</span><span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">pred</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">α</span> <span class=\"bp\">∈</span> <span class=\"n\">types</span><span class=\"o\">,</span> <span class=\"n\">Nonempty</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">α</span> <span class=\"bp\">∈</span> <span class=\"n\">types</span><span class=\"o\">,</span> <span class=\"n\">Not</span> <span class=\"o\">(</span><span class=\"n\">Nonempty</span> <span class=\"n\">α</span><span class=\"o\">)))</span>\n  <span class=\"c1\">-- (pred: (∀ α ∈ types, Nonempty α) ∨ (∀ α ∈ types, IsEmpty α))</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">α</span> <span class=\"bp\">∈</span> <span class=\"n\">types</span><span class=\"o\">,</span> <span class=\"n\">Nonempty</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">β</span> <span class=\"bp\">∈</span> <span class=\"n\">types</span><span class=\"o\">,</span> <span class=\"n\">Nonempty</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">pred</span>\n  <span class=\"n\">assumption</span>\n  <span class=\"n\">tauto</span> <span class=\"c1\">-- or aesop</span>\n</code></pre></div>\n<p>We <code>cases</code> the <code>Or</code>, show the first case by <code>assumption</code>, and show the second case is a contradiction by <code>h</code>.</p>\n<p>This latter step can be tackled by tactics like <code>tauto</code> and <code>aesop</code> in this form, but if we change it to <code>IsEmpty</code> they don't get it because they're not spotting the identities involving negated predicates.</p>\n<p>Of course I could use <code>IsEmpty</code> in the definition and just add a <code>rw</code> step into the proof, but it felt messy to keep doing that and this felt cleaner to my inexperienced eye.</p>\n<p>The issue with the simp lemma is that it aggressively tries to put things into the form which blocks <code>tauto</code>. Which again is perfectly workaroundable, but feels annoying/unclean.</p>",
        "id": 424857159,
        "sender_full_name": "Sam",
        "timestamp": 1709641472
    },
    {
        "content": "<p>Actually it's worse than that! I just realised. Without doing <code>attribute [-simp] not_nonempty_iff</code>, <code>aesop</code> actually fails on both versions - including the <code>Not Nonempty</code> one!</p>\n<p>I assume it's aggressively applying <code>simp</code> internally and tripping itself up. <code>tauto</code> still works.</p>",
        "id": 424857405,
        "sender_full_name": "Sam",
        "timestamp": 1709641576
    },
    {
        "content": "<p>Doing it with <code>IsEmpty</code> gives the following proof, which is slightly longer: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"kd\">example</span>\n    <span class=\"o\">(</span><span class=\"n\">types</span><span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">pred</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">α</span> <span class=\"bp\">∈</span> <span class=\"n\">types</span><span class=\"o\">,</span> <span class=\"n\">Nonempty</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">α</span> <span class=\"bp\">∈</span> <span class=\"n\">types</span><span class=\"o\">,</span> <span class=\"n\">IsEmpty</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">α</span> <span class=\"bp\">∈</span> <span class=\"n\">types</span><span class=\"o\">,</span> <span class=\"n\">Nonempty</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">β</span> <span class=\"bp\">∈</span> <span class=\"n\">types</span><span class=\"o\">,</span> <span class=\"n\">Nonempty</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">pred</span>\n  <span class=\"bp\">·</span> <span class=\"n\">assumption</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"n\">hc</span><span class=\"o\">⟩</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">not_isEmpty_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hc</span>\n    <span class=\"n\">tauto</span>\n</code></pre></div>",
        "id": 424860559,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1709642677
    },
    {
        "content": "<p>Yeah that's what I did first, then I changed the definition to avoid the <code>rw</code> because it felt messy to have to repeat that step in multiple theorems. I'm very open to the fact that may have been a silly deviation from best practice!? As a relatively inexperienced user I currently have a strong bias towards putting things in forms that make it as easy as possible for automation to do all the work for me so I don't have to mess about with finding/remembering the right theorems in the library.</p>\n<p>I'm definitely bikeshedding between two perfectly good ways of doing it here.</p>",
        "id": 424862380,
        "sender_full_name": "Sam",
        "timestamp": 1709643245
    },
    {
        "content": "<p>So here is my motivation for using IsEmpty; which is the same reason why we introduced <code>Uncountable</code> for <code>Not Countable</code> a while back:<br>\nin the following, the thing to be proven is not material, it is about the instance implicit terms. For the former, we get an error, for the latter, we don't:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Not</span> <span class=\"o\">(</span><span class=\"n\">Countable</span> <span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">X</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Uncountable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">X</span>\n</code></pre></div>",
        "id": 424863342,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1709643533
    },
    {
        "content": "<p>same for your <code>Not Nonempty</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Not</span> <span class=\"o\">(</span><span class=\"n\">Nonempty</span> <span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">X</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsEmpty</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">X</span>\n</code></pre></div>",
        "id": 424863454,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1709643573
    },
    {
        "content": "<p>I agree that you have to use <code>rw</code> a bit more, but the fact that you get access to this way of using instance implicit terms seems worthwhile to me.</p>",
        "id": 424863682,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1709643632
    },
    {
        "content": "<p>That makes total sense!</p>\n<p>However the thing that felt weird to me is that <code>simp</code> thinks the simplest form of the expression <code>(Nonempty α) ∨ ¬(Nonempty α)</code> is <code>(Nonempty α) ∨ (IsEmpty α)</code>. That hides the simple fact that one is a clear opposite of the other, and blocks reasoning by other tactics. The fact that it fully blocks <code>aesop</code> from working in this case seems quite bad?</p>\n<p>I see the clear value of <code>IsEmpty</code> existing - it's just not (yet) obvious to me why <code>not_nonempty_iff</code> should be a default simp lemma. But perhaps it's useful more often than it hinders!</p>",
        "id": 424864126,
        "sender_full_name": "Sam",
        "timestamp": 1709643750
    },
    {
        "content": "<p>That is a very good question, I don't know what the answer is to that</p>",
        "id": 424864624,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1709643928
    },
    {
        "content": "<p>I wonder if adding <code>coes</code> between them might occasionally be helpful? But I don't think that addresses the issue with things like <code>aesop</code>, so it's probably a sidetrack. (Edit: Tried it, can confirm it doesn't help.)</p>\n<p>I sort of wish there were a way to modify the \"matcher\" (whatever Lean calls that) to treat them as truly identical for the purposes of tactic automation - but I don't think that exists!?</p>",
        "id": 424866874,
        "sender_full_name": "Sam",
        "timestamp": 1709644633
    },
    {
        "content": "<p>My (humble newbie) assertion would be that any time you have a theorem involving both <code>Nonempty</code> and <code>IsEmpty</code>, the simplest form is to pick one or the other and stick with it. Having both side by side obscures the logic and blocks automation.</p>\n<p>The current behaviour of having <code>not_nonempty_iff</code> and <code>not_isEmpty_iff</code> be <code>simp</code> lemmas means the simplifier actively works against this. If you put them in the same form, it splits them back up again and kills <code>aesop</code>.</p>\n<p>It looks like there are two ways this could be addressed:</p>\n<ol>\n<li>Remove <code>@[simp]</code> from both lemmas and let the user choose how they want to handle this. The simplifier will no longer work against you when you put them both in the same form, but it won't help you when you only have one, either.</li>\n<li>Pick one form to be canonical, and have the simplifier move everything in that direction. The other form would be reserved mainly for use in type class inference. I think this would have the best automation results, but would occasionally be slightly ugly when dealing with <code>Not</code> everywhere. (This is what I've done locally in my tiny project and it feels nice so far.)</li>\n</ol>\n<p>I assume the same would go for <code>Countable</code> and <code>Uncountable</code>.</p>\n<p>Thoughts? I really don't know the bigger picture here.</p>",
        "id": 424872909,
        "sender_full_name": "Sam",
        "timestamp": 1709646474
    },
    {
        "content": "<p>We have learnt after a lot of experiments that it's better to have <code>Countable</code> and <code>Uncountable</code> instead of <code>Countable</code> and <code>¬ Countable</code>, and a simp lemma converting <code>¬ Countable</code> to <code>Uncountable</code>. In most cases, you have one assumption or the other one, but not the two of them together, and having one definite name to speak about it enables dot notation and typeclass resolution. The situation you're considering in your application is quite specific and a little bit artificial, and therefore probably a little bit misleading as to what works best most of the time. Of course, no design choice is perfect in all situations!</p>",
        "id": 424878455,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1709648158
    },
    {
        "content": "<p>Note that, in concrete situations, lemmas like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=isEmpty_or_nonempty#doc\">docs#isEmpty_or_nonempty</a> make it possible to discuss separately the case where a type is empty or nonempty without encountering a single negation.</p>",
        "id": 424878975,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1709648315
    },
    {
        "content": "<p>Right - that makes total sense <span class=\"user-mention\" data-user-id=\"110050\">@Sébastien Gouëzel</span>! I'm very happy to believe that the inconvenience in this case is outweighed by good reasons in others, and that the situation I'm in is simply the low priority outlier!</p>",
        "id": 424881994,
        "sender_full_name": "Sam",
        "timestamp": 1709649146
    }
]