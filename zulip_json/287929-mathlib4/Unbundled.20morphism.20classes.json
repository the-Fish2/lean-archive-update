[
    {
        "content": "<p>I see that the unbundled classes <code>IsAddHom</code>, <code>IsGroupHom</code> etc are deprecated in Mathlib, and the bundled morphisms are recommended as a replacement. However, I'm not seeing how to use them for what I need.</p>\n<p>I'm trying to build a data structure (<code>FilteredReal α</code>) that wraps types that represent subsets of the reals (and wraps them with floating-point intervals to improve performance). My WIP implementation is <a href=\"https://github.com/mdgeorge4153/cglean/blob/main/CGLean/Data/FilteredReal.lean\">here</a>.</p>\n<p>I can implement various operation typeclasses (e.g. <code>Zero</code>, <code>One</code>, <code>Add</code>, etc) on my wrapped type, but only if the underlying subset supports those operations and they commute with the embedding. (e.g. I can implement <code>One</code> if <code>α</code> has a <code>One</code> and if <code>coe (1 : α) = (1 : ℝ)</code>). It seems sensible to encode this using typeclasses:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">One</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsOneHom</span><span class=\"w\"> </span><span class=\"n\">coe</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">One</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FilteredReal</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"w\">    </span><span class=\"c1\">-- dependent value can only be constructed using `IsOneHom` instance</span>\n</code></pre></div>\n<p>The fact that Mathlib has migrated away from unbundled morphism classes makes me think that this design is not idiomatic. On the other hand, I don't see how to implement this with bundled morphisms, unless I make a separate <code>FilteredReal</code> structure for each combination of operations that I want to support. I wonder what's the \"right\" approach here? I'm also curious about why mathlib has shifted to favor bundled morphisms.</p>",
        "id": 440854487,
        "sender_full_name": "Michael George",
        "timestamp": 1716816177
    },
    {
        "content": "<p>You're right that there isn't a good way to express this property. On the other hand I'm worried that using <code>Coe</code> will bring you more trouble. Since <code>Coe.coe</code> doesn't actually appear in the elaborated coercions you're probably going to run into issues trying to simplify. Is it a good idea to parametrize over a function <code>(f : α → ℝ)</code> instead of over an instance <code>[Coe α ℝ)</code>. (Also: coercions are hard to parametrize over because coercions are actually elaborated as the transitive closure of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Coe#doc\">docs#Coe</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CoeHead#doc\">docs#CoeHead</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CoeTail#doc\">docs#CoeTail</a> etc.)</p>",
        "id": 440860660,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1716818151
    },
    {
        "content": "<p>Concretely:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">FilteredReal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">value</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Thunk</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">range</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Around</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">value.get</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simps</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ZeroHomClass</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FilteredReal</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Thunk.get</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">map_zero</span><span class=\"o\">]⟩</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 440860950,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1716818227
    },
    {
        "content": "<p>Thanks, that makes sense. I think what I was missing is that the Funlike instance allows me to not have to change the argument to FilteredReal.</p>",
        "id": 440895698,
        "sender_full_name": "Michael George",
        "timestamp": 1716831386
    }
]