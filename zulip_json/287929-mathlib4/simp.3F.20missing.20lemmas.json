[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Says</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- simp [hx] -- no goals</span>\n  <span class=\"n\">simp</span><span class=\"bp\">?</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span> <span class=\"n\">says</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">List.mem_cons</span><span class=\"o\">,</span> <span class=\"n\">List.mem_singleton</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- ⊢ x = a ∨ x = b ∨ x ∈ []</span>\n  <span class=\"n\">simp</span><span class=\"bp\">?</span> <span class=\"n\">says</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">List.not_mem_nil</span><span class=\"o\">,</span> <span class=\"n\">or_false</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- ⊢ x = a ∨ x = b</span>\n  <span class=\"n\">simp</span><span class=\"bp\">?</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span> <span class=\"n\">says</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>It appers that <code>simp?</code> leaves out some lemmas that the <code>simp</code> call actually uses.</p>",
        "id": 412710900,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705153220
    },
    {
        "content": "<p>The problem is not so much <code>simp?</code> leaving anything out that it used, but rather the <code>simp only</code> call using the lemmas in a different way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.List.Lemmas</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.simp.rewrite</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- [Meta.Tactic.simp.rewrite] @List.mem_cons:1000, x ∈ [a, b] ==&gt; x = a ∨ x ∈ [b]</span>\n  <span class=\"c1\">-- [Meta.Tactic.simp.rewrite] @List.mem_singleton:1100, x ∈ [b] ==&gt; x = b</span>\n  <span class=\"c1\">-- [Meta.Tactic.simp.rewrite] hx:1000, x = a ∨ x = b ==&gt; True</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">List.mem_cons</span><span class=\"o\">,</span> <span class=\"n\">List.mem_singleton</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- [Meta.Tactic.simp.rewrite] @List.mem_cons:1000, x ∈ [a, b] ==&gt; x = a ∨ x ∈ [b]</span>\n  <span class=\"c1\">-- [Meta.Tactic.simp.rewrite] @List.mem_cons:1000, x ∈ [b] ==&gt; x = b ∨ x ∈ []</span>\n</code></pre></div>",
        "id": 412773751,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1705200163
    },
    {
        "content": "<p>The problem is that <code>mem_singleton</code> has priority 1100, but when we provide it as a term in a <code>simp only</code> call this priority is forgotten, and so it doesn't get promoted ahead of <code>mem_cons</code>.</p>",
        "id": 412773908,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1705200292
    },
    {
        "content": "<p>I'm not sure how to fix this!</p>\n<ul>\n<li>Could we look up the priorities for explicitly provided simp lemmas? (this seems best if it is implementable)</li>\n<li>Could we provide a way of specifying priorities in <code>simp only</code>? And generate these priorities in <code>simp?</code>?</li>\n</ul>",
        "id": 412774035,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1705200378
    },
    {
        "content": "<p>why not both?</p>",
        "id": 412774099,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705200460
    },
    {
        "content": "<p>I'm not sure if it is more or less surprising to get the priority of an explicitly passed simp lemma from the <code>@[simp N]</code> attribute</p>",
        "id": 412774168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705200518
    },
    {
        "content": "<p>but a <code>(prio := N)</code> argument to simp lemmas in an explicit <code>simp [...]</code> call sounds like it would be useful for simp-set macros</p>",
        "id": 412774273,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705200610
    },
    {
        "content": "<p>I think that priorities of explicitly provided <code>simp</code> lemmas should be higher than default.</p>",
        "id": 412774366,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705200721
    },
    {
        "content": "<p>If I provide a lemma, then probably I really want to use it.</p>",
        "id": 412774419,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705200744
    },
    {
        "content": "<p>E.g., if I say <code>simp [not_and_or]</code>, then I don't want to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=not_and#doc\">docs#not_and</a></p>",
        "id": 412774464,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705200803
    },
    {
        "content": "<p>Maybe we need a special case for the output of <code>simp?</code> that keeps the priorities the same as they were in the <code>simp?</code> call? Maybe <code>simp only! [...]</code>? But that would not provide a way to make explicitly provided lemmas higher priority, as it could not differentiate whether a lemma in the <code>simp</code> set was provided explicitly to the original call or not. Annotating the lemmas with their priority (if different from 1000) seems the most flexible (if potentially a bit verbose) approach to me.</p>",
        "id": 412801696,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705226990
    },
    {
        "content": "<p>This has just hit me again:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">mport</span> <span class=\"n\">Mathlib.Analysis.Complex.Basic</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.simp.rewrite</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test1</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Set.indicator</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span> <span class=\"n\">F</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span><span class=\"bp\">?</span> <span class=\"n\">says</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_compl_iff</span><span class=\"o\">,</span> <span class=\"n\">not_true_eq_false</span><span class=\"o\">,</span> <span class=\"n\">not_false_eq_true</span><span class=\"o\">,</span>\n      <span class=\"n\">Set.indicator_of_not_mem</span><span class=\"o\">]</span> <span class=\"c1\">-- simp made no progress</span>\n  <span class=\"c1\">-- goal: `Set.indicator {0}ᶜ F 0 = 0`</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test2</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Set.indicator</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span> <span class=\"n\">F</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_compl_iff</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_singleton_iff</span><span class=\"o\">,</span> <span class=\"n\">not_true_eq_false</span><span class=\"o\">,</span> <span class=\"n\">not_false_eq_true</span><span class=\"o\">,</span>\n    <span class=\"n\">Set.indicator_of_not_mem</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- no goals</span>\n</code></pre></div>\n<p>The trace in the second call is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.rewrite</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">Set.mem_compl_iff</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">==&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">∉</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.rewrite</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">Set.mem_singleton_iff</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">==&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.rewrite</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">eq_self</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">True</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.rewrite</span><span class=\"o\">]</span> <span class=\"n\">not_true_eq_false</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">True</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">False</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.rewrite</span><span class=\"o\">]</span> <span class=\"n\">not_false_eq_true</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">False</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">True</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.rewrite</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">Set.indicator_of_not_mem</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"n\">Set.indicator</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span> <span class=\"n\">F</span> <span class=\"mi\">0</span> <span class=\"bp\">==&gt;</span> <span class=\"mi\">0</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.rewrite</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">eq_self</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">True</span>\n</code></pre></div>\n<p>(with just <code>simp</code>, it is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.rewrite</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">Set.mem_compl_iff</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">==&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">∉</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.rewrite</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">Set.mem_singleton_iff</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">==&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.rewrite</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">eq_self</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">True</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.rewrite</span><span class=\"o\">]</span> <span class=\"n\">not_true_eq_false</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">True</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">False</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.rewrite</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">Set.mem_compl_iff</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">==&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">∉</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.rewrite</span><span class=\"o\">]</span> <span class=\"n\">not_true_eq_false</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">True</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">False</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.rewrite</span><span class=\"o\">]</span> <span class=\"n\">not_false_eq_true</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">False</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">True</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.rewrite</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">Set.indicator_of_not_mem</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"n\">Set.indicator</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span> <span class=\"n\">F</span> <span class=\"mi\">0</span> <span class=\"bp\">==&gt;</span> <span class=\"mi\">0</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.rewrite</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">eq_self</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">True</span>\n</code></pre></div>\n<p>which is pretty similar).</p>\n<p>Howeverm it looks like all priorities are the same and <code>Set.mem_singleton_iff</code> is actually used by the <code>simp</code>call, so there seems to be a more fundamental problem with the output of <code>simp?</code>. (I also noticed that it still frequently adds <code>gt_iff_lt</code> and/or <code>ge_iff_le</code> even though they are not really needed.)</p>",
        "id": 426916205,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1710617735
    },
    {
        "content": "<p>Minimized a bit more:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Function.Indicator</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidablePred</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">bar</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidablePred</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">↓</span><span class=\"n\">reduceIte</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test1</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span><span class=\"bp\">?</span> <span class=\"n\">says</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_compl_iff</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_singleton_iff</span><span class=\"o\">,</span> <span class=\"n\">not_true_eq_false</span><span class=\"o\">,</span>\n      <span class=\"n\">not_false_eq_true</span><span class=\"o\">,</span> <span class=\"n\">bar</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test2</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Set.indicator</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span> <span class=\"n\">F</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- simp -- works</span>\n  <span class=\"n\">simp</span><span class=\"bp\">?</span> <span class=\"n\">says</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_compl_iff</span><span class=\"o\">,</span> <span class=\"n\">not_true_eq_false</span><span class=\"o\">,</span> <span class=\"n\">not_false_eq_true</span><span class=\"o\">,</span>\n    <span class=\"n\">Set.indicator_of_not_mem</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- simp made no progress, `Set.mem_singleton_iff` is missing</span>\n</code></pre></div>\n<p>I'm trying to emulate <code>Set.indicator_of_not_mem</code> via <code>bar</code>, but in this case, <code>simp?</code> does put <code>Set.mem_singleton_iff</code> in the list.</p>\n<p>I have no idea how to debug this.</p>",
        "id": 427133333,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1710685846
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> ?</p>",
        "id": 427133552,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1710685911
    },
    {
        "content": "<p>Keep minimising. :-) </p>\n<p>The basic no-insight-required method is to iteratively:</p>\n<ul>\n<li>replace <code>import X</code> with its imports and <code>section X; &lt;contents of X&gt;; end X</code></li>\n<li>delete everything from that section that isn't needed to reproduce the problem</li>\n<li>remove any imports that aren't needed</li>\n</ul>\n<p>Until no imports remain.</p>",
        "id": 427244834,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710715608
    },
    {
        "content": "<p>This seems to be very brittle.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Function</span>\n\n<span class=\"c1\">-- copied definitions</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Set.indicator'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_4</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">Classical.decPred</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n  <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"k\">then</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Set.indicator_of_not_mem'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_4</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Set.indicator'</span> <span class=\"n\">s</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"n\">if_neg</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test1</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Set.indicator'</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span> <span class=\"n\">F</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span><span class=\"bp\">?</span> <span class=\"c1\">-- includes `Set.mem_singleton_iff`</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Function.Indicator</span>\n\n<span class=\"c1\">-- attribute[-simp] Set.indicator_of_mem -- with attribute removed: OK</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test2</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Set.indicator</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span> <span class=\"n\">F</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span><span class=\"bp\">?</span>\n</code></pre></div>\n<p>But:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Function</span>\n\n<span class=\"c1\">-- copied definitions</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Set.indicator'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_4</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">Classical.decPred</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n  <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"k\">then</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Set.indicator_of_not_mem'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_4</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Set.indicator'</span> <span class=\"n\">s</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"n\">if_neg</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Set.indicator_of_mem'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_4</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Set.indicator'</span> <span class=\"n\">s</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n  <span class=\"n\">if_pos</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test1</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Set.indicator'</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span> <span class=\"n\">F</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span><span class=\"bp\">?</span> <span class=\"c1\">-- OK</span>\n</code></pre></div>",
        "id": 427472512,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1710766692
    },
    {
        "content": "<p>This is how far I got:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Set</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Set</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">singleton</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">↦</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">compl</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"bp\">¬</span> <span class=\"n\">s</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">compl_iff</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s.compl</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"bp\">¬</span> <span class=\"n\">s</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">singleton_iff</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">singleton</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.rfl</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Classical</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">indicator</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">s</span> <span class=\"n\">x</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"c1\">-- remove `simp` attribute --&gt; works (and the trace changes)</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">indicator_of</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">indicator</span> <span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">if_pos</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">indicator_of_not</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">s</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">indicator</span> <span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">if_neg</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.simp.rewrite</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">indicator</span> <span class=\"o\">(</span><span class=\"n\">compl</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">singleton</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span><span class=\"bp\">?</span> <span class=\"c1\">-- leaves out `singleton_iff` even though it is necessary</span>\n</code></pre></div>\n<p>I have no idea why and how the fact whether <code>indicator_of_mem</code> is a <code>simp</code> lemma or not influences a <code>simp?</code> call that does not use it.</p>",
        "id": 427503236,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1710773513
    },
    {
        "content": "<p>Trying to minimize a bit fruther...</p>",
        "id": 427505950,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1710774168
    },
    {
        "content": "<p>Done in the code block above. This seems to be close to the bare minimum. <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> ?</p>",
        "id": 427507293,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1710774508
    },
    {
        "content": "<p>Can you open an issue on the Lean repo?</p>",
        "id": 427507523,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710774575
    },
    {
        "content": "<p>I have never done that, but I will try.</p>",
        "id": 427507615,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1710774600
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/3710\">lean4#3710</a></p>",
        "id": 427511261,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1710775542
    },
    {
        "content": "<p>With <code>set_option trace.Meta.Tactic.simp.discharge true</code>, the trace in the \"bad\" case is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.discharge</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">Set.indicator_of</span> <span class=\"n\">discharge</span> <span class=\"bp\">❌</span>\n      <span class=\"n\">Set.compl</span> <span class=\"o\">(</span><span class=\"n\">Set.singleton</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"bp\">▼</span>\n  <span class=\"o\">[</span><span class=\"n\">rewrite</span><span class=\"o\">]</span> <span class=\"n\">Set.compl_iff</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"n\">Set.compl</span> <span class=\"o\">(</span><span class=\"n\">Set.singleton</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"bp\">==&gt;</span> <span class=\"bp\">¬</span><span class=\"n\">Set.singleton</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span>\n  <span class=\"o\">[</span><span class=\"n\">rewrite</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">Set.singleton_iff</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"n\">Set.singleton</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span> <span class=\"bp\">==&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n  <span class=\"o\">[</span><span class=\"n\">rewrite</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">eq_self</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">True</span>\n  <span class=\"o\">[</span><span class=\"n\">rewrite</span><span class=\"o\">]</span> <span class=\"n\">not_true_eq_false</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">True</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">False</span>\n\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.discharge</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">Set.indicator_of_not</span> <span class=\"n\">discharge</span> <span class=\"bp\">✅</span>\n      <span class=\"bp\">¬</span><span class=\"n\">Set.compl</span> <span class=\"o\">(</span><span class=\"n\">Set.singleton</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"bp\">▼</span>\n  <span class=\"o\">[</span><span class=\"n\">rewrite</span><span class=\"o\">]</span> <span class=\"n\">Set.compl_iff</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"n\">Set.compl</span> <span class=\"o\">(</span><span class=\"n\">Set.singleton</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"bp\">==&gt;</span> <span class=\"bp\">¬</span><span class=\"n\">Set.singleton</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span>\n  <span class=\"o\">[</span><span class=\"n\">rewrite</span><span class=\"o\">]</span> <span class=\"n\">not_true_eq_false</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">True</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">False</span>\n  <span class=\"o\">[</span><span class=\"n\">rewrite</span><span class=\"o\">]</span> <span class=\"n\">not_false_eq_true</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">False</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">True</span>\n\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.rewrite</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">Set.indicator_of_not</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"n\">Set.indicator</span> <span class=\"o\">(</span><span class=\"n\">Set.compl</span> <span class=\"o\">(</span><span class=\"n\">Set.singleton</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"mi\">0</span> <span class=\"bp\">==&gt;</span> <span class=\"mi\">0</span>\n\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.rewrite</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">eq_self</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">True</span>\n</code></pre></div>\n<p>whereas in the \"good\" case, it is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.discharge</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">Set.indicator_of_not</span> <span class=\"n\">discharge</span> <span class=\"bp\">✅</span>\n      <span class=\"bp\">¬</span><span class=\"n\">Set.compl</span> <span class=\"o\">(</span><span class=\"n\">Set.singleton</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"bp\">▼</span>\n  <span class=\"o\">[</span><span class=\"n\">rewrite</span><span class=\"o\">]</span> <span class=\"n\">Set.compl_iff</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"n\">Set.compl</span> <span class=\"o\">(</span><span class=\"n\">Set.singleton</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"bp\">==&gt;</span> <span class=\"bp\">¬</span><span class=\"n\">Set.singleton</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span>\n  <span class=\"o\">[</span><span class=\"n\">rewrite</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">Set.singleton_iff</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"n\">Set.singleton</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span> <span class=\"bp\">==&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n  <span class=\"o\">[</span><span class=\"n\">rewrite</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">eq_self</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">True</span>\n  <span class=\"o\">[</span><span class=\"n\">rewrite</span><span class=\"o\">]</span> <span class=\"n\">not_true_eq_false</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">True</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">False</span>\n  <span class=\"o\">[</span><span class=\"n\">rewrite</span><span class=\"o\">]</span> <span class=\"n\">not_false_eq_true</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">False</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">True</span>\n\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.rewrite</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">Set.indicator_of_not</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"n\">Set.indicator</span> <span class=\"o\">(</span><span class=\"n\">Set.compl</span> <span class=\"o\">(</span><span class=\"n\">Set.singleton</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"mi\">0</span> <span class=\"bp\">==&gt;</span> <span class=\"mi\">0</span>\n\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.rewrite</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">eq_self</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">True</span>\n</code></pre></div>\n<p><strong>Note:</strong> in the \"bad\" case, <code>singleton_iff</code> is used in the first attempt via <code>indicator_of</code> that ultimately fails, and is not listed again in the second (succeeding) attempt. However, it is necessary to use it there (as the \"good\" trace shows).</p>\n<p><em>Speculation:</em> <code>simp</code> caches the result obtained from <code>singleton_iff</code> in the first attempt and reuses that in the second one, but does not take note of it for inclusion in the lemma list.</p>\n<p>Does this sound reasonable?</p>",
        "id": 427512989,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1710775965
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span> <br>\nDo you think this makes sense?</p>",
        "id": 427556845,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1710788869
    },
    {
        "content": "<p>I recall there was some issue here with the <code>UsedSimps</code> state getting reset or not being handled correctly when <code>simp</code> backtracks</p>",
        "id": 427557152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710788979
    }
]