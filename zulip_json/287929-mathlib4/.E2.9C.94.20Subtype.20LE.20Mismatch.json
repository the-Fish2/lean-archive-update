[
    {
        "content": "<p>I have the following theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">make_iso.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"bp\">✝¹</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hinj</span> <span class=\"o\">:</span> <span class=\"n\">Function.Injective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hsurj</span> <span class=\"o\">:</span> <span class=\"n\">Function.Surjective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hord</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">≃</span><span class=\"n\">o</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which just says that if a map between linear orders is injective, surjective, and order preserving then they are isomorphic.</p>\n<p>I am now trying to use this theorem to prove the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Nonempty</span> <span class=\"o\">((</span><span class=\"bp\">@</span><span class=\"n\">Elem</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">image_left</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">image_left</span> <span class=\"n\">f</span> <span class=\"bp\">↓∩</span> <span class=\"n\">left_part</span><span class=\"o\">)</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"bp\">≃</span><span class=\"n\">o</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I have defined a map q and showed that it is injective, surjective and order preserving:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">image_left</span> <span class=\"n\">f</span> <span class=\"bp\">↓∩</span> <span class=\"n\">left_part</span><span class=\"o\">)</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">→</span> <span class=\"bp\">↑</span><span class=\"n\">e</span>\n<span class=\"n\">qinj</span> <span class=\"o\">:</span> <span class=\"n\">Function.Injective</span> <span class=\"n\">q</span>\n<span class=\"n\">qsurj</span> <span class=\"o\">:</span> <span class=\"n\">Function.Surjective</span> <span class=\"n\">q</span>\n<span class=\"n\">qord</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">image_left</span> <span class=\"n\">f</span> <span class=\"bp\">↓∩</span> <span class=\"n\">left_part</span><span class=\"o\">)</span><span class=\"bp\">ᶜ</span><span class=\"o\">},</span> <span class=\"n\">q</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">q</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>But when I write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">exact</span> <span class=\"n\">make_iso</span> <span class=\"n\">qinj</span> <span class=\"n\">qsurj</span> <span class=\"n\">qord</span>\n</code></pre></div>\n<p>I get the following error:</p>\n<div class=\"codehilite\" data-code-language=\"type\"><pre><span></span><code>  qord\nhas type\n  @LE.le (↑e) (@Preorder.toLE (↑e) (Subtype.preorder fun x =&gt; x ∈ e)) (q a✝) (q b✝) ↔ a✝ ≤ b✝ : Prop\nbut is expected to have type\n  @LE.le (↑e) (@Preorder.toLE (↑e) PartialOrder.toPreorder) (q a✝) (q b✝) ↔ a✝ ≤ b✝ : Prop\n</code></pre></div>\n<p>and I can't seem to fix it. I don't understand why I am getting the error as well since a Subtype of a linear order is a linear order.</p>",
        "id": 438726968,
        "sender_full_name": "Eric Paul",
        "timestamp": 1715750969
    },
    {
        "content": "<p>Does <code>convert</code> instead of <code>exact</code> work? Or do you genuinely have two different \\le's on your subtype?</p>",
        "id": 438740075,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1715757532
    },
    {
        "content": "<p>Unfortunately, it seems that convert did not work. I don't know why I would have different \\le's on my subtype.</p>",
        "id": 438740533,
        "sender_full_name": "Eric Paul",
        "timestamp": 1715757716
    },
    {
        "content": "<p>Is a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> possible?</p>",
        "id": 438740729,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1715757785
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"512030\">Eric</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Subtype.20LE.20Mismatch/near/438740533\">said</a>:</p>\n<blockquote>\n<p>I don't know why I would have different \\le's on my subtype.</p>\n</blockquote>\n<p>It sometimes happens when people stack typeclass assumptions and aren't careful enough. I've been there a few times!</p>",
        "id": 438781496,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715772855
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Subtype.20LE.20Mismatch/near/438740729\">said</a>:</p>\n<blockquote>\n<p>Is a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> possible?</p>\n</blockquote>\n<p>Here's a mwe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Set</span>\n<span class=\"kn\">open</span> <span class=\"n\">Set.Notation</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">δ</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">⊕ₗ</span> <span class=\"n\">β</span> <span class=\"bp\">≃</span><span class=\"n\">o</span> <span class=\"n\">γ</span> <span class=\"bp\">⊕ₗ</span> <span class=\"n\">δ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">make_iso</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hinj</span> <span class=\"o\">:</span> <span class=\"n\">Function.Injective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hsurj</span> <span class=\"o\">:</span> <span class=\"n\">Function.Surjective</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n <span class=\"o\">(</span><span class=\"n\">hord</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">≃</span><span class=\"n\">o</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">left_part</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⊕ₗ</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Sum.inl</span> <span class=\"bp\">''</span> <span class=\"o\">(</span><span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">image_left</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"bp\">⊕ₗ</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">left_part</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">mwe''</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">w</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">e</span><span class=\"o\">]</span> <span class=\"bp\">→</span>\n  <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"bp\">⊕ₗ</span> <span class=\"n\">e</span> <span class=\"bp\">≃</span><span class=\"n\">o</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">set</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">image_left</span> <span class=\"n\">f</span> <span class=\"bp\">\\</span> <span class=\"n\">left_part</span>\n    <span class=\"k\">with</span> <span class=\"n\">e_def</span>\n  <span class=\"n\">use</span> <span class=\"n\">e</span>\n  <span class=\"n\">intros</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">image_left</span> <span class=\"n\">f</span> <span class=\"bp\">↓∩</span> <span class=\"n\">left_part</span><span class=\"o\">)</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">≃</span><span class=\"n\">o</span> <span class=\"bp\">↑</span><span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">set</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">image_left</span> <span class=\"n\">f</span> <span class=\"bp\">↓∩</span> <span class=\"n\">left_part</span><span class=\"o\">)</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">→</span> <span class=\"bp\">↑</span><span class=\"n\">e</span> <span class=\"o\">:=</span>\n      <span class=\"bp\">λ</span><span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">g.val.val</span><span class=\"o\">,</span> <span class=\"o\">⟨(</span><span class=\"n\">g.val.property</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">g.property</span><span class=\"o\">)⟩⟩</span>\n      <span class=\"k\">with</span> <span class=\"n\">q_def</span>\n    <span class=\"k\">have</span> <span class=\"n\">qinj</span> <span class=\"o\">:</span> <span class=\"n\">Function.Injective</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n    <span class=\"k\">have</span> <span class=\"n\">qsurj</span> <span class=\"o\">:</span> <span class=\"n\">Function.Surjective</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n    <span class=\"k\">have</span> <span class=\"n\">qord</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">image_left</span> <span class=\"n\">f</span> <span class=\"bp\">↓∩</span> <span class=\"n\">left_part</span><span class=\"o\">)</span><span class=\"bp\">ᶜ</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">q</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n    <span class=\"n\">exact</span> <span class=\"n\">make_iso</span> <span class=\"n\">qinj</span> <span class=\"n\">qsurj</span> <span class=\"n\">qord</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>You'll see the error on the second to last line.</p>",
        "id": 438917871,
        "sender_full_name": "Eric Paul",
        "timestamp": 1715826791
    },
    {
        "content": "<p>I think this is failing because the theorem is stating that there exists an e such that for any LinearOrder instance of e, then something. And so that's where I get my other instance of\\le.</p>\n<p>How do I state \"there exists some e that is a LinearOrder such that\" in Lean?</p>",
        "id": 438955475,
        "sender_full_name": "Eric Paul",
        "timestamp": 1715843775
    },
    {
        "content": "<p>Say \"there exists a linear order on e\" rather than \"for all linear orders on e\"</p>",
        "id": 438956073,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1715844025
    },
    {
        "content": "<p>That makes so much sense, thank you!</p>",
        "id": 438956560,
        "sender_full_name": "Eric Paul",
        "timestamp": 1715844209
    },
    {
        "content": "<p>Here is the fix</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">mwe''</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">w</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"bp\">⊕ₗ</span> <span class=\"n\">e</span> <span class=\"bp\">≃</span><span class=\"n\">o</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n</code></pre></div>",
        "id": 438956594,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715844224
    },
    {
        "content": "<p>That works perfectly and makes a lot of sense now, thanks!<br>\nClearly I need to become more comfortable with typeclasses.</p>",
        "id": 438957002,
        "sender_full_name": "Eric Paul",
        "timestamp": 1715844371
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"512030\">Eric</span> has marked this topic as resolved.</p>",
        "id": 438957024,
        "sender_full_name": "Notification Bot",
        "timestamp": 1715844381
    },
    {
        "content": "<p>No this is a subtlety in logic which trips a lot of people up (but typically only once!). I met Commelin because he DMed me telling me I'd made the same mistake in the definition of a scheme.</p>",
        "id": 438963522,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1715846843
    },
    {
        "content": "<p>You know the \"for all\" must be wrong because what if there were no linear orders on e? Then your original claim would be vacuously true. Obviously this can't happen because of Zorn or whatever, but the very fact that you have to say this means that it can't be what you mean.</p>",
        "id": 438963786,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1715846940
    }
]