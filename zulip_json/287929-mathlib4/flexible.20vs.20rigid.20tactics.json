[
    {
        "content": "<p>I think all the tactic combinators like <code>done</code>, <code>skip</code>, <code>try</code>, <code>any_goals</code>, <code>all_goals</code> should be allowed</p>",
        "id": 427782429,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871132
    },
    {
        "content": "<p>Ok, I think that the way in which the \"following tactic\" is selected means that the tactic following the combinator will be flagged as well (unless it is whitelisted).  This is the intended behaviour, right?  I.e., the combinator should not be a stop-gag, just a see-through tactic that passes on the decision to the next one.</p>\n<p>Do you agree?</p>",
        "id": 427782779,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871240
    },
    {
        "content": "<p>I don't really like the current logic of your linter. I think a more pertinent logic would be to mark locations (hypotheses/goals) as \"non-squeezedly simped\" and forbidding \"rigid\" tactics from using those assumptions</p>",
        "id": 427783206,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871390
    },
    {
        "content": "<p>Eg this should be allowed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h0</span>\n<span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h2</span>\n</code></pre></div>\n<p>but neither of these should</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h0</span>\n<span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h0</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h0</span>\n<span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h0</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h1</span>\n</code></pre></div>",
        "id": 427783421,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871464
    },
    {
        "content": "<p>Yaël, I do not really understand what you are proposing... what is a  \"non-squeezedly simped\" location?</p>",
        "id": 427783422,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871465
    },
    {
        "content": "<p>Maybe I should specify: currently, the \"next tactic\" is \"the next tactic that acts on a goal that a <code>simp</code> produced\".</p>",
        "id": 427783551,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871516
    },
    {
        "content": "<p>It is <em>not</em> the next tactic that you type.</p>",
        "id": 427783608,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871540
    },
    {
        "content": "<p>(or rather, it need not be, although often it will be.)</p>",
        "id": 427783643,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871556
    },
    {
        "content": "<p>That sounds really brittle. That means that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span>\n<span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>is forbidden but</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span>\n<span class=\"n\">ring</span>\n<span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>is not</p>",
        "id": 427783652,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871560
    },
    {
        "content": "<p>Do you understand my proposition better now?</p>",
        "id": 427783756,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871584
    },
    {
        "content": "<p>Yes, I think that I understand.  You would like something like a cache of \"after <code>simp</code> locations\" that are only allowed actions by \"flexible\" tactics, including <code>simp, ring,...</code>, but, for instance, not <code>rw</code>.</p>",
        "id": 427784085,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871693
    },
    {
        "content": "<p>I wonder whether this should come after a first implementation of the linter, though...</p>",
        "id": 427784139,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871716
    },
    {
        "content": "<p>This seems more like a \"non-terminal <code>flexible tactic</code> follower\" linter to me.</p>",
        "id": 427784270,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871768
    },
    {
        "content": "<p>I think it's worth exploring! If we merge your linter now, we're at risk of teachings seas of beginners the wrong style</p>",
        "id": 427784300,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871781
    },
    {
        "content": "<p>This is certainly a very good suggestion, but I think that focusing on <code>simp</code> might already be productive.</p>",
        "id": 427784316,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871792
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60simp.60.20followers/near/427784270\">said</a>:</p>\n<blockquote>\n<p>This seems more like a \"non-terminal <code>flexible tactic</code> follower\" linter to me.</p>\n</blockquote>\n<p>Yes, that's exactly what it is, because simp is really no special here</p>",
        "id": 427784400,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871817
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60simp.60.20followers/near/427784300\">said</a>:</p>\n<blockquote>\n<p>I think it's worth exploring! If we merge your linter now, we're at risk of teachings seas of beginners the wrong style</p>\n</blockquote>\n<p>Ok, this is possible, but it is also possible that they can then learn a better style later on.</p>",
        "id": 427784420,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871825
    },
    {
        "content": "<p>Mathport experience would like to disagree...</p>",
        "id": 427784459,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871843
    },
    {
        "content": "<p>I claim that the correct implementation is so different to your current one that it's not worth trying to incrementally get to the correct one from yours</p>",
        "id": 427784534,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871878
    },
    {
        "content": "<p>Ok, so maybe the tactics that I am placing in the whitelist should be all allowed and should never be followed by anything else.</p>\n<p>This is probably not that hard to implement, although I have not really given this much thought.</p>",
        "id": 427784560,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871891
    },
    {
        "content": "<p>Also, you already ripped out most of the benefits from your linter by PRing fixes to the errors you found locally</p>",
        "id": 427784686,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871930
    },
    {
        "content": "<p>More errors will come, but only with a better logic</p>",
        "id": 427784720,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871943
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60simp.60.20followers/near/427784534\">said</a>:</p>\n<blockquote>\n<p>I claim that the correct implementation is so different to your current one that it's not worth trying to incrementally get to the correct one from yours</p>\n</blockquote>\n<p>The current suggestion is very far from v1 of the linter, not, I think, from v2 that I am testing right now.</p>",
        "id": 427784729,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871949
    },
    {
        "content": "<p>I think you should not allow specific tactics but instead disallow specific rigid tactics</p>",
        "id": 427784797,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710871978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60simp.60.20followers/near/427784686\">said</a>:</p>\n<blockquote>\n<p>Also, you already ripped out most of the benefits from your linter by PRing fixes to the errors you found locally</p>\n</blockquote>\n<p>Very few of those PRs have been merged and have conflicts now.  I am planning to close them, if the newer version of the linter is definitely an improvement.</p>",
        "id": 427784838,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710871996
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60simp.60.20followers/near/427784797\">said</a>:</p>\n<blockquote>\n<p>I think you should not allow specific tactics but instead disallow them</p>\n</blockquote>\n<p>As I am thinking of this right now, there are only two categories, right?  The category of tactics that can only act on goals on which a flexible tactic has not yet acted, and the flexible tactics, right?  You are saying that a tactic if automatically flexible, unless it is blacklisted?</p>",
        "id": 427785128,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872099
    },
    {
        "content": "<p>Nono, sorry I clarified</p>",
        "id": 427785198,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710872131
    },
    {
        "content": "<p>(the two perspective are easy to implement, it seems to be that we are simply deciding what the default category of each tactic is)</p>",
        "id": 427785202,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872134
    },
    {
        "content": "<p>The default should be rigid. This is what I'm claiming</p>",
        "id": 427785258,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710872161
    },
    {
        "content": "<p>Ok, I agree.  By default, everything is like <code>rw</code> (which I consider the default rigid tactic).</p>",
        "id": 427785342,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872186
    },
    {
        "content": "<p>And if a goal/location has been produced/touched by a flexible tactic, then only flexible tactics are allowed to touch it.</p>",
        "id": 427785428,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872221
    },
    {
        "content": "<p>... or use it!</p>",
        "id": 427785539,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710872264
    },
    {
        "content": "<p>(the \"location part\" I am not too sure about -- the current linter is implemented thinking about goals, but the linting framework does have access to the context.)</p>",
        "id": 427785663,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872294
    },
    {
        "content": "<p>Actually, it's not merely \"touched by a flexible tactic\" that's bad but \"potentially touched\"</p>",
        "id": 427785689,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710872304
    },
    {
        "content": "<p>\"potentially touched\" might include everything, though?  Do you mean that <code>simp_all</code> makes everything flexible, even if it actually just modifies one hypothesis?</p>",
        "id": 427785864,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872376
    },
    {
        "content": "<p>So the correct rule is:</p>\n<blockquote>\n<p>Only flexible tactics are allowed to target or use locations which have been previously been targeted by flexible tactics (regardless of whether said flexible tactics actually changed those locations)</p>\n</blockquote>",
        "id": 427785896,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710872387
    },
    {
        "content": "<p>Yes, <code>simp at *</code> means that no rigid tactic can target anything in that context anymore. If you then do <code>have := something_not_from_context</code>, that can be touched by a rigid tactic however,</p>",
        "id": 427786161,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710872474
    },
    {
        "content": "<p>I understand your point, although I wonder whether this requires knowledge of what each tactic <em>could</em> do...  E.g., when you see a <code>simp</code>, you should figure out whether it is <code>at</code> and what the <code>at</code> locations are.  I think that this would be very hard to maintain as a linter.</p>",
        "id": 427786201,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872488
    },
    {
        "content": "<p>Yes, but luckily there aren't many flexible tactics</p>",
        "id": 427786285,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710872513
    },
    {
        "content": "<p>Regardless, information on targeted locations should be part of the tactic framework long term</p>",
        "id": 427786428,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710872559
    },
    {
        "content": "<p>To avoid scope-creep, what do you think of focusing on goals, rather than locations, to begin with?</p>",
        "id": 427786432,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872561
    },
    {
        "content": "<p>I don't see how that could give you anything sensible</p>",
        "id": 427786504,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710872584
    },
    {
        "content": "<p>There are too many ways the goal-based heuristic could go wrong</p>",
        "id": 427786599,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710872620
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60simp.60.20followers/near/427786599\">said</a>:</p>\n<blockquote>\n<p>There are too many ways the goal-based heuristic could go wrong</p>\n</blockquote>\n<p>While this is true, I also think that for most proofs, the goal heuristic is actually good.</p>",
        "id": 427787008,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872750
    },
    {
        "content": "<p>Yes, but I really really do not want false linter positives</p>",
        "id": 427787144,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710872783
    },
    {
        "content": "<p>(Also, I am aware of my abilities and, while I can see myself coding the linter with locations and all, I can also see the result as being unusably slow...)</p>",
        "id": 427787242,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872817
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60simp.60.20followers/near/427787144\">said</a>:</p>\n<blockquote>\n<p>Yes, but I really really do not want false linter positives</p>\n</blockquote>\n<p>You can view it as \"Every silencing of the linter is a todo\"...</p>",
        "id": 427787356,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872852
    },
    {
        "content": "<p>I am going to move all this conversation to a separate topic, is that alright?</p>",
        "id": 427787603,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872937
    },
    {
        "content": "<p>(assuming that I can...)</p>",
        "id": 427787629,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710872945
    },
    {
        "content": "<p>49 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/.02klzzwxh.3A0000.03.20followers\">#mathlib4 &gt; <code>simp</code> followers</a> by <span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span>.</p>",
        "id": 427787981,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710873065
    },
    {
        "content": "<p>Ok, to seriously implement this rigid vs flexible linter, I need to see what kind of information hides in the <code>MetavarContext</code> that the linter offers.</p>",
        "id": 427788492,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710873239
    },
    {
        "content": "<p>Just to be clear, what you are suggesting is that, after a flexible tactic that potentially changes all locations, that metavariable can (almost) only be closed by flexible tactics: e.g. <code>assumption, tauto, linarith,..., have+something else,...</code> and <code>have</code> or something similar is the only way in which rigid tactics can play again there, and then only on the new hypotheses that have been introduced.</p>",
        "id": 427790233,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710873850
    },
    {
        "content": "<p>I agree that this would make proofs much less brittle.  It may also be somewhat of an added burden to write proofs in this \"flexible-vs-rigid\" style.</p>",
        "id": 427790567,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710873967
    },
    {
        "content": "<p>I don't think it will be much burden since this is already how we write most proofs</p>",
        "id": 427801416,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710878206
    },
    {
        "content": "<p>Some iteration of the \"non-terminal <code>simp</code>\" linter produces the output below.  Currently, the linter only looks at <code>simp</code> and <code>simp_all</code>, but this is easy to expand.  What the linter is <em>supposed</em> to do is check if some tactics that are likely to break with small changes to the <code>simp</code> output follow <code>simp</code>.</p>\n<p>The linter makes an effort to flag <code>simp at h; rw [h]</code> as well as <code>simp at h; rw at h</code>.</p>\n<p>The lnter should not flag <code>simp at h1; rw [h2] at h3</code>, assuming that <code>h1</code> is different from <code>h2, h3</code>.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Linted</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Mathlib/Init/Data/Nat/Bitwise.lean</span>\n    <span class=\"n\">cases</span> <span class=\"n\">bodd</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">cond</span><span class=\"o\">,</span> <span class=\"n\">not</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_comm</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Mathlib/Control/Applicative.lean</span>\n  <span class=\"n\">simp</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"n\">map</span><span class=\"o\">,</span> <span class=\"n\">Seq.seq</span><span class=\"o\">,</span> <span class=\"n\">functor_norm</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">commutative_map</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Mathlib/Data/Nat/Defs.lean</span>\n  <span class=\"bp\">·</span> <span class=\"n\">by_contra</span> <span class=\"n\">h'</span><span class=\"bp\">;</span> <span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"n\">h'</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.le_zero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h'</span>\n    <span class=\"n\">obtain</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">h'</span> <span class=\"o\">:=</span> <span class=\"n\">h'</span>\n\n<span class=\"c1\">-- Mathlib/Data/List/ReduceOption.lean</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">eq_comm</span> <span class=\"n\">_</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Option.not_isSome_iff_eq_none</span><span class=\"o\">,</span> <span class=\"n\">Decidable.imp_iff_not_or</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Mathlib/Order/Compare.lean</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">xy</span><span class=\"o\">:</span><span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">by_cases</span> <span class=\"n\">yx</span><span class=\"o\">:</span><span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">cmpLE</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">Ordering.swap</span><span class=\"o\">]</span>\n  <span class=\"n\">cases</span> <span class=\"n\">not_or_of_not</span> <span class=\"n\">xy</span> <span class=\"n\">yx</span> <span class=\"o\">(</span><span class=\"n\">total_of</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Mathlib/Data/Nat/PSub.lean</span>\n  <span class=\"n\">cases</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">psub</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">eq_comm</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"k\">show</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span>\n\n<span class=\"c1\">-- Mathlib/Tactic/Sat/FromLRAT.lean</span>\n    <span class=\"n\">induction</span> <span class=\"n\">as₁</span> <span class=\"k\">with</span> <span class=\"n\">simp</span>\n    <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">b</span> <span class=\"n\">as₁</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">bs</span> <span class=\"bp\">↦</span> <span class=\"n\">ih</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ_add</span> <span class=\"bp\">..</span><span class=\"o\">)</span> <span class=\"n\">_</span>\n\n<span class=\"c1\">-- Mathlib/Order/Iterate.lean</span>\n  <span class=\"n\">apply</span> <span class=\"n\">hf.seq_le_seq</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">intros</span> <span class=\"bp\">&lt;;&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">iterate_succ'</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">iterate_succ</span><span class=\"o\">,</span> <span class=\"n\">comp_apply</span><span class=\"o\">,</span> <span class=\"n\">id_eq</span><span class=\"o\">,</span> <span class=\"n\">le_refl</span><span class=\"o\">]</span>\n  <span class=\"n\">case</span> <span class=\"n\">hx</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">H</span> <span class=\"n\">_</span>\n\n<span class=\"c1\">-- Mathlib/Data/Nat/Bitwise.lean</span>\n  <span class=\"k\">have</span> <span class=\"n\">h4</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">two_mul</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_mul_div_left</span><span class=\"o\">]</span>\n  <span class=\"n\">cases</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">cases</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">h3</span><span class=\"o\">,</span> <span class=\"n\">h4</span><span class=\"o\">]</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">split_ifs</span>\n\n<span class=\"c1\">-- Mathlib/Data/Nat/Size.lean</span>\n  <span class=\"n\">induction'</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">IH</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">shiftLeft'</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"bp\">⊢</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">size_bit</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_succ</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Mathlib/Data/List/Lattice.lean</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">l₂</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">bagInter_nil_iff_inter_nil</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span>\n\n<span class=\"c1\">-- Mathlib/Analysis/MeanInequalities.lean</span>\n    <span class=\"n\">le_of_lt</span> <span class=\"n\">hpq.symm.pos</span><span class=\"o\">,</span> <span class=\"n\">le_of_lt</span> <span class=\"n\">hpq.symm.one_div_pos</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">convert</span> <span class=\"n\">this</span> <span class=\"n\">using</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"o\">[</span><span class=\"n\">skip</span><span class=\"bp\">;</span> <span class=\"n\">congr</span> <span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"o\">[</span><span class=\"n\">skip</span><span class=\"bp\">;</span> <span class=\"n\">skip</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">skip</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"bp\">&lt;;&gt;</span>\n\n<span class=\"c1\">-- Mathlib/RingTheory/Polynomial/Cyclotomic/Eval.lean</span>\n      <span class=\"n\">and_self_iff</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">intro</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">linarith</span>\n\n<span class=\"c1\">-- Mathlib/MeasureTheory/Integral/MeanInequalities.lean</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hi₀</span><span class=\"o\">]</span>\n      <span class=\"k\">have</span> <span class=\"n\">h2p</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n\n<span class=\"c1\">-- Mathlib/Geometry/Euclidean/Sphere/Power.lean</span>\n    <span class=\"n\">simp_all</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Classical.not_not</span><span class=\"o\">,</span> <span class=\"n\">one_smul</span><span class=\"o\">]</span>\n  <span class=\"n\">exacts</span> <span class=\"o\">[</span><span class=\"n\">hab</span> <span class=\"o\">(</span><span class=\"n\">vsub_left_cancel</span> <span class=\"n\">hab₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span> <span class=\"n\">hcd</span> <span class=\"o\">(</span><span class=\"n\">vsub_left_cancel</span> <span class=\"n\">hcd₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Mathlib/MeasureTheory/Function/LpSeminorm/TriangleInequality.lean</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LpAddConst_of_one_le</span> <span class=\"n\">h'p</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">snorm_add_le</span> <span class=\"n\">hf</span> <span class=\"n\">hg</span> <span class=\"n\">h'p</span>\n\n<span class=\"c1\">-- Mathlib/Analysis/InnerProductSpace/PiL2.lean</span>\n  <span class=\"c1\">-- Porting note: `LinearIsometryEquiv.trans_assoc` doesn't trigger in the `simp` above</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">LinearIsometryEquiv.trans_assoc</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Mathlib/MeasureTheory/Function/LpSpace.lean</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">q_zero</span><span class=\"o\">]</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">p_zero</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n\n<span class=\"c1\">-- Mathlib/Analysis/Matrix.lean</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">unitOf</span><span class=\"o\">]</span>\n  <span class=\"n\">split_ifs</span> <span class=\"k\">with</span> <span class=\"n\">h</span>\n\n<span class=\"c1\">-- Mathlib/MeasureTheory/Function/SimpleFuncDenseLp.lean</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">edist_comm</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"n\">edist_eq_coe_nnnorm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">exact</span> <span class=\"n\">mod_cast</span> <span class=\"n\">this</span>\n\n<span class=\"c1\">-- Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean</span>\n  <span class=\"n\">interval_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">%</span> <span class=\"mi\">8</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp_all</span> <span class=\"bp\">&lt;;&gt;</span>\n    <span class=\"n\">exact</span> <span class=\"n\">absurd</span> <span class=\"o\">(</span><span class=\"n\">hb2</span> <span class=\"bp\">▸</span> <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">Nat.mod_mod_of_dvd</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">decide</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">∣</span> <span class=\"mi\">8</span><span class=\"o\">))</span> <span class=\"n\">zero_ne_one</span>\n\n<span class=\"c1\">-- Mathlib/Probability/Process/Stopping.lean</span>\n    <span class=\"bp\">·</span> <span class=\"kd\">set_option</span> <span class=\"n\">tactic.skipAssignedInstances</span> <span class=\"n\">false</span> <span class=\"k\">in</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hij</span><span class=\"o\">]</span>\n      <span class=\"n\">convert</span> <span class=\"bp\">@</span><span class=\"n\">MeasurableSet.empty</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Filtration.seq</span> <span class=\"n\">f</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Mathlib/Probability/Kernel/Disintegration/Density.lean</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">κ</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">countablePartitionSet</span> <span class=\"n\">n</span> <span class=\"n\">x</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">univ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n\n<span class=\"c1\">-- Mathlib/Analysis/NormedSpace/Star/ContinuousFunctionalCalculus/Instances.lean</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hr'</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span> <span class=\"bp\">⊢</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hx.symm.le</span>\n\n<span class=\"c1\">-- Mathlib/NumberTheory/NumberField/CanonicalEmbedding.lean</span>\n    <span class=\"n\">Prod.snd_neg</span><span class=\"o\">,</span> <span class=\"n\">Complex.norm_eq_abs</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span> <span class=\"bp\">⊢</span>\n  <span class=\"n\">convert</span> <span class=\"n\">hx</span> <span class=\"n\">using</span> <span class=\"mi\">3</span>\n</code></pre></div>\n</div></div>",
        "id": 430388342,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711803734
    },
    {
        "content": "<p>Let me know if something from the output above looks like something that the linter should handle differently (i.e. should allow it).</p>\n<p>[I gave one line of context before each flag, which sometimes may not be enough to reconstruct what the issue was.]</p>",
        "id": 430388367,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711803763
    },
    {
        "content": "<p>I'm not sure about the <code>induction as with simp</code> thing. Is <code>simp</code> not an identifier there?</p>",
        "id": 430390028,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711805108
    },
    {
        "content": "<p>I assume that in the <code>RingTheory.Polynomial\nCyclotomic.Eval</code> example the above tactic is a simp operating on the goal that's focused?</p>",
        "id": 430390120,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711805187
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">q_zero</span><span class=\"o\">]</span>\n<span class=\"n\">by_cases</span> <span class=\"n\">p_zero</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>should be legal since <code>by_cases</code> doesn't operate on the goal.</p>",
        "id": 430390188,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711805271
    },
    {
        "content": "<p>Similarly for the <code>Probability.Kernel.Disintegration.Density</code> one</p>",
        "id": 430390254,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711805328
    },
    {
        "content": "<p>No, <code>induction as with simp</code> runs <code>simp</code> on each of the new subgoals</p>",
        "id": 430390684,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1711805722
    },
    {
        "content": "<p>That's quite confusing given the <code>induction'</code> syntax <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 430391787,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711806638
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/flexible.20vs.20rigid.20tactics/near/430390188\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">q_zero</span><span class=\"o\">]</span>\n<span class=\"n\">by_cases</span> <span class=\"n\">p_zero</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>should be legal since <code>by_cases</code> doesn't operate on the goal.</p>\n</blockquote>\n<p>Yes, there are still some rough edges around flagging <code>simp</code> when a new goal is created by the tactic.</p>\n<p>However, what I pasted there is the first failure in each file with basically no extra filter, so this is promising!</p>",
        "id": 430399483,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711813342
    },
    {
        "content": "<p>The \"flexible\" linter is essentially ready: <a href=\"https://github.com/leanprover-community/mathlib4/pull/11821\">#11821</a></p>\n<p>The PR above only defines the linter and adds a test file: the linter is not running on any file other than the test.</p>\n<p>There is a separate PR where I added the linter to most of mathlib: you can find it here: <a href=\"https://github.com/leanprover-community/mathlib4/pull/11822\">#11822</a>.</p>\n<p><a href=\"https://gist.github.com/adomani/2f7afc4bc515da47c3ff5c6e3f3bbbed\">Here is a gist</a> with the linter warnings from a separate run: there are approximately 230 files that the linter flags.  I scanned quickly a few of them and the linter seems to be doing its job!</p>",
        "id": 430619088,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711987739
    },
    {
        "content": "<p>One situation that the linter <em>does not</em> handle correctly is the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>  <span class=\"c1\">-- h : True</span>\n  <span class=\"n\">assumption</span>\n</code></pre></div>\n<p>Clearly, <code>assumption</code> is using <code>h</code>, but since <code>h</code> is not part of the syntax of the tactic, the linter is unaware of that.</p>\n<p>The linter <em>does</em> flag</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>  <span class=\"c1\">-- h : True</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 430619372,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711987810
    },
    {
        "content": "<p>Btw, if anyone feels like going through the gist above and knock down a few non-terminal simps, I would be more than thrilled!</p>",
        "id": 430619654,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711987890
    },
    {
        "content": "<p>(Also, while the whole setup would allow tactics other than <code>simp</code> to be flexible, I am only linting <code>simp</code> at the moment: already as it, it will be quite a lot of work to make <code>mathlib</code> compliant.)</p>",
        "id": 430619813,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711987943
    },
    {
        "content": "<p>While going through some of the lints, this is the most controversial that I found so far: is the pattern</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"bp\">...</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">split_ifs</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<p>acceptable?  What if the final <code>simp</code> is <code>exact</code> or <code>rw</code>?</p>",
        "id": 430744155,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712048520
    },
    {
        "content": "<p>I personally am not a huge fan of the <code>&lt;;&gt;</code>-combinator, because I usually value more clarity than saving space and I find that it more often obscures, rather than explain.</p>\n<p>In some cases, my solution has been to unlint, in others to squeeze, in others still to split the <code>&lt;;&gt;</code> combinators, depending on context.</p>",
        "id": 430744769,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712048696
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/287929-mathlib4/topic/flexible.20vs.20rigid.20tactics/near/430744155\">said</a>:</p>\n<blockquote>\n<p>While going through some of the lints, this is the most controversial that I found so far: is the pattern</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"bp\">...</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">split_ifs</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<p>acceptable?  What if the final <code>simp</code> is <code>exact</code> or <code>rw</code>?</p>\n</blockquote>\n<p>Surely that's fine iff the final tactic is flexible?</p>",
        "id": 430744906,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1712048750
    },
    {
        "content": "<p>Well, <code>if</code> could in theory be resolved by a better <code>simp</code> and then <code>split_ifs</code> would fail.</p>",
        "id": 430745074,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712048796
    },
    {
        "content": "<p>I am not sure that I consider <code>split_if</code> flexible.  Are you saying that <code>split_ifs</code> should simply be allowed as a <code>simp</code> follower?</p>",
        "id": 430745246,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712048859
    },
    {
        "content": "<p>I think <code>split_ifs</code> is neither flexible nor rigid. It's just a combinator</p>",
        "id": 430745415,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1712048903
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/287929-mathlib4/topic/flexible.20vs.20rigid.20tactics/near/430745074\">said</a>:</p>\n<blockquote>\n<p>Well, <code>if</code> could in theory be resolved by a better <code>simp</code> and then <code>split_ifs</code> would fail.</p>\n</blockquote>\n<p>In that case, you just remove the combinator, which should be a pretty obvious step to take</p>",
        "id": 430745507,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1712048938
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/287929-mathlib4/topic/flexible.20vs.20rigid.20tactics/near/430745074\">said</a>:</p>\n<blockquote>\n<p>Well, <code>if</code> could in theory be resolved by a better <code>simp</code> and then <code>split_ifs</code> would fail.</p>\n</blockquote>\n<p>Most flexible tactics have this behavior</p>",
        "id": 430745527,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712048945
    },
    {
        "content": "<p>simp can always produce something that the next tactic can't handle, flexible or otherwise</p>",
        "id": 430745616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712048973
    },
    {
        "content": "<p>but it's not dependent on the nitty gritty details of the goal, so it's flexible</p>",
        "id": 430745689,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712049001
    },
    {
        "content": "<p>Right, I agree that this is the behaviour of most flexible tactics, and the linter is trying to mitigate this by only allowing flexible tactics to follow flexible tactics.  There are <em>a lot</em> of rigid tactics following flexible ones already as is, so I am trying to find some common ground...</p>",
        "id": 430745790,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712049028
    },
    {
        "content": "<p>Anyway, I'll add <code>split_ifs</code> to the ignored list, which means that the linter would</p>\n<ul>\n<li>not complain on <code>simp &lt;;&gt; split_ifs &lt;;&gt; simp</code> but</li>\n<li>would complain on <code>simp &lt;;&gt; split_ifs &lt;;&gt; rw</code></li>\n</ul>",
        "id": 430745963,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712049092
    },
    {
        "content": "<p>Another question: should this proof be allowed, or should <code>simp</code> be squeezed?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">multiplicity</span><span class=\"o\">,</span> <span class=\"n\">rootMultiplicity</span><span class=\"o\">,</span> <span class=\"n\">Part.Dom</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">congr</span><span class=\"bp\">;</span> <span class=\"n\">funext</span><span class=\"bp\">;</span> <span class=\"n\">congr</span>\n</code></pre></div>\n<p>Note that there is an underlying decision that <code>congr</code> is allowed as a <code>simp</code> follower, so really the question is whether the <code>funext</code> jammed in there is acceptable or whether it is reason for preferring a <code>simp only</code> instead.</p>",
        "id": 431547995,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712329960
    },
    {
        "content": "<p>The last congr solves the goal? Too bad simp can't handle it on its own</p>",
        "id": 431554121,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1712331735
    },
    {
        "content": "<p>Yes, this is the full declaration:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Mathlib/Algebra/Polynomial/Div.lean</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">rootMultiplicity_eq_multiplicity</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">DecidableRel</span> <span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">∣</span> <span class=\"bp\">·</span><span class=\"o\">)]</span>\n    <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">rootMultiplicity</span> <span class=\"n\">a</span> <span class=\"n\">p</span> <span class=\"bp\">=</span>\n      <span class=\"k\">if</span> <span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">multiplicity</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">-</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"o\">(</span><span class=\"n\">multiplicity_X_sub_C_finite</span> <span class=\"n\">a</span> <span class=\"n\">h0</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">multiplicity</span><span class=\"o\">,</span> <span class=\"n\">rootMultiplicity</span><span class=\"o\">,</span> <span class=\"n\">Part.Dom</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">congr</span><span class=\"bp\">;</span> <span class=\"n\">funext</span><span class=\"bp\">;</span> <span class=\"n\">congr</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">polynomial.root_multiplicity_eq_multiplicity</span> <span class=\"n\">Polynomial.rootMultiplicity_eq_multiplicity</span>\n</code></pre></div>",
        "id": 431554294,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712331796
    },
    {
        "content": "<p>and this is the goal before the last <code>congr</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Nat.find</span> <span class=\"bp\">⋯</span> <span class=\"bp\">=</span> <span class=\"n\">Nat.find</span> <span class=\"bp\">⋯</span>\n</code></pre></div>\n<p><span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span></p>",
        "id": 431554516,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712331853
    },
    {
        "content": "<p>Is it expected that adding</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">pp.deepTerms</span> <span class=\"n\">true</span><span class=\"bp\">/</span><span class=\"n\">false</span> <span class=\"k\">in</span> <span class=\"c1\">-- I tried both</span>\n</code></pre></div>\n<p>before the declaration, I still see the <code>...</code>?</p>",
        "id": 431557457,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712332726
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/287929-mathlib4/topic/flexible.20vs.20rigid.20tactics/near/431554516\">said</a>:</p>\n<blockquote>\n<p>and this is the goal before the last <code>congr</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Nat.find</span> <span class=\"bp\">⋯</span> <span class=\"bp\">=</span> <span class=\"n\">Nat.find</span> <span class=\"bp\">⋯</span>\n</code></pre></div>\n<p><span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span></p>\n</blockquote>\n<p>I feel like the predicate argument to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.find#doc\">docs#Nat.find</a> should be explicit</p>",
        "id": 431562818,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1712334411
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/287929-mathlib4/topic/flexible.20vs.20rigid.20tactics/near/431557457\">said</a>:</p>\n<blockquote>\n<p>Is it expected that adding</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">pp.deepTerms</span> <span class=\"n\">true</span><span class=\"bp\">/</span><span class=\"n\">false</span> <span class=\"k\">in</span> <span class=\"c1\">-- I tried both</span>\n</code></pre></div>\n<p>before the declaration, I still see the <code>...</code>?</p>\n</blockquote>\n<p>I've been using <code>set_option pp.proofs.threshold 37</code> to expand <code>...</code>.</p>",
        "id": 431569392,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712336552
    },
    {
        "content": "<p>Thanks Kevin!  This is the goal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⊢</span> <span class=\"n\">Nat.find</span> <span class=\"o\">(</span><span class=\"n\">multiplicity_X_sub_C_finite</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">Eq.mpr_not</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n  <span class=\"n\">Nat.find</span>\n    <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"o\">(</span><span class=\"n\">PartENat.find</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">-</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∣</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"bp\">▸</span>\n      <span class=\"n\">multiplicity_X_sub_C_finite</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">Eq.mpr_not</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 431583012,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712341870
    },
    {
        "content": "<p>(I tried 0 and it didn't work so I tried 37 and it worked great)</p>",
        "id": 431606415,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712352179
    },
    {
        "content": "<p>I've just noticed that something we left out of the discussion is that tactics have different flexibility regarding their inputs and outputs eg in <code>simp [ha] at hb</code> we have</p>\n<ul>\n<li><code>ha</code> is a rigid input</li>\n<li><code>hb</code> is a flexible input</li>\n<li><code>hb</code> is a flexible output</li>\n</ul>",
        "id": 440258539,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1716447077
    },
    {
        "content": "<p>And, perhaps more subtly, <code>ha</code> is a rigid output in <code>have ha : Foo := by simpa using hb</code> but a flexible output in <code>have ha := by simpa using hb</code></p>",
        "id": 440258708,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1716447167
    },
    {
        "content": "<p>I'm not quite sure how to classify <code>ha</code> in intermediate situations like <code>have ha : Foo _ := by simpa using hb</code>. I guess it should be considered rigid even if it allows <code>have ha : _ := by simpa using hb</code> to leave <code>ha</code> rigid</p>",
        "id": 440258892,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1716447250
    },
    {
        "content": "<p>On the front of the flexible vs rigid, I was pretty happy with the linter output.  However, I personally find that there is no uniformly good way of pleasing the linter: replacing <code>simp [tacs]</code> with </p>\n<ul>\n<li>the output of <code>simp? [tacs]</code> hides what <code>tacs</code> is and is often too verbose;</li>\n<li><code>simp? [tacs] says ...</code> is again very verbose and also means that you still have to update the list of tactics when the simp-set changes;</li>\n<li><code>suffices ...</code> can again be very verbose, when the goals are long.</li>\n</ul>\n<p>Overall, while a non-terminal <code>simp</code> (or rigid tactic following a flexible one more generally) is not great for stability, I am not sure that the alternatives that are currently available are really an net improvement.</p>",
        "id": 440264542,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716449903
    },
    {
        "content": "<p>I have been thinking about a possible alternative.  Here is an initial idea.</p>\n<p>If a <code>simp</code> no longer works on a branch, but was present in <code>master</code>, then squeezing it in master would tell you what to use.  How about we write a tactic <code>squeeze_me_earlier</code> that takes a tactic as input (initially just <code>simp</code>) and</p>\n<ul>\n<li>checks out <code>master</code>,</li>\n<li>downloads the cache,</li>\n<li>attempts to find the correct <code>simp</code>;</li>\n<li>runs <code>simp?</code> recording the output;</li>\n<li>checks out the branch in development;</li>\n<li>says <code>Try this: [recorded output of `simp?`]</code>.</li>\n</ul>\n<p>This could also be something that runs in CI, possibly applying to <code>simp</code>s that break downstream of your changes, maybe in an untouched file, to begin with.</p>",
        "id": 440266043,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716450540
    }
]