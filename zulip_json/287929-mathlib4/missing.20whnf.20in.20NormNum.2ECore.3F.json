[
    {
        "content": "<p>Currently, <code>norm_num</code> can sometimes get stuck on sums:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.NormNum</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.NormNum.BigOperators</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"c1\">-- works</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">Finset.range</span> <span class=\"mi\">10</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">285</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num1</span>\n\n<span class=\"c1\">-- also works (via the evalOfNat extension)</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">Finset.range</span> <span class=\"mi\">10</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">45</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num1</span>\n\n<span class=\"c1\">-- does not work</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">Finset.range</span> <span class=\"mi\">10</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">45</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num1</span>\n</code></pre></div>\n<p>The problem is that when it tries to evaluate the inner body of the third example, <code>derive</code> is passed an expression of the form <code>(fun x : Nat =&gt; x) 9</code> where <code>9</code> is a nat literal. This expression is not itself a nat literal, and no norm num extensions apply to it.</p>\n<p>All three examples work if I make the following change:</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gh\">diff --git a/Mathlib/Tactic/NormNum/Core.lean b/Mathlib/Tactic/NormNum/Core.lean</span>\n<span class=\"gh\">index 6ebf7ed63e..ced2559f41 100644</span>\n<span class=\"gd\">--- a/Mathlib/Tactic/NormNum/Core.lean</span>\n<span class=\"gi\">+++ b/Mathlib/Tactic/NormNum/Core.lean</span>\n<span class=\"gu\">@@ -80,8 +80,9 @@ initialize normNumExt : ScopedEnvExtension Entry (Entry × NormNumExt) NormNums</span>\n\n<span class=\"w\"> </span>/-- Run each registered `norm_num` extension on an expression, returning a `NormNum.Result`. -/\n<span class=\"w\"> </span>def derive {α : Q(Type u)} (e : Q($α)) (post := false) : MetaM (Result e) := do\n<span class=\"gd\">-  if e.isNatLit then</span>\n<span class=\"gd\">-    let lit : Q(ℕ) := e</span>\n<span class=\"gi\">+  let e' ← whnfR e</span>\n<span class=\"gi\">+  if e'.isNatLit then</span>\n<span class=\"gi\">+    let lit : Q(ℕ) := e'</span>\n<span class=\"w\"> </span>    return .isNat (q(instAddMonoidWithOneNat) : Q(AddMonoidWithOne ℕ))\n<span class=\"w\"> </span>      lit (q(IsNat.raw_refl $lit) : Expr)\n<span class=\"w\"> </span>  profileitM Exception \"norm_num\" (← getOptions) do\n</code></pre></div>",
        "id": 411127500,
        "sender_full_name": "David Renshaw",
        "timestamp": 1704343592
    },
    {
        "content": "<p>Is that a reasonable change to make? I can prepare a PR if so.</p>",
        "id": 411127569,
        "sender_full_name": "David Renshaw",
        "timestamp": 1704343660
    },
    {
        "content": "<p>no, I think we don't want to whnf. This should probably happen in the norm_num extension that has to handle the lambda</p>",
        "id": 411128704,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704344480
    },
    {
        "content": "<p>Is your concern that this would be too expensive?</p>\n<p>The <code>normNums.tree.getMatch e discrTreeConfig</code> call later down already does some kind of <code>whnf</code> reduction.</p>\n<p>For reference, this is the current <code>derive</code> function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Run each registered `norm_num` extension on an expression, returning a `NormNum.Result`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">derive</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">post</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Result</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">if</span> <span class=\"n\">e.isNatLit</span> <span class=\"k\">then</span>\n    <span class=\"k\">let</span> <span class=\"n\">lit</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">e</span>\n    <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">isNat</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">instAddMonoidWithOneNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">AddMonoidWithOne</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span>\n      <span class=\"n\">lit</span> <span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">IsNat.raw_refl</span> <span class=\"bp\">$</span><span class=\"n\">lit</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span>\n  <span class=\"n\">profileitM</span> <span class=\"n\">Exception</span> <span class=\"s2\">\"norm_num\"</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getOptions</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"bp\">←</span> <span class=\"n\">saveState</span>\n    <span class=\"k\">let</span> <span class=\"n\">normNums</span> <span class=\"o\">:=</span> <span class=\"n\">normNumExt.getState</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getEnv</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">arr</span> <span class=\"bp\">←</span> <span class=\"n\">normNums.tree.getMatch</span> <span class=\"n\">e</span> <span class=\"n\">discrTreeConfig</span>\n    <span class=\"n\">for</span> <span class=\"n\">ext</span> <span class=\"k\">in</span> <span class=\"n\">arr</span> <span class=\"k\">do</span>\n      <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">bif</span> <span class=\"n\">post</span> <span class=\"k\">then</span> <span class=\"n\">ext.post</span> <span class=\"k\">else</span> <span class=\"n\">ext.pre</span><span class=\"o\">)</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"bp\">!</span> <span class=\"n\">normNums.erased.contains</span> <span class=\"n\">ext.name</span> <span class=\"k\">then</span>\n        <span class=\"n\">try</span>\n          <span class=\"k\">let</span> <span class=\"n\">new</span> <span class=\"bp\">←</span> <span class=\"n\">withReducibleAndInstances</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">ext.eval</span> <span class=\"n\">e</span>\n          <span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">Tactic.norm_num</span><span class=\"o\">]</span> <span class=\"s2\">\"{ext.name}:</span><span class=\"se\">\\n</span><span class=\"s2\">{e} ==&gt; {new}\"</span>\n          <span class=\"n\">return</span> <span class=\"n\">new</span>\n        <span class=\"n\">catch</span> <span class=\"n\">err</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">Tactic.norm_num</span><span class=\"o\">]</span> <span class=\"s2\">\"{e} failed: {err.toMessageData}\"</span>\n          <span class=\"n\">s.restore</span>\n    <span class=\"n\">throwError</span> <span class=\"s2\">\"{e}: no norm_nums apply\"</span>\n</code></pre></div>",
        "id": 411193091,
        "sender_full_name": "David Renshaw",
        "timestamp": 1704376660
    },
    {
        "content": "<blockquote>\n<p>This should probably happen in the norm_num extension that has to handle the lambda</p>\n</blockquote>\n<p>I don't understand what you mean. By the time norm_num extensions are seeing this expression, the beta redex has been reduced and the lambda is gone.</p>",
        "id": 411194397,
        "sender_full_name": "David Renshaw",
        "timestamp": 1704377066
    },
    {
        "content": "<p>Ah, I was wrong -- apparently the beta redex does not always go away. I tried writing an extension like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">norm_num</span> <span class=\"n\">_</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">evalNatLiteral</span> <span class=\"o\">:</span> <span class=\"n\">NormNumExt</span> <span class=\"n\">where</span> <span class=\"n\">eval</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">guard</span> <span class=\"n\">e.isNatLit</span>\n  <span class=\"k\">let</span> <span class=\"n\">sα</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">AddMonoidWithOne</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">inferInstance</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">e</span>\n  <span class=\"k\">let</span> <span class=\"n\">pa'</span> <span class=\"bp\">←</span> <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">IsNat.mk</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">sα</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">rfl</span> <span class=\"kt\">Type</span> <span class=\"n\">ℕ</span><span class=\"o\">)]</span>\n  <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">isNat</span> <span class=\"n\">sα</span> <span class=\"n\">n</span> <span class=\"n\">pa'</span>\n</code></pre></div>\n<p>and this fails to solve the problem because it sees <code>e</code> as the un-reduced <code>(fun (i : Nat) =&gt; i) 9</code>.</p>",
        "id": 411217777,
        "sender_full_name": "David Renshaw",
        "timestamp": 1704384386
    },
    {
        "content": "<p>aha! This seems to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">norm_num</span> <span class=\"n\">_</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">evalBetaRedex</span> <span class=\"o\">:</span> <span class=\"n\">NormNumExt</span> <span class=\"n\">where</span> <span class=\"n\">eval</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">lam</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">e</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"not beta redex\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">e'</span> <span class=\"bp\">←</span> <span class=\"n\">Core.betaReduce</span> <span class=\"n\">e</span>\n  <span class=\"n\">derive</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">e'</span>\n</code></pre></div>\n<p>I would prefer to something like <code>@[norm_num (fun _ =&gt; _ ) _] </code>, but that still seems to match <em>everything</em>, and so would still need the <code>let .app (.lam ...) ...</code> line.</p>",
        "id": 411240897,
        "sender_full_name": "David Renshaw",
        "timestamp": 1704393443
    },
    {
        "content": "<p>Another way to achieve basically the same thing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">diff</span> <span class=\"c1\">--git a/Mathlib/Tactic/NormNum/Core.lean b/Mathlib/Tactic/NormNum/Core.lean</span>\n<span class=\"n\">index</span> <span class=\"mi\">6</span><span class=\"n\">ebf7ed63e..adf7f96b2c</span> <span class=\"mi\">100644</span>\n<span class=\"c1\">--- a/Mathlib/Tactic/NormNum/Core.lean</span>\n<span class=\"bp\">+++</span> <span class=\"n\">b</span><span class=\"bp\">/</span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Tactic</span><span class=\"bp\">/</span><span class=\"n\">NormNum</span><span class=\"bp\">/</span><span class=\"n\">Core.lean</span>\n<span class=\"bp\">@@</span> <span class=\"bp\">-</span><span class=\"mi\">80</span><span class=\"o\">,</span><span class=\"mi\">6</span> <span class=\"bp\">+</span><span class=\"mi\">80</span><span class=\"o\">,</span><span class=\"mi\">12</span> <span class=\"bp\">@@</span> <span class=\"n\">initialize</span> <span class=\"n\">normNumExt</span> <span class=\"o\">:</span> <span class=\"n\">ScopedEnvExtension</span> <span class=\"n\">Entry</span> <span class=\"o\">(</span><span class=\"n\">Entry</span> <span class=\"bp\">×</span> <span class=\"n\">NormNumExt</span><span class=\"o\">)</span> <span class=\"n\">NormNums</span>\n\n <span class=\"sd\">/-- Run each registered `norm_num` extension on an expression, returning a `NormNum.Result`. -/</span>\n <span class=\"kd\">def</span> <span class=\"n\">derive</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">post</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Result</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n<span class=\"bp\">+</span>  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">e</span>\n<span class=\"bp\">+</span>  <span class=\"n\">while</span> <span class=\"n\">true</span> <span class=\"k\">do</span>\n<span class=\"bp\">+</span>    <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">lam</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">e</span>\n<span class=\"bp\">+</span>    <span class=\"k\">then</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">Core.betaReduce</span> <span class=\"n\">e</span>\n<span class=\"bp\">+</span>    <span class=\"k\">else</span> <span class=\"n\">break</span>\n<span class=\"bp\">+</span>\n   <span class=\"k\">if</span> <span class=\"n\">e.isNatLit</span> <span class=\"k\">then</span>\n</code></pre></div>",
        "id": 411249583,
        "sender_full_name": "David Renshaw",
        "timestamp": 1704397007
    },
    {
        "content": "<p>I don't want to have reduction there both because it is slow and also because norm_num extensions might want to spot the pattern even though it normalizes. The whole idea is that <code>norm_num</code> tries to use more efficient reduction strategies than kernel computation because it has more domain knowledge.</p>",
        "id": 411250840,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704397414
    },
    {
        "content": "<p>yeah, I understand now why we don't want to <code>whnf</code> at the beginning of <code>NormNum.derive</code></p>",
        "id": 411250917,
        "sender_full_name": "David Renshaw",
        "timestamp": 1704397446
    },
    {
        "content": "<p>In this case, I'm saying that you should back up one step to find out who put a beta redex in your term and deal with the issue there</p>",
        "id": 411250921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704397448
    },
    {
        "content": "<p>in this case I think the culprit is the norm_num extension for sums</p>",
        "id": 411251056,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704397539
    },
    {
        "content": "<p>ok, I'll look at that</p>",
        "id": 411251072,
        "sender_full_name": "David Renshaw",
        "timestamp": 1704397550
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/9446\">#9446</a></p>",
        "id": 411255935,
        "sender_full_name": "David Renshaw",
        "timestamp": 1704399825
    }
]