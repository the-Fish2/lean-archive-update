[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.LibrarySearch</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.BigOperators.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Parity</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">Finset.range</span> <span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">Finset.range</span> <span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha2</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">Even</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Odd</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span><span class=\"bp\">?</span>\n  <span class=\"c1\">-- maximum recursion depth has been reached</span>\n  <span class=\"c1\">-- std_exact? hits the same problem</span>\n  <span class=\"c1\">-- If I comment out `h` above, the we get what we want:</span>\n  <span class=\"c1\">-- Try this: exact Nat.odd_iff_not_even.mpr ha2</span>\n</code></pre></div>\n<p>My hypothesis is that <code>exact?</code> is getting bogged down trying to whnf-reduce the sums in <code>h</code> using <code>default</code> transparency. However, adding doing <code>with_reducible exact?</code> (to change to <code>reducible</code> transparency) does not help. So I guess something might be erroneously hard-coding <code>default</code> transparency?</p>",
        "id": 417649319,
        "sender_full_name": "David Renshaw",
        "timestamp": 1706104237
    },
    {
        "content": "<p>We have <code>exact? using ..</code>, maybe we need <code>exact? not_using ..</code> :-)</p>",
        "id": 417652296,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706105188
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">exact</span><span class=\"bp\">?</span> <span class=\"n\">using</span> <span class=\"n\">ha2</span>\n</code></pre></div>\n<p>hits the same error when I try it</p>",
        "id": 417652670,
        "sender_full_name": "David Renshaw",
        "timestamp": 1706105299
    },
    {
        "content": "<p>ah, I see <code>using</code> does not exclude other hypthesis (but your proposal <code>not_using</code> would)</p>",
        "id": 417656000,
        "sender_full_name": "David Renshaw",
        "timestamp": 1706106353
    },
    {
        "content": "<p>traces indicate:</p>\n<ol>\n<li><code>librarySearch</code> tries the lemma <code>Nat.odd_iff</code></li>\n<li>for that lemma to work, we need <code>a % 2 = 1</code></li>\n<li><code>solveByElim</code> tries applying <code>h</code> to prove <code>a % 2 = 1</code>.</li>\n<li><code>h</code> gets reduced, fully expanding out the sum</li>\n</ol>",
        "id": 417668526,
        "sender_full_name": "David Renshaw",
        "timestamp": 1706109968
    },
    {
        "content": "<p>aha! this makes the problem go away:</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gh\">diff --git a/Mathlib/Tactic/LibrarySearch.lean b/Mathlib/Tactic/LibrarySearch.lean</span>\n<span class=\"gh\">index 5855a99fd8..7895dc6f03 100644</span>\n<span class=\"gd\">--- a/Mathlib/Tactic/LibrarySearch.lean</span>\n<span class=\"gi\">+++ b/Mathlib/Tactic/LibrarySearch.lean</span>\n<span class=\"gu\">@@ -104,7 +104,8 @@ def solveByElim (goals : List MVarId) (required : List Expr) (exfalso := false)</span>\n<span class=\"w\"> </span>  -- There is only a marginal decrease in performance for using the `symm` option for `solveByElim`.\n<span class=\"w\"> </span>  -- (measured via `lake build &amp;&amp; time lake env lean test/librarySearch.lean`).\n<span class=\"w\"> </span>  let cfg : SolveByElim.Config :=\n<span class=\"gd\">-    { maxDepth := depth, exfalso := exfalso, symm := true, commitIndependentGoals := true }</span>\n<span class=\"gi\">+    { maxDepth := depth, exfalso := exfalso, symm := true, commitIndependentGoals := true,</span>\n<span class=\"gi\">+      transparency := .reducible  }</span>\n<span class=\"w\"> </span>  let cfg := if !required.isEmpty then cfg.requireUsingAll required else cfg\n<span class=\"w\"> </span>  SolveByElim.solveByElim.processSyntax cfg false false [] [] #[] goals\n</code></pre></div>\n<p>(but possibly has unwanted effects elsewhere)</p>",
        "id": 417669942,
        "sender_full_name": "David Renshaw",
        "timestamp": 1706110375
    },
    {
        "content": "<p>If you change this patch so that it passes the output of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.getTransparency#doc\">docs#Lean.Meta.getTransparency</a> instead of the flat <code>reducible</code>, it looks very reasonable to me.</p>",
        "id": 417672373,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1706111054
    },
    {
        "content": "<p>Yep, that makes it work with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">with_reducible</span> <span class=\"n\">exact</span><span class=\"bp\">?</span>\n</code></pre></div>",
        "id": 417673983,
        "sender_full_name": "David Renshaw",
        "timestamp": 1706111476
    },
    {
        "content": "<p>I think a solution that would often be useful is to have a tactic that turns a specific term into an atom - in circumstances like this, sometimes you don't want the kernel to further reduce these things, even if in principle it could, because the defeqs involved are heavy</p>",
        "id": 417674929,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706111763
    },
    {
        "content": "<p>Maybe this could be enforced by some mdata or just some special version of <code>id</code></p>",
        "id": 417675020,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706111784
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60exact.3F.60.20failure.3A.20.22maximum.20recursion.20depth.20has.20been.20reached.22/near/417674929\">said</a>:</p>\n<blockquote>\n<p>I think a solution that would often be useful is to have a tactic that turns a specific term into an atom</p>\n</blockquote>\n<p>I think that's <code>generalize</code></p>",
        "id": 418397269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706341003
    },
    {
        "content": "<p>Ah, yes, true! I meant in-place somehow but not sure if that is possible</p>",
        "id": 418412637,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706356931
    },
    {
        "content": "<p>I made the <code>getTransparency</code> change in <a href=\"https://github.com/leanprover-community/mathlib4/pull/10052\">#10052</a> and <a href=\"https://github.com/leanprover/std4/pull/566\">std4#566</a>.</p>",
        "id": 418423856,
        "sender_full_name": "David Renshaw",
        "timestamp": 1706367668
    },
    {
        "content": "<p>Both merged now, thanks!</p>",
        "id": 418753387,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1706579220
    }
]