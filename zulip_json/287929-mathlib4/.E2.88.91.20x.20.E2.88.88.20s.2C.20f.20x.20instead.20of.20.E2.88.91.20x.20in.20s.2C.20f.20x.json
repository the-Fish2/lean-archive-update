[
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/6795\">#6795</a> is an experiment with having <code>∑ x ∈ s, f x</code> mean what you think it should mean. Here, <code>s</code> can be a <code>Finset</code> or a <code>Set</code> that has a <code>Fintype</code> instance (in which case it inserts <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.toFinset#doc\">docs#Set.toFinset</a>).</p>\n<p>It has <code>∑ (x ∈ s) (y ∈ t), f x y</code> for <code>Finset.sum (s ×ˢ t) (fun ⟨x, y⟩ ↦ f x y)</code>, which gives limited support for products and destructuring. (The <code>extBinders</code> notation doesn't let you write <code>∑ ⟨x, y⟩ ∈ s ×ˢ t, f x y</code> since it requires an identifier or a <code>_</code> for a binder name, not <code>⟨x, y⟩</code>.) For nested sums, you can just use nested sums like <code>∑ x ∈ s, ∑ y ∈ t, f x y</code>.</p>\n<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> and <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> were suggesting that it's useful for their work being able to easily add a condition to the domain, so there's also a <code>with</code> clause, for example <code>∑ (x ∈ Finset.range 5) (y ∈ Finset.range 5) with x &lt; y, x * y</code>. They pointed out that, switching <code>∑</code> to an expectation operator, it being a product that's filtered is essential and it can't be a nested big operator.</p>\n<p>The PR also adds support for a handful of inequalities, like <code>∑ x &lt; 37, x</code> instead of <code>∑ x ∈ Finset.Iio 37, x</code>. This is ad hoc since it needs to give custom Finset interpretations of each extended binder.</p>",
        "id": 387352818,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693003668
    },
    {
        "content": "<p>This has already been mentioned privately, but it would be nice to allow the second set to depend on the first variable with <code>Finset.sigma</code>. Since I'm not good at reading Lean4 meta code yet, I'll ask directly - does this work for sums of more than two things?</p>",
        "id": 387357897,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1693007914
    },
    {
        "content": "<p>It only supports non-dependent sums at the moment (and it does work for more than two things). I think it should be possible to choose <code>Finset.sigma</code> vs <code>SProd.sprod</code> depending on whether the binders are dependent or not. (Or should it <em>always</em> use <code>Finset.sigma</code>?)</p>",
        "id": 387358443,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693008255
    },
    {
        "content": "<p>I mentioned it <a href=\"#narrow/stream/287929-mathlib4/topic/Destruction.20and.20big.20operators/near/384344815\">on another thread</a>, but to keep track of it, I'll mention here that I pushed an additional change to let you do <code>∑ ⟨x, y⟩ ∈ s ×ˢ t, f x y</code>.</p>\n<p>This took making a version of <code>extBinder</code> that lets it start with <code>term:max</code> rather than just <code>ident &lt;|&gt; hole</code>. It seems like this is safe enough to contribute back to std, but for now it's a mathlib experiment.</p>",
        "id": 387367323,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693012971
    },
    {
        "content": "<p>(edit: moved from a private stream)</p>\n<p>The main thing I dislike about <a href=\"https://github.com/leanprover-community/mathlib4/pull/6795\">#6795</a> is that at some people we'll get beginners asking \"why can't I rewrite by <code>Finset.mem_union</code> on <code>∑ x ∈ s ∪ t, f x</code>, and then we have to explain \"oh, that goal looks like it's about <code>x ∈ s ∪ t</code> but the <code>∈</code> means something completely different here for silly technical reasons and so they don't match\"</p>",
        "id": 430039359,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711622715
    },
    {
        "content": "<p>Fair enough!</p>",
        "id": 430039423,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711622750
    },
    {
        "content": "<p>Does it take much explanation to point out that <code>x</code> is being bound here, and what would <code>∑ x ∈ s ∨ x ∈ t, f x</code> mean?</p>\n<p>There's also the simple \"<code>∑ x ∈ s, f x</code> is just syntax for summing over <code>s</code>\".</p>",
        "id": 430041638,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711623666
    },
    {
        "content": "<p>I don't remember the current state of <a href=\"https://github.com/leanprover-community/mathlib4/pull/6795\">#6795</a>; I don't necessarily endorse it, but if people want it that's fine.</p>",
        "id": 430041876,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711623744
    },
    {
        "content": "<p>It's even more confusing if that user counters with \"well why does it work on <code>∑ᶠ x ∈ s ∪ t, f x</code>\"?</p>",
        "id": 430042002,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711623794
    },
    {
        "content": "<p>The more questionable feature in my opinion is that <code>∑ (x ∈ s) (y ∈ t), f x y</code> is <code>Finset.sum (s ×ˢ t) (fun ⟨x, y⟩ ↦ f x y)</code>, and it doesn't support dependent types.</p>",
        "id": 430042064,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711623817
    },
    {
        "content": "<p>There's a reason for this, which is that Yael and Bhavik want unity with some expectation syntax they have.</p>",
        "id": 430042243,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711623868
    },
    {
        "content": "<p>Isn't it a little weird that it works on <code>∑ᶠ x ∈ s ∪ t, f x</code>? First, it doesn't work with <code>rw</code>, only <code>simp_rw</code>, and second it changes form in a big way, turning into a nested sum. That one has to be explained as being due to a \"silly technical reason\", which is that it's convenient to encode this as a nested sum with the inner one being over the proofs of <code>x ∈ s ∪ t</code>.</p>",
        "id": 430042624,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711624017
    },
    {
        "content": "<p>The weirdness in that case is the same as the weirdness for</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">Finset.mem_union</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>though; it's not new weirdness</p>",
        "id": 430044229,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711624648
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, are you happy for me to move the conversation about <a href=\"https://github.com/leanprover-community/mathlib4/pull/6795\">#6795</a> out to <del>#<strong>PR reviews</strong></del> (edit: no point making  a new thread) so that Yael can see it?</p>",
        "id": 434856146,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713823687
    },
    {
        "content": "<p>Sure, go ahead <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span></p>",
        "id": 434876884,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713833266
    },
    {
        "content": "<p>13 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"180721\" href=\"/#narrow/stream/180721-mathlib-maintainers/topic/meta.20PRs.20-.20.236795\">#mathlib maintainers &gt; meta PRs - #6795</a> by <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span>.</p>",
        "id": 436145898,
        "sender_full_name": "Notification Bot",
        "timestamp": 1714427262
    },
    {
        "content": "<p>I hath seen <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span></p>",
        "id": 436146283,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1714427423
    },
    {
        "content": "<p>In the same vein, I have <a href=\"https://github.com/leanprover-community/mathlib4/pull/11582\">#11582</a> open which defines set builder notation. Personally, I find the resulting statements excessively nice and can't wait to overhaul mathlib to use the new notation.</p>",
        "id": 437506930,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715106314
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"695413\">@Christoph Spiegel</span> in particular would really like to have this notation for combinatorics</p>",
        "id": 437507116,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715106382
    }
]