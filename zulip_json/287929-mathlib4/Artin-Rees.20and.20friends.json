[
    {
        "content": "<p>One way to show that smooth ring homomorphisms are flat uses that the <code>I</code>-adic completion of a noetherian ring <code>R</code> with respect to an ideal <code>I</code> is flat over <code>R</code>.  A few questions:</p>\n<ul>\n<li>The proof I know uses the Artin-Rees lemma. As far as I can tell, this does not exist yet, but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=reesAlgebra#doc\">docs#reesAlgebra</a> exists. <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span>: Since you defined the Rees algebra, are you working on the Artin-Rees lemma? By any chance, do you know a direct way to show flatness of the <code>I</code>-adic completion?</li>\n<li>Why is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=adicCompletion#doc\">docs#adicCompletion</a> defined as an explicit submodule of <code>∀ n : ℕ, M ⧸ (I ^ n • ⊤ : Submodule R M)</code> as opposed to the categorical limit over a suitable diagram?</li>\n</ul>",
        "id": 434592505,
        "sender_full_name": "Christian Merten",
        "timestamp": 1713709509
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> \"Artin-Rees\"</p>",
        "id": 434592635,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1713709635
    },
    {
        "content": "<p><span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> nothing found</p>",
        "id": 434592637,
        "sender_full_name": "loogle",
        "timestamp": 1713709636
    },
    {
        "content": "<p>I thought loogle searched in docstrings as well?</p>",
        "id": 434592723,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1713709687
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ideal.exists_pow_inf_eq_pow_smul#doc\">docs#Ideal.exists_pow_inf_eq_pow_smul</a> Is this what you are looking for?</p>",
        "id": 434592751,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1713709713
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 434592936,
        "sender_full_name": "Christian Merten",
        "timestamp": 1713709882
    },
    {
        "content": "<p>Could I raise attention to my second question?<br>\n<span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Artin-Rees.20and.20friends/near/434592505\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Why is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=adicCompletion#doc\">docs#adicCompletion</a> defined as an explicit submodule of <code>∀ n : ℕ, M ⧸ (I ^ n • ⊤ : Submodule R M)</code> as opposed to the categorical limit over a suitable diagram?</li>\n</ul>\n</blockquote>\n<p>I am wondering, because I'll have to work on exactness properties of <code>I</code>-adic completions for which having the limit version seems to come in handy.</p>",
        "id": 434689999,
        "sender_full_name": "Christian Merten",
        "timestamp": 1713775240
    },
    {
        "content": "<p>I wouldn't be surprised if the answer is in large part: \"history\". I think this was developed a long time ago by Kenny Lau. The category library was much more in flux back then. And Kenny was on a constructive streak, so he didn't want to \"choose\" a limit.</p>",
        "id": 434701840,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1713778657
    },
    {
        "content": "<p>I don't have a strong opinion here, but a possible deficiency of using the category theory library is that it is not universe polymorphic. In particular, if <code>M</code> is a colimit of some family of <code>M i : Type u</code>, it is not completely trivial to use the category library to lift some family of <code>M i -&gt;* N</code> to <code>M -&gt;* N</code> for some <code>N : Type v</code> without going through some ulift shenanigans. The fact that <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/tensor.20products.20commute.20with.20direct.20limits/near/275178330\">ulifting groups does not preserve colimits</a> doesn't show a good sign as well, though I think it is well-behaved for limits of modules.</p>",
        "id": 434705735,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1713779741
    },
    {
        "content": "<p>shouldn't it be possible to prove it's a limit anyway? Categorical notions are usually only defined up to isomorphism anyway. (Plus universal constructions in lean are fundamentally restricted due to universe issues as Andrew says.)</p>",
        "id": 434705926,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713779792
    },
    {
        "content": "<p>Nonetheless we can either</p>\n<ol>\n<li>Disregard the universe issue and treat it later when we really need to</li>\n<li>Provide some wrapper API for ulift shenanigans.</li>\n</ol>",
        "id": 434705964,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1713779800
    },
    {
        "content": "<p>I personally think we should try the \"ulift shenanigans\" strategy instead of always falling back to doing things explicitly by hand. But for now maybe we can choose Andrews option 1, i.e. disregard universe issues for now?</p>\n<p>In any case we will need (commutative) ring and algebra versions of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=adicCompletion#doc\">docs#adicCompletion</a>. And for good definitional properties I suppose the ring version should be defined as the limit over <code>R ⧸ (I ^ n)</code> instead of <code>R ⧸ (I ^ n • R)</code> which <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=adicCompletion#doc\">docs#adicCompletion</a> would specialize to. Then there should be comparison isomorphisms relating the three (module, ring and algebra) adic completions. Do you agree?</p>",
        "id": 434712216,
        "sender_full_name": "Christian Merten",
        "timestamp": 1713781730
    },
    {
        "content": "<p>You may put suitable instances on a type <code>Functor.sections</code>, and not rely too much on the category theory limits API, even though when the universe are well suited, this is the point of a limit cone in the category of types (and also, in other categories as forgetful functors should at least reflects these limits).</p>",
        "id": 434720782,
        "sender_full_name": "Joël Riou",
        "timestamp": 1713784584
    },
    {
        "content": "<p>I am happy to use <code>Type u</code> in my code, but the moment I have problems with <code>Type u</code> and <code>Type v</code> I just switch to <code>u = v</code> rather than trying to fix them, because secretly I am confident that I will never care about multiple universe polymorphism.</p>",
        "id": 434746794,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713791817
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Artin-Rees.20and.20friends/near/434701840\">said</a>:</p>\n<blockquote>\n<p>I wouldn't be surprised if the answer is in large part: \"history\". I think this was developed a long time ago by Kenny Lau. The category library was much more in flux back then. And Kenny was on a constructive streak, so he didn't want to \"choose\" a limit.</p>\n</blockquote>\n<p>One shouldn't choose anything anyway. We should have a <code>IsAdicCompletion</code> class.</p>",
        "id": 434770698,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1713797471
    },
    {
        "content": "<p>I managed to prove exactness of adic completion over noetherian rings for f.g. modules with the current definition without going through category theory. This seems okay, but not ideal, as it essentially mimics the proof of exactness of inverse limits when the appropriate inverse system has surjective transition maps. </p>\n<ul>\n<li>Given a short exact sequence <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>→</mo><mo stretchy=\"false\">(</mo><msub><mi>M</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><mo>→</mo><mo stretchy=\"false\">(</mo><msub><mi>N</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><mo>→</mo><mo stretchy=\"false\">(</mo><msub><mi>P</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><mo>→</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0 \\to (M_i) \\to (N_i) \\to (P_i) \\to 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> of inverse systems indexed by a countable set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> where the system <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>M</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(M_i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> is Mittag-Leffler, the induced sequence on inverse limits is exact. The proof I know for this is the following: Since the index set is countable and cofiltered, we find <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> as a cofinal subset. Hence we are reduced to the case of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mo>=</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">I = \\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>. By Mittag-Leffler we may also assume that the transition maps in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>M</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(M_i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> are surjective. This refined statement is now shown by induction.</li>\n<li>To show this in full generality (for a cofiltered countable index category) we need the generalization of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Limits.sequentialFunctor_initial#doc\">docs#CategoryTheory.Limits.sequentialFunctor_initial</a>, which I currently don't want to spend time on. But, if we stick to the strategy outlined in the first bullet point, I am happy to show the refined version for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mo>=</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">I = \\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>, since that is the case needed for adic completions. One then at least gets the version for countable, cofiltered, preorderd sets via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Limits.sequentialFunctor_initial#doc\">docs#CategoryTheory.Limits.sequentialFunctor_initial</a>.</li>\n<li>Are you okay with the strategy outline in the first bullet point and with handling the case of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mo>=</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">I = \\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> first and generalize later via the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Functor.Initial#doc\">docs#CategoryTheory.Functor.Initial</a> API?</li>\n</ul>",
        "id": 435879497,
        "sender_full_name": "Christian Merten",
        "timestamp": 1714315276
    },
    {
        "content": "<p>I think it is perfectly fine to go for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mo>=</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">I = \\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> first.</p>",
        "id": 435880356,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1714315704
    },
    {
        "content": "<p>Do we want API for working with sequential limits?</p>",
        "id": 435882377,
        "sender_full_name": "Christian Merten",
        "timestamp": 1714317460
    },
    {
        "content": "<p>Of course! Any API useful for you is probably useful to someone else. Any development is greatly appreciated.</p>",
        "id": 435882683,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1714317733
    },
    {
        "content": "<p>So I am showing exactness in <code>AddCommGroupCat</code> right?</p>",
        "id": 435889652,
        "sender_full_name": "Christian Merten",
        "timestamp": 1714321823
    },
    {
        "content": "<p>Concerning adic completions: I have tried out a few things and decided to follow the following path:</p>\n<ul>\n<li>Keep <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=adicCompletion#doc\">docs#adicCompletion</a> mostly as is but rename to <code>AdicCompletion</code>.</li>\n<li>Make an <code>AdicCompletion</code> folder and maybe move to <code>Mathlib/RingTheory</code> (currently it is in <code>LinearAlgebra</code>).</li>\n<li>Add the universal lifting property by manual construction (since this is very easy, no machinery is needed).</li>\n<li>Add a type <code>AdicCauchySequence</code> as a submodule of <code>∀ n, M</code>, a surjective linear map <code>AdicCauchySequence I M →ₗ[R] AdicCompletion I M</code> and a corresponding induction principle.</li>\n<li>Provide comparison ismorphisms to the sections of the corresponding functor <code>ℕᵒᵖ ⥤ ModuleCat.{u} R</code>.</li>\n<li>For the algebra version: Don't introduce a second <code>AdicCompletionAlgebra</code>, but provide a <code>Algebra R (AdicCompletion I R)</code> instance, deduced from it being a <code>R</code>-subalgebra of <code>∀ n , R ⧸ (I^n • ⊤ : Ideal R)</code>.</li>\n<li>Since working with <code>R ⧸ (I^n • ⊤ : Ideal R)</code> is stupidly annoying (note that this is not def-eq to <code>R ⧸ I^n</code>), mimic the API for modules for algebras, in particular add constructors for <code>AdicCauchySequence I R</code> from the compatibility condition involving only <code>R ⧸ I ^ n</code> and Algebra homomorphisms <code>AdicCompletion I R →ₐ[R] R ⧸ I ^ n</code>.</li>\n</ul>\n<p>I would appreciate any comments on the outlined steps.</p>",
        "id": 436071994,
        "sender_full_name": "Christian Merten",
        "timestamp": 1714403490
    },
    {
        "content": "<p>Given that we just changed ringOfIntegers (a subring) to RingOfIntegers (a type) and this solved some slowdowns, I think that this approach is probably a good idea.</p>",
        "id": 436075512,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1714404353
    },
    {
        "content": "<p><del>I am confused: is this <code>ringOfIntegers</code> change still pending?</del> Never mind, I found the PR.</p>",
        "id": 436079617,
        "sender_full_name": "Christian Merten",
        "timestamp": 1714405301
    },
    {
        "content": "<p>The starting point is <a href=\"https://github.com/leanprover-community/mathlib4/pull/12516\">#12516</a>. For functoriality: <a href=\"https://github.com/leanprover-community/mathlib4/pull/12543\">#12543</a> and for the algebra instance: <a href=\"https://github.com/leanprover-community/mathlib4/pull/12553\">#12553</a>.</p>",
        "id": 436300453,
        "sender_full_name": "Christian Merten",
        "timestamp": 1714491578
    }
]