[
    {
        "content": "<p>Unsure if this is a mathlib question, because I'm not sure if there is some <code>integral_*</code> lemma that could help out here.</p>\n<p>How can I rewrite a term inside an set integral with the hypothesis that the variable of integration is a member of the set being integrated over? Specifically I'm trying to do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Integral.IntervalIntegral</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∫</span> <span class=\"o\">(</span><span class=\"n\">θ</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"n\">π</span><span class=\"o\">,</span> <span class=\"n\">ENNReal.toReal</span> <span class=\"o\">(</span><span class=\"n\">ENNReal.ofReal</span> <span class=\"n\">θ.sin</span><span class=\"o\">)</span> <span class=\"bp\">∂</span><span class=\"n\">ℙ</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lhs</span><span class=\"bp\">;</span> <span class=\"n\">arg</span> <span class=\"mi\">2</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">θ</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ENNReal.toReal_ofReal</span> <span class=\"bp\">?</span><span class=\"n\">pos</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>But I don't think <code>conv</code> is the right move here as it isn't aware of the context <code>θ</code> is under.</p>",
        "id": 418465320,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1706409720
    },
    {
        "content": "<p>Ended up solving it with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.set_integral_congr#doc\">docs#MeasureTheory.set_integral_congr</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.EqOn#doc\">docs#Set.EqOn</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- This can probably have a weaker condition, that f s is almost everywhere non-negative.</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">set_integral_toReal_ofReal</span> <span class=\"o\">[</span><span class=\"n\">MeasureSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSet</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∫</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">ENNReal.toReal</span> <span class=\"o\">(</span><span class=\"n\">ENNReal.ofReal</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"bp\">∫</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">comp_eq</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ENNReal.toReal</span> <span class=\"o\">(</span><span class=\"n\">ENNReal.ofReal</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">ENNReal.toReal</span> <span class=\"bp\">∘</span> <span class=\"n\">ENNReal.ofReal</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">comp_eq</span><span class=\"o\">]</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">eq_on</span> <span class=\"o\">:</span> <span class=\"n\">Set.EqOn</span> <span class=\"o\">(</span><span class=\"n\">ENNReal.toReal</span> <span class=\"bp\">∘</span> <span class=\"n\">ENNReal.ofReal</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Function.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">ENNReal.toReal_ofReal_eq_iff</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hf</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">MeasureTheory.set_integral_congr</span> <span class=\"n\">hs</span> <span class=\"n\">eq_on</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Edited because I didn't actually resolve the goals in the original message...</p>",
        "id": 418528131,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1706469612
    },
    {
        "content": "<p>The problem is that <code>set_integral</code> is defined by restricting the measure, not the domain of integration. You can either use <code>set_integral_congr</code> + <code>EqOn</code> as you did, or you can rewrite with <code>MeasureTheory.integral_subtype</code> to get an integral where the integration variable lives in the subtype <code>↑s</code>, so you can rewrite using <code>x.property</code>.</p>",
        "id": 418581288,
        "sender_full_name": "David Loeffler",
        "timestamp": 1706515398
    },
    {
        "content": "<p>Oh that's a nice idea. I had not seen <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.integral_subtype#doc\">docs#MeasureTheory.integral_subtype</a> before</p>",
        "id": 418639642,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1706535927
    }
]