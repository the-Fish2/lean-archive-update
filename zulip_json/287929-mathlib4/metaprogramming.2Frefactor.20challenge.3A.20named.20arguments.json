[
    {
        "content": "<p>Mathlib has tonnes of statements like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">inf_right_comm</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">⊓</span> <span class=\"n\">b</span> <span class=\"bp\">⊓</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">⊓</span> <span class=\"n\">c</span> <span class=\"bp\">⊓</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">sup_right_comm</span> <span class=\"n\">α</span><span class=\"bp\">ᵒᵈ</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p>In Lean 4 we can now write this as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">inf_right_comm</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">⊓</span> <span class=\"n\">b</span> <span class=\"bp\">⊓</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">⊓</span> <span class=\"n\">c</span> <span class=\"bp\">⊓</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n  <span class=\"n\">sup_right_comm</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">α</span><span class=\"bp\">ᵒᵈ</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p>I claim that even in simple cases like this, the resulting proof is more robust.</p>\n<p>In cases like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">LinearIndependent.restrict_of_comp_subtype</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">id</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">hs.linearIndependent_extend</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Continuous</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">selfAdjointPart</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>the result will also be shorter and more readable. I think it is one (mild) form in which we can clean up \"technical debt\".</p>\n<p>I think it should be possible to have a Lean meta-program that refactors mathlib to automatically transform to the new syntax. I also think it will be quite a non-trivial program, and it is certainly not within my current skill set.</p>\n<p>So I'm posing it as a challenge <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 426880595,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1710585228
    },
    {
        "content": "<p>One way in which the new style is <em>less</em> robust is:</p>\n<ul>\n<li>if the arguments get renamed. But I hope that in the near future we will have tools to help with that.</li>\n</ul>\n<p>Ways in which the new style is more robust:</p>\n<ul>\n<li>if the arguments are reordered, then named arguments don't notice</li>\n<li>if the number of arguments changes (hypothesis turns out to be redundant, or some typeclass is changed to a mixin, etc...) then named arguments don't notice.</li>\n</ul>",
        "id": 426880957,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1710585611
    },
    {
        "content": "<p>My understanding is that the challenge is that we can't easily go from source -&gt; syntax -&gt; source while preserving formatting in the rest of the file</p>",
        "id": 426881543,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710586235
    },
    {
        "content": "<p>Not my area of expertise, so I’m making things up as we go, but could this be a custom elaborator that somehow runs before the normal function application elaborator, recognizes the unwanted pattern, then elaborates as usual, but produces a code action to update it with the other form?</p>",
        "id": 426881926,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1710586629
    },
    {
        "content": "<p>But such a code action needs to be executed manually from VScode, or something? Or can that be automated?</p>",
        "id": 426882909,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1710587589
    },
    {
        "content": "<p>I think the missing piece is a function of signature along the lines of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">transformSource</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">Syntax</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">String</span>\n</code></pre></div>\n<p>which outputs the source verbatim, except for where <code>f</code> requests a modification by returning a <code>some</code></p>",
        "id": 426885676,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710590469
    },
    {
        "content": "<p>It's easy to write this today if you're happy to reformat everything</p>",
        "id": 426885760,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710590542
    },
    {
        "content": "<p>I would love to see the output of such a formatter</p>",
        "id": 426886022,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1710590802
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/287929-mathlib4/topic/metaprogramming.2Frefactor.20challenge.3A.20named.20arguments/near/426882909\">said</a>:</p>\n<blockquote>\n<p>But such a code action needs to be executed manually from VScode, or something? Or can that be automated?</p>\n</blockquote>\n<p>Not yet, I fear, but using <code>guard_msg</code> in test suites creates a very strong demand for something like that.</p>",
        "id": 426887056,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1710591782
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/287929-mathlib4/topic/metaprogramming.2Frefactor.20challenge.3A.20named.20arguments/near/426886022\">said</a>:</p>\n<blockquote>\n<p>I would love to see the output of such a formatter</p>\n</blockquote>\n<p>It's the default mathport output style, right?</p>",
        "id": 426907753,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710609726
    },
    {
        "content": "<p>Why is it necessary to reformat everything? The Lean frontend makes it pretty easy to take a <code>String</code> representing an entire file, chunk it into substrings corresponding to individual commands, and obtain the <code>Syntax</code> for each command separately.</p>",
        "id": 426933496,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710630618
    },
    {
        "content": "<p>That still entails reformatting entire theorems, right?</p>",
        "id": 426941084,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710632694
    },
    {
        "content": "<p>Yes.</p>",
        "id": 426959054,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710637715
    },
    {
        "content": "<p>how is that different from reformatting the whole file?</p>",
        "id": 426979948,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710643676
    },
    {
        "content": "<p>an actually targeted edit would only modify the substrings corresponding to applications we actually want to change</p>",
        "id": 426980155,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710643717
    },
    {
        "content": "<p>You only reformat the commands in which you want to make a change. Of course it would be nice if we could do even better, but we can do better than reformatting a whole file.</p>",
        "id": 426999912,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710649275
    },
    {
        "content": "<p>A rather boring problem with this challenge is that not all arguments are named (in particular instance arguments), so it is not always possible to remove the @ notation.</p>",
        "id": 427117355,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1710681663
    }
]