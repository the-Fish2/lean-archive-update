[
    {
        "content": "<p>What would be a good file for the following to go in?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">Complex.indicator_ofReal</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"o\">((</span><span class=\"n\">Set.indicator</span> <span class=\"n\">s</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">Set.indicator</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span>\n</code></pre></div>\n<p><code>#find_home</code> suggests <code>Mathlib.Data.Complex.Abs</code>, <code>Mathlib.Data.Complex.Cardinality</code>, <code>Mathlib.Data.Complex.BigOperators</code>, none of which looks very convincing.</p>",
        "id": 418299906,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706283535
    },
    {
        "content": "<p>And another one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">Complex.one_add_I_mul_ne_one</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">I</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>It could go into <code>Data.Complex.Basic</code>, but it does not feel like a \"basic\" lemma. I found that I need it a couple of times in an application (which should go into Mathliib eventually); so does it make sense to have it as a Mathlin lemma, or is it better a private lemma in the file where it is used?</p>",
        "id": 418301430,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706283986
    },
    {
        "content": "<p>The second one is just <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=add_right_ne_self#doc\">docs#add_right_ne_self</a></p>",
        "id": 418304435,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1706284843
    },
    {
        "content": "<p>(and mul_ne_zero)</p>",
        "id": 418304491,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706284860
    },
    {
        "content": "<p>It's not clear to me that the lemma is any more useful than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi><mo>+</mo><mi>i</mi><mi>y</mi><mo>≠</mo><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">z+iy\\not=z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span></span></p>",
        "id": 418304557,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706284885
    },
    {
        "content": "<p>Indeed, but I think even just <code>add_right_ne_self.mpr &lt;| by positivity</code> likely works (unless positivity doesn't know that <code>I</code> is nonzero, which is possible)</p>",
        "id": 418305002,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1706285032
    },
    {
        "content": "<p>But maybe we should tell it.</p>",
        "id": 418305118,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1706285055
    },
    {
        "content": "<p>But <code>I</code> isn't positive, right?</p>",
        "id": 418305343,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706285131
    },
    {
        "content": "<p>Positivity handles nonzeroness, no?</p>",
        "id": 418305411,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1706285147
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Home.20for.20a.20lemma/near/418305002\">said</a>:</p>\n<blockquote>\n<p>Indeed, but I think even just <code>add_right_ne_self.mpr &lt;| by positivity</code> likely works (unless positivity doesn't know that <code>I</code> is nonzero, which is possible)</p>\n</blockquote>\n<p>I get \"failed to synthesize PartialOrder ℂ\" (and with <code>open scoped ComplexOrder</code>, \"failed to prove positivity/nonnegativity/nonzeroness\"). My proof is a bit longer:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">one_add_I_mul_ne_one</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">I</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"n\">add_right_eq_self</span><span class=\"o\">,</span> <span class=\"n\">mul_eq_zero</span><span class=\"o\">,</span> <span class=\"n\">I_ne_zero</span><span class=\"o\">,</span> <span class=\"n\">ofReal_eq_zero</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">or_self</span><span class=\"o\">,</span>\n    <span class=\"n\">not_false_eq_true</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>which is why I have stated it as a separate lemma.</p>",
        "id": 418310605,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706286736
    },
    {
        "content": "<p>Ah, I forget that the partial order instance on <code>ℂ</code> isn't global, sorry.</p>",
        "id": 418311136,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1706286903
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Home.20for.20a.20lemma/near/418304557\">said</a>:</p>\n<blockquote>\n<p>It's not clear to me that the lemma is any more useful than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi><mo>+</mo><mi>i</mi><mi>y</mi><mo>≠</mo><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">z+iy\\not=z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span></span></p>\n</blockquote>\n<p>In my use case, there is a difference, because specializing the general lemma to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">z = 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> introduces a cast, which then prevents <code>ring</code> from closing whatever goal remains at that stage.</p>",
        "id": 418311613,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706287081
    },
    {
        "content": "<p>... but this can be remedied by a <code>rw [ofReal_one]</code>, which I'm willing to insert if the more general lemma Kevin suggests is deemed to be a useful addition to Mathlib.</p>",
        "id": 418312130,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706287277
    },
    {
        "content": "<p>I just had a second to sit down with this. The following works, probably my suggestion of <code>positivity</code> was not the right one.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Complex.Basic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Complex.one_add_I_mul_ne_one</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">I</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n  <span class=\"n\">add_right_ne_self.mpr</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span>\n</code></pre></div>",
        "id": 418312696,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1706287493
    },
    {
        "content": "<p>long live <code>aesop</code></p>",
        "id": 418312769,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1706287524
    },
    {
        "content": "<p>The <code>asesop</code> proof is pretty much the same as the one I had...</p>",
        "id": 418312848,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706287555
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">add_I_mul_ne_self</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">I</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">≠</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n  <span class=\"n\">mt</span> <span class=\"n\">add_right_eq_self.mp</span> <span class=\"k\">fun</span> <span class=\"n\">H</span> <span class=\"bp\">↦</span> <span class=\"n\">ofReal_ne_zero.mpr</span> <span class=\"n\">hy</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">mul_eq_zero.mp</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">resolve_left</span> <span class=\"n\">I_ne_zero</span>\n</code></pre></div>\n<p>is what you get by translating to a term.</p>",
        "id": 418313452,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706287726
    },
    {
        "content": "<p>okay? but the point is it's easy to write, so then why do we need the specialized lemma?</p>",
        "id": 418313465,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1706287732
    },
    {
        "content": "<p>My use case looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">riemannZeta_isBigO_of_ne_one_horizontal</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">↦</span> <span class=\"n\">ζ</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">I</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"bp\">=</span><span class=\"n\">O</span><span class=\"o\">[</span><span class=\"bp\">𝓝</span><span class=\"o\">[</span><span class=\"bp\">&gt;</span><span class=\"o\">]</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">Asymptotics.IsBigO.mono</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"n\">nhdsWithin_le_nhds</span>\n  <span class=\"n\">convert</span> <span class=\"n\">isBigO_comp_ofReal</span>\n    <span class=\"o\">(</span><span class=\"n\">differentiableAt_riemannZeta</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">add_I_mul_ne_self</span> <span class=\"n\">hy</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">continuousAt.isBigO</span> <span class=\"n\">using</span> <span class=\"mi\">3</span> <span class=\"k\">with</span> <span class=\"n\">x</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ofReal_one</span><span class=\"o\">]</span> <span class=\"c1\">-- not necessary with `one_add_I_mul_ne_one`</span>\n  <span class=\"n\">ring</span>\n</code></pre></div>\n<p>which I find nicer than providing a proof explicitly there (and at the other place where I need it).</p>",
        "id": 418313766,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706287855
    },
    {
        "content": "<p>That's not an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, can you provide the <code>open</code> statements?</p>",
        "id": 418314054,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1706287957
    },
    {
        "content": "<p>I think the rule is basically, if you need something at least twice (and its proof is not very short), then it makes sense as a lemma.</p>",
        "id": 418314068,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706287965
    },
    {
        "content": "<p>I think <code>add_right_ne_self.mpr &lt;| by aesop</code> qualifies as \"very short\". But in any case, I don't want to argue about this. If you really want the lemma, feel free to include it in a PR. I'll let another maintainer disagree if they care to. If not, that's fine too.</p>",
        "id": 418314362,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1706288079
    },
    {
        "content": "<p>It was not meant as an MWE. It is from <a href=\"https://github.com/MichaelStollBayreuth/EulerProducts/blob/main/EulerProducts/PNT.lean\">this file</a> and it needs <code>isBigO_comp_ofReal</code> from the file Auxiliary.lean in the same repo.</p>",
        "id": 418314456,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706288114
    },
    {
        "content": "<p>OK; maybe I should get acquainted with <code>aesop</code> better. Somehow my mental model is that it rarely works and is slow...</p>",
        "id": 418314707,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706288184
    },
    {
        "content": "<p>Also, I'm slightly confused about how you end up with a coercion on the <code>1</code>. Isn't it already of type <code>ℂ</code> in the lemma?</p>",
        "id": 418314850,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1706288236
    },
    {
        "content": "<p>(I have to teach, so need to stop responding now.)</p>",
        "id": 418314884,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1706288249
    },
    {
        "content": "<p>In the more general lemma, <code>x</code> is a real number, so you apply it to a real <code>1</code>.</p>",
        "id": 418315055,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706288303
    },
    {
        "content": "<p>(I have to cook dinner now.)</p>",
        "id": 418315107,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706288319
    },
    {
        "content": "<p><code>positivity</code> can prove <code>≠ 0</code> but it assumes <code>PartialOrder</code> everywhere.</p>",
        "id": 418321094,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706290543
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Home.20for.20a.20lemma/near/418299906\">said</a>:</p>\n<blockquote>\n<p>What would be a good file for the following to go in?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">Complex.indicator_ofReal</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"o\">((</span><span class=\"n\">Set.indicator</span> <span class=\"n\">s</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">Set.indicator</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span>\n</code></pre></div>\n<p><code>#find_home</code> suggests <code>Mathlib.Data.Complex.Abs</code>, <code>Mathlib.Data.Complex.Cardinality</code>, <code>Mathlib.Data.Complex.BigOperators</code>, none of which looks very convincing.</p>\n</blockquote>\n<p>What's your proof? Why do you need <code>Nat</code> here? Is it just <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.indicator_comp_of_zero#doc\">docs#Set.indicator_comp_of_zero</a> ?</p>",
        "id": 418321542,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706290703
    },
    {
        "content": "<p>I think, <code>aesop</code> in this case basically just runs <code>simp</code>, BTW. (In fact, the shortest proof is probably <code>by simp [hy]</code>,<br>\nwhich I'm now using in my code.)</p>",
        "id": 418326340,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706292410
    },
    {
        "content": "<p>perfect</p>",
        "id": 418326432,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1706292441
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Home.20for.20a.20lemma/near/418321542\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Home.20for.20a.20lemma/near/418299906\">said</a>:</p>\n<blockquote>\n<p>What would be a good file for the following to go in?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">Complex.indicator_ofReal</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"o\">((</span><span class=\"n\">Set.indicator</span> <span class=\"n\">s</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">Set.indicator</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span>\n</code></pre></div>\n<p><code>#find_home</code> suggests <code>Mathlib.Data.Complex.Abs</code>, <code>Mathlib.Data.Complex.Cardinality</code>, <code>Mathlib.Data.Complex.BigOperators</code>, none of which looks very convincing.</p>\n</blockquote>\n<p>What's your proof? Why do you need <code>Nat</code> here? Is it just <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.indicator_comp_of_zero#doc\">docs#Set.indicator_comp_of_zero</a> ?</p>\n</blockquote>\n<p>In my use case, it's about <code>Nat</code>. But you are right that it follows easily from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.indicator_comp_of_zero#doc\">docs#Set.indicator_comp_of_zero</a> .<br>\nIt is sometimes hard to guess the level of generality of a result in Mathlib. Here, <code>apply?</code> does not find this lemma (with or without preceding <code>ext</code>), and <code>aesop</code> fails. (My proof is basically <code>ext n; by_cases h : n ∈ s &lt;;&gt; simp [h]</code>.)</p>",
        "id": 418327446,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706292799
    },
    {
        "content": "<p>Another question: Would it make sense to add these?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">Complex.summable_re</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Summable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Summable</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">Complex.hasSum_re</span> <span class=\"n\">h.hasSum</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">summable</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Complex.summable_im</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Summable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Summable</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">Complex.hasSum_im</span> <span class=\"n\">h.hasSum</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">summable</span>\n</code></pre></div>\n<p>The proofs are short, but the statements are sometimes convenient (and there are many similar cases where there are <code>HasSum</code> and <code>Summable</code> versions).</p>",
        "id": 418330334,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706293897
    },
    {
        "content": "<p>One thing I did notice about your statement (aside from the <code>ℕ</code> issue). So in order to understand it, I had to reconfigure it in my head to <code>(↑) ∘ (Set.indicator s f) = Set.indicator s ((↑) ∘ f)</code>, which was a bit cleaner. But I didn't have time to go looking for the lemma.</p>\n<p>This version <code>exact?</code>finds without trouble.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Complex.indicator_ofReal</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">Set.indicator</span> <span class=\"n\">s</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">Set.indicator</span> <span class=\"n\">s</span> <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span><span class=\"bp\">?</span> <span class=\"c1\">-- exact (Set.indicator_comp_of_zero rfl).symm</span>\n</code></pre></div>\n<p>So, in this case, finding the cleanest phrasing was the problem, not so much the level of generality.</p>",
        "id": 418330359,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1706293907
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Home.20for.20a.20lemma/near/418315055\">said</a>:</p>\n<blockquote>\n<p>In the more general lemma, <code>x</code> is a real number, so you apply it to a real <code>1</code>.</p>\n</blockquote>\n<p>In the more general lemma I called the new variable z precisely because I thought it should be a complex number.</p>",
        "id": 418358352,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706307226
    },
    {
        "content": "<p>OK; I guess that would work. (But it's a moot point by now...)</p>",
        "id": 418358471,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706307285
    }
]