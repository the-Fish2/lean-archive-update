[
    {
        "content": "<p>It turns out that it is useful to have an extended version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.dist#doc\">docs#SimpleGraph.dist</a>, so that it returns <code>⊤</code> when the graph is disconnected (see <a href=\"https://github.com/leanprover-community/mathlib4/pull/12058#discussion_r1642553931\">this</a> to see why). However, I'm not sure what's the best way to define it, does this seem reasonable?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Combinatorics</span><span class=\"bp\">.</span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">Metric</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">ENat</span><span class=\"bp\">.</span><span class=\"n\">Lattice</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">edist</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Connected</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Connected</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"bp\">⊤</span>\n</code></pre></div>\n<p>I'm worried about this definition requiring <code>[Decidable G.Connected]</code>. I wonder if there is a way to do this without needing it.</p>",
        "id": 445289778,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1718695950
    },
    {
        "content": "<p>The general pattern between finite and extended stuff is that the extended stuff is defined first, and then the finite stuff is defined in terms of it. So here it would mean defining</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">edist</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⨅</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">edist</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n</code></pre></div>",
        "id": 445291014,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718696409
    },
    {
        "content": "<p>Great!<br>\nIn order to avoid a huge refactor (I'm not sure how many theorems use the old <code>dist</code>), is it possible to do something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">dist_def</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Walk</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"c1\">-- this is the current (to be changed) definition of `dist`</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>And then have lean understand this as a \"second way to define <code>dist</code>\"? Is there an annotation to be applied to the theorem that allows this?</p>",
        "id": 445294918,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1718697378
    },
    {
        "content": "<p>No, you would have to rewrite using that lemma in every theorem that (currently) unfolds the definition. I am pretty sure the new definition will provide a nicer API, though. You should try!</p>",
        "id": 445295421,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718697491
    },
    {
        "content": "<p>I see, I will try this at evening<br>\nDo you have any APIs in mind that I can take inspiration from?</p>",
        "id": 445296821,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1718697895
    },
    {
        "content": "<p>The corresponding one for metric spaces. See <a href=\"https://tqft.net/mathlib4files/Topology/MetricSpace/PseudoMetric\">file#Topology/MetricSpace/PseudoMetric</a></p>",
        "id": 445297427,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718698115
    },
    {
        "content": "<p>The infimum definition is definitely the right thing.</p>",
        "id": 445334945,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1718710240
    },
    {
        "content": "<p>But we are using infrimum in both cases, right?</p>",
        "id": 445339518,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1718711955
    },
    {
        "content": "<p>Yes, but no. One of them is not a proper infimum but a conditional infimum</p>",
        "id": 445400103,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718726599
    },
    {
        "content": "<blockquote>\n<p>In order to avoid a huge refactor</p>\n</blockquote>\n<p>Yaël's suggestion seems right to me. Don't worry about refactoring if you need to.</p>\n<p>Please include the <code>dist_def</code> theorem (perhaps as <code>dist_eq_sInf</code>?) using the old definition. Ideally you wouldn't use it in your refactor, instead it's just nice to have around.</p>",
        "id": 445405638,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718728002
    },
    {
        "content": "<p>I've finally managed to prove <code>dist_eq_sInf</code> when <code>G.dist u v = 0</code>, but something feels wrong, I wanna check whether the proof is supposed to be this annoying, or am I doing something wrong.<br>\nNote that I've proved the helper <code>ENat</code> lemmas in <a href=\"https://github.com/leanprover-community/mathlib4/pull/14043\">mathlib4#14043</a>, and I feel annoyed by the proofs in that PR too. They feel overcomplicated for such simple statements!</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Combinatorics</span><span class=\"bp\">.</span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">Connectivity</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">ENat</span><span class=\"bp\">.</span><span class=\"n\">Lattice</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">ENat</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">lt_one_iff_eq_zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">not_le</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">one_le_iff_ne_zero</span><span class=\"bp\">.</span><span class=\"n\">not</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_not</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">sInf_eq_zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inf_eq_bot_of_bot_mem</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">bot_eq_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sInf_eq_bot</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hn₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hn₂</span><span class=\"bp\">⟩</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">lt_one_iff_eq_zero</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hn₂</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">hn₁</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">ENat</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">edist</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⨅</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edist</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span><span class=\"w\"> </span><span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">dist</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">dist_eq_sInf_of_dist_eq_zero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">sInf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Walk</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">dist</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ENat</span><span class=\"bp\">.</span><span class=\"n\">toNat_eq_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">edist</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">symm</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sInf_eq_zero</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">cases'</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">iInf</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ENat</span><span class=\"bp\">.</span><span class=\"n\">sInf_eq_zero</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"bp\">.</span><span class=\"n\">inl</span>\n<span class=\"w\">    </span><span class=\"n\">simp_all</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">iInf</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sInf_eq_top</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"bp\">.</span><span class=\"n\">inr</span>\n<span class=\"w\">    </span><span class=\"n\">by_contra</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">range_eq_empty_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_isEmpty_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">forall_const</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rename_i</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">      </span><span class=\"n\">aesop</span>\n</code></pre></div>",
        "id": 446473818,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1719176609
    },
    {
        "content": "<p>Surely you should case on whether <code>G.edist u v = ∞</code> (or any equivalent statement)?</p>",
        "id": 446473956,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1719176683
    },
    {
        "content": "<p>If it's <code>∞</code>, then the <code>sInf</code> is zero. If it's finite, then the <code>ENat</code>-valued and <code>Nat</code>-valued <code>sInf</code>s agree.</p>",
        "id": 446474173,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1719176788
    },
    {
        "content": "<p>Also isn't <code>dist_eq_sInf_of_dist_eq_zero </code> a weird statement?</p>",
        "id": 446474177,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1719176793
    },
    {
        "content": "<p>I will try doing that, thanks!</p>",
        "id": 446474196,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1719176816
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Extending.20distance.20of.20graphs/near/446474177\">said</a>:</p>\n<blockquote>\n<p>Also isn't <code>dist_eq_sInf_of_dist_eq_zero </code> a weird statement?</p>\n</blockquote>\n<p>I do not plan to include it in the API, it is just that I found <code>dist_eq_sInf</code>too hard so I decided to start with something simpler.</p>",
        "id": 446474227,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1719176851
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Extending.20distance.20of.20graphs/near/446473956\">said</a>:</p>\n<blockquote>\n<p>Surely you should case on whether <code>G.edist u v = ∞</code> (or any equivalent statement)?</p>\n</blockquote>\n<p>I believe this should be your general strategy when trying to reduce the extended statement to the corresponding finite one</p>",
        "id": 446474230,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1719176857
    },
    {
        "content": "<p>The annoying part in that strategy will always be relating the proper no-junk extended operations to the junkful finite ones. Here, that will be incarnated by goals of the form <code>ENat.toNat (⨅ i, f i) = ⨅ i, ENat.toNat (f i)</code></p>",
        "id": 446474448,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1719177019
    },
    {
        "content": "<p>Yes! In the above lemma, this boils down to proving that <code>G.dist u v = ⨅ w : G.Walk u v, w.length</code>, which is the <code>iInf</code> version of the lemma.</p>",
        "id": 446479540,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1719179643
    },
    {
        "content": "<p>I would like to prove the following statement about <code>edist</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Combinatorics</span><span class=\"bp\">.</span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">Connectivity</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">ENat</span><span class=\"bp\">.</span><span class=\"n\">Lattice</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">edist</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⨅</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Walk</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">edist_eq_top_of_not_reachable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Reachable</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edist</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Here is the idea of the prove:<br>\nSince <code>u</code> and <code>v</code> are not reachable, there is no walks between them, thus  <code>w : G.Walk u v, w.length</code> is <code>∅</code>, which means that its infrimum is top by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=sInf_empty#doc\">docs#sInf_empty</a></p>",
        "id": 448113006,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1719752184
    },
    {
        "content": "<p>I'm having trouble translating this argument to lean, I don't know how to say \"there is no walk between <code>u</code> and <code>v</code> since they are not reachable\", and I don't know how to turn this into \"there is no length of walks between them either\".<br>\nCan you help me please?</p>",
        "id": 448113161,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1719752294
    },
    {
        "content": "<p>Here's an unrefined \"stream-of-conciousness\" proof, where I had a feeling if I did <code>simp</code> after unfolding <code>edist</code> it would be amenable to <code>simp</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">edist_eq_top_of_not_reachable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Reachable</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edist</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">edist</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">iInf_eq_top</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ENat</span><span class=\"bp\">.</span><span class=\"n\">coe_ne_top</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- found via `simp?`</span>\n<span class=\"w\">  </span><span class=\"n\">contrapose!</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">p</span>\n</code></pre></div>",
        "id": 448145649,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1719768539
    },
    {
        "content": "<p>This one is closer to your idea:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">edist_eq_top_of_not_reachable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Reachable</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">edist</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">reachable_iff_nonempty_univ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">nonempty_iff_univ_nonempty</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_nonempty_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">edist</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>A trick here is that <code>simp [edist]</code> can pick up on the resulting <code>IsEmpty (G.Walk u v)</code> hypothesis since it's an instance.</p>",
        "id": 448146220,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1719768672
    },
    {
        "content": "<p>Maybe it's worth having a helper lemma for <code>¬G.Reachable u v ↔ IsEmpty (G.Walk u v)</code>, to replace that <code>rw</code>?</p>",
        "id": 448146601,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1719768765
    },
    {
        "content": "<p>Thank you very much!<br>\n<span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Extending.20distance.20of.20graphs/near/448146601\">said</a>:</p>\n<blockquote>\n<p>Maybe it's worth having a helper lemma for <code>¬G.Reachable u v ↔ IsEmpty (G.Walk u v)</code>, to replace that <code>rw</code>?</p>\n</blockquote>\n<p>I think this is nice to have in the connectivity file, I'll add it.</p>",
        "id": 448231658,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1719813635
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/14315\">#14315</a></p>",
        "id": 448232900,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1719814042
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Extending.20distance.20of.20graphs/near/448146220\">said</a>:</p>\n<blockquote>\n<p>A trick here is that <code>simp [edist]</code> can pick up on the resulting <code>IsEmpty (G.Walk u v)</code> hypothesis since it's an instance.</p>\n</blockquote>\n<p>One more question, how did Lean understand that this is an instance, as opposed to just a normal <code>Prop</code>?</p>",
        "id": 448261936,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1719822701
    },
    {
        "content": "<p>It's because <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsEmpty#doc\">docs#IsEmpty</a> is defined as a <code>class</code></p>",
        "id": 448262181,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1719822759
    }
]