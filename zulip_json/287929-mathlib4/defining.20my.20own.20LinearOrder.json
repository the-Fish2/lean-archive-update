[
    {
        "content": "<p>As part of my project to express introductory topology assignments in Lean, I need to make statements about the properties of various sets under orderings that I define. (Maybe I want to give an unusual ordering to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>, or any ordering to <span class=\"tex-error\">$$\\mathBB{R}^2$$</span> - whatever.)</p>\n<p>I'd like to supply this ordering as a relation, a function from type to type to <code>Prop</code>. And I'd like to be able to work with the existing functionality defined for the <code>LinearOrder</code> class.</p>\n<p>I can't figure out how this is supposed to be done. The most promising thing I see in the documentation is <code>LinearOrder.lift'</code>, but (a) this appears to involve defining your own type that extends <code>LinearOrder</code>, and (b) I was defeated in my attempt to do this by an apparent need to define <code>decidableLE</code> for the new type. I have not found/understood documentation on what it means for something to be a <code>DecidableRel</code> or how to provide one to my <code>LinearOrder</code> instance.</p>\n<p>I think there's just enough information in <em>Mathematics in Lean</em> that I could define a type outside of Mathlib that benefited from the <code>&lt;</code> infix operator, but in that case I'd have to reimplement all the various theorems manipulating inequalities, just for that type.</p>\n<p>Questions:</p>\n<p>(1) What is the expected method of working with a custom ordering on a set?</p>\n<p>(2) If it really is to extend <code>LinearOrder</code> for every ordering, how is that done?</p>",
        "id": 423345588,
        "sender_full_name": "Michael",
        "timestamp": 1708936517
    },
    {
        "content": "<p>Your message seems to be confusing types and their terms several times:</p>\n<ul>\n<li>\"a function from type to type to Prop\" read literally means <code>Type → Type → Prop</code>. This is not what you want. Instead you want <code>CustomType → CustomType → Prop</code>, where you've previously defined <code>CustomType : Type</code>.</li>\n<li>\"this appears to involve defining your own type that extends <code>LinearOrder</code>\". No, it doesn't. Instead it states that if you have an injective map <code>CustomType → ExistingLinearOrder</code> and an instance <code>LinearOrder ExistingLinearOrder</code> then you can build an instance of <code>LinearOrder CustomType</code></li>\n</ul>",
        "id": 423348582,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708937572
    },
    {
        "content": "<p>What you want to do is</p>\n<ul>\n<li>Define <code>CustomType</code>. If you are going to equip an existing type with an unusual ordering, you will need to create a \"type synonym\". There are several ways to do that. The one that requires the less subtleties is to do something like <code>structure CustomType where toReal : ℝ</code> (assuming you want to equip <code>ℝ</code> with an unusual ordering)</li>\n<li>Write the <code>LinearOrder CustomType</code> instance. Start with</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">CustomType</span> <span class=\"n\">where</span>\n  <span class=\"n\">le</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n  <span class=\"n\">le_refl</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n  <span class=\"n\">le_trans</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">hab</span> <span class=\"n\">hbc</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n  <span class=\"n\">le_total</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>and fix the errors</p>",
        "id": 423349285,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708937818
    },
    {
        "content": "<p>... beginning with the Yaël code action that missed an underscore.</p>",
        "id": 423349720,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708937965
    },
    {
        "content": "<blockquote>\n<p>\"this appears to involve defining your own type that extends LinearOrder\". No, it doesn't.</p>\n<p>What you want to do is</p>\n<ul>\n<li>Define <code>CustomType</code>. </li>\n<li>Write the <code>LinearOrder CustomType</code> instance. </li>\n</ul>\n</blockquote>\n<p>How have I avoided defining my own type that extends <code>LinearOrder</code> by (1) defining my own type, and then (2) deriving it from <code>LinearOrder</code>?</p>\n<blockquote>\n<p>\"a function from type to type to Prop\" read literally means Type → Type → Prop. This is not what you want. </p>\n</blockquote>\n<p>I know that's not what I want; that's why <code>Prop</code> was capitalized and \"type\" wasn't, though this time around I forgot to put backquotes on <code>Prop</code>. My first draft of the message got erased.</p>\n<blockquote>\n<p>and fix the errors</p>\n</blockquote>\n<p>I already tried this, and noted the error that stopped me: I don't know how to provide <code>decidableLE</code>. How do I do that? You just told me to do what I already reported I had done, while completely failing to mention the thing that I asked for help with.</p>",
        "id": 423352290,
        "sender_full_name": "Michael",
        "timestamp": 1708938650
    },
    {
        "content": "<p>Ah okay. \"defining my own type that extends <code>LinearOrder</code>\" means</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">CustomType</span> <span class=\"kd\">extends</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">SomeExistingType</span> <span class=\"n\">where</span>\n  <span class=\"n\">one_more_field</span> <span class=\"o\">:</span> <span class=\"n\">SomeSort</span>\n</code></pre></div>",
        "id": 423354244,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708939167
    },
    {
        "content": "<p>\"extending\" means to literally use the <code>extends</code> keyword</p>",
        "id": 423354281,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708939183
    },
    {
        "content": "<p>If you don't know how to fill in <code>decidableEq</code>, you can always use the axiom of choice in the form of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.decRel#doc\">docs#Classical.decRel</a> :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">CustomType</span> <span class=\"n\">where</span>\n  <span class=\"n\">le</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n  <span class=\"n\">le_refl</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n  <span class=\"n\">le_trans</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">hab</span> <span class=\"n\">hbc</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n  <span class=\"n\">le_total</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n  <span class=\"n\">decidableEq</span> <span class=\"o\">:=</span> <span class=\"n\">Classical.decRel</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 423354530,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708939263
    },
    {
        "content": "<p>This is \"cheating\", but sometimes there's no way not to cheat (eg equality on <code>ℝ</code> is not algorithmically decidable)</p>",
        "id": 423354602,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708939296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/defining.20my.20own.20LinearOrder/near/423354530\">said</a>:</p>\n<blockquote>\n<p>If you don't know how to fill in <code>decidableEq</code>, you can always use the axiom of choice in the form of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.decRel#doc\">docs#Classical.decRel</a> :</p>\n</blockquote>\n<p>I suspect that, for a case where I draw on the <code>LinearOrder</code> already associated with an underlying type, I should be able to use that <code>LinearOrder</code>'s decidability fields to provide my own proof of decidability. I assume this would defer whether classical reasoning was required to the <code>LinearOrder</code> on the underlying type.</p>\n<p>Is that right? How can I do that? I've tried defining a function that invokes underlying <code>decidableEq</code> / <code>decidableLE</code> fields, but just joining them together with logical connectives and returning that seems to be an error.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">DictPoint</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n    <span class=\"n\">where</span>\n  <span class=\"n\">mk'</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">point</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">DictPoint</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">lt</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">p₁</span> <span class=\"n\">p₂</span> <span class=\"o\">:</span> <span class=\"n\">DictPoint</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">↦</span>\n    <span class=\"n\">p₁.point.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p₂.point.1</span> <span class=\"bp\">∨</span>\n    <span class=\"n\">p₁.point.1</span> <span class=\"bp\">=</span> <span class=\"n\">p₂.point.1</span> <span class=\"bp\">∧</span> <span class=\"n\">p₁.point.2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p₂.point.2</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">DictPoint</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n    <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"o\">(</span><span class=\"n\">DictPoint</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"c1\">-- [...]</span>\n  <span class=\"n\">decidableLE</span> <span class=\"o\">:=</span> <span class=\"c1\">-- this doesn't work</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span> <span class=\"o\">{</span><span class=\"n\">αₒ</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">βₒ</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"bp\">↦</span>\n      <span class=\"n\">αₒ.decidableLT</span> <span class=\"n\">p₁.point.1</span> <span class=\"n\">p₂.point.1</span> <span class=\"bp\">∨</span>\n      <span class=\"n\">αₒ.decidableEq</span> <span class=\"n\">p₁.point.1</span> <span class=\"n\">p₂.point.1</span> <span class=\"bp\">∧</span> <span class=\"n\">αₒ.decidableLE</span> <span class=\"n\">p₁.point.2</span> <span class=\"n\">p₂.point.2</span>\n</code></pre></div>\n<p>My best guess here is that logical connectives don't work with the <code>Decidable</code> type, but who knows. Is there some documentation somewhere on what the various <code>DecidableX</code> things mean, what they are, and how to work with them?</p>",
        "id": 423750674,
        "sender_full_name": "Michael",
        "timestamp": 1709098843
    },
    {
        "content": "<p>(My hope is that the <code>DictPoint.lt</code> function can be directly associated with the <code>&lt;</code> operator on that compositely-typed <code>LinearOrder</code> once it's successfully defined. I am not sure that's the case right now; if you see an obvious pitfall, please let me know.)</p>",
        "id": 423751036,
        "sender_full_name": "Michael",
        "timestamp": 1709099148
    },
    {
        "content": "<p>The <code>Decidable</code> instance you're missing is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Prod.Lex.decidable#doc\">docs#Prod.Lex.decidable</a></p>",
        "id": 423766458,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709108176
    },
    {
        "content": "<p>that was a little too cryptic for me to understand</p>",
        "id": 423774125,
        "sender_full_name": "Michael",
        "timestamp": 1709111227
    },
    {
        "content": "<p>A <code>Decidable p</code> instance is an <em>algorithm</em> for deciding whether <code>p</code> is true or false. Given algorithms for deciding whether <code>p₁.point.1 &lt; p₂.point.1</code>, <code>p₁.point.1 = p₂.point.1</code>, <code>p₁.point.2 &lt; p₂.point.2</code> are true or false, can you write an algorithm for deciding whether <code>p₁.point.1 &lt; p₂.point.1 ∨ p₁.point.1 = p₂.point.1 ∧ p₁.point.2 &lt; p₂.point.2</code> is true or false?</p>",
        "id": 423774544,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709111363
    },
    {
        "content": "<p>(the answer lies within <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=And.decidable#doc\">docs#And.decidable</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Or.decidable#doc\">docs#Or.decidable</a>, but you might want to try writing the algorithm yourself as an exercise)</p>",
        "id": 423774778,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709111448
    },
    {
        "content": "<p>well, without looking at anything...</p>\n<p>I can write such an algorithm in general, and it would look exactly like that. Ignoring the illegal identifiers, the description of that algorithm in C would be <code>p₁.point.1 &lt; p₂.point.1 || (p₁.point.1 == p₂.point.1 &amp;&amp; p₁.point.2 &lt; p₂.point.2)</code>.</p>\n<p>If I want to do the whole thing in nothing but if-else, a lisp version might look something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Common Lisp\"><pre><span></span><code><span class=\"p\">(</span><span class=\"nb\">defun</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">dle</span><span class=\"w\"> </span><span class=\"nv\">p1</span><span class=\"w\"> </span><span class=\"nv\">p2</span><span class=\"w\"> </span><span class=\"nv\">linear-order-1</span><span class=\"w\"> </span><span class=\"nv\">linear-order-2</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nb\">funcall</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">get-dlt</span><span class=\"w\"> </span><span class=\"nv\">linear-order-1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nb\">car</span><span class=\"w\"> </span><span class=\"nv\">p1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nb\">car</span><span class=\"w\"> </span><span class=\"nv\">p2</span><span class=\"p\">))</span>\n<span class=\"w\">    </span><span class=\"ss\">'t</span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nb\">funcall</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">get-deq</span><span class=\"w\"> </span><span class=\"nv\">linear-order-1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nb\">car</span><span class=\"w\"> </span><span class=\"nv\">p1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nb\">car</span><span class=\"w\"> </span><span class=\"nv\">p2</span><span class=\"p\">))</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nb\">funcall</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">get-dle</span><span class=\"w\"> </span><span class=\"nv\">linear-order-2</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nb\">cadr</span><span class=\"w\"> </span><span class=\"nv\">p1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nb\">cadr</span><span class=\"w\"> </span><span class=\"nv\">p2</span><span class=\"p\">))</span>\n<span class=\"w\">        </span><span class=\"ss\">'t</span>\n<span class=\"w\">        </span><span class=\"no\">nil</span><span class=\"p\">)</span>\n<span class=\"w\">      </span><span class=\"no\">nil</span><span class=\"p\">)))</span>\n</code></pre></div>\n<p>I don't think I can make do with a single decidable comparison function, but a set of two like <code>decidableLT</code> and <code>decidableEq</code> or <code>decidableLE</code> and <code>decidableNot</code> (?) should do the job.</p>\n<p>I'm a little bemused, I guess, by the description of <code>Decidable</code>, which says \"<code>Decidable p</code> is a data-carrying class that supplies a proof that <code>p</code> is either <code>true</code> or <code>false</code>. \" and goes on to note that it is equivalent to <code>Prop</code>. From what I've been able to glean, <code>p</code> itself is already a proof that <code>p</code> is either true or false - though formally it seems to be a proof that <code>p</code> is either <code>True</code> or <code>False</code>, not <code>true</code> or <code>false</code> - so this sounds like a data-carrying class with two fields that are guaranteed to be identical to each other.</p>\n<p>What am I missing?</p>",
        "id": 423779946,
        "sender_full_name": "Michael",
        "timestamp": 1709113320
    },
    {
        "content": "<p>I guess decidable NAND would do the job, but that doesn't seem to be provided by default, and I don't want to deal with NAND anyway.</p>",
        "id": 423780500,
        "sender_full_name": "Michael",
        "timestamp": 1709113496
    },
    {
        "content": "<p>Have you looked at the definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Decidable#doc\">docs#Decidable</a> ?</p>",
        "id": 423780825,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709113594
    },
    {
        "content": "<p>It is an inductive type with two constructors. If you want to write an algorithm, you need to start by pattern-matching on what constructor your <code>Decidable (p₁.point.1 &lt; p₂.point.1)</code> is.</p>",
        "id": 423781023,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709113663
    },
    {
        "content": "<p>Start with this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">decidable_and</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 423781298,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709113755
    },
    {
        "content": "<p>if you're having fun instructing me, or you think this might be edifying for other people, here are the problems I'm encountering:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">decidable_and</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">dp</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dq</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n    <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">dp</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"c1\">-- p has the wrong type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">dq</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isTrue</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I know that's the wrong skeleton, but I started there because it made more sense to me.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">decidable_and</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n    <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">dp</span> <span class=\"n\">dq</span> <span class=\"bp\">↦</span>\n    <span class=\"k\">match</span> <span class=\"n\">dp</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"o\">(</span><span class=\"n\">hₚ</span> <span class=\"o\">:</span> <span class=\"n\">Not</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"o\">(</span><span class=\"n\">Not</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">))</span> <span class=\"c1\">-- argument `¬(p ∧ q)` has type `Prop : Type` but is expected to have type `¬(p ∧ q) : Prop`</span>\n    <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">h₁</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">match</span> <span class=\"n\">dq</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"n\">h₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"bp\">∧</span> <span class=\"n\">h₂</span><span class=\"o\">)</span> <span class=\"c1\">-- similar type error</span>\n      <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">h₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isTrue</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"bp\">∧</span> <span class=\"n\">h₂</span><span class=\"o\">)</span> <span class=\"c1\">-- similar type error</span>\n</code></pre></div>\n<p>One problem seems to be that my variables have type \"a particular Prop\" when they should have type \"the Prop type itself\", I think. And/or the other way around. The other one has to do with <code>Decidable p</code> having the constructors <code>isFalse (Not p)</code> and <code>isTrue p</code>, which I hate. That suggests to me that all Decidable propositions are true, and leaves me unsure of how to correctly deconstruct a <code>Decidable</code>. But that second one is also the kind of thing I hope I could work out on my own.</p>\n<p>If I'm wearing on you, I can go consult the docs for And.decidable and Or.decidable that you mentioned.</p>",
        "id": 423785824,
        "sender_full_name": "Michael",
        "timestamp": 1709115230
    },
    {
        "content": "<p>Changing the result type of my \"intuitive\" approach (the first one) from <code>Decidable p → Decidable q → Decidable (p ∧ q)</code> to <code>Decidable (p ∧ q)</code> struck me as probably wise, but didn't resolve anything.</p>",
        "id": 423786415,
        "sender_full_name": "Michael",
        "timestamp": 1709115409
    },
    {
        "content": "<p>Do you know that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">pat1</span>\n<span class=\"bp\">|</span> <span class=\"n\">pat2</span>\n</code></pre></div>\n<p>is the same as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">|</span> <span class=\"n\">pat1</span>\n<span class=\"bp\">|</span> <span class=\"n\">pat2</span>\n</code></pre></div>",
        "id": 423787776,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709115878
    },
    {
        "content": "<p>I didn't know that and the example leaves me unsure what to do with it now;</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">decidable_and</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"n\">hₚ</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">isFalse</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">hₚ</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"n\">h₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">h₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isTrue</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>produces an error saying there's space in front of the second level of <code>| </code>.</p>\n<p>(The reason the subscripts are p and 2 is that, if I attempt to type <code>\\_q</code>, I get a subscript a followed by an ordinary q. <del>I have no idea what's responsible for that; it isn't my keyboard.</del> This appears to be a matter of which Unicode subscript characters exist and which don't.)</p>",
        "id": 423792826,
        "sender_full_name": "Michael",
        "timestamp": 1709117549
    },
    {
        "content": "<p>That shorthand only works at the very beginning of a definition when used instead of <code>:=</code>.</p>",
        "id": 423827848,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709129937
    },
    {
        "content": "<p>You can go back to using <code>match</code> for the inner cases or you can turn the whole thing into cases at the beginning like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">decidable_and</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"n\">hₚ</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">hₚ</span><span class=\"o\">,</span> <span class=\"n\">isFalse</span> <span class=\"n\">h₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">hₚ</span><span class=\"o\">,</span> <span class=\"n\">isTrue</span> <span class=\"n\">h₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isTrue</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 423828374,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709130098
    },
    {
        "content": "<p>Your problem besides the syntax is that you're providing <em>propositions</em> like <code>p \\and q</code> to <code>isTrue</code> when it expects a <em>proof</em> of that proposition</p>",
        "id": 423828712,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709130202
    },
    {
        "content": "<blockquote>\n<p>From what I've been able to glean, <code>p</code> itself is already a proof that <code>p</code> is either true or false</p>\n</blockquote>\n<p>TPIL puts a lot of emphasis on the idea that the proposition <code>p</code> is, by internal representation, a proof that <code>p</code> is true.</p>\n<p>Why is that not true in this case?</p>",
        "id": 424168856,
        "sender_full_name": "Michael",
        "timestamp": 1709275654
    },
    {
        "content": "<p>Here's something else that doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">decidable_and₂</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">isTrue</span> <span class=\"n\">h₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isTrue</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"bp\">∧</span> <span class=\"n\">h₂</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- [...]</span>\n</code></pre></div>\n<p>Here our first argument has type <code>Decidable p</code>, and we match it against the pattern <code>isTrue h₁</code>. So we have a hypothesis <code>h₁ : Prop</code> that says \"<code>p</code> is true\".</p>\n<p>This hypothesis is useless because it apparently has no logical value. The error Lean emits for this complains that <code>And</code> cannot work with h₁, because it's not a proposition and <code>And</code> can only work with propositions.</p>",
        "id": 424170392,
        "sender_full_name": "Michael",
        "timestamp": 1709276648
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">assumption</span> <span class=\"c1\">-- doesn't work</span>\n  <span class=\"n\">done</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">assumption</span> <span class=\"c1\">-- works fine</span>\n</code></pre></div>\n<p>I assume this is the same difference. What is that difference?</p>",
        "id": 424171244,
        "sender_full_name": "Michael",
        "timestamp": 1709277105
    },
    {
        "content": "<p>(The first of those examples gets pretty-printed as <code>∀ (p : Prop), p</code>, the claim that all propositions are true. I think it should be the claim that all propositions imply themselves; it says that the proposition <code>p</code> implies <code>p</code>.)</p>",
        "id": 424171747,
        "sender_full_name": "Michael",
        "timestamp": 1709277380
    },
    {
        "content": "<p>(However, as far as I recall it is actually the case that all propositions are true - the only values are <code>True</code> and <code>False</code>, and <code>False</code> has no introductions. No?)</p>",
        "id": 424171807,
        "sender_full_name": "Michael",
        "timestamp": 1709277442
    },
    {
        "content": "<p>You are confusing levels. False has no introductions, yet it <em>is</em> a Prop.</p>",
        "id": 424172613,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1709277874
    },
    {
        "content": "<p>But, if a <code>Prop</code> exists, it isn't <code>False</code>.</p>",
        "id": 424173443,
        "sender_full_name": "Michael",
        "timestamp": 1709278196
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">decidable_and₃</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intro</span> <span class=\"n\">hc</span>\n      <span class=\"n\">exact</span> <span class=\"n\">h₁</span> <span class=\"n\">hc.left</span>\n    <span class=\"n\">isFalse</span> <span class=\"n\">hn</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">isFalse</span> <span class=\"n\">h₂</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intro</span> <span class=\"n\">hc</span>\n      <span class=\"n\">exact</span> <span class=\"n\">h₂</span> <span class=\"n\">hc.right</span>\n    <span class=\"n\">isFalse</span> <span class=\"n\">hn</span>\n  <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">isTrue</span> <span class=\"n\">h₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isTrue</span> <span class=\"o\">(</span><span class=\"n\">And.intro</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but my approach to trying this solution was to think \"how would I get the IDE into 'proving mode'?\", which leaves something to be desired.</p>",
        "id": 424173598,
        "sender_full_name": "Michael",
        "timestamp": 1709278260
    },
    {
        "content": "<p>re: only one possible value of any <code>Prop</code>, am I misinterpreting this: <a href=\"#narrow/stream/270676-lean4/topic/Natural.20Number.20Game/near/418428611\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Natural.20Number.20Game/near/418428611</a> ?</p>",
        "id": 424174242,
        "sender_full_name": "Michael",
        "timestamp": 1709278633
    },
    {
        "content": "<p>(and for completeness, a terser version of <code>decidable_and</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">decidable_and₄</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n    <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"n\">h₁</span> <span class=\"n\">c.left</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">isFalse</span> <span class=\"n\">h₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"n\">h₂</span> <span class=\"n\">c.right</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">isTrue</span> <span class=\"n\">h₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isTrue</span> <span class=\"o\">(</span><span class=\"n\">And.intro</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Here the algorithm for deciding whether <code>p ∧ q</code> is true has morphed from \"well, it's true if they're both true, and false otherwise\" to \"well, if either of them is false, that would contradict the premise that <code>p ∧ q</code> is true\".)</p>",
        "id": 424175408,
        "sender_full_name": "Michael",
        "timestamp": 1709279332
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"686884\">Michael</span> <a href=\"#narrow/stream/287929-mathlib4/topic/defining.20my.20own.20LinearOrder/near/424173443\">said</a>:</p>\n<blockquote>\n<p>But, if a <code>Prop</code> exists, it isn't <code>False</code>.</p>\n</blockquote>\n<p>What does that even <em>mean</em>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">False</span> <span class=\"c1\">-- no error!</span>\n</code></pre></div>\n<p>It exists!</p>",
        "id": 424191623,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709285709
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/defining.20my.20own.20LinearOrder/near/424191623\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"686884\">Michael</span> <a href=\"#narrow/stream/287929-mathlib4/topic/defining.20my.20own.20LinearOrder/near/424173443\">said</a>:</p>\n<blockquote>\n<p>But, if a <code>Prop</code> exists, it isn't <code>False</code>.</p>\n</blockquote>\n<p>What does that even <em>mean</em>?</p>\n</blockquote>\n<p>Possibly a good question. Why are <code>AA</code> and <code>ZZ</code> necessarily equal to each other?</p>\n<p>If the only way to create a value of type <code>Prop</code> is by introducing <code>True</code>, then all <code>Prop</code>s must be true.</p>",
        "id": 424192326,
        "sender_full_name": "Michael",
        "timestamp": 1709285974
    },
    {
        "content": "<p>You're mistaking terms and their types. <code>0 = 1</code> and <code>1 = 1</code> are both propositions. Only one of them is true.</p>",
        "id": 424193610,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709286401
    },
    {
        "content": "<p>Given that 2+2=5 is clearly a Prop and it's clearly not true, there has to be something wrong with your thinking</p>",
        "id": 424193688,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709286433
    },
    {
        "content": "<p>When I'm introducing Props to my students I refer to them for a while as \"true/false statements\".</p>",
        "id": 424193797,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709286480
    },
    {
        "content": "<p>Lean implements two axioms, which you might be confusing:</p>\n<ul>\n<li>Propositional extensionality: If two propositions are equivalent, then they are equal: <code>(p ↔ q) → (p = q)</code></li>\n<li>Proof irrelevance: If  <code>h</code> and <code>h'</code> are two proofs of the same proposition, then they are equal: <code>h h' : p</code>, <code>h = h'</code></li>\n</ul>",
        "id": 424193923,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709286517
    },
    {
        "content": "<p>Further, we have the law of excluded middle, which says that every proposition is equivalent to either <code>True</code> or <code>False</code></p>",
        "id": 424193996,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709286557
    },
    {
        "content": "<p>In the world of sets, the analogous situation is: the empty set <em>exists</em> but it doesn't have any elements, so the <em>elements</em> of the empty set don't exist.</p>",
        "id": 424194148,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709286607
    },
    {
        "content": "<p>So the full picture is:</p>\n<ul>\n<li><code>Prop</code> has two terms: <code>True</code> and <code>False</code> (note this is only provable assuming LEM)</li>\n<li><code>False</code> has no term</li>\n<li><code>True</code> has one term</li>\n</ul>",
        "id": 424194154,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709286609
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/defining.20my.20own.20LinearOrder/near/424193923\">said</a>:</p>\n<blockquote>\n<p>Lean implements two axioms, which you might be confusing:</p>\n<ul>\n<li>Propositional extensionality: If two propositions are equivalent, then they are equal: <code>(p ↔ q) → (p = q)</code></li>\n<li>Proof irrelevance: If  <code>h</code> and <code>h'</code> are two proofs of the same proposition, then they are equal: <code>h h' : p</code>, <code>h = h'</code></li>\n</ul>\n</blockquote>\n<p>Am I confusing those two with each other, or one of them with something else?</p>",
        "id": 424194205,
        "sender_full_name": "Michael",
        "timestamp": 1709286634
    },
    {
        "content": "<p>You tell me!</p>",
        "id": 424194238,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709286646
    },
    {
        "content": "<p>Historically people took a long time to recognise 0 as a number for the same reason -- it represents the idea that something doesn't exist, but it itself exists.</p>",
        "id": 424194317,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709286679
    },
    {
        "content": "<p>It seems clear to me that if <code>h</code> and <code>h'</code> are two proofs of the same proposition, then <code>h ↔ h'</code> holds, which would make it difficult to confuse propositional extensionality with proof irrelevance. But that could be an argument that I'm not confusing them with each other, or that I am. So that's about all I can say about it.</p>",
        "id": 424195392,
        "sender_full_name": "Michael",
        "timestamp": 1709286998
    },
    {
        "content": "<p>The followup comment seems likely to be that ↔ is meant for variables of type <code>Prop : Type</code> and proof irrelevance is meant for variables of type <code>[XXX] : Prop</code>.</p>",
        "id": 424195808,
        "sender_full_name": "Michael",
        "timestamp": 1709287168
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/defining.20my.20own.20LinearOrder/near/424193688\">said</a>:</p>\n<blockquote>\n<p>Given that 2+2=5 is clearly a Prop and it's clearly not true, there has to be something wrong with your thinking</p>\n</blockquote>\n<p>For this one, you're exhibiting a way to create <code>Prop</code>s other than by introducing <code>True</code>. It is a good point and it doesn't agree well with what I've been absorbing about Lean from the documentation and other recent questions. It raises my interest in why <code>AA</code> and <code>ZZ</code> are necessarily equal to each other.</p>",
        "id": 424198778,
        "sender_full_name": "Michael",
        "timestamp": 1709288269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"686884\">Michael</span> <a href=\"#narrow/stream/287929-mathlib4/topic/defining.20my.20own.20LinearOrder/near/424195392\">said</a>:</p>\n<blockquote>\n<p>It seems clear to me that if <code>h</code> and <code>h'</code> are two proofs of the same proposition, then <code>h ↔ h'</code> holds, which would make it difficult to confuse propositional extensionality with proof irrelevance.</p>\n</blockquote>\n<p><code>h ↔ h'</code> doesn't make sense because <code>h h' : p</code>, not <code>h h' : Prop</code></p>",
        "id": 424202812,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709289434
    },
    {
        "content": "<p>Hey, I anticipated the followup comment <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> </p>\n<p>Moving back up the Great Tree of Thread Topics, figuring out <code>decidable_and</code> hasn't gotten me very far in implementing <code>decidableLE</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- just for context</span>\n<span class=\"kd\">structure</span> <span class=\"n\">DictPoint</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n    <span class=\"n\">where</span>\n  <span class=\"n\">mk'</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">point</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">DictPoint</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mk</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"bp\">↦</span> <span class=\"n\">DictPoint.mk'</span> <span class=\"o\">(</span><span class=\"n\">Prod.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">lt</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">p₁</span> <span class=\"n\">p₂</span> <span class=\"o\">:</span> <span class=\"n\">DictPoint</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">↦</span>\n    <span class=\"n\">p₁.point.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p₂.point.1</span> <span class=\"bp\">∨</span>\n    <span class=\"n\">p₁.point.1</span> <span class=\"bp\">=</span> <span class=\"n\">p₂.point.1</span> <span class=\"bp\">∧</span> <span class=\"n\">p₁.point.2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p₂.point.2</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">DictPoint</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n    <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"o\">(</span><span class=\"n\">DictPoint</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"c1\">-- [...]</span>\n  <span class=\"n\">decidableLE</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">p₁</span> <span class=\"n\">p₂</span> <span class=\"o\">:</span> <span class=\"n\">DictPoint</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">αₒ</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">βₒ</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"bp\">↦</span>\n      <span class=\"k\">let</span> <span class=\"n\">high₁</span> <span class=\"o\">:=</span> <span class=\"n\">p₁.point.1</span>\n      <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">αₒ.decidableLT</span> <span class=\"n\">p₁.point.1</span> <span class=\"n\">p₂.point.1</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">hhlt</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isTrue</span> <span class=\"gr\">sorry</span>\n      <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"n\">hhge</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- wrong, placeholder</span>\n</code></pre></div>\n<p>This produces a type error on <code>let high₁ := p₁.point.1</code>, which doesn't seem right. There are also type errors on the other <code>X.point.1</code> accesses. And a general problem with working in the definition of <code>decidableLE</code> is that the infoview often shows nothing where I'm hoping for stuff to be present.</p>",
        "id": 424207377,
        "sender_full_name": "Michael",
        "timestamp": 1709290909
    },
    {
        "content": "<p>How can <code>let [name] := [expression]</code> have a type error?</p>",
        "id": 424208142,
        "sender_full_name": "Michael",
        "timestamp": 1709291111
    },
    {
        "content": "<p>Can you make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ? I have errors when I cut and paste your code</p>",
        "id": 424208258,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709291147
    },
    {
        "content": "<p>Just put <code>sorry</code> to make things work, don't create errors</p>",
        "id": 424208443,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709291174
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">DictPoint</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n    <span class=\"n\">where</span>\n  <span class=\"n\">mk'</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">point</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">DictPoint</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mk</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"bp\">↦</span> <span class=\"n\">DictPoint.mk'</span> <span class=\"o\">(</span><span class=\"n\">Prod.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">lt</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">p₁</span> <span class=\"n\">p₂</span> <span class=\"o\">:</span> <span class=\"n\">DictPoint</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">↦</span>\n    <span class=\"n\">p₁.point.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p₂.point.1</span> <span class=\"bp\">∨</span>\n    <span class=\"n\">p₁.point.1</span> <span class=\"bp\">=</span> <span class=\"n\">p₂.point.1</span> <span class=\"bp\">∧</span> <span class=\"n\">p₁.point.2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p₂.point.2</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">DictPoint</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n    <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"o\">(</span><span class=\"n\">DictPoint</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">DictPoint.lt</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">p₁</span> <span class=\"bp\">=</span> <span class=\"n\">p₂</span>\n  <span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">decidableLE</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">p₁</span> <span class=\"n\">p₂</span> <span class=\"o\">:</span> <span class=\"n\">DictPoint</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">αₒ</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">βₒ</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"bp\">↦</span>\n      <span class=\"k\">let</span> <span class=\"n\">high₁</span> <span class=\"o\">:=</span> <span class=\"n\">p₁.point.1</span>\n      <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">αₒ.decidableLT</span> <span class=\"n\">p₁.point.1</span> <span class=\"n\">p₂.point.1</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">hhlt</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isTrue</span> <span class=\"gr\">sorry</span>\n      <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"n\">hhge</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- wrong, placeholder</span>\n</code></pre></div>",
        "id": 424209859,
        "sender_full_name": "Michael",
        "timestamp": 1709291437
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">α</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">β</span>\n<span class=\"n\">p₁p₂</span><span class=\"o\">:</span> <span class=\"n\">DictPoint</span> <span class=\"n\">α</span> <span class=\"n\">β</span>\n<span class=\"n\">αₒ</span><span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">α</span>\n<span class=\"n\">βₒ</span><span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">β</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">?</span><span class=\"n\">m.2528</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span>\n</code></pre></div>\n<p>says \"you have two unrelated linear order structures on alpha\".</p>",
        "id": 424210058,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709291493
    },
    {
        "content": "<p>I'm not convinced that <code>Decidable.isTrue sorry</code> is correct syntax, but I'm having a hard time addressing that because of the other errors.</p>",
        "id": 424210070,
        "sender_full_name": "Michael",
        "timestamp": 1709291496
    },
    {
        "content": "<p>ughh</p>",
        "id": 424210132,
        "sender_full_name": "Michael",
        "timestamp": 1709291513
    },
    {
        "content": "<p>So <code>a &lt; b</code> is ambiguous right now which is not a good sign</p>",
        "id": 424210161,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709291521
    },
    {
        "content": "<p>Really? Don't the two LinearOrders on alpha have to coincide with each other?</p>",
        "id": 424210284,
        "sender_full_name": "Michael",
        "timestamp": 1709291543
    },
    {
        "content": "<p>No, definitely not! Why should they?</p>",
        "id": 424210335,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709291559
    },
    {
        "content": "<p>Well, because they're automatically derived from context? Why are they defined at all?</p>",
        "id": 424210712,
        "sender_full_name": "Michael",
        "timestamp": 1709291662
    },
    {
        "content": "<p>The thing I posted is the exact state of Lean's brain at the point of the first error, and you can just read it, all the assumptions Lean knows are there. It says that alpha and beta are types, and you have two unrelated linear orders on each of them.</p>",
        "id": 424210745,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709291674
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n    <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"o\">(</span><span class=\"n\">DictPoint</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">DictPoint.lt</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">p₁</span> <span class=\"bp\">=</span> <span class=\"n\">p₂</span>\n  <span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">decidableLE</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"n\">le_total</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Now at the <code>decidableLE</code> goal the brain (i.e. the local context) is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">α</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">β</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">DecidableRel</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">x_1</span>\n</code></pre></div>\n<p>which looks much better</p>",
        "id": 424211149,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709291763
    },
    {
        "content": "<p>The reason I have the named LinearOrders in <code>decidableLE</code> is that I want to call their <code>decidableXX</code> functions.</p>\n<p>The reason I haven't lifted that naming out to the declaration that <code>DictPoint</code> instances are also LinearOrder instances is that I don't want to be calling <code>[LinearOrder_name].le</code> instead of using ≤ notation, in the other proofs.</p>",
        "id": 424211333,
        "sender_full_name": "Michael",
        "timestamp": 1709291797
    },
    {
        "content": "<p>1) You didn't name the linear orders, you made new ones<br>\n2) if you want to name linear orders then do it here</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">name1</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">name2</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 424211566,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709291847
    },
    {
        "content": "<p>if I just name the LinearOrders at the top level (<code>instance {α β : Type*} { something: LinearOrder α} {somethingelse : LinearOrder β</code>, they'll still work the same way as the implicit ones?</p>",
        "id": 424211724,
        "sender_full_name": "Michael",
        "timestamp": 1709291881
    },
    {
        "content": "<p>sounds like it</p>",
        "id": 424211777,
        "sender_full_name": "Michael",
        "timestamp": 1709291885
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/defining.20my.20own.20LinearOrder/near/424210745\">said</a>:</p>\n<blockquote>\n<p>The thing I posted is the exact state of Lean's brain at the point of the first error, and you can just read it, all the assumptions Lean knows are there. It says that alpha and beta are types, and you have two unrelated linear orders on each of them.</p>\n</blockquote>\n<p>How did you call that message up? For me the infoview shows various instances of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">synthesized</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">definitionally</span> <span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"n\">expression</span> <span class=\"n\">inferred</span> <span class=\"kd\">by</span> <span class=\"n\">typing</span> <span class=\"n\">rules</span><span class=\"o\">,</span> <span class=\"n\">synthesized</span>\n  <span class=\"n\">αₒ</span>\n<span class=\"n\">inferred</span>\n  <span class=\"n\">inst</span><span class=\"bp\">✝¹</span>\n</code></pre></div>",
        "id": 424211902,
        "sender_full_name": "Michael",
        "timestamp": 1709291928
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/defining.20my.20own.20LinearOrder/near/424211566\">said</a>:</p>\n<blockquote>\n<p>1) You didn't name the linear orders, you made new ones<br>\n2) if you want to name linear orders then do it here</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">name1</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">name2</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>wait, followup question: your named LinearOrders are still notated in <code>[]</code> square brackets. My understanding was that the meaning of the <code>[]</code> is that you don't provide a name for the value, which is why in my code I have <code>{}</code>.</p>",
        "id": 424212219,
        "sender_full_name": "Michael",
        "timestamp": 1709292015
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/tV1aBdd_B02cL2RYwEMLZBom/Screenshot-from-2024-03-01-11-19-55.png\">Screenshot-from-2024-03-01-11-19-55.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/tV1aBdd_B02cL2RYwEMLZBom/Screenshot-from-2024-03-01-11-19-55.png\" title=\"Screenshot-from-2024-03-01-11-19-55.png\"><img src=\"/user_uploads/3121/tV1aBdd_B02cL2RYwEMLZBom/Screenshot-from-2024-03-01-11-19-55.png\"></a></div><p>My cursor is at the beginning of the first error (just before the <code>p</code>).</p>",
        "id": 424212233,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709292018
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">decidableLE</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span> <span class=\"bp\">↦</span>\n      <span class=\"k\">let</span> <span class=\"n\">high₁</span> <span class=\"o\">:=</span> <span class=\"n\">p₁.point.1</span>\n      <span class=\"k\">let</span> <span class=\"n\">high₂</span> <span class=\"o\">:=</span> <span class=\"n\">p₂.point.1</span>\n      <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">αₒ.decidableLT</span> <span class=\"n\">high₁</span> <span class=\"n\">high₂</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">hhlt</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">have</span> <span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">this.le</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"c1\">-- error, there is no le</span>\n          <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hhlt</span>\n      <span class=\"gr\">sorry</span>\n      <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"n\">hhge</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- wrong, placeholder</span>\n</code></pre></div>\n<p>Here, <code>this.le</code> doesn't refer to anything. Also invalid are <code>le p₁ p₂</code> and <code>p₁ ≤ p₂</code>. I was able to use expressions of the form <code>p₁ ≤ p₂</code> in the definition of <code>le_trans</code>, and they use the definition of <code>le</code> provided above them. What's different in <code>decidableLE</code>?</p>",
        "id": 424215314,
        "sender_full_name": "Michael",
        "timestamp": 1709292997
    },
    {
        "content": "<p>What is <code>αₒ</code>? Can you post all the code that you changed since the last time you posted a MWE?</p>",
        "id": 424216193,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709293299
    },
    {
        "content": "<p>It's the linear order on alpha; other than naming the linear orders at the top level, that is all the code I've changed. But here's the mwe form again, with a line in <code>le_trans</code> to show correct synthesis of the ability to use the notation there:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">DictPoint</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n    <span class=\"n\">where</span>\n  <span class=\"n\">mk'</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">point</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">DictPoint</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mk</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"bp\">↦</span> <span class=\"n\">DictPoint.mk'</span> <span class=\"o\">(</span><span class=\"n\">Prod.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">lt</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">p₁</span> <span class=\"n\">p₂</span> <span class=\"o\">:</span> <span class=\"n\">DictPoint</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">↦</span>\n    <span class=\"n\">p₁.point.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p₂.point.1</span> <span class=\"bp\">∨</span>\n    <span class=\"n\">p₁.point.1</span> <span class=\"bp\">=</span> <span class=\"n\">p₂.point.1</span> <span class=\"bp\">∧</span> <span class=\"n\">p₁.point.2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p₂.point.2</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">DictPoint</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">αₒ</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">βₒ</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n    <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"o\">(</span><span class=\"n\">DictPoint</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">DictPoint.lt</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">p₁</span> <span class=\"bp\">=</span> <span class=\"n\">p₂</span>\n  <span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">le_total</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">decidableLE</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span> <span class=\"bp\">↦</span>\n      <span class=\"k\">let</span> <span class=\"n\">high₁</span> <span class=\"o\">:=</span> <span class=\"n\">p₁.point.1</span>\n      <span class=\"k\">let</span> <span class=\"n\">high₂</span> <span class=\"o\">:=</span> <span class=\"n\">p₂.point.1</span>\n      <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">αₒ.decidableLT</span> <span class=\"n\">high₁</span> <span class=\"n\">high₂</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">hhlt</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">have</span> <span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">p₁</span> <span class=\"bp\">≤</span> <span class=\"n\">p₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n          <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hhlt</span>\n      <span class=\"gr\">sorry</span>\n      <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"n\">hhge</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- wrong, placeholder</span>\n</code></pre></div>",
        "id": 424216705,
        "sender_full_name": "Michael",
        "timestamp": 1709293527
    },
    {
        "content": "<p>I haven't thought at all about how your proof goes, but would you  need to define the <code>LE</code> and <code>LT</code> instances for your <code>DictPoint</code>? Here is an example that at least compiles without error:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">DictPoint</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n    <span class=\"n\">where</span>\n  <span class=\"n\">mk'</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">point</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">DictPoint</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mk</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"bp\">↦</span> <span class=\"n\">DictPoint.mk'</span> <span class=\"o\">(</span><span class=\"n\">Prod.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">lt</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">p₁</span> <span class=\"n\">p₂</span> <span class=\"o\">:</span> <span class=\"n\">DictPoint</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">↦</span>\n    <span class=\"n\">p₁.point.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p₂.point.1</span> <span class=\"bp\">∨</span>\n    <span class=\"n\">p₁.point.1</span> <span class=\"bp\">=</span> <span class=\"n\">p₂.point.1</span> <span class=\"bp\">∧</span> <span class=\"n\">p₁.point.2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p₂.point.2</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">LT</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">DictPoint</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">where</span>\n  <span class=\"n\">lt</span> <span class=\"o\">:=</span> <span class=\"n\">lt</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">le</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">DictPoint</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p</span> <span class=\"bp\">&lt;</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span>\n\n<span class=\"c1\">-- Add LE instance</span>\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">LE</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">DictPoint</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">where</span>\n  <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p</span> <span class=\"bp\">&lt;</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">DictPoint</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">α₀</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"o\">(</span><span class=\"n\">DictPoint</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">le_total</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">decidableLE</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"k\">show</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"k\">from</span>\n    <span class=\"k\">match</span> <span class=\"n\">α₀.decidableLT</span> <span class=\"n\">a.point.1</span> <span class=\"n\">b.point.1</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a.point.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b.point.1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n    <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">a.point.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b.point.1</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n</div></div>",
        "id": 424217322,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1709293728
    },
    {
        "content": "<p>I have been worrying about defining LE and LT on <code>DictPoint</code>. It appears to me that, within the body of the <code>instance</code> declaration, LE is defined and LT isn't, which I find weird.</p>\n<p>In this particular instance, LE seems to be defined while I'm defining <code>le_trans</code>, but not while I'm defining <code>decidableLE</code>, which I find <em>much weirder</em>.</p>",
        "id": 424217734,
        "sender_full_name": "Michael",
        "timestamp": 1709293849
    },
    {
        "content": "<p>My understanding was that the LinearOrder on a DictPoint type defines the LE and LT notation for the type...?</p>",
        "id": 424217916,
        "sender_full_name": "Michael",
        "timestamp": 1709293906
    },
    {
        "content": "<p>But not in time for you to use them. This is why Jon's approach is better</p>",
        "id": 424218191,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709293982
    },
    {
        "content": "<blockquote>\n<p>But not in time for you to use them.</p>\n</blockquote>\n<p>How come one of them is usable in my <code>le_trans</code>?</p>",
        "id": 424218358,
        "sender_full_name": "Michael",
        "timestamp": 1709294034
    },
    {
        "content": "<p>Also, I tend to object to the fact that saying \"when alpha and beta have LinearOrders, there is a LinearOrder on the DictPoint type as follows: to decide whether p_1 &lt; p_2, find the LinearOrders on alpha and beta, and then...\" creates an error complaining that the implicit LinearOrder on alpha when I'm defining the LinearOrder on a DictPoint might be different from the implicit LinearOrder on alpha when I'm defining the implementation of that LinearOrder's <code>decidableLE</code> method...</p>\n<p>...but then defining an independent LE.le for the type I'm about to define a LinearOrder on is not just not a conflict with the LE.le provided by the LinearOrder, it's <strong>required</strong>.</p>",
        "id": 424221029,
        "sender_full_name": "Michael",
        "timestamp": 1709294750
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/defining.20my.20own.20LinearOrder/near/424218191\">said</a>:</p>\n<blockquote>\n<p>But not in time for you to use them. This is why Jon's approach is better</p>\n</blockquote>\n<p>I'm actually not sure what you mean here, Kevin</p>",
        "id": 424225287,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709296401
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">PartialOrder</span> <span class=\"n\">X</span> <span class=\"n\">where</span>\n  <span class=\"n\">le</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">True</span>\n  <span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">a</span>\n    <span class=\"k\">have</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- failed to synthesize instance LE X</span>\n  <span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 424233989,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709299214
    },
    {
        "content": "<p>But making the LE instance first avoids this.</p>",
        "id": 424234069,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709299240
    },
    {
        "content": "<p>The <code>le_refl</code> example bothered me, because by my standard LE is also available there!</p>\n<p>Turns out, LE in the <strong>goal</strong> is fine, and it uses the relation defined by the LinearOrder. (Note that the goal when providing a proof of <code>le_refl</code> is <code>a ≤ a</code>, and it simplifies just fine.) But using LE outside the goal, during your proof, is wrong and meaningless.</p>\n<p>Why the difference?</p>",
        "id": 424276756,
        "sender_full_name": "Michael",
        "timestamp": 1709309191
    },
    {
        "content": "<p>It's also possible to introduce a proof that <code>a ≤ b</code> from a protasis in the goal (<code>le_trans</code> defines a goal of this type), and that is given the expected meaning, even though it's no longer in the goal. But you can't define your own propositions that way?</p>",
        "id": 424277441,
        "sender_full_name": "Michael",
        "timestamp": 1709309362
    },
    {
        "content": "<p>This might be slightly inaccurate, but there are two different things happening regarding the <code>≤</code> symbol.</p>\n<p>1) In the infoview, you have a term like <code>@LE.le X (@LE.mk X fun (x y : X) =&gt; True) a a</code> which gets \"delaborated\" (aka. displayed)  as <code>a ≤ a</code>. (you can see this by setting <code>set_option pp.all true</code> above your proof).</p>\n<p>2) When you want to write <code>≤</code> yourself in code, this needs to be parsed, and that happens by using this macro from core:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>  <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">binrel</span><span class=\"bp\">%</span> <span class=\"n\">LE.le</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Lean needs to find an instance of <code>LE X</code> to do so. But instance inference cannot find this adhoc  instance <code>(@LE.mk X fun (x y : X) =&gt; True)</code>, which is created through the <code>le</code> field (and some others) in your structure. I guess because that one is never added (or rather, not added yet), but that's where I'm not super sure... </p>\n<p>You can still do what Kevin does, just without using the notation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">PartialOrder</span> <span class=\"n\">X</span> <span class=\"n\">where</span>\n  <span class=\"n\">le</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">True</span>\n  <span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">a</span>\n    <span class=\"k\">have</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">LE.mk</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">le</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">dsimp</span>\n    <span class=\"c1\">-- in the infoview you see: `foo : a ≤ a`</span>\n    <span class=\"n\">exact</span> <span class=\"n\">foo</span>\n  <span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 424297736,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1709315289
    },
    {
        "content": "<p>Somewhat unrelated to linear orders, but hijacking the initial discussion on Prop-s:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/defining.20my.20own.20LinearOrder/near/424194154\">said</a>:</p>\n<blockquote>\n<p>So the full picture is:</p>\n<ul>\n<li><code>Prop</code> has two terms: <code>True</code> and <code>False</code> (note this is only provable assuming LEM)</li>\n<li><code>False</code> has no term</li>\n<li><code>True</code> has one term</li>\n</ul>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"686884\">@Michael</span>, try making sense of this if you want to have some fun: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">True</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">False</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">npt</span><span class=\"o\">,</span> <span class=\"n\">npf</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span> <span class=\"n\">npf</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">↦</span> <span class=\"n\">f.elim</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">↦</span> <span class=\"n\">npt</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">trivial</span><span class=\"o\">⟩⟩</span>\n</code></pre></div>\n<p>Or even worse if you like propositional extensionality:  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span> <span class=\"n\">True</span> <span class=\"bp\">≠</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">False</span> <span class=\"bp\">≠</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">_</span> <span class=\"o\">,</span> <span class=\"n\">npt</span><span class=\"o\">,</span> <span class=\"n\">npf</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span> <span class=\"n\">npf</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">propext</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">↦</span> <span class=\"n\">f.elim</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">↦</span> <span class=\"n\">npt</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">propext</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">trivial</span><span class=\"o\">⟩⟩</span>\n</code></pre></div>\n<p>note that LEM was not used anywhere at all (as you can see from the lack of imports)</p>",
        "id": 424336336,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1709332482
    },
    {
        "content": "<blockquote>\n<p>LEM was not used anywhere at all (as you can see from the lack of imports)</p>\n</blockquote>\n<p>You don't need an import to use classical logic, <code>Classical.em</code> is defined in the <code>Init</code> package which is available by default</p>",
        "id": 424362837,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709353355
    },
    {
        "content": "<p>you don't even need to use <code>Classical</code> in your code directly; things like <code>by_contra</code>, <code>by_cases</code> and <code>split</code> will automatically use classical logic, and are available without imports</p>",
        "id": 424362875,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709353410
    },
    {
        "content": "<p>Ahhh, I should have remebered the discussion about LEM in <code>split</code> and deduced the rest, thank you for the clarification. Having said that, <span class=\"user-mention\" data-user-id=\"686884\">@Michael</span> you can still verify I’m not lying with <code>#print axioms</code> (assuming <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> won’t come out and show that even that can be bypassed in some way…)</p>",
        "id": 424408042,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1709383012
    },
    {
        "content": "<p>(it can, but the code that does generally looks decidedly adversarial / malicious. You won't run into it using lean/mathlib normally.)</p>",
        "id": 424408318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709383281
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"k\">in</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"#print axioms \"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"'{n}' does not depend on any axioms... jk lol\"</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">totally_intuitionistic</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">Classical.em</span> <span class=\"n\">p</span>\n\n<span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">totally_intuitionistic</span>\n<span class=\"c1\">-- 'totally_intuitionistic' does not depend on any axioms... jk lol</span>\n</code></pre></div>",
        "id": 424408547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709383471
    },
    {
        "content": "<p>See also <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general/topic/PSA.20about.20trusting.20Lean.20proofs\">#general &gt; PSA about trusting Lean proofs</a></p>",
        "id": 424408744,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709383711
    }
]