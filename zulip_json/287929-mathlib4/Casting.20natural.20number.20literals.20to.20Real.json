[
    {
        "content": "<p>This maybe a bit of a basic question, but I am working with Mathlib.RingTheory.PowerSeries and want to multiply a power series with Real coefficients. In the minimal example below, I would like <code>2•A</code> to be 2 to be <code>@OfNat.ofNat ℝ 2</code> instead of <code>@OfNat.ofNat ℕ 2</code>. I can force this by typing <code>(2:ℝ)</code> instead, but it is somewhat tedious. Is there a better way to ensure my natural numbers are of type <code>ℝ</code> when I am smul-ing them with a power series of type <code>ℝ⟦X⟧</code>?</p>\n<p>Minimal example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span> <span class=\"n\">PowerSeries</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">⟦</span><span class=\"n\">X</span><span class=\"bp\">⟧</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- 2 is of type ℕ</span>\n<span class=\"k\">#check</span> <span class=\"mi\">2</span><span class=\"bp\">•</span><span class=\"n\">A</span>\n\n<span class=\"c1\">-- 2 is of type ℝ</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">•</span><span class=\"n\">A</span>\n</code></pre></div>",
        "id": 436560044,
        "sender_full_name": "Herman Chau",
        "timestamp": 1714591932
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4/topic/Casting.20natural.20number.20literals.20to.20Real\">#lean4 &gt; Casting natural number literals to Real</a> by <span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span>.</p>",
        "id": 436560646,
        "sender_full_name": "Notification Bot",
        "timestamp": 1714592203
    },
    {
        "content": "<p>Why do you care what type 2 is in this case? Does <code>2•A</code> behave differently from <code>(2:ℝ)•A</code>?</p>",
        "id": 436560727,
        "sender_full_name": "Vasily Ilin",
        "timestamp": 1714592240
    },
    {
        "content": "<p>Yes, for example I get confusing messages in the Lean Infoview about being unable to unify two seemingly identical terms. Consider the following example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">•</span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"o\">((</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">•</span><span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">PowerSeries.inv_mul_cancel</span> <span class=\"o\">((</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">•</span><span class=\"n\">A</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>This leads to the message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">tactic</span> <span class=\"bp\">'</span><span class=\"n\">apply'</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">unify</span>\n  <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">•</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">•</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n<span class=\"k\">with</span>\n  <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">•</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">•</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>Only by hovering on the literal \"2\" in the message do we see that the issue is due to the type of 2 being <code>ℕ</code> in one case and <code>ℝ</code> in the other.</p>",
        "id": 436561970,
        "sender_full_name": "Herman Chau",
        "timestamp": 1714592767
    },
    {
        "content": "<p>I'm afraid an unadorned 2 means the natural 2. Note that you could also use <code>C 2</code>, which is the constant power series, and then just multiply.</p>",
        "id": 436576979,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1714599417
    },
    {
        "content": "<p>The problem in your example arises from using a mixture of the two different <code>2</code>s. Is there a reason you can't use the unadorned one everywhere?</p>",
        "id": 436580332,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714601285
    },
    {
        "content": "<p>Debugging tip:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span> <span class=\"n\">PowerSeries</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">⟦</span><span class=\"n\">X</span><span class=\"bp\">⟧</span><span class=\"o\">)</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.numericTypes</span> <span class=\"n\">true</span>\n\n<span class=\"k\">#check</span> <span class=\"mi\">2</span><span class=\"bp\">•</span><span class=\"n\">A</span>\n<span class=\"c\">/-</span><span class=\"cm\"> (2 : ℕ) • A : ℝ⟦X⟧ -/</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">•</span><span class=\"n\">A</span>\n<span class=\"c\">/-</span><span class=\"cm\"> (2 : ℝ) • A : ℝ⟦X⟧ -/</span>\n</code></pre></div>",
        "id": 436584219,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714603323
    },
    {
        "content": "<p>Unfortunately this can't be done locally (<code>@[default_instance]</code> doesn't allow it) but here's a way to get smul to default to Real if there's an applicable instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">default_instance</span><span class=\"kd\">]</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">instSMulRealDefault</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">SMul</span> <span class=\"n\">ℝ</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">SMul</span> <span class=\"n\">ℝ</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n\n<span class=\"k\">#check</span> <span class=\"mi\">2</span> <span class=\"bp\">•</span> <span class=\"n\">A</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">(2 : ℝ) • A : ℝ⟦X⟧</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 436586428,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714604533
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Thanks, I'm pretty happy with using that workaround!</p>\n<p>The reason why this arose for me is that I want to prove some a result on generating functions with real coefficients so I'd like for everything to be of type <code>ℝ⟦X⟧</code>. Specifically, I have the lemma</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">geometric_series</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">-</span><span class=\"n\">r</span><span class=\"bp\">•</span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">rescale</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">invUnitsSub</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>and I'd like to use it in the case of <code>1-2•X</code> but I need to cast 2 to be of type <code>ℝ</code>.</p>",
        "id": 436614693,
        "sender_full_name": "Herman Chau",
        "timestamp": 1714624084
    },
    {
        "content": "<p>So long as you're not contributing this to mathlib, it's fine. Note that it causes everything that imports the module to start having the same behavior.</p>",
        "id": 436616535,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714625691
    },
    {
        "content": "<p>Maybe you'd like a macro instead?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">PowerSeries</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">⟦</span><span class=\"n\">X</span><span class=\"bp\">⟧</span><span class=\"o\">)</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"ℝ'2\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">((</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">ℝ'2</span> <span class=\"bp\">•</span> <span class=\"n\">A</span>\n</code></pre></div>",
        "id": 436616569,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714625716
    },
    {
        "content": "<p>Are you using <code>1 - (2:ℝ)•X</code> enough that it's a burden to write it?</p>",
        "id": 436616738,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714625837
    },
    {
        "content": "<p>Maybe it'll help give more context if I share the entire lean file I'm working on. In the lemma <code>A_formula</code> I have <code>2 • A</code> in many lines. <br>\n<a href=\"/user_uploads/3121/WV-m45fUz2PmH4Vm_0Y33iKc/generating_function_example.lean\">generating_function_example.lean</a></p>\n<p>I'm trying to formalize some examples from the first chapter of generatingfunctionology by Herbert Wilf. Here, we start off with a sequence <code>a_n</code> that satisfies <code>a_{n+1} = 2*a_n + 1</code> and <code>a_0 = 0</code>. The goal is to show that the corresponding generating function <code>A(x)</code> is equal to <code>x / ((1-x) * (1-2x))</code>. I'm fairly new to lean so I suspect there are a lot of inefficiencies in my code. I'm interested in trying to faithfully translate the lines of reasoning in the first example.</p>\n<p>In the process of trying to formalize this example, I think I could perhaps contribute a couple lemmas regarding geometric series to mathlib. The power series for <code>1/(u-x)</code> is in Mathlib.RingTheory.PowerSeries.WellKnown and is defined via its coefficients, but unless I'm mistaken, there is no theorem in mathlib that states that this power series really is the inverse of <code>u-x</code>.</p>",
        "id": 436618063,
        "sender_full_name": "Herman Chau",
        "timestamp": 1714626928
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"665964\">Herman Chau</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Casting.20natural.20number.20literals.20to.20Real/near/436618063\">said</a>:</p>\n<blockquote>\n<p>The power series for <code>1/(u-x)</code> is in Mathlib.RingTheory.PowerSeries.WellKnown and is defined via its coefficients, but unless I'm mistaken, there is no theorem in mathlib that states that this power series really is the inverse of <code>u-x</code>.</p>\n</blockquote>\n<p>I think this is <code>invUnitsSub_mul_sub</code>.</p>",
        "id": 444250399,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1718202457
    }
]