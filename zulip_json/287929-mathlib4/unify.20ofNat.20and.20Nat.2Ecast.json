[
    {
        "content": "<p>With the addition of the <code>OfNat</code> typeclass for nat literals in Lean 4, we now have two names for the embedding of the natural numbers into a semiring: <code>OfNat.ofNat</code> and <code>Nat.cast</code>.  The former is used by numerals, e.g. <code>(5 : R)</code> is notation for <code>OfNat.ofNat 5</code>. The latter is used for coercions, e.g. <code>(↑n : R)</code> for some variable <code>n</code> is notation for <code>Nat.cast n</code>. These two functions are defeq, but they are not reducibly defeq, which means we need to duplicate lemmas for each of them. (See <a href=\"https://github.com/leanprover-community/mathlib4/pull/8006\">#8006</a> for an example of how many lemmas we need to add.) I have a proof of concept which would unify the two by making <code>Nat.cast</code> an <code>abbrev</code> for <code>OfNat.ofNat</code>. Would this change be a good idea? (Note that this should probably wait until after <a href=\"https://github.com/leanprover/lean4/pull/2867\">lean4#2867</a> is fixed.)</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Proof of concept</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\">! Proof of concept for unifying coercions from ℕ and nat literals. -/</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"c1\">-- Redefine `NatCast` from Std in terms of `OfNat`</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">NatCast</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">OfNat</span> <span class=\"n\">R</span> <span class=\"n\">n</span>\n\n<span class=\"c1\">-- `Nat.cast n` and `OfNat.ofNat n` will now be reducibly defeq so we don't have to duplicate theorems about them</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">Nat.cast</span> <span class=\"o\">[</span><span class=\"n\">NatCast</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">NatCast</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">Nat</span> <span class=\"n\">R</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.cast</span> <span class=\"n\">n</span>\n\n<span class=\"c1\">-- This works as intended!</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">NatCast</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">with_reducible</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">NatCast</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">with_reducible</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">NatCast</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">with_reducible</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">NatCast</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">with_reducible</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- `Zero` and `One` from mathlib can remain unchanged</span>\n<span class=\"kd\">class</span> <span class=\"n\">Zero</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">R</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">One</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">R</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">Zero.instOfNat</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">R</span> <span class=\"mi\">0</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"n\">Zero.zero</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">One.instOfNat</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">R</span> <span class=\"mi\">1</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"n\">One.one</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">OfNat</span> <span class=\"n\">R</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Zero</span> <span class=\"n\">R</span> <span class=\"n\">where</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">OfNat</span> <span class=\"n\">R</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">One</span> <span class=\"n\">R</span> <span class=\"n\">where</span>\n  <span class=\"n\">one</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n\n<span class=\"c1\">-- The only change needed to `AddMonoidWithOne` is removing `extends NatCast`</span>\n<span class=\"kd\">class</span> <span class=\"n\">AddMonoidWithOne</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Add</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">Zero</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">One</span> <span class=\"n\">R</span> <span class=\"n\">where</span>\n  <span class=\"n\">add_zero</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n  <span class=\"n\">zero_add</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n  <span class=\"n\">add_assoc</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n  <span class=\"n\">natCast</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">R</span>\n  <span class=\"n\">natCast_zero</span> <span class=\"o\">:</span> <span class=\"n\">natCast</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">natCast_succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">natCast</span> <span class=\"n\">n.succ</span> <span class=\"bp\">=</span> <span class=\"n\">natCast</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"c1\">-- We need to avoid non-defeq diamonds with `Zero.instOfNat` and `One.instOfNat`,</span>\n<span class=\"c1\">-- so we use them directly and effectively ignore the provided `natCast` at inputs `0` and `1`.</span>\n<span class=\"kd\">instance</span> <span class=\"n\">AddMonoidWithOne.instOfNat</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AddMonoidWithOne</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">OfNat</span> <span class=\"n\">R</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Zero.instOfNat</span> <span class=\"n\">R</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">One.instOfNat</span> <span class=\"n\">R</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">natCast</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)⟩</span>\n\n<span class=\"c1\">-- What defeqs does does nat coercion into `AddMonoidWithOne` have?</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">AddMonoidWithOne</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Zero.zero</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">AddMonoidWithOne</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">One.one</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">AddMonoidWithOne</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">AddMonoidWithOne.natCast</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- fails..</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">AddMonoidWithOne</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">AddMonoidWithOne.natCast</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- fails..</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">AddMonoidWithOne</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">AddMonoidWithOne.natCast</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- fails..</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">AddMonoidWithOne</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">AddMonoidWithOne.natCast</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- succeeds!</span>\n</code></pre></div>\n</div></div>",
        "id": 424762128,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709592608
    },
    {
        "content": "<p>I think this is a bad idea because <code>OfNat.ofNat</code> is, as I understand it, only ever allowed to contain raw literals</p>",
        "id": 424763105,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709593134
    },
    {
        "content": "<p>\"allowed\" in what sense? We already write lemmas about <code>OfNat.ofNat</code> applied to variables</p>",
        "id": 424764322,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709593774
    },
    {
        "content": "<p>Yes, you should not think of <code>OfNat.ofNat</code> as \"the embedding of natural numbers into a semiring\". Instead, it is a supporting structure for elaborating numerals.</p>\n<p>There are two different concerns here (elaborating numerals, and coercing into semirings), which have a confusing overlap, but are best kept separate.</p>",
        "id": 424766244,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1709594944
    },
    {
        "content": "<p>It's not clear to me that these concerns ought to be separate. While semirings are where this shows up in mathlib, this will be a problem for any type which supports coercions from <code>Nat</code>. I imagine any type (semiring or not) that would want a <code>Coe Nat MyType</code> instance would also want <code>OfNat MyType n</code> for all <code>n</code>.</p>",
        "id": 424767301,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709595512
    },
    {
        "content": "<p>\"allowed\" in the sense that users of this typeclass are allowed to assume this invariant in order to process numerals</p>",
        "id": 424767416,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709595559
    },
    {
        "content": "<p>Of course this could change, but this is a decision to be made in core, not something that can be safely changed in mathlib</p>",
        "id": 424767536,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709595617
    },
    {
        "content": "<p>It's hard for me to imagine the use case for this invariant. Are you saying existing meta code detects numerals by matching on <code>@OfNat.ofNat _ x _</code> and then errors if <code>x</code> is not <code>nat_lit n</code>? It seems simpler to pattern match on <code>@OfNat.ofNat _ (nat_lit n) _</code> anyway, and since core is not enforcing this invariant, that would also make the meta code more robust.</p>",
        "id": 424770885,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709597456
    },
    {
        "content": "<p>Also, I don't think this invariant is currently maintained in practice.</p>\n<ul>\n<li>Lemma statements often involve <code>OfNat.ofNat x</code> where <code>x</code> is a variable. e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.Nat.cast_ofNat_Int#doc\">docs#Int.Nat.cast_ofNat_Int</a></li>\n<li>Some lemma statements involve <code>OfNat.ofNat (Nat.succ n)</code>, e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PNat.val_ofNat#doc\">docs#PNat.val_ofNat</a>.</li>\n<li>Some lemma statements involve <code>OfNat.ofNat (n + 1)</code>, e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Real.Gamma_ofNat_eq_factorial#doc\">docs#Real.Gamma_ofNat_eq_factorial</a></li>\n</ul>\n<p>If meta code assumes that <code>OfNat.ofNat</code> is only ever applied to nat literals, then it will break if used in the proof of any such lemma.</p>",
        "id": 424773159,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709598874
    },
    {
        "content": "<p>Bump.. <a href=\"#narrow/stream/287929-mathlib4/topic/Rewriting.20an.20expression.20that.20involves.20.60OfNat.60/near/432367644\">Another user has bumped into the rough edge in the language that would be fixed by this proposal.</a> I would like to help move some resolution to this issue forward, so if this one is being rejected, it would be very helpful to have it clearly explained what's wrong with it so I know what would need to be improved in a future proposal.</p>",
        "id": 432381895,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1712716072
    },
    {
        "content": "<p>(Is the problem just that this thread is in the wrong stream since this proposal is broader than mathlib?)</p>",
        "id": 432382055,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1712716126
    },
    {
        "content": "<p>yes, this is not something mathlib can do anything about. It would need to be a lean4 RFC</p>",
        "id": 432382442,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712716268
    },
    {
        "content": "<p>Ahh thanks. So is the correct next step to make a post in the lean4 stream with \"[RFC]\" in the topic name?</p>",
        "id": 432382858,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1712716445
    },
    {
        "content": "<p>No, lean4 RFCs are issues on the lean4 repository. RFC threads here are more like pre-RFCs to gather support</p>",
        "id": 432382977,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712716510
    },
    {
        "content": "<p>which you may also want to do if you want to present a strong proposal</p>",
        "id": 432383016,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712716534
    },
    {
        "content": "<p>One issue I'm seeing here is that the instance in <code>@OfNat.ofNat R x _</code> should be determined by <code>R</code> and <code>x</code>. If you do anything to change <code>x</code> without being sure that the instance is the canonical one for this <code>R</code>, <code>x</code> pair, you're breaking an assumption about instance arguments.</p>\n<p>The <code>Nat.cast</code> function does not have this dependency on the specific value being cast. It just depends on the ring.</p>",
        "id": 432390254,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712719271
    },
    {
        "content": "<p>Another issue is that <code>OfNat.ofNat n</code> is assumed to be a sort of atomic expression, one that has special support in various tactics (like <code>simp</code>) that normalize them to some extent.</p>",
        "id": 432391572,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712719808
    },
    {
        "content": "<p>Thanks Kyle for taking a look! You make a good point that <code>simp</code> would need to be updated. Let me make sure I understand the issue about the instance argument.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/unify.20ofNat.20and.20Nat.2Ecast/near/432390254\">said</a>:</p>\n<blockquote>\n<p>One issue I'm seeing here is that the instance in <code>@OfNat.ofNat R x _</code> should be determined by <code>R</code> and <code>x</code>. If you do anything to change <code>x</code> without being sure that the instance is the canonical one for this <code>R</code>, <code>x</code> pair, you're breaking an assumption about instance arguments.</p>\n</blockquote>\n<p>I'm not sure I understand. Is the scenario you're imagining that you try to rewrite by a non-defeq equality at <code>x</code> and this fails because there's a dependency on <code>x</code>? Is this an accurate MWE?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- (These library definitions are copied from the proof of concept above)</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">NatCast'</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">OfNat</span> <span class=\"n\">R</span> <span class=\"n\">n</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Nat.cast'</span> <span class=\"o\">[</span><span class=\"n\">NatCast'</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">NatCast'</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">Nat</span> <span class=\"n\">R</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.cast'</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Zero</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">R</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">One</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">R</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">Zero.instOfNat</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">R</span> <span class=\"mi\">0</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"n\">Zero.zero</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">One.instOfNat</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">R</span> <span class=\"mi\">1</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"n\">One.one</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">AddMonoidWithOne</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Add</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">Zero</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">One</span> <span class=\"n\">R</span> <span class=\"n\">where</span>\n  <span class=\"n\">add_zero</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n  <span class=\"n\">zero_add</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n  <span class=\"n\">add_assoc</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n  <span class=\"n\">natCast</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">R</span>\n  <span class=\"n\">natCast_zero</span> <span class=\"o\">:</span> <span class=\"n\">natCast</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">natCast_succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">natCast</span> <span class=\"n\">n.succ</span> <span class=\"bp\">=</span> <span class=\"n\">natCast</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">AddMonoidWithOne.instOfNat</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AddMonoidWithOne</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">OfNat</span> <span class=\"n\">R</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Zero.instOfNat</span> <span class=\"n\">R</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">One.instOfNat</span> <span class=\"n\">R</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">natCast</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)⟩</span>\n\n<span class=\"c1\">-- (End library definitions; begin example)</span>\n\n<span class=\"sd\">/-- A term which is equal to `2`, but not definitionally so. -/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">my2</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">Classical.choose</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"k\">from</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩)</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">my2_spec</span> <span class=\"o\">:</span> <span class=\"n\">my2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">Classical.choose_spec</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"k\">from</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">AddMonoidWithOne</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Nat.cast'</span> <span class=\"n\">my2</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">my2_spec</span><span class=\"o\">]</span> <span class=\"c1\">-- no dependency on `my2` exposed because `Nat.cast'` is never unfolded</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">AddMonoidWithOne</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Nat.cast'</span> <span class=\"n\">my2</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.cast'</span><span class=\"o\">,</span> <span class=\"n\">my2_spec</span><span class=\"o\">]</span> <span class=\"c1\">-- dependency on `my2` is fine because `rw` works on all occurences</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">AddMonoidWithOne</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Nat.cast'</span> <span class=\"n\">my2</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.cast'</span><span class=\"o\">]</span>\n  <span class=\"n\">conv</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">_</span> <span class=\"n\">my2</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">my2_spec</span><span class=\"o\">]</span> <span class=\"c1\">-- ERROR: motive is dependent</span>\n</code></pre></div>",
        "id": 432396802,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1712721579
    },
    {
        "content": "<p>While that's a scenario I was imagining, it's not the one I was talking about. An assumption is that given <code>R</code> and <code>x</code> then Lean can use the instance it infers to fill in the <code>_</code> in <code>OfNat.ofNat R x _</code>. There are many places in Lean that try to check this assumption (an error you might see is \"inferred instance is not defeq to provided instance\", or something like that).</p>\n<p>Even if you replace <code>x</code> with a defeq term, if it's not syntactically of the right form there's a chance the instance it infers will not be the right one.</p>",
        "id": 432398031,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712721956
    },
    {
        "content": "<p>But as long as the synthesized instances are defeq there's no problem, right? The design of <code>AddMonoidWithOne.instOfNat</code> above is precisely to avoid non-defeq instance diamonds for <code>OfNat R 0</code> and <code>OfNat R 1</code></p>",
        "id": 432398452,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1712722092
    }
]