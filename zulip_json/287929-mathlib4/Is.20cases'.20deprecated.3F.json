[
    {
        "content": "<p>I looked in the style guide but I didn't see any mention of whether <code>cases'</code> is still an OK tactic to use. I just saw an instance of it in <a href=\"https://github.com/leanprover-community/mathlib4/pull/12156\">#12156</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">zero_of_hom_zero</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">Γ₀</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">IsRankOne.hom</span> <span class=\"n\">v</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">hx0</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">zero_le'</span>\n  <span class=\"n\">cases'</span> <span class=\"n\">le_iff_lt_or_eq.mp</span> <span class=\"n\">hx0</span> <span class=\"k\">with</span> <span class=\"n\">h_lt</span> <span class=\"n\">h_eq</span>\n  <span class=\"bp\">·</span> <span class=\"k\">have</span> <span class=\"n\">hs</span> <span class=\"o\">:=</span> <span class=\"n\">IsRankOne.strictMono</span> <span class=\"n\">v</span> <span class=\"n\">h_lt</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">_root_.map_zero</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hs</span>\n    <span class=\"n\">exact</span> <span class=\"n\">absurd</span> <span class=\"n\">hs</span> <span class=\"n\">not_lt_zero'</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">h_eq.symm</span>\n</code></pre></div>\n<p>and here both hypotheses need to be named, so if you do <code>cases</code> then must you end up with a longer proof and/or longer lines? I was reluctant to suggest that the author change it to <code>cases</code> when I couldn't make it more compact as well.</p>",
        "id": 433616450,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713305997
    },
    {
        "content": "<p>I would personally not use <code>cases'</code>, but I don't think there's yet a consensus. <code>cases</code> would take one more line. If you want compact, try <code>.symm &lt;| hx0.eq_or_lt.resolve_left ...</code></p>",
        "id": 433617183,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1713306464
    },
    {
        "content": "<p>It isn't deprecated, perhaps mostly out of hope that one day we will have a tool for automatic replacement. I think it would be reasonable to have a rule against new uses, in any case.</p>",
        "id": 433639958,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1713323065
    },
    {
        "content": "<p>An intermediate style that I like to use if I don't want to figure out the names of the constructors is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">zero_of_hom_zero</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">Γ₀</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">IsRankOne.hom</span> <span class=\"n\">v</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">hx0</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">zero_le'</span>\n  <span class=\"n\">cases</span> <span class=\"n\">le_iff_lt_or_eq.mp</span> <span class=\"n\">hx0</span>\n  <span class=\"n\">next</span> <span class=\"n\">h_lt</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"n\">hs</span> <span class=\"o\">:=</span> <span class=\"n\">IsRankOne.strictMono</span> <span class=\"n\">v</span> <span class=\"n\">h_lt</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">_root_.map_zero</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hs</span>\n    <span class=\"n\">exact</span> <span class=\"n\">absurd</span> <span class=\"n\">hs</span> <span class=\"n\">not_lt_zero'</span>\n  <span class=\"n\">next</span> <span class=\"n\">h_eq</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h_eq.symm</span>\n</code></pre></div>\n<p>That said, I don't think we need a rule against <code>cases'</code>. It's fair to suggest alternatives  however.</p>",
        "id": 433641388,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713324197
    },
    {
        "content": "<p>That suggestion is even two lines longer than the <code>cases'</code> variant</p>",
        "id": 433649081,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713329634
    },
    {
        "content": "<p>The \"return\" key on most keyboards is pretty durable, Kevin. :-)</p>",
        "id": 433659502,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1713330676
    },
    {
        "content": "<p>(That is, number of lines is not something we should be optimising for. It's structurally the same proof, so the only relevant questions are maintainability / readability.)</p>",
        "id": 433661599,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1713330749
    },
    {
        "content": "<p><code>rcases</code> is often a much smaller diff from <code>cases'</code>, and it's available in core</p>",
        "id": 433664653,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713332466
    },
    {
        "content": "<p>I think we can deprecate <code>cases'</code> in favor of <code>rcases</code>, <code>obtain</code>, <code>cases</code>. I think there are no cases where <code>cases'</code> is actually better than all three of those alternatives</p>",
        "id": 433664804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713332555
    },
    {
        "content": "<p>Now if only <code>cases</code> supported <code>rcases</code> patterns :)</p>",
        "id": 433711220,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1713345878
    },
    {
        "content": "<p>I'm visiting Johan today and we had a discussion about this during which he revealed that he didn't use <code>rcases</code> because it wasn't an English word and so it made the code look more confusing. He convinced me that <code>obtain</code> is best.</p>",
        "id": 433733936,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713353843
    },
    {
        "content": "<p>I deeply agree with Johan on this</p>",
        "id": 433734236,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713353932
    },
    {
        "content": "<p>I also agree, I prefer <code>obtain</code> over <code>rcases</code>, not just because of the non-word but also because the argument order is more sensible. There are some cases where you might prefer <code>rcases</code> argument order, e.g. if it's a really big or complex match, but in those cases you are probably better off using <code>cases</code> or <code>match</code> with their more heavyweight (but better documenting) syntax</p>",
        "id": 433736895,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713354835
    },
    {
        "content": "<p>(in case you weren't aware, <code>obtain</code> and <code>rcases</code> are basically the same tactic, they just have slightly different syntax to the same backend)</p>",
        "id": 433737205,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713354923
    },
    {
        "content": "<p>Things would be simpler if <code>intro</code> and <code>have</code> were invisibly upgraded to their more powerful variants in mathlib (<code>rintro</code> &amp; <code>obtain</code>). I'm guessing mathlib doesn't want to diverge from standard lean? I know <code>have</code> can be used in term mode, so perhaps it would be confusing if its behavior was different between the two modes.</p>",
        "id": 433743883,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1713356920
    },
    {
        "content": "<p>it's not quite as simple as that, <code>intro</code> and <code>have</code> have also leveled up in lean 4 and the grammar is incomparable with rcases patterns</p>",
        "id": 433745876,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713357518
    },
    {
        "content": "<p>for example you can write <code>have (a, b) := c</code> but that's not legal <code>obtain</code> syntax</p>",
        "id": 433745926,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713357539
    },
    {
        "content": "<p>I'd say the optimal solution would be that core lean adopts a syntax for have, cases, intro and suffices that supports all use cases that are currently supported in the r* variants</p>",
        "id": 433746534,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1713357730
    },
    {
        "content": "<p>I have also switched from <code>rcases</code> to <code>obtain</code> in all situations for readability purposes.</p>",
        "id": 433757205,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713360598
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Is.20cases'.20deprecated.3F/near/433746534\">said</a>:</p>\n<blockquote>\n<p>I'd say the optimal solution would be that core lean adopts a syntax for have, cases, intro and suffices that supports all use cases that are currently supported in the r* variants</p>\n</blockquote>\n<p>The issue here is that <code>have</code>, <code>let</code>, and <code>match</code> get their flexibility by allowing a <code>term</code> for the pattern, which is powerful but also limiting because it means you have less ability to have specialized syntax (like the <code>-</code> rcases pattern for clearing assumptions) without polluting the term category for everything else</p>",
        "id": 433769268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713362514
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Is.20cases'.20deprecated.3F/near/433745876\">said</a>:</p>\n<blockquote>\n<p>it's not quite as simple as that, <code>intro</code> and <code>have</code> have also leveled up in lean 4 and the grammar is incomparable with rcases patterns</p>\n</blockquote>\n<p>Is there a path to making <code>obtain</code> a strict superset of <code>have</code>?</p>",
        "id": 433770478,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1713362644
    },
    {
        "content": "<p>How many use cases are there in practice for non-trivial term patterns (that aren't simple variants of rcases patterns)? Because if there aren't too many, it might be an idea to put them behind some flag or switch.</p>",
        "id": 433770700,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1713362670
    },
    {
        "content": "<p>I use <code>have/let ⟨a, b⟩ := c</code> all the time</p>",
        "id": 433776533,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713363322
    },
    {
        "content": "<p>(I use those keywords basically in free variation, since it doesn't matter, they both act like <code>have</code> when doing destructuring)</p>",
        "id": 433776765,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713363349
    },
    {
        "content": "<p>an example of a nontrivial pattern which isn't covered by <code>rcases</code> is <code>let a :: l := l'</code>, which you will be surprised to know is actually legal sometimes</p>",
        "id": 433777510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713363429
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">l.map</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"n\">l</span>\n  <span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 433778113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713363498
    },
    {
        "content": "<p>What is going on there that Lean knows this is legal?</p>",
        "id": 433778363,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713363527
    },
    {
        "content": "<p>it desugars to a <code>match</code> expression with <code>(generalizing := true)</code>, and so in the missing match arm lean tries to prove the context is inconsistent via <code>injection</code></p>",
        "id": 433778700,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713363568
    },
    {
        "content": "<p><span aria-label=\"astonished\" class=\"emoji emoji-1f632\" role=\"img\" title=\"astonished\">:astonished:</span> that's some black magic.</p>",
        "id": 433779526,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713363662
    },
    {
        "content": "<p>Conversely, a case where lean's pattern matching is less powerful than rcases's is <code>fun rfl</code> vs <code>rintro rfl</code>, because the former will not generalize variables not participating in the match. This one is specifically problematic for unification of the two syntaxes because they are both using the same syntax</p>",
        "id": 433780185,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713363740
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">8</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"k\">fun</span> <span class=\"bp\">|</span> <span class=\"n\">rfl</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"c1\">-- ⊢ a + a = 8</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">8</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">rfl</span>\n  <span class=\"c1\">-- ⊢ 4 + 4 = 8</span>\n</code></pre></div>",
        "id": 433781132,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713363848
    },
    {
        "content": "<p>Could we change the <code>rcases</code> syntax? I know some people have wanted <code>rcases</code> to support <code>←</code> and  <code>→</code> for rewriting.<br>\ni.e. <code>obtain → : some_prop := by proof</code> instead of <code>rw [show some_prop by proof]</code>.</p>",
        "id": 433788117,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1713364656
    },
    {
        "content": "<p>that syntax makes no sense at all to me</p>",
        "id": 433791827,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713365061
    },
    {
        "content": "<p>what is being rewritten and where?</p>",
        "id": 433792048,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713365085
    },
    {
        "content": "<p>I think the idea is that <code>some_prop</code> is an equality or iff, and you are immediately rewriting with it in the goal.</p>",
        "id": 433792532,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713365141
    },
    {
        "content": "<p>Rocq has something similar to this, and it came up at LftCM</p>",
        "id": 433792717,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713365162
    },
    {
        "content": "<p>yes, rintro patterns are very similar to (a small subset of) intro patterns in ssreflect</p>",
        "id": 433793020,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713365194
    },
    {
        "content": "<p>I do get worried about the readability aspect of these extensions though</p>",
        "id": 433793366,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713365233
    },
    {
        "content": "<p>from a technical standpoint there is no obstruction to doing this</p>",
        "id": 433793600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713365259
    },
    {
        "content": "<p>it an example of how not using <code>term</code> gives us more flexibility to do these things</p>",
        "id": 433794258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713365334
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">8</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- assume h is a long proof</span>\n  <span class=\"c1\">-- obtain → : a = 4 := h</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"k\">show</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- ⊢ 4 + 4 = 8</span>\n</code></pre></div>",
        "id": 433795672,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1713365491
    },
    {
        "content": "<p>I agree that readability could be a concern, but <code>rfl</code> in <code>rcases</code> doesn't seem to impact readability negatively, so I can't imagine <code>←</code> and <code>→</code> to be worse.</p>",
        "id": 433796918,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1713365624
    },
    {
        "content": "<p><code>rfl</code> is actually a pattern though</p>",
        "id": 433798803,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713365824
    },
    {
        "content": "<p>which is to say, it makes sense as a term that we are matching against</p>",
        "id": 433798955,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713365840
    },
    {
        "content": "<p>The thing that struck me about the ssreflect syntax was the tight integration. It seemed to me that many of the specialized features in one tactic were available in other tactics <em>with the same syntax</em>. However, if only one specialized feature is available in one tactic and a different one in another, then it gets hard to remember.</p>",
        "id": 433799651,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713365914
    },
    {
        "content": "<p>well rcases patterns are used by several tactics, so it's not that crazy</p>",
        "id": 433799871,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713365939
    },
    {
        "content": "<p>but indeed it sucks that we have <del>three</del> four separate pattern languages:</p>\n<ol>\n<li><code>have</code>, <code>let</code>, <code>match</code>, <code>intro</code>, <code>fun</code>: uses terms as patterns</li>\n<li><code>obtain</code>, <code>rcases</code>, <code>rintro</code>, <code>ext</code>, <code>rcongr</code>/ <code>congr!</code>, <code>convert</code>: uses rcases patterns</li>\n<li><code>cases</code>, <code>induction</code>: uses binder names as patterns</li>\n<li><code>match_expr</code>, <code>let_expr</code>: uses constants</li>\n</ol>",
        "id": 433802047,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713366166
    },
    {
        "content": "<p>Sure, I'm not necessarily saying it's bad, but I think this kind of tight integration is what we should be striving for. So, medium-term, it would be great if we could, for example, unify <code>have</code> and <code>obtain</code> (possibly with a term flag) and obliterate <code>rcases</code>. Obviously this is a bit tricky, but I believe it's a good goal. <span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> mentioned a while ago that the fewer the tactics the better, and I have come to agree with that.</p>",
        "id": 433802483,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713366211
    },
    {
        "content": "<p>No, I mean that the so called \"tight integration\" is in fact provided by the fact that there are many tactics that use the same pattern language as <code>rcases</code>, so if you learn rcases patterns you can use them in all of those cases</p>",
        "id": 433805049,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713366489
    },
    {
        "content": "<p>the trouble is that 1 and 2 are incompatible approaches and both have significant uptake in lean</p>",
        "id": 433805300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713366518
    },
    {
        "content": "<p>4 looks like a slightly lazy tactic implementation so I'm not too worried about it, but 3 also has its strengths and weaknesses over the others so I'm not sure what we can do</p>",
        "id": 433805773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713366572
    },
    {
        "content": "<p>I worry though that if we just directly overload e.g. <code>have</code> and <code>obtain</code> it will become more confusing, not less, because sometimes you will be getting 1 and other times 2 and there isn't a clear indication of which is which</p>",
        "id": 433806519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713366655
    },
    {
        "content": "<p>Is there any symbol that <code>term</code>s can't start with, that could be used as a sigil to indicate that what follows is an rcases pattern?</p>",
        "id": 433823855,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1713369728
    },
    {
        "content": "<p>How about as a start we see if we can largely remove uses of <code>rcases</code> in favour of <code>obtain</code>, since it seems everyone likes that direction?</p>",
        "id": 433893175,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1713398390
    },
    {
        "content": "<p>I think both of these (<code>cases'</code> -&gt; <code>rcases</code>, <code>rcases</code> -&gt; <code>obtain</code>) should wait until we have the global refactor tool, as this is a perfect use case for it</p>",
        "id": 433917370,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713416201
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Is.20cases'.20deprecated.3F/near/433823855\">said</a>:</p>\n<blockquote>\n<p>Is there any symbol that <code>term</code>s can't start with, that could be used as a sigil to indicate that what follows is an rcases pattern?</p>\n</blockquote>\n<p><code>$</code>?</p>",
        "id": 433939640,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713420890
    },
    {
        "content": "<p>Ah sorry that would rather be to show rhat something <em>isn't</em> a <code>rcases</code> pattern</p>",
        "id": 433939960,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713420919
    },
    {
        "content": "<p>Ooh, that might also work.</p>",
        "id": 433944034,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1713421286
    },
    {
        "content": "<p>Funnily enough, $ is the one character basically <em>anything</em> in Lean can start with, because of syntax quotations. At least when followed by an ident or open paren.</p>",
        "id": 433946560,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1713421512
    },
    {
        "content": "<p>But an <code>rcases</code> pattern can not start with it. So the strategy could be \"if the argument starts with <code>$</code> then strip it off and treat the remainder as a <code>term</code> pattern like <code>have</code> does; otherwise, treat the argument as <code>rcases</code> pattern\"</p>",
        "id": 433948592,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1713421692
    },
    {
        "content": "<p>no, rcases patterns can start with <code>$</code></p>",
        "id": 433966240,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713423965
    },
    {
        "content": "<p>sebastian is right, <code>$</code> is a uniquely bad option because <code>$</code> can be the start of an antiquotation in any syntax category</p>",
        "id": 433966687,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713424005
    },
    {
        "content": "<p>note, this is valid lean syntax</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rcases</span> <span class=\"n\">x</span> <span class=\"k\">with</span> <span class=\"bp\">$</span><span class=\"n\">pat</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 433966952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713424029
    },
    {
        "content": "<p>I'm not sure I like using obtain instead of rcases in all situations. When there's an actual case split going on, <code>rcases</code> sounds more natural I think.</p>",
        "id": 433981213,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1713425515
    },
    {
        "content": "<p>Maybe € instead of $, then</p>",
        "id": 433986007,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1713427071
    }
]