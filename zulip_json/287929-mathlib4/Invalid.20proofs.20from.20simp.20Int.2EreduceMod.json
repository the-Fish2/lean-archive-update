[
    {
        "content": "<p>The two different definitions of <code>(a : Int) % (b : Int)</code> available in Mathlib are causing <code>Int.reduceMod</code> to produce invalid proofs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">â„¤</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"mi\">4</span> <span class=\"c1\">-- =&gt; 3</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"bp\">%</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Int.reduceMod</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">(kernel) declaration type mismatch, '_example' has type</span>\n<span class=\"cm\">  -1 = -1</span>\n<span class=\"cm\">but it is expected to have type</span>\n<span class=\"cm\">  -1 % 4 = -1</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>It would be nice to have a flag to turn on simproc proof checking, as I've added checking manually to all my simprocs. Also idk what to do about the specific situation above.</p>",
        "id": 426629563,
        "sender_full_name": "David A",
        "timestamp": 1710450575
    },
    {
        "content": "<p>To be clear, the above example is false but simp \"proves\" it, producing an error in the kernel.<br>\nA goal of <code>(-1%4) = 3</code> is proved by <code>rfl</code> but simp converts it into the false goal <code>-1 = 3</code>.</p>",
        "id": 426630136,
        "sender_full_name": "David A",
        "timestamp": 1710450782
    },
    {
        "content": "<p>Actually this might not be Mathlib's fault. I think it's related to <a href=\"https://github.com/leanprover/lean4/issues/2330\">https://github.com/leanprover/lean4/issues/2330</a>; which seems to point to a bug in the extern implementation of the modulo operation. I'm getting the same \"application type mismatch\" from the bug even when I use <code>Int.mod</code>.</p>",
        "id": 426638603,
        "sender_full_name": "David A",
        "timestamp": 1710454473
    },
    {
        "content": "<p>Oh, ffs. It's the <code>Int.mod</code> documentation which is wrong. It claims that <code>(-12 : Int).mod 7 = 2</code> when in fact it evaluates to <code>-5</code>. I still suspect the native code is going by the documented behavior rather than the implemented semantics or something like that, but the lesson is to explicitly use <code>Int.emod</code> everywhere.</p>",
        "id": 426640112,
        "sender_full_name": "David A",
        "timestamp": 1710455198
    },
    {
        "content": "<p>Thanks for this careful diagnosis!</p>",
        "id": 426650368,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710461069
    },
    {
        "content": "<p>Documentation PR <em>very</em> welcome!</p>",
        "id": 426655380,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710464171
    }
]