[
    {
        "content": "<p>Why is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Algebra.FinitePresentation#doc\">docs#Algebra.FinitePresentation</a> a <code>def</code> and not a <code>class</code>? Follow up question on naming conventions: For me <code>FinitePresentation</code> sounds like it contains data (i.e. a finite presentation of the algebra). Should it be called <code>FinitelyPresented</code>?</p>",
        "id": 432026748,
        "sender_full_name": "Christian Merten",
        "timestamp": 1712595766
    },
    {
        "content": "<p>I think <code>IsFinitelyPresented</code> would be even better!</p>",
        "id": 432031936,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712597523
    },
    {
        "content": "<p>I was somehow expecting you to suggest that :-)</p>",
        "id": 432032018,
        "sender_full_name": "Christian Merten",
        "timestamp": 1712597565
    },
    {
        "content": "<p>And I agree that it could be a class. I guess the argument for is that then you could imagine typeclass inference could supply instances automatically, and the argument against is that what is the point of cluttering up the typeclass system even more when you can just have <code>(h : IsFinitelyPresented R A)</code> and use dot notation etc.</p>",
        "id": 432032175,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712597640
    },
    {
        "content": "<p>To be consistent, <code>FiniteType</code> needs to be <code>IsFiniteType</code> then (and of course many more)</p>",
        "id": 432032347,
        "sender_full_name": "Christian Merten",
        "timestamp": 1712597700
    },
    {
        "content": "<p>Well <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> wrote that stuff in 2020 and perhaps conventions were less established back then. Note that for topology you have <code>IsCompact</code> for subspaces and <code>CompactSpace</code> for spaces, but here there doesn't seem to be such a dichotomy so I don't really see why we can't use <code>Is</code> for everything. I find that my students find it easier to navigate with the <code>Is</code> convention.</p>",
        "id": 432032627,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712597814
    },
    {
        "content": "<p>What is the rule here? When should it start with <code>Is</code>?</p>",
        "id": 432034147,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1712598295
    },
    {
        "content": "<p>If it is a <code>Prop</code>.</p>",
        "id": 432034348,
        "sender_full_name": "Christian Merten",
        "timestamp": 1712598352
    },
    {
        "content": "<p>The exception are predicates which we have in Lean both for topological spaces and for subspaces of topological spaces (like <code>CompactSpace</code>, which I would happily rename <code>IsCompactSpace</code> to be honest, but that's not how it is right now).</p>",
        "id": 432035068,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712598567
    },
    {
        "content": "<p>To be precise, I think this means <code>Prop</code> valued function.</p>\n<p>What about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LawfulMonad#doc\">docs#LawfulMonad</a> ? Should this be <code>IsLawfulMonad</code>? Or maybe <code>Monad.IsLawful</code>? Is this just legacy, or is there a rule exception which covers this case?</p>",
        "id": 432178645,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1712654851
    },
    {
        "content": "<p>Well there you're in core, so this is beyond the community's jurisdiction.</p>",
        "id": 432183089,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712655795
    },
    {
        "content": "<p>Ah, I understand. If it were in Mathlib, what would be its name?</p>",
        "id": 432185339,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1712656262
    },
    {
        "content": "<p>Well <code>Is</code> zealots like me would be keen for <code>IsLawful</code>, but golfy people might argue for <code>Lawful</code>. There isn't an algorithm, it's whatever the community converges on :-) I'm not entirely sure why <code>Monad</code> is in there at all, given that it's not extending Monad</p>",
        "id": 432186938,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712656691
    },
    {
        "content": "<p>It takes <code>[Monad m]</code> as a parameter though</p>",
        "id": 432259497,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1712673547
    },
    {
        "content": "<p>Sure, I mean why there's <code>Monad</code> in the name, I agree that it's pretty important that it takes a monad as parameter :-) For example we have <code>IsDomain</code> which doesn't mention <code>Ring</code>.</p>",
        "id": 432311484,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712686887
    },
    {
        "content": "<p>Well, if we had a <code>Ring</code> in core that contained only the data, then presumably you wouldn't argue against including <code>Ring</code> in a downstream <code>IsLawfulRing</code>...</p>",
        "id": 432318358,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712689133
    },
    {
        "content": "<p>We only get to use the name <code>IsLawful</code> once unless we suffix it!</p>",
        "id": 432318498,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712689172
    },
    {
        "content": "<p>To come back to the original topic of this thread: Does anyone have objections to making <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Algebra.FinitePresentation#doc\">docs#Algebra.FinitePresentation</a> a <code>class</code>? Maybe  <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> has an opinion as the author of that file?</p>",
        "id": 432441434,
        "sender_full_name": "Christian Merten",
        "timestamp": 1712736569
    },
    {
        "content": "<p>I have no objection.</p>",
        "id": 432441482,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1712736594
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Algebra.2EFinitePresentation/near/432026748\">said</a>:</p>\n<blockquote>\n<p>Should it be called <code>FinitelyPresented</code>?</p>\n</blockquote>\n<p>Note that <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> did the opposite rename in <a href=\"https://github.com/leanprover-community/mathlib/pull/6382\">mathlib3#6382</a>, for similarity to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Algebra.FiniteType#doc\">docs#Algebra.FiniteType</a>.</p>",
        "id": 432451885,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1712739158
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Algebra.2EFinitePresentation/near/432441434\">said</a>:</p>\n<blockquote>\n<p>Does anyone have objections to making <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Algebra.FinitePresentation#doc\">docs#Algebra.FinitePresentation</a> a <code>class</code>?</p>\n</blockquote>\n<p>Similarly, Riccardo initially made this a class in <a href=\"https://github.com/leanprover-community/mathlib/pull/5407\">mathlib3#5407</a>, but <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> preferred a plain <code>def</code>. The Lean 4 developers have radically improved the typeclass machinery since then, so IMO this warrants a re-evaluation.</p>",
        "id": 432452760,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1712739385
    },
    {
        "content": "<p>I get 404s on these links.</p>",
        "id": 432453008,
        "sender_full_name": "Christian Merten",
        "timestamp": 1712739461
    },
    {
        "content": "<p>Sorry, fixed!</p>",
        "id": 432453218,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1712739509
    },
    {
        "content": "<p>As a rule of thumb, making <code>FinitePresentation R A</code> a class is going to be useful if you can look at R and A and immediately say \"yes, that looks finitely presented\". If in practice showing it's finitely presented requires some proof steps first (even simple ones), in particular when it holds because <code>A</code> is actually equal to something else, then the typeclass system won't help you with this.</p>",
        "id": 432453754,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1712739627
    },
    {
        "content": "<p>That is for instance why we don't have a typeclass for saying a number is prime: you can't look at it and immediately see that. You need some sort of computation first, and the typeclass system doesn't do computation in that way.</p>",
        "id": 432454198,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1712739740
    },
    {
        "content": "<p>Thanks for the explanation, now that I think of it, there are probably not so many cases where typeclass inference can immediatly see that some algebra is finitely presented. Mostly base change (which is actually missing currently) and polynomial rings probably.</p>\n<p>For me the reason for wanting this to be a <code>class</code> is that I want to say (e.g.) an unramified ring homomorphism is <code>FormallyUnramified</code> and of <code>FinitePresentation</code>. If I have <code>Unramified R A</code> in my assumptions, I want to have <code>FinitePresentation R A</code> automatically without passing the extra argument around.</p>",
        "id": 432455356,
        "sender_full_name": "Christian Merten",
        "timestamp": 1712740079
    },
    {
        "content": "<p>I am in favor of making it a class, unless it creates serious performance issues.I don't see a lot of differences between finitely presented and of finite type, and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.Finite#doc\">docs#Module.Finite</a> is a class.</p>",
        "id": 432457661,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1712740855
    },
    {
        "content": "<p>I am very bad in choosing names, so fell free to rename if you think it is better.</p>",
        "id": 432457827,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1712740907
    },
    {
        "content": "<p>Suggestion: I'll make it a class later today and get a benchmark. Then we have some numbers to work with.</p>",
        "id": 432457927,
        "sender_full_name": "Christian Merten",
        "timestamp": 1712740929
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Algebra.2EFinitePresentation/near/432457927\">said</a>:</p>\n<blockquote>\n<p>Suggestion: I'll make it a class later today and get a benchmark. Then we have some numbers to work with.</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/12057\">#12057</a>, benchmark is on its way.</p>",
        "id": 432600371,
        "sender_full_name": "Christian Merten",
        "timestamp": 1712789213
    },
    {
        "content": "<p>You won't get a benchmark until the entire library compiles again...</p>",
        "id": 432606027,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712793130
    },
    {
        "content": "<p>It says \"no significant changes\".</p>",
        "id": 432652756,
        "sender_full_name": "Christian Merten",
        "timestamp": 1712824176
    },
    {
        "content": "<p>I don't see why you want FinitePresentation to be a class. It is rare that the actual structure beneath it is actually used in an important way. Most of the time, you can — an sometimes do — adjust the finite présentation so that it fits your present needs.</p>",
        "id": 433024123,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1712992957
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Algebra.2EFinitePresentation/near/433024123\">said</a>:</p>\n<blockquote>\n<p>I don't see why you want FinitePresentation to be a class. It is rare that the actual structure beneath it is actually used in an important way. Most of the time, you can — an sometimes do — adjust the finite présentation so that it fits your present needs.</p>\n</blockquote>\n<p>I think I don't understand. Note that <code>Algebra.FinitePresentation</code> is a <code>Prop</code> and remains a <code>Prop</code> after making it a <code>class</code>.</p>",
        "id": 433030865,
        "sender_full_name": "Christian Merten",
        "timestamp": 1712999878
    },
    {
        "content": "<p>It should probably be renamed to <code>FinitelyPresentable</code>.</p>",
        "id": 433031363,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1713000006
    },
    {
        "content": "<p>I tried to follow standard terminology, it seems to me people say \"let M be of finite presentation\", but of course they don't fix the actual presentation.</p>",
        "id": 433032615,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1713000340
    },
    {
        "content": "<p>Yeah, I think in mathlib we might want to have both notions</p>",
        "id": 433034321,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1713002079
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Algebra.2EFinitePresentation/near/433030865\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Algebra.2EFinitePresentation/near/433024123\">said</a>:</p>\n<blockquote>\n<p>I don't see why you want FinitePresentation to be a class. It is rare that the actual structure beneath it is actually used in an important way. Most of the time, you can — an sometimes do — adjust the finite présentation so that it fits your present needs.</p>\n</blockquote>\n<p>I think I don't understand. Note that <code>Algebra.FinitePresentation</code> is a <code>Prop</code> and remains a <code>Prop</code> after making it a <code>class</code>.</p>\n</blockquote>\n<p>It was me that didn't understand. (When I read in mathlib <code>Algebra.FinitePresentation</code>, I expect a presentation, not simply the existence of one.) Regarding terminology, I believe mathlib should take the opportunity to systematize it, especially in theses cases where there is no ambiguity and where specialists see the point. (It will be more difficult to argue for things like “graphs” that exist in many guises, all inconsistent, and where mathlib has to make an ur-choice — the one of Serre is of course the best one — and all others should derive from it, in particular <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph#doc\">docs#SimpleGraph</a>.)</p>",
        "id": 433044548,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1713012697
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Algebra.2EFinitePresentation/near/433031363\">said</a>:</p>\n<blockquote>\n<p>It should probably be renamed to <code>FinitelyPresentable</code>.</p>\n</blockquote>\n<p>Or even <code>IsFinitelyPresentable</code>.</p>",
        "id": 433044613,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1713012733
    },
    {
        "content": "<p>Here's a thought. What if we introduce the type of all finite presentations of an algebra, and put some structure on it (like a poset structure, or even a category structure). Then make <code>FinitelyPresentable</code> simply assert that this is nonempty. Then if you want to work with finite presentations, and modify them as needed by your argument, you can work with this additional structure of all finite presentations.</p>",
        "id": 433049536,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1713016836
    },
    {
        "content": "<p>Something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">FinitePresentation</span> <span class=\"n\">where</span>\n  <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">A</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"n\">B</span>\n  <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">Function.Surjective</span> <span class=\"n\">p</span>\n  <span class=\"n\">fg</span> <span class=\"o\">:</span> <span class=\"n\">p.toRingHom.ker.FG</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">}</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">FinitePresentation.Hom</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">FinitePresentation</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">F.n</span><span class=\"o\">)</span> <span class=\"n\">A</span> <span class=\"bp\">→+*</span> <span class=\"n\">MvPolynomial</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">G.n</span><span class=\"o\">)</span> <span class=\"n\">A</span>\n  <span class=\"n\">he</span> <span class=\"o\">:</span> <span class=\"n\">G.p.toRingHom.comp</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">F.p.toRingHom</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Category</span> <span class=\"o\">(</span><span class=\"n\">FinitePresentation</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">Hom</span> <span class=\"o\">:=</span> <span class=\"n\">FinitePresentation.Hom</span>\n  <span class=\"n\">id</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">RingHom.id</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"n\">comp</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"n\">hf</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"n\">hg</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">g.comp</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">RingHom.comp_assoc</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">]⟩</span>\n</code></pre></div>",
        "id": 433050713,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1713017809
    },
    {
        "content": "<p>We could, for example, prove that <code>FinitePresentation A B</code> has finite coproducts.</p>",
        "id": 433050818,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1713017886
    },
    {
        "content": "<p>Yes this a good idea. There is a natural partial order also</p>",
        "id": 433051006,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1713018050
    },
    {
        "content": "<p>Right. But for that we would have to identify the map from Fin n to B with its image which is categorically “evil”</p>",
        "id": 433051048,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1713018087
    },
    {
        "content": "<p>But maybe only slightly evil in this case :)</p>",
        "id": 433051075,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1713018120
    },
    {
        "content": "<p>You need this for “factor through”?</p>",
        "id": 433051132,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1713018149
    },
    {
        "content": "<p>No? I think the Homs in the category above would work as well</p>",
        "id": 433051159,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1713018178
    },
    {
        "content": "<p>Yeah. That’s more natural</p>",
        "id": 433051176,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1713018193
    },
    {
        "content": "<p>I mean, the skeleton of that category is “just” the poset you’re referring to, so <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 433051203,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1713018226
    },
    {
        "content": "<p>People do care about minimal things quite a bit</p>",
        "id": 433051263,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1713018256
    },
    {
        "content": "<p>Fixed it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">FinitePresentation</span> <span class=\"n\">where</span>\n  <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">B</span>\n  <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">Function.Surjective</span> <span class=\"o\">(</span><span class=\"n\">MvPolynomial.aeval</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S₁</span> <span class=\"o\">:=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"n\">fg</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">MvPolynomial.aeval</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S₁</span> <span class=\"o\">:=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toRingHom.ker.FG</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">}</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">PartialOrder</span> <span class=\"o\">(</span><span class=\"n\">FinitePresentation</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">le</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">A.n</span> <span class=\"bp\">≤</span> <span class=\"n\">B.n</span>\n  <span class=\"n\">le_refl</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">le_refl</span> <span class=\"n\">A.n</span>\n  <span class=\"n\">le_trans</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">A.n</span><span class=\"o\">)</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span>\n  <span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"n\">hf</span><span class=\"o\">,</span><span class=\"n\">h1</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"n\">hg</span><span class=\"o\">,</span><span class=\"n\">h2</span><span class=\"o\">⟩</span> <span class=\"n\">h1'</span> <span class=\"n\">h2'</span>\n    <span class=\"n\">congr</span>\n    <span class=\"n\">exact</span> <span class=\"n\">le_antisymm</span> <span class=\"n\">h1'</span> <span class=\"n\">h2'</span>\n</code></pre></div>",
        "id": 433051845,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1713018732
    },
    {
        "content": "<p>Did anyone complain about not using <code>Finite</code> yet?</p>",
        "id": 433052236,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1713019037
    },
    {
        "content": "<p>Do we have the concept of a finitely generated equivalence relation in mathlib?</p>",
        "id": 433061102,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1713027059
    },
    {
        "content": "<p>The problem I see with the second definition is that it doesn't show that there is an algebra isomorphic to B which lives in the same universe as A</p>",
        "id": 433111503,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1713079120
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Algebra.2EFinitePresentation/near/433111503\">said</a>:</p>\n<blockquote>\n<p>The problem I see with the second definition is that it doesn't show that there is an algebra isomorphic to B which lives in the same universe as A</p>\n</blockquote>\n<p>This could be done after the fact using, e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.equivFin#doc\">docs#Fintype.equivFin</a></p>",
        "id": 433126236,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1713093279
    },
    {
        "content": "<p>I think you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PartialOrder.lift#doc\">docs#PartialOrder.lift</a> to golf the instance above</p>",
        "id": 433127192,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713094228
    },
    {
        "content": "<p>Another direction this could go is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">IsFinitePresentationOn</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">Function.Surjective</span> <span class=\"o\">(</span><span class=\"n\">MvPolynomial.aeval</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S₁</span> <span class=\"o\">:=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"n\">fg</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">MvPolynomial.aeval</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S₁</span> <span class=\"o\">:=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toRingHom.ker.FG</span>\n</code></pre></div>\n<p>and then recover <code>FinitePresentation</code> by making a subtype and specializing to <code>I := (_ : Finset B)</code> and <code>f := coe</code></p>",
        "id": 433127494,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713094535
    },
    {
        "content": "<p>(this is a bit like the <code>Module.Free</code> vs <code>Basis</code> distinction)</p>",
        "id": 433127603,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713094622
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Algebra.2EFinitePresentation/near/433126236\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Algebra.2EFinitePresentation/near/433111503\">said</a>:</p>\n<blockquote>\n<p>The problem I see with the second definition is that it doesn't show that there is an algebra isomorphic to B which lives in the same universe as A</p>\n</blockquote>\n<p>This could be done after the fact using, e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.equivFin#doc\">docs#Fintype.equivFin</a></p>\n</blockquote>\n<p>Yes, but doing that in practice,I felt that it added one layer of burden.</p>",
        "id": 433137560,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1713104110
    },
    {
        "content": "<p>I understand. We could of course introduce both approaches I mentioned above, and an equivalence of categories between them. This would be the \"best of both worlds\".</p>",
        "id": 433138484,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1713104930
    },
    {
        "content": "<p>How should we proceed? Should I close <a href=\"https://github.com/leanprover-community/mathlib4/pull/12057\">#12057</a> or can we merge <a href=\"https://github.com/leanprover-community/mathlib4/pull/12057\">#12057</a> as an intermediate step? (Naturally I prefer the latter, as I would like to have <code>Algebra.FinitePresentation</code> as a <code>class</code> as soon as possible).</p>",
        "id": 433152023,
        "sender_full_name": "Christian Merten",
        "timestamp": 1713116599
    },
    {
        "content": "<p>Looks like Matt has merged this PR, which I completely agree with! We can think more about the design and refactor as needed</p>",
        "id": 433154842,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1713119291
    },
    {
        "content": "<p>Sorry. The merge was definitely not meant as the end of the conversation. Using a <code>class</code> instead is somewhat orthogonal to the excellent ideas discussed here. I hope there is an expansion of them!</p>",
        "id": 433552037,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1713281808
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/12518\">#12518</a> is an attempt to develop an API for presentations of algebras. The presentations I need aren't necessarily finite so not everything in this thread is used.</p>",
        "id": 436130651,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1714421590
    }
]