[
    {
        "content": "<p>I would like to use the <a href=\"https://leanprover-community.github.io/mathlib4_docs////Mathlib/Analysis/Quaternion.html\">quaternion</a> type to multiply (2+3i+4j+5k) by (6+7i+8j+9k). Any idea how to do this? I can't find a constructor for quaternions anywhere.</p>\n<p><a href=\"https://live.lean-lang.org/#code=import%20Mathlib%0D%0A%0D%0Aopen%20Quaternion%0D%0A%0D%0Adef%20x%3A%E2%84%8D%20%3A%3D%20%7Bre%3A%3D%201%2C%20imI%3A%3D%202%2C%20imJ%3A%3D%203%2C%20imK%3A%3D%204%7D%0D%0Adef%20y%3A%E2%84%8D%20%3A%3D%20%7Bre%3A%3D%205%2C%20imI%3A%3D%206%2C%20imJ%3A%3D%207%2C%20imK%3A%3D%208%7D%0D%0A%0D%0Adef%20z%3A%E2%84%8D%20%3A%3D%20x%20*%20y%0D%0A%0D%0A%23eval%20z%20%2F-doesn't%20work-%2F\">My attempt</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Quaternion</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ℍ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">re</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imI</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imJ</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imK</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">}</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">ℍ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">re</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imI</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imJ</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imK</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">:</span><span class=\"n\">ℍ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\">doesn't work-/</span>\n</code></pre></div>",
        "id": 444765940,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718390459
    },
    {
        "content": "<p>That sounds correct, but I don't think you should expect <code>#eval</code> to work on quaternions at all</p>",
        "id": 444769418,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1718391784
    },
    {
        "content": "<p>Yeah, it doesn't seem to work with complex numbers either.<br>\nAre there any other tools inside lean that can give the answer? <br>\nOr can I override #eval to add this functionality perhaps?</p>",
        "id": 444769638,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718391869
    },
    {
        "content": "<p>Also it is failing with Real</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">:</span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">5</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">k</span>\n</code></pre></div>\n<p>Giving error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">ofCauchy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, ... -/</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 444770225,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718392107
    },
    {
        "content": "<p>Reals are represented as cauchy sequences. There is no clear way to display a real number. Notice that in your case Lean is revealing that 5 is represented by the constant cauchy sequence of all 5s. </p>\n<p>In your code above, you should get that <code>z = {re:= -60, imI:= 12, imJ:= 30, imK:= 24}</code>. You can verify this works explicitly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">re</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">60</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imI</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">12</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imJ</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">30</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imK</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">24</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">ring</span>\n</code></pre></div>\n<p>But since real numbers (and hence complex and quaternions) are not, in general, computable, you will encounter friction when doing explicit computations.</p>",
        "id": 444771660,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1718392671
    },
    {
        "content": "<p>In fact, I didn't do the multiplication by hand. I tricked Lean into revealing the constant cauchy sequences it computed for <code>z</code> by trying </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"bp\">.</span><span class=\"n\">re</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"bp\">.</span><span class=\"n\">imI</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"bp\">.</span><span class=\"n\">imJ</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"bp\">.</span><span class=\"n\">imK</span>\n</code></pre></div>\n<p>which yield errors like you reported, but it's an informative one!</p>",
        "id": 444772623,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1718393005
    },
    {
        "content": "<p>If you want to <code>#eval</code> you need to use a field which is evalable. Try doing stuff over the rationals instead.</p>",
        "id": 444782217,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1718396503
    },
    {
        "content": "<p>I think the original point was to learn how to work with quaternions which are inherently tied to the reals (at least as implemented). I suppose a helpful learning project could be to define the \"rational quaternions\" from scratch and prove a few things about them.</p>",
        "id": 444783117,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1718396808
    },
    {
        "content": "<p>Oh I actually see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quaternion#doc\">docs#Quaternion</a> which defines quaternions over a type. So maybe the thing to do is not to use <code>ℍ</code>, but to use <code>Quaternion Rat</code> instead?</p>",
        "id": 444783881,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1718397045
    },
    {
        "content": "<p>Yeah, <code>ℍ</code> is <code>Quaternion Real</code></p>",
        "id": 444784488,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1718397234
    },
    {
        "content": "<p><code>Quaternion Rat</code> is also missing a <code>Repr</code> instance so is not currently evalable. Would it be hard to define one so the result could be displayed?</p>",
        "id": 444784989,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1718397379
    },
    {
        "content": "<p>I conjecture that it would be very easy, it just wouldn't be easy for me :-) Maybe go and look at how <code>Repr</code> is defined for types like <code>Rat</code> and then just copy stuff?</p>",
        "id": 444785761,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1718397659
    },
    {
        "content": "<p>Do we have a repr for Complex? That probably makes more sense to copy</p>",
        "id": 444786075,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718397786
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Quaternion</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">reprPrec</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{repr q.re} + {repr q.imI}i + {repr q.imJ}j + {repr q.imK}k\"</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Just to pick a mathy representation. This works. And if you add this to the code above making <code>x, y, z : Quaternion Rat</code> then it does the eval.</p>",
        "id": 444786574,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1718397993
    },
    {
        "content": "<p>Or a truly working example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Quaternion</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Quaternion</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">reprPrec</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{repr q.re} + {repr q.imI}i + {repr q.imJ}j + {repr q.imK}k\"</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Quaternion</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">re</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imI</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imJ</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imK</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">}</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">Quaternion</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">re</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imI</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imJ</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imK</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">}</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">:</span><span class=\"n\">Quaternion</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"c1\">-- -60 + 12i + 30j + 24k</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">z</span>\n</code></pre></div>",
        "id": 444786652,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1718398042
    },
    {
        "content": "<p>Once you're happy with it, feel free to PR! Do you have push access to non-master branches of mathlib? If not then let me know your github userid.</p>",
        "id": 444786802,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1718398086
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/How.20do.20you.20use.20the.20Quaternion.20type.3F/near/444786075\">said</a>:</p>\n<blockquote>\n<p>Do we have a repr for Complex? That probably makes more sense to copy</p>\n</blockquote>\n<p>I think the problem is that <code>Complex</code> truly is tied to <code>Real</code> which we can't expect to have a <code>Repr</code> (unless I'm wrong).</p>",
        "id": 444787238,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1718398246
    },
    {
        "content": "<p>Well, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Complex.instRepr#doc\">docs#Complex.instRepr</a> exists</p>",
        "id": 444787359,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718398309
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/How.20do.20you.20use.20the.20Quaternion.20type.3F/near/444786802\">said</a>:</p>\n<blockquote>\n<p>Once you're happy with it, feel free to PR! Do you have push access to non-master branches of mathlib? If not then let me know your github userid.</p>\n</blockquote>\n<p>I don't have push access to non-master branches. This seems like a pretty safe way to test those waters. My github id is <code>pauldavidrowe</code></p>",
        "id": 444787445,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1718398342
    },
    {
        "content": "<p>It's uglier, but I think the repr should be <code>{ re := _, im_i := _, im_j := _, im_k := _ }</code> or similar; <code>Repr</code> instances are expected to be roughly valid syntax</p>",
        "id": 444787473,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718398356
    },
    {
        "content": "<p>I've sent you an invite <span class=\"user-mention\" data-user-id=\"300396\">@Paul Rowe</span></p>",
        "id": 444787702,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718398473
    },
    {
        "content": "<p>I agree. I was being a little too cutesy.</p>",
        "id": 444787714,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1718398484
    },
    {
        "content": "<p>Well, the other way to take this is \"there ought to be matching notation\", but that sounds like a problem for another time</p>",
        "id": 444787776,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718398523
    },
    {
        "content": "<p>You could argue that <code>Quaternion</code> should be built like <code>Complex</code>, and use <code>r + x*I + y*J + z*K</code>; if you want to pursue that, perhaps worth creating a new thread and pinging <span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span></p>",
        "id": 444787920,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718398576
    },
    {
        "content": "<p>Thanks, that works great:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Quaternion</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Quaternion</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">reprPrec</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{repr q.re} + {repr q.imI}i + {repr q.imJ}j + {repr q.imK}k\"</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Quaternion</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">reprPrec</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{repr q.re} + {repr q.imI}i + {repr q.imJ}j + {repr q.imK}k\"</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> didn't know how to do the same for complexified quaternions-/</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ℍ</span><span class=\"o\">[</span><span class=\"n\">ℤ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">re</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imI</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imJ</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imK</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">}</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">ℍ</span><span class=\"o\">[</span><span class=\"n\">ℤ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">re</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imI</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imJ</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imK</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">:</span><span class=\"n\">ℍ</span><span class=\"o\">[</span><span class=\"n\">ℤ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">z</span>\n</code></pre></div>\n<p>Some further points:<br>\nI wonder is it possible to also use <code>ℂ[ℚ]</code> and <code>ℂ[ℤ]</code> ? . Should there be a way to display complexified quaternions <code>ℍ[ℂ]</code> just for completeness?</p>\n<p>Or if we want to go a bit crazy:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">ℍ</span><span class=\"o\">[</span><span class=\"n\">ℍ</span><span class=\"o\">[</span><span class=\"n\">ℤ</span><span class=\"o\">]]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">re</span><span class=\"o\">:=</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imI</span><span class=\"o\">:=</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imJ</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imK</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">}</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\">how would this be displayed?-/</span>\n</code></pre></div>",
        "id": 444796560,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718402638
    },
    {
        "content": "<p>I don't think quaternions make sense over non-commutative rings</p>",
        "id": 444797402,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718402920
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=GaussianInt#doc\">docs#GaussianInt</a> for ℂ[ℤ]</p>",
        "id": 444797417,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718402933
    },
    {
        "content": "<p>It turns out I was mistaken earlier. When the infoview shows the Cauchy sequence for a real number, it’s not an error. That’s just how real numbers are displayed. </p>\n<p>I’m no longer at a computer, but in another thread in this stream you can see a more general way to do it that will work for reals and complex too. But it will still show you all the messy Cauchy sequence stuff.</p>",
        "id": 444797579,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1718403031
    },
    {
        "content": "<p>Yes, I just thought it was an error because it had the word \"sorry\" in it. I'm sure there's a good reason why reals are displayed like that.  As a newcomer I'm not totally sure why it needs to display so many repeated 5's <code>/- 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, ... -/</code> but I'm sure there's a good reason <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 444798812,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718403444
    },
    {
        "content": "<p>it's displaying the underlying cauchy sequence, which is a converging sequence of rational numbers</p>",
        "id": 444799049,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718403570
    },
    {
        "content": "<p>for rational numbers this is just the constant sequence, although of course just because you see a bunch of 5's doesn't mean it doesn't eventually converge to <code>6</code> instead</p>",
        "id": 444799190,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718403612
    },
    {
        "content": "<p>Yes, I get the principle. And not knowing the internals I can't criticise. But I'm just wondering if there aren't some simple cases where it can tell the number is rational and then it doesn't have to write it out as a sequence.</p>",
        "id": 444799329,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718403686
    },
    {
        "content": "<p>The problem is that you can’t know what it converges to without considering the whole sequence which involves non-trivial reasoning.</p>",
        "id": 444799541,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1718403816
    },
    {
        "content": "<p>That is, there’s no easy test to know if a Cauchy sequence converges to some rational number that should be displayed more simply instead.</p>",
        "id": 444799714,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1718403911
    },
    {
        "content": "<p>I guess so. If you're defining the sequence by a general algorithm then the problem is unsolvable in general. But I mean there might be simple cases, for example where I just defined <code>z:Real = 3</code>. In those special cases would it not be possible? <br>\nJust theoretically I mean.</p>",
        "id": 444799747,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718403948
    },
    {
        "content": "<p>The issue is that the display function either has to work for all reals, or else you need a decidable algorithm to determine which thing to display. It doesn’t matter that you just defined it as a constant; it immediately get represented as a Cauchy sequence and the display code doesn’t know anything else.</p>",
        "id": 444800045,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1718404129
    },
    {
        "content": "<p>OK, but presumably it's represented by a Cauchy sequence which contains an algorithm of how to get the next number.  And can we not inspect that algorithm to see if the algorithm is a simple constant algorithm? Then for those special cases just write that constant?</p>\n<p>In terms of usefulness,  I think the usefullness of being able to display a shortened version in very special cases would outweigh the fact that the algorithm would not detect all rationals and default to the original sequence?</p>",
        "id": 444800500,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718404362
    },
    {
        "content": "<blockquote>\n<p>but presumably it's represented by a Cauchy sequence which contains an algorithm of how to get the next number.</p>\n</blockquote>\n<p>No, in lean functions cannot inspect the algorithms of their inputs, this would be unsound</p>",
        "id": 444800785,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718404545
    },
    {
        "content": "<p>e.g. if you could do this you could prove there are countably many reals</p>",
        "id": 444800845,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718404564
    },
    {
        "content": "<p>if you wanted to do this you would need to use an entirely different data structure which allows inspection. For example... <code>Rat</code></p>",
        "id": 444800953,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718404642
    },
    {
        "content": "<p>If your goal is play with quaternions, defining (computable) functions, and inspecting results, I strongly suggest restricting to quaternions over rationals. If you really want to prove general theorems, you can use the “full” quaternions and these issues around eval are probably irrelevant.</p>",
        "id": 444801198,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1718404807
    },
    {
        "content": "<p>Yes, it seems the problem is harder than I first thought. I suppose the correct solution is not do things like <code>z:Real=5</code> when you don't need to use a real.</p>\n<p>On a different note. If I was going to format a Cauchy sequence do you think this is a good notation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"bp\">/</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">/</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"bp\">..⟩</span>\n</code></pre></div>\n<p>Also I notice that actually you can do <code>ℍ[Float]</code> but the + * operations don't seem to work on it.</p>",
        "id": 444801932,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718405354
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/How.20do.20you.20use.20the.20Quaternion.20type.3F/near/444800785\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>but presumably it's represented by a Cauchy sequence which contains an algorithm of how to get the next number.</p>\n</blockquote>\n<p>No, in lean functions cannot inspect the algorithms of their inputs, this would be unsound</p>\n</blockquote>\n<p>The instance is already <code>unsafe</code>, so this seems totally possible</p>",
        "id": 444802506,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718405731
    },
    {
        "content": "<p>Some more tests:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Quaternion</span><span class=\"w\"> </span><span class=\"n\">GaussianInt</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">reprPrec</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{repr q.re} + {repr q.imI}i + {repr q.imJ}j + {repr q.imK}k\"</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Quaternion</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Quaternion</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">reprPrec</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"({repr q.re}) + ({repr q.imI})I + ({repr q.imJ})J + ({repr q.imK})K\"</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">:</span><span class=\"n\">ℍ</span><span class=\"o\">[</span><span class=\"n\">ℤ</span><span class=\"o\">]:={</span><span class=\"n\">re</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imI</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imJ</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imK</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">}</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"n\">ℍ</span><span class=\"o\">[</span><span class=\"n\">ℍ</span><span class=\"o\">[</span><span class=\"n\">ℤ</span><span class=\"o\">]]:={</span><span class=\"n\">re</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imI</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imJ</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imK</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">}</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">GaussianInt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">re</span><span class=\"o\">:=</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"n\">im</span><span class=\"o\">:=</span><span class=\"mi\">5</span><span class=\"o\">}</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">:</span><span class=\"n\">ℍ</span><span class=\"o\">[</span><span class=\"n\">GaussianInt</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:={</span><span class=\"n\">re</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imI</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imJ</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">imK</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">}</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\">1 + 2i + 3j + 4k-/</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"c\">/-</span><span class=\"cm\">(1 + 2i + 3j + 4k) + (1 + 2i + 3j + 4k)I + (1 + 2i + 3j + 4k)J + (1 + 2i + 3j + 4k)K-/</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\">⟨3, 5⟩ + ⟨3, 5⟩i + ⟨3, 5⟩j + ⟨3, 5⟩k-/</span>\n</code></pre></div>\n<p>Not that <code>ℍ[ℍ[ℤ]]</code> is well defined but it's nice to know that nesting works.</p>",
        "id": 444803780,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718406571
    },
    {
        "content": "<p>If you want a challenge related to nested quaternion objects, you could formalize John Selig's results about exponentiation of dual quaternions (<code>DualNumber (Quaternion R)</code>)</p>",
        "id": 444804028,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718406737
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/How.20do.20you.20use.20the.20Quaternion.20type.3F/near/444802506\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/How.20do.20you.20use.20the.20Quaternion.20type.3F/near/444800785\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>but presumably it's represented by a Cauchy sequence which contains an algorithm of how to get the next number.</p>\n</blockquote>\n<p>No, in lean functions cannot inspect the algorithms of their inputs, this would be unsound</p>\n</blockquote>\n<p>The instance is already <code>unsafe</code>, so this seems totally possible</p>\n</blockquote>\n<p>It's also <del>impossible</del> difficult from a technical standpoint, there is no interface for introspecting on closure values. You could write one from scratch with a lot of care using C code. I did some work on that a while back, packaging lean objects into a lean_external object so they can be explicitly interacted with as data structures, but it's tricky to ensure that the reference counts are handled directly when the compiler is handling some but not all of the inc/dec stuff</p>",
        "id": 444805249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718407662
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/How.20do.20you.20use.20the.20Quaternion.20type.3F/near/444804028\">said</a>:</p>\n<blockquote>\n<p>If you want a challenge related to nested quaternion objects, you could formalize John Selig's results about exponentiation of dual quaternions (<code>DualNumber (Quaternion R)</code>)</p>\n</blockquote>\n<p>Only thing I know about dual numbers is they're a special case of Grassmann numbers which is used in supersymmetry calculations.  That would be a another nice case to formalise. The #eval for them would look like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">bθ₁</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">cθ₂</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">dθ₁θ₂</span>\n</code></pre></div>\n<p>for example. Maybe this is already possible as some subset of non-commutable algebra in Lean. Then we could define superfields like <code>φ(x,θ₁,θ₂)</code></p>",
        "id": 444808557,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718409597
    }
]