[
    {
        "content": "<p>is linarith expected to work on simple goals involving <code>Fin</code> terms? MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">linarith</span> <span class=\"c1\">-- no contradiction found</span>\n</code></pre></div>\n<p>I don't know how linarith works, it's just my default tactic for goals that feel linear.</p>\n<p>Aside: aesop also does not work here without marking <code>lt_trans</code> as an aesop lemma. Is this a bad idea to do locally (or in mathlib)?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">aesop</span> <span class=\"n\">unsafe</span> <span class=\"n\">apply</span><span class=\"o\">]</span> <span class=\"n\">lt_trans</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">aesop</span>\n</code></pre></div>",
        "id": 420144061,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707257117
    },
    {
        "content": "<p>The <code>&lt;</code> on <code>Fin n</code> is pathological in the sense that it does not play well with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>+</mo></mrow><annotation encoding=\"application/x-tex\">+</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">+</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>×</mo></mrow><annotation encoding=\"application/x-tex\">\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">×</span></span></span></span> (arithmetic), so I would very much doubt that <code>linarith</code> would work on <code>Fin n</code>. It seems to me that you want some kind of \"partial order\" or \"total order\" tactic, but I should think that you could knock one off yourself with <code>apply_rules</code> -- in fact there was a discussion about this recently (I'll try and find it) (it was <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Tactic.20for.20Order.20Relation/near/412711300\">here</a> )</p>",
        "id": 420155687,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707263515
    },
    {
        "content": "<p>This really should be in scope for <code>omega</code>...</p>",
        "id": 420167026,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1707270887
    },
    {
        "content": "<p>Here's a trick:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">revert</span> <span class=\"n\">n</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Fin.forall_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">intros</span>\n  <span class=\"n\">linarith</span>\n</code></pre></div>\n<p>(A <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60PNat.60.20version.20of.20.60Nat.2Esub_lt.60/near/416696260\">link</a> to related discussion)</p>",
        "id": 420171553,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707274404
    },
    {
        "content": "<p>Should there be a version of <code>zify</code> for subtypes?</p>",
        "id": 420180757,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707281252
    },
    {
        "content": "<p>In fact, maybe there should be a general <code>ambient_typify</code> tactic, takes a type <code>Y</code>, realizes the goal is about terms in type <code>X</code>, finds a coercion <code>X -&gt; Y</code>, and looks up suitable <code>norm_cast</code> lemmas to transform the goal into something about terms in type <code>Y</code>.</p>",
        "id": 420180881,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707281338
    },
    {
        "content": "<p>That would generalize <code>zify</code> and friends...</p>",
        "id": 420180892,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707281347
    },
    {
        "content": "<p>And then one could hope that a goal like in OP would be <code>ambient_typify Nat ; omega</code></p>",
        "id": 420180919,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707281385
    },
    {
        "content": "<p>(Which isn't to say that in this specific case <code>omega</code> shouldn't be able to close it on its own...)</p>",
        "id": 420181034,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707281429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Fin.20.3C.20automation/near/420180757\">said</a>:</p>\n<blockquote>\n<p>Should there be a version of <code>zify</code> for subtypes?</p>\n</blockquote>\n<p>I think that would be quite useful for CS proofing</p>",
        "id": 420185499,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707284875
    },
    {
        "content": "<p>Maybe <code>coerce</code> would be a better name than <code>ambient_typify</code>. Then <code>zify</code> would be spelled <code>coerce \\Z</code>.</p>",
        "id": 420191191,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707289084
    },
    {
        "content": "<p><code>coerce_to</code>, perhaps?  I don't know how feasible this would be to implement, but it would be a natural tool to have.</p>",
        "id": 420192748,
        "sender_full_name": "Terence Tao",
        "timestamp": 1707290129
    },
    {
        "content": "<p>Now that we have <code>zify</code>, <code>qify</code>, <code>rify</code>, it might be worth thinking about unifying those tactics.</p>",
        "id": 420196981,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707292498
    },
    {
        "content": "<p>The approach in general is to apply infectivity of the coercion then use <code>push_cast</code></p>",
        "id": 420200030,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707294045
    },
    {
        "content": "<p>And I've been asking for a similar tactic for the coercion <code>Finset α → Set α</code> for a while now.</p>",
        "id": 420211350,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707298494
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Fin.20.3C.20automation/near/420144061\">said</a>:</p>\n<blockquote>\n<p>Aside: aesop also does not work here without marking <code>lt_trans</code> as an aesop lemma. Is this a bad idea to do locally (or in mathlib)?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">aesop</span> <span class=\"n\">unsafe</span> <span class=\"n\">apply</span><span class=\"o\">]</span> <span class=\"n\">lt_trans</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">aesop</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Transitivity lemmas are no good as global Aesop rules because they always apply but are rarely useful. In other words, all your unsuccessful Aesop calls will time out after ~200 <code>lt_trans</code> applications.</p>\n<p>However, adding transitivity lemmas locally, when you know a specific theorem needs them, is fine:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">aesop</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"mi\">1</span><span class=\"bp\">%</span> <span class=\"n\">lt_trans</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 420220787,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1707301747
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Fin.20.3C.20automation/near/420200030\">said</a>:</p>\n<blockquote>\n<p>The approach in general is to apply infectivity of the coercion then use <code>push_cast</code></p>\n</blockquote>\n<p>If we want to do this, definitely look at the transfer tactics in other provers. I think a few are simply called <code>transfer</code> and also <a href=\"https://github.com/coq-community/trocq\"><code>trocq</code></a> is interesting.</p>",
        "id": 420224626,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1707302935
    },
    {
        "content": "<p>Another potential example not mentioned yet is <code>natify</code> to move from <code>PNat</code> to <code>Nat</code>, which I needed recently.</p>",
        "id": 420240445,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707308825
    },
    {
        "content": "<p>I guess that falls under the <code>Subtype</code> class?</p>",
        "id": 420255150,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707313547
    }
]