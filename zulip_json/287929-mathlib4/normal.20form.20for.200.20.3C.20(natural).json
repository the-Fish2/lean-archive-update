[
    {
        "content": "<p>I am confused. An early lesson in formalisation that you learn is that there are many implementations of one mathematical specification. In other words, if someone asks on the Zulip \"how do you prove [some mathematical statement written in human language or LaTeX]?\" then a good response is \"please can you write down the <em>statement</em> of what you want in Lean?\", because there are many ways of saying the same thing. </p>\n<p>For simple concepts the community has decided upon \"simp normal forms\". For example it's quite rare to see <code>a &gt; b</code> in mathlib, because the normal form for this mathematical idea is <code>b &lt; a</code>.</p>\n<p>However, if <code>n : Nat</code> then the concept of being positive, or equivalently non-zero, has arguably no simp normal form, and a section of the style guide <a href=\"https://leanprover-community.github.io/contribute/style.html#normal-forms\">https://leanprover-community.github.io/contribute/style.html#normal-forms</a> is specifically devoted to this issue, where the conclusion is that because it's easy to convert <code>a &lt; b</code> to <code>b ≠ a</code> and less easy the other way around (because it's false in general if a isn't 0), we should have <code>n ≠ 0</code> in hypotheses and <code>0 &lt; n</code> in conclusions. </p>\n<p>With that in mind, let me present <code>Ne.zero_lt</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">hn.ne'</span> <span class=\"c1\">-- easy</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.zero_lt_of_ne_zero</span> <span class=\"n\">hn</span> <span class=\"c1\">-- the pain!</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Ne.zero_lt</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.zero_lt_of_ne_zero</span> <span class=\"n\">hn</span> <span class=\"c1\">-- the fix</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">hn.zero_lt</span> <span class=\"c1\">-- now easy!</span>\n</code></pre></div>\n<p>As far as I can see, this completely blows a hole in the argument for our current funny convention, and we should just pick one rather than making things more complicated than they are.</p>\n<p>What am I missing?</p>",
        "id": 425779530,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710082436
    },
    {
        "content": "<p>Actually, we already have <code>Ne.zero_lt</code> in the form of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ne.bot_lt#doc\">docs#Ne.bot_lt</a></p>",
        "id": 425779661,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710082537
    },
    {
        "content": "<p>(I agree that's definitionally the same, and also not syntactically the same)</p>",
        "id": 425779774,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710082622
    },
    {
        "content": "<p>Syntactic equality is not a very big deal here since you usually feed those <code>hn.bot_lt</code> to some lemma that has a <code>0 &lt; n</code> assumption.</p>",
        "id": 425779827,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710082677
    },
    {
        "content": "<p>You can already see this pattern in mathlib quite a lot, btw!</p>",
        "id": 425779884,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710082697
    },
    {
        "content": "<p>This is why I don't really follow that part of the style guide. Instead, I usually have one lemma with <code>≠ 0</code> assumptions and a <code>≠ 0</code> conclusion and the same lemma with <code>0 &lt;</code> assumptions and a <code>0 &lt;</code> conclusion.</p>",
        "id": 425779899,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710082724
    },
    {
        "content": "<p>And same thing with <code>↔</code> lemmas.</p>",
        "id": 425779908,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710082738
    },
    {
        "content": "<p>Not necessarily a big deal, but this still does not work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">hn.zero_lt</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">invalid field notation, type is not of the form (C ...) where C is a constant</span>\n<span class=\"cm\">  hn</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  n = 0 → False</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 425780110,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710082893
    },
    {
        "content": "<p>It is important to have both versions because you often want to interface those lemmas with lemmas from some other API which might write everything in terms of <code>≠ 0</code> (if it's algebraic) or <code>0 &lt;</code> (if it's order theoretic)</p>",
        "id": 425780140,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710082922
    },
    {
        "content": "<p>So you're saying that the current suggestion in the style guide is not what is happening anyway?</p>",
        "id": 425781538,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710084051
    }
]