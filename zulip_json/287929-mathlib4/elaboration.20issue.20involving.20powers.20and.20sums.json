[
    {
        "content": "<p>The new elaborators of +, *, ^ work very well. I just encountered an example where it still got confused.<br>\nHere is a MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.BigOperators.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">_k</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"c\">/-</span><span class=\"cm\">: ℕ-/</span> <span class=\"c\">/-</span><span class=\"cm\">: ℤ-/</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n<span class=\"c1\">-- elaboration error. It works when adding either coercion around the power</span>\n<span class=\"c1\">-- the error still occurs when replacing x ^ 2 by y ^ 2</span>\n</code></pre></div>",
        "id": 439243587,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1715958827
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span></p>",
        "id": 439243631,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1715958840
    },
    {
        "content": "<p>Yes, <code>∑</code> is not currently considered an arithmetic operator</p>",
        "id": 439248590,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715960358
    },
    {
        "content": "<p>This is a big open question in the expression tree elaborator. Right now, there's no way for anything other than simple arithmetic operations to participate in the coercion calculation.</p>\n<p>We could perhaps develop a <code>bigop%</code> node to handle these sorts of expressions, to let the types propagate into and out of the body of a sum. But, adding operator types like this one at a time makes me worry that this expression tree elaborator will start to subsume all of elaboration.</p>\n<p>I've been wondering if elaboration needs a more sophisticated bidirectional protocol. The current setup is that the Syntax is recursively traversed to produce an Expr, and an expected type is propagated toward the leaves. (With the extra complication that elaboration problems can also defer processing by elaborating to a metavariable and registering some code to be run later.) Expected types are just a suggestion, and elaborators do not need to respect them.</p>\n<p>What could happen is that there be two phases, one that recursively traverses expressions to propagate expected types and then collect actual types (or at least what's likely going to be the actual type) and then another that then actually elaborates using this collected information.</p>\n<p>With <code>x = ∑ _k in s, y * x ^ 2</code>, the way it could work is that <code>=</code> does the first phase for both sides, discovering that the LHS is Nat and the RHS is Int. Since it's using the expression tree elaborator, it computes that everything coerces to <code>Int</code>, so commits to <code>Int</code> for both sides.</p>",
        "id": 439273862,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715970780
    },
    {
        "content": "<p>Here are two fixes for your original example by the way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">_k</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">_k</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"o\">:)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>For some reason <code>∑ _k in s, y * x ^ 2</code> doesn't realize it's an <code>Int</code> in time for elaboration of <code>Eq</code>. It might be a bug in the expression tree elaborator, I'll have to check...</p>",
        "id": 439273871,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715970783
    },
    {
        "content": "<p>Minimized:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">error: failed to synthesize instance</span>\n<span class=\"sd\">  HMul Int Int Nat</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- Succeeds</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"o\">:)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- Succeeds</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- Succeeds</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 439274335,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715971009
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/elaboration.20issue.20involving.20powers.20and.20sums/near/439273862\">said</a>:</p>\n<blockquote>\n<p>I've been wondering if elaboration needs a more sophisticated bidirectional protocol. The current setup is that the Syntax is recursively traversed to produce an Expr, and an expected type is propagated toward the leaves. (With the extra complication that elaboration problems can also defer processing by elaborating to a metavariable and registering some code to be run later.)</p>\n</blockquote>\n<p>Also recall that I have complained (and Mario agreed) that there is only one \"post-defer\" point, rather than several. It is a big complication in <a href=\"https://github.com/leanprover-community/mathlib4/pull/11582\">#11582</a> because overriding the <code>Set</code> builder notation with a <code>Finset</code> builder that waits for the type to be available makes the overriden <code>Set</code> notation also wait for the type, which causes elaboration failures.</p>",
        "id": 439274499,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715971084
    },
    {
        "content": "<p>My understanding so far is that it should be considered to be a bug in how <code>^</code> is handled.</p>\n<p>The issue is that it's deferring deciding which <code>^</code> to use until much later than it needs to. The following works, since it causes <code>^</code> to specialize.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 439276361,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715972013
    },
    {
        "content": "<p>I think I have a fix for this in <a href=\"https://github.com/leanprover/lean4/pull/4215\">lean4#4215</a>. The issue is that when the expression tree elaborator constructs the expression at the end of elaboration, it doesn't record the computed \"max type\" in the operators. So for example, while it decides that <code>y * x ^ 2</code> should be an <code>Int</code>, it was just remembering that the <code>HMul</code> is <code>Int -&gt; ?_ -&gt; ?_</code> since the <code>x ^ 2</code> hasn't resolved its instance yet. With this PR, it specializes <code>HMul</code> to <code>Int -&gt; Int -&gt; Int</code>. That then causes the elaborator for <code>=</code> to see that the RHS is an <code>Int</code>, and then it all works.</p>\n<p>Hopefully it's not premature saying that this is actually a fix. I'm still waiting on mathlib to compile <span aria-label=\"fingers crossed\" class=\"emoji emoji-1f91e\" role=\"img\" title=\"fingers crossed\">:fingers_crossed:</span></p>",
        "id": 439367219,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1716050041
    },
    {
        "content": "<p>This now works with <a href=\"https://github.com/leanprover/lean4/pull/4215\">lean4#4215</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">_k</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- ⊢ ↑x = ∑ _k ∈ s, y * ↑x ^ 2</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The rule is now: if all the leaf terms have known types and they can all be coerced to the same type, then the entire arithmetic expression is made to have that type. In this case, <code>y * x ^ 2</code> has leaf terms <code>y</code> and <code>x</code>, they both have known types (<code>Int</code> and <code>Nat</code>), they're both coerceable to <code>Int</code>, so, in the end, the <code>HMul</code> instance is <code>HMul Int ?_ Int</code> rather than <code>HMul Int ?_ ?_</code>.</p>",
        "id": 439380052,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1716063163
    }
]