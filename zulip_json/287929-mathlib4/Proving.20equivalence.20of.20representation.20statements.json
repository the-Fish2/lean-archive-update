[
    {
        "content": "<p><code>RepresentationTheory</code> has 3 (eh, mostly 2) ways of writing down a representation of a group G. Here are my notes I have on a paper, to make the rest of this question make more sense</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"mf\">1.</span><span class=\"w\"> </span><span class=\"n\">Rep</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">defined</span><span class=\"w\"> </span><span class=\"n\">categorically</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"ss\">`Action</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"ss\">`G</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">category</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"ss\">`MonCat</span><span class=\"bp\">`</span>\n<span class=\"mf\">2.</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">explicit</span><span class=\"w\"> </span><span class=\"n\">definition</span><span class=\"w\"> </span><span class=\"ss\">`G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"bp\">`</span>\n<span class=\"mf\">3.</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">[</span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"bp\">-</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">module</span><span class=\"w\"> </span><span class=\"n\">over</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">[</span><span class=\"n\">G</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"n\">written</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"bp\">`</span>\n\n<span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;=&gt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Rep</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"bp\">&gt;</span>\n<span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;=&gt;</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rep</span><span class=\"bp\">.</span><span class=\"n\">equivalenceModuleMonoidAlgebra</span>\n<span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">&lt;=&gt;</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"n\">Representation</span><span class=\"bp\">.</span><span class=\"n\">asModuleModule</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"bp\">.</span><span class=\"n\">ofModule</span><span class=\"bp\">&gt;</span>\n</code></pre></div>\n<p>(Oh also <code>FdRep</code> has another separate definition, an Action over a FGMod)</p>\n<p>To say a representation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding=\"application/x-tex\">\\rho</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ρ</span></span></span></span> is irreducible, for (1) <code>CategoryTheory.Simple</code> is used, and for (3) <code>RingTheory.IsSimpleModule</code> is used I believe. So now I want to prove they are the same thing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.RepresentationTheory.Character</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.RingTheory.RootsOfUnity.Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.RingTheory.SimpleModule</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.CategoryTheory.Simple</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">Rep.is_simple_iff_isSimpleModule</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rep</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nontrivial</span><span class=\"w\"> </span><span class=\"n\">V.V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Simple</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">IsSimpleModule</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">V.ρ.asModule</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n</code></pre></div>\n<p>I tried both directions for maybe 2/3 hours but can't get anywhere, so if someone can help that would be great <span aria-label=\"sweat\" class=\"emoji emoji-1f613\" role=\"img\" title=\"sweat\">:sweat:</span></p>",
        "id": 443465555,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1717851069
    },
    {
        "content": "<p>Here's my attempt on one direction =&gt;:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">Rep.isSimpleModule_of_Simple</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rep</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nontrivial</span><span class=\"w\"> </span><span class=\"n\">V.V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hV</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Simple</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">      </span><span class=\"n\">IsSimpleModule</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">V.ρ.asModule</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">obtain</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">hV</span><span class=\"o\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hV</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">IsSimpleOrder.mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toNontrivial</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">_</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> Nontrivial instance can't be inferred.. -/</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⊤</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ne_comm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Ne</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Submodule.eq_bot_iff</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">push_neg</span>\n<span class=\"w\">    </span><span class=\"n\">obtain</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"o\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">exists_ne</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V.V</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mem_top</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hy</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">W</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">W'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Rep.equivalenceModuleMonoidAlgebra.inverse.obj</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">ModuleCat.of</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">W</span>\n<span class=\"w\">    </span><span class=\"n\">specialize</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">hV</span><span class=\"w\"> </span><span class=\"n\">W'</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">W.subtype</span>\n<span class=\"w\">    </span><span class=\"c\">/-</span><span class=\"cm\"> So W.subtype gives a k[G]-linear hom (W →ₗ[k[G]] V.ρ.asModule) -/</span>\n<span class=\"w\">    </span><span class=\"c\">/-</span><span class=\"cm\"> But I want a (CT) morphism (W' : Rep k G) ⟶ V -/</span>\n</code></pre></div>",
        "id": 443465699,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1717851163
    },
    {
        "content": "<p>Can you make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ? I get errors if I just naively add the imports from the first code block into the second.</p>",
        "id": 443570911,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717919925
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.RepresentationTheory.Character</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.RingTheory.RootsOfUnity.Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.RingTheory.SimpleModule</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.CategoryTheory.Simple</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">LinearMap</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">FiniteDimensional</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"w\"> </span><span class=\"n\">Pointwise</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n<span class=\"w\">  </span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">JordanHolderModule</span>\n\n<span class=\"kd\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ζ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hζ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ζ</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">primitiveRoots</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Rep.smul_def</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ρ.asModule</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">      </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ρ.asAlgebraHom</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- Idk if this is useful but it exists</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">lift_rep_hom</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rep</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">V.ρ.asModule</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">W.ρ.asModule</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- I don't know how this works but if you remove any part of this e.g. try to</span>\n<span class=\"w\">  </span><span class=\"c1\">-- \"inline\" the f_mod definition into the use, it will fail!</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">f_mod</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V.ρ.asModule</span><span class=\"w\"> </span><span class=\"bp\">→+</span><span class=\"w\"> </span><span class=\"n\">W.ρ.asModule</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f.hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V.V</span><span class=\"w\"> </span><span class=\"bp\">→+</span><span class=\"w\"> </span><span class=\"n\">W.V</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">f_mod</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">_</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">obtain</span><span class=\"w\"> </span><span class=\"o\">⟨⟨</span><span class=\"n\">f'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hf'₁</span><span class=\"o\">⟩,</span><span class=\"w\"> </span><span class=\"n\">hf'₂</span><span class=\"o\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Rep.smul_def</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">asAlgebraHom</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lift_apply'</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">map_finsupp_sum</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">congr</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">  </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"n\">f'.toFun</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">W.ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f'.toFun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hf'₁</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">congr</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Rep.hom_comm_apply</span><span class=\"w\"> </span><span class=\"o\">⟨⟨</span><span class=\"n\">f'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hf'₁</span><span class=\"o\">⟩,</span><span class=\"w\"> </span><span class=\"n\">hf'₂</span><span class=\"o\">⟩</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"c1\">-- A (finite dimensional) kG-representation is simple if and only if it's a simple module over k</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">FdRep.is_simple_iff_isSemiSimple''</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FdRep</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Simple</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">IsSimpleModule</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Supposedly it should be unwrapping definitions and lifting morphisms between types</span>\n<span class=\"w\">  </span><span class=\"c1\">-- But uh</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 443573819,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1717922720
    },
    {
        "content": "<p>sorry for that, I got too frustrated and forgot</p>",
        "id": 443573827,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1717922733
    },
    {
        "content": "<p>Half-hearted start (I'm off to catch a train) but I agree this is a pain. Probably this API should be there. Mathlib, as you've pointed out, has several ways of defining representations and we need the API to go between them assuming we're not planning on nuking any of them (which we're not as far as I know)</p>",
        "id": 443578282,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717926816
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">RepresentationTheory</span><span class=\"bp\">.</span><span class=\"n\">Character</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">RingTheory</span><span class=\"bp\">.</span><span class=\"n\">RootsOfUnity</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">RingTheory</span><span class=\"bp\">.</span><span class=\"n\">SimpleModule</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Simple</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- missing API?</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">bot_eq_top_iff_subsingleton</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Subsingleton</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⟨?_⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mem_top</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mem_bot</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">eq_comm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mem_bot</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">mem_top</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n\n<span class=\"c1\">-- A (finite dimensional) kG-representation is simple if and only if it's a simple module over k</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">FdRep</span><span class=\"bp\">.</span><span class=\"n\">is_simple_iff_isSemiSimple''</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FdRep</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Simple</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">IsSimpleModule</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⟨?_⟩⟩</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nontrivial</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">exists_pair_ne</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨⊥</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">id_nonzero</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">      </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n<span class=\"w\">      </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Action</span><span class=\"bp\">.</span><span class=\"n\">id_hom</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">id_apply</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Action</span><span class=\"bp\">.</span><span class=\"n\">zero_hom</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">bot_eq_top_iff_subsingleton</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">⟩</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨?_⟩</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">M</span>\n<span class=\"w\">    </span><span class=\"c1\">-- now make M ⟶ V or V ⟶ V / M (possibly easier to show the latter is fd) and go from there</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">hY</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">    </span><span class=\"c1\">-- constructor, then grind it out? Use h to prove nontrivial V, and if f isn't 0 then</span>\n<span class=\"w\">    </span><span class=\"c1\">-- the image of f is not bot so it's top, and the kernel of f is bot because f is mono,</span>\n<span class=\"w\">    </span><span class=\"c1\">-- so f is an isomorphism by abelian category</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 443578287,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717926824
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.subsingleton_iff#doc\">docs#Submodule.subsingleton_iff</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=subsingleton_iff_bot_eq_top#doc\">docs#subsingleton_iff_bot_eq_top</a> for the first one.</p>",
        "id": 443578515,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1717927032
    },
    {
        "content": "<p>Though we are probably missing things like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">map_isZero_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">HasZeroMorphisms</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasZeroMorphisms</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PreservesZeroMorphisms</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Faithful</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsZero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">IsZero</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsZero</span><span class=\"bp\">.</span><span class=\"n\">iff_id_eq_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsZero</span><span class=\"bp\">.</span><span class=\"n\">iff_id_eq_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map_id</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map_eq_zero_iff</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"n\">isZero_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsZero</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Subsingleton</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">subsingleton</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">    </span><span class=\"o\">((</span><span class=\"n\">forget</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mapIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">iso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">isZero_of_subsingleton</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"o\">))))</span><span class=\"bp\">.</span><span class=\"n\">toEquiv</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subsingleton</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">isZero_of_subsingleton</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">FdRep</span><span class=\"bp\">.</span><span class=\"n\">isZero_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FdRep</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsZero</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Subsingleton</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">forget₂</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FdRep</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FGModuleCat</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">map_isZero_iff</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FGModuleCat</span><span class=\"bp\">.</span><span class=\"n\">forget₂Monoidal</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_isZero_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"n\">isZero_iff</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FdRep</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Simple</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nontrivial</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">not_subsingleton_iff_nontrivial</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">FdRep</span><span class=\"bp\">.</span><span class=\"n\">isZero_iff</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Simple</span><span class=\"bp\">.</span><span class=\"n\">not_isZero</span><span class=\"w\"> </span><span class=\"n\">V</span>\n</code></pre></div>",
        "id": 443581213,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1717928531
    },
    {
        "content": "<p>I've said this before elsewhere but I'd encourage anyone thinking about our group representation API to consider the following alternate design (which would replace <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Representation#doc\">docs#Representation</a>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">RepresentationTheory</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">GroupRepresentation</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">SMulCommClass</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">smul_add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"c1\">-- Or maybe even:</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">GroupRepresentation'</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DistribSMul</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">SMulCommClass</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span>\n</code></pre></div>\n<p>This is the approach taken in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LieModule#doc\">docs#LieModule</a> and seems to have worked nicely there.</p>",
        "id": 446429195,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1719155665
    },
    {
        "content": "<p>The only potential problem I see would be the case when <code>R = G</code> since there would be two scalar actions on <code>M</code> but with the typeclasses I have proposed, this cannot thappen.</p>",
        "id": 446429345,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1719155728
    },
    {
        "content": "<p>I think this can happen because unfortunately the trivial ring is a group. This could be fixed by demanding that R is nontrivial, as a nontrivial group can't have a 0.</p>\n<p>I'm motivated to make this refactor because I have a Masters student developing the representation theory of locally profinite groups, and if it happens then the sooner the better. R could still be a <code>CommSemiring</code> as far as I can see, but the other big change, namely that G is no longer allowed to be a monoid (stopping G = R from being possible), is somehow nontrivial. Do we actually care about representations of monoids? The reason I like this approach is that I personally don't think I care about such things, but adding sane hypotheses like R != 0 and G is a group might upset some of the generalists among us, who will observe that the original definition works fine in this case. This might be true but do we ever need it in practice? If people actually about representations of monoids then this might be a blocker.</p>",
        "id": 448297462,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1719831881
    },
    {
        "content": "<p>Another question: why</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">GroupRepresentation'</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DistribSMul</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">SMulCommClass</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span>\n</code></pre></div>\n<p>? How about</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">GroupRepresentation'</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DistribMulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">SMulCommClass</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span>\n</code></pre></div>\n<p>? Does <code> [MulAction G M] [DistribSMul G M] </code> create a diamond for <code>SMul G M</code>?</p>",
        "id": 448299195,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1719832432
    },
    {
        "content": "<p>I think that the theory of representations of <em>general</em> monoids is just really hard and not much has been done.  In simple cases, there are ad hoc methods where you can pretend that you are dealing with representations of a close-by group.  <a href=\"https://mathoverflow.net/questions/37115/why-arent-representations-of-monoids-studied-so-much\">This MO question</a> gives some examples.</p>",
        "id": 448299402,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1719832500
    },
    {
        "content": "<p>But the question is: do we literally stop people from being able to talk about representations of monoids? Pros: all the worries about k = G go away. Cons: we can't talk about representations of monoids any more.</p>",
        "id": 448300788,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1719832886
    },
    {
        "content": "<p>I suspect that no one has effectively used representations of monoids.  Maybe, when there is an interest, whoever needs to weaken the assumptions <code>Group --&gt; Monoid</code> can think about how to do it?</p>",
        "id": 448301673,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1719833107
    },
    {
        "content": "<p>I feel that this is one of these situations where, in informal maths you say \"this is all the same for monoids\".  In reality, it is not true, but since your monoid was <code>Nat</code>, it is actually true.</p>",
        "id": 448301948,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1719833175
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proving.20equivalence.20of.20representation.20statements/near/448301673\">said</a>:</p>\n<blockquote>\n<p>I suspect that no one has effectively used representations of monoids.</p>\n</blockquote>\n<p>This is referencing mathlib right?</p>",
        "id": 448349932,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1719844369
    },
    {
        "content": "<p>I've remembered the diamond that this introduces: if R acts on M then so does the unit group R^x, so there are problems if G=R^x. In Iwasawa you have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi mathvariant=\"double-struck\">Z</mi><mi>p</mi><mi>x</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">\\Z_p^x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.072em;vertical-align:-0.3831em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-2.453em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3831em;\"><span></span></span></span></span></span></span></span></span></span> acting on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\Z_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>-modules in a nontrivial way :-/</p>",
        "id": 448353249,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1719845132
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proving.20equivalence.20of.20representation.20statements/near/448349932\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Proving.20equivalence.20of.20representation.20statements/near/448301673\">said</a>:</p>\n<blockquote>\n<p>I suspect that no one has effectively used representations of monoids.</p>\n</blockquote>\n<p>This is referencing mathlib right?</p>\n</blockquote>\n<p>Yes, I meant in mathlib.</p>\n<p>I find it hard to express the concept, but I would like to say that no one has really needed representations of non-group monoids in mathlib.</p>",
        "id": 448382610,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1719851786
    }
]