[
    {
        "content": "<p>When defining the predicates of <code>PBInequality</code>, I can just prove that it holds for a value:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.BigOperators.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fin.Tuple.Reflection</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fin.VecNotation</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">FinVec</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">PBInequality</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">cs</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">cs</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">xs</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">≥</span> <span class=\"n\">const</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">PBInequality</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- Change goal to 1 * 0 + 2 * 1 ≥ 2</span>\n  <span class=\"n\">reduce</span>\n  <span class=\"c1\">-- Prove 1 * 0 + 2 * 1 ≥ 2</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Int.le_refl</span> <span class=\"mi\">2</span>\n  <span class=\"n\">done</span>\n</code></pre></div>\n<p>What is really interesting is working with the PB's where the <code>xs</code> are not static, but a parameter. In this sense, I would prefer to work with non declared xs, and provide values later. However, while trying to prove for this specfic case, I stumbled upon a simple, but annoying problem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">xs</span> <span class=\"o\">,(</span><span class=\"n\">PBInequality</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"n\">xs</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">PBInequality</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"n\">xs</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">have</span> <span class=\"n\">heq</span> <span class=\"o\">:</span> <span class=\"n\">xs</span> <span class=\"bp\">=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">heq</span><span class=\"o\">]</span>\n    <span class=\"n\">reduce</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Int.le_refl</span> <span class=\"mi\">2</span>\n    <span class=\"n\">done</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n  <span class=\"n\">done</span>\n</code></pre></div>\n<p>This is what I got so far while proving it holds for some <code>xs</code>. The problem is that I first defined <code>xs</code> to be <code>![0,1]</code>, but inside the <code>h</code> definition I need to recover a proof that <code>xs = ![0,1]</code>. This may sound silly, what is the proper way to solve this?</p>",
        "id": 434450727,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1713570064
    },
    {
        "content": "<p>Use <code>let xs</code> instead of <code>have xs</code>.</p>",
        "id": 434478581,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713598043
    },
    {
        "content": "<p>This should raise an automatic warning in development, if the linter at <a href=\"https://github.com/leanprover-community/mathlib4/pull/12190\">#12190</a> makes it to mathlib.</p>",
        "id": 434485483,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713604839
    },
    {
        "content": "<p>Changing to <code>let</code> is working, but I don't know exactly why. I'll guess that a <code>have</code> is not a binding in the same sense</p>",
        "id": 434497788,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1713616673
    },
    {
        "content": "<p><code>have a : T := b</code> only remembers that <code>a : T</code>, it doesn't remember <code>b</code>. You can see the difference in the infoview.</p>",
        "id": 434514895,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713629726
    },
    {
        "content": "<p>is there a reason why you don't want to just add the first as a (private or protected) lemma <code>lem : PBInequailty ![1,2] ![0,1] 2</code>, then use</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span>  <span class=\"bp\">∃</span> <span class=\"n\">xs</span> <span class=\"o\">,(</span><span class=\"n\">PBInequality</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"n\">xs</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">],</span> <span class=\"n\">lem</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 434521210,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1713635337
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"671510\">Bernardo Borges</span> has marked this topic as resolved.</p>",
        "id": 434808289,
        "sender_full_name": "Notification Bot",
        "timestamp": 1713807438
    }
]