[
    {
        "content": "<p>I am wondering what parts of the API for types should be mirrored for <code>FintypeCat</code>. Certainly its preferable to create the API for <code>ConcreteCategory</code> instead, but I can't make this specialize to <code>FintypeCat</code>. Example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ConcreteCategory</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">≅</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">local</span> <span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">ConcreteCategory.hasCoeToSort</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">local</span> <span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">ConcreteCategory.instFunLike</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">FunctorToConcrete.map_inv_map_hom_apply</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f.inv</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f.hom</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">comp_apply</span><span class=\"o\">]</span>\n  <span class=\"k\">show</span> <span class=\"bp\">⇑</span><span class=\"o\">((</span><span class=\"n\">F.mapIso</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">F.mapIso</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Iso.hom_inv_id</span><span class=\"o\">,</span> <span class=\"n\">id_apply</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">FintypeCat</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">≅</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">F.map</span> <span class=\"n\">f.inv</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f.hom</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- erw [FunctorToConcrete.map_inv_map_hom_apply F f x] fails</span>\n  <span class=\"c1\">-- rw [FunctorToConcrete.map_inv_map_hom_apply F f x] fails</span>\n  <span class=\"c1\">-- simp only [FunctorToConcrete.map_inv_map_hom_apply F f x] fails</span>\n  <span class=\"c1\">-- simp does not make progress</span>\n  <span class=\"n\">exact</span> <span class=\"n\">FunctorToConcrete.map_inv_map_hom_apply</span> <span class=\"n\">F</span> <span class=\"n\">f</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>Is this expected? Can I make this work?</p>",
        "id": 420822170,
        "sender_full_name": "Christian Merten",
        "timestamp": 1707589649
    },
    {
        "content": "<p>I’m not sure what you mean about this not specializing to FintypeCat….</p>",
        "id": 420822462,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707589880
    },
    {
        "content": "<p>Do these lemmas not work when D is FintypeCat?</p>",
        "id": 420822483,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707589903
    },
    {
        "content": "<p>The lemma works, but the general simp lemma, stated for concrete categories, is not applied by <code>simp</code> when <code>D</code> is <code>FintypeCat</code>, note that even explicitly using it with <code>simp only [..]</code> does not work.</p>",
        "id": 420822573,
        "sender_full_name": "Christian Merten",
        "timestamp": 1707589974
    },
    {
        "content": "<p>That’s annoying…</p>",
        "id": 420822596,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707590005
    },
    {
        "content": "<p>Can you trace the simp to see why it fails?</p>",
        "id": 420822602,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707590015
    },
    {
        "content": "<p>That's what I tried to demonstrate with the <code>example</code> above.</p>",
        "id": 420822618,
        "sender_full_name": "Christian Merten",
        "timestamp": 1707590029
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/FintypeCat.20API/near/420822602\">said</a>:</p>\n<blockquote>\n<p>Can you trace the simp to see why it fails?</p>\n</blockquote>\n<p>How do I do this?</p>",
        "id": 420822635,
        "sender_full_name": "Christian Merten",
        "timestamp": 1707590038
    },
    {
        "content": "<p>set_option trace.Meta.Simp true (if i remember the name of the option correctly… I’m on mobile right now)</p>",
        "id": 420822921,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707590274
    },
    {
        "content": "<p>I found it: Its <code>set_option trace.Meta.Tactic.simp true</code>.<br>\nThe following code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.simp</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">FintypeCat</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">≅</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">F.map</span> <span class=\"n\">f.inv</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f.hom</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">FunctorToConcrete.map_inv_map_hom_apply</span> <span class=\"n\">F</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>yields</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">▶</span> <span class=\"mi\">45</span><span class=\"o\">:</span><span class=\"mi\">3</span><span class=\"bp\">-</span><span class=\"mi\">45</span><span class=\"o\">:</span><span class=\"mi\">60</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span>\n<span class=\"n\">simp</span> <span class=\"n\">made</span> <span class=\"n\">no</span> <span class=\"n\">progress</span>\n\n<span class=\"bp\">▶</span> <span class=\"mi\">45</span><span class=\"o\">:</span><span class=\"mi\">3</span><span class=\"bp\">-</span><span class=\"mi\">45</span><span class=\"o\">:</span><span class=\"mi\">60</span><span class=\"o\">:</span> <span class=\"n\">information</span><span class=\"o\">:</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.unify</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">eq_self</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">unify</span>\n      <span class=\"bp\">?</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">?</span><span class=\"n\">a</span>\n    <span class=\"k\">with</span>\n      <span class=\"n\">F.toPrefunctor.map</span> <span class=\"n\">f.inv</span> <span class=\"o\">(</span><span class=\"n\">F.toPrefunctor.map</span> <span class=\"n\">f.hom</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 420823537,
        "sender_full_name": "Christian Merten",
        "timestamp": 1707590799
    },
    {
        "content": "<p>I guess that means the only thing <code>simp</code> tried is <code>rfl</code>?</p>",
        "id": 420823844,
        "sender_full_name": "Christian Merten",
        "timestamp": 1707591072
    },
    {
        "content": "<p>Hmmm…</p>",
        "id": 420823970,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707591135
    },
    {
        "content": "<p>What happens if you explicitly specify universes?</p>",
        "id": 420824005,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707591165
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.ConcreteCategory#doc\">docs#CategoryTheory.ConcreteCategory</a></p>",
        "id": 420824033,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707591191
    },
    {
        "content": "<p>Same result:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">FunctorToConcrete.map_inv_map_hom_apply</span>\n\n<span class=\"n\">CategoryTheory.FunctorToConcrete.map_inv_map_hom_apply.</span><span class=\"o\">{</span><span class=\"n\">u_5</span><span class=\"o\">,</span> <span class=\"n\">u_4</span><span class=\"o\">,</span> <span class=\"n\">u_3</span><span class=\"o\">,</span> <span class=\"n\">u_2</span><span class=\"o\">,</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">u_5</span><span class=\"o\">,</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"bp\">✝¹</span> <span class=\"o\">:</span> <span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">u_3</span><span class=\"o\">,</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"bp\">✝²</span> <span class=\"o\">:</span> <span class=\"n\">ConcreteCategory</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">≅</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">forget</span> <span class=\"n\">D</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toPrefunctor.obj</span> <span class=\"o\">(</span><span class=\"n\">F.toPrefunctor.obj</span> <span class=\"n\">X</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">F.toPrefunctor.map</span> <span class=\"n\">f.inv</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">F.toPrefunctor.map</span> <span class=\"n\">f.hom</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>Specifiyng all universes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">FintypeCat.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">})</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">≅</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">F.map</span> <span class=\"n\">f.inv</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f.hom</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- exact FunctorToConcrete.map_inv_map_hom_apply.{u₂, w, w, w+1, u₁} F f x works</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">FunctorToConcrete.map_inv_map_hom_apply.</span><span class=\"o\">{</span><span class=\"n\">u₂</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"n\">F</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>yields the same trace.</p>",
        "id": 420824381,
        "sender_full_name": "Christian Merten",
        "timestamp": 1707591472
    },
    {
        "content": "<p>Does lean even find the concrete category instance?</p>",
        "id": 420824705,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707591688
    },
    {
        "content": "<p>Yes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">ConcreteCategory.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">FintypeCat.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span>\n\n<span class=\"bp\">▶</span> <span class=\"mi\">45</span><span class=\"o\">:</span><span class=\"mi\">1</span><span class=\"bp\">-</span><span class=\"mi\">45</span><span class=\"o\">:</span><span class=\"mi\">51</span><span class=\"o\">:</span> <span class=\"n\">information</span><span class=\"o\">:</span>\n<span class=\"n\">FintypeCat.concreteCategoryFintype</span>\n</code></pre></div>",
        "id": 420824790,
        "sender_full_name": "Christian Merten",
        "timestamp": 1707591748
    },
    {
        "content": "<p>It must be related to the function coercions: Even when replacing every occurence of <code>D</code> in the simp lemma with <code>FintypeCat</code>, it still does not work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">FintypeCat.map_inv_map_hom_apply</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">FintypeCat.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">})</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">≅</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f.inv</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f.hom</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">comp_apply</span><span class=\"o\">]</span>\n  <span class=\"k\">show</span> <span class=\"bp\">⇑</span><span class=\"o\">((</span><span class=\"n\">F.mapIso</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">F.mapIso</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Iso.hom_inv_id</span><span class=\"o\">,</span> <span class=\"n\">id_apply</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">FintypeCat.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">})</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">≅</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">F.map</span> <span class=\"n\">f.inv</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f.hom</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">FintypeCat.map_inv_map_hom_apply</span> <span class=\"n\">F</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"c1\">-- fails with the same trace</span>\n</code></pre></div>\n<p>When removing the explicit <code>⇑</code> coercions (which are not needed in the <code>FintypeCat</code> case), it works. But for general concrete categories the simp lemma can't be stated without <code>⇑</code> (or at least I did not succeed in doing so).</p>",
        "id": 420826280,
        "sender_full_name": "Christian Merten",
        "timestamp": 1707592755
    },
    {
        "content": "<p>This is a bit minimized:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">FintypeCat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"bp\">⇑</span><span class=\"n\">g</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">--fails</span>\n</code></pre></div>\n<p>Probably this is expected, but it makes working in <code>FintypeCat</code> horrible without copying every API lemma from the category of types.</p>",
        "id": 420827116,
        "sender_full_name": "Christian Merten",
        "timestamp": 1707593551
    },
    {
        "content": "<p>Maybe your bundled function approach would also make this less annoying?</p>",
        "id": 420827401,
        "sender_full_name": "Christian Merten",
        "timestamp": 1707593818
    },
    {
        "content": "<p>Yeah I think that’s the issue here</p>",
        "id": 420828004,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707594443
    }
]