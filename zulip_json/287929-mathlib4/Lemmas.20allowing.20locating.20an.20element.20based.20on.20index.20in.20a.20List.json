[
    {
        "content": "<p>Given a Nodup List <code>l</code> and two elements <code>i</code> and <code>j</code> that are both members of the list, we know that we can split <code>l</code> into <code>l = fr ++ j :: tail</code>. Assume <code>i</code>'s index is less than <code>j</code> in <code>l</code>, we can be sure that <code>i</code> is in <code>fr</code>. This can be stated in the attached lemma. </p>\n<p>I'm wondering if there is a way to get this result within one/two steps; if not is it worth adding to mathlib?</p>\n<p>The context is that I need to construct a swap of two elements in a list based off their indices.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">List.mem_front_of_index</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"n\">fr</span> <span class=\"n\">jtail</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_nd</span><span class=\"o\">:</span> <span class=\"n\">List.Nodup</span> <span class=\"o\">(</span><span class=\"n\">fr</span> <span class=\"bp\">++</span> <span class=\"n\">j</span> <span class=\"o\">::</span> <span class=\"n\">jtail</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">fr</span> <span class=\"bp\">++</span> <span class=\"n\">j</span> <span class=\"o\">::</span> <span class=\"n\">jtail</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hij</span><span class=\"o\">:</span> <span class=\"n\">List.indexOf</span> <span class=\"n\">i</span> <span class=\"n\">l</span> <span class=\"bp\">&lt;</span> <span class=\"n\">List.indexOf</span> <span class=\"n\">j</span> <span class=\"n\">l</span><span class=\"o\">):</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">fr</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 435027131,
        "sender_full_name": "Zhuanhao Wu",
        "timestamp": 1713891132
    },
    {
        "content": "<p>I'm working on now...</p>",
        "id": 435201997,
        "sender_full_name": "Pol'tta / Miyahara Kō",
        "timestamp": 1713968662
    },
    {
        "content": "<p>Done!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">List</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_front_of_index</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"n\">fr</span> <span class=\"n\">jtail</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hnd</span> <span class=\"o\">:</span> <span class=\"n\">Nodup</span> <span class=\"o\">(</span><span class=\"n\">fr</span> <span class=\"bp\">++</span> <span class=\"n\">j</span> <span class=\"o\">::</span> <span class=\"n\">jtail</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">hl</span> <span class=\"o\">:</span> <span class=\"n\">fr</span> <span class=\"bp\">++</span> <span class=\"n\">j</span> <span class=\"o\">::</span> <span class=\"n\">jtail</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hidx</span> <span class=\"o\">:</span> <span class=\"n\">indexOf</span> <span class=\"n\">i</span> <span class=\"n\">l</span> <span class=\"bp\">&lt;</span> <span class=\"n\">indexOf</span> <span class=\"n\">j</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">fr</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">subst</span> <span class=\"n\">hl</span>\n  <span class=\"n\">by_contra</span> <span class=\"n\">hnm</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nodup_append</span><span class=\"o\">,</span> <span class=\"n\">disjoint_cons_right</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hnd</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">indexOf_append_of_not_mem</span> <span class=\"n\">hnm</span><span class=\"o\">,</span> <span class=\"n\">indexOf_append_of_not_mem</span> <span class=\"n\">hnd.2.2.1</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hidx</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">List</span>\n</code></pre></div>",
        "id": 435220077,
        "sender_full_name": "Pol'tta / Miyahara Kō",
        "timestamp": 1713972978
    },
    {
        "content": "<p>Thanks! this is much cleaner than what I could have done!</p>",
        "id": 435223026,
        "sender_full_name": "Zhuanhao Wu",
        "timestamp": 1713973892
    }
]