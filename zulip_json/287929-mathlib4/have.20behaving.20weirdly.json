[
    {
        "content": "<p>Hi all,</p>\n<p>I've noticed recently that sometimes, when I write <code>have h := SomeLemma</code> as an intermediate step in a proof, sometimes Lean goes a step too far in filling in assumptions for the have. For instance, in the following def, when I try to work with <code>Equiv.ofBijective </code>, the tactic state assumes that the function is already bijective and produces an equivalence without me providing a proof. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.FiniteDimensional</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">Classical</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">isoThing</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"bp\">¬</span> <span class=\"n\">Submodule.map</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.inr</span> <span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">⊤</span> <span class=\"bp\">≤</span> <span class=\"n\">X</span><span class=\"o\">})</span> <span class=\"o\">:</span>\n  <span class=\"n\">r</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">Submodule.map</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.fst</span> <span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h4</span> <span class=\"o\">:=</span> <span class=\"n\">Equiv.ofBijective</span> <span class=\"o\">((</span><span class=\"n\">LinearMap.fst</span> <span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"n\">K</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">restrict</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">r.1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">Submodule.mem_map_of_mem</span> <span class=\"n\">hx</span><span class=\"o\">))</span>\n\n    <span class=\"gr\">sorry</span>\n\n  <span class=\"n\">apply</span> <span class=\"n\">Equiv.toLinearEquiv</span> <span class=\"n\">h4</span>\n\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>If I instead provide it with a hole, <code>?_</code>, it gives me the correct goal in the tactic state, but goes a step further and h4 becomes a term of type <code>↥(Submodule.map (LinearMap.fst K V K) ↑r)</code>, as if I evaluated the equivalence at some element of the submodule, and which gives me an error when I try to apply it to my goal with <code>Equiv.toLinearEquiv</code>.</p>",
        "id": 439293109,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1715980734
    },
    {
        "content": "<p>Here is the tactic state without the hole</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">**</span><span class=\"n\">V</span><span class=\"bp\">**</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n<span class=\"bp\">**</span><span class=\"n\">K</span><span class=\"bp\">**</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">**</span><span class=\"n\">inst</span><span class=\"bp\">✝²**</span> <span class=\"o\">:</span> <span class=\"n\">Field</span> <span class=\"n\">K</span>\n<span class=\"bp\">**</span><span class=\"n\">inst</span><span class=\"bp\">✝¹**</span> <span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span>\n<span class=\"bp\">**</span><span class=\"n\">inst</span><span class=\"bp\">✝**</span> <span class=\"o\">:</span> <span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span>\n<span class=\"bp\">**</span><span class=\"n\">r</span><span class=\"bp\">**</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"bp\">|</span> <span class=\"bp\">¬</span><span class=\"n\">Submodule.map</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.inr</span> <span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">⊤</span> <span class=\"bp\">≤</span> <span class=\"n\">X</span><span class=\"o\">}</span>\n<span class=\"bp\">**</span><span class=\"n\">h4</span><span class=\"bp\">**</span> <span class=\"o\">:</span> <span class=\"bp\">↥↑</span><span class=\"n\">r</span> <span class=\"bp\">≃</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Submodule.map</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.fst</span> <span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">↑</span><span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"bp\">**⊢**</span> <span class=\"bp\">↥↑</span><span class=\"n\">r</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Submodule.map</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.fst</span> <span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">↑</span><span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"n\">Expected</span> <span class=\"n\">type</span>\n<span class=\"bp\">**</span><span class=\"n\">V</span><span class=\"bp\">**</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n<span class=\"bp\">**</span><span class=\"n\">K</span><span class=\"bp\">**</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">**</span><span class=\"n\">inst</span><span class=\"bp\">✝²**</span> <span class=\"o\">:</span> <span class=\"n\">Field</span> <span class=\"n\">K</span>\n<span class=\"bp\">**</span><span class=\"n\">inst</span><span class=\"bp\">✝¹**</span> <span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span>\n<span class=\"bp\">**</span><span class=\"n\">inst</span><span class=\"bp\">✝**</span> <span class=\"o\">:</span> <span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span>\n<span class=\"bp\">**</span><span class=\"n\">r</span><span class=\"bp\">**</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"bp\">|</span> <span class=\"bp\">¬</span><span class=\"n\">Submodule.map</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.inr</span> <span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">⊤</span> <span class=\"bp\">≤</span> <span class=\"n\">X</span><span class=\"o\">}</span>\n<span class=\"bp\">**⊢**</span> <span class=\"bp\">↥↑</span><span class=\"n\">r</span> <span class=\"bp\">→</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Submodule.map</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.fst</span> <span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">↑</span><span class=\"n\">r</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and here's the tactic state with the hole</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"mi\">2</span> <span class=\"n\">goals</span>\n<span class=\"n\">case</span> <span class=\"n\">refine_2</span>\n<span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n<span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝²</span> <span class=\"o\">:</span> <span class=\"n\">Field</span> <span class=\"n\">K</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝¹</span> <span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span>\n<span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"bp\">|</span> <span class=\"bp\">¬</span><span class=\"n\">Submodule.map</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.inr</span> <span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">⊤</span> <span class=\"bp\">≤</span> <span class=\"n\">X</span><span class=\"o\">}</span>\n<span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Submodule.map</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.fst</span> <span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">↑</span><span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">↥↑</span><span class=\"n\">r</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Submodule.map</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.fst</span> <span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">↑</span><span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"n\">case</span> <span class=\"n\">refine_1</span>\n<span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n<span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝²</span> <span class=\"o\">:</span> <span class=\"n\">Field</span> <span class=\"n\">K</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝¹</span> <span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span>\n<span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"bp\">|</span> <span class=\"bp\">¬</span><span class=\"n\">Submodule.map</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.inr</span> <span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">⊤</span> <span class=\"bp\">≤</span> <span class=\"n\">X</span><span class=\"o\">}</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">Function.Bijective</span> <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">LinearMap.restrict</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.fst</span> <span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"n\">Messages</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">mwe2.lean</span><span class=\"o\">:</span><span class=\"mi\">17</span><span class=\"o\">:</span><span class=\"mi\">28</span>\n<span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">Equiv.toLinearEquiv</span> <span class=\"n\">h4</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">h4</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Submodule.map</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.fst</span> <span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">↑</span><span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.6769</span> <span class=\"bp\">≃</span> <span class=\"bp\">?</span><span class=\"n\">m.6770</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"bp\">?</span><span class=\"n\">u.6766</span> <span class=\"bp\">?</span><span class=\"n\">u.6767</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 439293540,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1715981000
    },
    {
        "content": "<p>My version is <code>leanprover/lean4:v4.6.0-rc1</code> if that helps, I'm wondering if it's just some updating/version error</p>",
        "id": 439293727,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1715981111
    },
    {
        "content": "<p>Isn't the first sorry filling in the bijective goal?</p>",
        "id": 439295464,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1715982153
    },
    {
        "content": "<p>I'm not really sure - when I click the line before it, the infoview still shows the main goal</p>",
        "id": 439295835,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1715982371
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/287929-mathlib4/topic/have.20behaving.20weirdly/near/439295464\">said</a>:</p>\n<blockquote>\n<p>Isn't the first sorry filling in the bijective goal?</p>\n</blockquote>\n<p>Okay yeah I think you're right, my bad. Still getting used to lean 4 not using commas for things</p>",
        "id": 439298842,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1715984192
    }
]