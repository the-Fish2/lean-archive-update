[
    {
        "content": "<p>i'd like to prove a variant of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearEquiv.automorphismGroup#doc\">docs#LinearEquiv.automorphismGroup</a> where semilinear equivalences with automorphisms on <code>R</code> are also considered... <br>\nMy current approach uses <code>Sigma</code> to describe the space as <code>(σ:RingAut R) × (@LinearEquiv R R _ _ (σ) (σ.symm)\n      (RingHomInvPair.of_ringEquiv σ)\n      (RingHomInvPair.of_ringEquiv σ).symm) M M</code> (lean needs some help to realise that ringauts have inverses and the like)</p>\n<p>i am almost done, but i am having trouble closing one last goal...</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Module.Equiv</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">SemilinearAut</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n    <span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"o\">:</span><span class=\"n\">RingAut</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearEquiv</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">σ.symm</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">RingHomInvPair.of_ringEquiv</span> <span class=\"n\">σ</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">RingHomInvPair.of_ringEquiv</span> <span class=\"n\">σ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">M</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]:</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">SemilinearAut</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">σ₁</span><span class=\"o\">,</span><span class=\"n\">f₁</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">σ₂</span><span class=\"o\">,</span><span class=\"n\">f₂</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">σ₂.trans</span> <span class=\"n\">σ₁</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LinearEquiv.trans</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">b</span> <span class=\"n\">b</span>\n    <span class=\"n\">c</span> <span class=\"n\">c</span> <span class=\"n\">c</span> <span class=\"n\">σ₂</span> <span class=\"n\">σ₁</span> <span class=\"o\">(</span><span class=\"n\">σ₂.trans</span> <span class=\"n\">σ₁</span><span class=\"o\">)</span> <span class=\"n\">σ₂.symm</span> <span class=\"n\">σ₁.symm</span> <span class=\"o\">(</span><span class=\"n\">σ₂.trans</span> <span class=\"n\">σ₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">⟨</span><span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">RingEquiv.coe_ringHom_trans</span> <span class=\"n\">σ₂</span> <span class=\"n\">σ₁</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n    <span class=\"o\">(</span><span class=\"n\">RingHomInvPair.of_ringEquiv</span> <span class=\"n\">σ₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">RingHomInvPair.of_ringEquiv</span> <span class=\"n\">σ₁</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">RingHomInvPair.of_ringEquiv</span> <span class=\"o\">(</span><span class=\"n\">σ₂.trans</span> <span class=\"n\">σ₁</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">RingHomInvPair.of_ringEquiv</span> <span class=\"n\">σ₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">RingHomInvPair.of_ringEquiv</span> <span class=\"n\">σ₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n    <span class=\"o\">(</span><span class=\"n\">RingHomInvPair.of_ringEquiv</span> <span class=\"o\">(</span><span class=\"n\">σ₂.trans</span> <span class=\"n\">σ₁</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n    <span class=\"o\">)</span> <span class=\"n\">f₂</span> <span class=\"n\">f₁</span><span class=\"o\">⟩</span>\n  <span class=\"n\">mul_assoc</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">σ₁</span><span class=\"o\">,</span><span class=\"n\">f₁</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">σ₂</span><span class=\"o\">,</span><span class=\"n\">f₂</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">σ₃</span><span class=\"o\">,</span><span class=\"n\">f₃</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">HMul.hMul</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">RingEquiv.coe_ringHom_trans</span><span class=\"o\">,</span> <span class=\"n\">Sigma.mk.inj_iff</span><span class=\"o\">,</span> <span class=\"n\">heq_eq_eq</span><span class=\"o\">]</span>\n    <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">one</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">RingEquiv.refl</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">LinearEquiv.refl</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">⟩</span>\n  <span class=\"n\">one_mul</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">HMul.hMul</span><span class=\"o\">,</span><span class=\"n\">OfNat.ofNat</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">RingEquiv.coe_ringHom_trans</span><span class=\"o\">,</span> <span class=\"n\">LinearEquiv.trans_refl</span><span class=\"o\">]</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"n\">mul_one</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">HMul.hMul</span><span class=\"o\">,</span><span class=\"n\">OfNat.ofNat</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">RingEquiv.coe_ringHom_trans</span><span class=\"o\">,</span> <span class=\"n\">LinearEquiv.refl_trans</span><span class=\"o\">]</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">σ</span><span class=\"o\">,</span><span class=\"n\">f</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">σ.symm</span><span class=\"o\">,</span><span class=\"n\">f.symm</span><span class=\"o\">⟩</span>\n  <span class=\"n\">mul_left_inv</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">σ</span><span class=\"o\">,</span><span class=\"n\">f</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">RingEquiv.coe_ringHom_trans</span><span class=\"o\">]</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">HMul.hMul</span><span class=\"o\">,</span><span class=\"n\">OfNat.ofNat</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">RingEquiv.coe_ringHom_trans</span><span class=\"o\">,</span> <span class=\"n\">Sigma.mk.inj_iff</span><span class=\"o\">,</span> <span class=\"n\">RingEquiv.self_trans_symm</span><span class=\"o\">,</span>\n      <span class=\"n\">RingEquiv.coe_ringHom_refl</span><span class=\"o\">,</span> <span class=\"n\">RingEquiv.symm_refl</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">]</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>\n</div></div>",
        "id": 430149964,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711654531
    },
    {
        "content": "<p>something that would possibly help is being able to <code>simp only</code> at the type of a subexpression of the goal... does something like that exist?</p>",
        "id": 430151453,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711655228
    },
    {
        "content": "<p>The <code>abbrev</code> can be simplified slightly to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">SemilinearAut</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n    <span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"o\">:</span><span class=\"n\">RingAut</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">letI</span> <span class=\"n\">inst</span> <span class=\"o\">:=</span> <span class=\"n\">RingHomInvPair.of_ringEquiv</span> <span class=\"n\">σ</span><span class=\"bp\">;</span> <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">inst.symm</span><span class=\"bp\">;</span> <span class=\"n\">M</span> <span class=\"bp\">≃ₛₗ</span><span class=\"o\">[(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">R</span><span class=\"o\">)]</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(which is really exactly the same thing)</p>",
        "id": 430152276,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711655592
    },
    {
        "content": "<p>I recommend taking a step back and first writing an ext lemma that says when two <code>SemilinearAut</code>s are equal</p>",
        "id": 430152753,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711655796
    },
    {
        "content": "<p>Namely; \"the <code>RingAut</code> parts are equal, and the linear maps, when treated as additive maps, are equal</p>",
        "id": 430152846,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711655844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Semilinear.20Equivalences.20form.20a.20group/near/430152846\">said</a>:</p>\n<blockquote>\n<p>Namely; \"the <code>RingAut</code> parts are equal, and the linear maps, when treated as additive maps, are equal</p>\n</blockquote>\n<p>i run into a similar problem, where i have to prove <code>HEq snd✝¹ snd✝</code>, with the types <code>snd✝¹: M ≃ₛₗ[↑fst✝¹] M</code> and <code>snd✝:M ≃ₛₗ[↑fst✝] M</code>, when i have <code>h₁: fst✝¹ = fst✝</code> and <code>h₂: ∀ (x : M), snd✝¹ x = snd✝ x</code>. i'd like to rewrite with <code>h₁</code> in the type of <code>snd✝¹</code> so i can apply <code>heq_eq_eq</code> and then something like funext...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">SemilinearAut.ext</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">⦃</span><span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">SemilinearAut</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"o\">:</span> <span class=\"n\">f.fst</span> <span class=\"bp\">=</span> <span class=\"n\">g.fst</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">f.snd</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g.snd</span> <span class=\"n\">x</span><span class=\"o\">):</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">f</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">g</span><span class=\"bp\">;</span> <span class=\"n\">congr</span>\n  <span class=\"n\">simp_all</span><span class=\"bp\">?</span> <span class=\"n\">says</span> <span class=\"n\">simp_all</span> <span class=\"n\">only</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 430154369,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711656435
    },
    {
        "content": "<p>This works for me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">SemilinearAut.ext</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">⦃</span><span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">SemilinearAut</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"o\">:</span> <span class=\"n\">f.1</span> <span class=\"bp\">=</span> <span class=\"n\">g.1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">f.2</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g.2</span> <span class=\"n\">x</span><span class=\"o\">):</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">f</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">g</span>\n  <span class=\"n\">subst</span> <span class=\"n\">h₁</span>\n  <span class=\"n\">congr</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h₂</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 430155599,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711657008
    },
    {
        "content": "<p>Your <code>congr</code> was too early; you want to try and eliminate the dependent types before you split componentwise</p>",
        "id": 430155646,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711657026
    },
    {
        "content": "<p>thanks!</p>",
        "id": 430155830,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711657101
    },
    {
        "content": "<p>i also just found <code>heq_of_eqRec_eq : ∀ {α β : Sort u} {a : α} {b : β} (h₁ : α = β), h₁ ▸ a = b → HEq a b</code>...</p>",
        "id": 430155908,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711657139
    },
    {
        "content": "<p>Now, the trick I'd use to prove this group structure is first show that there is an injection to <code>RingAut \\times AddAut</code>, define <code>mul</code>/<code>one</code>/<code>inv</code> as you've done, then pull back the group structure through <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.Injective.group#doc\">docs#Function.Injective.group</a></p>",
        "id": 430156206,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711657287
    },
    {
        "content": "<p>does it happen to be the case that for a semilinear equivalence, the choice of RingEquivalence is forced? i did some thinking, and this is true if the action of <code>R</code> on <code>M</code> (with <code>Module R M</code>) is faithful... is this always the case, or not? i've tried thinking of a counterexample with <code>Module Z (Z/n)</code> but there i run into the problem that there is a unique RingEquiv on Z...</p>",
        "id": 430390775,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711805803
    },
    {
        "content": "<p>another way of asking the same thing is \"is the (canonical) mapping from semilinear equivalence to addhom injective?\"</p>",
        "id": 430390901,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711805886
    },
    {
        "content": "<p>Let <code>A</code> be the ring of polynomials over your favourite base ring <code>R</code>. Let <code>M</code> be an <code>R</code>-module. View <code>M</code> as an <code>A</code>-module by letting every polynomial act via its constant coefficient. (In other words, <code>X</code> acts as multiplication by <code>0</code>.)<br>\nLet <code>f</code> be an <code>R</code>-linear endomorphism of <code>M</code>. Then <code>f</code> is also <code>A</code>-semilinear wrt any <code>R</code>-algebra endomorphism of <code>A</code>.</p>",
        "id": 430391703,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711806587
    },
    {
        "content": "<p>i'm not very familiar with algebras, could you give a specific example of two different R-algebra endomorphisms of A?</p>",
        "id": 430391924,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711806769
    },
    {
        "content": "<p>i suppose <code>X ↦ u X</code> with <code>u</code> a non-1 unit might do....</p>",
        "id": 430392042,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711806875
    },
    {
        "content": "<p>(along with identity)</p>",
        "id": 430392048,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711806885
    },
    {
        "content": "<p>An <code>R</code>-algebra hom out of <code>A</code> is determined by the image of <code>X</code>. And you can send <code>X</code> wherever you want.</p>",
        "id": 430392273,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711807132
    },
    {
        "content": "<p>surely it has to be bijective though?</p>",
        "id": 430392297,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711807161
    },
    {
        "content": "<p>Why?</p>",
        "id": 430392305,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711807173
    },
    {
        "content": "<p>because i'm looking at linear equivalences</p>",
        "id": 430392309,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711807183
    },
    {
        "content": "<p>Ooh, ok. Well you can send <code>X</code> to <code>a * X + b</code> with <code>a</code> invertible.</p>",
        "id": 430392371,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711807210
    },
    {
        "content": "<p>right, thanks <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 430392714,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711807475
    },
    {
        "content": "<p>Re the title: it’s sometimes called the “general semilinear group”</p>",
        "id": 430393241,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711807994
    },
    {
        "content": "<p>i'm thinking a bit, the typical consideration of \"general semilinear group\" might not quite be the same as the group structure on <code>SemilinearAut R M := (σ:RingAut R) × (M ≃ₛₗ[(σ : R →+* R)] M)</code>, as there in the second, there can be multiple copies of the same function, if there are multiple fitting ringEquivs...</p>",
        "id": 430393436,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711808207
    },
    {
        "content": "<p>however, i can imagine that the typical consideration doesnt...</p>",
        "id": 430393477,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711808280
    },
    {
        "content": "<p>Well, for one it should be the semi direct product. Also, this will indeed only agree with the set of semiliear equivs under some faithfulness assumptions</p>",
        "id": 430393515,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711808283
    },
    {
        "content": "<p>how do you mean semidirect product?</p>",
        "id": 430393538,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711808313
    },
    {
        "content": "<p>in the group sense?</p>",
        "id": 430393545,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711808325
    },
    {
        "content": "<p>Oh you write the semilinear equivs. Sorry, you’re correct. What I meant is if you take the product with the linear equivs, then you need to take a semi direct product</p>",
        "id": 430393589,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711808379
    },
    {
        "content": "<p>In the group sense</p>",
        "id": 430393596,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711808383
    },
    {
        "content": "<p>(Sorry, I’m doing this on my phone)</p>",
        "id": 430393822,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711808470
    },
    {
        "content": "<p>would it be possible to get the \"smaller\" group by looking at some quotient, perhaps?</p>",
        "id": 430394354,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711808832
    },
    {
        "content": "<p>I guess you could identify two terms in the sigma type you wrote down is the induced function on the module is the same.</p>",
        "id": 430394591,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711809031
    },
    {
        "content": "<p>At least for such a quotient you would get an extensionality principle based on the underlying function</p>",
        "id": 430394721,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711809141
    },
    {
        "content": "<p>And in the case where the action is faithful, the two variants should agree</p>",
        "id": 430394740,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711809172
    },
    {
        "content": "<p>right... i suppose that that would be the quotient with the subgroup of the identity map with all its possible ringisomorphisms?</p>",
        "id": 430394784,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711809224
    },
    {
        "content": "<p>I was actually envisioning doing something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Why doesn't this exist?</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">≃+*</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">RingHomInvPair</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">σ.symm</span> <span class=\"n\">where</span>\n  <span class=\"n\">comp_eq</span> <span class=\"o\">:=</span> <span class=\"n\">σ.symm_comp</span>\n  <span class=\"n\">comp_eq₂</span> <span class=\"o\">:=</span> <span class=\"n\">σ.comp_symm</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">≃+*</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">RingHomCompTriple</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">σ.trans</span> <span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n    <span class=\"n\">comp_eq</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">GSL</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">≃+*</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">≃ₛₗ</span><span class=\"o\">[(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">R</span><span class=\"o\">)]</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CoeFun</span> <span class=\"o\">(</span><span class=\"n\">GSL</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">f.snd</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">GSLSetoid</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"o\">(</span><span class=\"n\">GSL</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Setoid.ker</span> <span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">GSL'</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient</span> <span class=\"o\">(</span><span class=\"n\">GSLSetoid</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 430395999,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711810242
    },
    {
        "content": "<p>in case you didn't know about it: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingHomInvPair.of_ringEquiv#doc\">docs#RingHomInvPair.of_ringEquiv</a></p>",
        "id": 430396052,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711810308
    },
    {
        "content": "<p>Ok great! I didnt check too carefully :)</p>",
        "id": 430396112,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711810334
    },
    {
        "content": "<p>but it isn't an instance probably for loop reasons...</p>",
        "id": 430396130,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711810352
    },
    {
        "content": "<p>right... defining the group instance afterward might be a bit annoying though, because it is a quotient type. i'd rather use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=QuotientGroup.Quotient.group#doc\">docs#QuotientGroup.Quotient.group</a></p>",
        "id": 430396405,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711810564
    },
    {
        "content": "<p>I disagree. Since you’re just identifying two terms if they have the same underlying functions, and composition should be obviously compatible with function composition, defining the group structure using <code>Quotient.lift</code> should be trivial</p>",
        "id": 430396749,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711810872
    },
    {
        "content": "<p>And the setoid used for quotient groups won’t be as convenient to work with definitionally</p>",
        "id": 430396788,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711810918
    },
    {
        "content": "<p>i hadn't thought of that...</p>",
        "id": 430396855,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711810953
    },
    {
        "content": "<p>maybe the best of both worlds is lifting the group structure from AddAut?</p>",
        "id": 430397437,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711811424
    },
    {
        "content": "<p>because the map from <code>(σ : R ≃+* R) × (M ≃ₛₗ[(σ : R →+* R)] M)</code> to <code>AddAut M</code> is a grouphom</p>",
        "id": 430397720,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711811680
    },
    {
        "content": "<p>Oh yes that’s probably the way to go</p>",
        "id": 430398332,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711812260
    },
    {
        "content": "<p>something that i do keep walking into right now is that the api for using ring-isos with semilinear equivalences is quite poor... simp lemmas hardly ever apply.</p>",
        "id": 430398881,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711812772
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/287929-mathlib4/topic/General.20Semilinear.20group/near/430398881\">said</a>:</p>\n<blockquote>\n<p>something that i do keep walking into right now is that the api for using ring-isos with semilinear equivalences is quite poor... simp lemmas hardly ever apply.</p>\n</blockquote>\n<p>That’s not good… do you have a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> illustrating such a failure?</p>",
        "id": 430405745,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711818980
    },
    {
        "content": "<p>i tried, it turns out the lack of API is with my own classes rather than with Matlib <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 430408423,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711821487
    }
]