[
    {
        "content": "<p><code>Measure.comap</code> is <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/MeasureTheory/Measure/MeasureSpace.html#MeasureTheory.Measure.comap\">defined</a> as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Pullback of a `Measure`. If `f` sends each measurable set to a null-measurable set,</span>\n<span class=\"sd\">then for each measurable set `s` we have `comap f μ s = μ (f '' s)`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Injective</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">MeasurableSet</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NullMeasurableSet</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">OuterMeasure</span><span class=\"bp\">.</span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"bp\">.</span><span class=\"n\">toOuterMeasure</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toMeasure</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OuterMeasure</span><span class=\"bp\">.</span><span class=\"n\">comap_apply</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">image_inter</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">image_diff</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">measure_inter_add_diff₀</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>Why do we insist that <code>f</code> is injective? Is there an alternative version that doesn't?<br>\nFor example, the natural map sending a binary expansion to the corresponding real number is not injective, so I can prove some strange result this way. (Specifically, that the fair coin measure on Cantor space is the zero measure.)</p>",
        "id": 446342433,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1719098823
    },
    {
        "content": "<p>AFAICT, there is no better version of <code>Measure.comap</code> in Mathlib.</p>",
        "id": 446350007,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1719104603
    },
    {
        "content": "<p>You can replace the condition with <code>inferInstance ≤ (OuterMeasure.comap f μ.toOuterMeasure.)caratheodory</code></p>",
        "id": 446350486,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1719104755
    },
    {
        "content": "<p>I mean, make a PR to Mathlib that changes the condition.</p>",
        "id": 446350591,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1719104774
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> !<br>\nI don't know what <code>≤</code> means in this context though?</p>",
        "id": 446353492,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1719106551
    },
    {
        "content": "<p>In this context it means that every measurable set is Caratheodory measurable w.r.t. <code>OuterMeasure.comap f μ.toOuterMeasure</code></p>",
        "id": 446353581,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1719106598
    },
    {
        "content": "<p>You will have to prove this under some weaker assumptions on <code>f</code>.</p>",
        "id": 446353647,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1719106647
    },
    {
        "content": "<p>(e.g., a.e.-injectivity, or maybe something even weaker)</p>",
        "id": 446353721,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1719106682
    },
    {
        "content": "<p>There are quite a few definitions in Mathlib that can be generalized. Fortunately, we can do it once someone needs a more general version.</p>",
        "id": 446355271,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1719107810
    },
    {
        "content": "<p>Makes sense. As a smaller change, ideally the current version should have injectivity as an explicit assumption rather than hidden in the <code>ite</code>, I think.</p>",
        "id": 446356320,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1719108785
    },
    {
        "content": "<p>No, we use this design everywhere. E.g., <code>deriv</code> doesn't require the function to be differentiable.</p>",
        "id": 446356458,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1719108931
    },
    {
        "content": "<p>Probably, the first change is to fix the docstring to say explicitly that it's zero unless $f$ is injective and sends measurable sets to (null) measurable sets.</p>",
        "id": 446356522,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1719108975
    },
    {
        "content": "<p>If you turn <code>Injective f</code> into an argument, then you'll have to supply it every time you write <code>Measure.comap</code>, not just when you apply theorems about it. Also, <code>rw [(h : f = g)]</code> will fail.</p>",
        "id": 446356588,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1719109062
    },
    {
        "content": "<p>Okay I can try to make a PR. I added the changes in the docstring to <a href=\"https://github.com/bjoernkjoshanssen/mathlib4/blob/master/Mathlib/MeasureTheory/Measure/MeasureSpace.lean\">my copy of the file</a> which is part of <a href=\"https://github.com/bjoernkjoshanssen/mathlib4/tree/master\">my copy of mathlib</a></p>\n<p>Another option for dealing with the Cantor set and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>, I suppose, could be to restrict the Cantor set to a subtype so that the map into <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> becomes injective:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">real_of_cantor</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">tsum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">ite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">CantorLebesgueMeasure</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeasureTheory</span><span class=\"bp\">.</span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"n\">MeasureTheory</span><span class=\"bp\">.</span><span class=\"n\">Measure</span><span class=\"bp\">.</span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"n\">real_of_cantor</span><span class=\"w\"> </span><span class=\"n\">MeasureTheory</span><span class=\"bp\">.</span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"c1\">-- bad currently, since not injective</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">CantorLebesgueMeasureSubtype</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">MeasureTheory</span><span class=\"bp\">.</span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"w\">  </span><span class=\"c1\">-- those that don't end 0 1^∞</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">MeasureTheory</span><span class=\"bp\">.</span><span class=\"n\">Measure</span><span class=\"bp\">.</span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">real_of_cantor</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">MeasureTheory</span><span class=\"bp\">.</span><span class=\"n\">volume</span>\n</code></pre></div>",
        "id": 446359882,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1719112336
    },
    {
        "content": "<p>As a simple change, can you replace injectivity by ae injectivity?</p>",
        "id": 446402801,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1719138989
    },
    {
        "content": "<p>That should cover your Cantor set example</p>",
        "id": 446402819,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1719138999
    },
    {
        "content": "<p>That's a good idea.</p>\n<p>Alternatively, I don't know if Mathlib already has a  way to define a measure by \"extending by zero\".<br>\nE.g., define a measure on <code>ℕ → Bool</code> by: </p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mrow><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">L</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">b</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">s</mi><mi mathvariant=\"normal\">g</mi><mi mathvariant=\"normal\">u</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">M</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">s</mi><mi mathvariant=\"normal\">u</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">u</mi><mi mathvariant=\"normal\">b</mi><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">y</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi></mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo>∩</mo></mrow><annotation encoding=\"application/x-tex\">\\mu(A)=\\mathrm{CantorLebesgueMeasureSubtype}(A \\cap </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">CantorLebesgueMeasureSubtype</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mord\">∩</span></span></span></span><code>{x : ℕ → Bool // ¬ ∃ k, x k = false ∧ ∀ l, k &lt; l → x l = true}</code><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mclose\">}</span></span></span></span>?</p>",
        "id": 446459369,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1719168238
    },
    {
        "content": "<p>I'm probably misunderstanding what you mean, but do you mean <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.Measure.restrict#doc\">docs#MeasureTheory.Measure.restrict</a> ?</p>",
        "id": 446459656,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719168380
    },
    {
        "content": "<p>Hmm, <code>restrict</code> seems to assume you already have a measure on the bigger set (or type).</p>\n<p>I mean for example, say you have a measure on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{0,1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span>. What's the Mathlib way to extend that to a measure on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> by declaring that all numbers other than 0 and 1 have measure zero?</p>",
        "id": 446460778,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1719169152
    },
    {
        "content": "<p>For other structures in mathlib which I'm more familiar with, that would be called <code>.map</code></p>",
        "id": 446461223,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1719169364
    },
    {
        "content": "<p>That makes sense, thanks <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span><br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/MeasureTheory/Measure/MeasureSpace.html#MeasureTheory.Measure.map\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/MeasureTheory/Measure/MeasureSpace.html#MeasureTheory.Measure.map</a></p>",
        "id": 446461856,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1719169699
    }
]