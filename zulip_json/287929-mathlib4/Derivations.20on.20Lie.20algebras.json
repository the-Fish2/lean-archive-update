[
    {
        "content": "<p>Hi, I am new to formalization and Lean, and my long term goal is to formalize some of my current research results on control theory. With this goal in mind, I plan to start by contributing to mathlib4 by formalizing some of the prerequisites that I need. </p>\n<p>In particular, I intended to start by proving  that <em>Hall sets</em> (of the free magma over a set X) yield bases of the free Lie algebra over X (see e.g. <a href=\"https://personal.math.ubc.ca/~cass/research/pdf/Free.pdf\">Free Lie Algebras</a> by Bill Casselman). From the mathematical point of view, this is standard stable material dating from the 1970s and the proofs are rather straightforward. The proofs that I know of require manipulating <strong>derivations on Lie algebras</strong> (e.g. a linear map from a Lie algebra L to itself, satisfying Leibniz's law).</p>\n<p>As discussed in <a href=\"#narrow/stream/116395-maths/topic/derivation/near/370025008\">this thread</a>, the current definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/Derivation/Basic.html#Derivation\">derivations</a> in mathlib4 only works for commutative algebras, so doesn't apply to Lie algebras. </p>\n<ul>\n<li>On the one hand, I understand from the given thread that the proper refactoring with a generalization covering all possible settings for derivations might be complicated (and out of reach for me).</li>\n<li>On the other hand, the definition in the case of Lie algebras is probably simpler and I only need rather basic stuff about these derivations (say for example that the set of derivations of a Lie algebra is itself a Lie algebra).</li>\n</ul>\n<p><strong>How does the mathlib4 community approach such cases: do I need to wait for the long-term proper refactoring of derivations to include the non-commutative non-associative case? or could I follow the following plan:</strong></p>\n<ol>\n<li>State in mathlib4 a definition specific to Lie algebras, for example along the lines (please do correct me)</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">LieDerivation</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LieRing</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LieAlgebra</span> <span class=\"n\">R</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n  <span class=\"kd\">extends</span> <span class=\"n\">L</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">L</span> <span class=\"n\">where</span>\n  <span class=\"n\">leibniz</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">toLinearMap</span> <span class=\"bp\">⁅</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">⁆</span> <span class=\"bp\">=</span> <span class=\"bp\">⁅</span> <span class=\"n\">toLinearMap</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">⁆</span> <span class=\"bp\">+</span> <span class=\"bp\">⁅</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">toLinearMap</span> <span class=\"n\">b</span> <span class=\"bp\">⁆</span>\n</code></pre></div>\n<ol start=\"2\">\n<li>Prove in mathlib4 the basic facts that I need for such derivations of a Lie algebra to itself (e.g. they are themselves a Lie algebra).</li>\n<li>Use these facts to prove in mathlib4 Viennot's theorem that Hall sets yield bases of the free Lie algebra.</li>\n<li>One day, when the generalized definition becomes available, <code>LieDerivation</code> just becomes a kind of alias for the particular case of a derivation from a Lie algebra to itself, and we throw away the proofs of Step 2, since they now directly follow from the general case (and/or we also throw away the definition from Step 1, relying directly on the generalized notion). </li>\n</ol>\n<p>Thanks for you thoughts</p>",
        "id": 425518007,
        "sender_full_name": "Frédéric Marbach",
        "timestamp": 1709904294
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span></p>",
        "id": 425518667,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709904496
    },
    {
        "content": "<p>I am travelling so I will not be able to answer this properly till Monday. For now I’ll just say that I think your plan is probably the right way forward.</p>",
        "id": 425551354,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1709915381
    },
    {
        "content": "<p>I have the following remarks to make about derivations on Lie algebras:</p>\n<ol>\n<li>In addition to the issue that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Derivation#doc\">docs#Derivation</a> requires commutativity (pending a refactor, possibly using right actions) it also requires associativity! So this is another obstacle to unifying <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Derivation#doc\">docs#Derivation</a> with a new <code>LieDerivation</code> definition.</li>\n<li>Because all the Lie theory is developed using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Bracket#doc\">docs#Bracket</a> for the product rather than <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mul#doc\">docs#Mul</a>, even if we refactored <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Derivation#doc\">docs#Derivation</a> so that it was able to permit non-commutative, non-associative products, we would still have work to do because we do not have a <code>to_bracket</code> attribute analogous to <code>to_additive</code> for this job (and I don't think we should create one).</li>\n<li>With the above in mind we should just define <code>LieDerivation</code> essentially as you suggest. If / when we have a sufficiently general <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Derivation#doc\">docs#Derivation</a> we can have lemmas to connect the two notions, rather than bending over backwards to have a single definition.</li>\n<li>I think we should generalise <code>LieDerivation</code> slightly to allow for a general representation <code>M</code> of a Lie algebra <code>L</code> (suggestion below).</li>\n<li>Note that in some sense, the suggestion below commits the same sin as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Derivation#doc\">docs#Derivation</a> since its <code>leibniz</code> axiom reverses <code>a</code> and <code>b</code>. It also does this for the same reason: we don't have right actions of Lie algebras. However because every Lie algebra satisfies <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=lie_skew#doc\">docs#lie_skew</a>, all is well (see <code>apply_lie_eq_add</code> in the suggestion below). The only way this sin would ever be an issue is if someone wants to develop the theory of derivations of representations of <a href=\"https://en.wikipedia.org/wiki/Leibniz_algebra\">Leibniz algebras</a> which I think is sufficiently exotic that we should ignore it.</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Lie.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Lie.Killing</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">L</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LieRing</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LieAlgebra</span> <span class=\"n\">R</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LieRingModule</span> <span class=\"n\">L</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LieModule</span> <span class=\"n\">R</span> <span class=\"n\">L</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">LieDerivation</span> <span class=\"kd\">extends</span> <span class=\"n\">L</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span> <span class=\"n\">where</span>\n  <span class=\"n\">leibniz</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">toLinearMap</span> <span class=\"bp\">⁅</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">⁆</span> <span class=\"bp\">=</span> <span class=\"bp\">⁅</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">toLinearMap</span> <span class=\"n\">b</span><span class=\"bp\">⁆</span> <span class=\"bp\">-</span> <span class=\"bp\">⁅</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">toLinearMap</span> <span class=\"n\">a</span><span class=\"bp\">⁆</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">LieDerivation</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instCoeLinearMap</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">LieDerivation</span> <span class=\"n\">R</span> <span class=\"n\">L</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">toLinearMap</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instFunLike</span> <span class=\"o\">:</span> <span class=\"n\">FunLike</span> <span class=\"o\">(</span><span class=\"n\">LieDerivation</span> <span class=\"n\">R</span> <span class=\"n\">L</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">L</span> <span class=\"n\">M</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"n\">D.toLinearMap</span>\n  <span class=\"n\">coe_injective'</span> <span class=\"n\">D₁</span> <span class=\"n\">D₂</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">D₁</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">D₂</span><span class=\"bp\">;</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">h</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">apply_lie_eq_sub</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">LieDerivation</span> <span class=\"n\">R</span> <span class=\"n\">L</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">D</span> <span class=\"bp\">⁅</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">⁆</span> <span class=\"bp\">=</span> <span class=\"bp\">⁅</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">D</span> <span class=\"n\">b</span><span class=\"bp\">⁆</span> <span class=\"bp\">-</span> <span class=\"bp\">⁅</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">D</span> <span class=\"n\">a</span><span class=\"bp\">⁆</span> <span class=\"o\">:=</span>\n  <span class=\"n\">D.leibniz</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">apply_lie_eq_add</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">LieDerivation</span> <span class=\"n\">R</span> <span class=\"n\">L</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">D</span> <span class=\"bp\">⁅</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">⁆</span> <span class=\"bp\">=</span> <span class=\"bp\">⁅</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">D</span> <span class=\"n\">b</span><span class=\"bp\">⁆</span> <span class=\"bp\">+</span> <span class=\"bp\">⁅</span><span class=\"n\">D</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">⁆</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">D.apply_lie_eq_sub</span><span class=\"o\">,</span> <span class=\"n\">sub_eq_add_neg</span><span class=\"o\">,</span> <span class=\"n\">lie_skew</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">LieDerivation</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">lieDerivationOf</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">LieDerivation</span> <span class=\"n\">R</span> <span class=\"n\">L</span> <span class=\"n\">M</span> <span class=\"n\">where</span>\n  <span class=\"n\">__</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">LieModule.toEndomorphism</span> <span class=\"n\">R</span> <span class=\"n\">L</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">Module.End</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flip</span> <span class=\"n\">m</span>\n  <span class=\"n\">leibniz</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"sd\">/-- Every derivation of a finite-dimensional semisimple Lie algebra is inner. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">LieAlgebra.exists_eq_derivationOf</span>\n    <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LieAlgebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">IsKilling</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"c1\">-- Or maybe we really need `[CharZero K] [IsSemisimple K L]`</span>\n    <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">LieDerivation</span> <span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">D</span> <span class=\"bp\">=</span> <span class=\"n\">lieDerivationOf</span> <span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"n\">L</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 425888792,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1710156709
    },
    {
        "content": "<p>My final remark would be that I'm really excited to hear that someone will add <code>LieDerivation</code> to the library: it's a notable gap in our Lie algebra theory. A very useful result which I'd love to see someone add is that every derivation of a finite-dimensional semisimple Lie algebra in characteristic zero is inner (I've added this <code>sorry</code> to the example above).</p>",
        "id": 425889406,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1710156947
    },
    {
        "content": "<p>Should <code>lieDerivationOf</code> be called <code>innerDerivation</code> or something like that?</p>",
        "id": 425968304,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1710176087
    },
    {
        "content": "<p>Thank you for your detailed answer! As discussed in Marseille, I have started working on this (and the semi-simple related result, for which I am almost done). As a first step, I just pushed <a href=\"https://github.com/leanprover-community/mathlib4/pull/11790\">PR#11790</a> which concerns only the definition of Lie derivations, elementary properties (as for the other derivations), and the fact that they form a Lie algebra themselves. </p>\n<p>Since I am new to Lean, and I copy-pasted the (non-Lie) <code>Derivation</code> file, my code is guaranteed to contain all the imperfections of the initial file + all new new ones I might have added. So I am looking forward to your feedback.</p>",
        "id": 430397364,
        "sender_full_name": "Frédéric Marbach",
        "timestamp": 1711811378
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> for reviewing and merging <a href=\"https://github.com/leanprover-community/mathlib4/pull/11790\">https://github.com/leanprover-community/mathlib4/pull/11790</a> containing the definition of <code>LieDerivation</code>. I still have a bunch of content on my computer which I am trying to cut in appropriate chunks.</p>\n<p>My next step was pushing:<br>\n1) the definition of the adjoint action of a Lie algebra <code>L</code>, <br>\n2) the fact that it is a Lie algebra morphism from <code>L</code> to the Lie derivations over <code>L</code>, <br>\n3) that it's image is an ideal of the set of derivations. </p>\n<p>My initial plan was to create a <code>Algebra.Lie.Derivation.AdjointAction</code> file.</p>\n<p>Just before pushing, I realized, that  the adjoint action is already defined in the <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Lie/OfAssociative.html\">Algebra.Lie.OfAssociative</a> file, specifically here <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Lie/OfAssociative.html#LieAlgebra.ad\">LieAlgebra.ad</a> as a Lie algebra morphism from <code>L</code> to the linear endomorphisms of <code>L</code>. </p>\n<p>I initially thought that I should extract the <code>section AdjointAction</code> part of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Lie/OfAssociative.html\">Algebra.Lie.OfAssociative</a> and move it to a <code>Algebra.Lie.Derivation.AdjointAction</code> file. But then I realized that this section also contained stuff about <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Lie/OfAssociative.html#LieModule.toEndomorphism\">LieModule.toEndomorphism</a> which does not seem to be a Lie derivation (since <code>M</code> has no Lie structure). So I thought about extracting only the <code>LieAlgebra.ad</code> part and leave the <code>LieModule.toEndormorphism</code> where it is. But there is some intertwining between the APIs of both. </p>\n<p>Where should I put 2) and 3)?</p>",
        "id": 431234771,
        "sender_full_name": "Frédéric Marbach",
        "timestamp": 1712212831
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"674861\">@Frédéric Marbach</span> How much lines of code is this? If it isn't too much, you could include it in the file on Lie derivations.</p>",
        "id": 431235183,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1712213018
    },
    {
        "content": "<p>Otherwise, go ahead and start the AdjointAction file.</p>",
        "id": 431235220,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1712213032
    },
    {
        "content": "<p>Not much, around 50 lines. My problem was more that there is already a definition of <code>LieAlgebra.ad</code> in the <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Lie/OfAssociative.html\">OfAssociative</a> file. So I need to enhance this definition (to make it clear that the values of <code>ad</code> are Lie derivations, not just endomorphisms). But extracting <code>ad</code> from there seemed tough because it has intertwinned lemmas with the <code>LieModule.toEndomorphism</code> stuff.</p>",
        "id": 431235853,
        "sender_full_name": "Frédéric Marbach",
        "timestamp": 1712213281
    },
    {
        "content": "<p>Aah, so just define <code>adLieHom</code> or something like that.</p>",
        "id": 431236770,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1712213735
    },
    {
        "content": "<p>For example, we also have cast from <code>Nat</code> to any semiring as a function, as add_monoid hom, and as ring hom.</p>",
        "id": 431236884,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1712213777
    },
    {
        "content": "<p>So we can have multiple versions of the same map.</p>",
        "id": 431236902,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1712213789
    },
    {
        "content": "<p>I presume you're defining something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">L</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LieRing</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LieAlgebra</span> <span class=\"n\">R</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LieRingModule</span> <span class=\"n\">L</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LieModule</span> <span class=\"n\">R</span> <span class=\"n\">L</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">LieDerivation.inner</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">LieDerivation</span> <span class=\"n\">R</span> <span class=\"n\">L</span> <span class=\"n\">M</span> <span class=\"n\">where</span>\n  <span class=\"n\">__</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">LieModule.toEndomorphism</span> <span class=\"n\">R</span> <span class=\"n\">L</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">Module.End</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flip</span> <span class=\"n\">m</span>\n  <span class=\"n\">leibniz</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<p>and possibly and <code>abbrev</code> for the case <code>M = L</code>?</p>\n<p>In any case, I agree with Johan, make a second definition taking values in <code>LieDerivation R L L</code> together with a simp lemma saying that if it is regarded as a map to <code>Module.End R L</code> then it is equal to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LieAlgebra.ad#doc\">docs#LieAlgebra.ad</a></p>",
        "id": 431238469,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1712214535
    },
    {
        "content": "<p>Somewhat independently, you should feel free to propose a reorganisation of the file / import structure of the Lie theory files, especially the older files (usually higher up in the hierarchy). Some of the files are also too big and deserve splitting. We have learned a lot since some of the original decisions were taken.</p>",
        "id": 431239096,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1712214808
    },
    {
        "content": "<p>Thanks for your answers. I am working on it.</p>\n<p>Parallely, since the proof about inner derivations involves the Killing form, I will need to know that the set of Lie derivations is a finite free module. I created a PR for this basic fact: <a href=\"https://github.com/leanprover-community/mathlib4/pull/11927\">https://github.com/leanprover-community/mathlib4/pull/11927</a>. I tried to sharpen the hypotheses or shorten the proofs but after many failures I settled for this version which is sufficient for the goal about inner derivations on semisimple Lie algebras.</p>",
        "id": 431555196,
        "sender_full_name": "Frédéric Marbach",
        "timestamp": 1712332058
    },
    {
        "content": "<p>Thanks for all your work here. I left some review on <a href=\"https://github.com/leanprover-community/mathlib4/pull/11927\">#11927</a> and I look forward to the follow up :)</p>",
        "id": 431616863,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1712358700
    },
    {
        "content": "<p>Thanks! I knew <code>[Field R]</code> was not the correct assumption and that it had something to do with the Noetherian stuff but I had not managed to find your neat solution! I pushed a commit with your changes.</p>",
        "id": 431650227,
        "sender_full_name": "Frédéric Marbach",
        "timestamp": 1712388899
    },
    {
        "content": "<p>The proof about inner derivations is finished (on my laptop). As a prerequisite, I pushed <a href=\"https://github.com/leanprover-community/mathlib4/pull/12008\">#12008</a>, which states that if a Lie algebra is isomorphic to a Killing Lie algebra, then it is Killing too.</p>",
        "id": 431971289,
        "sender_full_name": "Frédéric Marbach",
        "timestamp": 1712582955
    },
    {
        "content": "<p>Another prerequisite is to have lemmas about orthogonal complements for the new bilinear form (not the old one). I pushed <a href=\"https://github.com/leanprover-community/mathlib4/pull/12015\">#12015</a> for this purpose.</p>",
        "id": 432011782,
        "sender_full_name": "Frédéric Marbach",
        "timestamp": 1712592348
    },
    {
        "content": "<p>Congratulations! This is a really useful result and is basically the dream outcome of my attempt to drag you into the Lie theory effort. I'll take a look at these PRs this evening!</p>",
        "id": 432033692,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1712598161
    },
    {
        "content": "<p>Here's a mathematical to which I do not know the answer: is it necessary to assume characteristic zero or is non-degenerate Killing form sufficient?</p>",
        "id": 432033853,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1712598212
    },
    {
        "content": "<p>Thank you for suggesting this result! It turned out to be a both a fun landmark and a useful benchmark for my definitions. Lean seems to think that it holds as follows (well, more might be true of course):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LieRing</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">LieAlgebra</span> <span class=\"n\">R</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module.Finite</span> <span class=\"n\">R</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LieAlgebra.IsKilling</span> <span class=\"n\">R</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_eq_ad</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">LieDerivation</span> <span class=\"n\">R</span> <span class=\"n\">L</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">D</span> <span class=\"bp\">=</span> <span class=\"n\">ad</span> <span class=\"n\">R</span> <span class=\"n\">L</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I might step out of semisimple Lie algebras after this is done since they are far outside my confort zone. I will try to go back to free Lie algebras and prove what I need there.</p>",
        "id": 432054445,
        "sender_full_name": "Frédéric Marbach",
        "timestamp": 1712605322
    },
    {
        "content": "<p>If you like universal enveloping algebras then I'd love to see them acting on C^infty functions on a Lie group!</p>",
        "id": 432055680,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712605844
    },
    {
        "content": "<p>Thanks, I see that you guys are experts at suggesting further projects! </p>\n<p>For my applications to control theory, I had in mind to \"start\" by </p>\n<ul>\n<li>the fact that Hall sets yield bases of the free Lie algebra,</li>\n<li>the Poincaré-Birkhoff-Witt theorem,</li>\n<li>the Guillemin-Sternberg realization theorem for transitive Lie algebras.</li>\n</ul>",
        "id": 432057043,
        "sender_full_name": "Frédéric Marbach",
        "timestamp": 1712606236
    },
    {
        "content": "<p>PBW would I'm sure be a very welcome addition, and it has the advantage that it's what <em>you</em> are interested in :-) FLT can wait :-)</p>",
        "id": 432057594,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712606454
    },
    {
        "content": "<p>Huge upvote for PBW from me (-;</p>",
        "id": 432141326,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1712645260
    }
]