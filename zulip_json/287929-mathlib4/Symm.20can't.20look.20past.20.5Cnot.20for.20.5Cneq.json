[
    {
        "content": "<p>Consider the following example. I understand why the error is thrown in the second example, but it can get annoying in the middle of a large proof. Is it possible to make symm look past <del>unary prop operators</del> negations? :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"c1\">-- a ≠ b, or Ne a b is defined as ¬ (a = b) or a = b → False, and asserts that a and b are not equal.</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">symm</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">symm</span> <span class=\"c1\">-- error</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 421254487,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1707834653
    },
    {
        "content": "<p>I really, really wish <code>≠</code> was a notation, like <code>\\notin</code>; I guess it would worsen your issue, though</p>",
        "id": 421307484,
        "sender_full_name": "Emilie (Shad Amethyst)",
        "timestamp": 1707851013
    },
    {
        "content": "<p>Symm seems to be expecting a binary relation at the top of the expression tree. It sees a unary relation when it encounters the negation and stops. I guess an exception could be made for negation since it is so basic and there are multiple ways to express it.</p>",
        "id": 421308101,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1707851236
    },
    {
        "content": "<p>Would adding this work for you?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">symm</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">refine</span> <span class=\"n\">ne_comm.mp</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 421309354,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1707851717
    },
    {
        "content": "<p>I am not at my machine, but would it also work with multiple negations?</p>",
        "id": 421310287,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1707852078
    },
    {
        "content": "<p>If you have a double negation, then I would expect that you should first deal with cancelling negations and then symmetrize, if you wanted.</p>",
        "id": 421311244,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1707852452
    },
    {
        "content": "<p>In any case, this fails:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">symm</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">refine</span> <span class=\"n\">ne_comm.mp</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">symm</span> <span class=\"c1\">-- error</span>\n</code></pre></div>",
        "id": 421311359,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1707852495
    },
    {
        "content": "<p>I guess I am basically asking how I can transparently deal with inequalities  (\\neq) without thinking too hard about what form they are written in. Further <code>symm</code> works on the <code>neq</code> form while simp often reduces the <code>neq</code> form to <code>\\neg &lt;equality&gt;</code> form whic his useful in some cases but stops <code>symm</code> from working</p>",
        "id": 421311508,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1707852582
    },
    {
        "content": "<p><code>simp</code> should cancel repeated negations, so I would expect the outcome of <code>simp</code> to have at most one negation.  With that, the <code>macro</code> above should work, no?</p>",
        "id": 421311727,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1707852670
    },
    {
        "content": "<p>I think that it is reasonable to expect a tactic to work assuming that the goal in in <code>simp</code>-normal form.</p>",
        "id": 421311805,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1707852703
    },
    {
        "content": "<p>(Note that I am not saying that the <code>macro</code> above is fool-proof: I only tested it in the examples that you provided!  But some variation might be what you are looking for.)</p>",
        "id": 421311951,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1707852753
    },
    {
        "content": "<p>Is <code>(· ≠ ·)</code> special here? It seems it would be a valid feature request for <code>symm</code> for it to rw <code>¬ r a b ↔ ¬ r b a</code></p>",
        "id": 421726569,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708025731
    },
    {
        "content": "<p>My guess is that it is different, because it's <code>Ne</code>, not <code>Not (eq ...)</code>.</p>",
        "id": 421727235,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708025976
    },
    {
        "content": "<p>Sure, I should've said <code>(¬ · = ·)</code>. <code>symm</code> already applies to <code>(· ≠ ·)</code></p>",
        "id": 421727508,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708026053
    },
    {
        "content": "<p>Right. I was answering the question \"is it special here?\" It is -- it has a name. The docstring for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.applySymm#doc\">docs#Lean.MVarId.applySymm</a> says that <code>symm</code> works on binary relations for which the corresponding <code>symm</code> lemma exists and is tagged with <code>@[symm]</code>, and <code>Ne</code> is a binary relation, and <code>Ne.symm</code> is tagged with <code>@[symm]</code> in Mathlib.Init.Logic,  but <code>\\not Eq</code> doesn't fit into this framework. I guess one could ask for it to work on <code>\\not r</code> goals if <code>r.symm</code> is tagged with <code>@[symm]</code> -- might be a nice metaprogramming exercise!</p>",
        "id": 421729354,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708026727
    },
    {
        "content": "<p>Ah, I have a stale branch from waay back causing symm and trans to match the whole target to handle just this (mentioned in <a href=\"#narrow/stream/287929-mathlib4/topic/.60trans.60.2F.60symm.60.20changes\">mathlib4&gt;<code>trans</code>/<code>symm</code> changes</a>, and possibly elsewhere)—but then it conflicted with a different refactor (<a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/Reordering.20arguments.20of.20.02klzzwxh.3A0002.03\">#mathlib4 &gt; Reordering arguments of <code>Set.EqOn</code></a>) a couple months later, so I didn't pursue merging it. But it worked! (I think the relevant branches are <code>rfl-symm-trans-reducibility</code> and <code>rfl-symm-trans-enhance</code>, but they're likely horribly out of date.)</p>\n<p>Point is, it can be done...and matching the whole target after <code>whnfR</code> is one way to do it :)</p>",
        "id": 421730803,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1708027224
    },
    {
        "content": "<p>Matching the whole target is also good for more general relations, as it sets the stage for relations in which the arguments are buried in some expression or otherwise not literally the last two arguments, e.g. <code>HEq</code>. These aren't frequent, but <code>symm</code> and <code>trans</code> could handle them pretty painlessly with this modification + storing some extra data on \"where\" the arguments are in the expression (if necessary).</p>",
        "id": 421733381,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1708028234
    },
    {
        "content": "<p>Sorry, what does \"matching the whole target\" mean exactly? That it looks for a <code>@[symm]</code> lemma with a conclusion which unifies with the target?</p>",
        "id": 421747478,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708034061
    },
    {
        "content": "<p>Basically, yes: the way it works currently is that we destruct the target into <code>rel a b</code>, then match <code>rel</code> in the <code>DiscrTree</code>. If the target is not of this form, we fail. Instead, we could just match against the whole target, and then we'd have the chance to match against things like <code>Not (Eq a b)</code>.</p>",
        "id": 421747856,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1708034251
    },
    {
        "content": "<p>(Btw, in checking that this was still the case, I realized <code>symm</code> is currently in <code>std</code>, so perhaps this topic should move streams <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span>)</p>",
        "id": 421748335,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1708034453
    }
]