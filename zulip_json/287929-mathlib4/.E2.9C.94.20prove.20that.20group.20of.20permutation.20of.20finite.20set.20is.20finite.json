[
    {
        "content": "<p>I would like to define the category of permutations of a finite set and prove that it is finte.<br>\nIdeally I think I should be able to express this as an instance</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">SmallCategory</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">FinCategory</span> <span class=\"n\">B</span><span class=\"o\">]:</span>\n    <span class=\"n\">FinCategory</span> <span class=\"o\">(</span><span class=\"n\">GroupCat.of</span> <span class=\"o\">(</span><span class=\"n\">Equiv.Perm</span> <span class=\"n\">B</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"bp\">???</span>\n</code></pre></div>\n<p>To make smaller steps I tried to I tried to express it as a lemma</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">l2</span><span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">SmallCategory</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">FinCategory</span> <span class=\"n\">B</span><span class=\"o\">):</span>\n    <span class=\"n\">FinCategory</span> <span class=\"o\">(</span><span class=\"n\">GroupCat.of</span> <span class=\"o\">(</span><span class=\"n\">Equiv.Perm</span> <span class=\"n\">B</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"bp\">???</span>\n</code></pre></div>\n<p>but I cannot even prove </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">l1</span><span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">SmallCategory</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">FinCategory</span> <span class=\"n\">B</span><span class=\"o\">):</span>\n   <span class=\"n\">SmallCategory</span> <span class=\"o\">(</span><span class=\"n\">GroupCat.of</span> <span class=\"o\">(</span><span class=\"n\">Equiv.Perm</span> <span class=\"n\">B</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"bp\">???</span>\n</code></pre></div>\n<p>Or for that matter even (blush)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">l0</span><span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">SmallCategory</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">FinCategory</span> <span class=\"n\">B</span><span class=\"o\">):</span>\n   <span class=\"n\">Category</span> <span class=\"o\">(</span><span class=\"n\">GroupCat.of</span> <span class=\"o\">(</span><span class=\"n\">Equiv.Perm</span> <span class=\"n\">B</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"bp\">???</span>\n</code></pre></div>\n<p>I have looked around and think I have found relevant lemmas:<br>\nin GroupCat/Basic.lean</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fintypePerm</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"o\">(</span><span class=\"n\">Perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">permsOfFinset</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Finset.univ</span> <span class=\"n\">α</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mem_perms_of_finset_iff</span><span class=\"o\">]⟩</span>\n</code></pre></div>\n<p>so i know it is finite . Also, from GroupTheory.Perm.Basic.lean I have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">permGroup</span> <span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">Perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">Equiv.trans</span> <span class=\"n\">g</span> <span class=\"n\">f</span>\n  <span class=\"n\">one</span> <span class=\"o\">:=</span> <span class=\"n\">Equiv.refl</span> <span class=\"n\">α</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"n\">Equiv.symm</span>\n  <span class=\"n\">mul_assoc</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">trans_assoc</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"n\">one_mul</span> <span class=\"o\">:=</span> <span class=\"n\">trans_refl</span>\n  <span class=\"n\">mul_one</span> <span class=\"o\">:=</span> <span class=\"n\">refl_trans</span>\n  <span class=\"n\">mul_left_inv</span> <span class=\"o\">:=</span> <span class=\"n\">self_trans_symm</span>\n</code></pre></div>\n<p>So I know it is a group.<br>\nSo it seems I should just be able to tie it together,  but I need some handholding...<br>\nThanks!</p>",
        "id": 430023137,
        "sender_full_name": "Dan Synek",
        "timestamp": 1711616698
    },
    {
        "content": "<p>You ask about the category of permutations of a finite set, but in your code you seem to be talking about a finite category. <code>Equiv.Perm B</code> will presumably totally ignore the morphisms. What exactly are you trying to do mathematically?</p>",
        "id": 430075883,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711635006
    },
    {
        "content": "<p>Note also that <code>Category</code> is <em>data</em>, not a theorem statement (ie not a Prop). So <code>lemma l0 ... : Category ...</code> is not correct.</p>",
        "id": 430076294,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711635121
    },
    {
        "content": "<p>Thanks Kevin. As is often the case, when I started explaining what I wanted to do I found a host of mistakes.<br>\nI am a bit embarassed! I think my confusion comes from trying to think in terms of Lean, where I am confused by all the new concepts.<br>\nInstead I should make a plan what I want to express in terms of mathematics and then translate it to Lean.<br>\nOf course, how I express the mathematics depends on what is natural in Lean and what is already predefined, so it is not straightforward.</p>\n<p>Anyway, here is what I am trying to do and I would appreciate any pointers if I am on the right track.</p>\n<p>I thought a nice exercise in learning Lean would be to starting to formalize combinatorial species <a href=\"https://en.wikipedia.org/wiki/Combinatorial_species\">https://en.wikipedia.org/wiki/Combinatorial_species</a>.<br>\nA species is a functor F: B -&gt; B where B is the category of finite sets with bijections as morphims.<br>\nOf course one could formalize this by using the notion of Set in lean (as a characteristic function on a type),<br>\nbut to me that seemed not to be idiomatic Lean. , but more natural to use the category of finite types instead of sets with bijections as the morphisms in the category.</p>\n<p>My first mistake was that I thought that category would be FinCat, but now I see that FinCat is just a category with a <code>Fintype</code> of objects, and a <code>Fintype</code> for each morphism space.<br>\nSo not exctly what I wanted. Instead I want the category where objects are Fintypes, but where the morphisms are bijections. I will look for it, or define it.</p>\n<p>When I have that,  I then want to define a species (thus a functor) that for each finite object returns the object of all permutations and for each equivalence on<br>\nthat type returns the bijections on the type of permutations.</p>",
        "id": 430112382,
        "sender_full_name": "Dan Synek",
        "timestamp": 1711643505
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FintypeCat#doc\">docs#FintypeCat</a> is the category whose objects are finite types, and you can take its <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Core#doc\">docs#CategoryTheory.Core</a> to get the category whose morphism set is the bijections.</p>",
        "id": 430129073,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711647164
    },
    {
        "content": "<p>Note that if you want your morphisms to be defeq to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv#doc\">docs#Equiv</a> then you shouldn't use <code>CategoryTheory.Core</code>.</p>",
        "id": 430131720,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711647944
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  It worked!</p>",
        "id": 430550953,
        "sender_full_name": "Dan Synek",
        "timestamp": 1711953438
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"698527\">Dan Synek</span> has marked this topic as resolved.</p>",
        "id": 430550964,
        "sender_full_name": "Notification Bot",
        "timestamp": 1711953449
    }
]