[
    {
        "content": "<p>How can I \"translate\" a theorem that holds for every <code>Fin n</code> into a theorem that holds for every <code>Fintype</code> please?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">finFoo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">fintypeFoo</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- How can I use `finFoo` here?</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 439771401,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1716283437
    },
    {
        "content": "<p>Maybe with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.equivFin#doc\">docs#Fintype.equivFin</a> ?</p>",
        "id": 439771851,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1716283529
    },
    {
        "content": "<p>Though if possible, prefer to prove things for <code>Fintype</code> in the first place</p>",
        "id": 439772110,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1716283622
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60Fin.60.20to.20.60Fintype.60/near/439772110\">said</a>:</p>\n<blockquote>\n<p>Though if possible, prefer to prove things for <code>Fintype</code> in the first place</p>\n</blockquote>\n<p>The current syntax of <code>Finset.cons_induction_on</code> is quite ugly.</p>",
        "id": 439772791,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1716283848
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60Fin.60.20to.20.60Fintype.60/near/439771851\">said</a>:</p>\n<blockquote>\n<p>Maybe with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.equivFin#doc\">docs#Fintype.equivFin</a> ?</p>\n</blockquote>\n<p>Thanks, but how can I use it?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Card</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">finFoo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">fintypeFoo</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">Fintype.equivFin</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">finFoo</span> <span class=\"n\">_</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>At this point, the theorem appears to be proved, the only error message being \"no goals to be solved\".<br>\nUnfortunately, when I delete the <code>sorry</code> I get an error \"don't know how to synthesize placeholder for argument 'n'\".</p>",
        "id": 439773364,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1716284047
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">Fintype.equivFin</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">finFoo</span> <span class=\"o\">(</span><span class=\"n\">Fintype.card</span> <span class=\"n\">T</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 439774273,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1716284372
    },
    {
        "content": "<p>Thank you very much!!</p>",
        "id": 439774335,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1716284402
    },
    {
        "content": "<p>Interestingly, the following proof works as well:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Card</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">finFoo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">fintypeFoo</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n  <span class=\"n\">finFoo</span> <span class=\"o\">(</span><span class=\"n\">Fintype.card</span> <span class=\"n\">T</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 439774628,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1716284522
    },
    {
        "content": "<p>I believe that this only works because the definition of <code>Foo</code> does not actually depend on <code>T</code>. I think that in general it is not true that every thing that is true for <code>Fin n</code> is true for every <code>Fintype</code>. I would expect the following <code>sorry</code> not to be provable:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Card</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">T</span> <span class=\"bp\">=</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">finFoo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">fintypeFoo</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>You'll need to prove that you property is preserved by equivalence of types, so the setup would look something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Card</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">transfer_foo</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">≃</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span> <span class=\"n\">U</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">finFoo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">fintypeFoo</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n  <span class=\"n\">transfer_foo</span> <span class=\"o\">(</span><span class=\"n\">Fintype.equivFin</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">finFoo</span> <span class=\"o\">(</span><span class=\"n\">Fintype.card</span> <span class=\"n\">T</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 439775675,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1716284886
    },
    {
        "content": "<p>Is there any mechanism in Mathlib that would allow me to do the translation in cases where I use <code>T</code> only to index matrices and similar objects?</p>",
        "id": 439777076,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1716285459
    },
    {
        "content": "<p>As advocated by Eric above, the right approach is definitely to use a general Fintype to start with instead of <code>Fin n</code>.</p>",
        "id": 439778023,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1716285779
    },
    {
        "content": "<p>As long as <code>Finset.cons_induction_on</code> looks the way it looks now, this approach is not acceptable for me.</p>",
        "id": 439778216,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1716285838
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60Fin.60.20to.20.60Fintype.60/near/439772791\">said</a>:</p>\n<blockquote>\n<p>The current syntax of <code>Finset.cons_induction_on</code> is quite ugly.</p>\n</blockquote>\n<p>Can you show what you mean? What's wrong with <code>induction s using Finset.cons_induction_on</code>?</p>",
        "id": 439778409,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1716285887
    },
    {
        "content": "<p>What was it about cons_induction that you didn't like? I'm inferring that you inducted over n in Fin n, is that right?</p>\n<p>It might be that you're using the additive structure, or the order structure, of Fin n when you're reindexing. Or even the order embeddings between Fin n and Fin m. So a plain isomorphism of types might not suffice for your Foo. Not sure without a worked example.</p>",
        "id": 439778428,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1716285892
    },
    {
        "content": "<p>In the <code>Fin n</code> version, I have something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">m</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>In the <code>Fintype</code> version, I have something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction'</span> <span class=\"n\">hI</span> <span class=\"o\">:</span> <span class=\"o\">‹</span><span class=\"n\">Fintype</span> <span class=\"n\">I</span><span class=\"o\">›</span><span class=\"bp\">.</span><span class=\"n\">elems</span> <span class=\"n\">using</span> <span class=\"n\">Finset.cons_induction_on</span> <span class=\"k\">with</span> <span class=\"n\">_i</span> <span class=\"n\">_I</span> <span class=\"n\">_hi</span> <span class=\"n\">_ih</span>\n<span class=\"bp\">·</span>  <span class=\"gr\">sorry</span>\n<span class=\"bp\">·</span>  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>If I used <code>induction</code> in the second example as well, it would look even worse because this is what the theorem looks like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">cons_induction_on</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∅</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">⦄</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n  <span class=\"n\">cons_induction</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span> <span class=\"n\">s</span>\n</code></pre></div>\n<p>Not only the syntax of the code is ugly!<br>\nWorking with the Infoview is much harder, too.<br>\nI end up having <code>Fintype.elems = Finset.cons _i _I _hi</code> instead of <code>m.succ</code> from the <code>Fin</code> version.</p>",
        "id": 439779456,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1716286279
    },
    {
        "content": "<p>Note that many individual problems of <code>Finset.cons_induction_on</code> can be solved, but the total amount of inconveniences when working with it just discourages me from doing it heavy lifting in the <code>Fintype</code> version.</p>",
        "id": 439779735,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1716286384
    },
    {
        "content": "<p>How about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.induction_empty_option#doc\">docs#Fintype.induction_empty_option</a></p>",
        "id": 439779789,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1716286403
    },
    {
        "content": "<p>Note that that induction, underneath, uses Nat induction much like your existing n induction (making sure to keep it computable, even). If you're able to work with Option X in your reindexing, this should apply. Which I hope you can! Because I don't know how you deal with the n+1 case other than further casing on \"0 and nonzero\" or \"small and last\" and relying on the order embeddings that I referenced earlier.</p>",
        "id": 439780372,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1716286651
    },
    {
        "content": "<p>The situation is that whatever MWE I post here, it will be solvable in the <code>Fintype</code> version without too much trouble.<br>\nUnfortunately, in the full version, these \"many small issues\" become overwhelming.<br>\nThat's why I want to do the heavy lifting with <code>Fin</code> and then translate to <code>Fintype</code>.</p>",
        "id": 439780788,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1716286811
    },
    {
        "content": "<p>Can you link to existing code with an example? Perhaps a helper induction lemma can be factored out.</p>",
        "id": 439780870,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1716286851
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60Fin.60.20to.20.60Fintype.60/near/439780870\">said</a>:</p>\n<blockquote>\n<p>Can you link to existing code with an example?</p>\n</blockquote>\n<p>Tomorrow.</p>",
        "id": 439781085,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1716286947
    },
    {
        "content": "<p>I'd love to see an example of how you discharge the succ inductive case to learn more about what nice patterns you've developed</p>",
        "id": 439781126,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1716286960
    },
    {
        "content": "<p>If you're using order embeddings in reindexing as I imagine, perhaps one could have a more powerful Fintype induction that uses an internally invented linear order on the inductive case Fintypes.</p>",
        "id": 439781339,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1716287041
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60Fin.60.20to.20.60Fintype.60/near/439779456\">said</a>:</p>\n<blockquote>\n<p>In the <code>Fintype</code> version, I have something like:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction'</span> <span class=\"n\">hI</span> <span class=\"o\">:</span> <span class=\"o\">‹</span><span class=\"n\">Fintype</span> <span class=\"n\">I</span><span class=\"o\">›</span><span class=\"bp\">.</span><span class=\"n\">elems</span> <span class=\"n\">using</span> <span class=\"n\">Finset.cons_induction_on</span> <span class=\"k\">with</span> <span class=\"n\">_i</span> <span class=\"n\">_I</span> <span class=\"n\">_hi</span> <span class=\"n\">_ih</span>\n<span class=\"bp\">·</span>  <span class=\"gr\">sorry</span>\n<span class=\"bp\">·</span>  <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This sounds like you should generalize from a fintype to a finset inside a type</p>",
        "id": 439781391,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1716287048
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60Fin.60.20to.20.60Fintype.60/near/439781391\">said</a>:</p>\n<blockquote>\n<p>This sounds like you should generalize from a fintype to a finset inside a type</p>\n</blockquote>\n<p>I think that's more of an indication that it wasn't clear how to induct on Fintypes. If the use case is types in reindexing, non-univ finsets won't help. Since matrix reindexing takes types and isos between them iiuc.</p>",
        "id": 439781579,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1716287125
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60Fin.60.20to.20.60Fintype.60/near/439780870\">said</a>:</p>\n<blockquote>\n<p>Can you link to existing code with an example? Perhaps a helper induction lemma can be factored out.</p>\n</blockquote>\n<p>The following code isn't MWE. It is a \"real world\" example.</p>\n<p>Bartl's generalization of Farkas — <code>Fin</code> version:<br>\n<a href=\"https://github.com/madvorak/vcsp/blob/f9184d3c2a584d30087e0c3170b3103d7952f484/VCSP/FarkasBartl.lean#L190\">https://github.com/madvorak/vcsp/blob/f9184d3c2a584d30087e0c3170b3103d7952f484/VCSP/FarkasBartl.lean#L190</a></p>\n<p>Bartl's generalization of Farkas — <code>Fintype</code> version:<br>\n<a href=\"https://github.com/madvorak/vcsp/blob/f9184d3c2a584d30087e0c3170b3103d7952f484/VCSP/FarkasBartl.lean#L219\">https://github.com/madvorak/vcsp/blob/f9184d3c2a584d30087e0c3170b3103d7952f484/VCSP/FarkasBartl.lean#L219</a></p>\n<p>I haven't tried <code>Finset</code> version yet.<br>\nI haven't tried <code>Fintype.induction_empty_option</code> either.</p>",
        "id": 439861932,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1716311012
    },
    {
        "content": "<p>In this case you could replace <code>I</code> with a Finset coerced to a type, but it probably wouldn't be any better than your Fin version</p>",
        "id": 439871429,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1716314190
    },
    {
        "content": "<p>The empty/option version ought to work well here</p>",
        "id": 439871484,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1716314210
    },
    {
        "content": "<p>I see what you mean about the difficulty. I checked out your inductive step -- you do use a lot of the order embedding of the Fin n and Fin m in defining these:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">chop</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">F</span> <span class=\"n\">W</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">Fin</span> <span class=\"n\">m.succ</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">Fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨⟨</span>\n    <span class=\"k\">fun</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">A</span> <span class=\"n\">w</span> <span class=\"n\">i.castSucc</span><span class=\"o\">,</span>\n<span class=\"o\">[</span><span class=\"bp\">...</span><span class=\"o\">]</span>\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">auxLinMaps</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">F</span> <span class=\"n\">W</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">Fin</span> <span class=\"n\">m.succ</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">Fin</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨⟨</span>\n    <span class=\"n\">chop</span> <span class=\"n\">A</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">·</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">lt_add_one</span> <span class=\"n\">m</span><span class=\"o\">⟩</span> <span class=\"bp\">•</span> <span class=\"n\">chop</span> <span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n<span class=\"o\">[</span><span class=\"bp\">...</span><span class=\"o\">]</span>\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">auxLinMap</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">LinearOrderedAddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">F</span> <span class=\"n\">W</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">Fin</span> <span class=\"n\">m.succ</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨⟨</span>\n    <span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">·</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">lt_add_one</span> <span class=\"n\">m</span><span class=\"o\">⟩</span> <span class=\"bp\">•</span> <span class=\"n\">b</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n</code></pre></div>",
        "id": 439871853,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1716314327
    },
    {
        "content": "<p>Hmm this induction principle seems broken...</p>",
        "id": 439879154,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1716316818
    },
    {
        "content": "<p><a href=\"#narrow/stream/287929-mathlib4/topic/Fintype.2Einduction_empty_option.3A.20result.20not.20type.20correct\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Fintype.2Einduction_empty_option.3A.20result.20not.20type.20correct</a></p>",
        "id": 439879941,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1716317089
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260921\">Markus Himmel</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60Fin.60.20to.20.60Fintype.60/near/439775675\">said</a>:</p>\n<blockquote>\n<p>You'll need to prove that you property is preserved by equivalence of types, so the setup would look something like this:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Card</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">transfer_foo</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">≃</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span> <span class=\"n\">U</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">finFoo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">fintypeFoo</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n  <span class=\"n\">transfer_foo</span> <span class=\"o\">(</span><span class=\"n\">Fintype.equivFin</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">finFoo</span> <span class=\"o\">(</span><span class=\"n\">Fintype.card</span> <span class=\"n\">T</span><span class=\"o\">))</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I will probably use this approach.</p>\n<p>At first <code>transfer_foo</code> seemed like a hassle, but now I see that, if I were to use <code>Fintype.induction_empty_option</code> instead, I would have to prove <code>of_equiv</code> anyways.</p>",
        "id": 439942987,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1716344090
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> has marked this topic as resolved.</p>",
        "id": 440093047,
        "sender_full_name": "Notification Bot",
        "timestamp": 1716384815
    }
]