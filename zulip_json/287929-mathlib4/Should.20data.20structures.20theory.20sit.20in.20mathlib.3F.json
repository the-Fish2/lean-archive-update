[
    {
        "content": "<p>In mathlib, there is a file on binary trees: <code>Data/Tree.lean</code> and a file on array based heaps: <code>Data/BinaryHeap.lean</code>. Should they be moved to std or core, or stay in mathlib ?<br>\nFor heaps, there are different representations. The array based one in <code>Data/BinaryHeap.lean</code> seems concerned about performance and feels like it should be in std. But a heap could be defined more abstractly with a tree representation, which might be a good choice to study its theory in mathlib.  I'm really unsure about where binary trees should sit.</p>\n<p>How to decide where a data structure theorem should go?</p>",
        "id": 426883631,
        "sender_full_name": "Julien Michel",
        "timestamp": 1710588302
    },
    {
        "content": "<p>I think in general it's fine to PR any such theorem to mathlib, even if eventually things get moved elsewhere</p>",
        "id": 426885454,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710590267
    },
    {
        "content": "<p>It was said on the other topic that \"data structures\" should probably not go into mathlib.<br>\nI think an issue, is that categorizing concepts as being or not being a \"data structure\" feels a bit meaningless especially in lean's type theory.<br>\nGraphs are often qualified as \"data structures\" by programmers who solve engineering problems. But graphs are also in mathlib because they are mathematically interesting.<br>\nI believe many simple tree structures from CS have an elegant definition and are mathematically interesting to study, so why should they not be part of mathlib ? Only because they've been labeled a \"data structure\" ?</p>\n<p>Thanks for your thoughts or clarifications</p>",
        "id": 426890943,
        "sender_full_name": "Julien Michel",
        "timestamp": 1710595559
    },
    {
        "content": "<p><a href=\"#narrow/stream/287929-mathlib4/topic/Should.20data.20structures.20theory.20sit.20in.20mathlib.3F/near/426890943\">A message</a> was moved here from <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4/topic/github.20permission\">#mathlib4 &gt; github permission</a> by <span class=\"user-mention silent\" data-user-id=\"697190\">Julien Michel</span>.</p>",
        "id": 426916936,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710618367
    },
    {
        "content": "<p>You raise interesting questions. I have what you might perceive as a very narrow view of mathematics. In my undergraduate maths degree I did a course on graph theory but I didn't do any course on abstract data structures and hence I regard them as computer science. I have no idea what made my university draw the line where they drew it. It's the job of the mathlib maintainers to decide where they want to draw the line here.</p>",
        "id": 426921129,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710622457
    },
    {
        "content": "<p>Sorry, I didn't intend to say that they were out of scope. Rather that work that is useful outside of mathematical or theoretical applications should ideally go outside of Mathlib!</p>\n<p>Mathlib is gigantic, and makes little attempt at this point to be backwards compatible (not that Lean itself does better!), and freely occupies the root namespace. All of these as practical matters make it difficult for some projects to consider having Mathlib as a dependency,  </p>\n<p>Hence if \"data structures\" if interpreted as generally useful things like Std's RBMap, then Mathlib is not the best home.</p>",
        "id": 426922388,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710623740
    },
    {
        "content": "<p>I think it's just that most of these data structures have a different form depending on if you want to reason about them (mathlib would be a nice place), or if you want to use them to build fast software (Std would be a nice place). <br>\nThat's how I would personally draw the line (but I'm curious what other people think).</p>\n<p>A basic example I mentioned is that of a binary heap. For me, a heap defined as a tree has its place in mathlib, but software engineers might want an efficient heap in Std that's implemented via an array.<br>\nAnother example is Array vs List.  I think there should be no occurrence of Array's in mathlib given it's just the same thing but with optimized access.</p>\n<p>I would be interested in formalizing some structures at the bottom of this page <a href=\"https://en.wikipedia.org/wiki/Tree_(data_structure)\">https://en.wikipedia.org/wiki/Tree_(data_structure)</a>  in mathlib, but as I was suggesting, only in their easy-to-reason-about form.</p>",
        "id": 426922460,
        "sender_full_name": "Julien Michel",
        "timestamp": 1710623784
    },
    {
        "content": "<p>More generally, I really hope that one day we move towards a world where e.g. graph theory / basic category theory / the basic algebraic hierarchy could be in separate libraries from Mathlib. They might still be in the same repository for convenience, but usable as separate dependencies.</p>",
        "id": 426922502,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710623837
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>  Thank you for answering, that clarifies things. That just gave me an idea (perhaps silly):</p>\n<p>Why not split Std into two packages : Std (only data and code, no theorems) and StdTheory (only theorems about Std, or relating Std to other stuff) with these dependencies: </p>\n<p>Std -&gt; Core<br>\nStdTheory -&gt; Std<br>\nStdTheory -&gt; Mathlib -&gt; Core</p>\n<p>One advantage is that StdTheory can use all the power of math to say things about Std. Std can be built fast and be lightweight, and doesn't hold any proofs.</p>\n<p>Now If I'm a programmer interested in creating verified software, I would create two packages : Software (only data and code, no theorems), SoftwareTheory (theorems about Software) with the following dependencies:</p>\n<p>Software -&gt; Std<br>\nSoftwareTheory -&gt; Software<br>\nSoftwareTheory -&gt; StdTheory</p>\n<p>SoftwareTheory could prove stuff about Software using all of StdTheory, or even Mathlib if necessary, but at least Software has minimal dependencies.</p>\n<p>Note that Mathlib should not depend on Std nor StdTheory anymore. Most theorems in Core could probably be moved to Mathlib or some other CoreTheory package.</p>\n<p>To sum it up, would that make sense to decouple theorems and defs completely in different packages?</p>",
        "id": 426936888,
        "sender_full_name": "Julien Michel",
        "timestamp": 1710631549
    },
    {
        "content": "<p>The reality is that definitions and theorems are rather entangled, and you can't get away with writing all of the former before writing any of the latter. Sometimes you can't define a function without proving that the recursion is well-founded, and this is much more difficult to do if no theorems are yet available for any of your types.</p>",
        "id": 426939684,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710632304
    },
    {
        "content": "<p>We want <em>fewer</em> things depending on Mathlib, not more. :-)</p>",
        "id": 426940327,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710632488
    },
    {
        "content": "<p>Another example of this is the <code>@[csimp]</code> attribute; this lets you prove that an efficient function is equal to a simple one, and tells the compiler that the efficient one always can be used in place of the simple one. But this attribute goes on a <code>theorem</code>, and so if you put it in <code>SoftwareTheory</code>, now your functions are slow unless people import the theory library.</p>",
        "id": 426940394,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710632506
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Should.20data.20structures.20theory.20sit.20in.20mathlib.3F/near/426922502\">said</a>:</p>\n<blockquote>\n<p>More generally, I really hope that one day we move towards a world where e.g. graph theory / basic category theory / the basic algebraic hierarchy could be in separate libraries from Mathlib. They might still be in the same repository for convenience, but usable as separate dependencies.</p>\n</blockquote>\n<p>I think it's important to note the \"one day\" here. If you have a graph theory result or a result about some other definition in mathlib, then at least today that result also belongs in mathlib</p>",
        "id": 426940752,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710632602
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 426941480,
        "sender_full_name": "Julien Michel",
        "timestamp": 1710632798
    },
    {
        "content": "<p>Regarding termination, maybe there should be a way to prove termination elsewhere, just like the <code>attribute</code> command can add simp lemmas later</p>",
        "id": 426942146,
        "sender_full_name": "Julien Michel",
        "timestamp": 1710632988
    },
    {
        "content": "<p>For the <code>@[csimp]</code> theorems, I'm not sure you care, because if you have the fast function in Software, you just use it. I don't see why you would use them for something else than proofs</p>",
        "id": 426942924,
        "sender_full_name": "Julien Michel",
        "timestamp": 1710633202
    },
    {
        "content": "<p>I'm saying that Software and Std code wouldn't depend on Mathlib. <br>\nFor building executable software under time and memory constraints, I agree it feels important to have few dependencies.  <br>\nBut if you're interest is only in proving, do you really care that much about the time or the memory it will take ? You would only care that you're Theory typechecks once and that's it. Wouldn't you?</p>",
        "id": 426944006,
        "sender_full_name": "Julien Michel",
        "timestamp": 1710633509
    },
    {
        "content": "<p>Std does not depend on mathlib, the dependency is the other way around; because mathematicians need the basic operations on Nat and List that Std provides.</p>",
        "id": 426944650,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710633678
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Should.20data.20structures.20theory.20sit.20in.20mathlib.3F/near/426940327\">said</a>:</p>\n<blockquote>\n<p>We want <em>fewer</em> things depending on Mathlib, not more. :-)</p>\n</blockquote>\n<p>Yes I know I thought Scott was implying that I said Std should depend on Mathlib. But I only meant StdTheory could</p>",
        "id": 426945024,
        "sender_full_name": "Julien Michel",
        "timestamp": 1710633775
    },
    {
        "content": "<p>Yes, I was saying that having a StdTheory that depends on Mathlib is not viable.</p>",
        "id": 426945226,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710633829
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"697190\">Julien Michel</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Should.20data.20structures.20theory.20sit.20in.20mathlib.3F/near/426942146\">said</a>:</p>\n<blockquote>\n<p>Regarding termination, maybe there should be a way to prove termination elsewhere, just like the <code>attribute</code> command can add simp lemmas later</p>\n</blockquote>\n<p>The problem is that this allows functions to exist that don't terminate at all, and now everything is unsound and proofs are meaningless.</p>",
        "id": 426945384,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710633872
    },
    {
        "content": "<p>But it is possible to do that with the partial keyword already?</p>",
        "id": 426945629,
        "sender_full_name": "Julien Michel",
        "timestamp": 1710633944
    },
    {
        "content": "<p>But it's true that you can't unfold the defs I think</p>",
        "id": 426945760,
        "sender_full_name": "Julien Michel",
        "timestamp": 1710633974
    },
    {
        "content": "<p>You could enforce that the termination is eventually proved in some downstream file but now a) you can't import your Software without also importing SoftwareTheory and b) it is much harder to ensure that proofs are not mutually cyclic if proofs of early results (termination) can appear after later results</p>",
        "id": 426945908,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710634012
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"697190\">Julien Michel</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Should.20data.20structures.20theory.20sit.20in.20mathlib.3F/near/426945629\">said</a>:</p>\n<blockquote>\n<p>But it is possible to do that with the partial keyword already?</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ohno</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"n\">ohno</span>\n</code></pre></div>\n<p>is not legal even with <code>partial</code></p>",
        "id": 426946024,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710634044
    },
    {
        "content": "<p>But the only way you can find out in general is by forcing the user to prove termination</p>",
        "id": 426946142,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710634075
    },
    {
        "content": "<p>(it's legal with <code>unsafe</code>, which is maybe your answer here)</p>",
        "id": 426946364,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710634129
    },
    {
        "content": "<p>Writing a function like that <code>partial def loop (x : Nat) : Nat := loop 0</code> compiles and runs (even if it doesn't terminate), and its not unsafe code. So I believe useful software functions could be written in Software and proven to terminate in a non-imported SoftwareTheory. I don't really know about b), I'll think more about it. Thank you for these answers</p>",
        "id": 426948104,
        "sender_full_name": "Julien Michel",
        "timestamp": 1710634590
    },
    {
        "content": "<p>You can't prove the termination of <code>partial def</code> after the fact. Once you use <code>partial</code>, you get a fully opaque function which is useless for reasoning purposes. So if StdTheory wants to prove facts about functions defined in Std, those functions have to be defined without using <code>partial</code> and proving termination on the spot.</p>",
        "id": 426977904,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710643115
    },
    {
        "content": "<p>Some of the division you are describing does exist in Std already, in particular there are things like <code>Std.Data.Array.Basic</code> with the definitions and <code>Std.Data.Array.Lemmas</code> with the theorems, with the intent that you can import just the first part if you just want to do programming and don't care about the proofs.</p>",
        "id": 426978289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710643228
    },
    {
        "content": "<p>But sometimes there are theorems that are needed by <code>Std.Data.Array.Basic</code> because of the aforementioned reasons, so there is <code>Std.Data.Array.Init.Lemmas</code> for holding those \"bootstrapping\" lemmas.</p>",
        "id": 426978504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710643292
    }
]