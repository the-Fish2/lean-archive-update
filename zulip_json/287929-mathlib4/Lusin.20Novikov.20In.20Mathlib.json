[
    {
        "content": "<p>I'm currently working on a formalization of the Lusin Novikov theorem, and you can see my adventures in doing so in <a href=\"#narrow/stream/116395-maths/topic/Setting.20up.20appropriate.20definitions.20for.20Lusin-Novikov\">this thread</a> and <a href=\"#narrow/stream/116395-maths/topic/.E2.9C.94.20Triangle.20inequality.20arguments.20and.20bijecting.20from.20N.20x.20N.20.2E.2E.2E\">this thread</a>. I would eventually like to push this to Mathlib, and some people encouraged me to start this process early rather than at the end, so here I am.</p>\n<p>I've never done this before and have essentially no experience with GitHub, so where would I start with this? Is there a \"Mathlib PRs for dummies\" that I can read somewhere?</p>\n<p>I also have some questions related to organization. This project has three parts that are somewhat independent of each other: definitions and properties relating to sigma ideals (which, so far as I can tell, are not implemented anywhere in Mathlib, so I used the dual filters instead and proved some convenience lemmas); two topology observations that are kind of separate from anything else (not sure if these should be in the main file or somewhere else, but I don't know where else they'd be, as they seem pretty much only useful for this project); and then the core definition of null collections and a bunch of results surrounding it, culminating in the main theorem. Should these all be in separate PRs?</p>\n<p>I have everything I've done so far in <a href=\"/user_uploads/3121/rujub5VCRHuWej14jrW-S8n7/LusinNovikov.lean\">LusinNovikov.lean</a>, which consists of the definition of the sigma ideal and convenience lemmas, beginning work on the two lemmas in the paper, and proofs of the two topology observations. (Yes I know that this code is very inefficient at many points; I'm currently just trying to get things that work.)</p>\n<p>Any suggestions/advice on what I should do?</p>",
        "id": 419298376,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1706808748
    },
    {
        "content": "<p>Voila: <a href=\"https://leanprover-community.github.io/contribute/index.html\">https://leanprover-community.github.io/contribute/index.html</a></p>\n<p>This should get you started. Please let me know if you have further questions about the PR process.</p>",
        "id": 419298671,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1706808837
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span>, isn't a sigma ideal exactly a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Bornology#doc\">docs#Bornology</a> ?</p>",
        "id": 419316128,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706814974
    },
    {
        "content": "<p>There's a difference -- sigma ideals allow countable unions rather than just finite unions.</p>",
        "id": 419316902,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706815296
    },
    {
        "content": "<p>Looking at the Wikipedia definition I don't think so because of the \"countable union\" axiom. It seems to be the dual of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CountableInterFilter#doc\">docs#CountableInterFilter</a></p>",
        "id": 419317154,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1706815405
    },
    {
        "content": "<p>Okay I see</p>",
        "id": 419317321,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706815461
    },
    {
        "content": "<p>It seems like this might be a better place to ask then in <a class=\"stream\" data-stream-id=\"116395\" href=\"/#narrow/stream/116395-maths\">#maths</a> , so I'll do it here. I've now finished the two topological observations and the two lemmas, and am now trying to complete the proof. For convenient reference, the original paper is <a href=\"/user_uploads/3121/Bkz5vqwssOB69JlqewouIpXL/Lusin-Novikov.pdf\">Shinko-Lusin-Novikov.pdf</a>. The proof as written in that paper isn't particularly suited for formalization in Lean directly (or at the very least, I'm not sure how to do it, so I've expanded on the splitting and Cantor scheme process a bit more in <a href=\"/user_uploads/3121/6Z3wwoIh3fDGW8yV0U7vWnpL/Outline.pdf\">Outline.pdf</a>.</p>\n<p>That leads me to where I'm asking for help now. I'm reasonably convinced that I can implement a proof for the splitting lemma as written in the outline. That being said, I'm not sure how to go from that splitting lemma to the rest of the proof, so I'd rather figure that out first in case I need to modify it. I mainly plan on using the infrastructure in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/MetricSpace/CantorScheme.html#CantorScheme.inducedMap\">docs#CantorScheme.inducedMap</a> to witness option (2) in light of failure of (1), but I'm not really sure how to construct the Cantor scheme. The main example I know of is <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/MetricSpace/Perfect.html#Perfect.exists_nat_bool_injection\">docs#Perfect.exists_nat_bool_injection</a> (I'll tag <span class=\"user-mention\" data-user-id=\"464202\">@Felix Weilacher</span> as the author of both of these), but that one involves a splitting lemma only dependent on a single set, where as the Lusin-Novikov argument depends on splitting an entire collection of sets at a time, and I'm not really sure how to actually define the scheme.</p>\n<p>Does anyone have any ideas on how I could do this? I'm happy to do most of the work in formalizing the splitting lemma and proving the resulting scheme actually has the properties we want it to, but I'm not really sure what precise statement of the splitting lemma is ideal or how to actually define the scheme.</p>",
        "id": 422476842,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1708453568
    },
    {
        "content": "<p>A cantor scheme here is a map from <code>List Bool</code> to <code>Set X</code>. It seems like the splitting lemma as you've set it up will let you construct such a map by induction on the length of the input list. What's the issue?</p>",
        "id": 422478744,
        "sender_full_name": "Felix Weilacher",
        "timestamp": 1708454279
    },
    {
        "content": "<p>I suppose first off that I'm not actually sure how to define a function from <code>List Bool</code> by induction on the length of the list. I see how to define things based on pattern matching <code>nil</code> vs. <code>a :: l</code>, but the latter seems too \"local\" to the specific list to be able to apply the splitting lemma to all lists of the same length at once. I guess my first question is what the setup for inducting on the length of the list in a definition would look like. (Are there any examples of such definitions in Mathlib?)</p>\n<p>But beyond that, the tools I have built up thus far would enable splitting a <code>Finset (Set X)</code>, but I'm not sure how to actually index that <code>Finset</code> using the finite strings. I'd imagine I'd want to do that with the splitting lemma, namely having the result of the splitting be indexed by a <code>Bool</code>. I've just not been successful in wrapping my head around that. (Namely, what should the actual types of the inputs and outputs to my splitting lemma be; I currently have unindexed finsets but eventually will need to index them by <code>List Bool</code>s.)</p>",
        "id": 422482184,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1708455555
    },
    {
        "content": "<p>Maybe you could define a function <code>f : Nat \\to P</code> by induction, where <code>f 0 = X</code>, <code>f n</code> has size 2^n, etc. Then afterwards give the appropriate bijection, for each n, between strings of length n and <code>f n</code>.</p>",
        "id": 422622344,
        "sender_full_name": "Felix Weilacher",
        "timestamp": 1708523551
    },
    {
        "content": "<p>Inducting on list length would be nice, but I also am not sure how to do it.</p>",
        "id": 422622507,
        "sender_full_name": "Felix Weilacher",
        "timestamp": 1708523601
    }
]