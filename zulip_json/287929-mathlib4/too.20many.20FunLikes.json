[
    {
        "content": "<p>A student got into the following mes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Ideal.map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→+*</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">I</span> <span class=\"bp\">=</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Ideal.map</span> <span class=\"n\">f</span> <span class=\"n\">I</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  h : Ideal.map (↑f) I = J</span>\n<span class=\"cm\">  ⊢ x ∈ Ideal.map f I ↔ x ∈ I</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Their goal involved <code>Ideal.map f</code>for <code>f</code> an algebra hom (in fact it was an algebra equiv) and they had some hypothesis which involved <code>Ideal.map (f : A -&gt;+* A)</code> and so <code>rw</code> was failing. Is there some painless way to move from one to the other (here <code>f</code> was a very complex function).</p>",
        "id": 428198551,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711047998
    },
    {
        "content": "<p>One might wonder whether there is or should be a simp lemma</p>",
        "id": 428198840,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1711048117
    },
    {
        "content": "<p>What would such a simp lemma say?</p>",
        "id": 428199760,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711048526
    },
    {
        "content": "<p>you can always change: <code>change Ideal.map f I = J at h</code></p>",
        "id": 428199894,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711048579
    },
    {
        "content": "<p>The problem with <code>change</code> is that <code>f</code> is huge</p>",
        "id": 428200211,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711048730
    },
    {
        "content": "<p>Alternatively we could redefine <code>Ideal.map</code> to have the following type: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Ideal.map</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">S</span>\n</code></pre></div>\n<p>... yes, that's a plain old function.</p>",
        "id": 428200310,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711048780
    },
    {
        "content": "<p>then rely on the coercion to functions for all these <code>FunLike</code>s</p>",
        "id": 428200358,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711048801
    },
    {
        "content": "<p>Now I'm sure that <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> will tell us why that's a terrible idea.</p>",
        "id": 428200511,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711048857
    },
    {
        "content": "<p>we really need some automation that would let us write <code>letMatch Ideal.map $f I = J := \\goal</code> to obtain <code>let f := ...</code> in context, so that you can work easily with <code>f</code>. I think <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> was trying to implement such a thing at some point?</p>",
        "id": 428200903,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711049007
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/too.20many.20FunLikes/near/428199760\">said</a>:</p>\n<blockquote>\n<p>What would such a simp lemma say?</p>\n</blockquote>\n<p>I guess you would need a simp lemma like <code>Ideal.map_toRingHom</code> below for every <code>XXXHomClass</code> :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">lemma</span> <span class=\"n\">Ideal.map_toRingHom</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FunLike</span> <span class=\"n\">F</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">RingHomClass</span> <span class=\"n\">F</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ideal.map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"n\">I</span> <span class=\"bp\">=</span> <span class=\"n\">Ideal.map</span> <span class=\"n\">f</span> <span class=\"n\">I</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Ideal.map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→+*</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">I</span> <span class=\"bp\">=</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Ideal.map</span> <span class=\"n\">f</span> <span class=\"n\">I</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">J</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 428201209,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711049109
    },
    {
        "content": "<p>note that <code>Ideal.map</code> only needs a plain old <code>FunLike</code>.</p>",
        "id": 428201296,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711049150
    },
    {
        "content": "<p>I was going to work on it, but then <span class=\"user-mention\" data-user-id=\"579936\">@Gareth Ma</span> wanted to do it. He was getting help from <span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span>, but I think got too busy and it languished. There is a PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/7890\">#7890</a>, but it's not finished.</p>",
        "id": 428201427,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711049182
    },
    {
        "content": "<p>I'm a bit busy with other things, but I could hopefully attempt to return to it in a few weeks if no one else does.</p>",
        "id": 428201580,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711049234
    },
    {
        "content": "<p>FWIW the PR kinda works, it's just buggy</p>",
        "id": 428201670,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1711049271
    },
    {
        "content": "<p>Gareth, can you find the old thread about it and we can continue discussion of this there? It would be good to know exactly what the bugs are.</p>",
        "id": 428201855,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711049333
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/too.20many.20FunLikes/near/428200511\">said</a>:</p>\n<blockquote>\n<p>Now I'm sure that <span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> will tell us why that's a terrible idea.</p>\n</blockquote>\n<p>Actually, I don't think it's a bad idea. The current definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ideal.map#doc\">docs#Ideal.map</a> strikes me as a bit weird: It doesn't use an unbundled function nor does it assume <code>f</code> preserves addition and scalar multiplication.</p>",
        "id": 428201869,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711049337
    },
    {
        "content": "<p>ya <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Help.20with.20writing.20tactic/near/428201984\">https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Help.20with.20writing.20tactic/near/428201984</a></p>",
        "id": 428202012,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1711049385
    },
    {
        "content": "<p><a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Help.20with.20writing.20tactic/near/398919178\">https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Help.20with.20writing.20tactic/near/398919178</a> you can see the \"works\" and \"fails\" here<br>\nBut at least there's a \"work\"! <span aria-label=\"sweat\" class=\"emoji emoji-1f613\" role=\"img\" title=\"sweat\">:sweat:</span></p>",
        "id": 428202229,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1711049441
    },
    {
        "content": "<p>It looks like <code>Ideal.map</code> use to assume <code>RingHomClass F R S</code> as well, but after the <code>FunLike</code> refactor, the <code>variable</code> assumptions split into <code>FunLike F R S</code> and <code>RingHomClass F R S</code>, and the latter was no longer assumed by <code>Ideal.map</code> definition since it's unused. (<a href=\"https://github.com/leanprover-community/mathlib4/blame/b6fe43dfe490d6749abab69bd8135fa836cb6017/Mathlib/RingTheory/Ideal/Operations.lean#L1394\">Git blame</a>)</p>",
        "id": 428202612,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711049581
    },
    {
        "content": "<p>Yes, I think we should redefine <code>Ideal.map</code> to take a bare function.</p>",
        "id": 428202700,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711049616
    },
    {
        "content": "<p>In any case, adding simp lemmas such as </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">lemma</span> <span class=\"n\">Ideal.map_toRingHom</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FunLike</span> <span class=\"n\">F</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">RingHomClass</span> <span class=\"n\">F</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ideal.map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"n\">I</span> <span class=\"bp\">=</span> <span class=\"n\">Ideal.map</span> <span class=\"n\">f</span> <span class=\"n\">I</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>seems like a very bad idea to me.</p>",
        "id": 428202701,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711049618
    },
    {
        "content": "<p>Should <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ideal.comap#doc\">docs#Ideal.comap</a> also be changed to take <code>R →+* S</code> instead of <code>F</code> where <code>[RingHomClass F R S]</code>?</p>",
        "id": 428204644,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711050257
    },
    {
        "content": "<p>Maybe!</p>",
        "id": 428204838,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711050320
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> do you have any thoughts about this?</p>",
        "id": 428205689,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711050628
    },
    {
        "content": "<p>The point of hom classes is precisely to avoid taking specific hom types in</p>",
        "id": 428207124,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711051228
    },
    {
        "content": "<p>Right, <code>Ideal.comap</code> should not change.</p>",
        "id": 428207496,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711051369
    },
    {
        "content": "<p>Couldn't the motivating example at the top of the thread have happened just as easily with <code>comap</code>? We're solving it for <code>map</code> but not for <code>comap</code></p>",
        "id": 428208097,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711051600
    },
    {
        "content": "<p>I disagree. IMO the point of hom classes is to avoid duplication for lemmas <em>about</em> homs. In this case, you're using a hom to construct some object. You can modify Kevin's example as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Ideal.comap</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→+*</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">I</span> <span class=\"bp\">=</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Ideal.comap</span> <span class=\"n\">f</span> <span class=\"n\">I</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">J</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">--fails</span>\n</code></pre></div>",
        "id": 428208168,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711051626
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/too.20many.20FunLikes/near/428208168\">said</a>:</p>\n<blockquote>\n<p>IMO the point of hom classes is to avoid duplication for lemmas <em>about</em> homs. In this case, you're using a hom to construct some object.</p>\n</blockquote>\n<p>I'll let Anne disagree</p>",
        "id": 428208487,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711051739
    },
    {
        "content": "<p>How do you propose to resolve the example above then?</p>",
        "id": 428208613,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711051789
    },
    {
        "content": "<p>And if it's okay for <code>Ideal.map</code> to take a function, why is it not okay for <code>Ideal.comap</code> to take an actual ring hom?</p>",
        "id": 428208690,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711051809
    },
    {
        "content": "<p>please explain to me the benefits of the current definition of <code>Ideal.comap</code> using <code>RinHomClass</code></p>",
        "id": 428209087,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711051970
    },
    {
        "content": "<p>The benefit is that you don't need to coerce to ring homs every time, nor do you need to even <em>have</em> a coercion anymore.</p>",
        "id": 428209238,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711052028
    },
    {
        "content": "<p>what's the issue  with coercing?</p>",
        "id": 428209370,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711052065
    },
    {
        "content": "<p>That you now need to write <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">n^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> lemmas about those coercions where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> is the depth of your hierarchy</p>",
        "id": 428209586,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711052144
    },
    {
        "content": "<p>What lemmas?</p>",
        "id": 428209745,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711052190
    },
    {
        "content": "<p>I'm just talking about <code>Ideal.comap</code>.</p>",
        "id": 428209767,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711052198
    },
    {
        "content": "<p>The point I'm trying to make is that I see at least two issues with the use of <code>RinHiomClass</code> in the definition of <code>Ideal.comap</code>. One is essentially Kevin's example. The other is that quite often I want to write <code>J.comap _</code> and get some help from Lean in filling in the blank, but at that point lean has no way of telling the actual type of <code>_</code>, so I have to go in blind.</p>",
        "id": 428210411,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711052443
    },
    {
        "content": "<p>I completely understand and agree that these hom classes are useful for avoiding duplication in lemmas like <code>map_add</code> and <code>map_mul</code>, etc., but I honestly don't see any benefit in using them in the definition of things like <code>Ideal.comap</code>.</p>",
        "id": 428210656,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711052525
    },
    {
        "content": "<ol>\n<li>Kevin's example is weird because the hypothesis has an unnecessary coercion.</li>\n<li>If you don't take a class and instead take an actual hom, then you actually have to coerce your algebra morphism to a ring morphism when you call <code>Ideal.comap</code></li>\n</ol>",
        "id": 428211105,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711052700
    },
    {
        "content": "<p>Re (2), I understand, but why is that a problem?</p>",
        "id": 428211422,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711052814
    },
    {
        "content": "<p>Lean will know to expect a ring hom, and it should insert the coercion without any further hints from the user in almost all cases</p>",
        "id": 428211479,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711052836
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FunLike</span> <span class=\"n\">F</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">RingHomClass</span> <span class=\"n\">F</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Ideal.comap'</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">I.comap'</span> <span class=\"n\">f</span>\n</code></pre></div>",
        "id": 428211819,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711052960
    },
    {
        "content": "<p>Yes so the idea was to get rid of that coercion <code>F → R →+* S</code> in the presence of <code>RingHomClass F R S</code> because this has bad performance</p>",
        "id": 428212025,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711053017
    },
    {
        "content": "<p>For what it's worth, from <a href=\"https://loogle.lean-lang.org/?q=%22.comap%22%2C+%7C-+%28_+%3A+Type+_%29\">a loogle search</a>, we are not consistent on this either way. e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subsemigroup.comap#doc\">docs#Subsemigroup.comap</a> uses bundled homs</p>",
        "id": 428213970,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711053670
    },
    {
        "content": "<p>That's correct, but it's because we never got around to finishing it.</p>",
        "id": 428214021,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711053692
    },
    {
        "content": "<p>Is it not possible to solve such performance issues with unification hints?</p>",
        "id": 428214577,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711053895
    },
    {
        "content": "<p>Adam, there are a few issues that can arise, including having multiple of these <code>FunLike</code> coercions. This can be a royal pain because If <code>f : A →ₐ[R] A</code>, then we have no rewrite lemmas that allow you change <code>((f : A →+* A) : A →* A)</code> into <code>(f : A →* A)</code>, and indeed, having such lemmas would lead to the <code>n ^ 2</code> problem Yaël mentioned.</p>",
        "id": 428214625,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711053920
    },
    {
        "content": "<p>Mario has told me that using unification hints is bad. I think the idea is that if you need a unification hint, then there's something about unification that should be improved, but maybe I've misunderstood that point.</p>",
        "id": 428214781,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711053979
    },
    {
        "content": "<p>Ok, I still don't see how this <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">n^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> issue plays any role for the very specific example of <code>Ideal.comap</code>.</p>",
        "id": 428215076,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711054090
    },
    {
        "content": "<p>And I think the performance issue is more closely linked to the need to repeatedly bundle into a new morphism. (but maybe I'm wrong here.)</p>",
        "id": 428215096,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711054098
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/too.20many.20FunLikes/near/428215096\">said</a>:</p>\n<blockquote>\n<p>And I think the performance issue is more closely linked to the need to repeatedly bundle into a new morphism. (but maybe I'm wrong here.)</p>\n</blockquote>\n<p>Wouldn't this bundling happen precisely once?</p>",
        "id": 428215186,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711054137
    },
    {
        "content": "<p>Once every time you call <code>Ideal.comap</code>, but like I said, I may be misdiagnosing here.</p>",
        "id": 428215636,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711054318
    },
    {
        "content": "<p>Maybe it's just me, but I think examples like this are really bad:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Ideal.comap</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→+*</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">I</span> <span class=\"bp\">=</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Ideal.comap</span> <span class=\"n\">f</span> <span class=\"n\">I</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">J</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">--fails</span>\n</code></pre></div>",
        "id": 428215940,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711054434
    },
    {
        "content": "<p>Again, that's just weird. Why is there a coercion in <code>h</code>?</p>",
        "id": 428216037,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711054456
    },
    {
        "content": "<p>These clearly show up in nature, as Kevin pointed out above.</p>",
        "id": 428216067,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711054468
    },
    {
        "content": "<p>But should it have? I mean, how did this <code>h</code> show up naturally? I'm not saying it couldn't, only that I don't understand yet how.</p>",
        "id": 428216189,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711054515
    },
    {
        "content": "<p>It's not unreasonable for such issues to show up. For example what if you're using morphisms in <code>RingCat</code>. It's not like we can generalize the <em>category</em> of rings using <code>RingCatHom</code>!</p>",
        "id": 428216266,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711054541
    },
    {
        "content": "<p>Maybe <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> can tell us how his student wound up with such a situation.</p>",
        "id": 428216444,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711054591
    },
    {
        "content": "<p>I don't hear the music here. How does using morphisms in <code>RingCat</code> cause this to arise naturally?</p>",
        "id": 428216460,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711054595
    },
    {
        "content": "<p>I may have an idea for how to deal with these issues, but I haven't yet fleshed it out enough to know.</p>",
        "id": 428216877,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711054748
    },
    {
        "content": "<p>Due to the missing n^2 simp lemmas that Yaël's talking about, I think we can end up with a very similar issue to Kevin's if we switch <code>Ideal.comap</code> to use bundled homs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Ideal.comap'</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- Adaptation of Kevin's example:</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FunLike</span> <span class=\"n\">F</span> <span class=\"n\">A</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AlgHomClass</span> <span class=\"n\">F</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Ideal.comap'</span> <span class=\"o\">((</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→+*</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">I</span> <span class=\"bp\">=</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Ideal.comap'</span> <span class=\"n\">f</span> <span class=\"n\">I</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">J</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">--fails</span>\n\n<span class=\"c1\">-- Ideally this would be solved by simp:</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">FunLike</span> <span class=\"n\">F</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AlgHomClass</span> <span class=\"n\">F</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">I.comap'</span> <span class=\"o\">((</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→+*</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">I.comap'</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"c1\">-- fails because we don't have those n^2 simp lemmas</span>\n</code></pre></div>",
        "id": 428217248,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711054881
    },
    {
        "content": "<p>okay, yes, that's a good example.</p>",
        "id": 428217823,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711055108
    },
    {
        "content": "<p>But the same issues would arise <em>even if</em> we don't rededefine <code>comap</code>.</p>",
        "id": 428217986,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711055177
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span>  was (is?) not a fan of these <code>FunLike</code> class-to-morphism coercions for this reason.</p>",
        "id": 428218001,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711055183
    },
    {
        "content": "<p>And if you don't believe that examples such as Kevin arise in nature, then I hope you also don't believe that such an example would show up in nature.</p>",
        "id": 428218282,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711055294
    },
    {
        "content": "<p>Anyway, in case it's not clear, I have a love/hate relationship with these hom classes :-/</p>",
        "id": 428218357,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711055328
    },
    {
        "content": "<p>I'm perfectly happy to use <code>erw [h]</code> in the first case and <code>rfl</code> in the second case.</p>",
        "id": 428218425,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711055358
    },
    {
        "content": "<p>well, I only agree these won't show up in nature if we're not making <code>def</code>s like <code>Ideal.comap'</code> which automatically include a coercion.</p>",
        "id": 428218431,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711055361
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/too.20many.20FunLikes/near/428208690\">said</a>:</p>\n<blockquote>\n<p>And if it's okay for <code>Ideal.map</code> to take a function, why is it not okay for <code>Ideal.comap</code> to take an actual ring hom?</p>\n</blockquote>\n<p>It seems like the answer here is because we <em>do</em> have simp lemmas for <code>(⇑(↑f : XXXHom A B) : A → B) = (⇑f : A → B)</code> where <code>f : F</code> and <code>[XXXHomClass F A B]</code>, e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingHom.coe_coe#doc\">docs#RingHom.coe_coe</a></p>",
        "id": 428219348,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711055763
    },
    {
        "content": "<p>Yes, once you go all the way down to functions, everything is fine. My current idea is to try to encode this <code>coe_coe</code> theorem as a class in a suitable way, so that we can get the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">n^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> lemmas as a single one for each morphism class (and maybe also allow for deleting the <code>↑</code> in the hypothesis in Kevin's example (with an additional lemma).</p>",
        "id": 428219806,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711056002
    },
    {
        "content": "<p>I can't tell you how it happened because a student just put their laptop in front of me and said \"why is this rewrite with a really long f failing when it looks syntactically the same?\" And it took me a long time to spot the coercion. Maybe the student did something silly, I don't know. I felt like it could plausibly happen but my real question was whether something like <code>norm_cast</code> or whatever could fix it</p>",
        "id": 428220705,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711056381
    },
    {
        "content": "<p>In case it wasn't answered clearly above, no, <code>norm_cast</code> can't fix it.</p>",
        "id": 428220802,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711056437
    },
    {
        "content": "<p><code>erw [h]</code> might work</p>",
        "id": 428220824,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711056450
    },
    {
        "content": "<p>Why can't we just write a metaprogram to generate all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">n^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> lemmas and call it a day?</p>",
        "id": 428221464,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711056730
    },
    {
        "content": "<p>No, because they may not even be declared at the time you would need to run the metaprogram.</p>",
        "id": 428221599,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711056796
    },
    {
        "content": "<p>or just write some tactic to normalize such coercions of coercions.</p>",
        "id": 428221655,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711056829
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/too.20many.20FunLikes/near/428221599\">said</a>:</p>\n<blockquote>\n<p>No, because they may not even be declared at the time you would need to run the metaprogram.</p>\n</blockquote>\n<p>I'm envisioning generating additional lemmas after each hom class is declared.</p>",
        "id": 428221772,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711056873
    },
    {
        "content": "<p>But you don't have access to all the other hom classes you might need.</p>",
        "id": 428221832,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711056902
    },
    {
        "content": "<p>only the ones downstream of the class that was just defined, no?</p>",
        "id": 428221880,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711056928
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/too.20many.20FunLikes/near/428221655\">said</a>:</p>\n<blockquote>\n<p>or just write some tactic to normalize such coercions of coercions.</p>\n</blockquote>\n<p>This is probably easier TBH</p>",
        "id": 428222373,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711057158
    },
    {
        "content": "<p>shoot, we can even make it a simproc :)</p>",
        "id": 428222424,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711057185
    },
    {
        "content": "<p>no (re: downstream), for instance, when<code>StarAlgHomClass</code> is defined, you don't have access to <code>ContinuousMapClass</code> but for certain types, having the former means you have the latter.</p>",
        "id": 428222549,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711057237
    },
    {
        "content": "<p>(update: I couldn't make my idea work)</p>",
        "id": 428224776,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711058241
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/287929-mathlib4/topic/too.20many.20FunLikes/near/428218001\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span>  was (is?) not a fan of these <code>FunLike</code> class-to-morphism coercions for this reason.</p>\n</blockquote>\n<p>Indeed; these coercions are a pain because they let you pick any sequence of points through a connected graph between <code>AlgHom</code> and (say) <code>AddHom</code> , and we have pretty much no lemmas that let you move between those paths.</p>",
        "id": 428230309,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711061050
    },
    {
        "content": "<p>The old strategy of going one step at a time gave you an arbitrary path, but it was easy to rewrite by commuting one diamond at a time</p>",
        "id": 428230395,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711061094
    },
    {
        "content": "<p>I think to make <code>def foo [HomClass _ _ F] (f : F)</code> viable, every such definition needs a lemma <code>theorem foo_coe (f : F) : foo (f : Hom) = foo f</code>, and we also don't have those lemmas</p>",
        "id": 428230679,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711061223
    },
    {
        "content": "<p>I think the most compelling reason for why <code>comap</code> should take a <code>RingHom</code> and not a <code>RingHomClass</code> is that otherwise you can't state <code>comap_comp</code>.</p>",
        "id": 428230810,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711061288
    },
    {
        "content": "<p>Or worse, you have to state it over again for every morphism type</p>",
        "id": 428230858,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711061322
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/too.20many.20FunLikes/near/428208168\">said</a>:</p>\n<blockquote>\n<p>I disagree. IMO the point of hom classes is to avoid duplication for lemmas <em>about</em> homs.</p>\n</blockquote>\n<p>I completely agree with this. The morphism classes are awesome for theorems using <code>map_foo</code>, but I think that more often than not, they are footguns when they appear in the signature of a definition.</p>",
        "id": 428231049,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711061454
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/too.20many.20FunLikes/near/428209586\">said</a>:</p>\n<blockquote>\n<p>That you now need to write <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">n^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> lemmas about those coercions where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> is the depth of your hierarchy</p>\n</blockquote>\n<p>I'm realizing that I've been overestimating this <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> figure. I'm pretty sure <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>&lt;</mo><mn>10</mn></mrow><annotation encoding=\"application/x-tex\">n &lt; 10</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">10</span></span></span></span> in the case of the morphism hierarchy because we only need new morphism types for new operators, not for new properties. Furthermore, I think we already have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> code size anyway. Any class hierarchy of depth <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> that has at least one concrete instance of each class will take at least <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> lines of code to write because defining each concrete instance at height <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> requires providing values for its <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> properties.</p>",
        "id": 428237949,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711065949
    },
    {
        "content": "<blockquote>\n<p>that has at least one concrete instance of each class</p>\n</blockquote>\n<p>honestly I would not be surprised if this assumption is false in mathlib</p>",
        "id": 428238427,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711066226
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/too.20many.20FunLikes/near/428230810\">said</a>:</p>\n<blockquote>\n<p>I think the most compelling reason for why <code>comap</code> should take a <code>RingHom</code> and not a <code>RingHomClass</code> is that otherwise you can't state <code>comap_comp</code>.</p>\n</blockquote>\n<p>IMO, this just highlights a long-standing issue with the morphsim-class hierarchy, which is that it is incapable of handling composition.</p>",
        "id": 428251637,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711075506
    },
    {
        "content": "<p>Maybe <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∘</mo></mrow><annotation encoding=\"application/x-tex\">\\circ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord\">∘</span></span></span></span> should be a macro...</p>",
        "id": 428270337,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711090588
    },
    {
        "content": "<p>There is a possible solution, but it hasn't been tested on larger scale : <a href=\"#narrow/stream/287929-mathlib4/topic/Bundled.20sets.2Ffunctions.20with.20even.20more.20classes/near/421284443\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Bundled.20sets.2Ffunctions.20with.20even.20more.20classes/near/421284443</a></p>",
        "id": 428275412,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1711093600
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/287929-mathlib4/topic/too.20many.20FunLikes/near/428270337\">said</a>:</p>\n<blockquote>\n<p>Maybe $\\circ$ should be a macro...</p>\n</blockquote>\n<p>I'm sure Core would love that idea <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>\n<p>But anyway, it wouldn't really solve the problem. I'm not saying the issue is that we have different composition defs for each kind of bundled morphism (although it would be nice if they were unified), but rather that we have no way to compose <code>(f : F)</code> and <code>(g : G)</code> when the types have <code>FunLike</code> instances where the domain and codomain match.</p>",
        "id": 428308177,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711106081
    },
    {
        "content": "<p>I was thinking of PRing <code>∘ₐ</code> to go with <code>∘ₗ</code> by the way -- I had a bunch of students working on Hopf algebras and I think it slightly has the edge over <code>.comp</code> in terms of readability</p>",
        "id": 428308536,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711106227
    },
    {
        "content": "<p>I think that would be unobjectionable</p>",
        "id": 428331988,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711114828
    },
    {
        "content": "<p>Should we define a notation class for <code>∘ₘ</code>? (the <code>ₘ</code> is for \"morphism\" but it could be something else). Then we can just have a single notation for morphism composition?</p>",
        "id": 428332402,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711114970
    }
]