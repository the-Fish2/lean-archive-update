[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  I just saw your PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/11700\">#11700</a>, and @AntoineChambert-Loir asked me today for something a bit similar.<br>\nSuppose you have a term <code>@IsOpen X t s</code> where type-class inference does <em>not</em> find <code>t</code> as the canonical topology on <code>X</code> (because it finds another topology or no topology), then it would be nice if this is printed as <code>IsOpen[t] s</code> (this is <a href=\"https://github.com/leanprover-community/mathlib4/blob/a492bebc97779a7a3f8a5dddf7b2672296432d75/Mathlib/Topology/Defs/Basic.lean#L158C48-L158C55\">notation</a>). Similar for <code>MeasurableSet[m]</code> and whatever-other predicate we have defined this notation for.<br>\nWould this be possible as an delaborator (i.e. can a delaborator call type-class inference)? It is probably quite inefficient though, so it probably shouldn't be enabled by default.</p>",
        "id": 429713080,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1711476811
    },
    {
        "content": "<p>I think there's a pretty cheap way to achieve this: Make <code>IsOpen[t] s</code> notation for <code>@IsOpen _ t s</code> except that you insert <code>mdata</code> somewhere</p>",
        "id": 429713642,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711477032
    },
    {
        "content": "<p>That won't survive rewriting, though (I think?)</p>",
        "id": 429713665,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711477044
    },
    {
        "content": "<p>Yeah, a delaborator has access to MetaM, so it can do synthInstance and do a defeq check.</p>",
        "id": 429715430,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711477685
    },
    {
        "content": "<p>Maybe there are some approximations that would generally do the right thing. What sorts of terms are the non-canonical instances? Are they always going to be applications of definitions that aren't themselves global instances? Or would the non-canonicity only appear deeper in the term?</p>",
        "id": 429716311,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711478013
    },
    {
        "content": "<p>I think often these non-instances will be either</p>\n<ul>\n<li>A local constant, when multiple local constants of the same type exist (e.g. <code>X</code> with two topologies on it)</li>\n<li>A definition that is not an instance</li>\n</ul>\n<p>I expect that these generally do not occur deeper in the term, since writing that down would be very inconvenient with the current setup (I can imagine having two uniform spaces and considering both topologies, but know of this actually happening in practice). But maybe <span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> knows of an example  (I just realized that my ping in the other message didn't work).</p>",
        "id": 429755070,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1711495225
    },
    {
        "content": "<p>The example I had in mind was of the form : to prove that two topologies <code>t</code> and <code>t'</code> on <code>X</code> are equal, use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TopologicalSpace.ext_iff_nhds#doc\">docs#TopologicalSpace.ext_iff_nhds</a>, and you are reduced to prove <code>nhds x = nhds x</code> for all <code>x : X</code>.<br>\nIf that were written <code>nhds[t] x = nhds[t'] x</code>, that would be much clearer…</p>",
        "id": 429756748,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1711496255
    }
]