[
    {
        "content": "<p>How to get a list of theorems that are directly or indirectly affected by other theorems? I'd need it in particular to avoid circular reasoning when proving the infinitude of primes.</p>",
        "id": 442504845,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1717499867
    },
    {
        "content": "<p>So, given a theorem in mathlib, you want to know whether it depends on mathlib's version of the infinitude of primes?</p>",
        "id": 442506071,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1717500287
    },
    {
        "content": "<p>You could try to adapt <code>forbiddenAxioms</code> from this message: <a href=\"#narrow/stream/348111-batteries/topic/scope.20of.20std/near/412282298\">https://leanprover.zulipchat.com/#narrow/stream/348111-batteries/topic/scope.20of.20std/near/412282298</a></p>",
        "id": 442506206,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1717500341
    },
    {
        "content": "<p>Better, given a theorem, which theorems are call-children of it.</p>",
        "id": 442506215,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1717500344
    },
    {
        "content": "<p>I.E. <code>x</code> is bad. <code>y</code> calls <code>x</code> so is bad too, etc. Give a list of all bad ones. The whole tree.</p>",
        "id": 442506637,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1717500480
    },
    {
        "content": "<p>Sigh, it seems I can no longer avoid metaprogramming...</p>",
        "id": 442507206,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1717500664
    },
    {
        "content": "<p>In some Zulip thread there is some code that gives you all the \"upstream\" declarations of a given one.  However, running it on all declarations in the environment is expensive.</p>",
        "id": 442514224,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1717502886
    },
    {
        "content": "<p><a href=\"#narrow/stream/287929-mathlib4/topic/Counting.20prerequisites.20of.20a.20theorem/near/425370265\">This</a> is the thread.</p>",
        "id": 442514637,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1717503010
    },
    {
        "content": "<p>Open it in VS Code and use the Call Hierarchy feature? It will only show explicit uses, though, e.g. won't work for simp lemmas.</p>",
        "id": 442560989,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1717515738
    },
    {
        "content": "<p>Thanks for the suggestions. I'm not satisfied with knowing if my own specific theorem depends on a bad theorem in Mathlib. I need to see the full picture of how \"bad\" (from my perspective) the whole situation is, to be able to plan around it.</p>\n<p>It looks to me that these scripts, and Lean4 metaprogramming in general, is meant to be run from a <code>.lean</code> file in VScode, and work on the data that is imported there. Contrary to your scripts, my idea is to read all of Mathlib, and list all theorems that depend on a (set of) bad theorem(s). Is that possible by <code>import Mathlib</code>?</p>\n<p>If not, or too slow, I'd rather write an external parser, because I don't need the full syntax for this. Parsec may be a choice.</p>",
        "id": 442561120,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1717515768
    },
    {
        "content": "<p>If you want precise information, I don't think that you will be able to do it more quickly than in Lean itself.</p>\n<p>Note that there are <em>many</em> \"invisible\" lemmas that are stated and used almost exclusively by tactics such as <code>norm_num</code>, <code>norm_cast</code>, <code>ring</code>, <code>simp</code>,...  Depending on how \"automated\" your set of bad lemmas is, you may get unreliable results without actually looking at the proof terms.</p>\n<p>In a file with <code>import Mathlib</code>, the environment has access to all the declarations and you can use (some modification of) the scripts above.  However, I suspect that unless you work on optimising the algorithms, getting the information that you want can be a fairly long task.</p>",
        "id": 442569130,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1717517594
    }
]