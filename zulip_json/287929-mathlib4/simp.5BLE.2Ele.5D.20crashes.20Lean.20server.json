[
    {
        "content": "<p>Upon applying the simp[LE.le] tactic, the Lean server crashes and an uncaught exception is raised. What could possibly cause this issue? If further context is needed, I'd be happy to provide it! Thanks!</p>",
        "id": 421777799,
        "sender_full_name": "Arnav Sabharwal",
        "timestamp": 1708052010
    },
    {
        "content": "<p>We always need the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> to reproduce the problem.</p>",
        "id": 421779365,
        "sender_full_name": "Wen Yang",
        "timestamp": 1708053038
    },
    {
        "content": "<p>Sure, let me know if it must be minimized further. The trouble-making section is the last-example.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\"># Inductive type variant of `Fin`</span>\n\n<span class=\"cm\">`Fin` is defined as a subtype of `Nat`. This file defines an equivalent type, `PFin2`, which is</span>\n<span class=\"cm\">defined inductively, and is universe polymorphic. This is useful for its induction principle and</span>\n<span class=\"cm\">different definitional equalities.</span>\n\n\n<span class=\"cm\">## Main declarations</span>\n\n<span class=\"cm\">* `PFin2 n`: Inductive and universe polymorphic type variant of `Fin n`. `fz` corresponds to `0` and</span>\n<span class=\"cm\">  `fs n` corresponds to `succ n`.</span>\n<span class=\"cm\">* `Fin2 n`: shorthand for `PFin2.{0} n`, i.e., it lives in `Type`</span>\n<span class=\"cm\">* `toNat`, `optOfNat`, `ofNat'`: Conversions to and from `Nat`. `ofNat' m` takes a proof that</span>\n<span class=\"cm\">  `m &lt; n` through the class `is_lt`.</span>\n<span class=\"cm\">* `add k`: Takes `i : PFin2 n` to `i + k : PFin2 (n + k)`.</span>\n<span class=\"cm\">* `left`: Embeds `PFin2 n` into `PFin2 (n + k)`.</span>\n<span class=\"cm\">* `insertPerm a`: Permutation of `PFin2 n` which cycles `0, ..., a - 1` and leaves `a, ..., n - 1`</span>\n<span class=\"cm\">  unchanged.</span>\n<span class=\"cm\">* `remapLeft f`: Function `PFin2 (m + k) → PFin2 (n + k)` by applying `f : PFin2 m → PFin2 n` to</span>\n<span class=\"cm\">  `0, ..., m - 1` and sending `m + i` to `n + i`.</span>\n<span class=\"cm\">-/</span>\n\n\n<span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n\n\n<span class=\"sd\">/-- An alternate definition of `fin n` defined as an inductive type instead of a subtype of `Nat`. -/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">PFin2</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n  <span class=\"bp\">|</span> <span class=\"sd\">/-- `0` as a member of `fin (succ n)` (`fin 0` is empty) -/</span>\n  <span class=\"n\">fz</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">PFin2</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"sd\">/-- `n` as a member of `fin (succ n)` -/</span>\n  <span class=\"n\">fs</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">PFin2</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">PFin2</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">PFin2</span>\n\n<span class=\"sd\">/-- Define a dependent function on `PFin2 (succ n)` by giving its value at</span>\n<span class=\"sd\">zero (`H1`) and by giving a dependent function on the rest (`H2`). -/</span>\n<span class=\"c1\">-- @[elab_as_eliminator]</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">cases'</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">PFin2</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H1</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">fz</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">fs</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">PFin2</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"n\">i</span>\n  <span class=\"bp\">|</span> <span class=\"n\">fz</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">H1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">fs</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">H2</span> <span class=\"n\">n</span>\n\n<span class=\"sd\">/-- Ex falso. The dependent eliminator for the empty `PFin2 0` type. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">elim0</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">PFin2</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">PFin2</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">intro</span> <span class=\"n\">i</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">i</span>\n\n<span class=\"sd\">/-- Converts a `PFin2` into a natural. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">toNat</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"n\">PFin2</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">fz</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">fs</span> <span class=\"n\">_</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">toNat</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">  ## LT / LE</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">instance</span> <span class=\"n\">instOrd</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ord</span> <span class=\"o\">(</span><span class=\"n\">PFin2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">compare</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">compare</span> <span class=\"bp\">·.</span><span class=\"n\">toNat</span> <span class=\"bp\">·.</span><span class=\"n\">toNat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instLT</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">LT</span> <span class=\"o\">(</span><span class=\"n\">PFin2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨(</span><span class=\"n\">Nat.lt</span> <span class=\"bp\">·.</span><span class=\"n\">toNat</span> <span class=\"bp\">·.</span><span class=\"n\">toNat</span><span class=\"o\">)⟩</span>\n<span class=\"kd\">instance</span> <span class=\"n\">instLE</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">LE</span> <span class=\"o\">(</span><span class=\"n\">PFin2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨(</span><span class=\"n\">Nat.le</span> <span class=\"bp\">·.</span><span class=\"n\">toNat</span> <span class=\"bp\">·.</span><span class=\"n\">toNat</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">decidable_lt</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">DecidableRel</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LT.lt</span> <span class=\"o\">(</span><span class=\"n\">PFin2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">instLT</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">a.toNat</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b.toNat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n    <span class=\"k\">match</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">h</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">isTrue</span>  <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"n\">assumption</span>\n    <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"n\">intro</span> <span class=\"n\">a_lt_b</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">h</span> <span class=\"n\">a_lt_b</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">decidable_le</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">DecidableRel</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LE.le</span> <span class=\"o\">(</span><span class=\"n\">PFin2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">instLE</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">a.toNat</span> <span class=\"bp\">≤</span> <span class=\"n\">b.toNat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n    <span class=\"k\">match</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">h</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">isTrue</span>  <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"n\">assumption</span>\n    <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"n\">intro</span> <span class=\"n\">a_le_b</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">h</span> <span class=\"n\">a_le_b</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">PFin2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">PFin2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n<span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">LT.lt</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 421780303,
        "sender_full_name": "Arnav Sabharwal",
        "timestamp": 1708053771
    },
    {
        "content": "<p>Don't forget to add <code>import Mathlib</code> at the beginning of your example. I can reproduce your problem now. However, I don't know why <code>simp [LT.lt]</code> raises error.</p>",
        "id": 421781998,
        "sender_full_name": "Wen Yang",
        "timestamp": 1708054940
    },
    {
        "content": "<p>Since <code>LT</code> on <code>Nat</code> is implemented using recursion, you are generating very deeply nested <code>match</code> expression by calling that simp, until Lean bails out.</p>\n<p>Here is the \"standard\" way to solve it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">lt_def</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">PFin2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a.toNat</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b.toNat</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.rfl</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">le_def</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">PFin2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a.toNat</span> <span class=\"bp\">≤</span> <span class=\"n\">b.toNat</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">PFin2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">PFin2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">lt_def</span><span class=\"o\">,</span> <span class=\"n\">le_def</span><span class=\"o\">,</span> <span class=\"n\">le_def</span><span class=\"o\">,</span> <span class=\"n\">Nat.lt_iff_le_not_le</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 421784847,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1708056805
    },
    {
        "content": "<p>We would like to have more helpful behaviour in these cases, so if you have the energy to make a no-imports-at-all <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> demonstrating this, and issue would be welcome.</p>",
        "id": 422074802,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1708240506
    },
    {
        "content": "<p>The code does work in the web editor without imports.</p>",
        "id": 422086151,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1708251463
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/287929-mathlib4/topic/simp.5BLE.2Ele.5D.20crashes.20Lean.20server/near/422074802\">said</a>:</p>\n<blockquote>\n<p>We would like to have more helpful behaviour in these cases, so if you have the energy to make a no-imports-at-all <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> demonstrating this, and issue would be welcome.</p>\n</blockquote>\n<p>Sure! However, I'm a bit confused by what you mean by \"no-imports-at-all\". Could you please clarify? Thanks!</p>",
        "id": 422171341,
        "sender_full_name": "Arnav Sabharwal",
        "timestamp": 1708325622
    },
    {
        "content": "<p>There should be no <code>import</code> statements in the file; it should stand entirely in its own</p>",
        "id": 422171848,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1708325991
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/287929-mathlib4/topic/simp.5BLE.2Ele.5D.20crashes.20Lean.20server/near/422086151\">said</a>:</p>\n<blockquote>\n<p>The code does work in the web editor without imports.</p>\n</blockquote>\n<p>That's very interesting, the following no-imports version fails for me in the web-editor:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n\n<span class=\"sd\">/-- An alternate definition of `fin n` defined as an inductive type instead of a subtype of `Nat`. -/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">PFin2</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n  <span class=\"bp\">|</span> <span class=\"sd\">/-- `0` as a member of `fin (succ n)` (`fin 0` is empty) -/</span>\n  <span class=\"n\">fz</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">PFin2</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"sd\">/-- `n` as a member of `fin (succ n)` -/</span>\n  <span class=\"n\">fs</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">PFin2</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">PFin2</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">PFin2</span>\n\n<span class=\"sd\">/-- Converts a `PFin2` into a natural. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">toNat</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"n\">PFin2</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">fz</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">fs</span> <span class=\"n\">_</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">toNat</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instLT</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">LT</span> <span class=\"o\">(</span><span class=\"n\">PFin2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨(</span><span class=\"n\">Nat.lt</span> <span class=\"bp\">·.</span><span class=\"n\">toNat</span> <span class=\"bp\">·.</span><span class=\"n\">toNat</span><span class=\"o\">)⟩</span>\n<span class=\"kd\">instance</span> <span class=\"n\">instLE</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">LE</span> <span class=\"o\">(</span><span class=\"n\">PFin2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨(</span><span class=\"n\">Nat.le</span> <span class=\"bp\">·.</span><span class=\"n\">toNat</span> <span class=\"bp\">·.</span><span class=\"n\">toNat</span><span class=\"o\">)⟩</span>\n\n<span class=\"c1\">-- Uncommenting causes session to crash</span>\n<span class=\"c1\">-- example (n : Nat) (a : PFin2 n) (b : PFin2 n) :</span>\n<span class=\"c1\">-- a &lt; b ↔ a ≤ b ∧ ¬(b ≤ a) :=</span>\n<span class=\"c1\">-- by</span>\n<span class=\"c1\">-- simp[LE.le];</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">PFin2</span>\n</code></pre></div>\n<p>Could you kindly share what you did differently that caused it to work with <code>LE.le</code> without imports? Thanks!</p>",
        "id": 422251512,
        "sender_full_name": "Arnav Sabharwal",
        "timestamp": 1708354990
    }
]