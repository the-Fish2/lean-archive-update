[
    {
        "content": "<p>In Mathlib.Data.Polynomial.Basic, the structure <code>Polynomial</code> is defined in a noncomputable section. Is there any reason for not applying noncomputable for noncomputable types only? Any other building blocks of <code>Polynomial</code> doesn't seem to be noncomputable.</p>",
        "id": 422258586,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1708356965
    },
    {
        "content": "<p>The reason is that we decided not to care about computability of polynomials when they were defined. Now there is a lot more reason to care about computability but it's going to be a lot of work to do so nicely. See e.g. <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Polynomial.20uncomputable\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/.E2.9C.94.20Polynomial.20uncomputable</a></p>",
        "id": 422259107,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1708357161
    },
    {
        "content": "<p>Here is a wiki page with even more information: <a href=\"https://github.com/leanprover-community/mathlib4/wiki/Computation-models-for-polynomials-and-finitely-supported-functions\">https://github.com/leanprover-community/mathlib4/wiki/Computation-models-for-polynomials-and-finitely-supported-functions</a></p>",
        "id": 422259201,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1708357194
    },
    {
        "content": "<p>Please add this Zulip thread to the list of Zulip topics on that page :)</p>",
        "id": 422268732,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708359562
    },
    {
        "content": "<p>(having a record of this being asked for is helpful in justifying the change in future, if it is ever made)</p>",
        "id": 422268835,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708359589
    },
    {
        "content": "<p>While staring at the wiki page, I couldn't figure out how de-classified <code>Finsupp</code>, <code>DFinsupp</code>, and <code>DFinsupp'</code> achieve <code>f i</code> (aka <code>p.coeff i</code>) without <code>DecidableEq ι</code>. How can it compute <code>f j</code> if <code>f = single i 1</code> and <code>i = j</code> but doesn't have <code>DecideableEq ι</code> property?</p>",
        "id": 422284792,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1708365458
    },
    {
        "content": "<p>I'd also like to share my idea of computable <code>Finsupp</code>. Let <code>ι</code> be a type which we can choose one element (if not empty) without classical choose, for example zero. Also let <code>Finsupp ι R</code> contain <code>f</code> which is a finite set of functions from <code>ι</code> to <code>ι</code>, which is likely to be computable. This will require the same restriction as the quotient of inductive type method for operations listed in the table, while not being inductive.</p>",
        "id": 422286196,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1708366114
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"574112\">Jihoon Hyun</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Why.20is.20.60Polynomial.60.20noncomputable.3F/near/422284792\">said</a>:</p>\n<blockquote>\n<p>While staring at the wiki page, I couldn't figure out how de-classified <code>Finsupp</code>, <code>DFinsupp</code>, and <code>DFinsupp'</code> achieve <code>f i</code> (aka <code>p.coeff i</code>) without <code>DecidableEq ι</code>. How can it compute <code>f j</code> if <code>f = single i 1</code> and <code>i = j</code> but doesn't have <code>DecideableEq ι</code> property?</p>\n</blockquote>\n<p>Because the <code>DecidableEq</code> obligation appeands at <code>f = single i 1</code> not at <code>f i</code></p>",
        "id": 422287642,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708366935
    },
    {
        "content": "<p>I don't really understand your suggestion (I think it has at least one typo, because you don't mention <code>R</code> in your definition)</p>",
        "id": 422287725,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708366991
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Why.20is.20.60Polynomial.60.20noncomputable.3F/near/422287642\">말함</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"574112\">Jihoon Hyun</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Why.20is.20.60Polynomial.60.20noncomputable.3F/near/422284792\">said</a>:</p>\n<blockquote>\n<p>While staring at the wiki page, I couldn't figure out how de-classified <code>Finsupp</code>, <code>DFinsupp</code>, and <code>DFinsupp'</code> achieve <code>f i</code> (aka <code>p.coeff i</code>) without <code>DecidableEq ι</code>. How can it compute <code>f j</code> if <code>f = single i 1</code> and <code>i = j</code> but doesn't have <code>DecideableEq ι</code> property?</p>\n</blockquote>\n<p>Because the <code>DecidableEq</code> obligation appeands at <code>f = single i 1</code> not at <code>f i</code></p>\n</blockquote>\n<p>Thank you for the explanation! Then it seems like the deterministic equality checking of index is not an issue when working on <code>f i</code>, right? Why is this the case?</p>",
        "id": 422289792,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1708368189
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Why.20is.20.60Polynomial.60.20noncomputable.3F/near/422287725\">말함</a>:</p>\n<blockquote>\n<p>I don't really understand your suggestion (I think it has at least one typo, because you don't mention <code>R</code> in your definition)</p>\n</blockquote>\n<p>I meant that <code>single i r</code> or <code>+</code> in the table doesn't require <code>DecidableEq</code> for both types, while <code>f i</code> requires <code>DecidableEq ι</code> and <code>support</code> needs both <code>DecidableEq ι</code> and <code>DecidableEq R</code>, just like the 'quotient of inductive type'.</p>\n<p>I'll explain more about the method. Each element <code>F</code> of <code>Finsupp ι R</code> of mine will hold functions from <code>ι</code> to <code>ι</code>, which denotes an index <code>f 0</code> for each <code>f</code> in <code>F</code> . <code>single i r</code> is constructible by choosing a singleton set <code>F</code> which  contains a function <code>f</code> which maps <code>0</code> to <code>i</code>, along with <code>r</code>. <code>+</code> can be lazily operated without comparison on <code>ι</code>. If we don't need to deterministically check for equality as stated above, then it seems like the <code>DecidabeEq ι</code> can also be cancelled out, but for <code>support</code> operation we still need both <code>DecidableEq</code> constraints.</p>",
        "id": 422291176,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1708369026
    },
    {
        "content": "<p>It's hard to understand your idea by words. I wrote down some possible implementations of Finsupp <a href=\"#narrow/stream/116395-maths/topic/Lagrange.20interpolants/near/287806674\">here</a> (in Lean 3). Can you take a look and how your approach differ, preferably with some actual code?</p>",
        "id": 422293056,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1708370018
    },
    {
        "content": "<p>If you want to compute with polynomials, there is the <a href=\"#narrow/stream/113489-new-members/topic/Compute.20roots.20of.20polynomials/near/420713624\"><code>polynomial</code> tactic</a> as well as a <a href=\"#narrow/stream/113489-new-members/topic/Compute.20roots.20of.20polynomials/near/420832934\">new approach</a> of mine that works for polynomials over types with decidable equality and computable arithmetic operations, like ℕ, ℤ, and ℚ.</p>",
        "id": 422293639,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1708370329
    },
    {
        "content": "<p>It seems like my idea was not that good after all. I tried creating an equivalence relation on <code>ι -&gt; ι</code>, then noticed that there is a bijection between the created equivalence classes and <code>ι</code> itself, which implies that what I have thought was actually similar to that of <code>DFinsupp</code>.</p>",
        "id": 422586903,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1708511444
    }
]