[
    {
        "content": "<p>I remember that in Lean 3 times, we've got some compilation speed improvements when we changed a bunch of lemmas about <code>(f : M →* N)</code> from <code>[Monoid M]</code> to <code>{_ : Monoid M}</code> (we didn't have <code>MulOneClass</code> back then). Does it make sense to do the same in Mathlib 4 for lemmas like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=isClosed_compl_iff#doc\">docs#isClosed_compl_iff</a> ?</p>",
        "id": 418196236,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706235711
    },
    {
        "content": "<p>Of course, we can't do this for lemmas that assume a typeclass, then use projections of this typeclass.</p>",
        "id": 418196325,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706235770
    },
    {
        "content": "<p>As a side effect, <code>isClosed_compl_iff</code> will work with <code>simp</code> for non-canonical topologies.</p>",
        "id": 418196467,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706235905
    },
    {
        "content": "<p>That would definitely be a performance improvement (and we previously mentioned it), but I think this is something that we should not have to do by hand. Instead it should be automatic.</p>",
        "id": 418229252,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706256936
    },
    {
        "content": "<p>When exactly should it be done automatically?</p>",
        "id": 418229374,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706256987
    },
    {
        "content": "<p>When the definition/lemma is declared or when it is used?</p>",
        "id": 418229392,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706257001
    },
    {
        "content": "<p>When it is declared (at least that's what I had in mind)</p>",
        "id": 418229422,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706257021
    },
    {
        "content": "<p>How should Lean decide that it should replace <code>[MyClass a]</code> with <code>{_ : MyClass a}</code>?</p>",
        "id": 418229504,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706257073
    },
    {
        "content": "<p>For rewriting lemmas (<code>_ = _</code> or <code>_ ↔ _</code>), there are at least three criteria that come to mind:</p>\n<ul>\n<li>An instance argument can be inferred from the LHS</li>\n<li>An instance argument can be inferred from the RHS</li>\n<li>Both of the above</li>\n</ul>",
        "id": 418229738,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706257195
    },
    {
        "content": "<p>Is there an issue for this already?</p>",
        "id": 418236418,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1706260311
    },
    {
        "content": "<p>I'd prefer \"both of the above\" to be on the safe side.</p>",
        "id": 418236592,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706260383
    },
    {
        "content": "<p>(I'd - naively - expect that the unification that happens when rw or simp tries to apply the lemma would already instantiate these arguments, if present, at least if they aren't in Prop, without changes to the types, so I'd be curious to read more about the issue and why this doesn't happen already.)</p>",
        "id": 418236971,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1706260557
    },
    {
        "content": "<p>As far as I understand, Lean 4 tries to be strict about \"instance implicit args must match whatever is generated by instance search\".</p>",
        "id": 418237165,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706260634
    },
    {
        "content": "<p>Also, there is more than \"<code>Prop</code>/non-<code>Prop</code>\" that can happen. E.g., if your lemma has <code>[UniformSpace X]</code> assumption, then uses projections to <code>TopologicalSpace X</code> and <code>uniformity</code> on LHS and RHS, then Lean can't recover <code>UniformSpace</code>.</p>",
        "id": 418237382,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706260726
    },
    {
        "content": "<p>Ah, so it actively avoids instantiating them by unification. Thanks!</p>",
        "id": 418237466,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1706260763
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Instance-implicit.20vs.20implicit/near/418237466\">said</a>:</p>\n<blockquote>\n<p>Ah, so it actively avoids instantiating them by unification. Thanks!</p>\n</blockquote>\n<p>As far as I understand, it actually runs both processes, so that it can complain if the one inferred is not the one gotten by unification. This makes working with non-canonical instances near-impossible, which is good and bad. (Also, I think this resynth every time must be costly - but Kyle told me that it's so core to how Lean4 is designed that it's unlikely to be removed no matter what, so it's likely not even worth testing)</p>",
        "id": 418242776,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706262877
    },
    {
        "content": "<p>But we can change some assumptions from <code>[SomeClass _]</code> to <code>{_ : SomeClass _}</code> in Mathlib, either manually or by overriding <code>theorem</code> in some clever way.</p>",
        "id": 418293640,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706281681
    },
    {
        "content": "<p>Is it worth testing?</p>",
        "id": 418293694,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706281687
    },
    {
        "content": "<p>Only on some theorems though, and those theorems will become much more fragile to further generalization</p>",
        "id": 418298803,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706283200
    },
    {
        "content": "<p>You can't further generalize <code>isClosed_compl_iff</code>...</p>",
        "id": 418318678,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706289654
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 418319932,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706290103
    },
    {
        "content": "<p>Were you going to post this in some other thread?</p>",
        "id": 418320041,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706290147
    },
    {
        "content": "<p>Yes, sorry.</p>",
        "id": 418326362,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706292419
    }
]