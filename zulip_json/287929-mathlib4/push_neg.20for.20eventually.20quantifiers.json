[
    {
        "content": "<p>In the example below 'push_neg' does not manage to push the negation inside the Eventually quantifier. <br>\nIt would seem natural for it to be able to handle cases like this one (and analogous cases with the Frequently quantifier), to avoid having to use lemmas like 'Filter.not_eventually' manually. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Filter.Basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">push_neg</span>\n  <span class=\"c1\">-- push_neg does nothing</span>\n  <span class=\"c1\">-- ⊢ ¬∀ᶠ (x : ℕ) in f, x ≠ 0</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Filter.not_eventually.mpr</span>\n  <span class=\"c1\">-- ⊢ ∃ᶠ (x : ℕ) in f, ¬x ≠ 0</span>\n  <span class=\"n\">push_neg</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>Actually in this case 'simp' solves the problem, but I guess there are situations where one just wants to move the negations without having 'simp' change other details.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 432480625,
        "sender_full_name": "Lorenzo Luccioli",
        "timestamp": 1712748037
    },
    {
        "content": "<p><code>push_neg</code> is basically one big lookup table <a href=\"https://github.com/leanprover-community/mathlib4/blob/e8433a6b8e7980bfaaf9b34513b77da2af14995a/Mathlib/Tactic/PushNeg.lean#L76\">https://github.com/leanprover-community/mathlib4/blob/e8433a6b8e7980bfaaf9b34513b77da2af14995a/Mathlib/Tactic/PushNeg.lean#L76</a> so implementing this feature would be a great first example for someone who wanted to try metaprogramming out</p>\n<p>There is the slight issue of dependencies however, the way push_neg is implemented unfortunately seems to require all the targeted pushes to be imported in the tactic itself, I suppose this is not strictly necessary but  a better extension mechanism would help for sure</p>",
        "id": 432486739,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1712750199
    }
]