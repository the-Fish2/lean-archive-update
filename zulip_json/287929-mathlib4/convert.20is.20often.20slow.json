[
    {
        "content": "<p>I have observed that <code>convert</code> often is fairly slow. My impression is that this is because it tries and fails to find <code>Subsingleton</code> instances. E.g.:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Nat</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">profiler</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedCommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">CompleteSpace</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf₁</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hmul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"n\">Nat.Coprime</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hsum</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">p.Prime</span> <span class=\"bp\">→</span> <span class=\"n\">Summable</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">↦</span> <span class=\"bp\">‖</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">‖</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Summable</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">N.smoothNumbers</span> <span class=\"bp\">↦</span> <span class=\"bp\">‖</span><span class=\"n\">f</span> <span class=\"n\">m</span><span class=\"bp\">‖</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n      <span class=\"n\">HasSum</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">N.smoothNumbers</span> <span class=\"bp\">↦</span> <span class=\"n\">f</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">∏</span> <span class=\"n\">p</span> <span class=\"k\">in</span> <span class=\"n\">N.primesBelow</span><span class=\"o\">,</span> <span class=\"bp\">∑'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.synthInstance</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">bar</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedField</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">CompleteSpace</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→*</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">p.Prime</span> <span class=\"bp\">→</span> <span class=\"bp\">‖</span><span class=\"n\">f</span> <span class=\"n\">p</span><span class=\"bp\">‖</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Summable</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">N.smoothNumbers</span> <span class=\"bp\">↦</span> <span class=\"bp\">‖</span><span class=\"n\">f</span> <span class=\"n\">m</span><span class=\"bp\">‖</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n      <span class=\"n\">HasSum</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">N.smoothNumbers</span> <span class=\"bp\">↦</span> <span class=\"n\">f</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">∏</span> <span class=\"n\">p</span> <span class=\"k\">in</span> <span class=\"n\">N.primesBelow</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">f</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">hmul</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Nat.Coprime</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f.map_mul</span> <span class=\"n\">m</span> <span class=\"n\">n</span>\n  <span class=\"c1\">-- ~3000 heartbeats</span>\n  <span class=\"n\">convert</span> <span class=\"n\">foo</span> <span class=\"n\">f.map_one</span> <span class=\"n\">hmul</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"n\">N</span> <span class=\"k\">with</span> <span class=\"n\">M</span> <span class=\"n\">hM</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">MathlibLatest.lean:28:2</span>\n<span class=\"cm\">[Meta.synthInstance] [0.009281s] ❌ Subsingleton Prop ▶</span>\n<span class=\"cm\">[Meta.synthInstance] [0.008945s] ❌ Subsingleton Prop ▶</span>\n<span class=\"cm\">[Meta.synthInstance] [0.000009s] ❌ Subsingleton Prop ▶</span>\n<span class=\"cm\">[Meta.synthInstance] [0.007182s] ❌ Subsingleton α ▶</span>\n<span class=\"cm\">[Meta.synthInstance] [0.026846s] ❌ Subsingleton F ▶</span>\n<span class=\"cm\">[Meta.synthInstance] [0.000009s] ❌ Subsingleton F ▶</span>\n<span class=\"cm\">[Meta.synthInstance] [0.008626s] ❌ Subsingleton (Inv α) ▶</span>\n<span class=\"cm\">[Meta.synthInstance] [0.007122s] ❌ Subsingleton α ▶</span>\n<span class=\"cm\">[Meta.synthInstance] [0.000011s] ✅ Inv F ▶</span>\n<span class=\"cm\">[Meta.synthInstance] [0.008401s] ❌ Subsingleton (AddCommMonoid α) ▶</span>\n<span class=\"cm\">[Meta.synthInstance] [0.015745s] ❌ Subsingleton (TopologicalSpace α) ▶</span>\n<span class=\"cm\">[Meta.synthInstance] [0.061848s] ❌ Subsingleton (β → α) ▶</span>\n<span class=\"cm\">[Meta.synthInstance] [0.000010s] ❌ Subsingleton F ▶</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>(this is extracted from <code>Mathlib.NumberTheory.EulerProduct.Basic</code>, before the changes made in <a href=\"https://github.com/leanprover-community/mathlib4/pull/12161\">#12161</a>).</p>\n<p>Looking at <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/Congr!.html#Congr!.Config\">docs#Congr!.Config</a>, I don't see an option to switch off the <code>Subsingleton</code> check. Would it make sense to have this? I assume in most cases, the check is not really relevant (so maybe <em>not</em> doing it is even the better default), and without it, <code>convert</code> should be quite a bit faster.</p>",
        "id": 433830798,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1713371893
    },
    {
        "content": "<p>That <code>Subsingleton</code> check is one of the key features of <code>convert</code>/<code>congr!</code>. It's used to solve for equalities for <code>Fintype</code> and <code>Decidable</code> instances.</p>",
        "id": 433833536,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713372788
    },
    {
        "content": "<p>Potentially we could make a special typeclass for this automation. A <code>FastSubsingleton</code> class that's meant to both succeed and fail fast?</p>",
        "id": 433833755,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713372857
    },
    {
        "content": "<p>we should do some statistics on what kind of subsingleton goals are actually proved by <code>convert</code>. Maybe it's <em>just</em> <code>Fintype</code> and <code>Decidable</code>?</p>",
        "id": 433833775,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713372864
    },
    {
        "content": "<p>I was thinking even more than that, just skip typeclass resolution completely and look for those types (or some lightly extensible variation of that)</p>",
        "id": 433833900,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713372907
    },
    {
        "content": "<p>Btw, I'm in the process of rewriting <code>congr!</code> to be more efficient. During this I could look into how much mathlib relies on its use of the general <code>Subsingleton</code> class.</p>",
        "id": 433834469,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713373097
    },
    {
        "content": "<p>In my experience it's always <code>Fintype</code> or <code>Decidable</code></p>",
        "id": 433952586,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713422431
    },
    {
        "content": "<p>See <a href=\"#narrow/stream/287929-mathlib4/topic/Ways.20to.20speed.20up.20Mathlib/near/435443585\">here</a> for hard data supporting my claim.</p>",
        "id": 435443751,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1714069140
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/convert.20is.20often.20slow/near/433833775\">said</a>:</p>\n<blockquote>\n<p>we should do some statistics on what kind of subsingleton goals are actually proved by <code>convert</code>. Maybe it's <em>just</em> <code>Fintype</code> and <code>Decidable</code>?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span> since you are in a stats gathering mood, what do you think about collecting this info? That is, when convert is successfully able to prove <code>Subsingleton</code>, what type was it applied to? Bucketed into the categories \"Propositional goal\" + \"non-propositional type with head X\"</p>",
        "id": 435444767,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1714069565
    },
    {
        "content": "<p>At least as interesting is to collect information on the unsucessful searches, as these are what takes all the time.<br>\nIn any case, that would be great, but to me looks like it requires metaprogramming, which I'm not into (yet?).</p>",
        "id": 435445015,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1714069672
    },
    {
        "content": "<p>Feel free to not collect this information, since my plan for <code>congr!</code> is to special case certain types when generating congruence theorems (rather than checking for a <code>Subsingleton</code> instance on <em>every</em> argument to <em>every</em> function!), and then see how much Subsingleton is actually used to close congr goals.</p>",
        "id": 435446726,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714070315
    },
    {
        "content": "<p>right, my thought regarding collecting the positive cases is to know what we need to put in the whitelist to avoid breaking mathlib too much. Everything else will become a fast failing case for <code>congr!</code>, and while presumably there are many interesting types showing up there we don't really care, except insofar as it will tell us how much we stand to gain</p>",
        "id": 435511228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1714104296
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/12495\">mathlib4#12495</a> adds an extra zero or two in front of each of the timing numbers for the example in this thread.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">000215</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">Lean.Meta.FastSubsingleton</span> <span class=\"kt\">Prop</span> <span class=\"bp\">▶</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">000173</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">Lean.Meta.FastSubsingleton</span> <span class=\"kt\">Prop</span> <span class=\"bp\">▶</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">000006</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">Lean.Meta.FastSubsingleton</span> <span class=\"kt\">Prop</span> <span class=\"bp\">▶</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">000096</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">Lean.Meta.FastSubsingleton</span> <span class=\"n\">α</span> <span class=\"bp\">▶</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">000080</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">Lean.Meta.FastSubsingleton</span> <span class=\"n\">F</span> <span class=\"bp\">▶</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">000005</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">Lean.Meta.FastSubsingleton</span> <span class=\"n\">F</span> <span class=\"bp\">▶</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">000085</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">Lean.Meta.FastSubsingleton</span> <span class=\"o\">(</span><span class=\"n\">Inv</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">▶</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">000071</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">Lean.Meta.FastSubsingleton</span> <span class=\"n\">α</span> <span class=\"bp\">▶</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">000517</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">Inv</span> <span class=\"n\">F</span> <span class=\"bp\">▶</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">000089</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">Lean.Meta.FastSubsingleton</span> <span class=\"o\">(</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">▶</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">000077</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">Lean.Meta.FastSubsingleton</span> <span class=\"o\">(</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">▶</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">000281</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">Lean.Meta.FastSubsingleton</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">▶</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">000005</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">Lean.Meta.FastSubsingleton</span> <span class=\"n\">F</span> <span class=\"bp\">▶</span>\n</code></pre></div>",
        "id": 435925219,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714352416
    },
    {
        "content": "<p>This isn't the final implementation, but \"the perfect is the enemy of the good\", and it has a favorable benchmark.</p>",
        "id": 435925274,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714352463
    },
    {
        "content": "<p>One change you can see in the PR is that sometimes you need <code>apply Subsingleton.elim</code>. I think one could argue that having <code>congr!</code> try to synthesize Subsingleton instances in general doesn't need to be within its purview (maybe there should be a <code>subsingleton</code> tactic that just does <code>apply Subsingleton.elim</code>?). The intent of this tactic is to try to equate dissimilar subexpressions, and it doesn't need to be its responsibility to try <em>too</em> hard.</p>\n<p>Something <a href=\"https://github.com/leanprover-community/mathlib4/pull/12495\">#12495</a> does is let you hint what Subsingleton instances are important by adding them to the local context.</p>\n<p>I could add an option to toggle trying <code>Subsingleton.elim</code> though. I imagine there's not that big of a performance impact to turn it on in general, since it could be used just for cleaning up goals once the congruence algorithm is done.</p>",
        "id": 435926046,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714352857
    },
    {
        "content": "<p>It would be interesting to compare the effect of this with that of <a href=\"https://github.com/leanprover/lean4/pull/4003\">lean4#4003</a> (once the latter is generally available).</p>",
        "id": 435990896,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1714381335
    },
    {
        "content": "<blockquote>\n<p>maybe there should be a <code>subsingleton</code> tactic that just does <code>apply Subsingleton.elim</code>?</p>\n</blockquote>\n<p>I went ahead and implemented such a tactic in <a href=\"https://github.com/leanprover-community/mathlib4/pull/12525\">#12525</a>, but it's more careful than just doing <code>apply Subsingleton.elim</code>. There's this funny fact that you can use it to prove that every type is trivial <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">Subsingleton.elim</span>\n</code></pre></div>\n<p>The <code>subsingleton</code> tactic does a bit more than this too, with a lot of subsingleton functionality extracted from <code>congr!</code>.</p>\n<ul>\n<li>it tries applying <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subsingleton.elim#doc\">docs#Subsingleton.elim</a> (without the above trap!)</li>\n<li>it tries <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=proof_irrel_heq#doc\">docs#proof_irrel_heq</a></li>\n<li>it tries proving <code>BEq</code> instances are equal by synthesizing <code>LawfulBEq</code> instances</li>\n<li>it tries reducing a HEq to an Eq using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subsingleton.helim#doc\">docs#Subsingleton.helim</a> (I'm not sure about this one for this tactic, since it doesn't close the goal)</li>\n<li>it starts with doing <code>intros</code>, since <code>intros; apply Subsingleton.elim</code> is common</li>\n</ul>\n<p>The syntax also lets you write <code>subsingleton [inst]</code> rather than <code>have := inst; subsingleton</code>. This isn't just a convenience, since <code>inst</code> doesn't need all its metavariables be solved for (not even universe level metavariables!). I'm pleased that <code>subsingleton [CharP.CharOne.subsingleton]</code> works — <code>CharP.CharOne.subsingleton</code> has a couple unsolved instance variables in there.</p>\n<p>I'm imagining that <code>subsingleton</code> could be among the tactics that <code>congr!</code> might call as a discharger.</p>",
        "id": 436243525,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714474335
    }
]