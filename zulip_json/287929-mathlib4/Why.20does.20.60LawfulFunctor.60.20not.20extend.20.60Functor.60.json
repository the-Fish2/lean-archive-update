[
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LawfulFunctor#doc\">docs#LawfulFunctor</a> is written using a type class dependency on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Functor#doc\">docs#Functor</a>, but I could imagine another implementation which instead extends <code>Functor</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">LawfulFunctor'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Functor</span> <span class=\"n\">f</span> <span class=\"n\">where</span>\n    <span class=\"n\">map_const</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">},</span> <span class=\"n\">Functor.mapConst</span> <span class=\"bp\">=</span> <span class=\"n\">Functor.map</span> <span class=\"bp\">∘</span> <span class=\"n\">Function.const</span> <span class=\"n\">β</span>\n    <span class=\"n\">id_map</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">id</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n    <span class=\"n\">comp_map</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">g</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>What's the advantage of the chosen implementation over this alternative?</p>",
        "id": 426009337,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1710191503
    },
    {
        "content": "<p>The biggest issue, at least IME, is that it's much more annoying to actually rely on structures being lawful that way. </p>\n<p>For starters, I can't actually make the code block you posted run on its own; I had to give Lean two extra hints:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">LawfulFunctor'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Functor</span> <span class=\"n\">f</span> <span class=\"n\">where</span>\n    <span class=\"n\">map_const</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">},</span> <span class=\"n\">mapConst</span> <span class=\"bp\">=</span> <span class=\"n\">map</span> <span class=\"bp\">∘</span> <span class=\"n\">Function.const</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"n\">id_map</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">id</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n    <span class=\"n\">comp_map</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">g</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>This ... is a running theme. Lean seems to have trouble finding typeclass instances when they're included by <code>extends</code>, and you'll often end up making your own projections to help it along anyway. On top of that, while it doesn't happen in the <code>LawfulFoo</code> pattern specifically, in general there's a footgun that can crop up whenever using <code>extends</code> -- if you specify the definitions of fields existing in the base object, you aren't actually specifying the definitions, you're just giving <em>default</em> definitions and can't rely on those definitions in proofs. </p>\n<p>Certainly, if you already know about that trap you can just not do that and make instances for those cases, but as a general habit + good habit to teach new users, it's probably better to just make separate instances to begin with.</p>\n<p>... Also, I recall hearing about performance issues from typeclass search, that result from instance loops (<code>class C X extends A X, B X</code> means <code>[C X]</code> implies <code>[A X]</code> and <code>[B X]</code>, but then you -- quite reasonably -- create an automatic <code>instance [A X] [B X] : C X</code>). And while it's annoying and verbose to have to type out too many typeclasses, separating them when possible does allow you to <em>not</em>  need that backward direction that closes the instance loop, if you just depend on the component typeclasses directly.</p>",
        "id": 426042742,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710210217
    },
    {
        "content": "<p>I see what you mean, even the code you provided throws an error in the current Lean playground. I got it to work using the code below, but I can see how this is annoying.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">LawfulFunctor'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Functor</span> <span class=\"n\">f</span> <span class=\"n\">where</span>\n    <span class=\"n\">map_const</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">},</span> <span class=\"n\">toFunctor.mapConst</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">toFunctor.map</span> <span class=\"bp\">∘</span> <span class=\"n\">Function.const</span> <span class=\"n\">β</span>\n    <span class=\"n\">id_map</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">id</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n    <span class=\"n\">comp_map</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">g</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 426072315,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1710230826
    },
    {
        "content": "<p>I don't think the comment about typeclass loops is relevant here</p>",
        "id": 426072691,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710231009
    },
    {
        "content": "<p>I don't think there's a particular reason why <code>LawfulFunctor</code> does not <code>extends</code> <code>Functor</code>. One reason would be that you want to talk about functors which have stronger properties that <code>Functor</code> and state they're lawful without having to introduce <code>StrongerLawfulFunctor</code>, but I don't think that really happens in practice.</p>",
        "id": 426080991,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710234317
    },
    {
        "content": "<p>It used to extend functor, but <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> changed it (without comment) 6 years ago in <a href=\"https://github.com/leanprover-community/lean/commit/940aca1ec331707ee4c789cf86069070a6f5931e\">https://github.com/leanprover-community/lean/commit/940aca1ec331707ee4c789cf86069070a6f5931e</a></p>",
        "id": 426082803,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710234985
    }
]