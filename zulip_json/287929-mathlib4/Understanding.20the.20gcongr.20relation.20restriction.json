[
    {
        "content": "<p>I'm trying to use <code>gcongr</code> to dispatch interval arithmetic lemmas.  However, I don't seem to be able to define new <code>gcongr</code> lemmas in the way I expect:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Pointwise.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Pointwise</span>\n<span class=\"kn\">open</span> <span class=\"n\">Set</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- `A` approximates `R`, in that we can map `A → Set R` -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">Approx</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">approx</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">R</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">Approx</span> <span class=\"o\">(</span><span class=\"n\">approx</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- `x` represents `a` is `a ∈ approx x`.  This is an attempt to make `gcongr` work for us. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">reps</span> <span class=\"o\">[</span><span class=\"n\">Approx</span> <span class=\"n\">A</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">approx</span> <span class=\"n\">a</span>\n\n<span class=\"sd\">/-- `-A` is conservative -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">ApproxNeg</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Neg</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Neg</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Approx</span> <span class=\"n\">A</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">approx_neg</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">approx</span> <span class=\"n\">x</span> <span class=\"bp\">⊆</span> <span class=\"n\">approx</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">ApproxNeg</span> <span class=\"o\">(</span><span class=\"n\">approx_neg</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Complains with</span>\n<span class=\"c1\">-- @[gcongr] attribute only applies to lemmas proving x₁ ~₁ x₁' → ... xₙ ~ₙ xₙ' → f x₁ ... xₙ ∼ f x₁' ... xₙ', got ∀</span>\n<span class=\"c1\">--  {R A : Type} [inst : InvolutiveNeg R] [inst_1 : Neg A] [inst_2 : Approx A R] [inst_3 : ApproxNeg A R] (a : A) {x : R},</span>\n<span class=\"c1\">--  reps a x → reps (-a) (-x)</span>\n<span class=\"kd\">@[</span><span class=\"n\">gcongr</span><span class=\"kd\">]</span> <span class=\"kd\">lemma</span> <span class=\"n\">reps_neg</span> <span class=\"o\">[</span><span class=\"n\">InvolutiveNeg</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Neg</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Approx</span> <span class=\"n\">A</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ApproxNeg</span> <span class=\"n\">A</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ax</span> <span class=\"o\">:</span> <span class=\"n\">reps</span> <span class=\"n\">a</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">reps</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">approx_neg</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">neg_mem_neg.mpr</span> <span class=\"n\">ax</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Is <code>reps</code> not a valid relation, or am I doing something else wrong...</p>\n<p>Ah, I see: the <code>f</code> has to be the same on both sides, which in particular means <code>gcongr</code> is restricted to relations between the same type?</p>",
        "id": 411639747,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704668476
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span></p>",
        "id": 411640546,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704669134
    },
    {
        "content": "<p>Yep, that's right.</p>",
        "id": 411647967,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704674461
    },
    {
        "content": "<p>Sounds good, I can make my own related tactic if that’s the better way to go.</p>",
        "id": 411689511,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704702159
    },
    {
        "content": "<p>This kind of looks like <code>mono</code>?</p>",
        "id": 411690080,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704702416
    },
    {
        "content": "<p>Ah, nice!  I had forgotten about <code>mono</code>.  That does work better, though I wasn't expecting to need the <code>rfl</code>s at the end based on the documentation?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Pointwise.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Monotonicity.Basic</span>\n<span class=\"kn\">open</span> <span class=\"n\">Pointwise</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Add</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Add</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- `A` approximates `R`, in that we can map `A → Set R` -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">Approx</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">approx</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">R</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">Approx</span> <span class=\"o\">(</span><span class=\"n\">approx</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">mono</span><span class=\"kd\">]</span> <span class=\"kd\">lemma</span> <span class=\"n\">subset_approx_add</span> <span class=\"o\">[</span><span class=\"n\">Approx</span> <span class=\"n\">A</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">ax</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">⊆</span> <span class=\"n\">approx</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">yb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">⊆</span> <span class=\"n\">approx</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">⊆</span> <span class=\"n\">approx</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- I hoped `mono` would do `rfl` for me -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">approx_mono_test</span> <span class=\"o\">[</span><span class=\"n\">Approx</span> <span class=\"n\">A</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">approx</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">approx</span> <span class=\"n\">y</span> <span class=\"bp\">⊆</span> <span class=\"n\">approx</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">mono</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 411699550,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704706168
    },
    {
        "content": "<p>Ah, <code>attribute [mono] subset_refl</code> fixes it.  Should <code>subset_refl</code> be registered as <code>mono</code> too?</p>",
        "id": 411699832,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704706267
    },
    {
        "content": "<p>Probably! Not many people (no one?) use <code>mono</code>, especially since it was ported to Lean 4 relatively late, so you will find rough edges.</p>",
        "id": 411705275,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704708152
    },
    {
        "content": "<p>I'll send a PR.</p>",
        "id": 411705432,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704708204
    },
    {
        "content": "<p>Note that in the mathlib4 implementation <code>mono</code> is just a bag of lemmas.  So you can make it mimic <code>continuity</code> or whatever you want:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Instances.Real</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">mono</span><span class=\"o\">]</span> <span class=\"n\">Continuous.add</span> <span class=\"n\">Continuous.mul</span> <span class=\"n\">continuous_const</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">mono</span>\n</code></pre></div>",
        "id": 411705845,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704708353
    },
    {
        "content": "<p>(not actually recommended ...)</p>",
        "id": 411706029,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704708404
    },
    {
        "content": "<p>Right, but I think <code>subset_refl</code> is a valid <code>mono</code> lemma, not a random lemma.</p>",
        "id": 411706084,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704708426
    },
    {
        "content": "<p>Hmm, actually, should <code>mono</code> just use all <code>refl</code> lemmas?  <code>subset_refl</code> is already marked <code>refl</code>.</p>",
        "id": 411706195,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704708477
    },
    {
        "content": "<p>It seems like this wouldn't have very good performance!</p>",
        "id": 411706331,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704708518
    },
    {
        "content": "<p>Is adding <code>subset_refl</code> specifically to <code>mono</code> correct to do here?</p>",
        "id": 411706389,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704708543
    },
    {
        "content": "<p>I don't really have a mental model of what monotonicity means for a heterogeneous \"relation.\"</p>",
        "id": 411706722,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704708676
    },
    {
        "content": "<p>Oh, but you're asking about <code>subset_refl</code> which is homogeneous ... so yes, I think so.</p>",
        "id": 411707075,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704708736
    },
    {
        "content": "<p>(by analogy with <code>le_refl</code>, which is marked as such)</p>",
        "id": 411707128,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704708758
    },
    {
        "content": "<p>In the cases I'm working with there are two types <code>X, Y</code> that are twinned, in that there are a bunch of <code>f : X \\to X</code> with a corresponding <code>f' : Y \\to Y</code>.  E.g., both have arithmetic.  This is why I sensibly want something like <code>mono</code> in a heterogenous case.</p>",
        "id": 411707223,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704708787
    },
    {
        "content": "<p>You could try removing the logic in the <code>gcongr</code> tagging that enforces LHS/RHS of same type, and see if it still works ...</p>",
        "id": 411708366,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704709138
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/9547\">https://github.com/leanprover-community/mathlib4/pull/9547</a> does <code>attribute [mono] subset_refl</code></p>",
        "id": 411709302,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704709429
    }
]