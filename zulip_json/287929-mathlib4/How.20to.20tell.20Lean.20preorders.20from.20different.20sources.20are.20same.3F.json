[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Intervals.Image</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.CompleteLatticeIntervals</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Order.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">Function</span> <span class=\"n\">Set</span> <span class=\"n\">Topology</span>\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ConditionallyCompleteLinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OrderTopology</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">δ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">δ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OrderClosedTopology</span> <span class=\"n\">δ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">A</span> <span class=\"o\">[</span><span class=\"n\">BoundedOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf_c</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">⊥</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"bp\">⊤</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf_i</span> <span class=\"o\">:</span> <span class=\"n\">Injective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">StrictMono</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">B</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hfab</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hf_c</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousOn</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hf_i</span> <span class=\"o\">:</span> <span class=\"n\">InjOn</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">StrictMonoOn</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">Icc.completeLinearOrder</span> <span class=\"n\">hab</span>\n  <span class=\"n\">refine</span> <span class=\"n\">StrictMono.of_restrict</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">set</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"o\">:=</span> <span class=\"n\">Set.restrict</span> <span class=\"o\">(</span><span class=\"n\">Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">f</span>\n  <span class=\"k\">have</span> <span class=\"n\">hgab</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">⊥</span> <span class=\"bp\">≤</span> <span class=\"n\">g</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">exact</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">hf_c.restrict</span> <span class=\"n\">hgab</span> <span class=\"n\">hf_i.injective</span>\n</code></pre></div>\n<p>Error occurs in the last line:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">ContinuousOn.restrict</span> <span class=\"n\">hf_c</span><span class=\"o\">)</span> <span class=\"n\">hgab</span> <span class=\"o\">(</span><span class=\"n\">InjOn.injective</span> <span class=\"n\">hf_i</span><span class=\"o\">)</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">StrictMono</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">StrictMono</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>The reason is that the first <code>StrictMono g</code> is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">StrictMono</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"n\">δ</span> <span class=\"n\">PartialOrder.toPreorder</span> <span class=\"n\">PartialOrder.toPreorder</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>while the second <code>StrictMono g</code> is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">StrictMono</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"n\">δ</span> <span class=\"o\">(</span><span class=\"n\">Subtype.preorder</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">PartialOrder.toPreorder</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>It seems that Lean does not realize that the <code>Preorder</code> obtained from <code>PartialOrder</code> on <code>Icc a b</code> and the <code>Subtype.preorder</code> inherited from <code>α</code> are the same.<br>\nWhat should I do?</p>",
        "id": 418377698,
        "sender_full_name": "Wen Yang",
        "timestamp": 1706321331
    },
    {
        "content": "<p>Just replace <code>haveI := Icc.completeLinearOrder hab</code> by <code>letI</code>.</p>",
        "id": 420706155,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1707502521
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/287929-mathlib4/topic/How.20to.20tell.20Lean.20preorders.20from.20different.20sources.20are.20same.3F/near/420706155\">发言道</a>：</p>\n<blockquote>\n<p>Just replace <code>haveI := Icc.completeLinearOrder hab</code> by <code>letI</code>.</p>\n</blockquote>\n<p>It works! It is really amazing! Thank you very much! <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 420751597,
        "sender_full_name": "Wen Yang",
        "timestamp": 1707523000
    },
    {
        "content": "<p>I'm sorry it took so long to get the question answered. It's a <a href=\"#narrow/stream/113488-general/topic/Type.20class.20trouble/near/283195180\">pretty</a> <a href=\"#narrow/stream/287929-mathlib4/topic/FunLike.20issues/near/315069815\">common</a> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Tensor.20products/near/360890599\">mistake</a> so I'd expect it got answered quickly. What's happening here is that <code>haveI</code> behaves like <code>lemma</code>/<code>theorem</code> which are intended for proofs, so they forget the term (proof) and only remember its type (statement), while <code>letI</code> behaves like <code>def</code>, which is intended for data, so they remember the term (data) as well as its type. In this particular case, <code>haveI := Icc.completeLinearOrder hab</code> forgets the term <code>Icc.completeLinearOrder hab</code> and only remembers its type <code>CompleteLinearOrder ↑(Icc a b)</code>; if you try <code>have : this = Icc.completeLinearOrder hab := rfl</code> you will also get a type mismatch error.</p>",
        "id": 420756408,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1707526613
    },
    {
        "content": "<p>If there were a core linter for this then the problem would basically go away</p>",
        "id": 420786714,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707558551
    }
]