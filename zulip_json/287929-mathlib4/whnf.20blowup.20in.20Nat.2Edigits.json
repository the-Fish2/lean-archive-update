[
    {
        "content": "<p>Pertaining to <code>Archive/Imo/Imo1962Q1.lean</code>, which is one of the broken files in <a href=\"#narrow/stream/287929-mathlib4/topic/request.20for.20help.20with.20failure.20in.20Archive/near/399646876\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/request.20for.20help.20with.20failure.20in.20Archive/near/399646876</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Digits</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.whnf</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Nat.digits</span> <span class=\"mi\">10</span> <span class=\"mi\">15</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">norm_num</span> <span class=\"c1\">-- succceds, but with more than 24600 lines of whnf traces</span>\n</code></pre></div>\n<p>The sheer size of that trace output makes me suspicious.</p>",
        "id": 399757322,
        "sender_full_name": "David Renshaw",
        "timestamp": 1698855428
    },
    {
        "content": "<p>lots of stuff like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.whnf</span><span class=\"o\">]</span> <span class=\"k\">match</span> <span class=\"n\">decEq</span> <span class=\"o\">((</span><span class=\"mi\">14</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"o\">(</span><span class=\"mi\">8</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"mi\">5</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">hab</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">match</span>\n        <span class=\"n\">List.hasDecEq</span>\n          <span class=\"o\">((</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span>\n              <span class=\"n\">Acc.rec</span>\n                <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x₁</span> <span class=\"n\">h</span> <span class=\"n\">ih</span> <span class=\"bp\">↦</span>\n                  <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">a_1</span> <span class=\"bp\">↦</span>\n                      <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span>\n                          <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n                            <span class=\"o\">((</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">invImage</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"n\">sizeOf</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">instWellFoundedRelation</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n                          <span class=\"n\">a</span> <span class=\"k\">with</span>\n                        <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">[]</span>\n                        <span class=\"bp\">|</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"o\">(</span><span class=\"mi\">8</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">x</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">8</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n                        <span class=\"n\">a_1</span><span class=\"o\">)</span>\n                    <span class=\"n\">x₁</span> <span class=\"n\">ih</span><span class=\"o\">)</span>\n                <span class=\"n\">_</span><span class=\"o\">)</span>\n            <span class=\"o\">((</span><span class=\"mi\">14</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">8</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n          <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"n\">habs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isTrue</span> <span class=\"n\">_</span>\n      <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"n\">nabs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"n\">_</span>\n    <span class=\"bp\">|</span> <span class=\"n\">isFalse</span> <span class=\"n\">nab</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isFalse</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 399757674,
        "sender_full_name": "David Renshaw",
        "timestamp": 1698855564
    },
    {
        "content": "<p>Anyone have any ideas about how I might drill down on this further?</p>",
        "id": 399757719,
        "sender_full_name": "David Renshaw",
        "timestamp": 1698855588
    },
    {
        "content": "<p>Or maybe this isn't actually suspicious, and I'm barking up the wrong tree?</p>",
        "id": 399757737,
        "sender_full_name": "David Renshaw",
        "timestamp": 1698855600
    },
    {
        "content": "<p>it's because <code>norm_num</code> doesn't implement <code>Nat.digits</code></p>",
        "id": 399758971,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698856065
    },
    {
        "content": "<p>Do we need to implement a <code>norm_digits</code> tactic?</p>",
        "id": 399765793,
        "sender_full_name": "David Renshaw",
        "timestamp": 1698858509
    },
    {
        "content": "<p><code>norm_num</code> currently can't output a value of list type.</p>",
        "id": 399765821,
        "sender_full_name": "David Renshaw",
        "timestamp": 1698858525
    },
    {
        "content": "<blockquote>\n<p>it's because norm_num doesn't implement Nat.digits</p>\n</blockquote>\n<p>right, so this is falling back on <code>simp</code> where the mathlib3 version had some tailored <code>norm_num</code> logic.<br>\nI guess all that extra <code>whnf</code> form work has to do with <code>simp</code> trying to figure out what steps to take?</p>",
        "id": 399766510,
        "sender_full_name": "David Renshaw",
        "timestamp": 1698858832
    },
    {
        "content": "<p><code>simp</code> called <code>decide</code> and <code>decide</code> is doing the whnf work</p>",
        "id": 399766619,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698858860
    },
    {
        "content": "<p>I'm currently working on a new tactic that will be much more general than <code>norm_num</code> and can potentially evaluate <code>Nat.digits</code> without a custom implementation, but I can also look into a smaller addition to <code>norm_num</code> to allow it to do reductions in other types</p>",
        "id": 399767260,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698859158
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/8100\">#8100</a> implements <code>norm_num</code> framework support for inductive types</p>",
        "id": 399801576,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1698871907
    },
    {
        "content": "<p>At a high level, I'm still confused about why we need to write special tactic code to reduce functions like <code>Nat.digits</code>. The function is already defined in a perfectly computational way, and <code>#eval</code> has no trouble with it.</p>",
        "id": 399959552,
        "sender_full_name": "David Renshaw",
        "timestamp": 1698937420
    },
    {
        "content": "<p>(I think) it's because kernel reduction is currently inefficient, but IIUC, this is one of the things Joachim is going to be working on.</p>",
        "id": 399972394,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1698940398
    },
    {
        "content": "<p>Hopefully, but maybe not at first, so don’t hold your breath.</p>",
        "id": 399972645,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1698940471
    },
    {
        "content": "<p>Simpler setup, with no <code>norm_num</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Digits</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.whnf</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Nat.digits</span> <span class=\"mi\">10</span> <span class=\"mi\">25</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"c1\">-- more than 50,000 lines of Meta.whnf traces</span>\n</code></pre></div>",
        "id": 399994280,
        "sender_full_name": "David Renshaw",
        "timestamp": 1698947464
    },
    {
        "content": "<p>It's only 13ms in total though, no? (with just <code>trace.profiler</code>, which adds its own overhead)</p>",
        "id": 399994578,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1698947593
    },
    {
        "content": "<p>sure, it's fast without the trace</p>",
        "id": 399994608,
        "sender_full_name": "David Renshaw",
        "timestamp": 1698947616
    },
    {
        "content": "<p>but it hits the maxRecDepth quickly if I make the inputs larger</p>",
        "id": 399994630,
        "sender_full_name": "David Renshaw",
        "timestamp": 1698947628
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Digits</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Nat.digits</span> <span class=\"mi\">10</span> <span class=\"mi\">1256</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"mi\">6</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"c1\">-- maximum recursion depth has been reached (use `set_option maxRecDepth &lt;num&gt;` to increase limit)</span>\n</code></pre></div>",
        "id": 399994755,
        "sender_full_name": "David Renshaw",
        "timestamp": 1698947683
    },
    {
        "content": "<p>Maybe some reduction function in the Lean core is supposed to be tail recursive, but isn't?</p>",
        "id": 399994863,
        "sender_full_name": "David Renshaw",
        "timestamp": 1698947733
    },
    {
        "content": "<p>Am I being unreasonable for expecting to be able to normalize <code>Nat.digits 10 1256</code> by <code>rfl</code>? It seems like it should not be a very big computation.</p>",
        "id": 399996843,
        "sender_full_name": "David Renshaw",
        "timestamp": 1698948463
    },
    {
        "content": "<p>I have a guess that it's due to how the <code>decreasing_by</code> is being compiled for the kernel -- doesn't this mean that it computes <code>Nat.digits 10</code> for all numbers up to <code>1256</code> and then selects this last value?</p>",
        "id": 400000231,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698949954
    },
    {
        "content": "<p>Here's another implementation that recurses on a gas variable instead, and it can handle big numbers fine:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Nat.digitsAux</span> <span class=\"o\">(</span><span class=\"n\">gas</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">gas</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">gas'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">b</span>\n    <span class=\"k\">if</span> <span class=\"n\">q</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"k\">then</span>\n      <span class=\"n\">n</span> <span class=\"bp\">%</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">Nat.digitsAux</span> <span class=\"n\">gas'</span> <span class=\"n\">b</span> <span class=\"n\">q</span>\n    <span class=\"k\">else</span>\n      <span class=\"o\">[]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Nat.digits</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">List.replicate</span> <span class=\"n\">n</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.digitsAux</span> <span class=\"n\">n</span> <span class=\"n\">b</span> <span class=\"n\">n</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Nat.digits</span> <span class=\"mi\">10</span> <span class=\"mi\">1234567890</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">9</span><span class=\"o\">,</span> <span class=\"mi\">8</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">6</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 400000295,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698949974
    },
    {
        "content": "<p>You can remove the <code>gas</code> variable and Lean can still see it terminates, but then that <code>example</code> hits max recursion depth.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Nat.digitsAux</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">b</span>\n  <span class=\"k\">if</span> <span class=\"n\">q</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"k\">then</span>\n    <span class=\"n\">n</span> <span class=\"bp\">%</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">Nat.digitsAux</span> <span class=\"n\">b</span> <span class=\"n\">q</span>\n  <span class=\"k\">else</span>\n    <span class=\"o\">[]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Nat.digits</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">List.replicate</span> <span class=\"n\">n</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.digitsAux</span> <span class=\"n\">b</span> <span class=\"n\">n</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Nat.digits</span> <span class=\"mi\">10</span> <span class=\"mi\">1234567890</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">9</span><span class=\"o\">,</span> <span class=\"mi\">8</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">6</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- maximum recursion depth has been reached</span>\n</code></pre></div>",
        "id": 400000589,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1698950083
    },
    {
        "content": "<p>With gas, it’s using structural recursion, without it’s using well-founded recursion. I thought the latter doesn't even reduce definionally, but it seems the kernel can somehow evaluate it, but obviously much slower. I wonder (blind guess) if the kernel is explicitly constructing the <code>Acc</code> predicate provided by <code>WellFoundedRelation</code> for the argument number?</p>",
        "id": 400022472,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1698960893
    },
    {
        "content": "<p>I thought this was an interesting topic, so I investigated a bit more deeply and I made a video explaining what I learned: <a href=\"https://www.youtube.com/watch?v=FOt-GsiNJmU\">https://www.youtube.com/watch?v=FOt-GsiNJmU</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"FOt-GsiNJmU\" href=\"https://www.youtube.com/watch?v=FOt-GsiNJmU\"><img src=\"https://uploads.zulipusercontent.net/2ff43a8d3c140fbd943fb008c78e6331a4cbb94b/68747470733a2f2f692e7974696d672e636f6d2f76692f464f742d4773694e4a6d552f64656661756c742e6a7067\"></a></div>",
        "id": 409029444,
        "sender_full_name": "David Renshaw",
        "timestamp": 1703026491
    },
    {
        "content": "<p>Thanks for the really interesting video David! It led to a very naive question for me - why does the kernel have to expand and typecheck the proof of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.lt_wfRel#doc\">docs#Nat.lt_wfRel</a> out at all?</p>",
        "id": 409037637,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703031116
    },
    {
        "content": "<p>My understanding is:</p>\n<ol>\n<li><code>WellFounded</code> is only used to kick things off. Once the recursion gets going, it's all in terms of <code>Acc</code></li>\n<li>If the recursion is at value <code>n</code> and needs to step to value <code>m</code>, then it has an <code>Acc n</code> and needs to use it to get an <code>Acc m</code>. I think it's that conversion where all the proof reduction happens.</li>\n<li>This all seems kind of silly, because we have an ambient <code>WellFounded</code> floating around in the typeclass system, so it feels like we ought to be able to ask it directly for an <code>Acc m</code>, rather than reducing our existing proof term.</li>\n</ol>",
        "id": 409038267,
        "sender_full_name": "David Renshaw",
        "timestamp": 1703031382
    },
    {
        "content": "<p>I want to emphasize that my understanding is only hazy, and I love it if someone who's more of an expert on these things could explain better.</p>",
        "id": 409038360,
        "sender_full_name": "David Renshaw",
        "timestamp": 1703031426
    },
    {
        "content": "<p>To take a step back, though: <code>Acc.rec</code> is where the recursion is coming from. It accepts an argument of type <code>Acc</code>, and for its reduction rule to fire, that argument must be normalized to a form <code>Acc.intro ...</code>.</p>",
        "id": 409040002,
        "sender_full_name": "David Renshaw",
        "timestamp": 1703032028
    },
    {
        "content": "<p>It seems to me that the fact that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WellFoundedRelation#doc\">docs#WellFoundedRelation</a> is in <code>Sort</code> is the cause of all this</p>",
        "id": 409040094,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703032070
    },
    {
        "content": "<p>(which of course it must be, but if the relation is unbundled as in just <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WellFounded#doc\">docs#WellFounded</a> it should just be able to take the correct steps - theoretically?)</p>",
        "id": 409040227,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703032112
    },
    {
        "content": "<p>I see, so I just realised - <code>Acc.rec</code> wants a normalised form to be able to actually reduce the recursor. But as a one field <code>Prop</code> structure, there is no actual need for this in reality; but I'm guessing this requires special kernel support, either for <code>Acc</code> specifically or one-constructor <code>Prop</code> structures more generally.</p>",
        "id": 409045489,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703034035
    },
    {
        "content": "<p>I think some thought has been put into trying to maximise performance: using a very <a href=\"https://gist.github.com/ericrbg/89dfcda9f715d5cccb62917f07d13f48\">rudimentary testing setup</a>, replacing the definition of <code>Nat.lt_wfRel.wf</code> with alternative options, there's no clear-cut way to make this faster (and indeed, as expected, using <code>sorry</code> to force Lean to not bother reducing the <code>Acc</code> constructors makes <code>#reduce</code> blazing fast)</p>",
        "id": 409046500,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703034240
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243791\">David Renshaw</span> <a href=\"#narrow/stream/287929-mathlib4/topic/whnf.20blowup.20in.20Nat.2Edigits/near/409038267\">said</a>:</p>\n<blockquote>\n<p>This all seems kind of silly, because we have an ambient <code>WellFounded</code> floating around in the typeclass system, so it feels like we ought to be able to ask it directly for an <code>Acc m</code>, rather than reducing our existing proof term.</p>\n</blockquote>\n<p>The kernel is really myopic, it is in the middle of running <code>whnf</code> on a term and has no idea what is in your context, much less what the typeclass system thinks</p>",
        "id": 409085973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703046271
    },
    {
        "content": "<p>I have thought about having the kernel use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Acc.inv#doc\">docs#Acc.inv</a> to produce a proof of <code>Acc r m</code> from <code>Acc r n</code>, which would avoid ever having to reduce proofs, but the proofs get larger at every step. If there was some way of mixing a <code>WellFounded</code> fact in there somehow then the proof could be constant size across the recursion, which sounds nice</p>",
        "id": 409086268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703046400
    },
    {
        "content": "<p>the downside of all these schemes is that they lead to undecidable typechecking, because if you are in an inconsistent context then you can still use <code>whnf</code> on false <code>Acc</code> proofs of termination and loop forever. However this is already a problem with the current system (it's unavoidable as long as <code>Acc</code> is a large-eliminating Prop) which is currently addressed by making <code>Acc</code> only reduce if the proof term reduces to a constructor, so it would get stuck if it was a false hypothesis or axiom. There is a discussion about this in <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a></p>",
        "id": 409086804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703046648
    },
    {
        "content": "<p>Oh, so this is why I couldn't get rfl to work on small terms with my sorried version even when reduce did</p>",
        "id": 409099414,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703053409
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/whnf.20blowup.20in.20Nat.2Edigits/near/409086268\">said</a>:</p>\n<blockquote>\n<p>I have thought about having the kernel use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Acc.inv#doc\">docs#Acc.inv</a> to produce a proof of <code>Acc r m</code> from <code>Acc r n</code>, which would avoid ever having to reduce proofs, but the proofs get larger at every step. If there was some way of mixing a <code>WellFounded</code> fact in there somehow then the proof could be constant size across the recursion, which sounds nice</p>\n</blockquote>\n<p>Isn't this what happens already? The proof of nat wf uses it</p>",
        "id": 409099633,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703053492
    },
    {
        "content": "<p>not sure what you mean</p>",
        "id": 409100102,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703053651
    },
    {
        "content": "<p>what I'm saying is that when you have a term <code>wf : WellFounded R</code> which is opaquified in some way, then we want reducing <code>wf.apply n : Acc R n</code> to a constructor to result in <code>Acc.intro n fun y h =&gt; wf.apply y</code> rather than some more complicated (but definitionally equal because of proof irrelevance) term in place of <code>wf.apply y</code></p>",
        "id": 409101026,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703053924
    },
    {
        "content": "<p>Note that we can't really do this for <code>Acc R n</code> terms directly, because we don't have any easy way to describe <code>Acc R y</code> except in terms of the original <code>h : Acc R n</code> term, so you end up with a more complicated term which uses <code>h</code> on the RHS. Compare:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">wf</span> <span class=\"o\">:</span> <span class=\"n\">WellFounded</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">wf.apply</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">Acc.intro</span> <span class=\"n\">n</span> <span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">wf.apply</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Acc</span> <span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">Acc.intro</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Acc.inv</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 409101525,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703054144
    },
    {
        "content": "<p>(imagine these are rewrite rules from left to right applied lazily by <code>whnf</code>)</p>",
        "id": 409101638,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703054181
    },
    {
        "content": "<p>Both of these methods are IMO better than the current approach of unfolding <code>h</code> (which is a proof), exposing lots of implementation details and usually getting stuck on an axiom eventually anyway</p>",
        "id": 409101811,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703054250
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243791\">@David Renshaw</span> I really liked the video, it is very well produced and you explained things well. I was also very interested to see your lean4lean modification for visualizing kernel reduction, I have wanted that for a very long time. You should make it available somewhere!</p>",
        "id": 409117989,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703060219
    },
    {
        "content": "<p>This seems to have no effect with the rudimentary testing setup linked above, although to my eyes it does seem that it should be far faster to do this. It'd be nice to have David's modification to see the proof terms! I also realised that some of the examples I sent in this file yesterday don't seem to reduce, but for example <code>h_UC</code> uses no axioms so should not be blocked!</p>",
        "id": 409132198,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703065750
    },
    {
        "content": "<p>I'm not sure what you are saying you tried</p>",
        "id": 409132424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703065835
    },
    {
        "content": "<p>what I described is a change to the kernel reduction algorithm</p>",
        "id": 409132456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703065845
    },
    {
        "content": "<p>I just tried inlining the such a definition, which should have a similar enough effect?</p>",
        "id": 409133075,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703066013
    },
    {
        "content": "<p>Or does stuff get unfolded still</p>",
        "id": 409133112,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703066020
    },
    {
        "content": "<p>which definition?</p>",
        "id": 409133159,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703066029
    },
    {
        "content": "<p>the kernel will unfold definitions when needed, so generally that won't make any difference</p>",
        "id": 409133376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703066066
    },
    {
        "content": "<p>My file just contains various different proofs of <code>∀ (a : ℕ), Acc Nat.lt a</code> to try and understand a bit, so if my understanding wasn't flawed then setting this to <code>Acc.intro n fun y _ =&gt; wf.apply y</code> shouldn't be too bad; but now I guess that if you don't have this as a rewrite rule within the kernel then after one layer of peeling you're straight back to the original issue</p>",
        "id": 409133710,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703066137
    },
    {
        "content": "<p>exactly</p>",
        "id": 409133778,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703066152
    },
    {
        "content": "<p>Normally reduction will proceed by first reducing the Acc proof to <code>Acc.intro</code> of something, then stepping the <code>Acc.rec</code> function once, then reducing the user function <code>f</code> until evaluation reaches uses of the IH, and then repeat</p>",
        "id": 409134461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703066284
    },
    {
        "content": "<p>and the question is whether it is possible to adjust the first step so that the amount of computation needed is minimal and the terms don't grow unnecessarily</p>",
        "id": 409134700,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703066336
    },
    {
        "content": "<p>I understand that type-theoretically it's bad to have the kernel have even more undecidable type-checking, but is this actually a problem in practice? Practically all that will happen is that we get timeouts during <code>rfl</code>, which we already do in cases where we really would like these statements to reduce anyways, so it seems we're no better off avoiding the issue</p>",
        "id": 409134820,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703066360
    },
    {
        "content": "<p>I tend to agree with that</p>",
        "id": 409134934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703066384
    },
    {
        "content": "<p>especially since \"even more undecidable\" is not particularly interesting to type theorists</p>",
        "id": 409135098,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703066408
    },
    {
        "content": "<p>the practical upshot would be that WF definitions compute by <code>rfl</code> just as well as structural recursions, which sounds like a very useful property</p>",
        "id": 409135326,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703066452
    },
    {
        "content": "<p>Note that when I wrote <code>lean4lean</code> I made it structurally terminating by just indiscriminately turning every non-structural recursion into a recursion with 1000 iterations and I could check mathlib just fine</p>",
        "id": 409136725,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703066711
    },
    {
        "content": "<p>So apparently mathlib does not depend on deep recursion in reduction</p>",
        "id": 409136904,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703066748
    },
    {
        "content": "<p>That probably isn't always the case, I'm sure if we had more coq style proofs by reflection we might need to increase the limit in some places</p>",
        "id": 409137094,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703066777
    },
    {
        "content": "<p>I mean considering how slow this recursion is at the moment (and in Lean3 wasn't it just stuck indiscriminately?) it's not at all surprising to me that Mathlib doesn't seem to use it</p>",
        "id": 409137820,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703066914
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/whnf.20blowup.20in.20Nat.2Edigits/near/409117989\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"243791\">David Renshaw</span>  I was also very interested to see your lean4lean modification for visualizing kernel reduction, I have wanted that for a very long time. You should make it available somewhere!</p>\n</blockquote>\n<p>It currently has zero polish and is not really intended for external consumption, but here it is: <a href=\"https://github.com/dwrensha/lean4lean/tree/reduce-cmd\">https://github.com/dwrensha/lean4lean/tree/reduce-cmd</a></p>",
        "id": 409189157,
        "sender_full_name": "David Renshaw",
        "timestamp": 1703079969
    },
    {
        "content": "<p>do you guys think it's worth writing an RFC/issue requesting Acc/one constructor Props's recursors to be expanded eagerly in the kernel?</p>",
        "id": 409189352,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703080059
    },
    {
        "content": "<p>It started to get rather ugly when I made it so that it returns a trace even when the reduction throws an exception.</p>",
        "id": 409189462,
        "sender_full_name": "David Renshaw",
        "timestamp": 1703080088
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/whnf.20blowup.20in.20Nat.2Edigits/near/409135326\">said</a>:</p>\n<blockquote>\n<p>the practical upshot would be that WF definitions compute by <code>rfl</code> just as well as structural recursions, which sounds like a very useful property</p>\n</blockquote>\n<p>Sounds good to me, as long as the cost isn't: \"now writing a third-party typechecker is much more difficult\".</p>",
        "id": 409190633,
        "sender_full_name": "David Renshaw",
        "timestamp": 1703080498
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/whnf.20blowup.20in.20Nat.2Edigits/near/409101026\">said</a>:</p>\n<blockquote>\n<p>what I'm saying is that when you have a term <code>wf : WellFounded R</code> which is opaquified in some way, then we want reducing <code>wf.apply n : Acc R n</code> to a constructor to result in <code>Acc.intro n fun y h =&gt; wf.apply y</code> rather than some more complicated (but definitionally equal because of proof irrelevance) term in place of <code>wf.apply y</code></p>\n</blockquote>\n<p>I’m out of my depth here, so this is more about me learning more…</p>\n<p>If I understand you correctly, it would be great if a definition like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">WellFounded.apply'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">wf</span> <span class=\"o\">:</span> <span class=\"n\">WellFounded</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Acc</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Acc.intro</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">wf.apply'</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>would unfold as such in the kernel, so that recursive definitions can recurse on that one (rather than <code>wf.apply</code> which could lead to complex proofs).</p>\n<p>But of course that definition isn’t accepted, because it’s recursive. One could try to write a function that traverses the “<code>Acc</code> tree” and replace all proofs by a “short expression”, maybe like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">WellFounded.apply'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">wf</span> <span class=\"o\">:</span> <span class=\"n\">WellFounded</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Acc</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Acc.rec</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Acc.intro</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"n\">_h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">wf.apply</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">wf.apply</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but that just moves the issue around: To see these nicer<code>Acc.intro</code> constructors, the kernel would have to unfold <em>this</em> proof, and we still end up with the large proofs from <code>wf.apply</code>.</p>\n<p>Is that correct so far?</p>",
        "id": 409191206,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1703080723
    },
    {
        "content": "<p>Yes. My idea behind making <code>WellFounded.apply'</code> work would be to make it magic in the kernel, it would perform that reduction instead of the real one when coming across that particular constant</p>",
        "id": 409195078,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703081834
    },
    {
        "content": "<p>Note that this does not involve any new definitional equalities, because <code>WellFounded.apply'</code> is a proof</p>",
        "id": 409195184,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703081871
    },
    {
        "content": "<p>The natural definition which would have the right properties here is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">WellFounded.apply'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">wf</span> <span class=\"o\">:</span> <span class=\"n\">WellFounded</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Acc</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n  <span class=\"n\">wf.apply</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">WellFounded.apply'_iota</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">wf</span> <span class=\"o\">:</span> <span class=\"n\">WellFounded</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">wf.apply'</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">Acc.intro</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">wf.apply'</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 409195724,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703082023
    },
    {
        "content": "<p>making it <code>opaque</code> ensures that <code>apply'</code> is exposed when we want it to be and does not have any unexpected reductions, and then <code>apply'_iota</code> is a built in reduction rule</p>",
        "id": 409195857,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703082066
    },
    {
        "content": "<p>note: you would have to turn this reduction off in <code>#reduce</code> I think, or else it would trivially loop</p>",
        "id": 409196582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703082265
    },
    {
        "content": "<p>I posted a website with an example kernel reduction trace (<code>minus3 7</code>) here: <a href=\"https://dwrensha.github.io/kernel-reduction-explosion/\">https://dwrensha.github.io/kernel-reduction-explosion/</a> . (Warning: the data payload is &gt; 75MB.)</p>",
        "id": 409196632,
        "sender_full_name": "David Renshaw",
        "timestamp": 1703082280
    },
    {
        "content": "<p>yeah, debugging these traces is fun and blows up vscode a lot</p>",
        "id": 409196755,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703082316
    },
    {
        "content": "<p>I also have a half baked logging branch of lean4lean but the one you demoed looks a lot better than mine</p>",
        "id": 409196859,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703082354
    },
    {
        "content": "<p>The raw json for this trace is 16MB. The syntax highlighting is what makes it really heavy. (I'm using pygments.)</p>",
        "id": 409196950,
        "sender_full_name": "David Renshaw",
        "timestamp": 1703082372
    },
    {
        "content": "<p>I just want to acknowledge that this is the best video about Lean 4 in terms of production quality I've seen so far <span aria-label=\"exploding head\" class=\"emoji emoji-1f92f\" role=\"img\" title=\"exploding head\">:exploding_head:</span><br>\nGood dynamics, audio capture, frame rate, font size, editing etc <span aria-label=\"pinched\" class=\"emoji emoji-1f90c\" role=\"img\" title=\"pinched\">:pinched:</span></p>",
        "id": 409205775,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1703084976
    },
    {
        "content": "<p>I agree, great video. Good speed, too :-)</p>\n<p>Small technical comment: Proof erasure is not why the IR code for well-founded recursion doesn’t blow up. The actual reason is that there is a fork in the <code>Expr</code> pipeline. The definitions are first elaborated to <code>PreDefinition</code>, which can be recursive.<br>\nThe path towards the compiler forrks here, and IR, IR interpreter and compiler then simply process recursive definitions. This is also why <code>partial</code> or <code>unsafe</code> recursive definitions work in <code>#eval</code>.<br>\nThe other path goes towards the kernel, and the (recursive) <code>PreDefinition</code>s are then elaborated some more into non-recursive definitions using <code>.brec</code> or <code>WellFounded.fix</code> etc.</p>",
        "id": 409222430,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1703090365
    },
    {
        "content": "<p>Interesting! I wonder whether there is a way to cause any kind of proof-term reduction to happen during an <code>#eval</code>...</p>",
        "id": 409224748,
        "sender_full_name": "David Renshaw",
        "timestamp": 1703091250
    },
    {
        "content": "<p>It would be fun to see an example where <code>#eval</code> is slow but the compiled native code is fast.</p>",
        "id": 409224939,
        "sender_full_name": "David Renshaw",
        "timestamp": 1703091336
    },
    {
        "content": "<p>My understanding is that <code>#eval t</code> puts <code>t</code> through the compiler pipeline to create IR, and then this IR is evaluated by a virtual machine. By that point, there are no proofs.</p>\n<p>The difference between <code>#eval</code> and native compilation is that this IR isn't translated to C and then compiled.</p>",
        "id": 409227241,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703091838
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243791\">David Renshaw</span> <a href=\"#narrow/stream/287929-mathlib4/topic/whnf.20blowup.20in.20Nat.2Edigits/near/409224939\">said</a>:</p>\n<blockquote>\n<p>It would be fun to see an example where <code>#eval</code> is slow but the compiled native code is fast.</p>\n</blockquote>\n<p>One case where this happens is when using naive recursive algorithms, because <code>#eval</code> and the compiler do exactly what you say here while the kernel uses <code>brecOn</code> which is \"accidentally\" a memoizing computation.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fib</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">fib</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">fib</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">fib</span> <span class=\"mi\">30</span> <span class=\"c1\">-- fast</span>\n<span class=\"k\">#eval</span> <span class=\"n\">fib</span> <span class=\"mi\">30</span>   <span class=\"c1\">-- slow</span>\n</code></pre></div>",
        "id": 409237687,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703095754
    },
    {
        "content": "<p>er, I guess that's not exactly what you asked for, since you compared <code>#eval</code> to native code, not to kernel computation</p>",
        "id": 409237815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703095807
    },
    {
        "content": "<p>right, I expect the native code for that to be slow too</p>",
        "id": 409237853,
        "sender_full_name": "David Renshaw",
        "timestamp": 1703095830
    },
    {
        "content": "<p>well it's not that hard to find examples where <code>#eval</code> is slower than compiled C code, this is the normal case. But maybe you mean asymptotically?</p>",
        "id": 409238128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703095940
    },
    {
        "content": "<p>yeah, like how <code>Nat.digits</code> takes O(n^2) time with <code>#reduce</code>, but <code>O(log(n))</code> time with <code>#eval</code>.</p>",
        "id": 409238325,
        "sender_full_name": "David Renshaw",
        "timestamp": 1703096020
    },
    {
        "content": "<p>I do remember seeing that <code>fib</code> example in TPIL4: <a href=\"https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html#structural-recursion-and-induction\">https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html#structural-recursion-and-induction</a></p>",
        "id": 409238417,
        "sender_full_name": "David Renshaw",
        "timestamp": 1703096051
    },
    {
        "content": "<p>do get a difference there it would have to be a low level optimization. The interpreter is supposed to have the same general performance profile as the compiler, but the compiler also involves some additional optimization passes (some in lean, some in clang/LLVM) and some of them change the asymptotic behavior of the code</p>",
        "id": 409238525,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703096116
    },
    {
        "content": "<blockquote>\n<p>The interpreter is supposed to have the same general performance profile as the compiler</p>\n</blockquote>\n<p>Cool, then I think the diagrams in my video still make sense, even if as a minor oversimplification. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 409238922,
        "sender_full_name": "David Renshaw",
        "timestamp": 1703096291
    },
    {
        "content": "<p>Yes, absolutely! I didn’t mean to say that it’s wrong in any serious sense.</p>",
        "id": 409239377,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1703096515
    },
    {
        "content": "<p>Here's an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">UInt64</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">UInt64</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"bp\">==</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">b</span> <span class=\"k\">else</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">foo</span> <span class=\"mi\">10000000</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">main</span> <span class=\"o\">(</span><span class=\"n\">args</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span><span class=\"o\">):</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"bp\">←</span> <span class=\"n\">IO.getNumHeartbeats</span>\n  <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">args.getD</span> <span class=\"mi\">0</span> <span class=\"s2\">\"10000000\"</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">toNat</span><span class=\"bp\">!</span>\n  <span class=\"n\">println</span><span class=\"bp\">!</span> <span class=\"n\">foo</span> <span class=\"n\">n.toUInt64</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>I was able to confirm by disassembling the binary that <code>foo</code> is compiled to a nonrecursive function, <code>def foo i b := i + b</code>, but lean misses this optimization so <code>#eval</code> is linear time while <code>lake exe test NNN</code> is constant time</p>",
        "id": 409240032,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703096841
    },
    {
        "content": "<p>nice</p>",
        "id": 409240069,
        "sender_full_name": "David Renshaw",
        "timestamp": 1703096863
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243791\">@David Renshaw</span> Thanks a lot for making that video! Very instructive <em>and</em> entertaining!</p>",
        "id": 409525883,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1703224178
    },
    {
        "content": "<p>Yes, well done <span class=\"user-mention\" data-user-id=\"243791\">@David Renshaw</span></p>",
        "id": 409530673,
        "sender_full_name": "Newell Jensen",
        "timestamp": 1703226918
    },
    {
        "content": "<p>What I'm curious about now is: how do other dependently-typed languages, like Coq and Agda, handle this kind of situation? Do they support well-founded recursion interacting with definitional equality any better than Lean currently does?</p>",
        "id": 409654711,
        "sender_full_name": "David Renshaw",
        "timestamp": 1703287729
    },
    {
        "content": "<p>I think they don't really have well founded recursion in lean's sense</p>",
        "id": 409654875,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703287836
    },
    {
        "content": "<p>These languages have decidable type-checking, right? So they should just be able to unfold an <code>Acc.rec</code> application eagerly, without having to unfold it into <code>(Acc.intro ...).rec</code>?</p>",
        "id": 409654903,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703287867
    },
    {
        "content": "<p>Coq at least is much more careful to use \"binary nats\" (i.e. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Num#doc\">docs#Num</a>) for kernel computation, which is to say that they don't handle it any better and the libraries worked around it</p>",
        "id": 409655001,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703287936
    },
    {
        "content": "<p>that said, Coq's kernel is much better than lean's for doing heavy reduction</p>",
        "id": 409655061,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703287998
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> I don't understand what you mean by that, or what that has to do with decidable typechecking</p>",
        "id": 409655262,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703288118
    },
    {
        "content": "<p>I think the short answer is that <code>Acc</code> would not be in Prop in Coq/Agda</p>",
        "id": 409655295,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703288144
    },
    {
        "content": "<p>so you would still be reducing it to <code>Acc.intro</code> but it wouldn't be a \"proof\" you are reducing</p>",
        "id": 409655380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703288176
    },
    {
        "content": "<p>... so I suppose one would be less justified in trying to implement of the kinds of optimizations discussed above (swap in a different value for the <code>Acc</code>)</p>",
        "id": 409655445,
        "sender_full_name": "David Renshaw",
        "timestamp": 1703288237
    },
    {
        "content": "<p>yes, that wouldn't work for acc-in-type</p>",
        "id": 409655458,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703288256
    },
    {
        "content": "<p>well it might hold up to propositional equality</p>",
        "id": 409655478,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703288274
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/whnf.20blowup.20in.20Nat.2Edigits/near/409655262\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> I don't understand what you mean by that, or what that has to do with decidable typechecking</p>\n</blockquote>\n<p>my understanding of this issue is that even though <code>Acc.rec</code> doesn't actually \"need\" to be reduced to <code>(Acc.intro ...).rec</code> in order to be unfolded (because there is no data, just a proposition is true), Lean's kernel does so because (a) it needs to do it for all other types, and (b) it causes issues with decidability in type-checking if this short-circuiting is done. However, I assumed as these other languages have decidable type-checking, they'd be justified in taking this shortcut; I guess your argument about turing machines from your thesis then works verbatim to make their type-checking uncomputable, however</p>",
        "id": 409655571,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703288337
    },
    {
        "content": "<blockquote>\n<p>However, I assumed as these other languages have decidable type-checking, they'd be justified in taking this shortcut</p>\n</blockquote>\n<p>They have decidable type-checking because they <em>do not</em> take the shortcut</p>",
        "id": 409655626,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703288398
    },
    {
        "content": "<p>(Lean also doesn't take the shortcut but that makes lean's typechecker not complete. But the theory allows it to do so)</p>",
        "id": 409655728,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703288459
    },
    {
        "content": "<blockquote>\n<p>even though <code>Acc.rec</code> doesn't actually \"need\" to be reduced to <code>(Acc.intro ...).rec</code> in order to be unfolded (because there is no data, just a proposition is true), Lean's kernel does so because (a) it needs to do it for all other types, and (b) it causes issues with decidability in type-checking if this short-circuiting is done.</p>\n</blockquote>\n<p>It's also not quite as simple as this, you need the <code>Acc.intro</code> term because it has the data you need to continue the computation (the arguments to the <code>Acc.intro</code> are remixed with the arguments to <code>Acc.rec</code> in the iota rule)</p>",
        "id": 409655874,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703288595
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">test.</span><span class=\"o\">{</span><span class=\"n\">u1</span><span class=\"o\">,</span> <span class=\"n\">u2</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u2</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u1</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">Acc</span> <span class=\"n\">r</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">Acc</span> <span class=\"n\">r</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Acc.intro</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"n\">a</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>this rule being something like this (I was struggling to make the general version typecheck, so I stole this from <code>Acc.ndrec</code>), right? ohh, do you need <code>a</code>?</p>",
        "id": 409657604,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703289758
    },
    {
        "content": "<p>wait no, <code>a</code> should be there already. the underscore is still something I don't understand</p>",
        "id": 409657708,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703289807
    },
    {
        "content": "<p>you need <code>h</code></p>",
        "id": 409658013,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703290004
    },
    {
        "content": "<p>the underscore is another <code>Acc.rec</code> application</p>",
        "id": 409658054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703290034
    },
    {
        "content": "<p>but <code>h</code> is a prop; can't we do some magic and say it exists because we have the term of <code>Acc</code>? proofs are irrelevant anyways</p>",
        "id": 409658183,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703290105
    },
    {
        "content": "<p>yes, that's <code>Acc.inv</code></p>",
        "id": 409658200,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703290118
    },
    {
        "content": "<p>well, it's not magic, it's an explicit term</p>",
        "id": 409658209,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703290129
    },
    {
        "content": "<p>you need to actually put something there and if you put something bigger than what you started with then things can get out of hand</p>",
        "id": 409658246,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703290154
    },
    {
        "content": "<p>right, I see! I think I fully understand the situation and why this kernel-rewrite rule is needed. Is anything similar done anywhere else in the kernel?</p>",
        "id": 409658376,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703290213
    },
    {
        "content": "<p>this is just the regular iota rule for inductives</p>",
        "id": 409658399,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703290235
    },
    {
        "content": "<p>it's just weird in this case because you don't actually have to use it, there are additional defeq side channels in Prop</p>",
        "id": 409658447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703290267
    },
    {
        "content": "<p>the kernel doesn't really do anything special here, and that's kind of the problem</p>",
        "id": 409658517,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703290311
    },
    {
        "content": "<p>no I mean I understood your proposed solution now, I was wondering if there's precedent for such solutions</p>",
        "id": 409658626,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703290359
    },
    {
        "content": "<p>Well eta for structures is kind of similar?</p>",
        "id": 409658900,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703290488
    },
    {
        "content": "<p>when faced with <code>T.casesOn t f</code> you reduce it to <code>f t.1 t.2 t.3</code> instead of first computing <code>t</code> to a constructor (or rather, trying this if you get stuck computing <code>t</code>)</p>",
        "id": 409659088,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703290577
    },
    {
        "content": "<p>Could the kernel for all values of sort <code>Prop</code> drop the actual terms, just keeping their types (and maybe the set of free variables) around? Together with an eta rule like above for, Acc reduction would not lead to large terms, I assume, as the h.inv term work be erased like this. But what would break?</p>",
        "id": 409702610,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1703324323
    },
    {
        "content": "<p>You can't reduce that, obviously, so anything that reduces proofs won't work anymore</p>",
        "id": 409743663,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703360217
    },
    {
        "content": "<p>Apparently Coq does essentially this, they eagerly replace checked proof terms with a proof irrelevance marker to avoid having to re-typecheck it</p>",
        "id": 409743753,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703360296
    },
    {
        "content": "<p>When do you have to reduce a (already type checked) proof?</p>",
        "id": 409749646,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1703365886
    },
    {
        "content": "<p>In this case, to turn an <code>Acc.rec</code> call into an <code>(Acc.intro _).rec</code> call, so that the iota rule can then apply to reduce the <code>rec</code></p>",
        "id": 409749739,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703365967
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/287929-mathlib4/topic/whnf.20blowup.20in.20Nat.2Edigits/near/409749646\">said</a>:</p>\n<blockquote>\n<p>When do you have to reduce a (already type checked) proof?</p>\n</blockquote>\n<p>In the situations that have come up here: when it's an inductive type and you need to head normalize it</p>",
        "id": 409749867,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703366096
    },
    {
        "content": "<p>What happens if you consider “proof erased” the normal form?</p>",
        "id": 409754082,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1703370352
    },
    {
        "content": "<p>then terms become stuck</p>",
        "id": 409754369,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703370556
    },
    {
        "content": "<p>If you have a recursor with a stuck term in the major premise then it will also be stuck</p>",
        "id": 409754391,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703370588
    },
    {
        "content": "<p>which is why it is specifically large eliminating props which cause problems since they have recursors that produce values which we want to reduce</p>",
        "id": 409754478,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703370650
    },
    {
        "content": "<p>I guess it's these large eliminating props that confuse me. They are eliminating into Type, so the kernel has to reduce them for type checking, but they are not eliminating into, say, Nat, so the compiler can have proof irrelevance, is that right?</p>\n<p>But I'm still a bit confused how eliminating props into anything but prop goes together with proof irrelevance. What would be an example where a prop needs to be eliminated and it's value matters?</p>",
        "id": 409793742,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1703403312
    },
    {
        "content": "<p>No, by eliminating into Type I mean the <code>motive</code> argument has a type like <code>motive : T -&gt; Sort u</code> and if you take <code>motive := fun _ =&gt; Nat</code> then the recursor is being used to produce a <code>Nat</code></p>",
        "id": 409795911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703405552
    },
    {
        "content": "<p>So you are doing recursion on proofs to produce a value in <code>Nat</code></p>",
        "id": 409795945,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703405583
    },
    {
        "content": "<p>The rules for large eliminating props are essentially to restrict to cases where the value \"doesn't matter\", and while it is true in some sense - you can reconstruct the arguments from the type in other ways - this is only true up to equality, it does not follow the reduction itself. It's like adding a simp lemma pointed the wrong direction, while it's still a true statement you might have broken other properties of the reduction system like confluence or termination. And without that, what even is the point of using definitional equality in the first place? Just make it an extensional type theory already</p>",
        "id": 409796176,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703405811
    },
    {
        "content": "<blockquote>\n<p>Just make it an extensional type theory already</p>\n</blockquote>\n<p>I guess my thinking is still very much extensionally influenced :-)</p>",
        "id": 409804264,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1703413473
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/287929-mathlib4/topic/whnf.20blowup.20in.20Nat.2Edigits/near/409754082\">said</a>:</p>\n<blockquote>\n<p>What happens if you consider “proof erased” the normal form?</p>\n</blockquote>\n<p>Then consider a context with a variable <code>t : False</code> you could then prove any wellfoundedness claims, and since the proof is erased the typechecker would wrongly assume that it is actually wellfounded and fall into a loop</p>",
        "id": 409804298,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1703413518
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/287929-mathlib4/topic/whnf.20blowup.20in.20Nat.2Edigits/near/409795911\">said</a>:</p>\n<blockquote>\n<p>No, by eliminating into Type I mean the <code>motive</code> argument has a type like <code>motive : T -&gt; Sort u</code> and if you take <code>motive := fun _ =&gt; Nat</code> then the recursor is being used to produce a <code>Nat</code></p>\n</blockquote>\n<p>Ah, but not <em>every</em> prop’s <code>.rec</code> allows such motives, but only those with a single constructor maybe?</p>\n<p>Ok, the answer is in “2.6.2 Large elimination” in Mario’s thesis. I should read more and ask less :-)</p>",
        "id": 409804313,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1703413545
    },
    {
        "content": "<p>If wellfoundedness is a <code>Set</code> instead there would be no problem because the reducer waits until the constructor is revealed before reducing, and if the proof came from a <code>False</code> then it would be forever stuck and no constructor will be revealed</p>",
        "id": 409804399,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1703413619
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"404479\">Trebor Huang</span> <a href=\"#narrow/stream/287929-mathlib4/topic/whnf.20blowup.20in.20Nat.2Edigits/near/409804298\">said</a>:</p>\n<blockquote>\n<p>Then consider a context with a variable <code>t : False</code> you could then prove any wellfoundedness claims, and since the proof is erased the typechecker would wrongly assume that it is actually wellfounded and fall into a loop</p>\n</blockquote>\n<p>Yes, agreed, but that’s also true for some of the other alternatives discussed in this thread, like a special reduction rule for <code>Acc</code> or <code>WellFounded</code>.</p>\n<p>I guess I am wondering what <em>else</em> breaks :-)</p>",
        "id": 409804403,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1703413623
    },
    {
        "content": "<p>I think the only three essential case for Prop eliminating into other things are the <code>True</code> type (which is harmless), the <code>Acc</code> type, and the <code>Eq</code> type (which iirc is also harmless if we embrace axiom K).</p>",
        "id": 409804666,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1703413905
    },
    {
        "content": "<p>So the reason to keep around proofs terms for proofs of these types (rather than just their type and maybe set of free variables) is termination of open terms and (somehow) confluence. Is that a reasonable summary?</p>",
        "id": 409804855,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1703414090
    },
    {
        "content": "<p>A disparate example, but I think this is again related to WF reduction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"mi\">3</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"n\">le_rfl</span><span class=\"o\">⟩</span>\n  <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"mi\">3</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">10000</span><span class=\"bp\">-</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">⟩</span>\n  <span class=\"k\">let</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"mi\">3</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">67123817236182736182731628371623871623871263817263817236187236182</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">⟩</span>\n\n\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Nat.find</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"c1\">--have : Nat.find b = 3 := rfl -- uncomment to get a max recursion depth crash</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Nat.find</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I thought <code>Nat.find</code> was more immune, as it always goes up \"one step at a time\". But I guess not</p>",
        "id": 411399437,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704473306
    },
    {
        "content": "<p>(the size of the number isn't what matters, but the proof term size generated - a raw literal of an enormous size will generate a working example!)</p>",
        "id": 411399471,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704473331
    },
    {
        "content": "<p>also, it's quite unintuitive that if you use <code>have</code> on the Prop, the reduction gets stuck.</p>",
        "id": 411399669,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704473413
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> , do you have a core issue in mind you'd like to open or should I try draft one? You'll be far more knowledgeable about what exactly to write.</p>",
        "id": 411400008,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704473561
    },
    {
        "content": "<p>I think it's not that useful to be pursuing kernel performance issues at this time. There are some ideas for speeding up the kernel but they will basically involve rewriting the algorithm. It's not the sort of thing which I think can be addressed by a quick patch</p>",
        "id": 411400369,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704473700
    },
    {
        "content": "<p>should we at least open the issue to say that there is interest in this?</p>",
        "id": 411400660,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704473823
    },
    {
        "content": "<p>Even if kernel reduction is not going to change, I'm interested in better understanding it, so that I know how to work around these issues when they come up.</p>",
        "id": 411400790,
        "sender_full_name": "David Renshaw",
        "timestamp": 1704473867
    },
    {
        "content": "<p>The issue in this example is the same as before: <code>Nat.find</code> is defined by well founded recursion, and unlike other examples it really has to be, it's not possible to define <code>Nat.find</code> without Acc-in-prop</p>",
        "id": 411400962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704473930
    },
    {
        "content": "<p>I imagined as much :/</p>",
        "id": 411401047,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704473959
    },
    {
        "content": "<p>the only thing that actually decreases here is the proof term</p>",
        "id": 411401225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704474008
    },
    {
        "content": "<p>There is a workaround though if you really want to pursue this style of proof, which is to write proofs that compute well</p>",
        "id": 411401358,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704474050
    },
    {
        "content": "<p>in fact there are a few of these in the WF.lean file itself</p>",
        "id": 411401401,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704474064
    },
    {
        "content": "<p>But then why does this work?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"mi\">3</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">10000</span><span class=\"bp\">-</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- works</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Nat.find</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 411401505,
        "sender_full_name": "David Renshaw",
        "timestamp": 1704474098
    },
    {
        "content": "<p>does it work as a <code>def</code>?</p>",
        "id": 411401651,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704474137
    },
    {
        "content": "<p>works with either <code>def</code> or <code>abbrev</code></p>",
        "id": 411401721,
        "sender_full_name": "David Renshaw",
        "timestamp": 1704474164
    },
    {
        "content": "<p>seems likely that the difference in that example has to do with kernel reducibility in some way</p>",
        "id": 411401757,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704474175
    },
    {
        "content": "<p>you should try running it through your kernel reduction viewer to find out</p>",
        "id": 411401842,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704474204
    },
    {
        "content": "<p>this works too</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"mi\">3</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">10000</span><span class=\"bp\">-</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">⟩</span><span class=\"bp\">;</span> <span class=\"n\">Nat.find</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 411401882,
        "sender_full_name": "David Renshaw",
        "timestamp": 1704474220
    },
    {
        "content": "<p>right, the reason I was pulling it into a def was to try to run it through the kernel reduction visualizer</p>",
        "id": 411402067,
        "sender_full_name": "David Renshaw",
        "timestamp": 1704474285
    },
    {
        "content": "<p>Oh, it might also not be a kernel issue but an elaborator issue, since the original example involved an unfinished definition</p>",
        "id": 411402190,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704474345
    },
    {
        "content": "<p>replacing <code>: False</code> with <code>: True</code> and appending <code>trivial</code> doesn't do much</p>",
        "id": 411402425,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704474433
    },
    {
        "content": "<p>welp, when I try to grab a kernel reduction trace, I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Messages</span> <span class=\"n\">here</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"mi\">6</span><span class=\"o\">:</span><span class=\"mi\">20</span><span class=\"o\">:</span>\n<span class=\"n\">unknown</span> <span class=\"n\">identifier</span> <span class=\"bp\">'</span><span class=\"n\">Nb'</span>\n<span class=\"mi\">6</span><span class=\"o\">:</span><span class=\"mi\">0</span><span class=\"o\">:</span>\n<span class=\"n\">unknown</span> <span class=\"n\">metavariable</span> <span class=\"bp\">'?</span><span class=\"n\">_uniq.2866'</span>\n</code></pre></div>\n<p>Probably a bug in my code.<br>\nEDIT: actually, restarting the Lean server made this go away.</p>",
        "id": 411402434,
        "sender_full_name": "David Renshaw",
        "timestamp": 1704474439
    },
    {
        "content": "<p>I'm interested in understanding the (possible) elaborator issue too.</p>",
        "id": 411402597,
        "sender_full_name": "David Renshaw",
        "timestamp": 1704474502
    },
    {
        "content": "<p>probably a missing <code>withSynthesize</code> in the term elaboration before sending to the kernel</p>",
        "id": 411402671,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704474541
    },
    {
        "content": "<p>The elaborator has a bit more logging, but whnf in particular is not logged as much as you would want</p>",
        "id": 411402850,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704474609
    },
    {
        "content": "<p>I have a <code>#whnf_seq</code> command from a long time ago that does something similar to your reduction viewer for <code>WHNF.lean</code>, but it needs an update and I'm sure you can do better with your version</p>",
        "id": 411402989,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704474670
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243791\">David Renshaw</span> <a href=\"#narrow/stream/287929-mathlib4/topic/whnf.20blowup.20in.20Nat.2Edigits/near/411401882\">said</a>:</p>\n<blockquote>\n<p>this works too</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"mi\">3</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">10000</span><span class=\"bp\">-</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">⟩</span><span class=\"bp\">;</span> <span class=\"n\">Nat.find</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>this actually seems to be something - it seems to be a coincidence, and you can make it time out by setting <code>3 = 500</code>, for example, but that's enough to make the <code>le_rfl</code> example time out too.</p>",
        "id": 411403218,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704474776
    },
    {
        "content": "<p>(however, this doesn't fix my actual example, so I think this is just some sort of confluence of coincidences)</p>",
        "id": 411403732,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704474967
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"mi\">3</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">10000</span><span class=\"bp\">-</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">⟩</span>\n\n  <span class=\"c1\">-- works</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Nat.find</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n\n  <span class=\"c1\">-- maximum recursion depth has been reached</span>\n  <span class=\"c1\">--have : Nat.find b = 3 := rfl</span>\n\n  <span class=\"n\">exact</span> <span class=\"n\">True.intro</span>\n</code></pre></div>",
        "id": 411409455,
        "sender_full_name": "David Renshaw",
        "timestamp": 1704477593
    },
    {
        "content": "<p><code>by rfl</code> works, but <code>rfl</code> does not</p>",
        "id": 411409528,
        "sender_full_name": "David Renshaw",
        "timestamp": 1704477604
    },
    {
        "content": "<p>One idea for dealing with <code>Nat.digits</code>: we could make it an <code>irreducible_def</code>. That seems to enable <code>simp_arith</code> to successfully handle <code>Nat.digits</code> in many cases: <a href=\"https://github.com/leanprover-community/mathlib4/pull/10414\">#10414</a></p>",
        "id": 420843289,
        "sender_full_name": "David Renshaw",
        "timestamp": 1707609956
    },
    {
        "content": "<p>A less invasive alternative: adding a <code>simp_digits</code> macro: <a href=\"https://github.com/leanprover-community/mathlib4/pull/10428\">#10428</a></p>",
        "id": 420900014,
        "sender_full_name": "David Renshaw",
        "timestamp": 1707666681
    },
    {
        "content": "<p>But maybe we don't need a new tactic at all, because <code>norm_num</code> works well on <code>Nat.digits</code> now: <a href=\"https://github.com/leanprover-community/mathlib4/pull/10429\">#10429</a></p>",
        "id": 420904777,
        "sender_full_name": "David Renshaw",
        "timestamp": 1707670376
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> I noticed that <a href=\"https://github.com/leanprover/lean4/pull/4061\">lean4#4061</a> looks potentially relevant to this issue, but also that the \"recursion limit\" error <a href=\"https://live.lean-lang.org/#url=https%3A%2F%2Fgist.githubusercontent.com%2Fdwrensha%2F8d9059eaa6f1838308b5527db3a9e434%2Fraw%2Fcd774eccba86b909f613842010266372b0b3b112%2Fdigits.lean\">still happens on the latest Lean</a>. Is that expected?</p>",
        "id": 448413201,
        "sender_full_name": "David Renshaw",
        "timestamp": 1719860343
    },
    {
        "content": "<p>Could it be that that <code>#reduce</code>, well, reduces, even if things are marked as <code>irreducible</code>? </p>\n<p>Note that</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">decimalDigits</span><span class=\"w\"> </span><span class=\"mi\">1234</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>now fails,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">unseal</span><span class=\"w\"> </span><span class=\"n\">decimalDigits</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">decimalDigits</span><span class=\"w\"> </span><span class=\"mi\">1234</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>has recursion error and </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">decimalDigits</span><span class=\"w\"> </span><span class=\"mi\">1234</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">decimalDigits</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>works.</p>",
        "id": 448418485,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1719861835
    }
]