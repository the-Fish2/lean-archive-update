[
    {
        "content": "<p>I want to start a project where I have to prove multiple things that only hold due to the assumption that my types are finite. I've browsed through some of the common introductory references to Mathlib with not much success: they cover a lot of ground in many areas but finiteness is usually not covered or just glanced over. Any sources you recommend as a general introduction to this subject?</p>\n<p>To be more precise on the kind of things that I want to do through one concrete simple example (I am not asking for a solution to this particular example, just a source to see how these kinds of ideas are formalised): I want to prove that if I have <code>Fintype α</code> and <code>M : Type α</code> is an instance of <code>CompleteLattice M</code>, then an element <code>x : M</code> is join irreducible if and only if it is completely join-irreducible. An element <code>x</code> being join-irreducible means that if <code>x = a ⊔ b</code> then <code>x = a ∨ x = b</code>, whereas <code>x</code> being completely join irreducible means that if <code>T : Set M</code>, then <code>x = ⨆ T</code> is equivalent to <code>∃ t : T, t = x</code>. Of course, right to left is immediate by applying the property to sets of two elements. Left to right is also easily obtained by applying the property a finite amount of times, since <code>T</code> is finite. So you express the supremum as the join of an element and the complementary set and keep doing that task until you find the element <code>x</code> is equal to.</p>\n<p>Thanks!</p>",
        "id": 421299076,
        "sender_full_name": "David Méndez",
        "timestamp": 1707848077
    },
    {
        "content": "<p>Finiteness can be a difficult area of mathlib to get used to. There are multiple ways to express finiteness:</p>\n<ul>\n<li>Do you have a type that you want to say is finite? Prefer <code>Finite α</code>. It's a proposition that there exists some (unknown) bijection between <code>α</code> and a <code>Fin n</code> for some <code>n</code>.</li>\n<li>Do you have a <code>Set</code> that's finite? Consider the predicate <code>Set.Finite s</code> (also written <code>s.Finite</code>). It's <code>Finite</code> but for sets.</li>\n<li>Do you want to <em>compute</em> in the programming sense with a finite type? Then there's <code>Fintype α</code>, which contains an enumeration of all the elements of <code>α</code>. This adds two complexities: (1) you often need <code>DecidableEq</code> instances for various constructions, and (2) both <code>Fintype</code> and <code>DecidableEq</code> are not propositions, which can make rewrites more difficult (but tactics like <code>convert</code> can help).</li>\n<li>Do you want to <em>compute</em> with your finite sets? Then there's the type <code>Finset α</code> of all finite sets of <code>α</code>. It's like the <code>Fintype</code> version of <code>Set.Finite</code>, but packaged up into a type of finite sets. It has similar complexities as <code>Fintype</code>.</li>\n</ul>\n<p>Sometimes you end up needing to use one or the other depending on what theory is available already in mathlib. For example, there is a lot about finite sums in terms of sums over a <code>Finset</code> (or the universe <code>Finset</code> of a <code>Fintype</code>), so that sort of forces you into the world of <code>Finset</code> and <code>Fintype</code>, though there are some alternatives.</p>\n<p>In your example, I probably would start with <code>Finite α</code>. The API of <code>Finite</code> allows you to \"construct\" a <code>Fintype α</code> as needed inside of proofs, if for some reason you ever need it.</p>\n<p>There are induction principles for <code>Finite</code> and <code>Set.Finite</code> such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finite.induction_empty_option#doc\">docs#Finite.induction_empty_option</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite.induction_on#doc\">docs#Set.Finite.induction_on</a> (the latter sounds like what you might use).</p>",
        "id": 421301315,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707848935
    },
    {
        "content": "<p>Sometimes <code>Fintype</code>/<code>Finset</code> is useful in proofs. The <code>fin_cases</code> tactic can, for concrete finite types/sets, evaluate the underlying enumeration of elements to generate new goals.</p>",
        "id": 421302153,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707849219
    },
    {
        "content": "<p>Here is a way to formulate your lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">SemilatticeSup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">⊔</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hne</span> <span class=\"o\">:</span> <span class=\"n\">s.Nonempty</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">s.sup'</span> <span class=\"n\">hne</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n  <span class=\"c1\">-- Use `Finset.Nonempty.cons_induction` to prove it by induction</span>\n</code></pre></div>",
        "id": 421307005,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707850853
    },
    {
        "content": "<p>This way you don't need to assume that <code>M</code> itself is finite.</p>",
        "id": 421307224,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707850925
    },
    {
        "content": "<p>Also, as it often happens in translation from informal to formal, the original statement is incorrect for <code>T = ∅</code>, <code>x = ⊥</code>.</p>",
        "id": 421307495,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707851017
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"663127\">David Méndez</span> has marked this topic as resolved.</p>",
        "id": 421491249,
        "sender_full_name": "Notification Bot",
        "timestamp": 1707930314
    }
]