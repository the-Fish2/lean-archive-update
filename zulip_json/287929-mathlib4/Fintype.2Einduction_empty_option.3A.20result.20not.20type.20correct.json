[
    {
        "content": "<p>I am trying to figure out how to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.induction_empty_option#doc\">docs#Fintype.induction_empty_option</a> to help <span class=\"user-mention\" data-user-id=\"417654\">@Martin Dvořák</span> , and found a weird behavior from this induction principle. MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Option</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.BigOperators.Basic</span>\n\n<span class=\"c1\">-- set_option pp.all true in</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">application type mismatch</span>\n<span class=\"cm\">  Finset.univ</span>\n<span class=\"cm\">argument has type</span>\n<span class=\"cm\">  Fintype I</span>\n<span class=\"cm\">but function has type</span>\n<span class=\"cm\">  [inst : Fintype x✝¹] → Finset x✝¹</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"n\">W</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">W</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">Finset.univ.sum</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">revert</span> <span class=\"n\">b</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Fintype.induction_empty_option</span> <span class=\"gr\">sorry</span> <span class=\"gr\">sorry</span> <span class=\"gr\">sorry</span> <span class=\"n\">I</span>\n</code></pre></div>\n<p>What's the right way to invoke this induction principle?</p>",
        "id": 439879626,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1716316984
    },
    {
        "content": "<p>Specifically, in the point of use (still somewhat minimized), I get a weird <code>Finset.univ = Finset.univ</code> goal, where the underlying <code>Fintype</code> instances are different, the LHS is still the uninducted initial Fintype.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Option</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.Matrix.DotProduct</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.Matrix.ToLin</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">I</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">generalizedFarkasBartl</span> <span class=\"o\">{</span><span class=\"n\">W</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">→</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">W</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">Finset.univ.sum</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">revert</span> <span class=\"n\">A</span> <span class=\"n\">b</span>\n  <span class=\"n\">refine</span> <span class=\"n\">Fintype.induction_empty_option</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"n\">I</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">K</span> <span class=\"n\">J</span> <span class=\"n\">_</span> <span class=\"n\">e</span> <span class=\"n\">hI</span> <span class=\"n\">A</span> <span class=\"n\">b</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">hI</span> <span class=\"o\">((</span><span class=\"bp\">·</span> <span class=\"bp\">∘</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">b</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hI</span> <span class=\"k\">with</span> <span class=\"c1\">-- other tactics: `tactic 'generalize' failed, result is not type correct`</span>\n    <span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"n\">U</span> <span class=\"n\">hU</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">U</span> <span class=\"bp\">∘</span> <span class=\"n\">e.symm</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">w</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hU</span> <span class=\"n\">w</span><span class=\"o\">]</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.ofEquiv</span> <span class=\"n\">J</span> <span class=\"n\">e.symm</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.coe_comp</span><span class=\"o\">,</span> <span class=\"n\">Function.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.funLeft_apply</span><span class=\"o\">]</span>\n      <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">e.symm.bijective.sum_comp</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">U</span> <span class=\"n\">x</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n      <span class=\"bp\">·</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- Finset.univ = Finset.univ</span>\n      <span class=\"bp\">·</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- Finset.univ = Finset.univ</span>\n  <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 439879905,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1716317074
    },
    {
        "content": "<p>This seems to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Option</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.BigOperators.Basic</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"c1\">-- identical, except `h_fintype` is explicit</span>\n<span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">induction_empty_option'</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">],</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">of_equiv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">P</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Fintype.ofEquiv</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"n\">e.symm</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">@</span><span class=\"n\">P</span> <span class=\"n\">β</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›)</span>\n    <span class=\"o\">(</span><span class=\"n\">h_empty</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">PEmpty</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_option</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">],</span> <span class=\"n\">P</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">Fintype.induction_empty_option</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"n\">of_equiv</span> <span class=\"n\">h_empty</span> <span class=\"n\">h_option</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"n\">W</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">W</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">Finset.univ.sum</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"o\">‹</span><span class=\"n\">Fintype</span> <span class=\"n\">I</span><span class=\"o\">›</span> <span class=\"n\">using</span> <span class=\"n\">induction_empty_option'</span>\n  <span class=\"gr\">sorry</span>\n  <span class=\"gr\">sorry</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 439911711,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1716327927
    },
    {
        "content": "<p>Though this is definitely a bug in the induction tactic (edit: <a href=\"https://github.com/leanprover/lean4/pull/4246\">lean4#4246</a>)</p>",
        "id": 439911782,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1716327959
    },
    {
        "content": "<p>This then works as expected:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">generalizedFarkasBartl</span> <span class=\"o\">{</span><span class=\"n\">W</span> <span class=\"n\">V</span> <span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">I</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">→</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">W</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">Finset.univ.sum</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"o\">‹</span><span class=\"n\">Fintype</span> <span class=\"n\">I</span><span class=\"o\">›</span> <span class=\"n\">using</span> <span class=\"n\">induction_empty_option'</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">of_equiv</span> <span class=\"n\">K</span> <span class=\"n\">J</span> <span class=\"n\">e</span> <span class=\"n\">hI</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">hU</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hI</span> <span class=\"o\">((</span><span class=\"bp\">·</span> <span class=\"bp\">∘</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">U</span> <span class=\"bp\">∘</span> <span class=\"n\">e.symm</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">w</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hU</span> <span class=\"n\">w</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.coe_comp</span><span class=\"o\">,</span> <span class=\"n\">Function.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.funLeft_apply</span><span class=\"o\">]</span>\n    <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">e.symm.bijective.sum_comp</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">U</span> <span class=\"n\">x</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"bp\">|</span> <span class=\"n\">h_empty</span><span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">|</span> <span class=\"n\">h_option</span> <span class=\"n\">α</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 439912506,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1716328246
    }
]