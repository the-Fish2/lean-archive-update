[
    {
        "content": "<p>I'd like to make some changes to: <a href=\"https://tqft.net/mathlib4files/CategoryTheory/Adjunction/Mates\">file#CategoryTheory/Adjunction/Mates</a> </p>\n<p>Here \"mates\" refers to a bijection between natural transformations in certain (not-necessarily commutative squares) of functors involving a pair of adjunctions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">transferNatTrans</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">‚ãô</span><span class=\"w\"> </span><span class=\"n\">L‚ÇÇ</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">L‚ÇÅ</span><span class=\"w\"> </span><span class=\"bp\">‚ãô</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R‚ÇÅ</span><span class=\"w\"> </span><span class=\"bp\">‚ãô</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"bp\">‚ãô</span><span class=\"w\"> </span><span class=\"n\">R‚ÇÇ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I'd like to introduce simpler names \"RightMate\" and \"LeftMate\" to describe the <code>toFun</code> and <code>invFun</code> respectively. (I can also give these maps a simpler construction than appears in the current file, though <code>ext</code>, <code>unfold</code>, and <code>simp</code> can prove that these agree with the current functions.)</p>\n<p>The reason I care so much about the explicit functions is they satisfy various coherences (most fully expressed in the language of a natural isomorphism between double categories but useful at a more elementary level)  and I'm hoping that if these are tagged appropriately (I have no idea how <code>simp</code> works) Lean could prove automatically that various natural transformations defined using these operations iteratively are equal. </p>\n<p>I plan to apply this to the construction of Beck-Chevalley natural transformations between various composites of adjoint functors between the slices of a locally cartesian closed category. (Part of a project with <span class=\"user-mention\" data-user-id=\"420917\">@Sina H ìÉµ</span> and Steve Awodey on LCCC and polynomial functors.) Right now I'm stressing out about how exactly to implement the constructions of these natural transformations but with the above it should be easy to prove that all of the definitions are equal. </p>\n<p>I'm writing here because I could use some advice on:<br>\n(i) How to propose changes to a file upon which other files depend.<br>\n(ii) Whether it's reasonable to propose renaming (and if so, how to start this discussion).<br>\n(iii) Whether it's good practice (or acceptable) to give explicit names for auxiliary functions  (eg the toFun and invFun of an equivalence; or the induced map on the subtype of isos that exists under more restrictive hypothesis). <br>\n(iv) How to give Lean the info it needs to hopefully automate some 2-categorical diagram chasing.</p>",
        "id": 444263877,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1718205802
    },
    {
        "content": "<p>Not an expert in category theory, but some general remarks:<br>\nYou can suggest changes to any file by making a pull request to Mathlib. Instructions here: <a href=\"https://leanprover-community.github.io/contribute/index.html\">https://leanprover-community.github.io/contribute/index.html</a><br>\nYou already did the very first step, namely discussing what you want to do on Zulip.</p>\n<p>Files that are not used often yet regularly lack quite some polish, so improvements would be welcome in such cases (I don't know if that is true for <code>Mates</code>).</p>",
        "id": 444265118,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1718206065
    },
    {
        "content": "<p>About the specific points:<br>\n(i) in your pull request, you are responsible for fixing things in all later files that import the file you changed.<br>\n(ii) For renaming things, I would suggest a new name here on Zulip, and if a maintainer says that they also like the new names, you can generally go ahead. <br>\n(iii) Generally in Mathlib we like to not define too many auxiliary things. If you define <code>def myFun := myEquiv.toFun</code> then what is the proper way to write it? <code>myFun</code> or <code>myEquiv</code>? Should lemmas be stated using <code>myFun</code> or <code>myEquiv.</code>? We definitely don't want both lemmas. (Note: in many cases we have multiple ways of writing the same thing, and we try to use one spelling as \"the canonical one\")<br>\nSpecifically about an equivalence, you can already easily use the equivalence itself as a function, and by adding <code>.symm</code> you can use the reverse function (<code>symm</code> is preferred over <code>invFun</code>). Examples:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Logic</span><span class=\"bp\">.</span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">‚áë</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"c1\">-- type `Œ± ‚Üí Œ≤`, not too commonly used.</span>\n</code></pre></div>\n<p>(iv) This is harder. You can mark any lemmas as <code>@[simp]</code> that you want simp to automatically apply (and <code>aesop_cat</code> will also use that). But that will only get you so far...</p>",
        "id": 444267212,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1718206598
    },
    {
        "content": "<p>I think renaming things could be nice if we could make dot notation work. For example if you make a def with the name <code>Quiver.Hom.rightMate</code> then you could write <code>f.rightMate</code> for a natural transformation <code>f</code> of the right shape.</p>",
        "id": 444309548,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1718218789
    },
    {
        "content": "<p>Very happy to see renaming happening here: be bold on that front.</p>\n<p>Regarding Floris's point (iii) about avoiding having two ways to say the same thing: you don't need to completely avoid this, but ideally there will be an explicit choice of the preferred way to say things, <strong>and</strong> a simp lemma writing non-preferred ways into the preferred way.</p>",
        "id": 444352120,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1718236088
    },
    {
        "content": "<p>Regarding Floris' point (iv), particularly in the category theory library most of the automation comes down to <code>by ext; simp</code>. Thus it's important not only to mark the right simp lemmas, but whenever there is an extensionality result (i.e. \"you can prove this componentwise\") that it is marked with <code>@[ext]</code>.</p>\n<p>Generally my process is to take any statement that should be automatable, look at why <code>by ext; simp</code> fails, and try to add either <code>@[ext]</code> or <code>@[simp]</code> lemmas that would make further progress.</p>",
        "id": 444352201,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1718236197
    },
    {
        "content": "<p>Thanks for these tips. It's very useful for a beginner. </p>\n<p>I now have a draft pull request I'd love feedback on. I'm using simply <code>Mates</code> for the mates bijection, now that I've finally learned to extract the inverse functions.</p>\n<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> and <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> I would have loved to prove the left inverse and right inverse fields of the <code>Mates</code> definition without appealing to <code>ext</code> (passing to components). In my head it's true by a very simple calculation involving pasting diagrams of natural transformations (using theorems that exist in the library, though those, to be fair, are often proven with components). But to apply them I needed to rewrite along equalities between functors (also in the library) and got stuck. </p>\n<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> you'll see later I made heavy use of <code>slice_rhs</code>. I found I was basically randomly guessing which integers to use, I think because sometimes my composites were hidden under the application of a functor.</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/13840\">https://github.com/leanprover-community/mathlib4/pull/13840</a></p>",
        "id": 444774207,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1718393526
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/stream/287929-mathlib4/topic/mates/near/444774207\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> you'll see later I made heavy use of <code>slice_rhs</code>. I found I was basically randomly guessing which integers to use, I think because sometimes my composites were hidden under the application of a functor.</p>\n</blockquote>\n<p>In many situations, <code>slice_[lr]hs</code> can be replaced by rewrites using <code>lemma_assoc</code> instead of <code>lemma</code> and/or by making certain parameters explicit in the applications of these lemmas in case they may be applied in multiple places in the syntactic tree.</p>",
        "id": 444780947,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1718396023
    },
    {
        "content": "<p>I wrote the original version of this file, originally for motivation very similar to yours here: <a href=\"https://github.com/b-mehta/topos\">https://github.com/b-mehta/topos</a> (the todo list is a bit out of date, the repo contains a bit more than what it says it does!). Leaving some comments on your PR now, but I agree your construction is nicer, thanks!</p>",
        "id": 444782711,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1718396663
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/mates/near/444309548\">said</a>:</p>\n<blockquote>\n<p>I think renaming things could be nice if we could make dot notation work. For example if you make a def with the name <code>Quiver.Hom.rightMate</code> then you could write <code>f.rightMate</code> for a natural transformation <code>f</code> of the right shape.</p>\n</blockquote>\n<p>I could imagine this begin useful for adjoint transposition as well (an important special case of mates).</p>\n<p>Eg in a cartesian closed category for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>√ó</mo><mi>Y</mi><mo>‚Üí</mo><mi>Z</mi></mrow><annotation encoding=\"application/x-tex\">f : X \\times Y \\to Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">√ó</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span></span></span></span> we'd have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mi mathvariant=\"normal\">.</mi><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>y</mi><mo>:</mo><mi>X</mi><mo>‚Üí</mo><msup><mi>Z</mi><mi>Y</mi></msup></mrow><annotation encoding=\"application/x-tex\">f.curry : X \\to Z^Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">rry</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.22222em;\">Y</span></span></span></span></span></span></span></span></span></span></span> with <code>f.curry.uncurry = f</code>.</p>",
        "id": 444976268,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1718544366
    }
]