[
    {
        "content": "<p>The new leader in instructions is now <code>CategoryTheory.ComposableArrows</code> and the load seems to be mainly due to the proliferation of <code>by linarith</code> auto-params. </p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/9594\">#9594</a> uses a macro which tries <code>assumption</code> before <code>linarith</code> and decreases the time by about 15%. </p>\n<p>Is there more light-weight tactic for <code>Nat</code> inequalities?</p>",
        "id": 411992676,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704825968
    },
    {
        "content": "<p>This might be a great place to compare performance of <code>linarith</code> and <code>omega</code>?</p>",
        "id": 411993319,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704826242
    },
    {
        "content": "<p>Where does <code>omega</code> live?</p>",
        "id": 411993617,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704826360
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/std4/blob/main/Std/Tactic/Omega.lean\">https://github.com/leanprover/std4/blob/main/Std/Tactic/Omega.lean</a></p>",
        "id": 411993684,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704826393
    },
    {
        "content": "<p>Yes, in my work on showing that the nerve is a quasicategory, I used <code>omega</code> instead. It seems to work quite well.</p>",
        "id": 411993875,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1704826472
    },
    {
        "content": "<p>But I haven't yet tested the change in mathlib. Curious what will happen!</p>",
        "id": 411993942,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1704826507
    },
    {
        "content": "<p>Lots of errors and warnings. Let me make sure I am not doing something wrong</p>",
        "id": 411994139,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704826580
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">first</span> <span class=\"bp\">|</span> <span class=\"n\">assumption</span> <span class=\"bp\">|</span> <span class=\"n\">omega</span> <span class=\"bp\">|</span> <span class=\"n\">linarith</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>cuts things by 50-60%</p>",
        "id": 411994458,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704826709
    },
    {
        "content": "<p>Oh wait.</p>",
        "id": 411994566,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704826751
    },
    {
        "content": "<p>I hit a timeout which might have cut the testing short</p>",
        "id": 411994644,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704826785
    },
    {
        "content": "<p>No, cut by 50% after restoring the code generation in the file. Oddly I needed to bump heartbeats on a new declaration</p>",
        "id": 411995155,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704826973
    },
    {
        "content": "<p>Both the heartbeat bumps involve <code>aesop</code> as the auto-param, which then calls this auto-param multiple times</p>",
        "id": 411995659,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704827170
    },
    {
        "content": "<p>Is there anything which <code>omega</code> doesn't solve?</p>",
        "id": 411995673,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704827175
    },
    {
        "content": "<p>Strict inequality?</p>",
        "id": 411995706,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704827187
    },
    {
        "content": "<p>I got a lot of errors with just <code>omega</code> as the auto-param. A quick glance made it seem that those were the majority of the problems</p>",
        "id": 411995840,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704827248
    },
    {
        "content": "<p>Huh, I <a href=\"https://github.com/leanprover/std4/blob/294242ff8a1505124480a145c8a7d063359a720b/Std/Tactic/Omega.lean#L29\">thought strict inequalities were in scope</a>.</p>",
        "id": 411995987,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704827309
    },
    {
        "content": "<p>I pushed the changes to the PR. Feel free to play with it. There is a <code>docBlame</code> complaint about the macro that I cannot for the life of me fix. I must be doing something silly</p>",
        "id": 411995990,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704827309
    },
    {
        "content": "<p>About to hop on a plane, so only backseat driving from me today :)</p>",
        "id": 411996072,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704827349
    },
    {
        "content": "<p>Free wifi on Delta :)</p>",
        "id": 411996096,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704827362
    },
    {
        "content": "<p>Odds are nontrivial that I am doing something silly though</p>",
        "id": 411996252,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704827414
    },
    {
        "content": "<p><code>omega</code> doesn't like auto-params</p>",
        "id": 411997529,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704827979
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.Omega</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">omega</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">omega</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">error:</span>\n<span class=\"cm\">omega did not find a contradiction:</span>\n<span class=\"cm\">[1, -1] ∈ [1, ∞)</span>\n<span class=\"cm\">[0, 1] ∈ [0, ∞)</span>\n<span class=\"cm\">[1] ∈ [0, ∞)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 411998678,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704828425
    },
    {
        "content": "<p>Maybe this is <a href=\"https://github.com/leanprover/std4/pull/510\">std4#510</a> again</p>",
        "id": 412000251,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704829058
    },
    {
        "content": "<p>Do we have to do some special incantation to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.getLocalHyps#doc\">docs#Lean.Meta.getLocalHyps</a> in the presence of auto-params?</p>",
        "id": 412000261,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704829064
    },
    {
        "content": "<p>Yeah that looks correct</p>",
        "id": 412000295,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704829078
    },
    {
        "content": "<p>Huh. It seems like <a href=\"https://github.com/leanprover/std4/pull/510\">std4#510</a> doesn't fix this.</p>",
        "id": 412004990,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704831181
    },
    {
        "content": "<p>Aren't autoParams a different type as oppposed to just metadata?</p>",
        "id": 412007213,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704832105
    },
    {
        "content": "<p>It may need special support</p>",
        "id": 412007223,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704832111
    },
    {
        "content": "<p>Maybe. I was just pretending</p>",
        "id": 412007352,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704832184
    },
    {
        "content": "<p>This hacky thing makes the example work </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.Omega</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span> <span class=\"k\">in</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"clean_up\"</span>  <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">withMainContext</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">ctx</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.MonadLCtx.getLCtx</span>\n    <span class=\"n\">ctx.forM</span> <span class=\"k\">fun</span> <span class=\"n\">decl</span><span class=\"o\">:</span> <span class=\"n\">Lean.LocalDecl</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">declExpr</span> <span class=\"o\">:=</span> <span class=\"n\">decl.toExpr</span>\n      <span class=\"k\">let</span> <span class=\"n\">declType</span> <span class=\"o\">:=</span> <span class=\"n\">decl.type.cleanupAnnotations</span>\n      <span class=\"n\">liftMetaTactic</span> <span class=\"k\">fun</span> <span class=\"n\">mvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n        <span class=\"k\">let</span> <span class=\"n\">mvarIdNew</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.assert</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"n\">mkFreshId</span><span class=\"o\">)</span> <span class=\"n\">declType</span> <span class=\"n\">declExpr</span>\n        <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">mvarIdNew</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mvarIdNew.intro1P</span>\n        <span class=\"n\">return</span> <span class=\"o\">[</span><span class=\"n\">mvarIdNew</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">omega</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">clean_up</span>\n  <span class=\"n\">omega</span>\n</code></pre></div>",
        "id": 412012614,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704834566
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I guess...</p>",
        "id": 412012870,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1704834671
    },
    {
        "content": "<p>With a little bit of <code>omega</code> we are speeding up </p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>Benchmark<span class=\"w\">                                            </span>Metric<span class=\"w\">             </span><span class=\"nv\">Change</span>\n<span class=\"w\">  </span><span class=\"o\">==============================================================================</span>\n+<span class=\"w\"> </span>build<span class=\"w\">                                                </span>tactic<span class=\"w\"> </span>execution<span class=\"w\">    </span>-7.8%\n+<span class=\"w\"> </span>~Mathlib.Algebra.Homology.ExactSequence<span class=\"w\">              </span>instructions<span class=\"w\">       </span>-10.0%\n+<span class=\"w\"> </span>~Mathlib.CategoryTheory.Abelian.DiagramLemmas.Four<span class=\"w\">   </span>instructions<span class=\"w\">       </span>-69.8%\n+<span class=\"w\"> </span>~Mathlib.CategoryTheory.ComposableArrows<span class=\"w\">             </span>instructions<span class=\"w\">       </span>-46.3%\n</code></pre></div>",
        "id": 412012997,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704834724
    },
    {
        "content": "<p>Using the current fallback to <code>linarith</code> implementation</p>",
        "id": 412013044,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704834742
    },
    {
        "content": "<p>Wall clock is -3% also</p>",
        "id": 412013117,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704834789
    },
    {
        "content": "<p>I'm curious watching this thread: why would <code>omega</code> be faster than <code>linarith</code>?  Isn't it way more complicated?</p>",
        "id": 412013149,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704834808
    },
    {
        "content": "<p>All I know was that I was told to use <code>omega</code> so I wouldn't mind being enlightened also</p>",
        "id": 412013256,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704834861
    },
    {
        "content": "<p>But parts of the complications are put there to make it fast :-)</p>",
        "id": 412014022,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1704835222
    },
    {
        "content": "<p>I don’t want to sidetrack the conversation, but the reason why we don’t do:</p>\n<ul>\n<li>run linarith</li>\n<li>extract the necessary proof steps, use them directly</li>\n</ul>\n<p>is that the number of lines required for the proof would be large, right? Would there be some other way around this? E.g. use a companion-file to keep track of long proofs extracted from linarith for a given file? I see the problems with that approach as well, I’m just curious whether there are some thoughts on possible solutions for this?</p>",
        "id": 412014036,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1704835236
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/287929-mathlib4/topic/lots.20of.20linarith/near/412014022\">said</a>:</p>\n<blockquote>\n<p>But parts of the complications are put there to make it fast :-)</p>\n</blockquote>\n<p>Sure, but doesn't that imply that <code>linarith</code> could be sped up as well?</p>",
        "id": 412014173,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704835313
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/287929-mathlib4/topic/lots.20of.20linarith/near/412014022\">said</a>:</p>\n<blockquote>\n<p>But parts of the complications are put there to make it fast :-)</p>\n</blockquote>\n<p><a href=\"https://www.clevelandbrowns.com/news/breaking-down-myles-garrett-s-impressive-nfl-combine-workout-18615820#:~:text=Garrett%20clocked%20a%204.64%2Dsecond,foot%2D5%20and%20270%20pounds.&amp;text=So%20what%27s%20it%20all%20mean%3F\">Myles Garrett</a> driven design</p>",
        "id": 412014433,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704835420
    },
    {
        "content": "<p>If we moved <code>linarith</code> to <code>std</code>, would it also get way faster? :)</p>",
        "id": 412015459,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704835878
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"514145\">Geoffrey Irving</span> <a href=\"#narrow/stream/287929-mathlib4/topic/lots.20of.20linarith/near/412013149\">said</a>:</p>\n<blockquote>\n<p>I'm curious watching this thread: why would <code>omega</code> be faster than <code>linarith</code>?  Isn't it way more complicated?</p>\n</blockquote>\n<p><code>omega</code> is not using <code>norm_num</code>, which means that all the numeric literals have to be literals. It is written in <code>std</code> which means that it lacks a lot of the features from mathlib tactics, but that also makes it faster</p>",
        "id": 412021329,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704838608
    },
    {
        "content": "<p>It also does not understand anything about the mathlib algebraic hierarchy, which it can get away with because it only works on <code>Nat</code> and <code>Int</code> where the operations are known. So that means no typeclass search which is big</p>",
        "id": 412021519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704838717
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"673728\">Josha Dekker</span> <a href=\"#narrow/stream/287929-mathlib4/topic/lots.20of.20linarith/near/412014036\">said</a>:</p>\n<blockquote>\n<p>I don’t want to sidetrack the conversation, but the reason why we don’t do:</p>\n<ul>\n<li>run linarith</li>\n<li>extract the necessary proof steps, use them directly</li>\n</ul>\n</blockquote>\n<p>In principle it would output a <code>linear_combination</code> call, but this require work (and <code>linear_combination</code> is still only for equalities so far).</p>",
        "id": 412025965,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1704841005
    },
    {
        "content": "<p>... which someone should fix</p>",
        "id": 412027258,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704841699
    },
    {
        "content": "<p>I was talking with some people about making better use of certificate-based proofs in mathlib, as I think a lot of people already love <code>polyrith</code> and extending those methods would be incredible :)</p>",
        "id": 412028920,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704842583
    },
    {
        "content": "<p>Rob pointed out to me a while ago that <code>linarith</code> <em>already</em> constructs the thing that could be the certificate, we just don't have the linear-combination-for-inequalities tactic to record it</p>",
        "id": 412029137,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704842695
    },
    {
        "content": "<p>Extending <code>linear_combination</code> to handle inequalities is definitely a known tactic improvement that wouldn't be crazy hard. It's waiting for someone with the time to do it. <code>linarith</code> should then factor through (the backend of) this implementation</p>",
        "id": 412030341,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1704843276
    },
    {
        "content": "<p><code>omega</code> is also often faster because it can take shortcuts that <code>linarith</code> can't. In particular, because it works over the integers whenever it notices a common factor in coefficients, it gets to divide through, rounding constant terms in the \"favourable\" direction. Often this gives a contradiction when <code>linarith</code> would still be dealing with rationals.</p>",
        "id": 412034491,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1704845279
    },
    {
        "content": "<p>Separately, the implementation of <code>omega</code> tries to short-circuit early wherever possible. I suspect that if you add an \"easy\" contradiction e.g. <code>x + y &lt; 1 &amp;&amp; x + y &gt; 1</code> to a large and difficult problem then <code>omega</code> will reliably be fast but <code>linarith</code> will sometimes still \"do the work\". In practice this makes a big difference, so most problems are actually easy, and the only difficult is avoiding working on the irrelevant facts too early.</p>",
        "id": 412034754,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1704845397
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306577\">@Matthew Ballard</span>, if you are finding <code>first | omega | linarith</code> is necessary in this file, I would <strong>love</strong> to have the list of examples where <code>omega</code> is failing.</p>",
        "id": 412034877,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1704845441
    },
    {
        "content": "<p>I added one to <a href=\"https://github.com/leanprover/std4/pull/510\">std4#510</a> - it is auto/opt params</p>",
        "id": 412035157,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704845576
    },
    {
        "content": "<p>I have a fix in <a href=\"https://github.com/leanprover-community/mathlib4/pull/9594\">#9594</a> (also above) which cleans those up and adds them to the context before calling <code>omega</code></p>",
        "id": 412035265,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704845628
    },
    {
        "content": "<p>I am sure there is a more idiomatic way to strip those out from the hypotheses in the context :)</p>",
        "id": 412035454,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704845707
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/std4/pull/518\">std4#518</a></p>",
        "id": 412035896,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1704845903
    },
    {
        "content": "<p>Using <a href=\"https://github.com/leanprover/std4/pull/518\">std4#518</a> to fully swap out </p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code><span class=\"w\">  </span>Benchmark<span class=\"w\">                                                           </span>Metric<span class=\"w\">             </span><span class=\"nv\">Change</span>\n<span class=\"w\">  </span><span class=\"o\">=============================================================================================</span>\n+<span class=\"w\"> </span>build<span class=\"w\">                                                               </span>tactic<span class=\"w\"> </span>execution<span class=\"w\">    </span>-8.8%\n+<span class=\"w\"> </span>~Mathlib.Algebra.Homology.ExactSequence<span class=\"w\">                             </span>instructions<span class=\"w\">       </span>-66.9%\n+<span class=\"w\"> </span>~Mathlib.CategoryTheory.Abelian.DiagramLemmas.Four<span class=\"w\">                  </span>instructions<span class=\"w\">       </span>-75.9%\n+<span class=\"w\"> </span>~Mathlib.CategoryTheory.ComposableArrows<span class=\"w\">                            </span>instructions<span class=\"w\">       </span>-53.4%\n-<span class=\"w\"> </span>~Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit<span class=\"w\">   </span>instructions<span class=\"w\">        </span><span class=\"m\">19</span>.5%\n</code></pre></div>\n<p>with -3% build wall-clock</p>",
        "id": 412044370,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704849884
    },
    {
        "content": "<p>That's over all of Mathlib?!</p>",
        "id": 412044426,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1704849922
    },
    {
        "content": "<p>Yes <a href=\"https://github.com/leanprover-community/mathlib4/pull/9594\">#9594</a></p>",
        "id": 412044483,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704849962
    },
    {
        "content": "<p>Nice!</p>",
        "id": 412044537,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1704849974
    },
    {
        "content": "<p>Do you know what the deal is in FilteredColimitCommutesFiniteLimit?</p>",
        "id": 412044596,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1704850019
    },
    {
        "content": "<p>No idea</p>",
        "id": 412044607,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704850025
    },
    {
        "content": "<p>It would be great to have a more targeted head-to-head demonstrating <code>linarith</code> being slower than <code>omega</code>, that smells like some missing optimization work</p>",
        "id": 412045554,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704850598
    },
    {
        "content": "<p>I imagine you can specialize <code>ComposableArrows</code> to <code>Type u</code></p>",
        "id": 412045781,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704850746
    },
    {
        "content": "<p>I definitely second Scott's observation that linarith needs to get better at handling easy cases; I see people using <code>linarith</code> so often to prove really silly things like <code>2 + 2 = 4</code></p>",
        "id": 412045799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704850759
    },
    {
        "content": "<p>I mean a microbenchmark, a single problem rather than a whole file</p>",
        "id": 412045834,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704850786
    },
    {
        "content": "<p>OK</p>",
        "id": 412045839,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704850793
    },
    {
        "content": "<p>Improving <code>zify</code> would be a huge help on its own. This takes .26 sec over <code>Nat</code> and .15 over <code>Int</code>. (Compare to .07 for <code>omega</code>, and negligible time for <code>norm_num</code>.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">100</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"mi\">100</span> <span class=\"bp\">=</span> <span class=\"mi\">10000</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">linarith</span>\n</code></pre></div>",
        "id": 412154118,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1704898000
    },
    {
        "content": "<p>oh, linarith only works on Nat/Int because of <code>zify</code>?</p>",
        "id": 412159277,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704899282
    },
    {
        "content": "<p><code>linarith</code> needs subtraction, so it only works on <code>Nat</code> because of <code>zify</code>. Support for <code>Int</code> is native but the algorithm isn't complete in this setting.</p>",
        "id": 412160397,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1704899536
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.Omega</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Linarith</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">profiler.threshold</span> <span class=\"mi\">1</span> <span class=\"k\">in</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">profiler</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hij</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hj</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">omega</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">tactic execution of Std.Tactic.Omega.omegaSyntax took 11.7ms</span>\n<span class=\"cm\">type checking took 9.1ms</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">profiler.threshold</span> <span class=\"mi\">1</span> <span class=\"k\">in</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">profiler</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hij</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hj</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">simp took 1.53ms</span>\n<span class=\"cm\">simp took 1.32ms</span>\n<span class=\"cm\">simp took 1.52ms</span>\n<span class=\"cm\">typeclass inference of CovariantClass took 2.16ms</span>\n<span class=\"cm\">typeclass inference of NeZero took 1.58ms</span>\n<span class=\"cm\">ring took 4.8ms</span>\n<span class=\"cm\">typeclass inference of CovariantClass took 2.88ms</span>\n<span class=\"cm\">tactic execution of linarith took 23.1ms</span>\n<span class=\"cm\">type checking took 3.82ms</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>There were lots of things like this in ComposableArrows</p>",
        "id": 412160964,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704899686
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110596\">Rob Lewis</span> <a href=\"#narrow/stream/287929-mathlib4/topic/lots.20of.20linarith/near/412160397\">said</a>:</p>\n<blockquote>\n<p><code>linarith</code> needs subtraction, so it only works on <code>Nat</code> because of <code>zify</code>. Support for <code>Int</code> is native but the algorithm isn't complete in this setting.</p>\n</blockquote>\n<p>could this all be replaced with <code>qify/rify</code>?</p>",
        "id": 412162625,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704900078
    },
    {
        "content": "<p>In that example too, <code>linarith</code> spends half its time in <code>zify</code>. It's still not as fast as <code>omega</code> but much closer</p>",
        "id": 412162717,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1704900101
    },
    {
        "content": "<p>The overall drop in instructions across the file was a little over a half from the swap</p>",
        "id": 412163184,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704900202
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/287929-mathlib4/topic/lots.20of.20linarith/near/412162625\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110596\">Rob Lewis</span> <a href=\"#narrow/stream/287929-mathlib4/topic/lots.20of.20linarith/near/412160397\">said</a>:</p>\n<blockquote>\n<p><code>linarith</code> needs subtraction, so it only works on <code>Nat</code> because of <code>zify</code>. Support for <code>Int</code> is native but the algorithm isn't complete in this setting.</p>\n</blockquote>\n<p>could this all be replaced with <code>qify/rify</code>?</p>\n</blockquote>\n<p>My impression is that <code>zify</code> does extra things, in particular to try to make sense of nat subtraction when possible. And you don't want to translate nat problems to rat for linarith, because it has some tricks that only apply on int</p>",
        "id": 412163365,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1704900244
    },
    {
        "content": "<p>One could probably shrink this file down to nothing with a more simple-minded tactic that just tried using reflexivity and transitivity.</p>",
        "id": 412166005,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704900846
    },
    {
        "content": "<p>what tricks are those? taking advantage of stuff like 1 &lt; x is the same as 2 ≤ x? I should hope <code>rify</code> and <code>qify</code> deal with nat-subtraction too.</p>",
        "id": 412167521,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704901206
    },
    {
        "content": "<blockquote>\n<p>what tricks are those? taking advantage of stuff like 1 &lt; x is the same as 2 ≤ x?</p>\n</blockquote>\n<p>Yes, exactly.</p>",
        "id": 412203327,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1704913696
    },
    {
        "content": "<p>You're right, <code>rify</code> does do conditional simplification. I don't know why the implementations of <code>rify</code> and <code>zify</code> are different. <code>rify</code> seems to be much slower, compare:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.Omega</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Linarith</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Rify</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">profiler.threshold</span> <span class=\"mi\">1</span> <span class=\"k\">in</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">profiler</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- rify [hn]</span>\n  <span class=\"n\">zify</span> <span class=\"o\">[</span><span class=\"n\">hn</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 412203455,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1704913760
    },
    {
        "content": "<p>Obviously <code>omega</code> has to do something equivalent to <code>zify</code>, as well. My initial draft of the frontend for <code>omega</code> in fact did use <code>zify</code>, but it was obviously too slow. One obstacle is simply that <code>zify</code> uses the simplifier, and will traverse deep subexpressions in irrelevant hypotheses looking for things to do. The <code>omega</code> frontend instead inspects hypotheses structurally from the top down, stopping as soon as it reaches a subexpression which is not \"in scope\".</p>",
        "id": 412232827,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1704926979
    },
    {
        "content": "<p>So we could \"just\" do that in <code>zify</code> too?</p>",
        "id": 412283289,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704957788
    },
    {
        "content": "<p>Quite likely!</p>",
        "id": 412283355,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1704957840
    }
]