[
    {
        "content": "<p>I often find myself fighting the <code>toLex</code> and <code>ofLex</code>.<br>\nOne example is in trying to prove the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Lex</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Sum</span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Sum</span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">hab</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span><span class=\"cm\"> rw [Sum.Lex.inl_le_inl_iff] at hab -/</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I'm not sure how to show this in particular.<br>\nBut also, in general, I often find myself adding and removing <code>toLex</code>'s and it's annoying. Am I doing something wrong?</p>",
        "id": 440241674,
        "sender_full_name": "Eric Paul",
        "timestamp": 1716435592
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hab</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Lex</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Sum</span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Sum</span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Sum</span><span class=\"bp\">.</span><span class=\"n\">Lex</span><span class=\"bp\">.</span><span class=\"n\">inl_le_inl_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hab</span>\n</code></pre></div>\n<p>works for this particular case (as does <code>Sum.lex_inl_inl.mp hab</code>).</p>",
        "id": 440247861,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1716439743
    },
    {
        "content": "<p>You could also use <code>apply Sum.Lex.inl_le_inl_iff.mp at hab</code> in tactic mode, or</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"n\">toLex</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">toLex</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hab</span>\n<span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Sum</span><span class=\"bp\">.</span><span class=\"n\">Lex</span><span class=\"bp\">.</span><span class=\"n\">inl_le_inl_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hab</span>\n<span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hab</span>\n</code></pre></div>",
        "id": 440248012,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1716439902
    },
    {
        "content": "<p>In general you should not use <code>@LE.le ...</code>, and just spell everything with <code>toLex</code>, I think</p>",
        "id": 440248447,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1716440253
    },
    {
        "content": "<p>Note that mathlib provides notation for <code>toLex (inl a)</code> and <code>toLex (inr a)</code></p>",
        "id": 440251703,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1716442975
    },
    {
        "content": "<p>Ah thank you for the <code>change</code> approach.</p>\n<p>And I was about to say that it seemed like I was being forced to use <code>Sum.inl</code> at some point instead of <code>toLex (Sum.inl)</code> but it was my fault for defining a function without a <code>toLex</code>. So now all my issues are gone and I can use the nice notation!</p>\n<p>Thanks for the help</p>",
        "id": 440252275,
        "sender_full_name": "Eric Paul",
        "timestamp": 1716443358
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"512030\">Eric Paul</span> has marked this topic as resolved.</p>",
        "id": 440252286,
        "sender_full_name": "Notification Bot",
        "timestamp": 1716443368
    },
    {
        "content": "<p>I do wish we had notation for <code>(toLex (a,b)) : Lex (a \\times b)</code></p>",
        "id": 440252590,
        "sender_full_name": "Eric Paul",
        "timestamp": 1716443600
    },
    {
        "content": "<p>We certainly could add such a notation! Maybe <code>(a,ₗ b)</code>? You want to be able to compose it, eg <code>(a, b, c) : α × β × γ</code>, <code>(a, b,ₗ c) : α × β ×ₗ γ</code>, <code>(a,ₗ b, c) : α ×ₗ β × γ</code>, <code>(a,ₗ b,ₗ c) : α ×ₗ β ×ₗ γ</code>.</p>",
        "id": 440256720,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1716446132
    }
]