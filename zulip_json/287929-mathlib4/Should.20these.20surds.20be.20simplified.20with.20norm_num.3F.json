[
    {
        "content": "<p>I'm playing around with norm_num to see what it can do. It feels like there is a gap in it's knowledge when it comes to square roots. Here's my results:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q0</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">Real</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"o\">:</span><span class=\"n\">Real</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\">works-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"bp\">=</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\">works-/</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">√</span><span class=\"mi\">9</span><span class=\"bp\">=</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\">doesn't work-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q3</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*√</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">12</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\">doesn't work (use ring_nf;simp;ring_nf)-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q4</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">3</span><span class=\"o\">:</span><span class=\"n\">Real</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">Real</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"mi\">7</span><span class=\"o\">))</span><span class=\"bp\">^</span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\">doesn't work-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q5</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">3</span><span class=\"o\">:</span><span class=\"n\">Real</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">7</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">Real</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"mi\">7</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\">doesn't work-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q6</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">3</span><span class=\"bp\">=</span><span class=\"mi\">3</span><span class=\"bp\">*√</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> doesn't work-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q7</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">3</span><span class=\"bp\">=√</span><span class=\"mi\">27</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> doesn't work-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q8</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"bp\">=</span><span class=\"mi\">2</span><span class=\"bp\">*√</span><span class=\"mi\">3</span><span class=\"bp\">+</span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> doesn't work (use ring_nf;simp;ring_nf)-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q9</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> doesn't work (use  rw [&lt;-Real.sqrt_mul];ring_nf;simp)-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q10</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">/√</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"bp\">/</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> doesn't work-/</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q11</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">Real</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">Real</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">Real</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\">works-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q12</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"mi\">100000000</span><span class=\"bp\">/</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"mi\">99999999</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\">works (slowly - probably not using the easy method)-/</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q13</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> doesn't work-/</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q14</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> works -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q15</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> works -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q16</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">*√</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"bp\">*√</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> works -/</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q17</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">+√</span><span class=\"mi\">3</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">linarith</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\">works when include linarith -/</span>\n</code></pre></div>\n<p>Do you think these should work with norm_num? Also q12 works but it is very slow suggesting it is not simplifying it using the easy shortcut of subtracting exponents.</p>",
        "id": 444354836,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718237914
    },
    {
        "content": "<p><code>norm_num</code> unfortunately doesn't support surds, and making it do so (except in the case where the evaluation of the surd is rational) would be a substantial refactor</p>",
        "id": 444354871,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718237945
    },
    {
        "content": "<p>It does support one case e.g <code> sqrt(3)^2=3</code></p>\n<p>Perhaps it should support <code>(2*sqrt(3))^2=18</code> since that gives a rational?</p>",
        "id": 444354919,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718237992
    },
    {
        "content": "<p>I think that's just using <code>simp</code></p>",
        "id": 444354987,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718238012
    },
    {
        "content": "<p>The concept of <code>norm_num</code> is to normalize numbers, and the only normal forms it has are natural number, integer, and rational number literals (as well as boolean literals to be able to decide certain properties, like <code>Nat.Prime</code>). These are all chosen to be data types that have an efficient run-time representation, since <code>norm_num</code> does computations using normalized numbers when generating its proofs.</p>\n<p>If <code>norm_num</code> were to support surd expressions as well, then it would need a specification for a normal form for them, as well as an efficient way to calculate with them. At that point, it seems like working with general algebraic numbers (i.e., roots of arbitrary polynomials) would be the way to go, but that is much more complicated, and I'm not sure how that works for general rings. The <code>norm_num</code> tactic isn't only for <code>Nat</code>/<code>Int</code>/<code>Rat</code>/<code>Real</code>/<code>Complex</code> after all.</p>",
        "id": 444356222,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718238890
    },
    {
        "content": "<p>It makes sense that the following is slow, since <code>norm_num</code> works by recursively normalizing numbers. It will not use any global structure of an expression during its normalization.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q12</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"mi\">100000000</span><span class=\"bp\">/</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"mi\">99999999</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n</code></pre></div>\n<p>Note that <code>norm_num</code> also interleaves <code>simp</code>, which can make understanding the capabilities of <code>norm_num</code> itself somewhat confusing. You can use the <code>norm_num only</code> tactic to make it not apply any <code>simp</code> lemmas.</p>",
        "id": 444356763,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718239322
    },
    {
        "content": "<p>I see. <br>\nStill, I think it is missing a few cases where the answer is an integer.  <br>\nBut I see the problem.<br>\nIn the case of where there is no nesting I don't think the normal form wouldn't be too hard? Just take all squares to the outside so you'd end up with <code>a+b√2+c√3+d√5+e√6+f√7+g√11+...</code> in that order. <br>\nBut I can see that implementing that in Lean is probably very difficult.</p>\n<p>Yes, for the q12, Mathematica does the same thing! Even though it should know better. Sometimes humans are just better I suppose.</p>\n<p>Mind you, Chat GPT can solve that equation and it uses the exponent rule!</p>",
        "id": 444356858,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718239394
    },
    {
        "content": "<blockquote>\n<p>I think it is missing a few cases where the answer is an integer.</p>\n</blockquote>\n<p>It's not a matter of whether the answer is an integer, but whether all the intermediate expressions have a normal form. It's possible to add new rules, but I think the design of <code>norm_num</code> is that it's only supposed to worry about normalized values. Making a rule about squaring a product of square roots isn't in <code>norm_num</code>'s wheelhouse.</p>",
        "id": 444357391,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718239804
    },
    {
        "content": "<blockquote>\n<p><code>a+b√2+c√3+d√5+e√6+f√7+g√11+...</code></p>\n</blockquote>\n<p>Then what happens if you take a square root of that? Should <code>norm_num</code> fail? Or do you use a more complicated representation?</p>",
        "id": 444357491,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718239883
    },
    {
        "content": "<blockquote>\n<p>Sometimes humans are just better I suppose.</p>\n</blockquote>\n<p>Just because <code>norm_num</code> doesn't do it doesn't mean that you can't make a tactic that tries to be smart about simplifying. That said, a risk with adding too many rules is that, while they might make some things fast, they might slow the common case down, since it'll spend so much time trying to be smart rather than doing the arithmetic, which computers are good at.</p>\n<p>By the way, it turns out that <code>q12</code> is solved almost immediately by <code>simp</code>. It uses some faster proof-generating evaluation procedures I guess (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.reducePow#doc\">docs#Nat.reducePow</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.reduceDiv#doc\">docs#Nat.reduceDiv</a>), which were added recently with the <code>simproc</code>s feature.</p>",
        "id": 444357805,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718240120
    },
    {
        "content": "<p>I would imagine if we had <code>sqrt(4*sqrt(3)+7) = 2+sqrt(3)</code> it would be able to work out the RHS is positive and square both sides to get the answer. It never has to take any actual square roots. If the examples were more complicated it could just fail.</p>\n<p>I'll look more into simp, that seems to be very good.</p>",
        "id": 444357933,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718240220
    },
    {
        "content": "<p>You could write a <code>simproc</code> to reduce <code>√n</code> where <code>n</code> is a non-square-free natural number.</p>",
        "id": 444358003,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718240281
    },
    {
        "content": "<blockquote>\n<p>it would be able to work out the RHS is positive and square both sides to get the answer</p>\n</blockquote>\n<p>That's out of scope for <code>norm_num</code>, whose strategy for <code>x = y</code> is to normalize <code>x</code> and <code>y</code> and see that both sides are the same.</p>",
        "id": 444358092,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718240322
    },
    {
        "content": "<p>Here's a <code>simproc</code> for normalizing <code>Real.sqrt</code> of a natural number. Example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">12</span>\n<span class=\"c1\">-- 2 * √3</span>\n</code></pre></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">sqrt_reduce</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nsqrt</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"o\">(</span><span class=\"n\">Nat.cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nsqrt</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">nsqrt</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n\n<span class=\"n\">simproc</span><span class=\"w\"> </span><span class=\"n\">reduceSqrt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Real.sqrt</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Rty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getOfNatValue</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"n\">e.appArg</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"ss\">``Real</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">continue</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"n\">Squarefree</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">continue</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">nsqrt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">n''</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">Nat.factors</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">multiplicity</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"n\">while</span><span class=\"w\"> </span><span class=\"n\">n''</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"n\">n''</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n''</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">      </span><span class=\"n\">multiplicity</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">multiplicity</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"n\">nsqrt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">nsqrt</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">multiplicity</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">multiplicity</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- now `n'` is squarefree and `n = nsqrt^2 * n'`.</span>\n<span class=\"w\">  </span><span class=\"c1\">-- pf1 is `OfNat.ofNat n = Nat.cast n`</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">pf1</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkEqSymm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAppOptM</span><span class=\"w\"> </span><span class=\"ss\">``Nat.cast_eq_ofNat</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">Rty</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toExpr</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">])</span>\n<span class=\"w\">  </span><span class=\"c1\">-- pf2 is `√(OfNat.ofNat n) = √(Nat.cast n)`</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">pf2</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkCongrArg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``Real.sqrt</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"n\">pf1</span>\n<span class=\"w\">  </span><span class=\"c1\">-- pf3 is `√(Nat.cast (nsqrt ^ 2 * n')) = nsqrt * √n'`</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">pf3</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``sqrt_reduce</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">toExpr</span><span class=\"w\"> </span><span class=\"n\">nsqrt</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toExpr</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- pf4 is `√(OfNat.ofNat n) = nsqrt * √n'`</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">pf4</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkEqTrans</span><span class=\"w\"> </span><span class=\"n\">pf2</span><span class=\"w\"> </span><span class=\"n\">pf3</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inferType</span><span class=\"w\"> </span><span class=\"n\">pf4</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">eq</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">continue</span><span class=\"w\"> </span><span class=\"c1\">-- should not fail</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">visit</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pf4</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">12</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>\n</div></div>",
        "id": 444362938,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718243470
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.sq_mul_squarefree#doc\">docs#Nat.sq_mul_squarefree</a> should help with simplifying this.</p>",
        "id": 444407804,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1718266126
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span> Unless there's some trick I'm missing, that's just a theorem that numbers exist, not what the numbers are.</p>",
        "id": 444489991,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718291576
    },
    {
        "content": "<p>If Lean were more constructive, we could reduce the proof and extract the witnesses. Barring that, a more useful way to state that theorem would be with subtypes, since it would give the data of what exists.</p>",
        "id": 444490395,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718291668
    },
    {
        "content": "<p>You're right; I was missing that one actually needs the witnesses.<br>\nI guess it would make sense to add a function that produces the squarefree factorization of a natural number (in a computable way).</p>",
        "id": 444490706,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1718291750
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> </p>\n<p>Combining your simplification function with linarith I can do easily:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"mi\">9</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">12</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\">   </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"w\">  </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">18</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"w\">  </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n</code></pre></div>\n<p>That's pretty nice. <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span> Not sure how many steps it would take without that function. (BTW putting the left hand side into Maxima automatically converts it to the RHS). Makes me wonder if simp should always call linarith at the end.</p>\n<p>Some things that might be low hanging fruit: (These are two things Maxima does automatically)</p>\n<ul>\n<li>norm_num could order terms in sums in some kind of consistent order (alphabetical?) e.g. <code>2+√3 </code> vs <code>√3 +2</code> (this may be covered by linarith)</li>\n<li>As well as taking out squares a useful function would also be to automatically combine square roots e.g. <code>√3 *√3 *√5 *√7 = 3 * √35</code>. (Of course it is a matter of taste whether <code>√5 *√7 </code> or  <code>√35</code> is the \"correct\" normal form, but maxima goes with the second choice.) </li>\n</ul>\n<p>These are just some ideas. When I get better at Lean hopefully I'll be able to write functions for these myself.</p>",
        "id": 444538065,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718304950
    },
    {
        "content": "<p>Again, <code>norm_num</code> isn't that sort of tactic (it's for evaluating numbers, not normalizing algebraic expressions), but these are certainly things that a tactic could do.</p>\n<p>By the way, you can use <code>ring</code> in place of <code>linarith</code> for that. There's also <code>ring_nf</code> for putting sum/product expressions into a normal form.</p>",
        "id": 444549900,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718308507
    },
    {
        "content": "<p>Thanks. I like to explore the edge cases so I know what lean can do. (Yes <code>ring_nf</code> is what I was looking for to expand out expressions!) I got another conundrum:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\">  </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ring_nf</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\">works-/</span>\n\n<span class=\"kn\">example</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\">  </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\">works-/</span>\n\n<span class=\"kn\">example</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\">  </span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ring_nf</span><span class=\"bp\">;</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\">doesn't work-/</span>\n</code></pre></div>\n<p>I kind of feel like the third example should work. But it doesn't understand<code> example: (√3)^2+ 1 = 4 := by simp</code> for example fails. i.e. it doesn't simplify the square of a square-root when it's in the middle of an expression <span aria-label=\"worried\" class=\"emoji emoji-1f61f\" role=\"img\" title=\"worried\">:worried:</span></p>",
        "id": 444552185,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718309333
    },
    {
        "content": "<p>I was mostly responding to the \"low-hanging fruit\" comment. If you're not careful, it's tempting to make every tactic a full general theorem prover!</p>",
        "id": 444554298,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718310100
    },
    {
        "content": "<p>For your examples, do simp first before ring</p>",
        "id": 444554407,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718310125
    },
    {
        "content": "<p>That true .<span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span>.  For my the low hanging fruit comment, that is mostly about expressions you can type into maxima that automatically get put in a normal form. </p>\n<p>Aha! Success! Just had to call it twice on the second example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">+</span><span class=\"o\">(</span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"bp\">=</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"n\">ring_nf</span>\n\n<span class=\"kn\">example</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\">  </span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ring_nf</span><span class=\"bp\">;</span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"n\">ring_nf</span>\n</code></pre></div>\n<p>Wonder if it's possible to write a meta-tactic that alternately calls  <code>simp</code> and <code>ring_nf</code> until it can't simplify any more.  Assuming that wouldn't loop forever. I would call it <code>ring_simp</code></p>\n<p>My final challenge for today:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"bp\">+√</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\">  </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">*√</span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ring_nf</span><span class=\"bp\">;</span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"n\">ring_nf</span><span class=\"bp\">;</span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>The final unsolved goal is: <code>√3 * √2 = √6</code></p>",
        "id": 444555380,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718310469
    },
    {
        "content": "<blockquote>\n<p>maxima</p>\n</blockquote>\n<p>I've wanted to make a mathematica/maxima-style evaluator tactic before, along with a suite of tactics like <code>collect</code>/<code>expand</code>/etc. I've written this sort of thing in Python before, but the fun of tactics is that in addition to doing the manipulations you need to generate <em>proofs</em> that the manipulations are correct.</p>\n<p>Since you have this CAS background, I suppose it's worth mentioning that <code>simp</code> has very little in common with <code>Simplify[...]</code>, confusingly. The <code>simp</code> tactic is more like <code>//.</code> (<code>ReplaceRepeated[...]</code>) with a list of global rewrite rules. And, as you can see, with <code>simprocs</code> they can be programmatic rewrite rules. So, while it might be called \"simplify\", it's only a simplification if the set of rewrite rules is constructed suitably.</p>",
        "id": 444558655,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718311594
    },
    {
        "content": "<p>Yes, I actually think it's a good idea to mirror CAS type behaviour in Lean, since then you could use it like a CAS and have it prove all your steps as you go along. I think it would make it more accessible.</p>\n<p>OK solved my last problem for today. But it's not pretty:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">√</span><span class=\"mi\">3</span><span class=\"bp\">+√</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\">  </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">*√</span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ring_nf</span><span class=\"bp\">;</span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">&lt;-</span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">sqrt_mul</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"n\">ring_nf</span><span class=\"bp\">;</span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 444561677,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718312779
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Should.20these.20surds.20be.20simplified.20with.20norm_num.3F/near/444558655\">said</a>:</p>\n<blockquote>\n<p><code>simp</code> has very little in common with <code>Simplify[...]</code>, confusingly</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, I agree with your analogy with <code>ReplaceRepeated</code>. Is there any public description of what <code>Simplify</code> is actually doing? Despite at times knowing a lot about Mathematica internals, this was always a black box to me.</p>",
        "id": 444584282,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1718323283
    },
    {
        "content": "<p>All I know is that it tries transforming the expression using many different approaches and then returns the simplest one according to some complexity measure. You can set the transformers using the <a href=\"https://reference.wolfram.com/language/ref/TransformationFunctions.html\">TransformationFunctions</a> and the complexity measure using the <a href=\"https://reference.wolfram.com/language/ref/ComplexityFunction.html\">ComplexityFunction</a> options.</p>",
        "id": 444588412,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718326354
    },
    {
        "content": "<p>Hmm...  looking into it more, it seems that <code>Simplify</code>/<code>FullSimplify</code> is also like <code>ReplaceRepeated</code>, but it nondeterministically does transformations and returns the simplest one it comes across. The thing I couldn't find is how it determines how long to try to simplify, or if there are heuristics on how complicated it's willing to make an expression.</p>",
        "id": 444589117,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718326872
    }
]