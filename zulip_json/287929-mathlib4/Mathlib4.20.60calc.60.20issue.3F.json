[
    {
        "content": "<p>Hi, I was working through converting a proof to <code>calc</code> style and came across this strangeness:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">--import Mathlib.Tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pow256_shr</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">UInt8</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">256</span><span class=\"bp\">^</span><span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">m.val</span> <span class=\"bp\">*</span> <span class=\"mi\">256</span><span class=\"bp\">^</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">256</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">mLt</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">m.val</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">256</span> <span class=\"o\">:=</span> <span class=\"n\">m.val.isLt</span>\n  <span class=\"k\">calc</span>\n    <span class=\"n\">_</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">256</span> <span class=\"bp\">*</span> <span class=\"mi\">256</span><span class=\"bp\">^</span><span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">256</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>On Lean <code>4.7.0</code> the above succeeds (ignoring <code>sorry</code>) for now. However, if I uncomment the <code>import Mathlib.Tactic</code> line, then it fails. Here, <code>Mathlib</code> is imported with this line in the <code>lakefile.lean</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">require</span> <span class=\"n\">mathlib</span> <span class=\"k\">from</span> <span class=\"n\">git</span> <span class=\"s2\">\"https://github.com/leanprover-community/mathlib4\"</span><span class=\"bp\">@</span><span class=\"s2\">\"v4.7.0\"</span>\n</code></pre></div>\n<p>I'm confused what's going on here?</p>",
        "id": 438448742,
        "sender_full_name": "David Pearce",
        "timestamp": 1715634546
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kd\">def</span> <span class=\"n\">pow256_shr</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">UInt8</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">256</span><span class=\"bp\">^</span><span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">m.val.val</span> <span class=\"bp\">*</span> <span class=\"mi\">256</span><span class=\"bp\">^</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">256</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n       <span class=\"c1\">-- ^^^^ added this</span>\n  <span class=\"k\">have</span> <span class=\"n\">mLt</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">m.val</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">256</span> <span class=\"o\">:=</span> <span class=\"n\">m.val.isLt</span>\n  <span class=\"k\">calc</span>\n    <span class=\"n\">_</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">256</span> <span class=\"bp\">*</span> <span class=\"mi\">256</span><span class=\"bp\">^</span><span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">256</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 438451728,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715635601
    },
    {
        "content": "<p>The issue is that the new imports <em>changed the meaning of the theorem!</em></p>",
        "id": 438451772,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715635618
    },
    {
        "content": "<p>I think that not providing the LHS on the first calc line is also not helping Lean.</p>",
        "id": 438452366,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1715635829
    },
    {
        "content": "<p>It's already too late by then though, the statement was wrong as soon as the <code>by</code> began</p>",
        "id": 438452481,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715635867
    },
    {
        "content": "<p>With <code>Mathlib.Tactic</code> imported, the type of the <code>256</code> is now <code>Fin 256</code> not <code>Nat</code>; and so the theorem is false!</p>",
        "id": 438452546,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715635901
    },
    {
        "content": "<p>Sure, these are independent comments.</p>",
        "id": 438452569,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1715635914
    },
    {
        "content": "<p>I've not seen an algebraic case where dropping the first calc term causes an issue</p>",
        "id": 438452658,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715635940
    },
    {
        "content": "<p>(It certainly happens with morphisms, where you have to give the LHS on every line, repeating the RHS of the previous line!)</p>",
        "id": 438452734,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715635971
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Mathlib4.20.60calc.60.20issue.3F/near/438452546\">said</a>:</p>\n<blockquote>\n<p>With <code>Mathlib.Tactic</code> imported, the type of the <code>256</code> is now <code>Fin 256</code> not <code>Nat</code>; and so the theorem is false!</p>\n</blockquote>\n<p>So, this is the key thing.  Using <code>Mathlib</code> changes the types given to constants?  That seems ... unexpected to me.</p>",
        "id": 438459325,
        "sender_full_name": "David Pearce",
        "timestamp": 1715638627
    },
    {
        "content": "<p>You don't specify types of LHS and RHS, so Lean has to guess. Mathlib adds more instances, so Lean can put everything to <code>Fin 256</code> now instead of casting to <code>Nat</code>.</p>",
        "id": 438459538,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1715638737
    },
    {
        "content": "<p>Instead of adding extra <code>.val</code>, you can specify that LHS has type <code>Nat</code>.</p>",
        "id": 438459597,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1715638767
    },
    {
        "content": "<p>The rule for arithmetic is that it looks at the whole arithmetic expression tree, finds the types of everything (if known), and then figures out what everything can be coerced to. It turns out <code>m.val</code> is a <code>Fin UInt8.size</code>, so it goes with that.</p>\n<p>It doesn't affect anything here, but this algorithm can go wrong if there's a loop in the coercions. We fixed this with <code>ZMod</code> <a href=\"#narrow/stream/113488-general/topic/Strange.20coercions.20with.20ZMod/near/416575181\">the last time this discussion came up</a>, but <code>Fin</code> is not well-behaved: <code>(((16 : Nat) : Fin 5) : Nat)</code>. We'll have to fix that one...</p>",
        "id": 438610539,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715703544
    },
    {
        "content": "<p>In my mind the difference between ZMod and Fin is that ZMod has a coercion from Nat but no coercion to Nat (it's the quotient), and Fin has a coercion to Nat but not a coercion from Nat (it's the subobject). However I'm aware that this doesn't correspond to reality -- people want to load more and more structure onto Fin n to get it to be some kind of substitute for ZMod.</p>",
        "id": 438630499,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1715711163
    },
    {
        "content": "<p>Currently <code>Fin</code> has coercions both ways.</p>",
        "id": 438678815,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1715729148
    },
    {
        "content": "<p>On the one hand, this (and related <code>OfNat</code> instances) allow expressions like <code>(3 : Fin 5)</code>. OTOH, sometimes this leads to confusion.</p>",
        "id": 438679019,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1715729231
    },
    {
        "content": "<p>You don't need the coercion to make expressions like <code>(3 : Fin 5)</code> work though, and the bidirectional coercion causes issues with elaboration:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">decide</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"c1\">-- true</span>\n<span class=\"k\">#eval</span> <span class=\"n\">decide</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"c1\">-- false</span>\n</code></pre></div>\n<p>It's not good that this depends on imports. Without the import, both are <code>false</code>.</p>",
        "id": 438679909,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715729655
    },
    {
        "content": "<p>This one's because mathlib has <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.instCommRing#doc\">docs#Fin.instCommRing</a>, which enables the <code>Nat -&gt; Fin n</code> coercion, but since <code>Fin</code> is a subtype, it has a <code>Fin n -&gt; Nat</code> coercion too.</p>",
        "id": 438680200,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715729801
    },
    {
        "content": "<p>Johan had fixed this for ZMod by removing the <code>ZMod n -&gt; Nat</code> coercion <a href=\"https://github.com/leanprover-community/mathlib4/pull/9839/files#diff-045563e9a620ceedb72bba37de77554038dfe9d0ec1bcdc4989585c5020e6b77L156-L158\">here</a>, but that's not an option for <code>Fin</code>. It's meant to be a subtype of the natural numbers.</p>",
        "id": 438680306,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715729880
    },
    {
        "content": "<p>Some thoughts about solving this problem:</p>\n<ul>\n<li>We could make <code>Fin.instCommRing</code> not be a global instance, but that seems heavy handed.</li>\n<li>We could make the <code>NatCast</code> coercions somehow be opt-in. I'm not sure what that would look like (is it instances you activate? an explicit coercion notation you use?)</li>\n<li>We could get the core expression tree elaborator to be more picky with what coercions it should consider. There are valid reasons for inserting <code>Fin n -&gt; Nat</code> coercions, but inserting non-injective coercions seems problematic.</li>\n</ul>",
        "id": 438682442,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715731045
    },
    {
        "content": "<p><code>Fin</code> is a custom structure, not a subtype (though we think about it as a subtype).</p>",
        "id": 438704436,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1715741732
    },
    {
        "content": "<p>I would vote for removing <code>Fin.instCommRing</code>. We can have it as a scoped instance (e.g., if someone will write a <code>norm_num</code> extension for <code>Fin</code>)</p>",
        "id": 438704687,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1715741822
    },
    {
        "content": "<p>But I like the idea \"if you want a ring, use <code>ZMod</code>\". Note: I may change my mind when I see the <code>diff</code>.</p>",
        "id": 438704831,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1715741878
    }
]