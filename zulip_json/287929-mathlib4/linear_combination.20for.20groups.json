[
    {
        "content": "<p>I just stumbled upon a goal which was very <code>linear_combination</code>-flavoured.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.LinearCombination</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">d</span> <span class=\"bp\">-</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">d</span> <span class=\"bp\">-</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"bp\">-</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linear_combination</span> <span class=\"n\">h</span>\n<span class=\"c1\">-- failed to synthesize `CommSemiring G`</span>\n</code></pre></div>",
        "id": 437008587,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1714816497
    },
    {
        "content": "<p>Sadly, I am only in a group <code>G</code> and <code>linear_combination</code> expects at least <code>CommSemiring</code>. Of course, this should not matter, since <code>G</code> is a <code>Nat</code>-module and I was only going to input <code>Nat</code> scalars.</p>",
        "id": 437008624,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1714816535
    },
    {
        "content": "<p>Would that be too much of a scope-creep to support modules in <code>linear_combination</code> instead of just rings?</p>",
        "id": 437008691,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1714816570
    },
    {
        "content": "<p><code>linear_combination</code> just takes a linear combination of the equations you feed to it, yielding an equation that can be proved by just <code>congr</code>. Then it uses a normalization tactic (by default <code>ring_nf</code>) to show that the resulting equation is equivalent to the one you are trying to show. <code>linear_combination</code> doesn't do any simplification at all by itself. That means you can get it to prove equations about abelian groups by using <code>abel_nf</code> as the normalization tactic instead of <code>ring_nf</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">d</span> <span class=\"bp\">-</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">d</span> <span class=\"bp\">-</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"bp\">-</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linear_combination</span> <span class=\"o\">(</span><span class=\"n\">norm</span> <span class=\"o\">:=</span> <span class=\"n\">abel_nf</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 437042293,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1714847246
    },
    {
        "content": "<p>However, there are two issues with this approach.</p>\n<ol>\n<li><code>linear_combination</code> cannot combine equations using <code>•</code>, only using <code>*</code>. For example:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"c\">/-</span>\n<span class=\"cm\">    typeclass instance problem is stuck, it is often due to metavariables</span>\n<span class=\"cm\">      HSMul ℕ ?m.1763 ?m.1764</span>\n<span class=\"cm\">    -/</span>\n    <span class=\"mi\">2</span> <span class=\"bp\">•</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">•</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linear_combination</span> <span class=\"o\">(</span><span class=\"n\">norm</span> <span class=\"o\">:=</span> <span class=\"n\">abel_nf</span><span class=\"o\">)</span> <span class=\"mi\">2</span> <span class=\"bp\">•</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>(This can be fixed by extending <code>linear_combination</code>.)</p>\n<ol start=\"2\">\n<li><code>abel_nf</code> works great for abelian groups. But as far as I know, there is no currently no normalization tactic for general module-valued expressions. (See <a href=\"#narrow/stream/287929-mathlib4/topic/Feature.20request.3A.20.22module_nf.22\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Feature.20request.3A.20.22module_nf.22</a>.)<br>\nFor example, there is no tactic that can prove an equation like this.</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"n\">x</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">-</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(This is not an issue with <code>linear_combination</code>, and there is no way that <code>linear_combination</code> could possibly prove this theorem unless there was a separate <code>module_nf</code> tactic that could already prove it by itself.)</p>",
        "id": 437042918,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1714847814
    }
]