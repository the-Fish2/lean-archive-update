[
    {
        "content": "<p>I am trying to  define a functor associating a pointed space to its fundamental group. In order to do so, I defined a category of  pointed spaces like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Topology</span><span class=\"bp\">.</span><span class=\"n\">Defs</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">ConcreteCategory</span><span class=\"bp\">.</span><span class=\"n\">Bundled</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">AlgebraicTopology</span><span class=\"bp\">.</span><span class=\"n\">FundamentalGroupoid</span><span class=\"bp\">.</span><span class=\"n\">FundamentalGroup</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PointedSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\">  </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">base_point</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">PointedSpace</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">PointedSpaceCat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Bundled</span><span class=\"w\"> </span><span class=\"n\">PointedSpace</span>\n\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PointedSpaceCat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">str</span><span class=\"bp\">.</span><span class=\"n\">toTopologicalSpace</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">PointedContinuousMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PointedSpaceCat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">ContinuousMap</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">isPointed</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">str</span><span class=\"bp\">.</span><span class=\"n\">base_point</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">str</span><span class=\"bp\">.</span><span class=\"n\">base_point</span>\n\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">PointedSpaceCat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\">  </span><span class=\"n\">PointedContinuousMap</span>\n<span class=\"w\">  </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">},</span><span class=\"n\">id_eq</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span>\n<span class=\"w\">  </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">toFun</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">ContinuousMap</span><span class=\"bp\">.</span><span class=\"n\">toFun_eq_coe</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">comp_apply</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">isPointed</span><span class=\"o\">,</span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">isPointed</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>but then, when I try to define the map between fundamental groups induced by a continuous map, I try this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PointedSpaceCat</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PointedContinuousMap</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FundamentalGroup</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">str</span><span class=\"bp\">.</span><span class=\"n\">base_point</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FundamentalGroup</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"bp\">.</span><span class=\"n\">α</span><span class=\"w\">  </span><span class=\"n\">Y</span><span class=\"bp\">.</span><span class=\"n\">str</span><span class=\"bp\">.</span><span class=\"n\">base_point</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">toPath</span>\n</code></pre></div>\n<p>and Lean complains with an error message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"n\">FundamentalGroup</span><span class=\"bp\">.</span><span class=\"n\">toPath</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"n\">argument</span>\n<span class=\"w\">  </span><span class=\"n\">g</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">FundamentalGroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">base_point</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">FundamentalGroup</span><span class=\"w\"> </span><span class=\"bp\">↑?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">20728</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">20729</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n</code></pre></div>\n<p>I really don't see where the problem is.</p>",
        "id": 444989117,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1718553873
    },
    {
        "content": "<p>It seems that it is unable to complete type inference, because this works</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PointedSpaceCat</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PointedContinuousMap</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FundamentalGroup</span><span class=\"w\"> </span><span class=\"n\">X.α</span><span class=\"w\"> </span><span class=\"n\">X.str.base_point</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FundamentalGroup</span><span class=\"w\"> </span><span class=\"n\">Y.α</span><span class=\"w\">  </span><span class=\"n\">Y.str.base_point</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">FundamentalGroup.toPath</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">TopCat.of</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">X.str.toTopologicalSpace</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">g</span>\n</code></pre></div>",
        "id": 444997893,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1718558781
    },
    {
        "content": "<p>In the above, the <code>base_point</code> is picked up automatically, so it seems that the true problem is to figure out the space.</p>",
        "id": 444997931,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1718558806
    },
    {
        "content": "<p>I see, so  <code>FundamentalGroup.toPath</code> expects a <code>TopCat</code> lifted to a <code>TopologicalSpace</code>, and we have to wrap the topological space again to provde it. Shouldn't the <code>extend</code> clause take care of that?</p>",
        "id": 444998374,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1718559034
    },
    {
        "content": "<p>Actually if you change your <code>(g : FundamentalGroup X.α X.str.base_point)</code> to <code>(g : FundamentalGroup (TopCat.of X.α) X.str.base_point)</code> your code works.</p>",
        "id": 444998481,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1718559107
    },
    {
        "content": "<p>I think you are being a bit too greedy, because Lean starts of with <code>X</code>, then it creates <code>X.α</code> which is a PointedSpace structure on it and you are automatically coercing it to a type that you would like it to automatically re-bundle into an object of TopCat</p>",
        "id": 444998812,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1718559290
    },
    {
        "content": "<p>Which would be the right way to do it?</p>",
        "id": 444998859,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1718559339
    },
    {
        "content": "<p>If you are calling <code>`@FundamentalGroup.toPath (@TopCat.of _ X.str.toTopologicalSpace) _ g</code> it is happy with a <em>pair</em> of a type+topological space on it (that can automatically infer by the <code>extend</code>) but here you are asking it to re-bundled the pair (the type, the top structure) <em>automatically</em> and this it cannot do.</p>",
        "id": 444998885,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1718559360
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461731\">Miguel Marco</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Error.20trying.20to.20define.20fundamental.20group.20as.20a.20functor/near/444998859\">said</a>:</p>\n<blockquote>\n<p>Which would be the right way to do it?</p>\n</blockquote>\n<p>I think you might try to define a coercion from <code>PointedSpaceCat</code> to <code>TopCat</code>.</p>",
        "id": 444998974,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1718559408
    },
    {
        "content": "<p>I see, does that sound better than trying to \"extend\" the bundled structure?</p>",
        "id": 444999015,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1718559451
    },
    {
        "content": "<p>That being said, have you already checked that this functor is not already in the library? Are you trying it as an excercise or really to contribute? (Note: I am not saying it is there, I am really asking...)</p>",
        "id": 444999036,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1718559466
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461731\">Miguel Marco</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Error.20trying.20to.20define.20fundamental.20group.20as.20a.20functor/near/444999015\">said</a>:</p>\n<blockquote>\n<p>I see, does that sound better than trying to \"extend\" the bundled structure?</p>\n</blockquote>\n<p>You could also extend <code>TopCat</code>, true. I think both are viable options, but it mainly depends if you want to put more focus on \"pointed topological spaces\" and then create their category; or to start from the category of topological spaces and \"sometimes\" to stare at its objects in the eyes.</p>",
        "id": 444999194,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1718559565
    },
    {
        "content": "<p>I cheked and didn't find it (the fundamental groupoid one exists, but not the fundamental group). For starters, I am just playing around. If i manage to do something of reasonable quality, i might consider contributing it, but  that is not what I have in mind now.</p>",
        "id": 444999304,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1718559619
    },
    {
        "content": "<p>I see, then I would certainly suggest that you try to play with both options and decide which one is the best according at how difficult becomes to prove \"trivial\" statements, like: the composition of functions incudes homs of fundamental groups (or just maps, to start with), the identity map induces the identity, etc... Most probably, in one of the two settings things will be easier than in the other, and you'll have your answer.</p>",
        "id": 444999509,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1718559737
    },
    {
        "content": "<p>Consider that you could also do everything by hand first (with no category theory), just defining the \"functor\" on obj+morphisms (without calling it \"a functor\"); and invoking the category library at a second stage. Again, this is not what I recommend, just an option whose value can normally be appreciated at a later stage, once you are working with these notions.</p>",
        "id": 444999587,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1718559817
    }
]