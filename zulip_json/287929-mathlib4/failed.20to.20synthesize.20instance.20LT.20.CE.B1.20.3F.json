[
    {
        "content": "<p>I'm pretty sure I just don't know the correct way to do this, but I'm trying to do a proof about a LinearOrdered set and something isn't being recognized.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Lattice</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Set</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">s1</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">s2</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"n\">r</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">s1</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"bp\">∧</span>\n      <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"n\">r</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">s2</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"bp\">→</span>\n    <span class=\"n\">s1</span> <span class=\"bp\">=</span> <span class=\"n\">s2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">done</span>\n</code></pre></div>\n<p>This produces errors for all the comparisons (failed to synthesize instance <code>LT α</code>), which I assume means Lean is trying to treat the type α as comparable when that is not guaranteed. As far as I see, all of my variables belong to the set <code>A</code>, and <code>A</code> is comparable, so the comparisons should be fine. I've also tried putting the LinearOrder constraint in the example as <code>example [LinearOrder A] : ...</code>, which doesn't work either.</p>\n<p>How am I supposed to do this?</p>",
        "id": 422732428,
        "sender_full_name": "Michael",
        "timestamp": 1708566162
    },
    {
        "content": "<p>Are you sure you don't want to work with a linearly ordered <em>type</em> instead?</p>",
        "id": 422733470,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708566922
    },
    {
        "content": "<p>I am not sure of that, no. I don't really know how the [] annotations work.</p>",
        "id": 422734495,
        "sender_full_name": "Michael",
        "timestamp": 1708567573
    },
    {
        "content": "<p>the immediate problem is that you put the order on the set instead of the type, which I think is what Eric is getting at</p>",
        "id": 422735624,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1708568019
    },
    {
        "content": "<p>There doesn't appear to be a syntax error placing it on the set - what does [LinearOrder A] make comparable?</p>",
        "id": 422735753,
        "sender_full_name": "Michael",
        "timestamp": 1708568098
    },
    {
        "content": "<p><code>LinearOrder</code> works with types, so what Lean is doing is coercing the set A to a type, specifically the subtype of elements of A, so elements of that subtype (like <code>x : A</code>) will have the order on them</p>",
        "id": 422736053,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1708568287
    },
    {
        "content": "<p>so technically if you changed all of the <code>∈</code> to <code>:</code>, the error would go away</p>",
        "id": 422736089,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1708568332
    },
    {
        "content": "<p>Lean also has a concept of subrelation (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subrel#doc\">docs#Subrel</a>) which is when a relation on a type is restricted to members of a set</p>",
        "id": 422736217,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1708568426
    },
    {
        "content": "<p>thanks!</p>",
        "id": 422736274,
        "sender_full_name": "Michael",
        "timestamp": 1708568473
    },
    {
        "content": "<p>Well, I'm having a problem that I strongly suspect is related to this. I have a theorem about all sets of real numbers. I have another set of type <code>Set ↑(Ico 0 1)</code> - that is, it's a subset of the half-open real interval from 0 to 1. I want to apply my theorem (about all sets of real numbers) to this set that is a subset of [0, 1). Is there a better way to handle this than defining <code>let S' := {Subtype.val x | x ∈ S}</code>?</p>\n<p>That <em>works</em>, but I'm not thrilled with the approach:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">lubp</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">lubp</span> <span class=\"o\">(</span><span class=\"n\">Set.Ico</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">lubp</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h0</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">lubp</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">S</span> <span class=\"n\">hsne</span> <span class=\"n\">hsba</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">BddAbove</span><span class=\"o\">,</span> <span class=\"n\">Set.Nonempty</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hsba</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">ub</span><span class=\"o\">,</span> <span class=\"n\">hub</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hsba</span>\n  <span class=\"c1\">-- S has a \"subset\" type; let S' be all the reals in S</span>\n  <span class=\"k\">let</span> <span class=\"n\">S'</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">Subtype.val</span> <span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">}</span>\n  <span class=\"c1\">-- S' = S, and S is nonempty, so S' is also nonempty</span>\n  <span class=\"k\">have</span> <span class=\"n\">hs'ne</span> <span class=\"o\">:</span> <span class=\"n\">Set.Nonempty</span> <span class=\"n\">S'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.Nonempty</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.Nonempty</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hsne</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hsne</span>\n    <span class=\"n\">exists</span> <span class=\"n\">Subtype.val</span> <span class=\"n\">s</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_setOf</span><span class=\"o\">]</span>\n    <span class=\"n\">exists</span> <span class=\"n\">s</span>\n  <span class=\"c1\">-- And since S is bounded above in [0, 1), S' is certainly bounded above in ℝ</span>\n  <span class=\"k\">have</span> <span class=\"n\">hs'ba</span> <span class=\"o\">:</span> <span class=\"n\">BddAbove</span> <span class=\"n\">S'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">BddAbove</span><span class=\"o\">,</span> <span class=\"n\">Set.Nonempty</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_upperBounds</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hub</span>\n    <span class=\"n\">exists</span> <span class=\"n\">ub.val</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_upperBounds</span><span class=\"o\">]</span>\n    <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_setOf</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hx</span>\n    <span class=\"k\">have</span> <span class=\"n\">hr'</span> <span class=\"o\">:=</span> <span class=\"n\">hub</span> <span class=\"n\">r</span> <span class=\"n\">hr.left</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hr.right</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">subrel_val</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hr'</span>\n  <span class=\"c1\">-- [proof continues...]</span>\n</code></pre></div>",
        "id": 422979810,
        "sender_full_name": "Michael",
        "timestamp": 1708680755
    },
    {
        "content": "<p>This is a pain point when working in type theory. Whilst I don't know your actual application, for me the alarm bells would be going off at the coercion from Ico 0 1 to a type. Are you sure you can't make do with a term of type <code>Set \\R</code> and a proof that it's a subset of Ico 0 1? This would probably be the idiomatic approach. The moment you make a new type eg coercing a subset to a type, you're asking for trouble (in the form that you're already seeing). Use the default types as much as possible, if you can.</p>",
        "id": 422982000,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708681552
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"686884\">@Michael</span> could you provide the definition of <code>lubp</code>?</p>",
        "id": 423060560,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1708708780
    },
    {
        "content": "<p>The one applying to a type (as complained about immediately above) was this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">lubp</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n  <span class=\"n\">S.Nonempty</span> <span class=\"bp\">→</span> <span class=\"n\">S.BddAbove</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">IsLUB</span> <span class=\"n\">S</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>(For context, what I'm doing is expressing the assignments of <a href=\"https://ocw.mit.edu/courses/18-901-introduction-to-topology-fall-2004/\">https://ocw.mit.edu/courses/18-901-introduction-to-topology-fall-2004/</a> in Lean. What's supposed to be expressed is \"An ordered set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> has the <strong>least upper bound property</strong> if every nonempty subset <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub><mo>⊆</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A_0 \\subseteq A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> that is bounded above [in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>] has a least upper bound [in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>].\")</p>\n<p>This type-oriented definition works well for the theorem that a set has the least upper bound property only if it has the greatest lower bound property (defined analogously), and benefits from leaning on the stuff like <code>IsLUB</code> that Mathlib already provides.</p>\n<p>It causes the problems that I illustrated above for the theorem that, if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> has the lubp, then so does <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[0, 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>. I have managed to finish both proofs using this more set-oriented definition of lubp:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">lubp</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">S</span> <span class=\"bp\">⊆</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">S.Nonempty</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">upperBounds</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">IsLeast</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">upperBounds</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>But there are still some aspects of this that I find less than ideal; it adds a lot of boilerplate to the lubp → glbp theorem, it makes the Mathlib <code>Set.BddAbove</code> predicate unusable (since that gives you a bound of the relevant type, not a bound in a relevant superset), and it leaves weirdnesses in the other proof such as the need to use <code>{y : ℝ | True}</code> for the set of real numbers (since ℝ is a type, not a set). Then, once the proof is finished, I get warnings everywhere I refer to <code>{y : ℝ | True}</code> because the variable <code>y</code> is unused.</p>",
        "id": 423122012,
        "sender_full_name": "Michael",
        "timestamp": 1708740490
    },
    {
        "content": "<p>This approach is normal in mathlib. For example there are two definitions of compact -- one for subsets of a type and one for types. The main API is developed for subsets of a type and then the theory is developed for types as a corollary of the subset work (applying to <code>Set.univ</code>). This is an unfortunate consequence of using type theory as a foundation; subsets of subsets are not equal to subsets in type theory.</p>",
        "id": 423138619,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708754115
    },
    {
        "content": "<p>To tidy up your other comments: I would just use <code>Set.univ</code> for the subset representing the entire type rather than rolling your own, and to get rid of an unused variable warning don't name the variable, call it <code>_</code>.</p>",
        "id": 423138743,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708754270
    }
]