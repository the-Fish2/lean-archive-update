[
    {
        "content": "<p>I would like to work with multisets of fixed cardinality.<br>\nMWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.List.OfFn</span>\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">List</span>\n\n<span class=\"c1\">-- `n`-ary operation on `α`</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">MyOperation</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"c1\">-- permuting the input does not change the output</span>\n<span class=\"kd\">def</span> <span class=\"n\">MyOperation.IsSymmetric</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">MyOperation</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">List.ofFn</span> <span class=\"n\">x</span> <span class=\"bp\">~</span> <span class=\"n\">List.ofFn</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>For those operations that happen to be symmetric, I would like to convert them to a function <code>Multiset α → α</code> but only on multisets of cardinality <code>n</code>. The motivation is that I do a lot of summations later. Working with <code>Multiset.sum</code> should be easier than with <code>List.sum</code> since I already have <code>Finset.sum</code> elsewhere and they will have to be compared.</p>\n<p>Do we have such a notion in Mathlib? I could use a subtype, but it wouldn't be very convenient.</p>",
        "id": 425850167,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1710142625
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sym#doc\">docs#Sym</a> is that notion.</p>",
        "id": 425854419,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710144647
    },
    {
        "content": "<p>Thanks a lot!</p>",
        "id": 425855295,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1710145007
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Multiset.20of.20fixed.20cardinality/near/425854419\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sym#doc\">docs#Sym</a> is that notion.</p>\n</blockquote>\n<p>Should<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/blob/c671da20f0a9c6375a329f6b4a723ba9e0d8eb5a/Mathlib/Combinatorics/Optimization/ValuedCSP.lean#L120\">https://github.com/leanprover-community/mathlib4/blob/c671da20f0a9c6375a329f6b4a723ba9e0d8eb5a/Mathlib/Combinatorics/Optimization/ValuedCSP.lean#L120</a><br>\nbe refactored to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"bp\">∈</span> <span class=\"n\">ω</span><span class=\"o\">,</span> <span class=\"n\">some_existing_Mathlib_notion</span> <span class=\"n\">g</span>\n</code></pre></div>\n<p>for better compatibility with <code>Sym</code> please?</p>\n<p>I would like to know if there is more API that I could (and indeed should) reüse.</p>",
        "id": 425859231,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1710146279
    },
    {
        "content": "<p>I would have gone with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">FractionalOperation.IsSymmetric</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">FractionalOperation</span> <span class=\"n\">D</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">Equiv.Perm</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">m</span><span class=\"o\">)),</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"bp\">∈</span> <span class=\"n\">ω</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">∘</span>  <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"n\">g</span>\n</code></pre></div>",
        "id": 425864151,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710147779
    },
    {
        "content": "<p>But that's probably less not more compatible with Sym</p>",
        "id": 425864253,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710147821
    },
    {
        "content": "<p>Is there a canonical way to \"require symmetry\" before converting an operation to <code>Sym</code> please?</p>",
        "id": 425865419,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1710148228
    },
    {
        "content": "<p>What do you mean by \"converting to Sym\"?</p>",
        "id": 425872288,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710150756
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Multiset.20of.20fixed.20cardinality/near/425872288\">said</a>:</p>\n<blockquote>\n<p>What do you mean by \"converting to Sym\"?</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">FractionalOperation.IsSymmetric.toSym</span> <span class=\"o\">{</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">FractionalOperation</span> <span class=\"n\">D</span> <span class=\"n\">m</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hω</span> <span class=\"o\">:</span> <span class=\"n\">ω.IsSymmetric</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Multiset</span> <span class=\"o\">(</span><span class=\"n\">Sym</span> <span class=\"n\">D</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 425877202,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1710152551
    },
    {
        "content": "<p>In particular, I want to convert every term of the <code>(Fin m → D) → D</code> type to a term of the <code>Sym D m → D</code> type.</p>",
        "id": 425877393,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1710152642
    },
    {
        "content": "<p>Which also brings up a question whether there is a canonical conversion from <code>Sym D m</code> to <code>Fin m → D</code>.</p>",
        "id": 425877557,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1710152699
    },
    {
        "content": "<p>This is not a usual conversion, is it? I guess it is up to me how I do it and then I have to write the API myself?</p>",
        "id": 425878655,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1710153078
    },
    {
        "content": "<p>Perhaps I should build on top of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sym.ofVector#doc\">docs#Sym.ofVector</a> ...</p>",
        "id": 425882843,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1710154497
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Multiset.20of.20fixed.20cardinality/near/425877557\">said</a>:</p>\n<blockquote>\n<p>Which also brings up a question whether there is a canonical conversion from <code>Sym D m</code> to <code>Fin m → D</code>.</p>\n</blockquote>\n<p>No, this direction cannot be canonical (unless you can sort D or similar)</p>",
        "id": 425883859,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710154826
    },
    {
        "content": "<p>Sorry, I misused the word \"canonical\". I meant standard.</p>",
        "id": 425883999,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1710154874
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Multiset.20of.20fixed.20cardinality/near/425882843\">said</a>:</p>\n<blockquote>\n<p>Perhaps I should build on top of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sym.ofVector#doc\">docs#Sym.ofVector</a> ...</p>\n</blockquote>\n<p>Together with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Vector.ofFn#doc\">docs#Vector.ofFn</a> should work.</p>",
        "id": 425884397,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1710155030
    },
    {
        "content": "<p>Well, I am the other way around...</p>",
        "id": 425884768,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1710155162
    },
    {
        "content": "<p>I manage to put together this conversion</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Sym.Basic</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Function.ofSym</span> <span class=\"o\">{</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Sym</span> <span class=\"n\">D</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">x.attach.toMultiset.toList.get</span> <span class=\"o\">(</span><span class=\"n\">Fin.cast</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"n\">i</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Sym.coe_attach</span><span class=\"o\">,</span> <span class=\"n\">Multiset.length_toList</span><span class=\"o\">,</span> <span class=\"n\">Multiset.attach</span><span class=\"o\">,</span> <span class=\"n\">Multiset.card_pmap</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">x.property.symm</span>\n</code></pre></div>\n<p>but it feels very very very wrong.</p>",
        "id": 425887488,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1710156183
    },
    {
        "content": "<p>Don't get me wrong — the <code>noncomputable</code> is not the problem — I will end up having <code>noncomputable</code> in one place or the other either way. The \"body\" of the definition is horrendous!</p>",
        "id": 425889320,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1710156916
    },
    {
        "content": "<p>Then just prove that the map you see is surjective and take a right inverse for the one you want, using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.surjInv#doc\">docs#Function.surjInv</a></p>",
        "id": 425902938,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1710161724
    },
    {
        "content": "<p>I think that's probably a worse approach here, because you lose the ability to translate to <code>toList</code></p>",
        "id": 425916158,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710165930
    },
    {
        "content": "<p>I don't see why you needed the <code>attach</code>; why not just <code>x.toMultiset.toList.get (Fin.cast ?_ i)</code>?</p>",
        "id": 425916356,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710165983
    },
    {
        "content": "<p>You are completely right! I thought I was losing the property, but I was wrong, fortunately.<br>\nThis works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Sym.Basic</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Function.ofSym</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Sym</span> <span class=\"n\">D</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">x.toMultiset.toList.get</span> <span class=\"o\">(</span><span class=\"n\">Fin.cast</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Multiset.length_toList</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">x.property.symm</span>\n</code></pre></div>",
        "id": 425917656,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1710166341
    },
    {
        "content": "<p>Better:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Sym.Basic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Sym.toMultiset_toList_length</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Sym</span> <span class=\"n\">D</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x.toMultiset.toList.length</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Multiset.length_toList</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">x.property</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Function.ofSym</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Sym</span> <span class=\"n\">D</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"o\">:=</span>\n  <span class=\"n\">x.toMultiset.toList.get</span> <span class=\"o\">(</span><span class=\"n\">Fin.cast</span> <span class=\"n\">x.toMultiset_toList_length.symm</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 425918636,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1710166646
    }
]