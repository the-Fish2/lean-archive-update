[
    {
        "content": "<p>For FLT I'm running into the issue that I don't really know how to say any of the following.</p>\n<p>\"Let G be an affine group scheme (or group scheme) over Spec(R) (or S)\".</p>\n<p>Thanks to work done essentially entirely by undergraduates in Edinburgh and London, I now have a way of saying \"let G be an affine group scheme over Spec(R)\", and it's \"let H be a commutative Hopf algebra over R\". Loads of the proofs in Oort-Tate and Raynaud's extension involve careful calculations in Hopf algebras, and perhaps this is the best way to think about it in the finite case. I will need to define what it means for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ρ</mi><mo>:</mo><mrow><mi mathvariant=\"normal\">G</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">l</mi></mrow><mo stretchy=\"false\">(</mo><mover accent=\"true\"><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub><mo stretchy=\"true\">‾</mo></mover><mi mathvariant=\"normal\">/</mi><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub><mo stretchy=\"false\">)</mo><mo>→</mo><msub><mrow><mi mathvariant=\"normal\">G</mi><mi mathvariant=\"normal\">L</mi></mrow><mn>2</mn></msub><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"double-struck\">F</mi><mi>p</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\rho: \\mathrm{Gal}(\\overline{\\mathbb{Q}_p}/\\mathbb{Q}_p)\\to\\mathrm{GL}_2(\\mathbb{F}_p)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ρ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.175em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Gal</span></span><span class=\"mopen\">(</span><span class=\"mord overline\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8889em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-3.8089em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">GL</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathbb\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> to be flat; the definition is that it's the Galois representation attached to some finite (and hence affine) flat group scheme over the ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\Z_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>\" and I reckon all of that can be set up using module-finite Hopf algebras.</p>\n<p>Where it gets a bit gnarlier for me is the theory of connected reductive algebraic groups. Again everything is affine (although this time only ring-finite (i.e. finite-dimensional), not module-finite) and we only need the theory over a perfect field base K to state the global Langlands conjectures for number fields. But now thinking of things as the Hopf algebra sounds ridiculous, we want to talk about the representation theory of this group (it's even in the definition of \"reductive\"), and I'm not sure I want to develop corepresentation theory in the category of R-coalgebras. What model of affine group schemes over a field do I want for the definition of a reductive group?</p>\n<p>Finally, given a connected reductive group over the complexes (or more generally any smooth affine group scheme of finite type over the complexes), I would like to be able to take the associated complex Lie group, and I'd like to do the same thing over the $p$-adic numbers. Right now I'm a bit unclear about how best to state this in Lean. </p>\n<p>When we finally get on to moduli spaces, we are going to have to be able to talk about families of elliptic curves over an arbitrary base scheme, because in general moduli spaces aren't affine, and when we're there we really will need non-affine group varieties over non-affine schemes.</p>",
        "id": 425696668,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709999174
    },
    {
        "content": "<p>Eventually the definition should be \"group object in the category of schemes over S\" right? Are you saying you want a more concrete, intermediate definition, while the general group scheme theory is not sufficiently developed?</p>",
        "id": 425698707,
        "sender_full_name": "Christian Merten",
        "timestamp": 1710000850
    },
    {
        "content": "<p>Is that definitely true? Writing <code>Mon_</code> and <code>Grp_</code> reminds me awfully of version 2 of schemes, which had <code>SheafOfTypes</code> and <code>SheafOfCommRings</code>. The prefix <code>SheafOf</code> is playing a very similar role to <code>_</code> there. Version 3 of schemes used category theory (<code>SheafOf Type</code>, <code>SheatOf CommRing</code>) and was the version which made it into mathlib. Adam Topaz was suggesting a more lawvereian approach for monoid objects, group objects etc which works for all algebraic structures and is more natural.</p>",
        "id": 425699820,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710001734
    },
    {
        "content": "<p>It begins with <a href=\"https://github.com/leanprover-community/mathlib4/pull/11248\">#11248</a> so please feel free to review :-)</p>",
        "id": 425699956,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710001822
    },
    {
        "content": "<p>Is there an outline somewhere? Or a followup PR to <a href=\"https://github.com/leanprover-community/mathlib4/pull/11248\">#11248</a>?</p>",
        "id": 425700975,
        "sender_full_name": "Christian Merten",
        "timestamp": 1710002630
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> ?</p>",
        "id": 425701471,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710002959
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Definition.20of.20group.20scheme.3F/near/425699820\">said</a>:</p>\n<blockquote>\n<p>Is that definitely true? Writing <code>Mon_</code> and <code>Grp_</code> reminds me awfully of version 2 of schemes, which had <code>SheafOfTypes</code> and <code>SheafOfCommRings</code>. The prefix <code>SheafOf</code> is playing a very similar role to <code>_</code> there. Version 3 of schemes used category theory (<code>SheafOf Type</code>, <code>SheatOf CommRing</code>) and was the version which made it into mathlib. Adam Topaz was suggesting a more lawvereian approach for monoid objects, group objects etc which works for all algebraic structures and is more natural.</p>\n</blockquote>\n<p>Maybe something like this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Category.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.ConcreteCategory.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Yoneda</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ConcreteCategory</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">DObj</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"n\">where</span>\n  <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span>\n  <span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span>\n  <span class=\"n\">fac</span> <span class=\"o\">:</span> <span class=\"n\">str</span> <span class=\"bp\">⋙</span> <span class=\"n\">forget</span> <span class=\"n\">D</span> <span class=\"bp\">=</span> <span class=\"n\">yoneda.obj</span> <span class=\"n\">X</span>\n</code></pre></div>",
        "id": 425701625,
        "sender_full_name": "Christian Merten",
        "timestamp": 1710003075
    },
    {
        "content": "<p>A group object in <code>C</code> is <code>DObj C GroupCat</code>.</p>",
        "id": 425701668,
        "sender_full_name": "Christian Merten",
        "timestamp": 1710003112
    },
    {
        "content": "<p>You should just come to my (online) talk on Thursday</p>",
        "id": 425702130,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1710003420
    },
    {
        "content": "<p>Where do I find a link?</p>",
        "id": 425702269,
        "sender_full_name": "Christian Merten",
        "timestamp": 1710003524
    },
    {
        "content": "<p>I’m not sure</p>",
        "id": 425702472,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1710003681
    },
    {
        "content": "<p>I think there will be an announcement at some point.</p>",
        "id": 425702511,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1710003714
    },
    {
        "content": "<p>FWIW I think the case of groups is sufficiently important that we should have various approaches, including using yoneda as above, and provide explicit equivalences between the various cats</p>",
        "id": 425703383,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1710004335
    },
    {
        "content": "<p>I think the yoneda approach is actually quite good. But it’s not as elegant when you have an algebraic theory with more than one sort.</p>",
        "id": 425703449,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1710004403
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Definition.20of.20group.20scheme.3F/near/425703449\">said</a>:</p>\n<blockquote>\n<p>I think the yoneda approach is actually quite good. But it’s not as elegant when you have an algebraic theory with more than one sort.</p>\n</blockquote>\n<p>You mean, if you want to consider objects that have factorisations of <code>yoneda.obj X</code> for multiple categories <code>D</code>?</p>",
        "id": 425704024,
        "sender_full_name": "Christian Merten",
        "timestamp": 1710004861
    },
    {
        "content": "<p>No not quite. With two sorts you will need two “carrier” objects, etc. So this means you will need a new bespoke structure for n-sorted internal objects, one for every n.</p>",
        "id": 425704151,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1710004972
    },
    {
        "content": "<p>OTOH if you have a Lawvere theory L, the internal objects associated to L are always the product preserving functors from L to C, no matter how many sorts are involved.</p>",
        "id": 425704359,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1710005154
    },
    {
        "content": "<p>The main thing I’ve been working on is setting this up in such a way so that this approach has good definitional properties.</p>",
        "id": 425704416,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1710005186
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Definition.20of.20group.20scheme.3F/near/425704151\">said</a>:</p>\n<blockquote>\n<p>No not quite. With two sorts you will need two “carrier” objects, etc. So this means you will need a new bespoke structure for n-sorted internal objects, one for every n.</p>\n</blockquote>\n<p>Ah, for example module objects over some monoid?</p>",
        "id": 425704448,
        "sender_full_name": "Christian Merten",
        "timestamp": 1710005213
    },
    {
        "content": "<p>I see, I will wait for your talk then before asking more questions :)</p>",
        "id": 425704893,
        "sender_full_name": "Christian Merten",
        "timestamp": 1710005565
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Definition.20of.20group.20scheme.3F/near/425701625\">said</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ConcreteCategory</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">DObj</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"n\">where</span>\n  <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span>\n  <span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span>\n  <span class=\"n\">fac</span> <span class=\"o\">:</span> <span class=\"n\">str</span> <span class=\"bp\">⋙</span> <span class=\"n\">forget</span> <span class=\"n\">D</span> <span class=\"bp\">=</span> <span class=\"n\">yoneda.obj</span> <span class=\"n\">X</span>\n</code></pre></div>\n<p>With an isomorphism instead of an equality, this is what I do at <a href=\"https://github.com/leanprover-community/mathlib4/blob/jriou_localization/Mathlib/CategoryTheory/Internal/Basic.lean#L16-L19\">https://github.com/leanprover-community/mathlib4/blob/jriou_localization/Mathlib/CategoryTheory/Internal/Basic.lean#L16-L19</a></p>\n<p>With this approach, it is very easy to construct some group schemes: 1) we first define a contravariant functor from schemes to groups (e.g. units, <code>GL_n</code> of global sections) and 2) we show that when forgetting the group structure it is representable.</p>\n<p>In order to develop more localization of triangulated categories (e.g. derived categories), I would need some version of this (or at least that if <code>F : C ⥤ D</code> is a functor which preserves finite products (between categories where finite products exists), then there is a obvious functor from abelian group objects in <code>C</code> to abelian group objects in <code>D</code>).</p>",
        "id": 425718440,
        "sender_full_name": "Joël Riou",
        "timestamp": 1710018190
    },
    {
        "content": "<p>Where does this come up in localization of triangulated categories?</p>",
        "id": 425719220,
        "sender_full_name": "Christian Merten",
        "timestamp": 1710018918
    },
    {
        "content": "<p>This is to show that under suitable assumptions, a localization of an additive category is also additive. I do this by showing that every object in the localization is endowed with a natural abelian group structure <a href=\"https://github.com/leanprover-community/mathlib4/blob/jriou_localization/Mathlib/CategoryTheory/Localization/Preadditive.lean#L21-L26\">https://github.com/leanprover-community/mathlib4/blob/jriou_localization/Mathlib/CategoryTheory/Localization/Preadditive.lean#L21-L26</a></p>",
        "id": 425719563,
        "sender_full_name": "Joël Riou",
        "timestamp": 1710019273
    },
    {
        "content": "<p>Ah! Because being additive is the same as every object being an internal abelian group object via your <a href=\"https://github.com/leanprover-community/mathlib4/blob/jriou_localization/Mathlib/CategoryTheory/Internal/Preadditive.lean\">https://github.com/leanprover-community/mathlib4/blob/jriou_localization/Mathlib/CategoryTheory/Internal/Preadditive.lean</a>. But I see you already have <a href=\"https://github.com/leanprover-community/mathlib4/blob/b8729820011e68f5c14374399e1db2ce89a11efb/Mathlib/CategoryTheory/Internal/AddCommGroup.lean#L365C19-L365C45\">https://github.com/leanprover-community/mathlib4/blob/b8729820011e68f5c14374399e1db2ce89a11efb/Mathlib/CategoryTheory/Internal/AddCommGroup.lean#L365C19-L365C45</a> ?</p>",
        "id": 425720176,
        "sender_full_name": "Christian Merten",
        "timestamp": 1710019890
    },
    {
        "content": "<p>Yes, this is not speculation: I know how to do all this ;-) (But, if Adam's approach is better, I do not mind too much how exactly it is proved when it eventually reaches mathlib!)</p>",
        "id": 425720350,
        "sender_full_name": "Joël Riou",
        "timestamp": 1710020079
    },
    {
        "content": "<p>Proving that a functor which preserves products sends abelian group objects to abelian group objects would be a triviality with my approach</p>",
        "id": 425720486,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1710020243
    },
    {
        "content": "<p>But the focus isn’t on abelian group objects (or group objects more generally) in particular. I’m also interested in the multi sorted case, which should be useful for, e.g., sheaves of modules</p>",
        "id": 425720562,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1710020306
    },
    {
        "content": "<p>There’s also some meta aspects to what I’m doing :)</p>",
        "id": 425720577,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1710020337
    },
    {
        "content": "<p>Actually, I have formalized a more direct construction of the preadditive structure on localized categories (using calculus of left fractions) <a href=\"https://github.com/leanprover-community/mathlib4/pull/11728\">#11728</a>, so that we may have derived categories in mathlib sooner than expected...</p>",
        "id": 430224846,
        "sender_full_name": "Joël Riou",
        "timestamp": 1711703022
    },
    {
        "content": "<p>I merged one prereq and left a comment on the other.</p>",
        "id": 430230558,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711705893
    }
]