[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> recently generalised <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.ae#doc\">docs#MeasureTheory.ae</a> so that it would work with <code>μ : OuterMeasure Ω</code>. However as a result it doesn't work with <code>μ : FiniteMeasure Ω</code> (nor <code>μ : ProbabilityMeasure Ω</code>) anymore.</p>",
        "id": 441657925,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1717147132
    },
    {
        "content": "<p>The reason is that, when <code>μ : FiniteMeasure Ω</code>, we were able to just write <code>f =ᵐ[μ] g</code> and Lean would automatically insert the coercion to get <code>f =ᵐ[↑μ] g</code>, as opposed to now where it tries to synthesize <code>OuterMeasureClass (FiniteMeasure Ω) (Set Ω) ℝ≥0∞</code>, which doesn't exist.</p>",
        "id": 441658672,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1717147351
    },
    {
        "content": "<p>I see four ways out:</p>\n<ol>\n<li>Write <code>f =ᵐ[(μ : Measure Ω)] g</code> everywhere. Kind of defeats the point of having a notation in the first place.</li>\n<li>We add <code>FunLike</code> and <code>OuterMeasureClass</code> instances for <code>FiniteMeasure Ω</code>/<code>ProbabilityMeasure Ω</code>. I am doing that in <a href=\"https://github.com/leanprover-community/mathlib4/pull/13171\">#13171</a> because that's needed anyway for other reasons (the <code>CoeFun</code> for <code>FiniteMeasure Ω</code>/<code>ProbabilityMeasure Ω</code> unfolds to a lambda, so simp can't index any lemma of the form <code>⇑μ _ = _</code>). However there is a catch: The instance I'm adding is <code>OuterMeasureClass (FiniteMeasure Ω) (Set Ω) ℝ≥0</code>, not <code>OuterMeasureClass (FiniteMeasure Ω) (Set Ω) ℝ≥0∞</code> and I don't think we want the latter. So that doesn't really solve the problem unless we also generalise away the <code>ℝ≥0</code>/<code>ℝ≥0∞</code> codomain, which sounds like overengineering.</li>\n<li>We revert the generalisation.</li>\n<li>We write a more robust elaborator for <code>f =ᵐ[μ] g</code>. Then we might want to reconsider the generalisation: There might be a way to not introduce <code>OuterMeasureClass</code> by getting the elaborator to do more work.</li>\n</ol>",
        "id": 441659625,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1717147656
    },
    {
        "content": "<p>I think (4) is the only reasonable alternative.</p>",
        "id": 441659669,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1717147673
    },
    {
        "content": "<p>Context is bumping PFR: <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture\">https://leanprover.zulipchat.com/#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture</a></p>",
        "id": 441659847,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1717147729
    },
    {
        "content": "<p>The generalization is not just to have the notation <code>f =ᵐ[μ] g</code>, it's mainly to be able to prove simultaneously many lemmas both for measures and outer measures, see the content of the file <code>MeasureTheory.OuterMeasure.Basic</code>.</p>\n<p>I agree with you that the natural <code>FunLike</code> instance on <code>FiniteMeasure</code> takes values in <code>ℝ≥0</code>, not <code>ℝ≥0∞</code>. And still it would be nice to be able to talk about <code>ae μ</code> in a transparent way when <code>μ</code> is a finite measure. Would it work to <em>not</em> use the <code>FunLike</code> mechanism for <code>OuterMeasureClass</code>, but instead register a tailor-made class?</p>",
        "id": 441662583,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1717148547
    },
    {
        "content": "<p>I am answering my own question: not really, because lemmas in <code>MeasureTheory.OuterMeasure.Basic</code> are phrased in terms of the <code>FunLike</code> instance, so if there is no such instance then the lemmas can't even be stated.</p>",
        "id": 441662794,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1717148620
    },
    {
        "content": "<p>Yep. The one way to solve it would be axiomatise <code>ℝ≥0</code>/<code>ℝ≥0∞</code></p>",
        "id": 441662949,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1717148661
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sébastien Gouëzel</span> <a href=\"#narrow/stream/287929-mathlib4/topic/ae.20of.20a.20finite.20measure/near/441662583\">said</a>:</p>\n<blockquote>\n<p>The generalization is not just to have the notation <code>f =ᵐ[μ] g</code>, it's mainly to be able to prove simultaneously many lemmas both for measures and outer measures, see the content of the file <code>MeasureTheory.OuterMeasure.Basic</code>.</p>\n</blockquote>\n<p>Yes, I am aware.</p>",
        "id": 441663116,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1717148719
    },
    {
        "content": "<p>I'd say for now the reasonable solution is to use <code>f =ᵐ[(μ : Measure Ω)] g</code> just for the bump, and see if we can improve the elaborator. It's not unreasonable: we are really using the coercion to measures, after all!</p>",
        "id": 441663799,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1717148912
    },
    {
        "content": "<p>Could this be solved with scoped notation overriding  <code>f =ᵐ[μ] g</code>?</p>",
        "id": 441703185,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1717161073
    },
    {
        "content": "<p>Yeah sure, but like the notation should Just Work <span aria-label=\"tm\" class=\"emoji emoji-2122\" role=\"img\" title=\"tm\">:tm:</span></p>",
        "id": 441811060,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1717191378
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/287929-mathlib4/topic/ae.20of.20a.20finite.20measure/near/441659625\">said</a>:</p>\n<blockquote>\n<ol start=\"2\">\n<li>We add <code>FunLike</code> and <code>OuterMeasureClass</code> instances for <code>FiniteMeasure Ω</code>/<code>ProbabilityMeasure Ω</code>.</li>\n</ol>\n</blockquote>\n<p>Update: <a href=\"https://github.com/leanprover-community/mathlib4/pull/13171\">#13171</a> now passes CI. I don't think it will directly help with the problem at hand, but at least it won't hurt</p>",
        "id": 441811199,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1717191422
    },
    {
        "content": "<p>I can generalize to <code>NNReal/ENNReal</code> this weekend. I'm sorry for breaking it for you.</p>",
        "id": 441825082,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1717197521
    },
    {
        "content": "<p>Is there really anything to generalize? Even when mu is a <code>FiniteMeasure</code>, the associated a.e. filter should be the one associated to the corresponding measure, right? The problem is more that the notation <code>f =ᵐ[μ] g</code> is not firing because the coercion from finite measures to measures can not be inserted automatically here. In an ideal world, this notation could mean: if <code>μ</code> is an <code>OuterMeasureClass</code>, then use it, otherwise try to coerce <code>μ</code> to a measure. In the real world, I think I like Richard's idea to have a scoped notation that would insert the coercion to measures (so, it would fail for outer measures, but work for FiniteMeasure or ProbabilityMeasure) that one would activate when needed. Since one essentially never uses FiniteMeasure and OuterMeasure simultaneously, this should be essentially optimal, right?</p>",
        "id": 441873645,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1717229514
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sébastien Gouëzel</span> <a href=\"#narrow/stream/287929-mathlib4/topic/ae.20of.20a.20finite.20measure/near/441873645\">said</a>:</p>\n<blockquote>\n<p>Since one essentially never uses FiniteMeasure and OuterMeasure simultaneously, this should be essentially optimal, right?</p>\n</blockquote>\n<p>Lean 4's notation capabilities are so great that I say \"No, we can make one notation work in all cases\".</p>",
        "id": 441873774,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1717229587
    },
    {
        "content": "<p>It's not very hard, just some expected type manipulation. If nobody has managed it in 10 days (aka when my exams end), I'll do it quickly</p>",
        "id": 441873847,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1717229640
    },
    {
        "content": "<p>I have opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/13740\">#13740</a>, but I need help</p>",
        "id": 444080804,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718133630
    }
]