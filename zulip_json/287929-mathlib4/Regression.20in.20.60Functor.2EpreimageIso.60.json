[
    {
        "content": "<p>Before <a href=\"https://github.com/leanprover-community/mathlib4/pull/12449\">#12449</a> was merged, the last sorry in </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Condensed.TopComparison</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Condensed.LocallyConstant</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">The functor from the category of sets to presheaves on `CompHaus` given by locally constant maps.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simps</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">functorToPresheaves</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"bp\">⥤</span> <span class=\"o\">(</span><span class=\"n\">CompHaus.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">obj</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">S</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span> <span class=\"n\">LocallyConstant</span> <span class=\"n\">S</span> <span class=\"n\">X</span>\n    <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">↦</span> <span class=\"n\">g.comap</span> <span class=\"n\">f.unop</span> <span class=\"o\">}</span>\n  <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">app</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">S</span> <span class=\"n\">t</span> <span class=\"bp\">↦</span> <span class=\"n\">t.map</span> <span class=\"n\">f</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Locally constant maps are the same as continuous maps when the target is equipped with the discrete</span>\n<span class=\"sd\">topology</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simps</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">locallyConstantIsoContinuousMap</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">LocallyConstant</span> <span class=\"n\">Y</span> <span class=\"n\">X</span> <span class=\"bp\">≅</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">TopCat.discrete.obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"bp\">⊥</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">DiscreteTopology</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n  <span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n    <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">IsLocallyConstant.iff_continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">f.2</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- `locallyConstantIsoContinuousMap` is a natural isomorphism. -/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">functorToPresheavesIsoTopCatToCondensed</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">functorToPresheaves.obj</span> <span class=\"n\">X</span> <span class=\"bp\">≅</span> <span class=\"o\">(</span><span class=\"n\">topCatToCondensed.obj</span> <span class=\"o\">(</span><span class=\"n\">TopCat.discrete.obj</span> <span class=\"n\">X</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">:=</span>\n  <span class=\"n\">NatIso.ofComponents</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">S</span> <span class=\"bp\">↦</span> <span class=\"n\">locallyConstantIsoContinuousMap</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- `Condensed.LocallyConstant.functorToPresheaves` lands in condensed sets. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simps</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">functor</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">⥤</span> <span class=\"n\">CondensedSet.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">where</span>\n  <span class=\"n\">obj</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">functorToPresheaves.obj</span> <span class=\"n\">X</span>\n    <span class=\"n\">cond</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Presheaf.isSheaf_of_iso_iff</span> <span class=\"o\">(</span><span class=\"n\">functorToPresheavesIsoTopCatToCondensed</span> <span class=\"n\">X</span><span class=\"o\">)]</span>\n      <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">topCatToCondensed.obj</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cond</span>\n  <span class=\"o\">}</span>\n  <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">functorToPresheaves.map</span> <span class=\"n\">f</span><span class=\"o\">⟩</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">`Condensed.LocallyConstant.functor` is naturally isomorphic to the restriction of</span>\n<span class=\"sd\">`topCatToCondensed` to discrete topological spaces.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">functorIsoTopCatToCondensed</span> <span class=\"o\">:</span> <span class=\"n\">functor</span> <span class=\"bp\">≅</span> <span class=\"n\">TopCat.discrete</span> <span class=\"bp\">⋙</span> <span class=\"n\">topCatToCondensed</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">NatIso.ofComponents</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">X</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">sheafToPresheaf</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">preimageIso</span>\n    <span class=\"o\">(</span><span class=\"n\">functorToPresheavesIsoTopCatToCondensed</span> <span class=\"n\">X</span><span class=\"o\">))</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>was completed by automation, but not anymore, now that <code>Functor.preimage</code> is defined by <code>Exists.choose</code>. How are we supposed to work with full functors where there is a \"preferred\" preimage? There is an easy workaround that I could use here, just define something like <code>Sheaf.isoEquiv</code> analogous to <code>Sheaf.homEquiv</code> that I think Joël added in this PR. But shouldn't we have more general API to work with this type of \"canonically fully faithful\" functors / actual inclusion functors?</p>",
        "id": 435993955,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1714382337
    },
    {
        "content": "<p>Maybe this is just lean having problems unifying <code>f.val</code> with <code>(sheafToPresheaf _ _).map f</code>, but I wonder what caused automation to break...</p>",
        "id": 435999494,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1714383890
    },
    {
        "content": "<p>Maybe we can add a type-valued <code>FullyFaithful</code> structure that is not a class? Are there any full functors that are not faithful but have a \"preferred preimage\"?<br>\ncc <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span></p>",
        "id": 436025437,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1714392081
    },
    {
        "content": "<p>I think the most reasonable fix is to define <code>Sheaf.isoEquiv</code>.</p>",
        "id": 436026603,
        "sender_full_name": "Joël Riou",
        "timestamp": 1714392445
    },
    {
        "content": "<p>Yeah but you needed to add plenty of such definitions throughout the refactor for <code>yoneda</code> and <code>SheafedSpace.toPresheafedSpace</code> etc, and defining a separate <code>isoEquiv</code> for each fully faithful embedding we have isn't scalable IMHO.</p>",
        "id": 436028478,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1714392973
    },
    {
        "content": "<p>I do not mind if someone makes the effort of developing this <code>FullyFaithful</code> API! Then, presumably, given <code>data : F.FullyFaithful</code>, we would define <code>data.homEquiv</code>, <code>data.isoEquiv</code>, and once these data are defined for (yoneda/sheaves/SheafedSpace), <code>Sheaf.homEquiv</code> should be defined as an abbreviation for <code>data.homEquiv</code>, etc.</p>\n<p>The API should also contain, <code>FullyFaithful.whisker</code>: if <code>F</code> is fully faithful, the postcomposition with <code>F</code> is also fully faithful. Then, we could get <code>coyoneda.preimageNatTrans</code> and <code>coyoneda.preimageNatIso</code>.</p>",
        "id": 436031876,
        "sender_full_name": "Joël Riou",
        "timestamp": 1714393912
    }
]