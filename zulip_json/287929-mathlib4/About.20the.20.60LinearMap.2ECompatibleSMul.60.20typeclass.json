[
    {
        "content": "<p>It seems like the standard usage of the <code>LinearMap.CompatibleSMul M M₂ R S</code> typeclass, at least the one which is generated by instance resolution, is the case where <code>[IsScalarTower R S M]</code> and <code>[IsScalarTower R S M₂]</code> (in standard math language, when <code>S</code> is an <code>R</code>-algebra and <code>M</code>, <code>M₂</code> are <code>S</code>-modules). But the predicate is also be true if <code>R</code>  is a solid <code>S</code>-algebra, i.e. one for which the restriction of scalars <code>R-Mod -&gt; S-Mod</code> is fully faithful (hence a reflective embedding). We can't express this in terms of typeclasses (unless we add a <code>[IsSolid S R]</code> typeclass, which might be useful?) but in the specific cases where <code>R</code> is a localization or quotient of <code>S</code> we could add an instance <code>[LinearMap.CompatibleSMul M M₂ R S]</code>. Is there a reason not to do this? I think the <code>LinearMap.CompatibleSMul</code> typeclass is intended for the case where <code>S</code> is an <code>R</code>-algebra, but I don't see any place things would break in the reverse situation.</p>",
        "id": 437055279,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1714860174
    },
    {
        "content": "<p>(this usage of the term solid is unrelated to and predates its usage in condensed mathematics)</p>",
        "id": 437055372,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1714860254
    },
    {
        "content": "<p>I created <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.CompatibleSMul#doc\">docs#LinearMap.CompatibleSMul</a>` pretty much just to allow some questionable generalizations on the border of rings and semirings; if you only care about rings, I think you can stick to the more general scalar compatibility classes.</p>",
        "id": 437059022,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714864292
    },
    {
        "content": "<p>(<a href=\"https://github.com/leanprover-community/mathlib4/pull/12671\">#12671</a> fixes a typo in its docstring)</p>",
        "id": 437088888,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714894853
    },
    {
        "content": "<p>Oh huh I thought it served a different purpose because it showed up in <code>LinearEquiv.restrictScalars</code>. It was that that I wanted to use to go from an R-linear equivalence to an (R/I)-linear equivalence</p>",
        "id": 437089007,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1714894943
    },
    {
        "content": "<p>Well I guess I have the same questions about scalar towers. But I'd guess there's a reason we don't want to have cycles there...</p>",
        "id": 437089021,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1714894965
    },
    {
        "content": "<p>There <em>was</em> a reason we didn't want to have cycles (lean 3 didn't like them...)</p>",
        "id": 437098164,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1714903151
    },
    {
        "content": "<p>I think nontrivial cycles can still be pretty bad for performance</p>",
        "id": 437100536,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714905450
    }
]