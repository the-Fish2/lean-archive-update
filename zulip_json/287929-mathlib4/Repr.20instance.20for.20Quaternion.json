[
    {
        "content": "<p>In another thread there was some discussion about a Repr instance for Quaternions. Two potentially reasonable options are</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">One</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Neg</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Quaternion</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">reprPrec</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"</span><span class=\"err\">\\</span><span class=\"s2\">{ re := {repr q.re}, imI := {repr q.imI}, imJ := {repr q.imJ}, imK := {repr q.imK} }\"</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>which mirrors the way a Quaternion is constructed as input. </p>\n<p>Another suggestion was to mimic what was done for Complex</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">One</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Neg</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Repr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Quaternion</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">reprPrec</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{repr q.re} + {repr q.imI}*I + {repr q.imJ}*J + {repr q.imK}*K\"</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>With this second option we would probably want to introduce a <code>notation</code> to match. </p>\n<p>And of course there may be a better third option not yet considered. Any thoughts <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> ?</p>",
        "id": 444791106,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1718399688
    },
    {
        "content": "<p>I have no opinion. I have no plans to use quaternions in the near future.</p>",
        "id": 444791261,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1718399754
    },
    {
        "content": "<p>My suggestion there was that we could have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">QuaternionAlgebra</span><span class=\"bp\">.</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">re</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">im_i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>and then change the simp-normal forms everywhere</p>",
        "id": 444791358,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718399801
    },
    {
        "content": "<p>My only suggestion is that would be best to have brackets around it, then it makes combining types easier. e.g. <code>DualNumber (Quaternion Int)</code>. I don't think things are very consistent since <code>GaussianInt</code> is represented as <code>⟨ 3, 4⟩</code> but <code>DualNumber  Int</code>is represented  <code>3 + 4*ε</code>. So probably doesn't really matter.</p>",
        "id": 444819328,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718418805
    },
    {
        "content": "<p>It would be nice to have consistent and combinable reprs.</p>",
        "id": 444851029,
        "sender_full_name": "Utensil Song",
        "timestamp": 1718447015
    },
    {
        "content": "<p>This is what the prec argument of <code>reprPrec</code> is for</p>",
        "id": 444852697,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718448522
    },
    {
        "content": "<p>The parentheses are only added when needed</p>",
        "id": 444852704,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718448531
    },
    {
        "content": "<p>Take a look at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Complex.instRepr#src\">src#Complex.instRepr</a></p>",
        "id": 444852800,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718448576
    },
    {
        "content": "<p>I just created <a href=\"https://github.com/leanprover-community/mathlib4/pull/13940\">#13940</a> to add a Repr instance for quaternions. I chose the <code>\"{ re := w, imI := x, imJ := y, imK := z }\"</code> format, where each of <code>w, x, y, z</code> are formatted according to their type. In particular, if they are Reals, then the components display as Cauchy sequences. </p>\n<p>This is my first PR so I'm quite happy to receive any suggestions for improvement.</p>",
        "id": 445464602,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1718745928
    }
]