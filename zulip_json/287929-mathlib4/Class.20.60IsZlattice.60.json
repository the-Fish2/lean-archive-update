[
    {
        "content": "<p>Is it a good idea to define the class <code>IsZlattice</code> in <code>Mathlib/Algebra/Module/Zlattice.lean</code>, say something like: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">IsZlattice</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NormedLinearOrderedField</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">HasSolidNorm</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FloorRing</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">K</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"n\">K</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ProperSpace</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">AddSubgroup</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DiscreteTopology</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- `L` spans the full space `E` over `K`. -/</span>\n  <span class=\"n\">span_top</span> <span class=\"o\">:</span> <span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span>\n</code></pre></div>\n<p>That would make things a bit cleaner since, at the moment , we need to pass directly the hypothesis:<code>(hs :  span K (L : Set E) = ⊤)</code> to the different lemmas about ℤ-lattices. Unfortunately, Lean cannot infer directly from this class that a ℤ-lattice is a finite module or free module because of synthesization order... </p>\n<p>See <a href=\"https://github.com/leanprover-community/mathlib4/pull/11356\">#11356</a> to see what it would look like.</p>",
        "id": 426301607,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1710325060
    },
    {
        "content": "<p>What about assuming the existence of <code>L</code> rather than giving it?</p>",
        "id": 426316485,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1710329862
    },
    {
        "content": "<p>I am not sure I understand what you mean</p>",
        "id": 426316764,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1710329950
    },
    {
        "content": "<p>span_top would instead read Exists L,...</p>",
        "id": 426317561,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1710330219
    },
    {
        "content": "<p>Maybe I am confused and I need a coffee, but I mean something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">IsZlattice</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NormedLinearOrderedField</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">HasSolidNorm</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FloorRing</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">K</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"n\">K</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ProperSpace</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- `L` spans the full space `E` over `K`. -/</span>\n  <span class=\"n\">span_top</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">AddSubgroup</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"n\">DiscreteTopology</span> <span class=\"n\">L</span> <span class=\"bp\">∧</span> <span class=\"n\">Submodule.span</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span>\n</code></pre></div>\n<p>(this would not solve the synthesization order of course, it is a general remark)</p>",
        "id": 426317607,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1710330242
    },
    {
        "content": "<p>But the class is about <code>L</code>. It is there to characterise <code>L</code> when used as an argument in lemmas. Right now, the hypothesis <code>(hs : span K (L : Set E) = ⊤)</code> as to be provided to these lemmas and I thought using a class instead was a more elegant way to do it.</p>",
        "id": 426318094,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1710330411
    },
    {
        "content": "<p>Ah yes, the lattice is <code>L</code>, sorry for the noise.</p>",
        "id": 426319060,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1710330789
    },
    {
        "content": "<p>Does it make sense to define it as a discrete module over a blabla ring such that the tensorization with the field of fraction is finite dimensional?</p>",
        "id": 426319449,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1710330925
    },
    {
        "content": "<p>No, ok, I need a coffee</p>",
        "id": 426319632,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1710330993
    },
    {
        "content": "<p>It needs the whole space of course</p>",
        "id": 426319646,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1710331001
    },
    {
        "content": "<p>I mean we could say that the tensorization by <code>K</code> (which you can think of as being <code>ℝ</code>) is equal to <code>E</code>. That would be another way to spell <code>span_top</code>.</p>",
        "id": 426319980,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1710331098
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ProperSpace</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">AddSubgroup</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DiscreteTopology</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsZlattice</span> <span class=\"n\">ℝ</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Module.Finite</span> <span class=\"n\">ℤ</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>is OK, right? So even if we don't have the general instance we can have the relevant ones.</p>",
        "id": 426321244,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1710331532
    },
    {
        "content": "<p>I am not in front of a computer so I cannot make sure it works but I think you are right: this should work and it is actually what we need.</p>",
        "id": 426321970,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1710331771
    },
    {
        "content": "<p>Another possibility is to define the <em>type</em> of lattices</p>",
        "id": 426321992,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1710331777
    },
    {
        "content": "<p>Defining the instances as you suggested above  works great. Lean can infer now in <code>NumberField.Units</code> that  the <code>unitLattice</code> is a finite and free module  automatically from the fact that it is a <code>Zlattice</code>, see <a href=\"https://github.com/leanprover-community/mathlib4/pull/11356\">#11356</a></p>",
        "id": 426395648,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1710351937
    },
    {
        "content": "<p>But why the preference for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span>? In <span class=\"user-mention\" data-user-id=\"488648\">@Xavier Roblot</span> 's first version we would have that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">O</mi><mi>K</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">K</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>-lattice for a finite <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mi mathvariant=\"normal\">/</mi><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">K/\\mathbb{Q}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>, and we certainly do not want to duplicate this class in all possible cases.</p>",
        "id": 426496813,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1710407360
    },
    {
        "content": "<p>The results in <code>Mathlib.Algebra.Module.Zlattice.lean</code> are proved for <code>ℤ</code>-lattices and the class is there to make it easier to use these results. Now, there will probably be the need to define a more general class of lattices over other rings as suggested by <span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> eventually and which point we should replace the class <code>IsZlattice</code> by a more general class or as a special case of the more general class. But that would belong to another file (and another project), I guess.</p>",
        "id": 426501342,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1710408860
    }
]