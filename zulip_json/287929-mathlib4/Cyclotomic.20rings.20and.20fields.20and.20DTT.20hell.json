[
    {
        "content": "<p>I am trying to produce the obvioud ℤ-algebra isomorphism between <code>CyclotomicRing 3 ℤ ℚ</code>and the ring of integers of <code>CyclotomicField 3 ℚ</code>. There is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsPrimitiveRoot.adjoinEquivRingOfIntegers%27#doc\">docs#IsPrimitiveRoot.adjoinEquivRingOfIntegers'</a>, which gives </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Algebra.adjoin</span> <span class=\"n\">ℤ</span> <span class=\"o\">{</span><span class=\"n\">μ</span><span class=\"o\">})</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">ℤ</span><span class=\"o\">]</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">NumberField.ringOfIntegers</span> <span class=\"o\">(</span><span class=\"n\">CyclotomicField</span> <span class=\"mi\">3</span> <span class=\"n\">ℚ</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>(here <code>μ</code> is a primitive cube root of unity in <code>CyclotomicField 3 ℚ</code>). [Aside: this needs <code>Fact (Nat.Prime (3 : ℕ+))</code> to be available as an instance, which is a minor annoyance.]<br>\nSo now I'm left with constructing</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">CyclotomicRing</span> <span class=\"mi\">3</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">ℤ</span><span class=\"o\">]</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Algebra.adjoin</span> <span class=\"n\">ℤ</span> <span class=\"o\">{</span><span class=\"n\">μ</span><span class=\"o\">})</span>\n</code></pre></div>\n<p>There is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CyclotomicRing.eq_adjoin_primitive_root#doc\">docs#CyclotomicRing.eq_adjoin_primitive_root</a>, which says that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">CyclotomicRing</span> <span class=\"mi\">3</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span> <span class=\"bp\">=</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Algebra.adjoin</span> <span class=\"n\">ℤ</span> <span class=\"o\">{</span><span class=\"n\">μ</span><span class=\"o\">})</span>\n</code></pre></div>\n<p>so this should be easy, one would think. However:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">PNat.three_prime</span> <span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Nat.Prime</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Nat.prime_three</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">CyclotomicField</span> <span class=\"mi\">3</span> <span class=\"n\">ℚ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hμ</span> <span class=\"o\">:</span> <span class=\"n\">IsPrimitiveRoot</span> <span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">))</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">ι'</span> <span class=\"c\">/-</span><span class=\"cm\"> : CyclotomicRing 3 ℤ ℚ ≃ₐ[ℤ] ↥(NumberField.ringOfIntegers (CyclotomicField 3 ℚ)) -/</span> <span class=\"o\">:=</span>\n  <span class=\"n\">CyclotomicRing.eq_adjoin_primitive_root</span> <span class=\"mi\">3</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span> <span class=\"n\">hμ</span> <span class=\"bp\">▸</span> <span class=\"n\">hμ.adjoinEquivRingOfIntegers'</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">ι'</span> <span class=\"n\">hμ</span> <span class=\"c1\">-- ι' hμ : ↥(Algebra.adjoin ℤ {μ}) ≃ₐ[ℤ] ↥(NumberField.ringOfIntegers (CyclotomicField 3 ℚ))</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">CyclotomicRing</span> <span class=\"mi\">3</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">ℤ</span><span class=\"o\">]</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Algebra.adjoin</span> <span class=\"n\">ℤ</span> <span class=\"o\">{</span><span class=\"n\">μ</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">convert</span> <span class=\"n\">AlgEquiv.refl</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A₁</span> <span class=\"o\">:=</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Algebra.adjoin</span> <span class=\"n\">ℤ</span> <span class=\"o\">{</span><span class=\"n\">μ</span><span class=\"o\">}))</span> <span class=\"n\">using</span> <span class=\"mi\">1</span> <span class=\"k\">with</span> <span class=\"n\">h</span> <span class=\"n\">h'</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">CyclotomicRing.eq_adjoin_primitive_root</span> <span class=\"mi\">3</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span> <span class=\"n\">hμ</span>\n  <span class=\"bp\">·</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- HEq CommSemiring.toSemiring (Subalgebra.toSemiring (Algebra.adjoin ℤ {μ})); more detail:</span>\n    <span class=\"c1\">-- Heq (@CommSemiring.toSemiring (CyclotomicRing 3 ℤ ℚ) CommRing.toCommSemiring)</span>\n    <span class=\"c1\">--   (@Subalgebra.toSemiring ℤ (CyclotomicField 3 ℚ) Int.instCommSemiringInt DivisionSemiring.toSemiring</span>\n    <span class=\"c1\">--   (CyclotomicField.algebra' 3 ℚ) (Algebra.adjoin ℤ {μ}))</span>\n  <span class=\"bp\">.</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- HEq (CyclotomicRing.algebraBase 3 ℤ ℚ) (Subalgebra.algebra (Algebra.adjoin ℤ {μ}))</span>\n    <span class=\"c1\">-- Heq (@CyclotomicRing.algebraBase 3 ℤ ℚ Int.instCommRingInt Rat.field (algebraInt ℚ)); more detail:</span>\n    <span class=\"c1\">--   (@Subalgebra.algebra ℤ (CyclotomicField 3 ℚ) Int.instCommSemiringInt DivisionSemiring.toSemiring</span>\n    <span class=\"c1\">--   (CyclotomicField.algebra' 3 ℚ) (Algebra.adjoin ℤ {μ}))</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">ι''</span> <span class=\"o\">:</span> <span class=\"n\">CyclotomicRing</span> <span class=\"mi\">3</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">ℤ</span><span class=\"o\">]</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">NumberField.ringOfIntegers</span> <span class=\"o\">(</span><span class=\"n\">CyclotomicField</span> <span class=\"mi\">3</span> <span class=\"n\">ℚ</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"n\">CyclotomicRing.eq_adjoin_primitive_root</span> <span class=\"mi\">3</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span> <span class=\"n\">hμ</span> <span class=\"bp\">▸</span> <span class=\"n\">hμ.adjoinEquivRingOfIntegers'</span>\n<span class=\"c1\">-- type mismatch</span>\n<span class=\"c1\">--   IsPrimitiveRoot.adjoinEquivRingOfIntegers' hμ</span>\n<span class=\"c1\">-- has type</span>\n<span class=\"c1\">--   @AlgEquiv ℤ (↥(Algebra.adjoin ℤ {μ})) (↥(NumberField.ringOfIntegers (CyclotomicField 3 ℚ))) Int.instCommSemiringInt</span>\n<span class=\"c1\">--     (Subalgebra.toSemiring (Algebra.adjoin ℤ {μ}))</span>\n<span class=\"c1\">--     (Subalgebra.toSemiring (NumberField.ringOfIntegers (CyclotomicField 3 ℚ)))</span>\n<span class=\"c1\">--     (Subalgebra.algebra (Algebra.adjoin ℤ {μ}))</span>\n<span class=\"c1\">--     (Subalgebra.algebra (NumberField.ringOfIntegers (CyclotomicField 3 ℚ))) : Type</span>\n<span class=\"c1\">-- but is expected to have type</span>\n<span class=\"c1\">--   @AlgEquiv ℤ (↥(Algebra.adjoin ℤ {μ})) (↥(NumberField.ringOfIntegers (CyclotomicField 3 ℚ))) Int.instCommSemiringInt</span>\n<span class=\"c1\">--     CommSemiring.toSemiring (Subalgebra.toSemiring (NumberField.ringOfIntegers (CyclotomicField 3 ℚ)))</span>\n<span class=\"c1\">--     (CyclotomicRing.algebraBase 3 ℤ ℚ) (Subalgebra.algebra (NumberField.ringOfIntegers (CyclotomicField 3 ℚ))) : Type</span>\n\n<span class=\"c1\">-- (similar error when using `(CyclotomicRing.eq_adjoin_primitive_root 3 ℤ ℚ hμ).symm ▸ ...`)</span>\n</code></pre></div>\n<p>So I'm stuck, and help would be much appreciated.<br>\nI assume the problem is that Lean cannot figure out that the algebra structures on both sides are compatible...<br>\n<span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span></p>",
        "id": 411428812,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1704486772
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CyclotomicRing.eq_adjoin_primitive_root#doc\">docs#CyclotomicRing.eq_adjoin_primitive_root</a> looks like a very weird lemma to me; equalities of types are almost never what you want</p>",
        "id": 411429311,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704487016
    },
    {
        "content": "<p>That's what I thought, too.</p>",
        "id": 411429349,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1704487039
    },
    {
        "content": "<p>Really the statement should be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Algebra.adjoin</span> <span class=\"n\">A</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">CyclotomicField</span> <span class=\"n\">n</span> <span class=\"n\">K</span> <span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"bp\">↑</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">adjoin</span> <span class=\"n\">A</span> <span class=\"o\">({</span><span class=\"n\">μ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">CyclotomicField</span> <span class=\"n\">n</span> <span class=\"n\">K</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>(which is an equality of subalgebras/sets)</p>",
        "id": 411429393,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704487067
    },
    {
        "content": "<p>Then one could probably go via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subalgebra.equivOfEq#doc\">docs#Subalgebra.equivOfEq</a>.</p>",
        "id": 411429708,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1704487214
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">PNat.three_prime</span> <span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Nat.Prime</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Nat.prime_three</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">CyclotomicField</span> <span class=\"mi\">3</span> <span class=\"n\">ℚ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hμ</span> <span class=\"o\">:</span> <span class=\"n\">IsPrimitiveRoot</span> <span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">))</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">help</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Algebra.adjoin</span> <span class=\"n\">ℤ</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">CyclotomicField</span> <span class=\"mi\">3</span> <span class=\"n\">ℚ</span> <span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">})</span> <span class=\"bp\">=</span>\n    <span class=\"n\">Algebra.adjoin</span> <span class=\"n\">ℤ</span> <span class=\"o\">({</span><span class=\"n\">μ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">CyclotomicField</span> <span class=\"mi\">3</span> <span class=\"n\">ℚ</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">Algebra.adjoin_eq_of_le</span> <span class=\"o\">(</span><span class=\"n\">Algebra.adjoin</span> <span class=\"n\">ℤ</span> <span class=\"o\">{</span><span class=\"n\">μ</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span>\n    <span class=\"n\">Algebra.adjoin_mono</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Set.singleton_subset_iff.mpr</span> <span class=\"n\">hμ.pow_eq_one</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">hm</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hμ.eq_pow_of_pow_eq_one</span> <span class=\"n\">hx</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">)</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hm</span> <span class=\"bp\">▸</span> <span class=\"n\">Subalgebra.pow_mem</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Algebra.self_mem_adjoin_singleton</span> <span class=\"n\">ℤ</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"n\">m</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">ι'</span> <span class=\"o\">:</span> <span class=\"n\">CyclotomicRing</span> <span class=\"mi\">3</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">ℤ</span><span class=\"o\">]</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">NumberField.ringOfIntegers</span> <span class=\"o\">(</span><span class=\"n\">CyclotomicField</span> <span class=\"mi\">3</span> <span class=\"n\">ℚ</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">Subalgebra.equivOfEq</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">help</span> <span class=\"n\">hμ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">hμ.adjoinEquivRingOfIntegers'</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">ι'</span> <span class=\"n\">hμ</span> <span class=\"c1\">-- CyclotomicRing 3 ℤ ℚ ≃ₐ[ℤ] ↥(NumberField.ringOfIntegers (CyclotomicField 3 ℚ))</span>\n</code></pre></div>",
        "id": 411430590,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1704487662
    },
    {
        "content": "<p>I think I wrote this a while ago and over time I think we've deprecated use of cyclotomicring, it's really not worth it and as you say an absolute mess. We should probably do some tidying in this area, cc <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span></p>",
        "id": 411431082,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704487920
    },
    {
        "content": "<p>So what is the Mathlib-canonical way of speaking about <code>ℤ[ζ]</code> for a primitive <code>n</code>th root of unity <code>ζ</code>?</p>",
        "id": 411431232,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1704487997
    },
    {
        "content": "<p><code>CyclotomicRing</code> seemed to be the natural thing to use...</p>",
        "id": 411431260,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1704488020
    },
    {
        "content": "<p>(Filled in the proof of <code>help</code> above.)</p>",
        "id": 411433701,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1704489233
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Cyclotomic.20rings.20and.20fields.20and.20DTT.20hell/near/411431232\">said</a>:</p>\n<blockquote>\n<p>So what is the Mathlib-canonical way of speaking about <code>ℤ[ζ]</code> for a primitive <code>n</code>th root of unity <code>ζ</code>?</p>\n</blockquote>\n<p>I agree with Eric and I would avoid <code>CyclotomicRing</code>. You can use <code>Algebra.adjoin ℤ {ζ}</code>. We have the instance that says that it is the ring of integer of the cyclotomic field.</p>",
        "id": 411468142,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1704509483
    },
    {
        "content": "<p>I suggest to have <code>ζ</code> of type <code>K</code>, it is a little more flexible.</p>",
        "id": 411468234,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1704509537
    },
    {
        "content": "<p>Are there plans to add the fact that <code>ℤ[ζ]</code> is the ring of integers of <code>ℚ[ζ]</code> for arbitrary <code>n</code>? I think right now it is only in Mathlib when <code>n</code> is a prime power.</p>",
        "id": 411497847,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1704538640
    },
    {
        "content": "<p>I don't think anyone is working on it, but it is something we of course want at some point.</p>",
        "id": 411497940,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1704538705
    },
    {
        "content": "<p>I don't think anyone is working on it, but it is something we of course want at some point.</p>",
        "id": 411497943,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1704538707
    },
    {
        "content": "<p>Now I am trying to prove that <code>Algebra.adjoin ℤ {μ} ≃ₐ[ℤ] Algebra.adjoin ℤ {μ'}</code>, where <code>μ : CyclotomicField 3 ℚ</code> and <code>μ' : ℂ</code> are primitive cube roots of unity, but I'm finding it hard. E.g., <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AlgEquiv.adjoinSingletonEquivAdjoinRootMinpoly#doc\">docs#AlgEquiv.adjoinSingletonEquivAdjoinRootMinpoly</a> only works over fields. (I did manage to show that <code>minpoly ℤ μ = minpoly ℤ μ'</code>, so if this were more general [it should be true over rings when the minimal polynomial is monic], I would be done.)</p>",
        "id": 411504120,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1704543768
    },
    {
        "content": "<p>I think the better way to go is to construct an embedding <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><msub><mi>ζ</mi><mn>3</mn></msub><mo stretchy=\"false\">]</mo><mo>↪</mo><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}[\\zeta_3]\\hookrightarrow \\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07378em;\">ζ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↪</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> sending μ to μ' and use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AlgHom.map_adjoin_singleton#doc\">docs#AlgHom.map_adjoin_singleton</a></p>",
        "id": 411504370,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1704544024
    },
    {
        "content": "<p>How to I get an <code>AlgEquiv</code> to the image of an injective <code>AlgHom</code>?</p>",
        "id": 411508163,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1704548070
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> AlgEquiv, <a href=\"http://Subalgebra.map\">Subalgebra.map</a>, Function.Injective</p>",
        "id": 411509619,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1704549625
    },
    {
        "content": "<p><span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> nothing found</p>",
        "id": 411509621,
        "sender_full_name": "loogle",
        "timestamp": 1704549626
    },
    {
        "content": "<p>I tried something similar, with the same result.</p>",
        "id": 411509658,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1704549653
    },
    {
        "content": "<p>We should add an <code>AlgHom</code> version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RingHom.restrict#doc\">docs#RingHom.restrict</a></p>",
        "id": 411509894,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1704549797
    },
    {
        "content": "<p>And then use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AlgEquiv.ofBijective#doc\">docs#AlgEquiv.ofBijective</a> to get something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.equivMapOfInjective#doc\">docs#Submodule.equivMapOfInjective</a></p>",
        "id": 411510108,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1704549995
    },
    {
        "content": "<p>BTW, what I did now is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">AlgEquiv</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Polynomial</span> <span class=\"n\">AdjoinRoot</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">adjoinSingletonEquivAdjoinRootMinpoly'</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsDomain</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsIntegrallyClosed</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsDomain</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">F</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NoZeroSMulDivisors</span> <span class=\"n\">F</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">IsIntegral</span> <span class=\"n\">F</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Algebra.adjoin</span> <span class=\"n\">F</span> <span class=\"o\">({</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">AdjoinRoot</span> <span class=\"o\">(</span><span class=\"n\">minpoly</span> <span class=\"n\">F</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">AlgEquiv.symm</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">AlgEquiv.ofBijective</span> <span class=\"o\">(</span><span class=\"n\">Minpoly.toAdjoin</span> <span class=\"n\">F</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨(</span><span class=\"n\">injective_iff_map_eq_zero</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"k\">fun</span> <span class=\"n\">P₁</span> <span class=\"n\">hP₁</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">Minpoly.toAdjoin.surjective</span> <span class=\"n\">F</span> <span class=\"n\">x</span><span class=\"o\">⟩</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">mk_surjective</span> <span class=\"n\">P₁</span>\n  <span class=\"n\">refine</span> <span class=\"n\">AdjoinRoot.mk_eq_zero.mpr</span> <span class=\"o\">(</span><span class=\"n\">minpoly.isIntegrallyClosed_dvd</span> <span class=\"n\">hx</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">Minpoly.toAdjoin_apply'</span><span class=\"o\">,</span> <span class=\"n\">liftHom_mk</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Subalgebra.coe_eq_zero</span><span class=\"o\">,</span> <span class=\"n\">aeval_subalgebra_coe</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hP₁</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">AlgEquiv</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">PNat.three_prime</span> <span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Nat.Prime</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Nat.prime_three</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">μ'</span> <span class=\"o\">:</span> <span class=\"n\">CyclotomicField</span> <span class=\"mi\">3</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span> <span class=\"n\">IsCyclotomicExtension.zeta</span> <span class=\"mi\">3</span> <span class=\"n\">ℚ</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"n\">abbrev</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">Algebra.adjoin</span> <span class=\"n\">ℤ</span> <span class=\"o\">{</span><span class=\"n\">μ'</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">μ_prim</span> <span class=\"o\">:</span> <span class=\"n\">IsPrimitiveRoot</span> <span class=\"n\">μ'</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">IsCyclotomicExtension.zeta_spec</span> <span class=\"mi\">3</span> <span class=\"n\">ℚ</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">μℂ'</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"n\">IsCyclotomicExtension.zeta</span> <span class=\"mi\">3</span> <span class=\"n\">ℂ</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">μℂ'_prim</span> <span class=\"o\">:</span> <span class=\"n\">IsPrimitiveRoot</span> <span class=\"n\">μℂ'</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">IsCyclotomicExtension.zeta_spec</span> <span class=\"mi\">3</span> <span class=\"n\">ℂ</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">minpoly_eq</span> <span class=\"o\">:</span> <span class=\"n\">minpoly</span> <span class=\"n\">ℤ</span> <span class=\"n\">μ'</span> <span class=\"bp\">=</span> <span class=\"n\">minpoly</span> <span class=\"n\">ℤ</span> <span class=\"n\">μℂ'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">minpoly</span> <span class=\"n\">ℚ</span> <span class=\"n\">μ'</span> <span class=\"bp\">=</span> <span class=\"n\">minpoly</span> <span class=\"n\">ℚ</span> <span class=\"n\">μℂ'</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">minpoly.isIntegrallyClosed_eq_field_fractions'</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">μ_prim.isIntegral</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">)),</span>\n      <span class=\"n\">minpoly.isIntegrallyClosed_eq_field_fractions'</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">μℂ'_prim.isIntegral</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">))]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">Polynomial.map_injective</span> <span class=\"n\">_</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">RingHom.injective_int</span> <span class=\"o\">(</span><span class=\"n\">algebraMap</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span><span class=\"o\">))</span> <span class=\"n\">this</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Irreducible</span> <span class=\"o\">(</span><span class=\"n\">Polynomial.cyclotomic</span> <span class=\"bp\">↑</span><span class=\"mi\">3</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"n\">Polynomial.cyclotomic.irreducible_rat</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">)</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">IsPrimitiveRoot.minpoly_eq_cyclotomic_of_irreducible</span> <span class=\"n\">μ_prim</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"bp\">←</span> <span class=\"n\">IsPrimitiveRoot.minpoly_eq_cyclotomic_of_irreducible</span> <span class=\"n\">μℂ'_prim</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"n\">abbrev</span> <span class=\"n\">R'</span> <span class=\"o\">:=</span> <span class=\"n\">Algebra.adjoin</span> <span class=\"n\">ℤ</span> <span class=\"o\">{</span><span class=\"n\">μℂ'</span><span class=\"o\">}</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">equiv_R1</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">ℤ</span><span class=\"o\">]</span> <span class=\"n\">AdjoinRoot</span> <span class=\"o\">(</span><span class=\"n\">minpoly</span> <span class=\"n\">ℤ</span> <span class=\"n\">μ'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">AlgEquiv.adjoinSingletonEquivAdjoinRootMinpoly'</span> <span class=\"o\">(</span><span class=\"n\">μ_prim.isIntegral</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">))</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">equiv_R2</span> <span class=\"o\">:</span> <span class=\"n\">R'</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">ℤ</span><span class=\"o\">]</span> <span class=\"n\">AdjoinRoot</span> <span class=\"o\">(</span><span class=\"n\">minpoly</span> <span class=\"n\">ℤ</span> <span class=\"n\">μ'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">minpoly_eq</span> <span class=\"bp\">▸</span> <span class=\"n\">AlgEquiv.adjoinSingletonEquivAdjoinRootMinpoly'</span> <span class=\"o\">(</span><span class=\"n\">μℂ'_prim.isIntegral</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">))</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">R_equiv_R'</span> <span class=\"o\">:=</span> <span class=\"n\">equiv_R1.trans</span> <span class=\"n\">equiv_R2.symm</span>\n</code></pre></div>\n<p>What I find a bit strange is the occurrence of <code>AlgebraCat</code> in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">R_equiv_R'</span> <span class=\"c1\">-- R_equiv_R' : ↑(AlgebraCat.of ℤ ↥R) ≃ₐ[ℤ] ↑(AlgebraCat.of ℤ ↥R')</span>\n</code></pre></div>\n<p>Why is this not just <code>↥R ≃ₐ[ℤ] ↥R'</code>? (It seems I can force it to be this by adding a type ascription. Still, I'd like to know.)</p>",
        "id": 411510429,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1704550350
    },
    {
        "content": "<p>mwe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Category.AlgebraCat.Basic</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"n\">abbrev</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">Subalgebra</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">R</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">ℤ</span><span class=\"o\">]</span> <span class=\"n\">R</span> <span class=\"c1\">-- bad coercion introduced `AlgebraCat.of`</span>\n</code></pre></div>",
        "id": 411511308,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704551373
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instCoeOutSubalgebraToCommSemiringToSemiringAlgebraCat#doc\">docs#instCoeOutSubalgebraToCommSemiringToSemiringAlgebraCat</a></p>",
        "id": 411511403,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1704551450
    },
    {
        "content": "<p>That's the one, that instance is a disaster</p>",
        "id": 411511427,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704551471
    },
    {
        "content": "<p>The caller should be forced to write <code>of _ S</code> to turn a subalgebra into a category</p>",
        "id": 411511464,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704551515
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span> all of this is for FLT 3, right? Can you explain a little bit what you need?</p>\n<p>I may be completely wrong, but I think all the computations should take place in <code>K = CyclotomicField 3 ℚ</code> or <code>𝓞 K</code>.</p>",
        "id": 411712920,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1704710491
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> At this point, this is for a student's bachelor's thesis, which is about implementing Jacobi sums (following Ireland-Rosen), and the particular goal here is to show that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>J</mi><mo stretchy=\"false\">(</mo><mi>χ</mi><mo separator=\"true\">,</mo><mi>χ</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>a</mi><mo>+</mo><mi>b</mi><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">J(\\chi, \\chi) = a + b  \\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">χ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">χ</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">bω</span></span></span></span> when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>χ</mi></mrow><annotation encoding=\"application/x-tex\">\\chi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">χ</span></span></span></span> is a cubic character, with <em>integers</em> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> and a primitive cube root of unity <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span>. So working with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><mi>ω</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}[\\omega]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"mclose\">]</span></span></span></span> is quite natural...</p>",
        "id": 411734330,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1704718998
    },
    {
        "content": "<p>I see. What about working with a general <code>K</code> with <code>IsCyclotomicExtension {p ^ k} ℚ K</code> (of course replacing <code>p^k</code> with <code>n</code> would be very nice) and any primitive root of unity? Your computation can live in <code>𝓞 K</code> or in <code>Algebra.adjoin ℤ {ζ}</code> depending on what is more convenient, and we know that they're isomorphic, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsPrimitiveRoot.adjoinEquivRingOfIntegers#doc\">docs#IsPrimitiveRoot.adjoinEquivRingOfIntegers</a></p>",
        "id": 411767248,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1704729559
    },
    {
        "content": "<p>I've just started to try that <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 411767369,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1704729598
    },
    {
        "content": "<p>RIght now, I'm stuck at proving</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">K</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">:</span> <span class=\"n\">Field</span> <span class=\"n\">K</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"n\">CharZero</span> <span class=\"n\">K</span>\n<span class=\"n\">cyc</span><span class=\"o\">:</span> <span class=\"n\">IsCyclotomicExtension</span> <span class=\"o\">{</span><span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"n\">ℚ</span> <span class=\"n\">K</span>\n<span class=\"n\">μ</span><span class=\"o\">:</span> <span class=\"n\">K</span>\n<span class=\"n\">μ_prim</span><span class=\"o\">:</span> <span class=\"n\">IsPrimitiveRoot</span> <span class=\"n\">μ</span> <span class=\"bp\">↑</span><span class=\"mi\">3</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">↑</span><span class=\"o\">((</span><span class=\"n\">IsIntegralClosure.lift</span> <span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Algebra.adjoin</span> <span class=\"n\">ℤ</span> <span class=\"o\">{</span><span class=\"n\">μ</span><span class=\"o\">}))</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Algebra.IsIntegral</span> <span class=\"n\">ℤ</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">NumberField.ringOfIntegers</span> <span class=\"n\">K</span><span class=\"o\">)))</span>\n      <span class=\"o\">(</span><span class=\"n\">IsPrimitiveRoot.toInteger</span> <span class=\"n\">μ_prim</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n  <span class=\"n\">μ</span>\n</code></pre></div>\n<p>Any hints on how to peel off the stack of maps on the left?</p>",
        "id": 411772244,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1704731144
    },
    {
        "content": "<p>BTW, when working with concrete numbers, it is really a pain in the neck that the cyclotomic machinery uses <code>PNat</code>s. E.g., you have to write <code>μ_prim : IsPrimitiveRoot μ (3 : ℕ+)</code> and provide the instance <code>Fact (Nat.Prime (3 : ℕ+))</code> to make <code>μ_prim.integralPowerBasis'</code> work. I'd propose to change to using <code>Nat</code>s, perhaps with a <code>[NeZero n]</code> assumption (or allow zero and just ignore it). <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span></p>",
        "id": 411772969,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1704731368
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Cyclotomic.20rings.20and.20fields.20and.20DTT.20hell/near/411772244\">said</a>:</p>\n<blockquote>\n<p>RIght now, I'm stuck at proving</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">K</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">:</span> <span class=\"n\">Field</span> <span class=\"n\">K</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"n\">CharZero</span> <span class=\"n\">K</span>\n<span class=\"n\">cyc</span><span class=\"o\">:</span> <span class=\"n\">IsCyclotomicExtension</span> <span class=\"o\">{</span><span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"n\">ℚ</span> <span class=\"n\">K</span>\n<span class=\"n\">μ</span><span class=\"o\">:</span> <span class=\"n\">K</span>\n<span class=\"n\">μ_prim</span><span class=\"o\">:</span> <span class=\"n\">IsPrimitiveRoot</span> <span class=\"n\">μ</span> <span class=\"bp\">↑</span><span class=\"mi\">3</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">↑</span><span class=\"o\">((</span><span class=\"n\">IsIntegralClosure.lift</span> <span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Algebra.adjoin</span> <span class=\"n\">ℤ</span> <span class=\"o\">{</span><span class=\"n\">μ</span><span class=\"o\">}))</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Algebra.IsIntegral</span> <span class=\"n\">ℤ</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">NumberField.ringOfIntegers</span> <span class=\"n\">K</span><span class=\"o\">)))</span>\n      <span class=\"o\">(</span><span class=\"n\">IsPrimitiveRoot.toInteger</span> <span class=\"n\">μ_prim</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n  <span class=\"n\">μ</span>\n</code></pre></div>\n<p>Any hints on how to peel off the stack of maps on the left?</p>\n</blockquote>\n<p>Can you write down the full result you need? I can give a try.</p>",
        "id": 411773272,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1704731463
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/287929-mathlib4/topic/Cyclotomic.20rings.20and.20fields.20and.20DTT.20hell/near/411772969\">said</a>:</p>\n<blockquote>\n<p>BTW, when working with concrete numbers, it is really a pain in the neck that the cyclotomic machinery uses <code>PNat</code>s. E.g., you have to write <code>μ_prim : IsPrimitiveRoot μ (3 : ℕ+)</code> and provide the instance <code>Fact (Nat.Prime (3 : ℕ+))</code> to make <code>μ_prim.integralPowerBasis'</code> work. I'd propose to change to using <code>Nat</code>s, perhaps with a <code>[NeZero n]</code> assumption (or allow zero and just ignore it). <span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span></p>\n</blockquote>\n<p>Yes, this is something we are aware since the beginning. We chose to work with <code>PNat</code> to simplify things, but we end up with a lot of coercions and we more or less got used to them, but we almost never work with explicit numbers. This was not so bad, so I never found the energy to do the refactor, but I am not against it in principle. Maybe the other FLT-regular people have a different opinion. <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> <span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> <span class=\"user-mention\" data-user-id=\"389019\">@Chris Birkbeck</span></p>",
        "id": 411773698,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1704731606
    },
    {
        "content": "<p>The current state of my proof attempt is this (not yet very polished):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Polynomial</span>\n\n<span class=\"c1\">-- A useful lemma for going from polynomials to linear combinations.</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">aeval_of_natDegree_lt_2</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">f.natDegree</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">aeval</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f.coeff</span> <span class=\"mi\">0</span> <span class=\"bp\">•</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">f.coeff</span> <span class=\"mi\">1</span> <span class=\"bp\">•</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">hf'</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">f.coeff</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">f.coeff</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">X</span>\n  <span class=\"bp\">·</span> <span class=\"n\">ext</span> <span class=\"n\">n</span> <span class=\"c1\">-- prove by comparing coefficients</span>\n    <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">eq_intCast</span><span class=\"o\">]</span> <span class=\"c1\">-- otherwise the coefficient gets changed before other lemmas apply</span>\n    <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"c1\">-- show that all higher coefficients are zero on both sides</span>\n        <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">coeff_add</span><span class=\"o\">,</span> <span class=\"n\">coeff_C_succ</span><span class=\"o\">,</span> <span class=\"n\">coeff_mul_X</span><span class=\"o\">,</span> <span class=\"n\">add_zero</span><span class=\"o\">]</span>\n          <span class=\"n\">using</span> <span class=\"n\">natDegree_le_iff_coeff_eq_zero.mp</span> <span class=\"o\">(</span><span class=\"n\">Nat.lt_succ.mp</span> <span class=\"n\">hf</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Nat.one_lt_succ_succ</span> <span class=\"n\">n</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hf'</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Algebra.algebraMap_eq_smul_one</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Polynomial</span>\n\n<span class=\"c1\">-- The following instance is needed in some places later.</span>\n<span class=\"kd\">instance</span> <span class=\"n\">PNat.three_prime</span> <span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Nat.Prime</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Nat.prime_three</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">have_repr</span> <span class=\"o\">{</span><span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CharZero</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">cyc</span> <span class=\"o\">:</span> <span class=\"n\">IsCyclotomicExtension</span> <span class=\"o\">{</span><span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"n\">ℚ</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">μ_prim</span> <span class=\"o\">:</span> <span class=\"n\">IsPrimitiveRoot</span> <span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">))</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Algebra.adjoin</span> <span class=\"n\">ℤ</span> <span class=\"o\">{</span><span class=\"n\">μ</span><span class=\"o\">})</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">μ_prim.integralPowerBasis'</span>\n  <span class=\"k\">have</span> <span class=\"n\">H₂</span> <span class=\"o\">:</span> <span class=\"n\">B.dim</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">μ_prim.power_basis_int'_dim</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf₁</span><span class=\"o\">,</span> <span class=\"n\">hf₂</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">B.exists_eq_aeval</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">μ_prim.adjoinEquivRingOfIntegers'</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">f.coeff</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">f.coeff</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"n\">apply_fun</span> <span class=\"n\">μ_prim.adjoinEquivRingOfIntegers'.symm</span> <span class=\"n\">at</span> <span class=\"n\">hf₂</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">AlgEquiv.symm_apply_apply</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hf₂</span>\n  <span class=\"n\">apply_fun</span> <span class=\"n\">Subtype.val</span> <span class=\"n\">at</span> <span class=\"n\">hf₂</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">μ_prim.integralPowerBasis'_gen</span><span class=\"o\">,</span> <span class=\"n\">μ_prim.adjoinEquivRingOfIntegers'_symm_apply</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hf₂</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hf₂</span><span class=\"o\">,</span> <span class=\"n\">Polynomial.aeval_of_natDegree_lt_2</span> <span class=\"o\">(</span><span class=\"n\">H₂</span> <span class=\"bp\">▸</span> <span class=\"n\">hf₁</span><span class=\"o\">),</span> <span class=\"c1\">-- `H₂ ▸ hf₁ : f.natDegree f &lt; 2`</span>\n    <span class=\"n\">map_add</span><span class=\"o\">,</span> <span class=\"n\">map_zsmul</span><span class=\"o\">,</span> <span class=\"n\">map_zsmul</span><span class=\"o\">,</span> <span class=\"n\">map_one</span><span class=\"o\">,</span> <span class=\"n\">zsmul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">zsmul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Subsemiring.coe_add</span><span class=\"o\">,</span> <span class=\"n\">Subalgebra.coe_toSubsemiring</span><span class=\"o\">,</span> <span class=\"n\">SubringClass.coe_intCast</span><span class=\"o\">,</span>\n    <span class=\"n\">Submonoid.coe_mul</span><span class=\"o\">,</span> <span class=\"n\">Subsemiring.coe_toSubmonoid</span><span class=\"o\">,</span> <span class=\"n\">add_right_inj</span><span class=\"o\">,</span> <span class=\"n\">mul_eq_mul_left_iff</span><span class=\"o\">,</span>\n    <span class=\"n\">Int.cast_eq_zero</span><span class=\"o\">]</span>\n  <span class=\"n\">left</span>\n  <span class=\"c1\">-- this is the tactic state mentioned above</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 411773738,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1704731621
    },
    {
        "content": "<p>Let me have a look.</p>",
        "id": 411774311,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1704731814
    },
    {
        "content": "<p>Essentially, the task is to transfer the statement that the image of <code>x</code> in the ring of integers of <code>K</code> has the correct form back to <code>x</code> and <code>μ</code>.</p>",
        "id": 411774719,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1704731919
    },
    {
        "content": "<p>I was just trying to apply the inverse map (and the coercion from the subtype) on both sides and then simplify...</p>",
        "id": 411774812,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1704731954
    },
    {
        "content": "<p>have you tried using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.span_range_natDegree_eq_adjoin#doc\">docs#Submodule.span_range_natDegree_eq_adjoin</a> ?</p>",
        "id": 411774948,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1704731999
    },
    {
        "content": "<p>It seems relevant</p>",
        "id": 411774960,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1704732002
    },
    {
        "content": "<p>No; I'm just at the beginning of exploring that part of the library.</p>",
        "id": 411775172,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1704732065
    },
    {
        "content": "<p>I more or less agree. Using <code>PNat</code>s had minor inconveniences that I got used to and it is probably worth trying if using <code>Nat</code> can make things easier.</p>",
        "id": 411775477,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1704732183
    },
    {
        "content": "<p>???</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Submodule.span_range_natDegree_eq_adjoin</span>\n<span class=\"c1\">-- unknown constant 'Submodule.span_range_natDegree_eq_adjoin'</span>\n</code></pre></div>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.span_range_natDegree_eq_adjoin#doc\">docs#Submodule.span_range_natDegree_eq_adjoin</a></p>",
        "id": 411776472,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1704732560
    },
    {
        "content": "<p>Maybe it changed name and you have an old version?</p>",
        "id": 411776573,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1704732596
    },
    {
        "content": "<p>It works for me</p>",
        "id": 411776578,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1704732599
    },
    {
        "content": "<p>That lemma is relatively new.</p>",
        "id": 411776586,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1704732601
    },
    {
        "content": "<p>OK, let me bump Mathlib...</p>",
        "id": 411776657,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1704732614
    },
    {
        "content": "<p>I think I can finish the proof, give me 10 minutes</p>",
        "id": 411776896,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1704732703
    },
    {
        "content": "<p>Voilà</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Polynomial</span>\n\n<span class=\"c1\">-- A useful lemma for going from polynomials to linear combinations.</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">aeval_of_natDegree_lt_2</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">f.natDegree</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">aeval</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f.coeff</span> <span class=\"mi\">0</span> <span class=\"bp\">•</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">f.coeff</span> <span class=\"mi\">1</span> <span class=\"bp\">•</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">hf'</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">f.coeff</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">f.coeff</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">X</span>\n  <span class=\"bp\">·</span> <span class=\"n\">ext</span> <span class=\"n\">n</span> <span class=\"c1\">-- prove by comparing coefficients</span>\n    <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">eq_intCast</span><span class=\"o\">]</span> <span class=\"c1\">-- otherwise the coefficient gets changed before other lemmas apply</span>\n    <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"c1\">-- show that all higher coefficients are zero on both sides</span>\n        <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">coeff_add</span><span class=\"o\">,</span> <span class=\"n\">coeff_C_succ</span><span class=\"o\">,</span> <span class=\"n\">coeff_mul_X</span><span class=\"o\">,</span> <span class=\"n\">add_zero</span><span class=\"o\">]</span>\n          <span class=\"n\">using</span> <span class=\"n\">natDegree_le_iff_coeff_eq_zero.mp</span> <span class=\"o\">(</span><span class=\"n\">Nat.lt_succ.mp</span> <span class=\"n\">hf</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Nat.one_lt_succ_succ</span> <span class=\"n\">n</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hf'</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Algebra.algebraMap_eq_smul_one</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Polynomial</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">have_repr</span> <span class=\"o\">{</span><span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CharZero</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">cyc</span> <span class=\"o\">:</span> <span class=\"n\">IsCyclotomicExtension</span> <span class=\"o\">{</span><span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"n\">ℚ</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">μ_prim</span> <span class=\"o\">:</span> <span class=\"n\">IsPrimitiveRoot</span> <span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">))</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Algebra.adjoin</span> <span class=\"n\">ℤ</span> <span class=\"o\">{</span><span class=\"n\">μ</span><span class=\"o\">})</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">classical</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">Nat.totient</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">Finset.range</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">minpoly.aeval</span> <span class=\"n\">ℤ</span> <span class=\"n\">μ</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">Polynomial.cyclotomic_eq_minpoly</span> <span class=\"n\">μ_prim</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">)]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">change</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Subalgebra.toSubmodule</span> <span class=\"o\">(</span><span class=\"n\">Algebra.adjoin</span> <span class=\"n\">ℤ</span> <span class=\"o\">{</span><span class=\"n\">μ</span><span class=\"o\">})</span> <span class=\"n\">at</span> <span class=\"n\">hx</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">Submodule.span_range_natDegree_eq_adjoin</span> <span class=\"o\">(</span><span class=\"n\">Polynomial.cyclotomic.monic</span> <span class=\"mi\">3</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">Polynomial.natDegree_cyclotomic</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Finset.image_insert</span><span class=\"o\">,</span> <span class=\"n\">pow_zero</span><span class=\"o\">,</span> <span class=\"n\">Finset.image_singleton</span><span class=\"o\">,</span> <span class=\"n\">pow_one</span><span class=\"o\">,</span> <span class=\"n\">Finset.coe_insert</span><span class=\"o\">,</span>\n    <span class=\"n\">Finset.coe_singleton</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">Submodule.mem_span_pair.1</span> <span class=\"n\">hx</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hx</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 411777555,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1704732926
    },
    {
        "content": "<p>Of course it has nothing to do with cyclotomic extensions</p>",
        "id": 411777628,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1704732962
    },
    {
        "content": "<p>And all the job is done by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.span_range_natDegree_eq_adjoin#doc\">docs#Submodule.span_range_natDegree_eq_adjoin</a></p>",
        "id": 411778194,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1704733167
    }
]