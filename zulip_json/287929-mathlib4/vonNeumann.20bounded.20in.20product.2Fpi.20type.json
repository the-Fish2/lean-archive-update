[
    {
        "content": "<p>Hi, what should we do about von Neumann boundedness in product/pi type?</p>\n<ul>\n<li>prove that the corresponding <code>Bornology</code> agrees with <code>prod</code>/<code>pi</code> bornologies?</li>\n<li>or introduce a typeclass <code>[Bornology X] [IsVonNBornology R X]</code> and migrate all lemmas from <code>IsVonNBounded</code> to this assumption?</li>\n</ul>\n<p>How often do we have a <code>Bornology</code> instance but it is <strong>not</strong> propositionally equal to the von Neumann bornology?</p>",
        "id": 420921885,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707685642
    },
    {
        "content": "<p>Well, any time we will work in a metrizable TVS which is not normed I think (or rather, any time we would like to endow such a space with a <code>MetricSpace</code> instance inside a proof)</p>",
        "id": 420922118,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707685906
    },
    {
        "content": "<p>Then I'll go with option 1.</p>",
        "id": 420922173,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707685959
    },
    {
        "content": "<p>I think that the second approach you give is the best and, as a matter of fact, I think we should even do this for the case of metric spaces instead of forgetful inheritance.</p>",
        "id": 420922286,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707686051
    },
    {
        "content": "<p>(Essentially, I’m unhappy with having <code>MetricSpace -&gt; Bornology</code> as an instance, because <code>MetricSpace</code> clashes with so much things that it essentially forbids making anything else an instance ever)</p>",
        "id": 420922544,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707686357
    },
    {
        "content": "<p>What other instances for <code>Bornology</code> do you have in mind?</p>",
        "id": 420923172,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707686961
    },
    {
        "content": "<p>Surely you want <code>MetricSpace -&gt; Bornology</code> to be an instance, else you can't talk about bounded sets?</p>",
        "id": 420923272,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707687040
    },
    {
        "content": "<p>I think one could expect to at least capture order-boundedness (above, below, and on both sides) as well as Von-Neumann. </p>\n<p>My main complaint about the current setup is that in practice the only thing that has changed is that we now write <code>Bornology.IsBounded</code> instead of <code>Metric.Bounded</code>, and that's about it. As an example, you can check that basically none of the theorems about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Bornology.IsVonNBounded#doc\">docs#Bornology.IsVonNBounded</a> are <strong><em>not</em></strong> spelled in terms of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Bornology.vonNBornology#doc\">docs#Bornology.vonNBornology</a>, exactly because we have no hope of ever making it an instance without causing some diamonds in the case of metrizable TVSs.</p>\n<p>The solution I would imagine is to have <code>Metric.IsBounded</code> as a notation/abbrev for <code>PseudoMetricSpace.toBornology.IsBounded</code>, and then have all theorems about boundedness in metric spaces assume <code>[MetricSpace X] {b : Bornology X} [MetricBornology (b := b) X]</code>, so that they apply both to <code>Metric.IsBounded</code> as well as the general <code>IsBounded</code> for types which have canonical bornologies agreeing with the metric one. Does that make sense?</p>",
        "id": 420925464,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707689018
    },
    {
        "content": "<p>Certainly, although my fingers currently hurt too much from climbing to expand on why I agree</p>",
        "id": 420925547,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707689082
    },
    {
        "content": "<p>An example I've had in mind for some time is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Real.isBounded_iff_bddBelow_bddAbove#doc\">docs#Real.isBounded_iff_bddBelow_bddAbove</a>. The fact that we only have this for reals is completely stupid, and having a <code>OrderBornology</code> typeclass would make it instantly better.</p>",
        "id": 420925607,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707689148
    },
    {
        "content": "<p>How Lean will deduce <code>b</code> if you rewrite a generalize <code>isBounded_iff_bddBelow_bddAbove</code> from right to left?</p>",
        "id": 420925679,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707689187
    },
    {
        "content": "<p>Also, if <code>Metric.IsBounded</code> fixed defeq for <code>b</code>, then we can no longer use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsBounded.prod#doc\">docs#IsBounded.prod</a> with it.</p>",
        "id": 420925820,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707689305
    },
    {
        "content": "<p>It will produce <code>Bornology.IsBounded (b := Bornology.prod) _</code></p>",
        "id": 420925841,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707689329
    },
    {
        "content": "<p>On the other hand all theorems should still apply to it because we would have an instance of <code>MetricBornology</code> on the product, but indeed that's a bit annoying</p>",
        "id": 420925906,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707689397
    },
    {
        "content": "<p>No, if you're trying to apply a theorem that assumes <code>Metric.IsBounded s</code>.</p>",
        "id": 420926022,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707689484
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/287929-mathlib4/topic/vonNeumann.20bounded.20in.20product.2Fpi.20type/near/420926022\">said</a>:</p>\n<blockquote>\n<p>No, if you're trying to apply a theorem that assumes <code>Metric.IsBounded s</code>.</p>\n</blockquote>\n<p>No theorems should assume it, they should assume <code>[MetricBornology]</code> instead</p>",
        "id": 420926045,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707689514
    },
    {
        "content": "<p>And <code>s</code> is in fact <code>u × v</code></p>",
        "id": 420926046,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707689515
    },
    {
        "content": "<p>Then <code>apply</code> will produce a <code>Bonology</code> goal.</p>",
        "id": 420926093,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707689535
    },
    {
        "content": "<p>Also, if we never assume <code>Metric.IsBounded</code>, then why should we have it at all?</p>",
        "id": 420926103,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707689552
    },
    {
        "content": "<p>In order not to have to declare local instances and/or use implicit arguments in the middle of proofs</p>",
        "id": 420926129,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707689587
    },
    {
        "content": "<p>Looks like a footgun to me.</p>",
        "id": 420926166,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707689630
    },
    {
        "content": "<p>Another suggestion:</p>\n<ol>\n<li>We make the <code>Bornology</code> argument explicit.</li>\n<li><code>Metric.IsBounded</code> is a notation for <code>Metric.bornology.IsBounded</code></li>\n<li>We have typeclasses like <code>MetricBornology (b : Bornology X) : Prop where eq_metric : _</code> and rewrite on <code>b.eq_metric</code> as needed.</li>\n</ol>",
        "id": 420926284,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707689751
    },
    {
        "content": "<p>I'm not saying my suggestion is perfect, what I wanted to point out is that I think the canonicity-level of bornologies is more around that of measures than that of topologies.</p>",
        "id": 420926286,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707689753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/287929-mathlib4/topic/vonNeumann.20bounded.20in.20product.2Fpi.20type/near/420926284\">said</a>:</p>\n<blockquote>\n<p>Another suggestion:</p>\n<ol>\n<li>We make the <code>Bornology</code> argument explicit.</li>\n<li><code>Metric.IsBounded</code> is a notation for <code>Metric.bornology.IsBounded</code></li>\n<li>We have typeclasses like <code>MetricBornology (b : Bornology X) : Prop where eq_metric : _</code> and rewrite on <code>b.eq_metric</code> as needed.</li>\n</ol>\n</blockquote>\n<p>That would work as well, but then that means not \"canonical bornologies\" on anything (e.g reals, where everything agrees)</p>",
        "id": 420926382,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707689844
    },
    {
        "content": "<p>Except if we do a <code>volume</code>-kind of trick</p>",
        "id": 420926407,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707689877
    },
    {
        "content": "<p>In fact if we have the freedom of a tactic, we could also make it so that it tries some common ones, even if they are potentially conflicting ? So that <code>IsBounded</code> in a space which is \"only\" a metric space defaults to order-boundedness ? Or would it make the statements have an ugly <code>by</code> block instead of <code>Metric.bornology</code> ?</p>",
        "id": 420927840,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707691262
    },
    {
        "content": "<p>Anyway, all these solutions look like medium-to-large refactors, so I'll just add a lemma about <code>isVonNBounded_pi</code> for now.</p>",
        "id": 420929006,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707692307
    },
    {
        "content": "<p>Sure <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 420929283,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707692531
    }
]