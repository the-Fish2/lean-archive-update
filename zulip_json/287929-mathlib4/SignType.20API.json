[
    {
        "content": "<p>What is the recommended way of showing</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">SignType.sign</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">SignType.sign</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>? (This came up in <a href=\"https://github.com/leanprover-community/mathlib4/pull/12779\">#12779</a>  <span class=\"user-mention\" data-user-id=\"481963\">@David Loeffler</span>.) <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> </p>\n<p>My best effort is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">SignType.sign</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">SignType.sign</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">sign_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">norm_cast</span>\n  <span class=\"n\">split_ifs</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<p>(squeezing the <code>simp</code>s makes it a bit faster; the version above takes &gt; 3000 heartbeats, which strikes me as slow for such an elementary fact), but I was hoping there would be sufficient API available to not have to split cases in the proof.</p>",
        "id": 438180722,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1715515834
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=map_sign#doc\">docs#map_sign</a> ?</p>",
        "id": 438180901,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715516116
    },
    {
        "content": "<p>Missing <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>",
        "id": 438180921,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715516154
    },
    {
        "content": "<p>David's proof is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">SignType.sign</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">SignType.sign</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">SignType.map_cast</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">Int.castRingHom</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"n\">Int.coe_castRingHom</span><span class=\"o\">,</span> <span class=\"n\">Int.cast_inj</span><span class=\"o\">,</span>\n      <span class=\"bp\">←</span> <span class=\"n\">eq_intCast</span> <span class=\"o\">(</span><span class=\"n\">Int.castRingHom</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">StrictMono.sign_comp</span><span class=\"o\">]</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">strictMono_iff_map_pos</span><span class=\"o\">,</span> <span class=\"n\">Int.coe_castRingHom</span><span class=\"o\">,</span> <span class=\"n\">Int.cast_pos</span><span class=\"o\">,</span> <span class=\"n\">imp_self</span><span class=\"o\">,</span> <span class=\"n\">forall_const</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>which is fairly involved (and slower)...</p>",
        "id": 438181484,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1715516778
    },
    {
        "content": "<p>I think there are two missing lemmas here.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">sign_cast_int</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">OrderedRing</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Nontrivial</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"o\">((</span><span class=\"bp\">·</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">SignType.sign</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">SignType.sign</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sign_apply</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">norm_cast</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">sign_int_cast</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddGroupWithOne</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">SignType</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n  <span class=\"n\">SignType.map_cast'</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">mod_cast</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mod_cast</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mod_cast</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">SignType.sign</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">SignType.sign</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>\n<p>Names may not be optimal and I haven't thought about where they should go in mathlib. Also, neither lemma properly is anything to do with <code>ℤ</code>; the first should be for any order-preserving cast, the second should be for any cast preserving 0, 1 and negation. But maybe using type classes to assert that casts have those properties is hard given how Lean 4 elaborates casts (see the reverted <a href=\"https://github.com/leanprover-community/mathlib/pull/17048\">!3#17048</a>).</p>",
        "id": 438189532,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1715525192
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266253\">Joseph Myers</span> <a href=\"#narrow/stream/287929-mathlib4/topic/SignType.20API/near/438189532\">said</a>:</p>\n<blockquote>\n<p>I think there are two missing lemmas here. […] Also, neither lemma properly is anything to do with <code>ℤ</code>; the first should be for any order-preserving cast, the second should be for any cast preserving 0, 1 and negation. But maybe using type classes to assert that casts have those properties is hard given how Lean 4 elaborates casts (see the reverted <a href=\"https://github.com/leanprover-community/mathlib/pull/17048\">!3#17048</a>).</p>\n</blockquote>\n<p>That’s exactly the issue. More general versions of both lemmas already exist - for an arbitrary homomorphism of ordered types satisfying the necessary type class assumptions. The problem is that mathlib has two different versions of the canonical map from Z to an arbitrary ring - one which is a homomorphism type (Int.castRingHom) and one that’s just a bare function - and the one that’s used by default as a coercion is the bare-function version. So you have to rewrite (using “eq_intCast”) to substitute the homomorphism version, before the SignType lemmas will work; and that’s exactly the proof of mine that Michael posted earlier in this thread and was criticising as overcomplicated.</p>",
        "id": 438190321,
        "sender_full_name": "David Loeffler",
        "timestamp": 1715525917
    },
    {
        "content": "<p>It’s a pity that there is no information at all in the PR <a href=\"https://github.com/leanprover-community/mathlib/pull/17048\">!3#17048</a>, or the later PR <a href=\"https://github.com/leanprover-community/mathlib/pull/17733\">!3#17733</a> that reverts it, explaining why the decision was take to remove it again.</p>",
        "id": 438190872,
        "sender_full_name": "David Loeffler",
        "timestamp": 1715526403
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266253\">Joseph Myers</span> <a href=\"#narrow/stream/287929-mathlib4/topic/SignType.20API/near/438189532\">said</a>:</p>\n<blockquote>\n<p>I think there are two missing lemmas here.</p>\n</blockquote>\n<p>Names should be <code>SignType.sign_intCast</code> and <code>SignType.intCast_cast</code> (or <code>Int.cast_signTypeCast</code>) respectively</p>",
        "id": 438194212,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715529901
    },
    {
        "content": "<p>I have added <span class=\"user-mention\" data-user-id=\"266253\">@Joseph Myers</span> 's two missing lemmas (using the names suggested by Yaël) to <code>Data.Sign</code> as part of <a href=\"https://github.com/leanprover-community/mathlib4/pull/12779\">#12779</a>. Thanks!</p>",
        "id": 438202501,
        "sender_full_name": "David Loeffler",
        "timestamp": 1715538098
    }
]