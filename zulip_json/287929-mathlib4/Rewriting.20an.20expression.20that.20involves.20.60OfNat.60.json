[
    {
        "content": "<p>Hello. I have run into the following issue several times in the past week and I want to know if there is any way around it.</p>\n<p>Suppose that I want to prove a simple theorem such as </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">100</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">100</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Both sides of the equation appear exactly the same in the goal view. However, I tried <code>rfl</code>, <code>simp</code>, <code>norm_cast</code>, and <code>push_cast</code> and none of them worked. Even <code>exact?</code> cannot close the goal, and <code>apply?</code> suggests a wide variety of lemmas that don't seem likely to help at all.</p>\n<p>After quite a bit of manual library searching, I figured out that this example can be closed with <code>(nsmul_eq_smul_cast R 100 m).symm</code>.  Here is the type line of <code>nsmul_eq_smul_cast</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">nsmul_eq_smul_cast</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">•</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>The reason <code>exact?</code> can't find this lemma is that <code>(nsmul_eq_smul_cast R 100 m).symm</code> has type <code>((100 : ℕ) : R) • m = 100  • m</code>. This is definitionally equal to the desired equation <code>(100 : R) • m = 100 • m</code>, but it is not syntactically equal.</p>",
        "id": 432367644,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712710208
    },
    {
        "content": "<p>The fact that <code>(100 : R)</code> and <code>((100 : ℕ) : R)</code> are not syntactically equal has some other annoying consequences. For example, suppose that <code>(100 : R) • m</code> appears in a goal expression, and I would like to rewrite it to <code>100 • m</code>. Or, to put it another way, how can we prove the example <code>(100 : R) • m = 100 • m</code> from earlier by rewriting the left-hand side into the right-hand side?</p>\n<p>Because<code>(100 : R) • m = 100 • m</code> is a special case of <code>nsmul_eq_smul_cast</code>, one might try:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">100</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">100</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> tactic 'rewrite' failed, did not find instance of the pattern in the target expression</span>\n<span class=\"cm\">  ↑?n • ?b -/</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">nsmul_eq_smul_cast</span> <span class=\"n\">R</span> <span class=\"mi\">100</span> <span class=\"n\">m</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Of course, this doesn't work, because the right-hand side of <code>nsmul_eq_smul_cast R 100 m</code> is not <code>(100 : R) • m</code>, but rather <code>((100 : ℕ) : R) • m</code>.  The best I can do is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">100</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">100</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"mi\">100</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">100</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">nsmul_eq_smul_cast</span> <span class=\"n\">R</span> <span class=\"mi\">100</span> <span class=\"n\">m</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>However, having to rewrite using <code>(100 : R) = (100 : ℕ)</code> is rather annoying, and I can't help but think there should be a better way to do this.</p>",
        "id": 432368862,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712710766
    },
    {
        "content": "<p>Here is a combined snippet of code that demonstrates this difficulty:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">100</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">100</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> `exact?` could not close the goal. Try `apply?` to see partial suggestions. -/</span>\n  <span class=\"n\">exact</span><span class=\"bp\">?</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">100</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">100</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">nsmul_eq_smul_cast</span> <span class=\"n\">R</span> <span class=\"mi\">100</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">100</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">100</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> tactic 'rewrite' failed, did not find instance of the pattern in the target expression</span>\n<span class=\"cm\">  ↑?n • ?b -/</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">nsmul_eq_smul_cast</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">100</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">100</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"mi\">100</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">100</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">nsmul_eq_smul_cast</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 432369284,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712710944
    },
    {
        "content": "<p>This problem has kinda been my project for a number of months. I've PRed simp lemmas for <code>OfNat.ofNat</code> corresponding to every <code>Nat.cast</code> simp lemma, but I didn't get around to the non-simp ones. There are a lot of them and it isn't always easy to generalize them appropriately due to the <code>Nat.AtLeastTwo</code> typeclass adding an additional hypothesis. <a href=\"#narrow/stream/287929-mathlib4/topic/unify.20ofNat.20and.20Nat.2Ecast/near/424762128\">I made an RFC for unifying the two</a> which would make <code>exact?</code> work properly for your use case, but there were some concerns posed and the discussion seems to have trailed off after I tried to clarify.</p>",
        "id": 432370458,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1712711467
    },
    {
        "content": "<p>Here's a similar example of this issue that impacts even those who aren't using module theory:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"mi\">22</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"mi\">22</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(In fact, <code>^</code> is a right action, so it's essentially the same issue.)</p>",
        "id": 432371308,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712711887
    },
    {
        "content": "<p>Thank you so much for working to make this sort of thing easier <span class=\"user-mention\" data-user-id=\"500038\">@Timo Carlin-Burns</span></p>",
        "id": 432371358,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712711910
    },
    {
        "content": "<p>Here is another situation in which this particular issue was quite painful: <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Proving.20Hadamard.5E2.20.3D.20Identity.20in.202.5En.20dimensions/near/431612839\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/.E2.9C.94.20Proving.20Hadamard.5E2.20.3D.20Identity.20in.202.5En.20dimensions/near/431612839</a><br>\nIn order to get the rewriting to work, I had to write twice the identity matrix as <code>(2 : ℕ)</code>, because writing it as just <code>2</code> made it much harder to apply some general matrix theorems.</p>\n<p>And here's a snippet where I tried very hard not to write <code>rw [show (2 : R) = (2 : ℕ) by rfl]</code>, but ended up having to do so anyways: <a href=\"https://github.com/leanprover-community/mathlib4/pull/7569#discussion_r1556964555\">https://github.com/leanprover-community/mathlib4/pull/7569#discussion_r1556964555</a></p>",
        "id": 432371421,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712711942
    },
    {
        "content": "<p>This might be a stupid question, but why does <code>instOfNatAtLeastTwo</code> even exist? If it didn't, would it not still be possible to write things like <code>(100 : R)</code>?</p>",
        "id": 432373693,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712712789
    },
    {
        "content": "<p>It's to deal with making sure that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Zero#doc\">docs#Zero</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=One#doc\">docs#One</a> cover <code>OfNat R 0</code> and <code>OfNat R 1</code>. The <code>OfNat</code> class is new in Lean 4, so Mathlib needs these classes to be integrated somehow. But simultaneously there are some good reasons for Zero and One. I'm not sure what the long-term solution will be.</p>",
        "id": 432374395,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712712973
    },
    {
        "content": "<p>(A reason to still have these classes: an algebraic structure cannot extend both <code>OfNat R 0</code> and <code>OfNat R 1</code> since there is a name collision in fields. They both want <code>ofNat</code>.)</p>",
        "id": 432374694,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712713057
    },
    {
        "content": "<p>What I mean is this: I think it's quite useful to be able to type <code>0</code> and <code>1</code> and not have them be interpreted as a coercion. But when I type <code>(100 : R)</code>, I'm totally okay with that just being an abbreviation for <code>((100 : ℕ) : R)</code>. What problems would occur if this were the case?</p>",
        "id": 432375435,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712713317
    },
    {
        "content": "<p>And do these problems outweigh having to make two different versions of every theorem that involves <code>natCast</code>?</p>",
        "id": 432376391,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712713906
    },
    {
        "content": "<p>Is this the implementation you're suggesting? The problem is that <code>(100 : R)</code> is currently programmed to elaborate only if <code>OfNat R 100</code> and doesn't fall back to <code>(100 : Nat)</code> and <code>CoeHTCT Nat R</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MyRing</span> <span class=\"o\">:=</span> <span class=\"n\">Rat</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">MyRing</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstanceAs</span> <span class=\"o\">(</span><span class=\"n\">OfNat</span> <span class=\"n\">Rat</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">MyRing</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstanceAs</span> <span class=\"o\">(</span><span class=\"n\">OfNat</span> <span class=\"n\">Rat</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CoeHTCT</span> <span class=\"n\">Nat</span> <span class=\"n\">MyRing</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstanceAs</span> <span class=\"o\">(</span><span class=\"n\">CoeHTCT</span> <span class=\"n\">Nat</span> <span class=\"n\">Rat</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">MyRing</span><span class=\"o\">)</span> <span class=\"c1\">-- OK</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">MyRing</span><span class=\"o\">)</span> <span class=\"c1\">-- OK</span>\n<span class=\"k\">#check</span> <span class=\"o\">((</span><span class=\"mi\">100</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyRing</span><span class=\"o\">)</span> <span class=\"c1\">-- OK</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">100</span> <span class=\"o\">:</span> <span class=\"n\">MyRing</span><span class=\"o\">)</span> <span class=\"c1\">-- ERROR: failed to synthesize instance `OfNat MyRing 100`</span>\n</code></pre></div>",
        "id": 432380785,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1712715646
    },
    {
        "content": "<p>I see.</p>",
        "id": 432381120,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712715784
    }
]