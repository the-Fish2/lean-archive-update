[
    {
        "content": "<p>There are a number of <code>erw</code>s in the files <code>Mathlib.RepresentationTheory.Rep</code> and <code>Mathlib.RepresentationTheory.GroupCohomology.Resolution</code> - for instance, when defining morphisms of <code>Rep</code>s (the category-theoretic, bundled definition of group representations). I'm going to extend these files in some PRs soon and didn't like how little <code>simp</code> was helping me/how many <code>erw</code>s I was using. <br>\nSo instead I added a definition of morphisms of unbundled, non-category-theoretic <code>Representation</code>s:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Hom</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">k</span> <span class=\"n\">W</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">Representation</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"n\">Representation</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n    <span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">W</span>\n    <span class=\"n\">comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hom</span> <span class=\"bp\">∘ₗ</span> <span class=\"n\">ρ</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">τ</span> <span class=\"n\">g</span> <span class=\"bp\">∘ₗ</span> <span class=\"n\">hom</span>\n</code></pre></div>\n<p>and just worked with <code>Representation</code>s instead; simp was very helpful and I didn't have to <code>erw</code> anything. Then given a <code>Representation</code> morphism defined using the above, the corresponding morphism of <code>Rep</code>s is 1 line. </p>\n<p>However, this approach seems like a bit of a shame. Getting things for free from the category theory framework is cool; it would be nice to just use<code>Rep</code>s, and actually work out why I'm having to <code>erw</code> things - although I have tried.</p>\n<p>So how would people feel about me adding the unbundled definition <code>Representation.Hom</code>?</p>",
        "id": 418891263,
        "sender_full_name": "Amelia Livingston",
        "timestamp": 1706637179
    },
    {
        "content": "<p>It doesn't shock me that it would be necessary</p>",
        "id": 418901059,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706640944
    },
    {
        "content": "<p>Yes, I think it's sad, but please don't let this obstruct you forever. The unbundled definition is fine.</p>\n<p>That said, if anyone is interested in investigating <code>erw</code>s in the category theory library, I suspect there are still better solutions.</p>\n<p>It would be great to have an <code>erw?</code> tool, which would print info messages explaining which subterms obstructued just using <code>rw</code>. I think this is not impossible for anyone who has previously read the code of <code>kabstract</code> (or would like to learn how the internal of <code>rw</code> operate!)</p>",
        "id": 418928608,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1706652474
    },
    {
        "content": "<p>Nearly always the problem is that we have <code>dsimp</code> lemmas that operate in the implicit arguments of some category theoretic statement (e.g. modifying the objects in a composition), that then cause lemmas to not match syntactically and cause <code>rw</code> to fail.</p>\n<p>Understanding exactly what is going wrong in specific cases would hopefully make it possible to either remove the unhelpful dsimp lemmas, or restate the theorems so their implicit arguments match what will be seen \"in the wild\" after a <code>dsimp</code> in a proof.</p>",
        "id": 418928820,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1706652572
    },
    {
        "content": "<p>Thank you very much! There are some <code>erw</code>s that this approach won't affect, so I might try messing around with the dsimp lemmas in any case.</p>",
        "id": 418992072,
        "sender_full_name": "Amelia Livingston",
        "timestamp": 1706691161
    }
]