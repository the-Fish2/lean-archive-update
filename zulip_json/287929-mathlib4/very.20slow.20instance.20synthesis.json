[
    {
        "content": "<p>The following takes something like five whole seconds to run:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">FiniteDimensional</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">ℂ</span> <span class=\"bp\">×</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">ℂ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">infer_instance</span>\n</code></pre></div>\n<p>Any thoughts on what is making this so slow?</p>",
        "id": 431682092,
        "sender_full_name": "David Loeffler",
        "timestamp": 1712417140
    },
    {
        "content": "<p>For me, just over half of the time spent is in the statement</p>",
        "id": 431683297,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712418222
    },
    {
        "content": "<p>It takes most of the actual TC time working on <code>ContinuousLinearMap.module =?= Module.complexToReal (ℂ × ℂ →L[ℂ] ℂ)</code></p>",
        "id": 431683443,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712418355
    },
    {
        "content": "<p>It also seems to become slower if you import <em>too much</em> of Mathlib. With a minimal set of imports, namely</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Complex.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Algebra.Module.FiniteDimension</span>\n</code></pre></div>\n<p>it takes about 1.9sec for me; but with <code>import Mathlib</code>, it is more than twice that. </p>\n<p>Running with all of mathlib imported, the output of <code>#minimize_imports</code> has a highly suspect entry, <code>import Mathlib.RingTheory.HopfAlgebra</code>. It looks like whatever rabbit hole instance-synthesis goes down involves visiting the instance <code>CommSemiring.toHopfAlgebra</code> (\"every commutative semiring is a Hopf algebra over itself\") somewhere along the way. But disabling this instance doesn't make the example significantly faster.</p>",
        "id": 431685964,
        "sender_full_name": "David Loeffler",
        "timestamp": 1712420306
    },
    {
        "content": "<p>On my fast machine, with all of mathlib imported. I get 0.61 seconds for <code>FiniteDimensional ℝ (ℂ × ℂ →L[ℂ] ℂ)</code> to be interpreted as a <code>Prop</code> (i.e. checking the statement makes sense), and then 0.50 seconds for <code>infer_instance</code> to work (the proof). Let's switch on <code>set_option trace.profiler true</code> and <code>set_option trace.Meta.synthInstance true</code> to see what's going on.</p>\n<p>Most of the pain in the <code>FiniteDimensional</code> issue is this. The question is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>      <span class=\"o\">[]</span> <span class=\"n\">new</span> <span class=\"n\">goal</span> <span class=\"n\">Module</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">ℂ</span> <span class=\"bp\">×</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">ℂ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">▼</span>\n</code></pre></div>\n<p>Lean can see actions of <code>ℝ</code> on <code>ℂ</code> and of <code>ℂ</code> on <code>ℂ</code>, and to make the algebra work it needs to check that they commute. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[]</span> <span class=\"n\">new</span> <span class=\"n\">goal</span> <span class=\"n\">SMulCommClass</span> <span class=\"n\">ℂ</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℂ</span> <span class=\"bp\">▼</span>\n          <span class=\"o\">[</span><span class=\"n\">instances</span><span class=\"o\">]</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">IsScalarTower.to_smulCommClass</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">IsScalarTower.to_smulCommClass'</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">ModuleCat.sMulCommClass_mk</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">Algebra.to_smulCommClass</span><span class=\"o\">,</span> <span class=\"n\">smulCommClass_self</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">Complex.instSMulCommClassComplexInstSMulRealComplexInstSMulRealComplex</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Unfortunately, Lean is going to work through that list backwards (the right answer is <code>@IsScalarTower.to_smulCommClass'</code>, the second one). The philosophy is that it doesn't really matter what order we work through things because hopefully stuff that fails is going to fail quickly. However this is not the case here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">400800</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">Complex.instSMulCommClassComplexInstSMulRealComplexInstSMulRealComplex</span> <span class=\"n\">to</span> <span class=\"n\">SMulCommClass</span> <span class=\"n\">ℂ</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℂ</span>\n</code></pre></div>\n<p>This instance says \"if R and S act on the reals and the actions commute, then they can be viewed as acting on the complexes and the actions also commute (because the complexes is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\R^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>)\". So now we are led to this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">synthInstance</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">398565</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">SMul</span> <span class=\"n\">ℂ</span> <span class=\"n\">ℝ</span>\n</code></pre></div>\n<p>The trace for this failing instance synthesis is huge: nearly 2000 applications of typeclass instances to go on a wild goose chase. If you turn off instance tracing then it looks like this (although I'm a bit confused about why the numbers don't add up):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">synthInstance</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">339037</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">SMul</span> <span class=\"n\">ℂ</span> <span class=\"n\">ℝ</span> <span class=\"bp\">▼</span>\n                                                                    <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">030130</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">DirectSum.GradeZero.semiring</span> <span class=\"n\">to</span> <span class=\"n\">Semiring</span> <span class=\"o\">(</span><span class=\"n\">Submodule</span> <span class=\"n\">ℂ</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">▶</span>\n                                                                    <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">016200</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">Submodule.idemSemiring</span> <span class=\"n\">to</span> <span class=\"n\">IdemSemiring</span> <span class=\"o\">(</span><span class=\"n\">Submodule</span> <span class=\"n\">ℂ</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">▶</span>\n                                                                    <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">015283</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">Submodule.instIdemCommSemiringSubmoduleToSemiringToAddCommMonoidToNonUnitalNonAssocSemiringToNonAssocSemiringToSemiringToModule</span> <span class=\"n\">to</span> <span class=\"n\">IdemCommSemiring</span>\n                                                                          <span class=\"o\">(</span><span class=\"n\">Submodule</span> <span class=\"n\">ℂ</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">▶</span>\n                                                                    <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">028142</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">DirectSum.GradeZero.commSemiring</span> <span class=\"n\">to</span> <span class=\"n\">CommSemiring</span> <span class=\"o\">(</span><span class=\"n\">Submodule</span> <span class=\"n\">ℂ</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">▶</span>\n                                                                    <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">022209</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">DirectSum.GradeZero.semiring</span> <span class=\"n\">to</span> <span class=\"n\">Semiring</span> <span class=\"o\">(</span><span class=\"n\">Submodule</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">▶</span>\n                                                                    <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">020841</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">❌</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">DirectSum.GradeZero.commSemiring</span> <span class=\"n\">to</span> <span class=\"n\">CommSemiring</span> <span class=\"o\">(</span><span class=\"n\">Submodule</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">▶</span>\n</code></pre></div>\n<p>but I do know that typeclass inference is going nuts behind the scenes.</p>\n<p>So the tl;dr summary for the slowness in the <em>statement</em> is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.profiler</span> <span class=\"n\">true</span> <span class=\"k\">in</span> <span class=\"c1\">-- [0.426561s] on a fast machine</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">SMul</span> <span class=\"n\">ℂ</span> <span class=\"n\">ℝ</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>\n<p>and a dirty hack which speeds things up (by convincing Lean not to try to prove this at all) is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"n\">Complex.instSMulCommClassComplexInstSMulRealComplexInstSMulRealComplex</span>\n  <span class=\"n\">Complex.instIsScalarTowerComplexInstSMulRealComplexInstSMulRealComplex</span>\n</code></pre></div>\n<p>which ensures that Lean doesn't go down that route.</p>",
        "id": 431712675,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712445094
    },
    {
        "content": "<p>(<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Complex.instSMulCommClassComplexInstSMulRealComplexInstSMulRealComplex#doc\">docs#Complex.instSMulCommClassComplexInstSMulRealComplexInstSMulRealComplex</a>)</p>",
        "id": 431713303,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712445801
    },
    {
        "content": "<p>This looks like the case I was afraid of; the <code>GradeZero</code> instances for direct sums are bad, and we should probably scope them</p>",
        "id": 431713514,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712446031
    },
    {
        "content": "<p>(They're supposed to match elements <code>A 0</code> of some family, but this doesn't make sense because every type could potentially be the constant family )</p>",
        "id": 431713526,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712446069
    },
    {
        "content": "<p>What seems to happen is that <code>A</code> remains a metavariable forever, and so Lean fruitlessly unfolds everything it can reach to try and assign it</p>",
        "id": 431713591,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712446153
    },
    {
        "content": "<p>As for the proof, it seems to be a related problem. This time it's</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.profiler</span> <span class=\"n\">true</span> <span class=\"k\">in</span> <span class=\"c1\">-- [0.503354s]</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">SMulCommClass</span> <span class=\"n\">ℂ</span> <span class=\"n\">ℂ</span> <span class=\"n\">ℂ</span>\n</code></pre></div>\n<p>which boils down to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">455496</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">SMul</span> <span class=\"n\">ℂ</span> <span class=\"n\">ℂ</span> <span class=\"bp\">▼</span>\n    <span class=\"o\">[]</span> <span class=\"n\">new</span> <span class=\"n\">goal</span> <span class=\"n\">SMul</span> <span class=\"n\">ℂ</span> <span class=\"n\">ℂ</span> <span class=\"bp\">▼</span>\n      <span class=\"o\">[</span><span class=\"n\">instances</span><span class=\"o\">]</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">Mul.toSMul</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">MulAction.toSMul</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">SMulZeroClass.toSMul</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">Algebra.toSMul</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">GradedMonoid.GradeZero.smul</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">Complex.instSMulRealComplex</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>and again the first choice is a disaster: <code>Complex.instSMulRealComplex</code> says \"if a ring A acts on the reals then it acts on the complexes\" so Lean is back looking for <code>SMul ℂ ℝ</code> again, and again the trace is 2000 lines long. A not particularly unreasonable hack to speed this up would be to make a shortcut instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">SMulCommClass</span> <span class=\"n\">ℂ</span> <span class=\"n\">ℂ</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"n\">smulCommClass_self</span> <span class=\"n\">ℂ</span> <span class=\"n\">ℂ</span>\n</code></pre></div>\n<p>So this is now over twice as fast, but still perhaps annoyingly slow:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"n\">Complex.instSMulCommClassComplexInstSMulRealComplexInstSMulRealComplex</span>\n  <span class=\"n\">Complex.instIsScalarTowerComplexInstSMulRealComplexInstSMulRealComplex</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">SMulCommClass</span> <span class=\"n\">ℂ</span> <span class=\"n\">ℂ</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"n\">smulCommClass_self</span> <span class=\"n\">ℂ</span> <span class=\"n\">ℂ</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.profiler</span> <span class=\"n\">true</span> <span class=\"c1\">-- now only [0.502854s]</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">FiniteDimensional</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">ℂ</span> <span class=\"bp\">×</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">ℂ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 431713676,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712446247
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/very.20slow.20instance.20synthesis/near/431713514\">said</a>:</p>\n<blockquote>\n<p>This looks like the case I was afraid of; the <code>GradeZero</code> instances for direct sums are bad, and we should probably scope them</p>\n</blockquote>\n<p>Though actually</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">DirectSum.GradeZero.semiring</span> <span class=\"n\">DirectSum.GradeZero.commSemiring</span> <span class=\"n\">DirectSum.GradeZero.ring</span> <span class=\"n\">DirectSum.GradeZero.commRing</span>\n</code></pre></div>\n<p>doesn't help much; it just removes all the information from the trace (which is now 2 lines long, but only 25 faster)</p>",
        "id": 431713936,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712446679
    },
    {
        "content": "<p>When you see things like this, it's a good idea to open a PR lowering a little bit the priority of the bad instances, or increasing a little bit the priority of the good instances, and bench it to  see if it has nasty effects elsewhere. I've done it in <a href=\"https://github.com/leanprover-community/mathlib4/pull/11980\">#11980</a> for the case at hand.</p>",
        "id": 431733785,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1712467939
    },
    {
        "content": "<p>This looks useful (three files get a good speedup, no bad consequence), so I'm setting this as awaiting-review.</p>",
        "id": 431743916,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1712478057
    },
    {
        "content": "<p>That's wonderful, thanks Sebastien!</p>",
        "id": 431747507,
        "sender_full_name": "David Loeffler",
        "timestamp": 1712481200
    }
]