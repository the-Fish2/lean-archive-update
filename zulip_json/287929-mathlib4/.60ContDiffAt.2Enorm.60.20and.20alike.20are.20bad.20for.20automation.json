[
    {
        "content": "<p>The theorem <code>ContDiffAt.norm</code> has type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"bp\">ùïú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">IsROrC</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">InnerProductSpace</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">NormedSpace</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_4</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">inst_3</span> <span class=\"o\">:</span> <span class=\"n\">NormedSpace</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"bp\">‚àû</span><span class=\"o\">},</span> <span class=\"n\">ContDiffAt</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">‚â†</span> <span class=\"mi\">0</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">ContDiffAt</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">‚Ü¶</span> <span class=\"bp\">‚Äñ</span><span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"bp\">‚Äñ</span><span class=\"o\">)</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>The issue that the field <code>ùïú</code> does not appear in the conclusion, because of this the theorem can't be used by <code>fun_prop</code>. How to tackle this? What about introducing a class <code>SmoothNorm</code> similar to <code>ContinuousMul</code>? Any other idea?</p>",
        "id": 422304670,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708375491
    },
    {
        "content": "<p>Introducing a <code>SmoothNorm</code> typeclass would only move the problem, because then this we can‚Äôt have an instance from <code>InnerProductSpace</code> to <code>SmoothNorm</code> because it would have to guess the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">k</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{k}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">k</span></span></span></span></p>",
        "id": 422305713,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708376088
    },
    {
        "content": "<p><del>What if <code>InnerProductSpace</code> extends <code>SmoothNorm</code>?</del> (...it won't work)</p>",
        "id": 422306061,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708376277
    },
    {
        "content": "<p>Is \"the norm satisfies the parallelogram rule\" sufficient?</p>",
        "id": 422313572,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708380941
    },
    {
        "content": "<p>Well it has to be because then it comes from a inner product space (which you can assume to be real of course), but I don‚Äôt think it would be natural to reroute the proof that way</p>",
        "id": 422316559,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708382789
    },
    {
        "content": "<p>What I mean is, could we have a typeclass for that instead?</p>",
        "id": 422318306,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708383680
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> does it help that <code>ùïú</code> is marked as a <code>semiOutParam</code> in the definition of <code>IsROrC</code>? That's how Lean deals with this issue in type class inference.</p>",
        "id": 422320453,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708385084
    },
    {
        "content": "<p>In the definition of <code>IsROrC</code> or <code>InnerProductSpace</code>?</p>",
        "id": 422320715,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708385325
    },
    {
        "content": "<p>Yeah if it would be in InnerProductSpace then I think it would help.</p>",
        "id": 422320795,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708385393
    },
    {
        "content": "<p>What happens if I try to synthesize <code>InnerProductSpace K? X</code> and there is <code>InnerProductSoace R X</code> in the context? Would <code>R</code> get assigned to <code>K?</code></p>",
        "id": 422320928,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708385506
    },
    {
        "content": "<p>I don't know. Try?</p>",
        "id": 422322369,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708386771
    },
    {
        "content": "<p>Tomorrow I will, it is dinner time for me now</p>",
        "id": 422322395,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708386814
    },
    {
        "content": "<p>Here is my attempt but I can't get it to infer <code>K</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Qq</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IsROrC</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">InnerProductSpace</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">outParam</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">IsROrC</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">IsROrC</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">‚ü®‚ü©</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">InnerProductSpace</span> <span class=\"n\">Nat</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">‚ü®‚ü©</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">MetaM</span> <span class=\"n\">Unit</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">K</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">mkFreshExprMVarQ</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">inst</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">mkFreshExprMVarQ</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">IsROrC</span> <span class=\"bp\">$</span><span class=\"n\">K</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">InnerProductSpace</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)]</span>\n\n  <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">inst4</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">synthInstance</span><span class=\"bp\">?</span> <span class=\"n\">e</span> <span class=\"k\">then</span>\n    <span class=\"n\">IO.println</span> <span class=\"s2\">\"success\"</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">throwError</span> <span class=\"s2\">\"failure\"</span>\n</code></pre></div>",
        "id": 422455186,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708446539
    },
    {
        "content": "<p>Here's a question: should <code>ùïú</code> be marked as a <code>semiOutParam</code> in any class that takes <code>IsROrC ùïú</code> as an argument? (obviously this includes <code>InnerProductSpace</code>)</p>",
        "id": 422455609,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708446661
    },
    {
        "content": "<p>I have no idea and it does not help in the example above.</p>",
        "id": 422455722,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708446704
    },
    {
        "content": "<p>Ohh <code>#synth InnerProductSpace _ Nat</code> actually succeeds. I have no idea what is going on.</p>",
        "id": 422456088,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708446803
    },
    {
        "content": "<p>but it succeeds only with <code>class IsROrC (Œ± : outParam Type)</code> adding just <code>semiOutParam</code> won't do it</p>",
        "id": 422456344,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708446874
    },
    {
        "content": "<p>From a completely different viewpoint, I would prefer if we have specialized <code>Norm2</code> typeclass and some version of <code>InnerProductSpace</code> that does not induce norm and distance. I want inner product space structure on <code>X√óY</code> and <code>Œπ‚ÜíY</code>without this it will be impossible/very hard to get <code>fun_trans</code>(upcoming tactic) to compute gradients and adjoints.</p>",
        "id": 422459380,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708447846
    },
    {
        "content": "<p>This is very orthogonal to the way mathlib has been doing things for a long time, is it a problem to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PiLp#doc\">docs#PiLp</a> ?</p>",
        "id": 422459891,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708447996
    },
    {
        "content": "<p>Or more generally <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WithLp#doc\">docs#WithLp</a></p>",
        "id": 422459977,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708448035
    },
    {
        "content": "<p>I will have to think about it a bit more. Internally the tactic is doing a lot of uncurrying, I would have to modify it to use <code>WithLp 2 (X√óY)</code> in certain cases and I'm not sure how to go about it.</p>",
        "id": 422460348,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708448154
    },
    {
        "content": "<p>Tomas, you can't make the argument to <code>IsROrC</code> an <code>outParam</code>, as that would mean there's only one type that's allowed (at least, practically speaking) as the argument to <code>IsROrC</code>. The point of <code>semiOutParam</code> is that, although there's more than one possible value of <code>Œ±</code>, the search space is small (there are only two existing instances).</p>",
        "id": 422466228,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708449855
    },
    {
        "content": "<p>Yeah I know that <code>outParam</code> is a no go for <code>IsROrC</code>. I was just curious when does the typeclass synthesis resolves the type <code>K</code>.</p>",
        "id": 422474226,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708452620
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/287929-mathlib4/topic/.60ContDiffAt.2Enorm.60.20and.20alike.20are.20bad.20for.20automation/near/422313572\">said</a>:</p>\n<blockquote>\n<p>Is \"the norm satisfies the parallelogram rule\" sufficient?</p>\n</blockquote>\n<p>I realized now I brought this up before <a href=\"#narrow/stream/113488-general/topic/Dealing.20with.20different.20paths.20in.20type.20class.20inference/near/343124346\">here</a></p>",
        "id": 422476142,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708453294
    }
]