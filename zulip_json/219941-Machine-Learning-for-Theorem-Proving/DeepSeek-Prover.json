[
    {
        "content": "<p>We submitted a new paper on arxiv and successfully achieved large-scale synthesis of formal proof data for Lean4. The trained model successfully proved 52% of theorems using the Lean4 language on the miniF2F benchmark. <a href=\"http://arxiv.org/abs/2405.14333\">http://arxiv.org/abs/2405.14333</a></p>",
        "id": 440441302,
        "sender_full_name": "Huajian Xin",
        "timestamp": 1716528699
    },
    {
        "content": "<p>Example b,  in section A.3, which I think is one of your claimed IMO problems, the formal statement does not agree at all with the informal statement, and as a consequence a trivial proof is acceptable that doesn't at all reflect the difficulty of the problem.</p>",
        "id": 440442082,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1716529344
    },
    {
        "content": "<p>The problem confused the <code>Nat.sqrt</code> function with the actual square root function <code>Nat \\to Real</code>!</p>",
        "id": 440442094,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1716529363
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Synthetic.20dataset.20generation/near/440442082\">said</a>:</p>\n<blockquote>\n<p>Example b,  in section A.3, which I think is one of your claimed IMO problems, the formal statement does not agree at all with the informal statement, and as a consequence a trivial proof is acceptable that doesn't at all reflect the difficulty of the problem.</p>\n</blockquote>\n<p>Yes, errors still exist in the FIMO benchmark (<a href=\"https://github.com/liuchengwucn/FIMO\">https://github.com/liuchengwucn/FIMO</a>) and require further inspection.</p>",
        "id": 440442372,
        "sender_full_name": "Huajian Xin",
        "timestamp": 1716529634
    },
    {
        "content": "<p>Maybe you shouldn't make claims about solving IMO problems then?</p>",
        "id": 440442383,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1716529650
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Synthetic.20dataset.20generation/near/440442383\">said</a>:</p>\n<blockquote>\n<p>Maybe you shouldn't make claims about solving IMO problems then?</p>\n</blockquote>\n<p>In addition to the FIMO benchmark, we have also solved some IMO problems in miniF2F. These have received more community inspections. We will add these examples to the paper update. Thank you for your correction!</p>",
        "id": 440442489,
        "sender_full_name": "Huajian Xin",
        "timestamp": 1716529733
    },
    {
        "content": "<p>I'm confused by example a as well. The problem statement is about positive integers, yet the formal statement extends the domain to zero, and then the proof immediately uses facts about the function at zero. I think this means this proof is also unrelated to the actual problem.</p>",
        "id": 440442622,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1716529820
    },
    {
        "content": "<p>There is also a problem in Example a, in section A.3, where the informal statement only allows positive (nonzero) integers, but the formal statement allows zero, and the proof is based on the use of zero.</p>",
        "id": 440442625,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1716529823
    },
    {
        "content": "<p>Are the IMO problems from miniF2F available?</p>",
        "id": 440442840,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1716529956
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Synthetic.20dataset.20generation/near/440442840\">said</a>:</p>\n<blockquote>\n<p>Are the IMO problems from miniF2F available?</p>\n</blockquote>\n<p>Yes, the following are five proofs generated by our model of IMO from miniF2F:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">imo_1959_p1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">gcd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">21</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">14</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">=</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ring</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">21</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">14</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ring</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">imo_1964_p2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h₃</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">norm_num</span>\n<span class=\"w\">    </span><span class=\"n\">ring_nf</span>\n<span class=\"w\">    </span><span class=\"n\">nlinarith</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mul_self_nonneg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">mul_self_nonneg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">mul_self_nonneg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">imo_1964_p1_2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">revert</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">    </span><span class=\"n\">norm_num</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">    </span><span class=\"n\">induction'</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">IH</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">IH</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IH</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">IH</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">IH</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">pow_succ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IH</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">mul_mod</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_mod</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">mod_eq_of_lt</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">H</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">mod_add_div</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">H</span>\n<span class=\"w\">  </span><span class=\"n\">revert</span><span class=\"w\"> </span><span class=\"n\">H</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"n\">omega</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">imo_1965_p2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₃</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h₄</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₅</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₆</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h₇</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₈</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h₉</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine'</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">cases'</span><span class=\"w\"> </span><span class=\"n\">le_total</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">cases'</span><span class=\"w\"> </span><span class=\"n\">le_total</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">cases'</span><span class=\"w\"> </span><span class=\"n\">le_total</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">h''</span><span class=\"w\"> </span><span class=\"n\">h''</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">nlinarith</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">imo_1983_p6</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h₃</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h₄</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">nlinarith</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">sq_nonneg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">sq_nonneg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h₅</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">nlinarith</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">sq_nonneg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">sq_nonneg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h₆</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">nlinarith</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">sq_nonneg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">sq_nonneg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">nlinarith</span>\n</code></pre></div>",
        "id": 440445426,
        "sender_full_name": "Huajian Xin",
        "timestamp": 1716531548
    },
    {
        "content": "<p>In fact, many benchmarks currently widely used in the field of AI have errors. For example, we found that a theorem of miniF2F also has errors: the premise of <a href=\"https://github.com/facebookresearch/miniF2F/blob/main/lean/src/test.lean#L946\">https://github.com/facebookresearch/miniF2F/blob/main/lean/src/test.lean#L946</a> should be <code>(3 * n) % 11 = 2</code>.</p>",
        "id": 440448637,
        "sender_full_name": "Huajian Xin",
        "timestamp": 1716533080
    },
    {
        "content": "<p>I think one should be very careful to not claim anything that could be interpreted as \"we solve an IMO problem\" when in fact you mean \"we solve a broken problem from a poorly maintained database\". </p>\n<p>Moreover, I think papers that are insufficiently careful in this regard should be promptly updated. Otherwise it looks bad for everyone, no?</p>",
        "id": 440454215,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1716535280
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Synthetic.20dataset.20generation/near/440454215\">said</a>:</p>\n<blockquote>\n<p>I think one should be very careful to not claim anything that could be interpreted as \"we solve an IMO problem\" when in fact you mean \"we solve a broken problem from a poorly maintained database\". </p>\n<p>Moreover, I think papers that are insufficiently careful in this regard should be promptly updated. Otherwise it looks bad for everyone, no?</p>\n</blockquote>\n<p>Yes, we will update the paper immediately, thank you for your correction!</p>",
        "id": 440454944,
        "sender_full_name": "Huajian Xin",
        "timestamp": 1716535523
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481527\">Huajian Xin</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Synthetic.20dataset.20generation/near/440442372\">said</a>:</p>\n<blockquote>\n<p>Yes, errors still exist in the FIMO benchmark (<a href=\"https://github.com/liuchengwucn/FIMO\">https://github.com/liuchengwucn/FIMO</a>) and require further inspection.</p>\n</blockquote>\n<p>I'm somewhat sad to see that this dataset was done in lean 3, especially if the GitHub claim that it was built only 5 months ago is to be believed. Are there plans to update it to lean 4?</p>",
        "id": 440474525,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1716543401
    },
    {
        "content": "<p>My understanding is that formalised datasets with low-quality data are just generally problematic in this field, because you see an issue where a dataset says \"this is a formalisation of question X from exam Y\" and you look at it and think \"well actually it's not, because you tell the computer the answer/have failed to formalise the question accurately/have only formalised part of the question\" and then your instinct is to fix the dataset but then you've changed the dataset so you're invalidating all the claims in the literature of the form \"we got Z% on this dataset\". Furthermore you are probably genuinely invalidating them in the sense that they got the original question right because the AI spotted e.g. that 1/0=0 in Lean making the question trivial, and once you've fixed this the AI would never have solved the problem. </p>\n<p>This is particularly problematic when the problem is labelled as \"an IMO problem\" and then the splash is \"we solved an IMO problem\". But in general this is something that researchers like <span class=\"user-mention\" data-user-id=\"481527\">@Huajian Xin</span> can do little about, the problem is with the datasets.</p>\n<p>My instinct is that, despite the niggles above (and I'll post one or two more below), this is a pretty impressive piece of work. As my earlier comment above indicated, two days ago I was skeptical about getting computers to generate datasets which would be of any use at all in domains like number theory, even though I'm aware of the alphageometry work which seemed to work great for Euclidean geometry; I'm also aware of the fact that Euclidean geometry is a decidable domain and elementary number theory is not, which is some kind of indication that elementary number theory is in some sense much harder. I know this is a very unfashionable viewpoint amongst the AI crowd, but I personally would be very interested in seeing a few random samples from the \"dataset of 869,659 high-quality natural language math problems\" and their autoformalisations!</p>\n<p>My nit is section 5.2, example (b). I'm not entirely sure what this section is supposed to be demonstrating, but I cannot make any sense of the question. Right now (translated a little) this question says: \"given a real number D and the condition that D=-a-25b-11c for some real numbers a,b,c, prove that D^2=154\". This question is obviously complete nonsense. In the paper it says \"the computer formalised this statement in one way, and obviously this is complete nonsense; here is the correct way\". But every way to formalise this nonsense question is nonsense.</p>",
        "id": 440474557,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1716543413
    },
    {
        "content": "<blockquote>\n<p>The formalization employs the <code>Matrix.det</code> function to compute the determinant,<br>\nutilizing the <code>![...]</code> notation for lists of lists in Lean to represent the matrix rows.</p>\n</blockquote>\n<p>A nit and a complaint: <code>![x, y, z]</code> is notation for tuples not lists, and matrices  should be written <code>!![a, b; c, d]</code> not <code>![![a, b], ![c, d]]</code>, the latter has the wrong type and gets the wrong multiplication (though does end up meaning the right thing anyway in your example)</p>",
        "id": 440476412,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1716544167
    },
    {
        "content": "<blockquote>\n<p>Right now (translated a little) this question says: \"given a real number D and the condition that D=-a-25b-11c for some real numbers a,b,c, prove that D^2=154\".</p>\n</blockquote>\n<p>The statement actually says \"for real numbers a,b,c, ...\" which I guess is meant to be interpreted as \"for all real numbers a,b,c\" rather than \"there exists real numbers a,b,c\" as you have done. And given that the header is \"proving under inconsistent assumptions\" I guess the point is that this assumption is supposed to be inconsistent and hence D^2=154 is provable. But I guess it is \"complete nonsense\" if you reason that no one would ever pose a question with inconsistent hypotheses which doesn't ask to prove this unless it was a mistake (i.e. the D^2=154 part is a red herring and would not appear in real mathematics).</p>",
        "id": 440476541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1716544218
    },
    {
        "content": "<p>But the original informal statement is really ambiguous about this quantifier</p>",
        "id": 440476762,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1716544311
    },
    {
        "content": "<p>This is not the first paper where an AI system found a proof for a claimed IMO or IMO shortlist problem in a benchmark that then proved to be a completely incorrect statement for obvious reasons to do with getting types wrong (a previous one was a miniF2F statement wrongly using natural number subtraction when negative numbers could occur in the original problem). It's hard to get formal statements 100% right without also formalizing human solutions (mistakes in stating a lemma formally often get discovered when you try to formalize a proof), which would be a lot of work, but I'm pretty sure it would be possible to do a lot better than miniF2F (or, from the evidence of this paper, FIMO) simply by having a checklist of rules for how to choose types in formal statements and common pitfalls such as natural number subtraction and division.</p>",
        "id": 440505405,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1716555940
    },
    {
        "content": "<p>Are there examples of human-formalized statements which were found to be inaccurate due to small details, yet somehow could still be proven with the expected human proof strategy due to making the same mistakes in the proof?</p>",
        "id": 440515899,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1716559304
    },
    {
        "content": "<p>Does <a href=\"https://github.com/leanprover-community/mathlib4/pull/13134\">#13134</a> count?</p>",
        "id": 440516402,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1716559444
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481527\">Huajian Xin</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/DeepSeek-Prover/near/440441302\">said</a>:</p>\n<blockquote>\n<p>We submitted a new paper on arxiv and successfully achieved large-scale synthesis of formal proof data for Lean4. The trained model successfully proved 52% of theorems using the Lean4 language on the miniF2F benchmark. <a href=\"http://arxiv.org/abs/2405.14333\">http://arxiv.org/abs/2405.14333</a></p>\n</blockquote>\n<p>Thanks for the excellent work! I am very interested in this work, please allow me to ask a noob question, i think the proof verification should use a lean4 server or something similar, so how to use lean4 in python?</p>",
        "id": 440517792,
        "sender_full_name": "Max Cui",
        "timestamp": 1716559855
    },
    {
        "content": "<p>Regarding the paper, there is seemingly an error in A.2.b, which says:</p>\n<blockquote>\n<p>the logical structure with existential quantifiers (∃) and implications (→) aligns well with the<br>\nproblem’s requirements.</p>\n</blockquote>\n<p>I can't make out what the \"problems requirements\" are here, but the statement of</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">;</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">;</span>\n<span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">k</span>\n</code></pre></div>\n<p>is surely not what was intended, because I can prove it by choosing <code>m = k = 0</code> and ignoring all the statements about <code>f</code>. I think this is falling into the <code>∃ x, 0 &lt; x ∧ P x</code> (there exists a positive x satisfying P) vs <code>∃ x, 0 &lt; x → P x</code> (meaningless) trap</p>",
        "id": 440518650,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1716560139
    },
    {
        "content": "<p>Why don’t those papers use <a href=\"https://dwrensha.github.io/compfiles/\">https://dwrensha.github.io/compfiles/</a> instead of miniF2F? Are there so few problems in David’s database that it cannot be used?</p>",
        "id": 440519995,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1716560581
    },
    {
        "content": "<p>One fear I've seen (which I think is why the hoskinson miniF2F lean4 dataset is not on GitHub) is that anything on GitHub with solutions quickly becomes ineligible for using as a benchmark due to LLMs training on GitHub data</p>",
        "id": 440520900,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1716560886
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Synthetic.20dataset.20generation/near/440519995\">said</a>:</p>\n<blockquote>\n<p>Why don’t those papers use <a href=\"https://dwrensha.github.io/compfiles/\">https://dwrensha.github.io/compfiles/</a> instead of miniF2F? Are there so few problems in David’s database that it cannot be used?</p>\n</blockquote>\n<p>Thank you so much for your suggestion! We use miniF2F just because most of the existing research in the field of AI uses this data set, and our work is convenient for comparison with previous work. We will try David’s database later.</p>",
        "id": 440521205,
        "sender_full_name": "Huajian Xin",
        "timestamp": 1716560990
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"723604\">Max Cui</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/DeepSeek-Prover/near/440517792\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"481527\">Huajian Xin</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/DeepSeek-Prover/near/440441302\">said</a>:</p>\n<blockquote>\n<p>We submitted a new paper on arxiv and successfully achieved large-scale synthesis of formal proof data for Lean4. The trained model successfully proved 52% of theorems using the Lean4 language on the miniF2F benchmark. <a href=\"http://arxiv.org/abs/2405.14333\">http://arxiv.org/abs/2405.14333</a></p>\n</blockquote>\n<p>Thanks to <span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span>  for the great work <a href=\"https://github.com/leanprover-community/repl\">REPL</a>, we found it to be very efficient when doing large-scale verification.<br>\nThanks for the excellent work! I am very interested in this work, please allow me to ask a noob question, i think the proof verification should use a lean4 server or something similar, so how to use lean4 in python?</p>\n</blockquote>",
        "id": 440522327,
        "sender_full_name": "Huajian Xin",
        "timestamp": 1716561344
    },
    {
        "content": "<p>Exciting work.  I look forward to understanding it better.  I do worry that the MiniF2F theorems are compromised.  I'm not sure the LLMs you use take much effort to remove them from training and I know for example that <span class=\"user-mention\" data-user-id=\"243791\">@David Renshaw</span> has been writing proofs for most of them in Lean and posting them publically.  Also since you take a DSP approach, one also has to grapple with the fact that most of these problems have public natural language solutions that have been on the internet for years.  I'm not saying there is a good answer, but it is something worth thinking about coming up with a better solution towards.</p>",
        "id": 440527152,
        "sender_full_name": "Jason Rute",
        "timestamp": 1716562943
    },
    {
        "content": "<p>Also, do you think it is confusing we now have a \"DeepSeek-Prover\" and a <a href=\"https://openreview.net/forum?id=lxlMFlzZO9\">DS-Prover</a> in Lean?  At a quick glance, I can't figure out which one \"DS-Prover\" in figure 1 is referring to. :/</p>",
        "id": 440528488,
        "sender_full_name": "Jason Rute",
        "timestamp": 1716563419
    },
    {
        "content": "<p>Another thing that I worry about is the vast amount of compute going into inference to get these scores.  I really appreciate the details in your column \"generation times\", but I think there are still a lot of questions to be addressed by the community.  It is an important observation that \"cumulative\" approaches work.  Unlike usual ensemble approaches in machine learning, with theorem proving one knows the answer is correct and doesn't have to average solutions, but can take the best score of all models/parameters/runs.  This can be taken to the extreme.  Josef Urban likes to claim that automated methods can solve say 80% of Mizar theorems.  (If someone could remind me where to find this reference that would be great.)  But the catch is that he is taking the union of ALL approaches ever tried.  One could do the same in MiniF2F, taking the union of all approaches ever tried over all theorem provers.  This isn't a silly idea exactly, but it also isn't clear how to make it practical.  Is one spending many GPU-days solving a problem?  Or, is one just quickly running a solver with many configurations?  (In my experience it is better to run 5 solvers for 1 minute each than 1 solver for 5 minutes.)  I think we need better metrics for inference compute used and inference time used, or benchmarks (like in <a href=\"https://arxiv.org/abs/2401.02949\">my recent paper</a>) where the compute and time are capped at something reasonable.</p>",
        "id": 440533137,
        "sender_full_name": "Jason Rute",
        "timestamp": 1716565271
    },
    {
        "content": "<p>Should we move the messages in this thread to <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/DeepSeek-Prover\">https://leanprover.zulipchat.com/#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/DeepSeek-Prover</a> which seems to be the announcement for this paper?</p>",
        "id": 440534350,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1716565759
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/DeepSeek-Prover/near/440528488\">said</a>:</p>\n<blockquote>\n<p>Also, do you think it is confusing we now have a \"DeepSeek-Prover\" and a <a href=\"https://openreview.net/forum?id=lxlMFlzZO9\">DS-Prover</a> in Lean?  At a quick glance, I can't figure out which one \"DS-Prover\" in figure 1 is referring to. :/</p>\n</blockquote>\n<p>Thanks for your comment! Sorry for the confusion, DS-Prover is our abbreviation for DeepSeek-Prover, and we will correct these problems in an updated version.</p>",
        "id": 440537325,
        "sender_full_name": "Huajian Xin",
        "timestamp": 1716566870
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/DeepSeek-Prover/near/440533137\">said</a>:</p>\n<blockquote>\n<p>Another thing that I worry about is the vast amount of compute going into inference to get these scores.  I really appreciate the details in your column \"generation times\", but I think there are still a lot of questions to be addressed by the community.  It is an important observation that \"cumulative\" approaches work.  Unlike usual ensemble approaches in machine learning, with theorem proving one knows the answer is correct and doesn't have to average solutions, but can take the best score of all models/parameters/runs.  This can be taken to the extreme.  Josef Urban likes to claim that automated methods can solve say 80% of Mizar theorems.  (If someone could remind me where to find this reference that would be great.)  But the catch is that he is taking the union of ALL approaches ever tried.  One could do the same in MiniF2F, taking the union of all approaches ever tried over all theorem provers.  This isn't a silly idea exactly, but it also isn't clear how to make it practical.  Is one spending many GPU-days solving a problem?  Or, is one just quickly running a solver with many configurations?  (In my experience it is better to run 5 solvers for 1 minute each than 1 solver for 5 minutes.)  I think we need better metrics for inference compute used and inference time used, or benchmarks (like in <a href=\"https://arxiv.org/abs/2401.02949\">my recent paper</a>) where the compute and time are capped at something reasonable.</p>\n</blockquote>\n<p>As for the efficiency of theorem proving, since we use naive sampling to generate the entire proof instead of performing tree search step-by-step, all model generation is independent of each other and can be parallelized without any time dependence. Therefore, if there is strong enough parallel computing The proof can be performed very quickly on a capable GPU server. <br>\nIn our experiments, we can complete the evaluation of miniF2F with 32 samples in 34 minutes using two servers each with 8 40G Nvidia A100 GPUs and a 350-core CPU, and the average time per question was less than 5 seconds. Even without such large-scale parallel experiments, the time required for proving a single theorem test is considerable.</p>",
        "id": 440537682,
        "sender_full_name": "Huajian Xin",
        "timestamp": 1716566990
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"481527\">@Huajian Xin</span>  How much inference compute is used for the claimed 52% number?</p>",
        "id": 440538090,
        "sender_full_name": "Jason Rute",
        "timestamp": 1716567104
    },
    {
        "content": "<p>That is more than 32 samples, right?</p>",
        "id": 440538187,
        "sender_full_name": "Jason Rute",
        "timestamp": 1716567134
    },
    {
        "content": "<p>But as for your 32-samples numbers, 40 GPU-seconds per theorem is quite reasonable compared to a lot of other approaches.</p>",
        "id": 440538454,
        "sender_full_name": "Jason Rute",
        "timestamp": 1716567254
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/DeepSeek-Prover/near/440538090\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"481527\">Huajian Xin</span>  How much inference compute is used for the claimed 52% number?</p>\n</blockquote>\n<p>Yes, this result is a combination of all the evaluation experimental results we have conducted in this work. However, the pass rate at 128 samples is already good, and more samples do not increase much compared to the inference cost. We believe that in general it is still economical to use the 7B model for whole-proof generation.</p>",
        "id": 440539775,
        "sender_full_name": "Huajian Xin",
        "timestamp": 1716567783
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Synthetic.20dataset.20generation/near/440474557\">said</a>:</p>\n<blockquote>\n<p>My understanding is that formalised datasets with low-quality data are just generally problematic in this field, because you see an issue where a dataset says \"this is a formalisation of question X from exam Y\" and you look at it and think \"well actually it's not, because you tell the computer the answer/have failed to formalise the question accurately/have only formalised part of the question\" and then your instinct is to fix the dataset but then you've changed the dataset so you're invalidating all the claims in the literature of the form \"we got Z% on this dataset\". Furthermore you are probably genuinely invalidating them in the sense that they got the original question right because the AI spotted e.g. that 1/0=0 in Lean making the question trivial, and once you've fixed this the AI would never have solved the problem. </p>\n<p>This is particularly problematic when the problem is labelled as \"an IMO problem\" and then the splash is \"we solved an IMO problem\". But in general this is something that researchers like <span class=\"user-mention silent\" data-user-id=\"481527\">Huajian Xin</span> can do little about, the problem is with the datasets.</p>\n</blockquote>\n<p>I think there's a tension here between different uses of such benchmarks.</p>\n<ul>\n<li>If you want to compare performance of one AI with another, a fixed benchmark may be appropriate.</li>\n<li>But if you want to make externally meaningful assertions about the achievements of your AI, you want a simple, correct, externally meaningful description of the contents of the benchmark, such as \"all IMO shortlist algebra and number theory problems from 2006 to 2021\", and so want to fix any mistakes found in the benchmark. Note that FIMO is <em>not</em> all algebra and number theory problems from that period, only a subset (in easy-mode, i.e. with answers to \"determine\" problems provided) whose statements were successfully autoformalized. It's not clear how the choice of this subset might bias statistics of how many problems get solved by an AI; for externally meaningful statistics, a <em>complete</em> set of all shortlist problems in given categories from a given period would be better (and even better would be a complete set without excluding combinatorics or geometry). This incompleteness also affects use of Compfiles as a benchmark as well.</li>\n<li>From the mathlib community point of view, these formalizations are most valuable if solutions are formalized as well and all relevant lemmas are added to mathlib (if formalizing is done with an eye to factoring out as much as possible in general form for mathlib) - formalizing such problems serves to test whether relevant parts of mathlib have all the lemmas needed to make it convenient to apply the theory in specific cases; completeness is less important, though personally I'd like to see formal solutions to all 386 past IMO problems in the mathlib archive. Benchmarks might not want solutions online, though in practice all these problems will have informal solutions online in material that LLMs have likely trained on.</li>\n</ul>",
        "id": 440545073,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1716569836
    },
    {
        "content": "<p>Very impressive results! Sorry to bring some bad news, but I carefully read the examples of FIMO solved and I don't think either of them are formulated in Lean correctly (not the authors' fault):</p>\n<p>In section A.3.2:</p>\n<p><code>fimo_2009_algebra_p3</code> is stated in natural language for with a property for positive integers x y, but the Lean statement assumes x y : Nat. This allows the model to find a very short proof (note the induction is not needed), because you can just take y = 0 and the answer is immediate by linarith.</p>\n<p><code>fimo_2016_algebra_p5_1</code> is stated in natural language for square root of n, but translated to n.sqrt instead of Real.sqrt n, resulting in a super short proof that takes a = n.sqrt and b = 1 and concludes by simp.</p>\n<p>So it turns out both examples of IMO problems solved are false positives. It would have been very great if a model could actually solve a P3 problem; it is still very impressive the model can find these bugs and abuse them.</p>",
        "id": 440557407,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1716574838
    },
    {
        "content": "<p>Ah sorry, I just saw this was already posted somewhere else. So the above is just reposting something  from another conversation</p>",
        "id": 440558525,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1716575356
    },
    {
        "content": "<p>26 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"219941\" href=\"/#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Synthetic.20dataset.20generation\">#Machine Learning for Theorem Proving &gt; Synthetic dataset generation</a> by <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span>.</p>",
        "id": 440561548,
        "sender_full_name": "Notification Bot",
        "timestamp": 1716576758
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"631691\">Thomas Zhu</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/DeepSeek-Prover/near/440558525\">said</a>:</p>\n<blockquote>\n<p>Ah sorry, I just saw this was already posted somewhere else. So the above is just reposting something  from another conversation</p>\n</blockquote>\n<p>I've combined the two threads</p>",
        "id": 440561625,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1716576810
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/DeepSeek-Prover/near/440533137\">said</a>:</p>\n<blockquote>\n<p>Josef Urban likes to claim that automated methods can solve say 80% of Mizar theorems.  (If someone could remind me where to find this reference that would be great.)  </p>\n</blockquote>\n<p><a href=\"https://intelligence.org/2013/12/21/josef-urban-on-machine-learning-and-automated-reasoning/\">https://intelligence.org/2013/12/21/josef-urban-on-machine-learning-and-automated-reasoning/</a></p>",
        "id": 440839163,
        "sender_full_name": "Qian Hong",
        "timestamp": 1716811110
    },
    {
        "content": "<p>This accords with my recollection: Josef did not say 80% now, he said <a href=\"https://arxiv.org/abs/2303.06686\">60% now</a> and 80% in 10 years (20 from the date of that interview)</p>",
        "id": 440907547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1716837481
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> .  I misremembered. But I’m actually referring to the <strong>75%</strong> number in that paper which is also the number on <a href=\"https://github.com/ai4reason/ATP_Proofs\">this website</a>.  In that number he is combining many different solvers.  If we did the same for MiniF2F, Mathlib, or Isabelle/HOL AFP (through the PISA benchmark) we would also probably see really high pass rates.  (Heck, even in our <a href=\"https://arxiv.org/abs/2401.02949\">Graph2Tac paper</a> if we combine <em>all</em> 25 solvers we benchmarked at some point on the test set, we get a combined 50% pass rate, almost twice the pass rate of our best single method.  Of course this naive combining requires x25 more compute than the single best method.)</p>",
        "id": 441025986,
        "sender_full_name": "Jason Rute",
        "timestamp": 1716898302
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"481527\">@Huajian Xin</span> Is it accurate or a typo that 46.3% appears twice in your table 1.  (I could believe it is correct but worth checking. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> )</p>",
        "id": 441374251,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717042447
    },
    {
        "content": "<p>Here is my opinionated summary of this paper:</p>",
        "id": 441390031,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717050473
    },
    {
        "content": "<p>Right now there are two main machine learning approaches to automated theorem proving: (1) A neural-guided tree search like PACT, Reprover/Lean-Copilot, Graph2Tac, etc. and (2) use an LLM to predict the proof in one go.  The latter approach is ambitious and seems to be gaining steam (and it is easy because you can just plug the theorem into an LLM like GPT-4).   But currently, this LLM approach hasn’t worked too well (at least not without also being augmented with another solver like in <a href=\"https://arxiv.org/abs/2210.12283\">Draft-Sketch-Prove</a>).</p>",
        "id": 441390048,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717050479
    },
    {
        "content": "<p>This paper makes me think maybe the LLM-gives-a-proof-in-one-go approach is not only reasonable, but it could rival the neural-guided search approach.  (Especially if the search uses an LLM at each search step as that is prohibitively slow.). This is a reasonably small model and they said here on Zulip that they can get pretty good results in 5 seconds on two (good) GPUs.  This is starting to become practical.</p>",
        "id": 441390096,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717050485
    },
    {
        "content": "<p>To improve the results of the base DeepSeek-Model they use two very well-established approaches to improve any machine-learned theorem prover:</p>",
        "id": 441390106,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717050491
    },
    {
        "content": "<p>(1) Diversity:<br>\nIf there is any diversity in your provers—whether it is the same prover with randomly sampled solutions, similar provers trained with slightly different (hyper-)parameters, or entirely different provers—they will prove more theorems.  (My experience is that the number of theorems proved is approximately logarithmic in the number of diverse proof attempts.)</p>",
        "id": 441390116,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717050497
    },
    {
        "content": "<p>The way they accomplish that here is that they don’t just generate one proof candidate (as typical in ChatGPT or Github Copilot), but hundreds (or hundreds of thousands) of proof candidates.  (This is called pass@k in the literature.)  (Note to developers of tools, this would mean that an LLM integration with an ITP would have to be able to have the ITP check hundreds of generated proofs to know if it needs to attempt another generation.  This is unlike Github Copilot which just gives one result.)</p>",
        "id": 441390128,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717050504
    },
    {
        "content": "<p>(2) <em>Reinforcement learning</em> (RL) (sometimes called <em>expert iteration</em> (EI)).<br>\nThe idea here is that to improve a theorem prover, you can keep trying to prove test theorems and learn from your successful (and unsuccessful) proof attempts to improve your model.  This has been repeatedly shown to work quite well.  And it has two especially helpful advantages for Lean.  First, Lean changes repeatedly so the base LLM model probably confuses Lean 3 with Lean 4 (and even Lean 4 keeps changing in drastic ways every few months).  Second, the test set is not actually Mathlib theorems, but MiniF2F theorems which are high-school challenge problems.  So having more data similar to MiniF2F helps.</p>",
        "id": 441390151,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717050511
    },
    {
        "content": "<p>The challenge with RL/EI is to find the best list of theorems to learn from.  The available options have been the following up until now:</p>\n<ul>\n<li>Use the training theorems (typically theorems from your library). This was done in <a href=\"https://arxiv.org/abs/1805.07563\">Reinforcement Learning of Theorem Proving</a>, <a href=\"https://arxiv.org/abs/1905.10501\">Learning to Reason in Large Theories without Imitation</a>, and <a href=\"https://arxiv.org/abs/2009.03393\">Generative Language Modeling for Automated Theorem Proving</a>.</li>\n<li>Curate a list of formal theorems similar to the test theorems (possibly synthetically).  This was done in <a href=\"https://arxiv.org/abs/2202.01344\">Formal Mathematics Statement Curriculum Learning</a>.</li>\n<li>Curate a list of <em>informal theorems</em> and <em>auto-formalize</em> them into formal theorems.  This was done in <a href=\"https://arxiv.org/abs/2205.12615\">Autoformalization with Large Language Models.</a>.</li>\n</ul>",
        "id": 441390179,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717050522
    },
    {
        "content": "<p>This paper follows the last approach--but with some new ideas.</p>",
        "id": 441390209,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717050537
    },
    {
        "content": "<ul>\n<li>They collect a very large database of high school math competition problems.  (I don’t see many details about the dataset or if they will release it.)</li>\n</ul>",
        "id": 441390274,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717050567
    },
    {
        "content": "<ul>\n<li>They seem to use a dataset of informalized Lean theorems to jump-start the auto-formalizer.</li>\n</ul>",
        "id": 441390288,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717050573
    },
    {
        "content": "<ul>\n<li>Autoformalization often doesn't work.  (In the Autoformalization with LLM models approach, only about 15% of formalizations were correct.)  They do a lot of things to weed out incorrect auto-formalizations early:<ul>\n<li>They have an LLM score the quality of the translation.  They use a fairly detailed prompt (in Appendix A1 of the paper), where they ask the LLM to evaluate if this is a useful translation.</li>\n<li>They check if the hypotheses of the formalization are inconsistent (by trying to prove the negation from the previous hypotheses).  This avoids having a vacuously true translation.</li>\n<li>Only provable translations are used, but to check that the translation is provable, they simultaneously try to prove <em>and disprove</em> the theorem.  (I want to remark that I <a href=\"https://github.com/jasonrute/thoughts-on-ai-for-theorem-proving/blob/main/search.md#turn-search-into-something-adversarial-and-self-supervised\">proposed a similar idea</a> a few years ago, although a bit more involved, which I’ve never had a chance to explore.) This speeds up proof search.  (I don’t think they use <a href=\"https://github.com/haruhisa-enomoto/mathlib4-all-tactics/blob/main/all-tactics.md#slim_check\">slim_check</a>, but that could possibly speed it up even faster.). I assume (but am not sure) that they learn from these negative proofs (including the proofs of that hypotheses are inconsistent).</li>\n</ul>\n</li>\n</ul>",
        "id": 441390317,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717050584
    },
    {
        "content": "<ul>\n<li>I assume (but am not sure) that they further finetune not only the theorem prover, but also the auto-formalizer with the newly found autoformalizations.  So they are using RL to train both a theorem prover and an auto-formalizer.  This is the <em>holy grail</em> aim of this field (mentioned in <a href=\"https://link.springer.com/chapter/10.1007/978-3-030-53518-6_1\">A Promising Path Towards Autoformalization and General Artificial Intelligence</a>).  <em>This might be the furthest we have come on this goal</em>  (but it certainly isn’t yet the full virtuous runaway loop the field is shooting for).</li>\n</ul>",
        "id": 441390332,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717050591
    },
    {
        "content": "<p>Overall I think the results are pretty good (this is one of the best results on MiniF2F) and it looks like they plan to release the 712,073 auto-formalizations (hopefully with the natural language statement and the generated proof, but we will see <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span>).</p>",
        "id": 441390350,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717050601
    },
    {
        "content": "<p>Of course, the reliance on MiniF2F leaves the usual questions:</p>",
        "id": 441390409,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717050610
    },
    {
        "content": "<ul>\n<li>Does this approach also help with generating Mathlib-like theorems?  (Their data is geared to competition problems and auto-formalization of real math would be much harder.)</li>\n</ul>",
        "id": 441390425,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717050616
    },
    {
        "content": "<ul>\n<li>Is MiniF2F still a good benchmark, or is it completely compromised?  (It is even harder since if we make a new benchmark, there are several abandoned projects, like PACT and HTPS, that it would be impossible to test on this new benchmark.)</li>\n</ul>",
        "id": 441390434,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717050621
    },
    {
        "content": "<ul>\n<li>How does this compare per-compute to previous approaches?  In particular, they are doing pass@&lt;a huge number&gt; (possibly just so they can claim state of the art <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span> ), but that might be similar compute-wise to a pass@100 run for a different model that uses tree search or a larger LLM.</li>\n</ul>",
        "id": 441390444,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717050626
    },
    {
        "content": "<ul>\n<li>Any benchmark containing old IMO problems is liable to overclaiming.  I would recommend talking with someone associated with the IMO (or <span class=\"user-mention\" data-user-id=\"266253\">@Joseph Myers</span>) before ever making a “my AI solved an IMO problem” claim.</li>\n</ul>",
        "id": 441390451,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717050632
    },
    {
        "content": "<ul>\n<li>I’m curious how well both the auto-formalizer and theorem prover work on the 10 public AIMO progress prize problems (if they came out after the data scrapping for this project).  (Yes, one needs to also find candidate solutions to the problem before formalizing them, but one could use the DeepSeek-Math model for that, which I think is common for that challenge.)</li>\n</ul>",
        "id": 441390455,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717050635
    },
    {
        "content": "<p>@Huajian Xin Another question I realize I have.  What do you do with the formalizations that you can't prove true but also can't prove false?  Those seem like they would also be useful data for some purpose.  (They could be useful challenge problems for example.)</p>",
        "id": 441476591,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717081160
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"481527\">@Huajian Xin</span> I have another question.  I'm still not sure what you mean by \"cumulative\" in Table 1 and the paper doesn't say anything about it that I can find.  Here are a few possible alternatives.  Which if any is correct?</p>\n<ul>\n<li>You are taking the union over all pass@k runs in Table 1.</li>\n<li>You are taking the union over all iterations in Table 4 where each iteration includes 128 attempts for each problem. (This is my guess.)</li>\n<li>You are including the MiniF2F problems in the problems you learn from and unioning over all attempts at those problems in some reinforcement learning run with multiple training iterations.  (This is what the HTPS paper means by \"cumulative\", but I suspect this is not what you are doing, and it would be a bit suspect if you did it for MiniF2F-Test.)</li>\n<li>You are taking the union over all attempts by any version of DeepSeek-Prover in your paper (Table 1, Table 4, Table 5, etc.).</li>\n</ul>",
        "id": 441575410,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717109800
    },
    {
        "content": "<p>This is somewhat important since this is the number you claim in the paper (and it is higher than any other claimed numbers for MiniF2F that I'm aware of).</p>",
        "id": 441575567,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717109886
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span>  Thank you very much for your insightful and detailed analysis! I apologize for the typos and any confusion. Here are my clarifications:</p>\n<ol>\n<li>\n<p>The reported 46.3% pass@64 is indeed a typo; the correct result is 45.5%. We regret this error in our abstract and introduction claims. However, our model is rapidly improving, and our best version now outperforms the results presented in the current paper. We will provide a final performance report upon the official release of the model and data.</p>\n</li>\n<li>\n<p>We chose MiniF2F-like theorems instead of Mathlib-like theorems because Mathlib is a large-scale, complex scientific project. Generating identically distributed data requires careful consideration of dependencies, definitions, and lemmas needed for theorem declaration and proof. This complexity necessitates advanced generation technology like RAG, which we are currently exploring. We plan to publish a detailed paper and open-source the model and data when ready.</p>\n</li>\n<li>\n<p>I share your concerns about miniF2F and believe that a significant challenge in automatic theorem proving for proof assistants is the lack of comprehensive benchmarks across various fields. Regarding the use of unprovable or unfalsifiable formalized data, we found that they can indeed be used as a benchmark: for any problems our model cannot decide, if other models can prove or falsify them, it indicates their superior theorem-proving capabilities. We will mark these data in the final open-source dataset and hope this benchmark will help measure model performance.</p>\n</li>\n<li>\n<p>Comparing our results with existing methods is nuanced, as most use tree search rather than direct generation, and model reasoning costs vary by parameter count. The purpose of providing pass@k results from small to large k is to offer multiple options for performance comparison:<br>\n   a. Directly comparing different definitions of pass@k, though this may be unfair for whole-proof generation methods that only interact with the verifier k times.<br>\n   b. Comparing performance after a fixed number of model generations (e.g., HTPS performing 32k generations) may also be unfair to tree search methods, which require multiple steps to synthesize complete proofs.<br>\n   c. Comparing cumulative results as an approximation of pass@infinity. This is why we provide the cumulative result for miniF2F-test, although we did not perform expert iteration on these problems. However, this requires excessive computing costs and imposes too much burden on researchers.<br>\nWe apologize for not explaining \"cumulative\" clearly in the paper. It refers to your third guess: merging all attempts of any DeepSeek-Prover version (Tables 1, 4, 5, etc.). If it is argued that merging all pass@k runs in Table 1 is more reasonable, we will clarify both performance reports in the revised paper.</p>\n</li>\n<li>\n<p>We only performed expert iterations on miniF2F-valid, resulting in much higher cumulative results than miniF2F-test. Therefore, we did not publish corresponding pass@k results, as they are nearly identical to the cumulative results and offer little comparative value.</p>\n</li>\n</ol>\n<p>Finally, thank you again for your attention and detailed analysis. Community feedback is crucial to us. Our goal is to advance the entire field, which is also DeepSeek's mission for all fields of artificial intelligence.</p>",
        "id": 441603744,
        "sender_full_name": "Huajian Xin",
        "timestamp": 1717124815
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/DeepSeek-Prover/near/441025986\">said</a>:</p>\n<blockquote>\n<p>I misremembered. But I’m actually referring to the <strong>75%</strong> number in that paper which is also the number on <a href=\"https://github.com/ai4reason/ATP_Proofs\">this website</a>.</p>\n</blockquote>\n<p>Note that this number is obtained by using human-supplied premises. As such, these proofs are not found fully autonomously. A bit further down on the website, it reports 58% proof rate while using trained premise selectors.</p>",
        "id": 441738576,
        "sender_full_name": "Lasse Blaauwbroek",
        "timestamp": 1717170052
    },
    {
        "content": "<p>One more comment that I want to make about this work.  It should be made clear that the techniques employed are not at all specific to using LLMs as all-in-one-go theorem provers.  Indeed, the same approach (figure 1) would work with the DS-Prover being replaced by any machine-learned theorem prover (LLM-based or tree-search-based or other).  After the authors release their new dataset of generated formal theorems and proofs, fine-tuning on that dataset should be enough to boost any existing ML theorem prover by a decent margin on MiniF2F (maybe even surpassing the DS-Prover score <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>).  This of course comes with the caveat that using a pretrained LLM was crucial to the autoformalization step, and there might be some synergy if the same LLM is used for both autoformalization and proving.  (I'm not sure if this was the case.)</p>",
        "id": 441811907,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717191655
    },
    {
        "content": "<p>Also, I hope the authors release not only the positive data (successful proofs), but also the negative data (failed proof attempts).  This negative data is a big value-add that can only come from experience-based methods like reinforcement learning, expert iteration, etc.  For tree-search-based methods, one can use negative information to construct an alpha-go-style value function.  For whole-proof LLM-based methods, one can use it for RLHF (but replace human feedback with Lean feedback).  It also can be used for proof repair techniques (like in <a href=\"https://arxiv.org/abs/2303.04910\">Baldur</a>).  <span class=\"user-mention\" data-user-id=\"481527\">@Huajian Xin</span> Did you use any negative information when fine-tuning either the prover or the auto-formalizer?  (Also, did you fine-tune the auto-formalizer at all?)</p>",
        "id": 441811919,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717191660
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481527\">Huajian Xin</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/DeepSeek-Prover/near/441603744\">said</a>:</p>\n<blockquote>\n<p>c. Comparing cumulative results as an approximation of pass@infinity.</p>\n</blockquote>\n<p>I'm not sure what you mean by \"pass@infinity\".   Shouldn't the pass rate in the limit be close to 100%?  You are just flipping a (biased) coin until it succeeds.  The only way a theorem would never pass is if it has a probability exactly equal to zero by your model (e.g. the shortest proof is beyond the context length or every proof has a token with a floating point log probability of <code>-infty</code>).  But this seems unlikely.</p>",
        "id": 441820573,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717195473
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481527\">Huajian Xin</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/DeepSeek-Prover/near/441603744\">said</a>:</p>\n<blockquote>\n<p>We apologize for not explaining \"cumulative\" clearly in the paper. It refers to your third guess: merging all attempts of any DeepSeek-Prover version (Tables 1, 4, 5, etc.). If it is argued that merging all pass@k runs in Table 1 is more reasonable, we will clarify both performance reports in the revised paper.</p>\n</blockquote>\n<p>To the extent that you are claiming victory with your score of 52.0, this vast amount of computing does seem a bit excessive.  This \"arms race\" of getting a SoTA score on MiniF2F could devolve into just throwing excess computing at the problem.  (By your report above of 5 seconds per 32 iterations, we are talking something like 3 hours per theorem for your 65536-generation score.  That seems quite large to me.)</p>\n<p>Nonetheless, it is reasonable to expect that diversity will help.  I would expect that if you just take all 15 models in tables 2,3,4,5 and union their 128 generation runs, that union would do better than your 8192 generation run (and certainly better than a 2048 generation run).  I wouldn't necessarily consider this cheating.  (The HTPS paper also uses a lot of hyper-parameter diversity between successive proof attempts to improve their score.)</p>",
        "id": 441820827,
        "sender_full_name": "Jason Rute",
        "timestamp": 1717195562
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span>, would there be scope in the field for incremental crowdsourcing of datasets useful for learning?</p>\n<p>I'm thinking something like Amazon Mechanical Turk, but more citizen-science oriented and of course targeted at people with knowledge of Lean. I think pyBOSSA is an open source package that has been widely used for these kind of projects (although, of course, support for running Lean in the browser window with the task would have to be added):</p>\n<p><a href=\"https://github.com/Scifabric/pybossa\">https://github.com/Scifabric/pybossa</a></p>\n<p><a href=\"https://blog.okfn.org/2012/06/08/introducing-pybossa-the-open-source-micro-tasking-platform/\">https://blog.okfn.org/2012/06/08/introducing-pybossa-the-open-source-micro-tasking-platform/</a></p>\n<p>I think the ideal workflow would be something like this:</p>\n<p>an AI method (like DeepSeek Prover) could be used to generate most-valuable data for training (e.g. theorems that are just outside of its proving capability, and cannot be proven by the AI prover at the moment), and add the statements of those theorems into a job queue.</p>\n<p>Humans (likely undergraduate mathematicians) pick up the theorems and prove them in the pyBOSSA citizen-science environment. This actually could be a useful way for mathematicians to learn lean.</p>\n<p>The AI method gets re-trained, improves, and proposes better training data.</p>\n<p>This could be useful until we hit that runaway loop you've mentioned in your earlier posts.</p>",
        "id": 442769078,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1717589412
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481527\">Huajian Xin</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/DeepSeek-Prover/near/440448637\">said</a>:</p>\n<blockquote>\n<p>In fact, many benchmarks currently widely used in the field of AI have errors. For example, we found that a theorem of miniF2F also has errors: the premise of <a href=\"https://github.com/facebookresearch/miniF2F/blob/main/lean/src/test.lean#L946\">https://github.com/facebookresearch/miniF2F/blob/main/lean/src/test.lean#L946</a> should be <code>(3 * n) % 11 = 2</code>.</p>\n</blockquote>\n<p>please PR :)</p>",
        "id": 443752496,
        "sender_full_name": "Fabian Glöckle",
        "timestamp": 1718020266
    },
    {
        "content": "<p>A message was moved from this topic to <a class=\"stream-topic\" data-stream-id=\"219941\" href=\"/#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Aristotle\">#Machine Learning for Theorem Proving &gt; Aristotle</a> by <span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span>.</p>",
        "id": 443984175,
        "sender_full_name": "Notification Bot",
        "timestamp": 1718107476
    }
]