[
    {
        "content": "<p>For V4, click <a href=\"#narrow/stream/423402-PrimeNumberTheorem.2B/topic/Outstanding.20Tasks.2C.20V4/near/423533587\">here</a>.</p>\n<p>I've refactored the Second Approach (see the new file <code>ZetaBounds</code>), outlining a method that avoids any more complex analytic developments than those we already have (in particular, no Hadamard, not even Jensen). Just using very classical techniques (partial summation), this gives the error term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mi>exp</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mo>−</mo><mi>c</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>x</mi><msup><mo stretchy=\"false\">)</mo><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><mn>10</mn></mrow></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(x \\exp(-c (\\log x)^{1/10})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.138em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\">exp</span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1/10</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> (whereas <code>StrongPNT</code> was meant to replace the exponent <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><mn>10</mn></mrow><annotation encoding=\"application/x-tex\">1/10</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/10</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">1/2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/2</span></span></span></span>). I'm thus renaming <code>WeakPNT2</code> to <code>MediumPNT</code>. This error is basically good enough for just about any application, as it gets a rate that's better than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mi mathvariant=\"normal\">/</mi><msup><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>C</mi></msup><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(x/\\log^C x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1757em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">/</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\"><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9257em;\"><span style=\"top:-3.1473em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>, for any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">C&gt;0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>. As far as I'm aware (please correct me?), this will be the first time that an error of this quality is formalized. (We'll see if we even want to continue pushing for <code>StrongPNT</code>; we might want to move right on to Dirichlet/Chebotarev... I've temporarily (?) taken the <code>StrongPNT</code> section out of the blueprint, so we can see the dependency graph a bit clearer.) This also means we will no longer need any Selberg upper bound sieving (sorry <span class=\"user-mention\" data-user-id=\"585783\">@Arend Mellendijk</span>!).</p>\n<p>With those caveats, here's the next round of targets (I tried to break them into really rather small pieces, so there are a few more than usual):</p>\n<ol>\n<li><a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0003.html#sum_eq_int_deriv\">sum_eq_int_deriv</a> This is partial summation. I've already almost (modulo some annoying stuff mixing up <code>uIoo</code> and <code>uIcc</code> in <code>sum_eq_int_deriv_aux2</code>) got it proved on intervals of length at most one (<code>sum_eq_int_deriv_aux</code>), so now it's just a matter of stringing those together. <strong> Done by me</strong></li>\n<li><a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0003.html#ZetaSum_aux1\">ZetaSum_aux1</a> is just an application of partial summation to the power function. Should not be too hard. <strong> Done by me </strong></li>\n<li><a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0003.html#ZetaSum_aux1a\">ZetaSum_aux1a</a> is an auxiliary function, amounts to applying the triangle inequality inside an integral. Shouldn't be hard. <strong>Done by <span class=\"user-mention\" data-user-id=\"571592\">@Paul Nelson</span> </strong></li>\n<li><a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0003.html#ZetaSum_aux2\">ZetaSum_aux2</a> is taking <code>ZetaSum_aux1</code> and sending <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi><mo>→</mo><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">b\\to\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord\">∞</span></span></span></span>. <strong> Done by <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>, <span class=\"user-mention\" data-user-id=\"613795\">@Vláďa Sedláček</span>  and me </strong></li>\n<li><a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0003.html#ZetaBnd_aux1\">ZetaBnd_aux1</a> is a combination of 3. and 4., namely applying the triangle inequality inside an integral and sending <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi><mo>→</mo><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">b\\to\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord\">∞</span></span></span></span>. <strong> Done by <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>, <span class=\"user-mention\" data-user-id=\"613795\">@Vláďa Sedláček</span>  and me </strong></li>\n<li><a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0003.html#Zeta0EqZeta\">Zeta0EqZeta</a> is that the two zeta functions now defined agree on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">ℜ</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\Re(s)&gt;0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">ℜ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> (but not necessarily at <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">s=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>, since we don't know/care what the junk value of either is!!). <strong> Claimed by me </strong></li>\n<li><a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0003.html#ZetaBnd_aux2\">ZetaBnd_aux2</a> begins the analysis inside the critical strip; just bounds an individual term in the Dirichlet series. (Should be very straightforward.) <strong> Done by <span class=\"user-mention\" data-user-id=\"571592\">@Paul Nelson</span> </strong></li>\n<li><a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0003.html#ZetaUpperBnd\">ZetaUpperBnd</a> uses the formula in 6. and bound in 7. to give an upper bound for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ζ</mi><mo stretchy=\"false\">(</mo><mi>σ</mi><mo>+</mo><mi>i</mi><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\zeta(\\sigma+it)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07378em;\">ζ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span> for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>−</mo><mi>A</mi><mi mathvariant=\"normal\">/</mi><mi>log</mi><mo>⁡</mo><mi>t</mi><mo>≤</mo><mi>σ</mi></mrow><annotation encoding=\"application/x-tex\">1-A/\\log t \\le \\sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord\">/</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span></span></span></span>. <strong> Done by <span class=\"user-mention\" data-user-id=\"613795\">@Vláďa Sedláček</span> </strong></li>\n<li><a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0003.html#ZetaDerivUpperBnd\">ZetaDerivUpperBnd</a> Differentiating 8. term by term gives a bound for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>ζ</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\zeta&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9463em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07378em;\">ζ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span>. <strong> Claimed by me and <span class=\"user-mention\" data-user-id=\"613795\">@Vláďa Sedláček</span> </strong></li>\n</ol>\n<p>[Breaking here because of zulip length issues]</p>",
        "id": 426130159,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1710251662
    },
    {
        "content": "<p>[Breaking here because of zulip length issues]</p>\n<ol start=\"10\">\n<li><a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0003.html#ZetaNear1Bnd\">ZetaNear1Bnd</a> is an upper bound for the blowup of zeta near 1 (like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">1/(s-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>) for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">ℜ</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\Re(s)&gt;1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">ℜ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>. (Just adapt <code>riemannZeta_isBigO_near_one_horizontal</code> in <span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span>'s <code>EulerProducts.PNT</code> file) <strong> Done by <span class=\"user-mention\" data-user-id=\"613795\">@Vláďa Sedláček</span> </strong></li>\n<li><a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0003.html#ZetaInvBound1\">ZetaInvBound1</a> is a first upper bound for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>ζ</mi></mrow><annotation encoding=\"application/x-tex\">1/\\zeta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07378em;\">ζ</span></span></span></span> for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">ℜ</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\Re(s)&gt;1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">ℜ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>, just using the \"Hadamard-de la Vallee Poussin\" inequality. (Adapt <code>norm_zeta_product_ge_one</code> in <span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span>'s <code>EulerProducts.PNT</code> file) <strong> Done by <span class=\"user-mention\" data-user-id=\"613795\">@Vláďa Sedláček</span> </strong></li>\n<li><a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0003.html#ZetaInvBound2\">ZetaInvBound2</a> combines 11., 10., and 8. (should be very easy) <strong> Done by <span class=\"user-mention\" data-user-id=\"613795\">@Vláďa Sedláček</span> </strong></li>\n<li><a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0003.html#Zeta_eq_int_derivZeta\">Zeta_eq_int_derivZeta</a> is the fundamental theorem of calculus applied to this setting (also very easy).  <strong> Done by <span class=\"user-mention\" data-user-id=\"613795\">@Vláďa Sedláček</span> </strong></li>\n<li><a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0003.html#Zeta_diff_Bnd\">Zeta_diff_Bnd</a> combines 13. with 9.; trivially estimating an integral by the max of the integrand times the length.  <strong> Done by <span class=\"user-mention\" data-user-id=\"613795\">@Vláďa Sedláček</span> </strong></li>\n<li><a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0003.html#ZetaInvBnd\">ZetaInvBnd</a> This is the first main goal of this section, proving the upper bound <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi mathvariant=\"normal\">∣</mi><mi>ζ</mi><mo stretchy=\"false\">(</mo><mi>σ</mi><mo>+</mo><mi>i</mi><mi>t</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∣</mi><mo>≪</mo><msup><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>7</mn></msup><mi mathvariant=\"normal\">∣</mi><mi>t</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">1/|\\zeta(\\sigma+it)| \\ll \\log^7|t|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.07378em;\">ζ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≪</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1484em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8984em;\"><span style=\"top:-3.1473em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">7</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\">t</span><span class=\"mord\">∣</span></span></span></span> for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>−</mo><mi>A</mi><mi mathvariant=\"normal\">/</mi><msup><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>9</mn></msup><mi mathvariant=\"normal\">∣</mi><mi>t</mi><mi mathvariant=\"normal\">∣</mi><mo>&lt;</mo><mi>σ</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1-A/\\log^9|t| &lt; \\sigma &lt;1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1484em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord\">/</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\"><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8984em;\"><span style=\"top:-3.1473em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\">t</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>. <strong> Claimed by me and <span class=\"user-mention\" data-user-id=\"613795\">@Vláďa Sedláček</span> </strong></li>\n<li><a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0003.html#LogDerivZetaBnd\">LogDerivZetaBnd</a> And this is the main corollary of 15, used together with 9. <strong> Done by <span class=\"user-mention\" data-user-id=\"613795\">@Vláďa Sedláček</span> </strong></li>\n</ol>\n<p>With <code>LogDerivZetaBnd</code> in place, we're really very very close to a strong (well, \"medium\") PNT. I'll be writing up these last steps over the next few days. </p>\n<p>On the Fourier/Tauberian side, here are the next goals from Terry:<br>\n17. <a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0002.html#schwarz-id\">Fourier identity in the Schwartz class</a> This is the first somewhat tricky step in the Fourier argument to formalize: one wants to extend the identity in the <a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0002.html#limiting-cor\">previous corollary</a> from C^2_c functions to Schwartz functions by applying smooth cutoffs (using the smooth Urysohn lemma) and take limits. There will be a moderate amount of estimation of error terms that needs to be done. <strong> Done by <span class=\"user-mention\" data-user-id=\"242586\">@Vincent Beffara</span>  </strong><br>\n18. <a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0002.html#bij\">Bijectivity of the Fourier transform</a>  Now that the <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Analysis/Fourier/Inversion.html\">Fourier inversion formula is Mathlib</a>, this is just a matter of showing that the Fourier transform (and its inverse) preserve the Schwartz class.   Possibly some of the tools used to establish <a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0002.html#decay\">Decay bounds</a> could be relevant here.<br>\n19. <a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0002.html#WienerIkeharaSmooth\">Smoothed Wiener-Ikehara</a> The first major milestone towards the Wiener-Ikehara lemma!  It should follow readily from <a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0002.html#schwarz-id\">Fourier identity in the Schwartz class</a> and  <a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0002.html#bij\">Bijectivity of the Fourier transform</a> and some basic algebraic manipulation. <strong> Done by <span class=\"user-mention\" data-user-id=\"242586\">@Vincent Beffara</span>  </strong><br>\n20. <a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0002.html#limiting-cor\">Limiting corollary</a> Immediate from <a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/web/sect0002.html#limiting\">Limiting Fourier Identity</a>  and the <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Analysis/Fourier/RiemannLebesgueLemma.html#Real.zero_at_infty_fourierIntegral\">Riemann-Lebesgue lemma</a> <strong> Done by <span class=\"user-mention\" data-user-id=\"242586\">@Vincent Beffara</span> </strong></p>",
        "id": 426130214,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1710251680
    },
    {
        "content": "<ol start=\"10\">\n<li>is basically the first <code>have</code> in <code>riemannZeta_isBigO_near_one_horizontal</code> in <a href=\"https://github.com/MichaelStollBayreuth/EulerProducts/blob/main/EulerProducts/PNT.lean\">EulerProducts.PNT</a> .</li>\n</ol>",
        "id": 426132377,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1710252304
    },
    {
        "content": "<p>Great thanks! (Yes, they're meant to be \"easy\", from what is already done...)</p>",
        "id": 426132855,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1710252423
    },
    {
        "content": "<p>I see you want it along the real axis and coming from the right. This is <code>riemannZeta_isBigO_near_one_horizontal</code> on the nose, except for a shift <code>σ = 1 + x</code>.</p>",
        "id": 426133382,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1710252563
    },
    {
        "content": "<p>Note that <code>isBigO_mul_iff_isBigO_div</code> and <code>isBigO_comp_ofReal_nhds_ne</code> are defined locally (the first one in <a href=\"https://github.com/MichaelStollBayreuth/EulerProducts/blob/main/EulerProducts/Auxiliary.lean\">EulerProducts.Auxiliary</a>).</p>",
        "id": 426133938,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1710252711
    },
    {
        "content": "<p>...and 11 is <code>norm_zeta_product_ge_one</code> in my <code>PNT</code> file (modulo moving terms around). (This is actually mentioned in the blueprint.)</p>",
        "id": 426157806,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1710258638
    },
    {
        "content": "<p>Theorem 10 is <code>LSeries_vonMangoldt_eq</code>.</p>",
        "id": 426158590,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1710258875
    },
    {
        "content": "<p>Yes, many of these are just assembling in one place the various identities needed...</p>",
        "id": 426163834,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1710260247
    },
    {
        "content": "<p>Are you working on (1) already?</p>",
        "id": 426234348,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710289082
    },
    {
        "content": "<p>Regarding partial summation, wouldn't it be better to express <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∑</mo><mrow><mi>a</mi><mo>&lt;</mo><mi>n</mi><mo>≤</mo><mi>b</mi></mrow></msub><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\sum_{a &lt; n \\le b} f(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1449em;vertical-align:-0.3949em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1864em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">a</span><span class=\"mrel mtight\">&lt;</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mrel mtight\">≤</span><span class=\"mord mathnormal mtight\">b</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3949em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> as <code>∑ n in Finset.Ioc ⌊a⌋ ⌊b⌋, f n</code> rather than <code>∑ n in Finset.Icc (⌊a⌋ + 1) ⌊b⌋, f n</code>. I think it would make identities like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∑</mo><mrow><mi>a</mi><mo>&lt;</mo><mi>n</mi><mo>≤</mo><mi>b</mi></mrow></msub><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>+</mo><msub><mo>∑</mo><mrow><mi>b</mi><mo>&lt;</mo><mi>n</mi><mo>≤</mo><mi>c</mi></mrow></msub><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>a</mi><mo>&lt;</mo><mi>n</mi><mo>≤</mo><mi>c</mi></mrow></msub><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\sum_{a &lt; n \\le b} f(n) + \\sum_{b &lt; n \\le c} f(n) = \\sum_{a &lt; n \\le c} f(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1449em;vertical-align:-0.3949em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1864em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">a</span><span class=\"mrel mtight\">&lt;</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mrel mtight\">≤</span><span class=\"mord mathnormal mtight\">b</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3949em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1449em;vertical-align:-0.3949em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1864em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">b</span><span class=\"mrel mtight\">&lt;</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mrel mtight\">≤</span><span class=\"mord mathnormal mtight\">c</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3949em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1449em;vertical-align:-0.3949em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1455em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">a</span><span class=\"mrel mtight\">&lt;</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mrel mtight\">≤</span><span class=\"mord mathnormal mtight\">c</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3949em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> easier to prove.</p>",
        "id": 426235114,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1710289573
    },
    {
        "content": "<p>The convention in mathlib is rather to use sums <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∑</mo><mrow><mi>a</mi><mo>≤</mo><mi>n</mi><mo>&lt;</mo><mi>b</mi></mrow></msub><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">\\sum_{a \\le n &lt; b} ...</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1449em;vertical-align:-0.3949em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1864em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">a</span><span class=\"mrel mtight\">≤</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mrel mtight\">&lt;</span><span class=\"mord mathnormal mtight\">b</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3949em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">...</span></span></span></span>, because over the naturals you can express any sum on an interval like that, while sums <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∑</mo><mrow><mi>a</mi><mo>&lt;</mo><mi>n</mi><mo>≤</mo><mi>b</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\sum_{a &lt; n \\le b}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1449em;vertical-align:-0.3949em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1864em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">a</span><span class=\"mrel mtight\">&lt;</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mrel mtight\">≤</span><span class=\"mord mathnormal mtight\">b</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3949em;\"><span></span></span></span></span></span></span></span></span></span> can never contain <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>.</p>",
        "id": 426268648,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1710311862
    },
    {
        "content": "<p>Sébastien, this is more of an historical artefact that will disappear as soon as I have time</p>",
        "id": 426287208,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710320277
    },
    {
        "content": "<p>Historically, there was only <code>Finset.Ico</code>, then at some point 2 years ago I added <code>Icc</code>, <code>Ioc</code>, <code>Ioo</code>, but didn't have the time to appropriately expand the big operators API. But I will do it soon, at the latest this summer</p>",
        "id": 426287521,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710320368
    },
    {
        "content": "<p>It's not a historical artifact, it's mathematically better to do it this way -- I mean, when you want to sum <code>n</code> terms, most of the time the best way to write it is as a sum from <code>0</code> to <code>n-1</code>. So I am strongly in favor that it remains the canonical way to write sums in mathlib, although having more API for the other types of intervals is definitely welcome.</p>",
        "id": 426296800,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1710323526
    },
    {
        "content": "<p>Your consideration only applies to intervals starting at zero. I have many summation proofs that are weird because they have shoehorned into the <code>Ico</code> framework.</p>",
        "id": 426305888,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710326399
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sébastien Gouëzel</span> <a href=\"#narrow/stream/423402-PrimeNumberTheorem.2B/topic/Outstanding.20Tasks.2C.20V5/near/426268648\">said</a>:</p>\n<blockquote>\n<p>The convention in mathlib is rather to use sums $\\sum_{a \\le n &lt; b} ...$, because over the naturals you can express any sum on an interval like that, while sums $\\sum_{a &lt; n \\le b}$ can never contain $0$.</p>\n</blockquote>\n<p>Do note these sums are over <code>Int</code>, so considerations about 0 don't apply directly, though of course the <code>Ico</code> api might be more developed because of it.</p>",
        "id": 426319707,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1710331021
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"579936\">Gareth Ma</span> <a href=\"#narrow/stream/423402-PrimeNumberTheorem.2B/topic/Outstanding.20Tasks.2C.20V5/near/426234348\">said</a>:</p>\n<blockquote>\n<p>Are you working on (1) already?</p>\n</blockquote>\n<p>Kind of, but not directly. I've been thinking about what's really going on here. It's so obvious to humans, that I find it difficult to state formally. You know something is true on all intervals between two consecutive integers, and can easily prove that it's additive on adjacent intervals, and then want to conclude that it's true on any interval. It's some kind of \"induction on intervals\". So I've been thinking a bit about what the right API is so that (1) follows easily from <code>sum_eq_int_deriv_aux2</code> (which itself isn't completely finished either...)</p>",
        "id": 426563232,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1710429007
    },
    {
        "content": "<p>I'll claim (1) for now, to try out <span class=\"user-mention\" data-user-id=\"110050\">@Sébastien Gouëzel</span>'s suggestion to change to <code>Ico</code>. Though as <span class=\"user-mention\" data-user-id=\"585783\">@Arend Mellendijk</span> points out, I'm working here over <code>Int</code>, not <code>Nat</code>, so maybe it's not essential to make the change... (I'd have to slightly change the mathematics to get it to work...)</p>",
        "id": 426564399,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1710429336
    },
    {
        "content": "<p>I think this is the statement I have in mind. Kinda weird... but also cool?...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">intervalInduction</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k_le_a</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a_lt_b</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b_le_k1</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k_le_a</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a_lt_k1</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k1_lt_b</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">b_le_k2</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a_lt_b</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>You induct on the number of integers between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>. I'll try to see if I can prove it myself (no hints please, for now!...)</p>",
        "id": 426567804,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1710430221
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> and I have this induction principle in LeanCamCombi</p>",
        "id": 426572624,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710431542
    },
    {
        "content": "<p><del>This sounds like saying \"if the property holds for every interval containing no integer, and also for each interval containing at least one integer, then it holds for every interval\"</del> Read too fast sorry...</p>",
        "id": 426573269,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1710431731
    },
    {
        "content": "<p>So the induction scheme is this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">intervalInduction</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a_lt_b</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span> <span class=\"bp\">↑</span><span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">Set.Icc</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a_lt_b</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span>\n      <span class=\"bp\">↑</span><span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">Set.Icc</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"bp\">∩</span> <span class=\"n\">Set.Ioo</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a_lt_b</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 426576200,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1710432462
    },
    {
        "content": "<p>IOW, if <code>P a b</code> holds whenever <code>Set.Icc (b - 1) a</code> intersects Z, and whenever <code>Set.Icc (b - 2) a ∩ Set.Ioo (a - 1) (b - 1)</code> intersects Z, then it holds all the time?</p>",
        "id": 426576963,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1710432671
    },
    {
        "content": "<p>I don't think the statement is quite right. Surely there is no way to conclude <code>P 0 10</code> without assuming transitivity of some form? I think we'd want something more like this.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">interval_induction</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">step</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(and I have a proof, but <span class=\"user-mention silent\" data-user-id=\"252920\">Alex Kontorovich</span>  asked for no hints <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> )</p>",
        "id": 426577292,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1710432779
    },
    {
        "content": "<p>That feels weird because if <code>P</code> says \"a is not much smaller than b` then both h1 and h2 are vacuously true</p>",
        "id": 426577386,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1710432804
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/423402-PrimeNumberTheorem.2B/topic/Outstanding.20Tasks.2C.20V5/near/426572624\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> and I have this induction principle in LeanCamCombi</p>\n</blockquote>\n<p>Wild! Can you point me to it please?</p>",
        "id": 426596093,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1710438474
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"585783\">Arend Mellendijk</span> <a href=\"#narrow/stream/423402-PrimeNumberTheorem.2B/topic/Outstanding.20Tasks.2C.20V5/near/426577292\">said</a>:</p>\n<blockquote>\n<p>I don't think the statement is quite right. Surely there is no way to conclude <code>P 0 10</code> without assuming transitivity of some form? I think we'd want something more like this.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">interval_induction</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">step</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(and I have a proof, but <span class=\"user-mention silent\" data-user-id=\"252920\">Alex Kontorovich</span>  asked for no hints <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> )</p>\n</blockquote>\n<p>In my application, I don't think I can verify <code>step</code>; I can only do it if <code>b</code> is an integer. (Yeah, you can send the proof; I've been in meetings since my post ... I was hoping I could ignore the calls and play with the proof, but then unfortunately I actually had to pay attention and participate...)</p>",
        "id": 426596750,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1710438707
    },
    {
        "content": "<p>The inductive step here doesn't quite go through if you change <code>b</code> to be an integer, but it shouldn't be too difficult to adapt the proof.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrderedRing</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FloorRing</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"k\">in</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Int.le_floor_add_one</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"bp\">⌊</span><span class=\"n\">a</span><span class=\"bp\">⌋</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">calc</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"bp\">⌈</span><span class=\"n\">a</span><span class=\"bp\">⌉</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">le_ceil</span> <span class=\"n\">a</span>\n    <span class=\"n\">_</span> <span class=\"bp\">≤</span> <span class=\"bp\">⌊</span><span class=\"n\">a</span><span class=\"bp\">⌋</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_cast</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">ceil_le_floor_add_one</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrderedSemiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FloorSemiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"k\">in</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Nat.le_floor_add_one</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"bp\">⌊</span><span class=\"n\">a</span><span class=\"bp\">⌋₊</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">calc</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"bp\">⌈</span><span class=\"n\">a</span><span class=\"bp\">⌉₊</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">le_ceil</span> <span class=\"n\">a</span>\n    <span class=\"n\">_</span> <span class=\"bp\">≤</span> <span class=\"bp\">⌊</span><span class=\"n\">a</span><span class=\"bp\">⌋₊</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_cast</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">ceil_le_floor_add_one</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">interval_induction_aux</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"bp\">-</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">b</span><span class=\"bp\">-</span><span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">),</span>\n    <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">using</span> <span class=\"n\">Nat.case_strong_induction_on</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">hz</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">intro</span> <span class=\"n\">P</span> <span class=\"n\">base</span> <span class=\"n\">step</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">hab</span> <span class=\"n\">_</span> <span class=\"n\">hn'</span>\n    <span class=\"n\">norm_num</span> <span class=\"n\">at</span> <span class=\"n\">hn'</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Int.floor</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">Int.floor_le</span> <span class=\"n\">b</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">hab'</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">Int.floor</span> <span class=\"n\">b</span>\n    <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">step</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">Int.floor</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"n\">hab'</span> <span class=\"o\">(</span><span class=\"n\">Int.floor_le</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n      <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">base</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Int.floor</span> <span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n        <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Int.cast_sub</span><span class=\"o\">,</span> <span class=\"n\">Int.cast_one</span><span class=\"o\">,</span> <span class=\"n\">tsub_le_iff_right</span><span class=\"o\">]</span>\n          <span class=\"n\">linarith</span>\n        <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">hab'</span>\n        <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n      <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">base</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Int.floor</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">linarith</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">not_le</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hab'</span>\n      <span class=\"n\">apply</span> <span class=\"n\">base</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Int.floor</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">)</span> <span class=\"n\">hab</span> <span class=\"o\">(</span><span class=\"n\">Int.le_floor_add_one</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">hi</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">intro</span> <span class=\"n\">P</span> <span class=\"n\">base</span> <span class=\"n\">step</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">_</span> <span class=\"n\">hn</span> <span class=\"n\">hn'</span>\n    <span class=\"n\">norm_num</span> <span class=\"n\">at</span> <span class=\"n\">hn</span> <span class=\"n\">hn'</span>\n    <span class=\"n\">apply</span> <span class=\"n\">step</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">b</span>\n    <span class=\"bp\">·</span> <span class=\"n\">linarith</span>\n    <span class=\"bp\">·</span> <span class=\"n\">linarith</span>\n    <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">ih</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">Nat.zero_le</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">P</span> <span class=\"n\">base</span> <span class=\"n\">step</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">norm_num</span>\n    <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">ih</span> <span class=\"n\">n</span> <span class=\"n\">le_rfl</span> <span class=\"n\">P</span> <span class=\"n\">base</span> <span class=\"n\">step</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">linarith</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">interval_induction</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">step</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">interval_induction_aux</span> <span class=\"o\">(</span><span class=\"n\">Nat.floor</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">-</span><span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"n\">P</span> <span class=\"n\">base</span> <span class=\"n\">step</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">hab</span> <span class=\"o\">(</span><span class=\"n\">Nat.floor_le</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">Nat.le_floor_add_one</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 426599288,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1710439528
    },
    {
        "content": "<p>Here's the integer version:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"lean4\"><pre><span></span><code>variable {α : Type*} [LinearOrderedRing α] [FloorRing α] in\ntheorem Int.le_floor_add_one (a : α) : a ≤ ⌊a⌋ + 1 := by\n  calc a ≤ ⌈a⌉ := by exact le_ceil a\n    _ ≤ ⌊a⌋ + 1 := by norm_cast; exact ceil_le_floor_add_one a\n\nvariable {α : Type*} [LinearOrderedSemiring α] [FloorSemiring α] in\ntheorem Nat.le_floor_add_one (a : α) : a ≤ ⌊a⌋₊ + 1 := by\n  calc a ≤ ⌈a⌉₊ := by exact le_ceil a\n    _ ≤ ⌊a⌋₊ + 1 := by norm_cast; exact ceil_le_floor_add_one a\n\nlemma interval_induction_aux_int (n : ℕ) :  ∀ (P : ℝ → ℝ → Prop)\n    (_ : ∀ a b : ℝ, ∀ k : ℤ, k ≤ a → a ≤ b → b ≤ k+1 → P a b)\n    (_ : ∀ a : ℝ, ∀ b c : ℤ, a ≤ b → b ≤ c → P a b → P b c → P a c)\n    (a : ℝ) (b : ℤ) (_ : a ≤ b) (_ : n ≤ b-a) (_ : b-a ≤ n+1),\n    P a b := by\n  induction n using Nat.case_strong_induction_on with\n  | hz =&gt;\n    intro P base _ a b hab _ hn'\n    norm_num at hn'\n    apply base a b (b-1) (by push_cast; linarith) hab (by norm_num)\n  | hi n ih =&gt;\n    intro P base step a b _ hn hn'\n    norm_num at hn hn'\n    rw [show (n + 1 + 1 : ℝ) = n + 2 by ring] at hn'\n    apply step a (b-1) b\n    · push_cast; linarith\n    · linarith\n    · apply ih n le_rfl P base step &lt;;&gt; push_cast &lt;;&gt; linarith\n    · apply ih 0 (Nat.zero_le n) P base step &lt;;&gt; norm_num\n\nlemma interval_induction' (P : ℝ → ℝ → Prop)\n    (base : ∀ a b : ℝ, ∀ k : ℤ, k ≤ a → a ≤ b → b ≤ k+1 → P a b)\n    (step : ∀ (a : ℝ) (b c : ℤ), a ≤ b → b ≤ c → P a b → P b c → P a c)\n    (a : ℝ) (b : ℤ) (hab : a ≤ b) : P a b := by\n  apply interval_induction_aux_int (Nat.floor (b-a)) P base step a b hab (Nat.floor_le (by linarith))\n    (Nat.le_floor_add_one _)\n\nlemma interval_induction (P : ℝ → ℝ → Prop)\n    (base : ∀ a b : ℝ, ∀ k : ℤ, k ≤ a → a ≤ b → b ≤ k+1 → P a b)\n    (step : ∀ (a : ℝ) (b : ℤ) (c : ℝ), a ≤ b → b ≤ c → P a b → P b c → P a c)\n    (a b : ℝ) (hab : a ≤ b) : P a b := by\n  by_cases hab' : a ≤ Int.floor b\n  · apply step a (Int.floor b) b hab' (Int.floor_le b)\n    · apply interval_induction' P base (fun a b c ↦ by simpa using step a b c) _ _ hab'\n    · apply base _ _ (Int.floor b) &lt;;&gt; norm_num\n      · exact Int.floor_le b\n      · exact Int.le_floor_add_one b\n  · rw [not_le] at hab'\n    apply base _ _ (Int.floor b) hab'.le hab (Int.le_floor_add_one b)\n</code></pre></div>\n</div></div>",
        "id": 426604151,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1710441118
    },
    {
        "content": "<p>I can try 3. ZetaSum_aux1a</p>",
        "id": 430596044,
        "sender_full_name": "Paul Nelson",
        "timestamp": 1711979617
    },
    {
        "content": "<p>Awesome, thanks! Let me know if you want to do it yourself, or if you want to hop on zoom and keep playing...</p>",
        "id": 430633102,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1711992265
    },
    {
        "content": "<p>tonight I reduced ZetaSum_aux1a to a couple integrability checks: <a href=\"https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/commit/79064cfb0b106fde554b6f28d821eb3fa1f11162\">https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/commit/79064cfb0b106fde554b6f28d821eb3fa1f11162</a></p>",
        "id": 430658845,
        "sender_full_name": "Paul Nelson",
        "timestamp": 1712003395
    },
    {
        "content": "<p>Great! PR what you have, and others can try to help...</p>",
        "id": 430663918,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1712005692
    },
    {
        "content": "<p>did so just now.  reduced it further to a measurability check, see <a href=\"https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/commit/c54dd71ebedad1ede2bcfb36b94295c289ab74dc\">https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/commit/c54dd71ebedad1ede2bcfb36b94295c289ab74dc</a> or below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">ZetaSum_aux1a_aux5c</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">apos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a_lt_b</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">σpos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">s.re</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"k\">let</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">u</span> <span class=\"bp\">↦</span> <span class=\"bp\">|↑⌊</span><span class=\"n\">u</span><span class=\"bp\">⌋</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">u</span><span class=\"bp\">|</span> <span class=\"bp\">/</span> <span class=\"n\">u</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">s.re</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n  <span class=\"n\">MeasureTheory.AEStronglyMeasurable</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">MeasureTheory.Measure.restrict</span> <span class=\"n\">MeasureTheory.volume</span> <span class=\"o\">(</span><span class=\"bp\">Ι</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I didn't spot basic API for working with ratios like this</p>",
        "id": 430714020,
        "sender_full_name": "Paul Nelson",
        "timestamp": 1712035006
    },
    {
        "content": "<p>For measurability things I try to make it work with fun_prop, tracing and apply?ing at points where it gets stuck. The hope is to be able to discover new places where a @[fun_prop] tag could be added upstream</p>\n<p>(Usually get blocked by side conditions though and then I end up spamming apply then cleaning up)</p>",
        "id": 430717301,
        "sender_full_name": "llllvvuu",
        "timestamp": 1712037353
    },
    {
        "content": "<p>Here's a proof (tactics didn't seem to do too well here):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Function.Floor</span>\n\n<span class=\"c1\">-- TODO: why do we need to bump this?</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableDiv₂</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DivInvMonoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableInv</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableMul₂</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">MeasurableDiv₂</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n  <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"n\">ℝ</span>\n\n<span class=\"bp\">...</span>\n\n  <span class=\"n\">apply</span> <span class=\"n\">Measurable.aestronglyMeasurable</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Measurable.div</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">_root_.continuous_abs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">measurable.comp</span>\n    <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">Measurable.sub</span>\n      <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">Measurable.add</span>\n        <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">Measurable.comp</span>\n          <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">trivial</span>\n          <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Int.measurable_floor</span>\n        <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">measurable_const</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">measurable_id</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">measurable_id.pow_const</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 430719591,
        "sender_full_name": "llllvvuu",
        "timestamp": 1712038685
    },
    {
        "content": "<p>OK, thanks!  do you want to append this to the PR, or should I just copy/paste it in?</p>",
        "id": 430754475,
        "sender_full_name": "Paul Nelson",
        "timestamp": 1712052086
    },
    {
        "content": "<p>Feel free to copy paste at your own leisure!</p>",
        "id": 430843479,
        "sender_full_name": "llllvvuu",
        "timestamp": 1712080252
    },
    {
        "content": "<p>thanks.  I did so and tried to PR just now, but the PR attempt failed the following check:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">stdout</span><span class=\"o\">:</span>\n<span class=\"bp\">./././</span><span class=\"n\">PrimeNumberTheoremAnd</span><span class=\"bp\">/</span><span class=\"n\">SecondProofPNT.lean</span><span class=\"o\">:</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"mi\">0</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"kn\">import</span> <span class=\"n\">PrimeNumberTheoremAnd.ZetaBounds</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">environment</span> <span class=\"n\">already</span> <span class=\"n\">contains</span> <span class=\"bp\">'</span><span class=\"n\">instMeasurableDiv₂RealMeasurableSpaceToDivInstLinearOrderedFieldReal'</span> <span class=\"k\">from</span> <span class=\"n\">PrimeNumberTheoremAnd.PerronFormula</span>\n</code></pre></div>\n<p>This is related to the instance from your snippet.</p>",
        "id": 430848318,
        "sender_full_name": "Paul Nelson",
        "timestamp": 1712081963
    },
    {
        "content": "<p>Interesting <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> maybe see if removing that part works?</p>\n<p>Otherwise I'd be happy to update the PR later when I'm back at my computer</p>",
        "id": 430849146,
        "sender_full_name": "llllvvuu",
        "timestamp": 1712082299
    },
    {
        "content": "<p>it doesn't.  for some reason <code>#check (inferInstance : MeasurableDiv₂ ℝ)</code> works in SecondProofPNT.lean, but not in ZetaBounds.lean.  I'll poke around w/ the instances some</p>",
        "id": 430849365,
        "sender_full_name": "Paul Nelson",
        "timestamp": 1712082379
    },
    {
        "content": "<p>ah, I see now.  the point was that the same hack <code>instance : MeasurableDiv₂ ℝ ...</code> had already been used in PerronFormula.lean, and was getting included twice in SecondProofPNT.lean.  so maybe that instance should go in some \"common\" file?  is there a good convention?</p>\n<p>anyway, tried PR'ing again (after replacing that instance w/ an import of PerronFormula) and checks passed, so I guess we can cross off item (3)</p>",
        "id": 430849934,
        "sender_full_name": "Paul Nelson",
        "timestamp": 1712082583
    },
    {
        "content": "<p>I could try 19 next.  seems like one step is to check that (smooth, compact support) implies Schwartz, which I didn't spot anywhere.  I guess it would be formulated something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">schwartz_of_smooth_compact_support</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hsmooth</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"n\">n</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hsupp</span><span class=\"o\">:</span> <span class=\"n\">HasCompactSupport</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n    <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">SchwartzMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℂ</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 430855503,
        "sender_full_name": "Paul Nelson",
        "timestamp": 1712084749
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"571592\">Paul Nelson</span> <a href=\"#narrow/stream/423402-PrimeNumberTheorem.2B/topic/Outstanding.20Tasks.2C.20V5/near/430855503\">said</a>:</p>\n<blockquote>\n<p>I could try 19 next.  seems like one step is to check that (smooth, compact support) implies Schwartz, which I didn't spot anywhere.  I guess it would be formulated something like this?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">schwartz_of_smooth_compact_support</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hsmooth</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"n\">n</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hsupp</span><span class=\"o\">:</span> <span class=\"n\">HasCompactSupport</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n    <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">SchwartzMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℂ</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>19 is yours! I think <code>hsmooth</code> can be spelled: <code>ContDiff ℝ ⊤ f</code>. I indeed didn't see this theorem in the library, so would be great to add it (and shouldn't be too hard...?). Thanks Paul!!</p>",
        "id": 430861871,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1712087344
    },
    {
        "content": "<p>Could also be a <code>def</code> that returns <code>SchwartzMap \\R \\C</code>; I'm not sure what the \"best practice\" is though</p>",
        "id": 430861918,
        "sender_full_name": "llllvvuu",
        "timestamp": 1712087369
    },
    {
        "content": "<p>Good point! Yes, that might be the preferred practice, not to prove the existence, but to exhibit the property...</p>",
        "id": 430862173,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1712087448
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">toSchwartz</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">HasCompactSupport</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">𝓢</span><span class=\"o\">(</span><span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"n\">f</span>\n  <span class=\"n\">smooth'</span> <span class=\"o\">:=</span> <span class=\"n\">h1</span>\n  <span class=\"n\">decay'</span> <span class=\"n\">k</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">have</span> <span class=\"n\">l1</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">‖</span><span class=\"n\">x</span><span class=\"bp\">‖</span> <span class=\"bp\">^</span> <span class=\"n\">k</span> <span class=\"bp\">*</span> <span class=\"bp\">‖</span><span class=\"n\">iteratedFDeriv</span> <span class=\"n\">ℝ</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"bp\">‖</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"o\">(</span><span class=\"n\">iteratedFDeriv</span> <span class=\"n\">ℝ</span> <span class=\"n\">n</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">h1.iteratedFDeriv_right</span> <span class=\"n\">le_top</span>\n      <span class=\"n\">exact</span> <span class=\"n\">Continuous.mul</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">continuity</span><span class=\"o\">)</span> <span class=\"n\">this.continuous.norm</span>\n    <span class=\"k\">have</span> <span class=\"n\">l2</span> <span class=\"o\">:</span> <span class=\"n\">HasCompactSupport</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"bp\">‖</span><span class=\"n\">x</span><span class=\"bp\">‖</span> <span class=\"bp\">^</span> <span class=\"n\">k</span> <span class=\"bp\">*</span> <span class=\"bp\">‖</span><span class=\"n\">iteratedFDeriv</span> <span class=\"n\">ℝ</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"bp\">‖</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">h2.iteratedFDeriv</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">norm.mul_left</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">l1.bounded_above_of_compact_support</span> <span class=\"n\">l2</span>\n</code></pre></div>",
        "id": 430863194,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1712087813
    },
    {
        "content": "<p>In fact I just started as well on <code>wiener_ikehara_smooth</code> which is why I needed this lemma ...</p>",
        "id": 430863586,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1712087958
    },
    {
        "content": "<p>ah cool</p>",
        "id": 430863740,
        "sender_full_name": "Paul Nelson",
        "timestamp": 1712088011
    },
    {
        "content": "<p>you can have it if you'd like, I'll just paste here the small amount I did tonight:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">wiener_ikehara_smooth_aux1</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"n\">n</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">wiener_ikehara_smooth</span> <span class=\"o\">{</span><span class=\"bp\">Ψ</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hsmooth</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"n\">n</span> <span class=\"bp\">Ψ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hsupp</span><span class=\"o\">:</span> <span class=\"n\">HasCompactSupport</span> <span class=\"bp\">Ψ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hplus</span><span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">Function.support</span> <span class=\"bp\">Ψ</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">Set.Ioi</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">Tendsto</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">∑'</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"bp\">Ψ</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">/</span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"bp\">/</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">A</span> <span class=\"bp\">*</span> <span class=\"bp\">∫</span> <span class=\"n\">y</span> <span class=\"k\">in</span> <span class=\"n\">Set.Ioi</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">Ψ</span> <span class=\"n\">y</span> <span class=\"bp\">∂</span> <span class=\"n\">volume</span><span class=\"o\">)</span>\n    <span class=\"n\">atTop</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">set</span> <span class=\"n\">ψ₀</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">cexp</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"bp\">Ψ</span> <span class=\"o\">(</span><span class=\"n\">exp</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"n\">hsmooth₀</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"n\">n</span> <span class=\"n\">ψ₀</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">n</span>\n    <span class=\"n\">apply</span> <span class=\"n\">ContDiff.mul</span>\n    <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">ContDiff.cexp</span>\n      <span class=\"n\">exact</span> <span class=\"n\">wiener_ikehara_smooth_aux1</span> <span class=\"n\">n</span>\n    <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">ContDiff.comp</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">hsmooth</span> <span class=\"n\">n</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Real.contDiff_exp</span>\n  <span class=\"n\">set</span> <span class=\"n\">times_two_pi</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">π</span> <span class=\"bp\">*</span> <span class=\"n\">x</span>\n  <span class=\"n\">set</span> <span class=\"n\">ψ₁</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">ψ₀</span> <span class=\"bp\">∘</span> <span class=\"n\">times_two_pi</span><span class=\"o\">)</span> <span class=\"n\">x</span>\n  <span class=\"k\">have</span> <span class=\"n\">hsmooth₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"n\">n</span> <span class=\"n\">ψ₁</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">n</span>\n    <span class=\"n\">apply</span> <span class=\"n\">ContDiff.comp</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">hsmooth₀</span> <span class=\"n\">n</span>\n    <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">ContDiff.mul</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">contDiff_const</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">contDiff_id</span>\n  <span class=\"k\">have</span> <span class=\"n\">hsupp₁</span> <span class=\"o\">:</span> <span class=\"n\">HasCompactSupport</span> <span class=\"n\">ψ₁</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">ψ₂</span> <span class=\"o\">:</span> <span class=\"n\">SchwartzMap</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℂ</span><span class=\"o\">,</span> <span class=\"n\">ψ₂</span> <span class=\"bp\">=</span> <span class=\"n\">ψ₁</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">exact</span> <span class=\"n\">schwartz_of_smooth_compact_support</span> <span class=\"n\">hsmooth₁</span> <span class=\"n\">hsupp₁</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">ψ₂</span><span class=\"o\">,</span> <span class=\"n\">hψ₂</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">this</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">fourier_surjection_on_schwartz</span> <span class=\"n\">ψ₂</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">ψ</span><span class=\"o\">,</span> <span class=\"n\">hψ</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">this</span>\n  <span class=\"k\">have</span> <span class=\"n\">hRHS</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∫</span> <span class=\"n\">y</span> <span class=\"k\">in</span> <span class=\"n\">Set.Ioi</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">Ψ</span> <span class=\"n\">y</span> <span class=\"bp\">∂</span> <span class=\"n\">volume</span><span class=\"o\">)</span>\n       <span class=\"bp\">=</span> <span class=\"bp\">∫</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"bp\">𝓕</span> <span class=\"n\">ψ</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">π</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- change of variable</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">Ψ</span> <span class=\"bp\">=</span> <span class=\"k\">fun</span> <span class=\"n\">u</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ψ₁</span> <span class=\"o\">(</span><span class=\"n\">Real.log</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ofReal_div</span><span class=\"o\">,</span> <span class=\"n\">ofReal_nat_cast</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hψ₂</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hψ</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"n\">hLHS</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"bp\">∑'</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"bp\">Ψ</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">/</span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"bp\">/</span><span class=\"n\">x</span><span class=\"o\">)</span>\n       <span class=\"bp\">=</span> <span class=\"bp\">∑'</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"bp\">𝓕</span> <span class=\"n\">ψ</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">log</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(not edited or necessarily correct or anything)</p>",
        "id": 430863811,
        "sender_full_name": "Paul Nelson",
        "timestamp": 1712088043
    },
    {
        "content": "<p>Here is where I am:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">lemma</span> <span class=\"n\">toSchwartz_apply</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">SchwartzMap.mk</span> <span class=\"n\">f</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">lemma</span> <span class=\"n\">why</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">π</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">field_simp</span> <span class=\"bp\">;</span> <span class=\"n\">ring</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">wiener_ikehara_smooth</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">σ'</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">σ'</span> <span class=\"bp\">→</span> <span class=\"n\">Summable</span> <span class=\"o\">(</span><span class=\"n\">nterm</span> <span class=\"n\">f</span> <span class=\"n\">σ'</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hcheby</span> <span class=\"o\">:</span> <span class=\"n\">cheby</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hG</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn</span> <span class=\"n\">G</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">s.re</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">hG'</span> <span class=\"o\">:</span> <span class=\"n\">Set.EqOn</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">↦</span> <span class=\"n\">LSeries</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"bp\">-</span> <span class=\"n\">A</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">s.re</span><span class=\"o\">})</span>\n    <span class=\"o\">{</span><span class=\"bp\">Ψ</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hsmooth</span><span class=\"o\">:</span> <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"bp\">Ψ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hsupp</span><span class=\"o\">:</span> <span class=\"n\">HasCompactSupport</span> <span class=\"bp\">Ψ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hplus</span><span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">Function.support</span> <span class=\"bp\">Ψ</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">Set.Ioi</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Tendsto</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">∑'</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"bp\">Ψ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">/</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">A</span> <span class=\"bp\">*</span> <span class=\"bp\">∫</span> <span class=\"n\">y</span> <span class=\"k\">in</span> <span class=\"n\">Set.Ioi</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">Ψ</span> <span class=\"n\">y</span> <span class=\"bp\">∂</span> <span class=\"n\">volume</span><span class=\"o\">)</span> <span class=\"n\">atTop</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"n\">rexp</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">π</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"bp\">Ψ</span> <span class=\"o\">(</span><span class=\"n\">exp</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">π</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">HasCompactSupport</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">fourier_surjection_on_schwartz</span> <span class=\"o\">(</span><span class=\"n\">toSchwartz</span> <span class=\"n\">h</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">)</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">l1</span> <span class=\"o\">{</span><span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"bp\">Ψ</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"bp\">𝓕</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">Real.log</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">field_simp</span> <span class=\"o\">[</span><span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">toSchwartz</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"bp\">;</span> <span class=\"n\">norm_cast</span> <span class=\"bp\">;</span> <span class=\"n\">field_simp</span> <span class=\"bp\">;</span> <span class=\"n\">norm_cast</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Real.exp_log</span> <span class=\"n\">hy</span><span class=\"o\">]</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">key</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">limiting_cor_schwartz</span> <span class=\"n\">f</span> <span class=\"n\">A</span> <span class=\"n\">G</span> <span class=\"n\">g</span> <span class=\"n\">hf</span> <span class=\"n\">hcheby</span> <span class=\"n\">hG</span> <span class=\"n\">hG'</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">l2</span> <span class=\"o\">:</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">atTop</span><span class=\"o\">,</span> <span class=\"bp\">∑'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"bp\">↑</span><span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"bp\">𝓕</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">Real.log</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n      <span class=\"bp\">∑'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"bp\">Ψ</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">filter_upwards</span> <span class=\"o\">[</span><span class=\"n\">eventually_gt_atTop</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n    <span class=\"n\">congr</span> <span class=\"bp\">;</span> <span class=\"n\">ext</span> <span class=\"n\">n</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hn</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">l1</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">positivity</span><span class=\"o\">)]</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">hn</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">hx.ne.symm</span>\n    <span class=\"n\">field_simp</span> <span class=\"bp\">;</span> <span class=\"n\">ring</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">l3</span> <span class=\"o\">:</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">atTop</span><span class=\"o\">,</span> <span class=\"bp\">↑</span><span class=\"n\">A</span> <span class=\"bp\">*</span> <span class=\"bp\">∫</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">Ici</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">Real.log</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"bp\">𝓕</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">π</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n      <span class=\"bp\">↑</span><span class=\"n\">A</span> <span class=\"bp\">*</span> <span class=\"bp\">∫</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">Ioi</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">Ψ</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">filter_upwards</span> <span class=\"o\">[</span><span class=\"n\">eventually_gt_atTop</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n    <span class=\"n\">congr</span> <span class=\"mi\">1</span>\n\n    <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 430864006,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1712088115
    },
    {
        "content": "<p>cool.  so I guess I worked out something like your \"h1\"</p>",
        "id": 430864321,
        "sender_full_name": "Paul Nelson",
        "timestamp": 1712088242
    },
    {
        "content": "<p>Yes exactly, I'm going to steal it :-) The last sorry is (well, should be) a simple change of variable. And <code>h2</code> should not be too hard, but I'm slightly afraid of it...</p>",
        "id": 430864579,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1712088343
    },
    {
        "content": "<p>for h2, I figured one would have to show that a compact subset of the positive reals that did not contain 0 is contained in some interval [a,b] with positive endpoints, and then pull this back via the logarithm.  but I wondered if it might be slightly easier to tweak the formulation to say explicitly \"this function is supported on [a,b] for some 0 &lt; a &lt; b\" rather than to formulate things topologically (assuming that such a tweak would not affect usage elsewhere)</p>",
        "id": 430864831,
        "sender_full_name": "Paul Nelson",
        "timestamp": 1712088441
    },
    {
        "content": "<p>I wanted to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=hasCompactSupport_iff_eventuallyEq#doc\">docs#hasCompactSupport_iff_eventuallyEq</a> and to say that <code>exp x</code> as <code>x</code> goes to eventually exits the support (but this still needs the fact that the support is contained in such an [a, b])</p>",
        "id": 430866007,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1712088952
    },
    {
        "content": "<p>very well.  GL HF.  I'll relinquish 19 and try 7 tomorrow night</p>",
        "id": 430867321,
        "sender_full_name": "Paul Nelson",
        "timestamp": 1712089467
    },
    {
        "content": "<p>In one dimension we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=cocompact_eq_atBot_atTop#doc\">docs#cocompact_eq_atBot_atTop</a> for R and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=cocompact_eq_atTop#doc\">docs#cocompact_eq_atTop</a> for R+</p>\n<p><del>Maybe combined with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.EventuallyEq.comp_tendsto#doc\">docs#Filter.EventuallyEq.comp_tendsto</a> could do the trick</del></p>",
        "id": 430873202,
        "sender_full_name": "llllvvuu",
        "timestamp": 1712091783
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 430878676,
        "sender_full_name": "llllvvuu",
        "timestamp": 1712093983
    },
    {
        "content": "<p>Maybe this is an easier goal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">Filter.EventuallyEq.sup_filter</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">f</span> <span class=\"bp\">=ᶠ</span><span class=\"o\">[</span><span class=\"n\">l</span> <span class=\"bp\">⊔</span> <span class=\"n\">l'</span><span class=\"o\">]</span> <span class=\"n\">g</span> <span class=\"bp\">↔</span> <span class=\"n\">f</span> <span class=\"bp\">=ᶠ</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"n\">g</span> <span class=\"bp\">∧</span> <span class=\"n\">f</span> <span class=\"bp\">=ᶠ</span><span class=\"o\">[</span><span class=\"n\">l'</span><span class=\"o\">]</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">EventuallyEq</span><span class=\"o\">,</span> <span class=\"n\">Filter.eventually_sup</span><span class=\"o\">]</span>\n\n<span class=\"bp\">...</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">HasCompactSupport</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">show</span> <span class=\"n\">HasCompactSupport</span> <span class=\"o\">((</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">((</span><span class=\"n\">rexp</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">π</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"bp\">Ψ</span> <span class=\"o\">(</span><span class=\"n\">rexp</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">π</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">))))</span>\n    <span class=\"n\">apply</span> <span class=\"n\">HasCompactSupport.smul_left</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hasCompactSupport_iff_eventuallyEq</span><span class=\"o\">,</span> <span class=\"n\">Filter.coclosedCompact_eq_cocompact</span><span class=\"o\">,</span>\n      <span class=\"n\">cocompact_eq_atBot_atTop</span><span class=\"o\">,</span> <span class=\"n\">EventuallyEq.sup_filter</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hsupp</span> <span class=\"bp\">⊢</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- ⊢ (fun x ↦ Ψ (rexp (2 * π * x))) =ᶠ[atBot] 0</span>\n    <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"bp\">Ψ</span> <span class=\"bp\">=ᶠ</span><span class=\"o\">[</span><span class=\"n\">atTop</span><span class=\"o\">]</span> <span class=\"mi\">0</span> <span class=\"k\">from</span> <span class=\"n\">hsupp.2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp_tendsto</span>\n      <span class=\"gr\">sorry</span> <span class=\"c1\">-- ⊢ Tendsto (fun x ↦ rexp (2 * π * x)) atTop atTop</span>\n</code></pre></div>",
        "id": 430882644,
        "sender_full_name": "llllvvuu",
        "timestamp": 1712095597
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">comp_exp_support</span> <span class=\"o\">{</span><span class=\"bp\">Ψ</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hsupp</span> <span class=\"o\">:</span> <span class=\"n\">HasCompactSupport</span> <span class=\"bp\">Ψ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hplus</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">Function.support</span> <span class=\"bp\">Ψ</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">Ioi</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">HasCompactSupport</span> <span class=\"o\">(</span><span class=\"bp\">Ψ</span> <span class=\"bp\">∘</span> <span class=\"n\">rexp</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hasCompactSupport_iff_eventuallyEq</span><span class=\"o\">,</span> <span class=\"n\">EventuallyEq</span><span class=\"o\">,</span> <span class=\"n\">coclosedCompact_eq_cocompact</span><span class=\"o\">,</span>\n    <span class=\"n\">cocompact_eq_atBot_atTop</span><span class=\"o\">,</span> <span class=\"n\">eventually_sup</span><span class=\"o\">,</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">zero_apply</span><span class=\"o\">]</span> <span class=\"bp\">;</span> <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">disjoint_compl_right_iff_subset</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hplus</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">δ</span><span class=\"o\">,</span> <span class=\"n\">hδ</span><span class=\"o\">,</span> <span class=\"n\">hdisj</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hplus.exists_thickenings</span> <span class=\"n\">hsupp</span> <span class=\"n\">isClosed_Iic</span>\n    <span class=\"k\">have</span> <span class=\"n\">l1</span> <span class=\"o\">:</span> <span class=\"n\">Metric.thickening</span> <span class=\"n\">δ</span> <span class=\"o\">(</span><span class=\"n\">Iic</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝓝</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">refine</span> <span class=\"n\">mem_of_superset</span> <span class=\"o\">(</span><span class=\"n\">Metric.ball_mem_nhds</span> <span class=\"mi\">0</span> <span class=\"n\">hδ</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n      <span class=\"n\">exact</span> <span class=\"n\">Metric.ball_subset_thickening</span> <span class=\"o\">(</span><span class=\"n\">mem_Iic.mpr</span> <span class=\"n\">le_rfl</span><span class=\"o\">)</span> <span class=\"n\">δ</span>\n    <span class=\"k\">have</span> <span class=\"n\">l2</span> <span class=\"o\">:</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">atBot</span><span class=\"o\">,</span> <span class=\"n\">rexp</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Metric.thickening</span> <span class=\"n\">δ</span> <span class=\"o\">(</span><span class=\"n\">Iic</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Real.tendsto_exp_atBot</span> <span class=\"n\">l1</span>\n    <span class=\"n\">filter_upwards</span> <span class=\"o\">[</span><span class=\"n\">l2</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">hdisj.subset_compl_left</span> <span class=\"n\">hx</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">compl_subset_compl.mpr</span> <span class=\"o\">(</span><span class=\"n\">Metric.self_subset_thickening</span> <span class=\"n\">hδ</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">this</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">compl_subset_compl.mpr</span> <span class=\"n\">subset_closure</span> <span class=\"n\">this</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">this</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hasCompactSupport_iff_eventuallyEq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hsupp</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Real.tendsto_exp_atTop</span> <span class=\"n\">hsupp.2</span>\n</code></pre></div>",
        "id": 430883835,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1712096107
    },
    {
        "content": "<p>I just <a href=\"https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/pull/138\">finished</a> 16. to get a taste of this section and I can do 12.-15. in the near future.</p>",
        "id": 430889531,
        "sender_full_name": "Vláďa Sedláček",
        "timestamp": 1712099112
    },
    {
        "content": "<ol start=\"19\">\n<li>is done, modulo surjectivity of the Fourier transform on the Schwartz class.</li>\n</ol>",
        "id": 430893542,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1712101819
    },
    {
        "content": "<p>I added the surjectivity as an axiom to make sure that there were no other sorries missing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">'</span><span class=\"n\">wiener_ikehara_smooth'</span> <span class=\"n\">depends</span> <span class=\"n\">on</span> <span class=\"kd\">axioms</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">propext</span><span class=\"o\">,</span> <span class=\"n\">Classical.choice</span><span class=\"o\">,</span> <span class=\"n\">Quot.sound</span><span class=\"o\">,</span> <span class=\"n\">fourier_surjection_on_schwartz</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 430893592,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1712101863
    },
    {
        "content": "<p>I also removed the assumption that <code>f 0 = 0</code> from most of <code>Wiener.lean</code> and switched all statements from <code>ArithmeticFunction</code> to <code>N \\to C</code> to make them more flexible.</p>",
        "id": 430986244,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1712145666
    },
    {
        "content": "<p>I am looking at <code>WienerIkeharaInterval</code> and it is going to be a bit annoying, because everything switches to real-valued sequences to use order. But the previous results are for complex-values sequences so it is not easy to use them. I think I am planning to replace everywhere <code>ℂ</code> with <code>{𝕜 : Type*} [IsROrC 𝕜]</code> so that we don't have to prove two versions of each lemma ... except that <code>term</code> wants complex numbers.</p>",
        "id": 431173057,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1712177218
    },
    {
        "content": "<p>Yes, we had a similar problem with MellinTransform, so had to make the <code>[IsROrC]</code> move, so I'm not surprised... Sorry! :(</p>",
        "id": 431174782,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1712177884
    },
    {
        "content": "<p>I cannot touch <code>term</code> which is in Mathlib, so the move to <code>IsROrC</code> is a bit tricky to do :-( I am trying this instead</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>and hoping for the best.</p>",
        "id": 431175670,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1712178190
    },
    {
        "content": "<p>Note that <code>IsRorC</code> is nowadays called <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RCLike#doc\">docs#RCLike</a> .</p>",
        "id": 431177548,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1712178927
    },
    {
        "content": "<p>There might also be the option of using the ordering on the complex numbers (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Complex.partialOrder#doc\">docs#Complex.partialOrder</a>), available via <code>open scoped ComplexOrder</code>. But likely using <code>RCLike</code> is nicer.</p>",
        "id": 431177804,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1712179020
    },
    {
        "content": "<blockquote>\n<p>I cannot touch <code>term</code> which is in Mathlib,</p>\n</blockquote>\n<p>the location might matter less than whether the change makes sense</p>",
        "id": 431177987,
        "sender_full_name": "llllvvuu",
        "timestamp": 1712179081
    },
    {
        "content": "<p>the location means that changing the def involves either forking Mathlib to make the change and base PNT+ on that, or PRing the change and waiting for review and such</p>",
        "id": 431178241,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1712179184
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/423402-PrimeNumberTheorem.2B/topic/Outstanding.20Tasks.2C.20V5/near/431177548\">said</a>:</p>\n<blockquote>\n<p>Note that <code>IsRorC</code> is nowadays called <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RCLike#doc\">docs#RCLike</a> .</p>\n</blockquote>\n<p>I didn't know! When did this occur?</p>",
        "id": 431178356,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1712179222
    },
    {
        "content": "<p>When <a href=\"https://github.com/leanprover-community/mathlib4/pull/10819\">#10819</a> was merged last week.</p>",
        "id": 431179493,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1712179689
    },
    {
        "content": "<p>OK so this is not too bad:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">wiener_ikehara_smooth'</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">σ'</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">σ'</span> <span class=\"bp\">→</span> <span class=\"n\">Summable</span> <span class=\"o\">(</span><span class=\"n\">nterm</span> <span class=\"n\">f</span> <span class=\"n\">σ'</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hcheby</span> <span class=\"o\">:</span> <span class=\"n\">cheby</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hG</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn</span> <span class=\"n\">G</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">s.re</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">hG'</span> <span class=\"o\">:</span> <span class=\"n\">Set.EqOn</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">↦</span> <span class=\"n\">LSeries</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"bp\">-</span> <span class=\"n\">A</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">s.re</span><span class=\"o\">})</span>\n    <span class=\"o\">(</span><span class=\"n\">hsmooth</span><span class=\"o\">:</span> <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"bp\">Ψ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hsupp</span><span class=\"o\">:</span> <span class=\"n\">HasCompactSupport</span> <span class=\"bp\">Ψ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hplus</span><span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">Function.support</span> <span class=\"bp\">Ψ</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">Set.Ioi</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Tendsto</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">∑'</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"bp\">Ψ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">/</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">atTop</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">*</span> <span class=\"bp\">∫</span> <span class=\"n\">y</span> <span class=\"k\">in</span> <span class=\"n\">Set.Ioi</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">Ψ</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"n\">tendsto_sub_nhds_zero_iff.mp</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">wiener_ikehara_smooth</span> <span class=\"n\">hf</span> <span class=\"n\">hcheby</span> <span class=\"n\">hG</span> <span class=\"n\">hG'</span> <span class=\"n\">hsmooth</span> <span class=\"n\">hsupp</span> <span class=\"n\">hplus</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">norm_cast</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">set_integral_ofReal</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∫</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∫</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n  <span class=\"n\">integral_ofReal</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">wiener_ikehara_smooth_real</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"bp\">Ψ</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">σ'</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">σ'</span> <span class=\"bp\">→</span> <span class=\"n\">Summable</span> <span class=\"o\">(</span><span class=\"n\">nterm</span> <span class=\"n\">f</span> <span class=\"n\">σ'</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hcheby</span> <span class=\"o\">:</span> <span class=\"n\">cheby</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hG</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn</span> <span class=\"n\">G</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">s.re</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">hG'</span> <span class=\"o\">:</span> <span class=\"n\">Set.EqOn</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">↦</span> <span class=\"n\">LSeries</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"bp\">-</span> <span class=\"n\">A</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">s.re</span><span class=\"o\">})</span>\n    <span class=\"o\">(</span><span class=\"n\">hsmooth</span><span class=\"o\">:</span> <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"bp\">Ψ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hsupp</span><span class=\"o\">:</span> <span class=\"n\">HasCompactSupport</span> <span class=\"bp\">Ψ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hplus</span><span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">Function.support</span> <span class=\"bp\">Ψ</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">Set.Ioi</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Tendsto</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">∑'</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"bp\">Ψ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">/</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">atTop</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">*</span> <span class=\"bp\">∫</span> <span class=\"n\">y</span> <span class=\"k\">in</span> <span class=\"n\">Set.Ioi</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">Ψ</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n\n  <span class=\"k\">let</span> <span class=\"bp\">Ψ'</span> <span class=\"o\">:=</span> <span class=\"n\">ofReal'</span> <span class=\"bp\">∘</span> <span class=\"bp\">Ψ</span>\n  <span class=\"k\">have</span> <span class=\"n\">l1</span> <span class=\"o\">:</span> <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"bp\">Ψ'</span> <span class=\"o\">:=</span> <span class=\"n\">contDiff_ofReal.comp</span> <span class=\"n\">hsmooth</span>\n  <span class=\"k\">have</span> <span class=\"n\">l2</span> <span class=\"o\">:</span> <span class=\"n\">HasCompactSupport</span> <span class=\"bp\">Ψ'</span> <span class=\"o\">:=</span> <span class=\"n\">hsupp.comp_left</span> <span class=\"n\">rfl</span>\n  <span class=\"k\">have</span> <span class=\"n\">l3</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">Function.support</span> <span class=\"bp\">Ψ'</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">Ioi</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">Function.support_comp_eq</span><span class=\"o\">]</span> <span class=\"bp\">;</span> <span class=\"n\">simp</span>\n  <span class=\"k\">have</span> <span class=\"n\">key</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">continuous_re.tendsto</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">wiener_ikehara_smooth'</span> <span class=\"n\">A</span> <span class=\"bp\">Ψ</span> <span class=\"n\">G</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"n\">hcheby</span> <span class=\"n\">hG</span> <span class=\"n\">hG'</span> <span class=\"n\">l1</span> <span class=\"n\">l2</span> <span class=\"n\">l3</span><span class=\"o\">)</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">key</span> <span class=\"bp\">;</span> <span class=\"n\">norm_cast</span> <span class=\"n\">at</span> <span class=\"n\">key</span>\n</code></pre></div>",
        "id": 431183359,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1712181360
    },
    {
        "content": "<p>I've made good progress on <code>WienerIkeharaInterval</code>, a few sorries left but nothing major I believe, the current code is at <a href=\"https://github.com/vbeffara/PNT/blob/d77dfe42843896bf651bfbfc9c76681ae218d655/PrimeNumberTheoremAnd/Wiener.lean#L1775\">https://github.com/vbeffara/PNT/blob/d77dfe42843896bf651bfbfc9c76681ae218d655/PrimeNumberTheoremAnd/Wiener.lean#L1775</a></p>\n<p>In retrospect it would have been much nicer in some respects to work in ENNReal, a wonderful place where liminf is always below limsup ...</p>",
        "id": 431314946,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1712237675
    },
    {
        "content": "<p>Do you think it's worth a refactor? As we near PNT (in both weak and medium form), I'm starting to think about what it'll take to port this all to mathlib. It'll be a big job!... (Of course we'll need to split into lots of little PRs) Maybe we'll keep up the momentum through Dirichlet, and then pause to port before embarking on Chebotarev, something like that?... TBD...</p>",
        "id": 431321584,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1712239583
    },
    {
        "content": "<p>FYI 2. <code>ZetaSum_aux1</code> is now done, modulo <code>Real.differentiableAt_cpow_const_of_ne</code>. PRing now.</p>",
        "id": 431345816,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1712245919
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"242586\">Vincent Beffara</span> <a href=\"#narrow/stream/423402-PrimeNumberTheorem.2B/topic/Outstanding.20Tasks.2C.20V5/near/431314946\">said</a>:</p>\n<blockquote>\n<p>I've made good progress on <code>WienerIkeharaInterval</code>, a few sorries left but nothing major I believe, the current code is at <a href=\"https://github.com/vbeffara/PNT/blob/d77dfe42843896bf651bfbfc9c76681ae218d655/PrimeNumberTheoremAnd/Wiener.lean#L1775\">https://github.com/vbeffara/PNT/blob/d77dfe42843896bf651bfbfc9c76681ae218d655/PrimeNumberTheoremAnd/Wiener.lean#L1775</a></p>\n<p>In retrospect it would have been much nicer in some respects to work in ENNReal, a wonderful place where liminf is always below limsup ...</p>\n</blockquote>\n<p>In the event that we choose this route, I extended the blueprint at <a href=\"https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/pull/147\">https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/pull/147</a> to show how to remove the Chebyshev hypothesis from the Wiener-Ikehara theorem.</p>",
        "id": 431386078,
        "sender_full_name": "Terence Tao",
        "timestamp": 1712258308
    },
    {
        "content": "<p>Great thanks!</p>",
        "id": 431400342,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1712264037
    },
    {
        "content": "<p><code>WienerIkeharaInterval</code> is done at <a href=\"https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/pull/148\">https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/pull/148</a></p>",
        "id": 431402733,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1712264990
    },
    {
        "content": "<p>(But I did changes that break <code>MellinCalculus.lean</code>, let me fix them real quick.)</p>",
        "id": 431403669,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1712265376
    },
    {
        "content": "<p>Done!</p>",
        "id": 431405853,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1712266353
    },
    {
        "content": "<p>Followint the whole <code>Icc</code> vs <code>Ico</code> discussion I rewrote the interval version of Wiener-Ikehara using <code>Ico</code> everywhere, and then wrote a <code>Finset</code> version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">WienerIkeharaInterval_discrete'</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hpos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">σ'</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">σ'</span> <span class=\"bp\">→</span> <span class=\"n\">Summable</span> <span class=\"o\">(</span><span class=\"n\">nterm</span> <span class=\"n\">f</span> <span class=\"n\">σ'</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">hcheby</span> <span class=\"o\">:</span> <span class=\"n\">cheby</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hG</span><span class=\"o\">:</span> <span class=\"n\">ContinuousOn</span> <span class=\"n\">G</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">s.re</span><span class=\"o\">})</span>\n    <span class=\"o\">(</span><span class=\"n\">hG'</span> <span class=\"o\">:</span> <span class=\"n\">Set.EqOn</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">↦</span> <span class=\"n\">LSeries</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"bp\">-</span> <span class=\"n\">A</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">s.re</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Tendsto</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">n</span> <span class=\"k\">in</span> <span class=\"n\">Finset.Ico</span> <span class=\"bp\">⌈</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">N</span><span class=\"bp\">⌉₊</span> <span class=\"bp\">⌈</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">N</span><span class=\"bp\">⌉₊</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"n\">atTop</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"n\">a</span><span class=\"o\">)))</span>\n</code></pre></div>\n<p>from which <code>WienerIkeharaTheorem'</code> should readily follow. And indeed the API around <code>Ico</code> is much nicer to use, no need to juggle with floor and ceil and so on.</p>",
        "id": 431542356,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1712328332
    },
    {
        "content": "<p><code>ZetaBnd_aux2</code> (item 7): <a href=\"https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/pull/152\">https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/pull/152</a></p>",
        "id": 432059307,
        "sender_full_name": "Paul Nelson",
        "timestamp": 1712607146
    }
]