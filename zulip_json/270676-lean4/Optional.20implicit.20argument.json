[
    {
        "content": "<p>I would like to have optional implicit argument i.e. define function like <code>def foo {n := 1} := n</code>. The only way to specify the argument would be with named argument assignment <code>foo (n:=5)</code>.</p>\n<p>For example I want to write funciton<code>boundingSphere</code> which returns the smallest sphere(center and radius) bounding a set <code>s</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">boundingSphere</span> <span class=\"o\">(</span><span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NormedField</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">K</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"bp\">×</span><span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>you can see that <code>K</code> has to be set as explicit argument here as it can't be inferred from other arguments.</p>\n<p>I would really like to write <code>boundingSphere s</code> but right now I have to write <code>boundingSphere K s</code>.</p>\n<p>My idea is to use the trick described in the <a href=\"#narrow/stream/270676-lean4/topic/notation.20over.20field\">notation over field</a> thread. With that I would define the function as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">boundingSphere</span> <span class=\"o\">{</span><span class=\"n\">K</span><span class=\"o\">:=</span><span class=\"n\">currentBaseRing</span><span class=\"bp\">%</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedField</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">K</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"bp\">×</span><span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>where  <code>currentBaseRing%</code> is a macro that identifies the current field/ring we are working with. This is very common scenario that I have one filed/ring parameter through out the whole file and it a chore to mention it all the time.</p>\n<p>I guess this is feature request for Lean core, I would like opinion of others if this is a good idea or not.</p>",
        "id": 434366948,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1713534544
    },
    {
        "content": "<blockquote>\n<p>Why do I want that? I write lots of code polymorphics in the base field</p>\n</blockquote>\n<p><del>I'm sure I'm just being dim, but what's the connection, explicitly? Can you spell it out?</del></p>",
        "id": 434368215,
        "sender_full_name": "Richard Copley",
        "timestamp": 1713534951
    },
    {
        "content": "<p>Ahh sorry, Zulip failed me and the post disappeared while I was writing it. At first it looked like it didn't get posted but it did ... I need to finish the question <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span></p>",
        "id": 434368519,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1713535037
    },
    {
        "content": "<p>It seems like you might have forgotten to ask a question. Or is this a feature request?</p>",
        "id": 434369931,
        "sender_full_name": "Richard Copley",
        "timestamp": 1713535489
    },
    {
        "content": "<p>Ok I fixed the question now, and yes it is more of a RFC then a question</p>",
        "id": 434438140,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1713561958
    },
    {
        "content": "<p>I've thought this would be a neat feature to have. I'd like it to support auto-params too (i.e., <code>{K := by tactics...}</code>).</p>",
        "id": 434439714,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713562754
    },
    {
        "content": "<p>Question about this RFC: when would the default values be inserted? Would it try to use unification first and only insert a default value later? Or would it <em>not</em> use unification and insert the default value immediately?</p>",
        "id": 434439993,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713562913
    },
    {
        "content": "<p>Would it be better to modify <code>optParam</code> and <code>autoParam</code> to have a Bool flag that indicates whether the explicit argument can be provided positionally? And to come up with a syntax using <code>( ... )</code> for this concept?</p>",
        "id": 434440123,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713562972
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Optional.20implicit.20argument/near/434439993\">said</a>:</p>\n<blockquote>\n<p>Question about this RFC: when would the default values be inserted? Would it try to use unification first and only insert a default value later? Or would it <em>not</em> use unification and insert the default value immediately?</p>\n</blockquote>\n<p>Good question but I'm afraid that is above my pay grade <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span>  I was thinking about it only in the context specifying the base field/ring. In that case I would insert the default value immediately.</p>",
        "id": 434440407,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1713563140
    },
    {
        "content": "<p>Here's a partially formed competing idea:</p>\n<p>The <code>named%</code> term would tag a type with metadata to let the app elaborator know that this parameter <em>must</em> be passed using named arguments. You could write for example <code>(x : named% _)</code> or <code>(x : named% Nat)</code> or <code>(x : named% _ := defVal)</code>, and these parameters will not be given any of the positional arguments. If the argument is not supplied and it has no default value, the elaborator raises an error that the argument is missing.</p>",
        "id": 434440586,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713563236
    },
    {
        "content": "<p><code>named%</code> here is just a barely acceptable placeholder. Using explicit parameters means we can avoid questions about whether these are implicit arguments.</p>",
        "id": 434440789,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713563361
    },
    {
        "content": "<p>If you keep such argument implicit <code>{x : _}</code> and assuming such argument can't be inferred from other arguments or return type then calling such function will be only valid if you specify <code>x</code> with a named argument. I'm not completely convinced for the need of <code>named%</code> macro</p>",
        "id": 434440813,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1713563376
    },
    {
        "content": "<p>The point is to be clear that it's not interacting with the metavariable-insertion feature of implicit arguments in any way. It's weird to say \"this implicit argument must be passed explicitly\" -- that means it's explicit, right?</p>",
        "id": 434440986,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713563455
    },
    {
        "content": "<p>Yes I agree that treating implicit arguments this way breaks the normal meaning of implicit arguments and relying on doc string explaining that is probably suboptimal.</p>",
        "id": 434441173,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1713563538
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Optional.20implicit.20argument/near/434440986\">said</a>:</p>\n<blockquote>\n<p>The point is to be clear that it's not interacting with the metavariable-insertion feature of implicit arguments in any way. </p>\n</blockquote>\n<p>I'm afraid I do not understand this part of Lean so I don't see the potential consequences.</p>",
        "id": 434441294,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1713563625
    },
    {
        "content": "<p>I'm not sure there's anything particularly weird, other than some confusion (for the user) about whether the default arguments are applied now or later, and to what extent it's by unification or assignment.</p>\n<p>Using <code>{...}</code> instead of <code>(...)</code> also means there's not a possibility for letting the user know that a particular argument is <em>supposed</em> to be supplied by name. I'm not sure there are many uses for required-named arguments that don't have default values however, though what does come to mind is an API that requires Bool flags to be passed by named argument, so that the API is free to reorder them as it wishes without breaking downstream code.</p>",
        "id": 434441857,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713563979
    },
    {
        "content": "<p>(There's also a feature that some languages have -- for example Common Lisp and Swift -- which is being able to specify the the external name of a named parameter, letting the internal name used in the function be different. This isn't very related, but maybe it's worth thinking about since it's in the general design space.)</p>",
        "id": 434442420,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713564292
    },
    {
        "content": "<p>Writing <code>{x := ...}</code> would mean that you should not provide the argument by name, it should be inferred automatically from the default value or maybe by unification in special cases.</p>",
        "id": 434442610,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1713564402
    },
    {
        "content": "<p>Right, but I mean the <code>(x : named% _)</code> feature, with no defaults, which can't really be represented using <code>{...}</code> (in the sense that <code>{...}</code> gives a bad error message, \"cannot synthesize placeholders\")</p>",
        "id": 434442816,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713564521
    },
    {
        "content": "<p>Yes agreed! I got a bit confused as we started discussing multiple somewhat related things.</p>",
        "id": 434442885,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1713564596
    },
    {
        "content": "<p>Would this be the use case for <code>(x : named% _)</code> ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Probability.Density</span>\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">ℙ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">pdf</span> <span class=\"n\">f</span> <span class=\"n\">ℙ</span> <span class=\"n\">_</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"n\">pdf</span> <span class=\"n\">f</span> <span class=\"n\">ℙ</span> <span class=\"n\">x</span> <span class=\"c1\">-- error: application type mismatch</span>\n<span class=\"k\">#check</span> <span class=\"n\">pdf</span> <span class=\"n\">f</span> <span class=\"n\">ℙ</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"o\">:=</span><span class=\"n\">μ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Right now you <em>have to</em> write down the underscore for the autoParam <code>(μ : Measure E := by volume_tac)</code>. So with <code>named%</code> you could specify <code>μ</code> only by <code>(μ:=...)</code>, is that the idea?</p>",
        "id": 434443918,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1713565243
    },
    {
        "content": "<p>For a case study, Python has multiple kinds of parameters: positional only, keyword only, and ones that can be passed either positionally or by keyword (the default). Its syntax is <code>def f(a,b,c,/,d,e,f,*,g,h)</code> to get <code>a,b,c</code> being positional-only and <code>g,h</code> keyword-only. The syntax isn't relevant here, but they have PEPs supporting the use cases for these parameter types.</p>",
        "id": 434443940,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713565263
    },
    {
        "content": "<blockquote>\n<p>Right now you <em>have to</em> write down the underscore for the autoParam <code>(μ : Measure E := by volume_tac)</code>. So with <code>named%</code> you could specify <code>μ</code> only by <code>(μ:=...)</code>, is that the idea?</p>\n</blockquote>\n<p>Yeah, that looks like a good use case for it.</p>",
        "id": 434444148,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713565403
    },
    {
        "content": "<p>(Your version with <code>{μ : Measure E := by volume_tac}</code> would work here too)</p>",
        "id": 434444228,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713565451
    },
    {
        "content": "<p>That's not the only use case though. I could imagine <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Term.elabAppArgs#doc\">docs#Lean.Elab.Term.elabAppArgs</a> using it for its last three Bool arguments, to require you to use named arguments for them, since it doesn't seem like good practice to depend on whatever order they're in.</p>",
        "id": 434444666,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713565833
    },
    {
        "content": "<p>Imagine the <code>explicit</code> argument gets a default value. For that to be effective, it would have to be moved after <code>ellipsis</code>, and that does not sound like a fun refactor.</p>",
        "id": 434444737,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713565899
    },
    {
        "content": "<p>Yeah I ran into this annoying issue multiple times already and I had to rearrange function arguments.</p>",
        "id": 434444857,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1713565971
    },
    {
        "content": "<p>I'm not sure I understand in what way <code>named%</code> differs from Tomas's proposal</p>",
        "id": 434446328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713567040
    },
    {
        "content": "<p>Two ways:</p>\n<ol>\n<li>It's clear it's meant to elaborate similar to an explicit argument because it uses <code>(...)</code>.</li>\n<li>It supports named-only arguments without default values. (It can give a better error message than \"cannot synthesize placeholder\".)</li>\n</ol>",
        "id": 434447193,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713567632
    },
    {
        "content": "<p>The first isn't a functional difference. Maybe <code>{x := v}</code> is completely self-explanatory, but at least for me I think I would wonder how exactly the default argument is passed in, like whether it does it immediately or it defers it until checking for unsynthesized placeholders.</p>",
        "id": 434447430,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713567794
    },
    {
        "content": "<p>I don't think that's something most users will be wondering about. Elaboration order is an extremely niche aspect of lean</p>",
        "id": 434453494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713572286
    },
    {
        "content": "<p>I think the \"surface reading\" being sensible is more important</p>",
        "id": 434453506,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713572298
    },
    {
        "content": "<p>but regarding elaboration order I would expect it to behave the same as implicit arguments currently do</p>",
        "id": 434453540,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713572339
    },
    {
        "content": "<p>you can already specify the values of implicit arguments using named arguments, so it seems this question is already decided?</p>",
        "id": 434453575,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713572374
    },
    {
        "content": "<p>The error message being bad is something that can be improved independently, even for unmarked implicits</p>",
        "id": 434453671,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713572440
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Optional.20implicit.20argument/near/434453575\">said</a>:</p>\n<blockquote>\n<p>you can already specify the values of implicit arguments using named arguments, so it seems this question is already decided?</p>\n</blockquote>\n<p>How so? Passing named arguments is a very different feature from default values for missing arguments.</p>",
        "id": 434453860,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713572578
    },
    {
        "content": "<blockquote>\n<p>The error message being bad is something that can be improved independently</p>\n</blockquote>\n<p>Let's say we want to support named-only arguments. Would you suggest that error handling should detect that this argument can never be inferred, and from that explain that it must be supplied as a named argument? While that could work, I think it could be confusing to people trying to make sense of an API -- how can they tell whether the argument is supposed to be a named-only argument?</p>",
        "id": 434454148,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713572817
    },
    {
        "content": "<p>I don't think that this needs to be something the function author needs to decide on behalf of clients</p>",
        "id": 434460426,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713578999
    },
    {
        "content": "<p>if it's confusing to call this function with 5 bools in it, then let the client code use named arguments if it wants</p>",
        "id": 434460494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713579036
    },
    {
        "content": "<p>I think the error handling should always suggest using named arguments when an implicit argument fails to be inferred (whether or not it is impossible for it to ever be inferred)</p>",
        "id": 434460543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713579107
    },
    {
        "content": "<p>Another reason why I want default arguments for implicit arguments is to do reductions in function return types.</p>\n<p>Consider this function</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">halve</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">/</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>I would like to reduce <code>n/2</code> as much as possible when you do the application.</p>\n<p>I have a prototype of a tactic <code>infer</code> with which you can define the function as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">halve</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>the tactic figures out that <code>m</code> is meta variable and should be equal to <code>n/2</code>, it reduces <code>n/2</code> and assigns the result to <code>m</code>. For <code>i : Fin 10</code> calling <code>halve i</code> returns term of type <code>Fin 5</code>.</p>\n<p>Ideally the argument <code>hm</code> is an implicit argument:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">halve</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 435106803,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1713932229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Optional.20implicit.20argument/near/434441857\">said</a>:</p>\n<blockquote>\n<p>I'm not sure there are many uses for required-named arguments that don't have default values</p>\n</blockquote>\n<p>this is a feature in ocaml that i genuinely miss in Lean.</p>\n<p>one extra-- in OCaml there's syntax sugar for passing the same labeled argument around, so instead of writing <code>f ~arg:arg</code> you can just write <code>f ~arg</code> (where <code>arg</code> is a variable in the context with the right type). akin to the structure syntax allowing you to pass names directly. I'm not sure how this would be adapted to Lean.</p>",
        "id": 435291344,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1714004043
    },
    {
        "content": "<p>What are the parsers that parse optParams?<br>\nI couldn't find mentions to optParams in the main manuals - are there any? - and I'm trying to read the sources to understand more about them...</p>\n<p>As I already had the parsing diagrams below I tried to read the parsers starting from <code>funBinder</code> and <code>typeAscription</code>, but I couldn't find the code that parse the \"<code>(... := ...)</code>\"s in:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">      </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">     </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"n\">b</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">20</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"n\">b</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f3</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\">       </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">20</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\">       </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"n\">b</span>\n</code></pre></div>",
        "id": 448130712,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1719762252
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/WjrNGMMKauD08YO6mYrK7K_W/sshot.png\">sshot.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/WjrNGMMKauD08YO6mYrK7K_W/sshot.png\" title=\"sshot.png\"><img src=\"/user_uploads/3121/WjrNGMMKauD08YO6mYrK7K_W/sshot.png\"></a></div>",
        "id": 448130760,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1719762286
    },
    {
        "content": "<p>Again, you can ask lean for the names of the parsers by using <code> `(command| def f2 (a : Nat := 20) (b : Nat := 3) : Nat := a+b) </code></p>",
        "id": 448131016,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1719762414
    },
    {
        "content": "<p>Oops, sorry - I forgot that! It's binderDefault...<br>\nThanks!</p>",
        "id": 448132097,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1719763273
    }
]