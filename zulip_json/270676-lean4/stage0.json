[
    {
        "content": "<p>What's the <code>stage0/src</code> directory used for? From the name I guess some thing that handles early parts of the startup process? <code>diff -r stage0/src src</code> shows it's <em>nearly</em> but not exactly a hard copy of the <code>src/</code> directory?</p>",
        "id": 228792441,
        "sender_full_name": "Julian Berman",
        "timestamp": 1614871829
    },
    {
        "content": "<p>See <a href=\"https://leanprover.github.io/lean4/doc/make/index.html#lean-build-pipeline\">https://leanprover.github.io/lean4/doc/make/index.html#lean-build-pipeline</a></p>",
        "id": 228793523,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1614872152
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 228793821,
        "sender_full_name": "Julian Berman",
        "timestamp": 1614872243
    },
    {
        "content": "<p>Are there any precautions against a self-replicating stage0 attack in Lean? I mean, what if someone pushes a PR that updates stage0 but also adds a self-replicating code that opens a backdoor in all future versions? I've just read about <a href=\"https://www.openwall.com/lists/oss-security/2024/03/29/4\">a recent attack on liblzma</a> and I'm more worried about security than usual.</p>",
        "id": 430410268,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1711823286
    },
    {
        "content": "<p><code>update-stage0</code> is currently mostly performed by a bot or trusted contributors. At least I have never seen an <code>update-stage0</code> by an outsider get merged.</p>\n<p>That said, in the xz attack one of the trusted contributors placed the code in question. And there aren't really any measures against this in place. If say an FRO member with Lean 4 push access decides to put some crypto trojan code into the repo that somehow makes it until a release that gets actively used by mathlib the mathlib people do indeed end up in big trouble.</p>",
        "id": 430411789,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1711824672
    },
    {
        "content": "<p>Oh and for an xz type of attack. Of course a mathlib maintainer (or whoever else has push access to master) can push malware to master that gets run on machines of people that pull from master.<br>\nFurthermore if an account of a maintainer gets corrupted by someone it is also possible to carry out this type of attack. So really the security of projects like mathlib is only as good as the maintainer's security, in particular of course the maintainer with the worst security, whoever that might be.</p>\n<p>In the end this is all a very trust based system^^ There are measures against this such as allowing nobody to actually put things on to master but instead enforcing a review process with as many people as you feel secure with signing off on changes (e.g. in the regulated German IT security industry it is mandated that the author + 2 colleagues must sign off on changes) but this always carries an overhead of course. In the end, as with almost all things in security, it is a question of balancing producitvity and security</p>",
        "id": 430415101,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1711827684
    },
    {
        "content": "<p>I would love to see someone replaying the history of lean4, redoing all the stage0 updates, as far back as they manage, so see how close we get to a bootstrappable build (in the sense of  <a href=\"https://bootstrappable.org/\">https://bootstrappable.org/</a>), even if it may not be fully achievable. Bonus points if this effort is made reproducible using nix.</p>",
        "id": 430418551,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1711831095
    },
    {
        "content": "<p>Thinking about this, it shouldn't be too hard to write a script that reproduces a single stage0 update in isolation. Then add a script that runs that on all of them, and displays the result somewhere. Then look at those that fail and see if they can be fixed, or what to do with the few commits that accidentally combine stage0 with other changes (maybe grab the separated changes from the original PR). In some cases shortcuts may be possible, i.e. skipping a stage0, or maybe it will be the case thst one stage0 output cannot be reproduced (actually quite likely given that it may be constructed from a state on a branch that differs from the rebased-onto-master stage), but as long as the output is identical eventually, it should be fine. </p>\n<p>The result of this exercise would be identifying a hopefully very early stage0 that cannot be replicated (yet), reducing the trust needed to those contributers that were already around then. In particular and crucially, not me <span aria-label=\"smiling devil\" class=\"emoji emoji-1f608\" role=\"img\" title=\"smiling devil\">:smiling_devil:</span></p>",
        "id": 430419201,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1711831824
    },
    {
        "content": "<p>Although it’s going to be quite a bit of work: Ever since the <code>stage0</code> directory was introduced in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">commit</span> <span class=\"mi\">91</span><span class=\"n\">b68d8fa42153c696f51c1b57a4c67f803c54c2</span>\n<span class=\"n\">Author</span><span class=\"o\">:</span> <span class=\"n\">Sebastian</span> <span class=\"n\">Ullrich</span> <span class=\"bp\">&lt;</span><span class=\"n\">sebasti</span><span class=\"bp\">@</span><span class=\"n\">nullri.ch</span><span class=\"bp\">&gt;</span>\n<span class=\"n\">Date</span><span class=\"o\">:</span>   <span class=\"n\">Sun</span> <span class=\"n\">Nov</span> <span class=\"mi\">10</span> <span class=\"mi\">23</span><span class=\"o\">:</span><span class=\"mi\">00</span><span class=\"o\">:</span><span class=\"mi\">02</span> <span class=\"mi\">2019</span> <span class=\"bp\">+</span><span class=\"mi\">0100</span>\n\n    <span class=\"n\">feat</span><span class=\"o\">:</span> <span class=\"n\">cleanly</span> <span class=\"n\">separate</span> <span class=\"n\">bootstrap</span> <span class=\"n\">stages</span>\n</code></pre></div>\n<p>there have been 1825 stage0 updates…</p>",
        "id": 430470308,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1711884887
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/stage0/near/430470308\">said</a>:</p>\n<blockquote>\n<p>Although it’s going to be quite a bit of work: Ever since the <code>stage0</code> directory was introduced in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">commit</span> <span class=\"mi\">91</span><span class=\"n\">b68d8fa42153c696f51c1b57a4c67f803c54c2</span>\n<span class=\"n\">Author</span><span class=\"o\">:</span> <span class=\"n\">Sebastian</span> <span class=\"n\">Ullrich</span> <span class=\"bp\">&lt;</span><span class=\"n\">sebasti</span><span class=\"bp\">@</span><span class=\"n\">nullri.ch</span><span class=\"bp\">&gt;</span>\n<span class=\"n\">Date</span><span class=\"o\">:</span>   <span class=\"n\">Sun</span> <span class=\"n\">Nov</span> <span class=\"mi\">10</span> <span class=\"mi\">23</span><span class=\"o\">:</span><span class=\"mi\">00</span><span class=\"o\">:</span><span class=\"mi\">02</span> <span class=\"mi\">2019</span> <span class=\"bp\">+</span><span class=\"mi\">0100</span>\n\n    <span class=\"n\">feat</span><span class=\"o\">:</span> <span class=\"n\">cleanly</span> <span class=\"n\">separate</span> <span class=\"n\">bootstrap</span> <span class=\"n\">stages</span>\n</code></pre></div>\n<p>there have been 1825 stage0 updates…</p>\n</blockquote>\n<p>I'm not 100% sure if I am recalling this correctly but I believe that we very rarely manually copied parts of the build system over into stage0 while reboostrapping? So that could make it harder to automate this</p>",
        "id": 430491738,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1711904540
    },
    {
        "content": "<p>I'm not optimistic to retrace the bootstrapping completely all the way back, but maybe we can achieve an “from X onwards” audit. And in the future enthusiastic sleuthers can push that X further back.</p>",
        "id": 430498992,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1711911457
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 430499570,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1711912022
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/UphmOWWVZk0s_GYqy_m2hqTZ/preview.png\">preview.png</a><br>\nSneak preview into a little stage0 audit tool.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/UphmOWWVZk0s_GYqy_m2hqTZ/preview.png\" title=\"preview.png\"><img src=\"/user_uploads/3121/UphmOWWVZk0s_GYqy_m2hqTZ/preview.png\"></a></div><p>Because of <code>git rebase</code>, the stage0 cannot always be reproduced from the previous commit, in these cases one has to replay a couple of the stage0 updates to go justify one particular good state from another older one. I hope I can automate trying that.</p>\n<p>In other cases we have accidential squash merges where rebase should happen. In these cases probably some manual investigation is needed, e.g. justify the resulting stage0 by going via commits from the original PR.</p>\n<p>This is a little vacation side project, not sure how far I’ll take this.</p>",
        "id": 430867105,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712089387
    },
    {
        "content": "<p>Is it the case that the bot-based stage0 updates mean that this type of non-reproduction is still possible going forward?</p>",
        "id": 430868377,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712089912
    },
    {
        "content": "<p>Yes: the bot can only be used if the stage0 update can happen on master, between two (squashed) PRs. Some features need one or more stage0 updates in the middle of some changes. These PRs are then rebase-merged, and if that happens without first rebasing them on master <em>and</em> updating the stage0 commit therein we get these discrepancies.</p>",
        "id": 430877015,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712093304
    },
    {
        "content": "<p>Would it be better to do a regular merge on those PRs in future so that the bootstrapping can be reproduced?</p>",
        "id": 430877739,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712093599
    },
    {
        "content": "<p>Possibly, if one values that more than the linear history on master. I am not too concerned either way, the history is still in the GitHub repo, and with a bit of plumbing we can probably still retrace the bootstrapping. </p>\n<p>The recent xz backdoor debacle kinda emphasizes the value of such audit, doesn't it? :-)</p>",
        "id": 430974679,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712141548
    },
    {
        "content": "<p>Did I a bit more work on this, my tool can now be told “revision <code>c8d77b83de</code> is a bad squash merge, pretend that instead we have <code>b762567174</code>  at this point in the history”. That justfies a few more stage0 bumps.</p>\n<p>But some are odd in the sense that they simply don’t build. For example this stage0 bump: <a href=\"https://github.com/leanprover/lean4/commits/c8d77b83de1be912bd9aa232d666c6896b05d90e/stage0\">https://github.com/leanprover/lean4/commits/c8d77b83de1be912bd9aa232d666c6896b05d90e/stage0</a><br>\nIf I check out the parent and run <code>nix run .#update-stage0-commit</code> it fails with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">builder</span> <span class=\"n\">for</span> <span class=\"bp\">'/</span><span class=\"n\">nix</span><span class=\"bp\">/</span><span class=\"n\">store</span><span class=\"bp\">/</span><span class=\"n\">iq2bpkkj77phd4x8qrr1b9fr3fhghwjm</span><span class=\"bp\">-</span><span class=\"n\">Init.Tactics.drv'</span> <span class=\"n\">failed</span> <span class=\"k\">with</span> <span class=\"n\">exit</span> <span class=\"n\">code</span> <span class=\"mi\">1</span><span class=\"bp\">;</span>\n       <span class=\"n\">last</span> <span class=\"mi\">8</span> <span class=\"n\">log</span> <span class=\"n\">lines</span><span class=\"o\">:</span>\n       <span class=\"bp\">&gt;</span> <span class=\"n\">Init</span><span class=\"bp\">/</span><span class=\"n\">Tactics.lean</span><span class=\"o\">:</span><span class=\"mi\">1323</span><span class=\"o\">:</span><span class=\"mi\">41</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n       <span class=\"bp\">&gt;</span>   <span class=\"n\">tk.raw</span>\n       <span class=\"bp\">&gt;</span> <span class=\"n\">argument</span>\n       <span class=\"bp\">&gt;</span>   <span class=\"n\">tk</span>\n       <span class=\"bp\">&gt;</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n       <span class=\"bp\">&gt;</span>   <span class=\"n\">Syntax</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n       <span class=\"bp\">&gt;</span> <span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n       <span class=\"bp\">&gt;</span>   <span class=\"n\">TSyntax</span> <span class=\"o\">(</span><span class=\"n\">Name.mkStr1</span> <span class=\"s2\">\"term\"</span> <span class=\"o\">::</span> <span class=\"n\">List.nil</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n       <span class=\"n\">For</span> <span class=\"n\">full</span> <span class=\"n\">logs</span><span class=\"o\">,</span> <span class=\"n\">run</span> <span class=\"bp\">'</span><span class=\"n\">nix</span> <span class=\"n\">log</span> <span class=\"bp\">/</span><span class=\"n\">nix</span><span class=\"bp\">/</span><span class=\"n\">store</span><span class=\"bp\">/</span><span class=\"n\">iq2bpkkj77phd4x8qrr1b9fr3fhghwjm</span><span class=\"bp\">-</span><span class=\"n\">Init.Tactics.drv'.</span>\n</code></pre></div>\n<p>I fear that maybe sometimes developers (no finger pointing intended here!) ran <code>make update-stage0-commit</code> on a different state than was committed before.</p>\n<p>At this point probably manual labor is needed to re-bootstrap from this version from an earlier one.</p>",
        "id": 434529129,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713642603
    },
    {
        "content": "<p>Ok, the weekend is coming to an end, and I should wrap up this weekend project hacking phase, before I use this for even more procrastination.</p>\n<p><a href=\"/user_uploads/3121/z1n7Qj3kOUE79YGPApZSEd9A/audit.png\">audit.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/z1n7Qj3kOUE79YGPApZSEd9A/audit.png\" title=\"audit.png\"><img src=\"/user_uploads/3121/z1n7Qj3kOUE79YGPApZSEd9A/audit.png\"></a></div><p><a href=\"https://lean-stage0.nomeata.de/\">https://lean-stage0.nomeata.de/</a> explains the problem, my methodology  and what the icons above mean. There are not few commits that may require some investigation into how to recreate their stage0. Code at <a href=\"https://github.com/nomeata/lean-stage0-audit\">https://github.com/nomeata/lean-stage0-audit</a>.</p>\n<p>So far, this is static, I did not yet write the automation needed to reproduce commits on github action and update this page automatically. Will do the next time round.</p>\n<p>If someone would enjoy sleuthing around: Can you patch commit <code>c8d77b83de</code> (or its parent) so that a new stage0 can be produced from it?</p>",
        "id": 434612683,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713727218
    },
    {
        "content": "<p>I have on occasion produced stage0 commits which do not exactly match the result you would expect, so I can provide at least one explanation for why this might happen:</p>\n<ul>\n<li>The PR needs a stage0-update</li>\n<li>Create part 1</li>\n<li>run <code>make update-stage0</code></li>\n<li>Create part 2</li>\n<li>Run the tests</li>\n<li>oops, missed a doc comment in part 1</li>\n<li>create a fixup commit and <code>git rebase -i</code> to apply it to part 1</li>\n<li>I can't be bothered to run <code>make update-stage0</code> again because I'll need to do it again later after every rebase</li>\n</ul>\n<p>I generally expect that stage0 commits in PRs don't matter though, because they are recreated from scratch on the master branch in the end anyway. They are just used to make sure the tests pass</p>",
        "id": 434616167,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713730497
    },
    {
        "content": "<p>you can also replace \"doc comment\" with \"trivial code typo\" in the above as well, at which point the possibility of a stage0 update that fails to build becomes more likely</p>",
        "id": 434616258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713730572
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/stage0/near/430877015\">said</a>:</p>\n<blockquote>\n<p>Yes: the bot can only be used if the stage0 update can happen on master, between two (squashed) PRs. Some features need one or more stage0 updates in the middle of some changes. These PRs are then rebase-merged, and if that happens without first rebasing them on master <em>and</em> updating the stage0 commit therein we get these discrepancies.</p>\n</blockquote>\n<p>My impression was that in these cases you <em>always</em> rerun the update-stage0 during the rebase-merge. I will usually make use of the <code>x</code> command in <code>rebase -i</code> to replace every update-stage0 commit.</p>",
        "id": 434616518,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713730803
    },
    {
        "content": "<p>it would be nice if there was a way to get the bot to do this too</p>",
        "id": 434616544,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713730829
    },
    {
        "content": "<p>The final rebase is usuay done by GitHub (triggered by an admin), I think, and thus won't do anything special to the commit. For this to work out nicely, the PR author has to have the feature branch up to date with master and the stage0 commit fresh also has to be up to date. Maybe this isn't clearly documented? But even when it is, it's plenty of manual busiwork that can go wrong. We could have CI complain if thats not the case, so far we don't have such a check.</p>",
        "id": 434660089,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713766494
    },
    {
        "content": "<p>I couldn’t resist playing around with this some more. Most of the “red” commits on <code>master</code> could be fixed by digging through Github to see from what branch they were rebased from, and using that instead.</p>\n<p>In two instances that failed as well, probably because of not committing all changes before updating stage0. In these cases I found a manual fix that I could apply to make it build again. I pushed these to <code>stage0-graft/&lt;hash of commit to be replaced&gt;</code>. </p>\n<p>This means I can now reproduce the history of stage0 until … <span aria-label=\"drum\" class=\"emoji emoji-1f941\" role=\"img\" title=\"drum\">:drum:</span>  …  February!</p>\n<p>Not so impressive yet, but its a start. Going back further is initially just busiwork (and better automation). Going forwards should hopefully be easier as well, as we hopefully pay a bit more  attention to this.</p>",
        "id": 435232410,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713976796
    },
    {
        "content": "<p>I’m on vacation, and for reasons best not dwelled too much on this meant I pushed this project a bit further.</p>\n<p>There is now a github action workflow that uses that <del>free</del> payed-by-someone-else computer power to audit new lean4 commits, and also tries to reproduce older stage0 updates, pushing the “time of trust” further back. So every two hours, one step of progress should happen on <a href=\"https://lean-stage0.nomeata.de/\">https://lean-stage0.nomeata.de/</a>.</p>\n<p>Right now there aren’t any stage0 commits whose providence needs manual investigation, we’ll see how much of that we need.</p>",
        "id": 439464582,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1716150518
    },
    {
        "content": "<p>Another thing I'd like to try, maybe after you have finished replicating all the stage0's back to the beginning, is to see whether you can skip steps: That is, if you can use an earlier lean compiler to compile and reproduce a later stage0 update, you may be able to remove steps from the chain. My guess is that most steps can't be removed, or else we would not have an update-stage0 there, but it's possible that independent changes can be merged</p>",
        "id": 439465128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1716151114
    },
    {
        "content": "<p>That would be rather easy to test with the current infrastructure – the build script takes a stage0 and a non-stage0 source and builds the latter with the former, so one could probe larger steps</p>\n<p>But it doesn't matter for the existential question “can we reproduce current stage0”, only for (non-Prop?) task of actually doing that. So if, one day, the guix people want to ship lean4 they’ll be very happy if we can shorten the bootstrap chain from what it’s now :-). Besides, that, do you have another motivation for investigating in that direction?</p>",
        "id": 439465873,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1716151906
    },
    {
        "content": "<p>Shortening the chain is my primary motivation. I have a dream that we can shorten the chain to O(1) compilers, but it will not at all be following history. For your current work, it does have a side benefit that skipping steps allows you to not worry about breaks in the chain and potentially decrease the amount of commits to test, although since my prior on the probability of steps being skippable is low, it's likely to be more work and not less to optimize the chain length</p>",
        "id": 439466071,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1716152107
    },
    {
        "content": "<p>At one commit per 2 hours, I project it to finish at <time datetime=\"2024-10-13T13:00:00Z\">2024-10-13T15:00:00+02:00</time></p>",
        "id": 439466690,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1716152734
    },
    {
        "content": "<p>And that's only if the build script works fine with old commits, and we don't have too many bad merges or other commits that need manual intervention, and the page starts at a relative random point in the lean history (I think when the <code>stage0</code> directory was created)…</p>\n<p>It takes about 15 mins on a runner to do one step, and it's quite trivially parallizable, so we could run it faster of course. But it just means that we hit some more serious road blocks earlier…</p>",
        "id": 439466885,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1716152937
    },
    {
        "content": "<p>I would like to better understand the \"prehistory\" of stage0</p>",
        "id": 439466987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1716153050
    },
    {
        "content": "<p>does there actually exist a working C++ lean compiler in the lean4 history?</p>",
        "id": 439467008,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1716153083
    },
    {
        "content": "<p>If it only takes 15 minutes per step, then I suggest increasing the frequency to 30 minutes instead of 2 hours. And ideally it shouldn't stop at bad merges, it should just keep going until the status of all updates is determined. You can do manual intervention stuff in parallel</p>",
        "id": 439467116,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1716153224
    },
    {
        "content": "<blockquote>\n<p>The produced <code>stage0/</code> trees, which may not exist as such in the main lean4 repository, are stored in this git repository under <code>refs/stage0/&lt;short tree hash&gt;</code>. This allows the reproduction of each individual step even in a long “alternative” chain.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> I can't find this in the git repo. Is this a tag, a branch, or a folder? I can't find any of them from github. It's also not clear from the description how short the tree hash is or whether it refers to the commit before or after a stage0 update</p>",
        "id": 439467674,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1716153782
    },
    {
        "content": "<p>It does keep going if the build fails, but will get stuck if my GitHub action fails.</p>",
        "id": 439496375,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1716180905
    },
    {
        "content": "<p>It's neither, it's a ref ”next to” tags and branches, and stores a tree object instead of a commit object there. May unnecessary advanced git foo :-)</p>\n<p>You can fetch them using </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">git</span> <span class=\"n\">fetch</span> <span class=\"n\">https</span><span class=\"o\">:</span><span class=\"bp\">//</span><span class=\"n\">github.com</span><span class=\"bp\">/</span><span class=\"n\">nomeata</span><span class=\"bp\">/</span><span class=\"n\">lean</span><span class=\"bp\">-</span><span class=\"n\">stage0</span><span class=\"bp\">-</span><span class=\"n\">audit</span> <span class=\"bp\">'</span><span class=\"n\">refs</span><span class=\"bp\">/</span><span class=\"n\">stage0</span><span class=\"bp\">/*</span><span class=\"o\">:</span><span class=\"n\">refs</span><span class=\"bp\">/</span><span class=\"n\">stage0</span><span class=\"bp\">/*'</span>\n</code></pre></div>",
        "id": 439496576,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1716181045
    },
    {
        "content": "<p>Bumped frequency to 30mins. It's now hitting a stretch of commits where there seems to be a stray <code>#exit</code> in the source making the build fails (signified by a frowny in the table), so probably needs manual intervention (possibly just deleting the exit and everything after). Not sure when and if I'll investigate myself, but happy to assist if someone else feels like sleuthing.</p>",
        "id": 439506201,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1716185462
    },
    {
        "content": "<p>Many build failures or reproducibility failures can be fixed by rewriting the git history and replacing the rebased commits with the original one. This is supported and helped a few times. </p>\n<p>I wonder if this can be automated: is there a way to query GitHub for a given commit if this is commit is the result of a rebase merge on GitHub, and what the original commit was?</p>\n<p>Maybe <a href=\"https://github.com/orgs/community/discussions/24679#discussioncomment-3245032\">https://github.com/orgs/community/discussions/24679#discussioncomment-3245032</a>  is worth investigating.</p>",
        "id": 439546190,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1716201330
    },
    {
        "content": "<p>I would guess your best option is to hit the API for every PR and build the map in the other direction</p>",
        "id": 439554893,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1716204862
    },
    {
        "content": "<p>(I hit the API this for all ~30k mathlib PRs when building a .bib file for my thesis; PyGithub is clever enough to do the necessary rate limit backoff)</p>",
        "id": 439555006,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1716204911
    },
    {
        "content": "<p>This is mildly addictive; I fixed a few more failing stage0 builds, mostly by digging out the corresponding commit from the pre-rebase feature branch, but in a few cases the builds failed due to some temporary <code>#exit</code> in a source file; if I just remove that part of the file it reproduces. Not sure if the make-based stage0 update ignores such warnings and the nix-based one (which my tool uses) doesn’t, or how else that worked initially. If that comes up more often I guess the build script can use <code>sed</code> to remove <code>#exit</code>’s from the source so that that needs less manual intervention.</p>",
        "id": 439680826,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1716239482
    },
    {
        "content": "<p>I know that kind of vacations.</p>",
        "id": 439681015,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1716239549
    },
    {
        "content": "<p>Granted, it’s <span aria-label=\"rainy\" class=\"emoji emoji-1f327\" role=\"img\" title=\"rainy\">:rainy:</span> :-)</p>",
        "id": 439681071,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1716239575
    },
    {
        "content": "<p><a href=\"https://lean-stage0.nomeata.de/\">https://lean-stage0.nomeata.de/</a> is chugging along nicely now, seems to be able to fix the occasional bad merge by itself, and has reached last November.</p>",
        "id": 440077939,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1716379986
    },
    {
        "content": "<p>I'm sorry about the weather. :-)</p>",
        "id": 440079102,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1716380391
    },
    {
        "content": "<p>I did get another two flights done this morning, but now it's hailing…</p>",
        "id": 440097622,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1716386113
    },
    {
        "content": "<p>The new completion forecast is <time datetime=\"2024-06-11T21:30:00Z\">2024-06-11T23:30:00+02:00</time></p>",
        "id": 440196625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1716417457
    },
    {
        "content": "<p>Note that I shortened the list of commits shown on the webpage to begin with the first one that introduces the nix based stage0 update, which my build script is using. Going further back will require more work on that front. Maybe that changed the forecast.</p>",
        "id": 440257263,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1716446426
    },
    {
        "content": "<p>The attack horizon is now pushed back to Jul 25, 2023, which is before I started at the FRO, so that should be a relief for many ;-)</p>",
        "id": 440257461,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1716446524
    },
    {
        "content": "<p>Ah, but if we can't trust you, can we trust your verification? :)</p>",
        "id": 440261154,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1716448378
    },
    {
        "content": "<p>Darn, and I thought I got through with this</p>",
        "id": 440262738,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1716449113
    },
    {
        "content": "<p>Jokes aside: it should be possible to clone the repo, delete the <code>builds.csv</code> file, let it sit for a while while GitHub does their work, and reproduce the audit. Of course you also have to check the scripts in tbe repo (not much) and every single non-stage0 source change in the lean4 history (a bit more work…)</p>",
        "id": 440262989,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1716449230
    },
    {
        "content": "<p>And already we are at Dec 1, 2022. Suddenly we have much fewer problematic stage0 updates. I wager that's because back then there were fewer developers, so less parallel feature branches, and more direct pushes to master, rather than going via a PR. That's good news. If it continues like this the next hurdle will be adjusting to older build setups in the repo.</p>",
        "id": 440397437,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1716497874
    },
    {
        "content": "<p>It is unreasonably satisfying to reload the page and see a few more green tickmarks there. But I was tired of manually scrolling past the green part, so the top of  <a href=\"https://lean-stage0.nomeata.de/\">https://lean-stage0.nomeata.de/</a> now has a status line of the form</p>\n<blockquote>\n<p>The current <code>stage0/</code> code copy can be traced to <code>stage0/</code> in <a href=\"https://lean-stage0.nomeata.de/#f9acb7fc9f\">revision ✨ <code>f9acb7fc9f</code></a> from 2022-10-15 in 191 steps.</p>\n</blockquote>\n<p>Assuming we ever get to a non-lean bootstrap, I’m looking forward to the conversation with the nix or guix people</p>\n<p>– So lean is self-boostrapping, is it?<br>\n– Yes, but we also have a bootstrap path from C++!<br>\n– Great! Then we can include lean in our bootstrapped distribution…<br>\n– Cool. Here are the 1456 versions of lean you have to build in sequence.<br>\n– <span aria-label=\"fear\" class=\"emoji emoji-1f628\" role=\"img\" title=\"fear\">:fear:</span></p>",
        "id": 440577388,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1716584686
    },
    {
        "content": "<p>– We tested it, it totally works. You just need to tie up your build machine / your users' computers for a month</p>",
        "id": 440581478,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1716587077
    },
    {
        "content": "<p>Now at  2021-09-12 in 612 steps. In that time frame I find a few with actual build errors such as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">       </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Init</span><span class=\"bp\">/</span><span class=\"n\">SimpLemmas</span><span class=\"bp\">.</span><span class=\"n\">lean</span><span class=\"o\">:</span><span class=\"mi\">71</span><span class=\"o\">:</span><span class=\"mi\">51</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">       </span><span class=\"bp\">&gt;</span><span class=\"w\">   </span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">       </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">       </span><span class=\"bp\">&gt;</span><span class=\"w\">   </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">       </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">       </span><span class=\"bp\">&gt;</span><span class=\"w\">   </span><span class=\"n\">ite</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ite</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>that likely require manual investigation. The tool keeps churning on below, so when and if someone investigates the gap will be filled.</p>",
        "id": 442847204,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1717607652
    },
    {
        "content": "<p>this is so cool</p>",
        "id": 442856393,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1717610404
    },
    {
        "content": "<p>Glad to hear you think it’s cool, because it’s very questionable whether it’s useful :-D</p>",
        "id": 443111734,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1717693076
    },
    {
        "content": "<p>Well clearly it makes the weather go better by the time it's done <span aria-label=\"mostly sunny\" class=\"emoji emoji-1f324\" role=\"img\" title=\"mostly sunny\">:mostly_sunny:</span></p>",
        "id": 443111892,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1717693112
    },
    {
        "content": "<p>Did not investigate the few failing commits yet, but the tool chugged on, so as additional motivation it now says how far it could build things if one did investigate these builds:</p>\n<blockquote>\n<p>The current <code>stage0/</code> code copy can be traced to <code>stage0/</code> in <a href=\"https://lean-stage0.nomeata.de/#1de3efff9d\">revision ✨ <code>1de3efff9d</code></a> from 2021-09-12 in 615 steps.</p>\n</blockquote>\n<blockquote>\n<p>Investigating 6 revisions will trace it to <a href=\"https://lean-stage0.nomeata.de/#5787fc5ce4\">revision <code>5787fc5ce4</code></a> from 2021-03-06 in 839 steps.</p>\n</blockquote>",
        "id": 443857935,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1718051315
    },
    {
        "content": "<p>Investigated a few commits that really needed some work (splitting commits, reordering). Now at</p>\n<blockquote>\n<p>The current <code>stage0/</code> code copy can be traced to <code>stage0/</code> in <a href=\"https://lean-stage0.nomeata.de/#14c438234a\">revision ✨ <code>14c438234a</code></a> from 2020-12-08 in 1027 steps.</p>\n</blockquote>\n<p>I’m nearing the commit that introduced the <code>nix run .#update-stage0-commit</code> feature, going earlier than that will require more plumbing work on my end.</p>",
        "id": 445135739,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1718631784
    },
    {
        "content": "<p>We have reached the end of this list of commits</p>\n<blockquote>\n<p>The current <code>stage0/</code> code copy can be traced to <code>stage0/</code> in <a href=\"https://lean-stage0.nomeata.de/#e2ff1c2b7e\">revision ✨ <code>e2ff1c2b7e</code></a> from 2020-11-25 in 1088 steps.</p>\n</blockquote>\n<p>This is not the beginning of development, far from it, but is the stage0 following the introduction of  <code>nix run .#update-stage0-commit</code> in <a href=\"https://github.com/leanprover/lean4/commit/2794ae76f9924fa4d1047c478e0b509d568322e6\"><code>2794ae76</code></a>.</p>\n<p>Going further back would require writing a small script and nix derivation that sets up the build environment using nix (for reproduciliby) but then uses the <code>make</code> setup to build stage0. Maybe during the next rainy vacation.</p>\n<p>Until then I have reduced the cron rate of the script; it will still update <a href=\"https://lean-stage0.nomeata.de/\">https://lean-stage0.nomeata.de/</a> as new stage0 commits are added to the top.</p>",
        "id": 445776278,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1718868536
    }
]