[
    {
        "content": "<p>I have the following minimized problem. For some reason, <code>taker nop</code> renders as <code>taker fun {A} =&gt; nop</code> in the infoview, which is very distracting and hard to read. In some places I can fix this by writing <code>taker @nop</code> instead.<br>\nIt's eta equivalent, but annoying.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Ty</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">|</span> <span class=\"n\">ty</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Tm</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"bp\">|</span> <span class=\"n\">tm</span> <span class=\"o\">:</span> <span class=\"n\">Tm</span> <span class=\"bp\">.</span><span class=\"n\">ty</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Subb</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span><span class=\"o\">}</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">var_idx</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Tm</span> <span class=\"n\">A</span>\n<span class=\"kd\">def</span> <span class=\"n\">nop</span> <span class=\"o\">:</span> <span class=\"n\">Subb</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"n\">idx</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">tm</span>\n<span class=\"kd\">def</span> <span class=\"n\">taker</span> <span class=\"o\">:</span> <span class=\"n\">Subb</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"k\">#check</span> <span class=\"n\">taker</span> <span class=\"n\">nop</span> <span class=\"c1\">-- taker fun {A} =&gt; nop : String</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">pp.all</span> <span class=\"n\">true</span>\n<span class=\"kd\">def</span> <span class=\"n\">ohno</span> <span class=\"o\">:=</span> <span class=\"n\">taker</span> <span class=\"n\">nop</span>\n<span class=\"kd\">def</span> <span class=\"n\">ohyes</span> <span class=\"o\">:=</span> <span class=\"n\">taker</span> <span class=\"bp\">@</span><span class=\"n\">nop</span>\n<span class=\"k\">#print</span> <span class=\"n\">ohno</span> <span class=\"c1\">-- taker fun {A : Ty} =&gt; @nop A</span>\n<span class=\"k\">#print</span> <span class=\"n\">ohyes</span> <span class=\"c1\">-- taker @nop</span>\n</code></pre></div>\n<p>I assume that would be very hard to fix and would require the elaborator or delaborator to be changed.<br>\nIs there a better way of handling these? Does someone have a delaborator for this written already? Maybe there is a tactic which will eta-simplify?</p>",
        "id": 409198609,
        "sender_full_name": "Max Nowak 游낼",
        "timestamp": 1703082881
    },
    {
        "content": "<p>The fact that these two print in different ways suggests that what you want is an elaborator change, not a delaborator change.</p>",
        "id": 409204666,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703084664
    },
    {
        "content": "<p>Yeah... I take it there is no easy solution, other than just not using implicit arguments like this?</p>",
        "id": 409208362,
        "sender_full_name": "Max Nowak 游낼",
        "timestamp": 1703085805
    },
    {
        "content": "<p>I find this to be surprising behavior. Why is the elaborator unfolding <code>Subb</code>? The type of <code>nop</code> is <code>Subb</code>, so where is it getting the idea that it needs to see that there is an implicit argument hidden behind the definition of <code>Subb</code>?</p>",
        "id": 409218339,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703088922
    },
    {
        "content": "<p>Oh yeah I didn't even notice that, that's even weirder.</p>",
        "id": 409218913,
        "sender_full_name": "Max Nowak 游낼",
        "timestamp": 1703089111
    },
    {
        "content": "<p>I think implicit lambdas always do this?</p>",
        "id": 409219034,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703089160
    },
    {
        "content": "<p>they are eagerly inserted and then canceled using implicit arguments (producing an eta redex) if needed</p>",
        "id": 409219108,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703089191
    },
    {
        "content": "<p>That would make sense to me if there were any implicit lambdas that the elaborator could immediately see in the types of <code>taker</code> or <code>nop</code>, but does it see that <code>nop</code> is an implicit lambda? Or that <code>Subb</code> is a type with an implicit forall?</p>",
        "id": 409219437,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703089301
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"416280\">Max Nowak 游낼</span> <a href=\"#narrow/stream/270676-lean4/topic/Funcs.20with.20implicit.20parameters.20hard.20to.20read/near/409208362\">said</a>:</p>\n<blockquote>\n<p>Yeah... I take it there is no easy solution, other than just not using implicit arguments like this?</p>\n</blockquote>\n<p>well, implicit foralls in definitions are generally avoided for exactly this reason. Normally when you want this in a definition like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Subset#src\">src#Set.Subset</a> you use semi-implicits instead (this is their main motivation)</p>",
        "id": 409219617,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703089354
    },
    {
        "content": "<p>Oh, the implicit lambda feature does whnf on the expected type, right? Actually, never mind, this doesn't explain the behavior of <code>nop</code> for me, since it's not a lambda unless you unfold it.</p>",
        "id": 409219637,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703089358
    },
    {
        "content": "<p>implicit lambda triggers basically whenever you call <code>elabTerm</code>, it doesn't require there to be a lambda expected or a forall goal</p>",
        "id": 409219946,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703089464
    },
    {
        "content": "<p>it's an optional parameter to the function: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Term.elabTerm#doc\">docs#Lean.Elab.Term.elabTerm</a></p>",
        "id": 409220099,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703089533
    },
    {
        "content": "<p>I think the semi implicit binders are exactly what I was looking for</p>",
        "id": 409220633,
        "sender_full_name": "Max Nowak 游낼",
        "timestamp": 1703089709
    }
]