[
    {
        "content": "<p>Say I define a type of heterogeneous lists by </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">HList.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span>  <span class=\"o\">:</span> <span class=\"n\">HList</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">τs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)}</span> <span class=\"bp\">→</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">HList</span> <span class=\"n\">τs</span> <span class=\"bp\">→</span> <span class=\"n\">HList</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"o\">::</span> <span class=\"n\">τs</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Then <code>HList τs</code> lives in the universe <code>u+1</code> because each node of the list has to store the type of that element. But we can define an equivalence <code>(τs : List (Type u)) → HList τs ≃ List.foldr Prod PUnit.{u + 1} τs</code>, so in fact <code>HList τs</code> is essentially <code>u</code>-small. Is there any clever way of rewriting this definition that's still an inductive type but lives in <code>Type u</code>?</p>",
        "id": 419661877,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1707014420
    },
    {
        "content": "<p>I'm curious about this too. It seems like the fact that <code>List (Type u)</code> is an index to the inductive type means that <code>{τ : Type u}</code> and <code>{τs : List (Type u)}</code> shouldn't be counted for the universe bump. Maybe there's some subtlety to constructors (like <code>::</code>) in indices, or maybe this is something that could be supported but isn't? I have heard that there are some inductive types that the elaborator rejects but the kernel wouldn't -- this isn't one of those, is it?</p>",
        "id": 419676666,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707031001
    },
    {
        "content": "<p>Agda also rejects this:</p>\n<div class=\"codehilite\" data-code-language=\"Agda\"><pre><span></span><code><span class=\"kr\">open</span><span class=\"w\"> </span><span class=\"kr\">import</span><span class=\"w\"> </span><span class=\"n\">Data.List</span>\n\n<span class=\"kr\">data</span><span class=\"w\"> </span>HList<span class=\"w\"> </span><span class=\"o\">{</span>u<span class=\"o\">}</span><span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span>List<span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Set</span><span class=\"w\"> </span>u<span class=\"o\">)</span><span class=\"w\"> </span><span class=\"ow\">→</span><span class=\"w\"> </span><span class=\"kt\">Set</span><span class=\"w\"> </span>u<span class=\"w\"> </span><span class=\"kr\">where</span>\n<span class=\"w\">  </span><span class=\"nf\">nil</span><span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span>HList<span class=\"w\"> </span>[]\n<span class=\"w\">  </span><span class=\"nf\">cons</span><span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span><span class=\"ow\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span>τ<span class=\"w\"> </span>τs<span class=\"o\">}</span>,<span class=\"w\"> </span>τ<span class=\"w\"> </span><span class=\"ow\">→</span><span class=\"w\"> </span>HList<span class=\"w\"> </span>τs<span class=\"w\"> </span><span class=\"ow\">→</span><span class=\"w\"> </span>HList<span class=\"w\"> </span><span class=\"o\">(</span>τ<span class=\"w\"> </span>∷<span class=\"w\"> </span>τs<span class=\"o\">)</span>\n\n<span class=\"cm\">{-</span>\n<span class=\"cm\">Set (Agda.Primitive.lsuc u) is not less or equal than Set u</span>\n<span class=\"cm\">when checking that the type List (Set u) of an argument to the</span>\n<span class=\"cm\">constructor cons fits in the sort Set u of the datatype.</span>\n<span class=\"cm\">Note: this argument is forced by the indices of cons, so this</span>\n<span class=\"cm\">definition would be allowed under --large-indices.</span>\n<span class=\"cm\">-}</span>\n</code></pre></div>\n<p>The mentioned <code>large-indices</code> option is <a href=\"https://agda.readthedocs.io/en/v2.6.4/tools/command-line-options.html#cmdoption-large-indices\">apparently</a> known to be inconsistent with the no-UIP version of Agda's type theory, but since Lean has UIP, it could maybe relax its restrictions here.</p>",
        "id": 419715592,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1707067941
    },
    {
        "content": "<p>Just to check, by writing an implementation for the type by hand, this inductive type should be OK in Lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">HList</span> <span class=\"o\">(</span><span class=\"n\">τs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">τs.foldr</span> <span class=\"n\">Prod</span> <span class=\"n\">PUnit</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">match_pattern</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">HList.nil</span> <span class=\"o\">:</span> <span class=\"n\">HList</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">PUnit.unit</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">match_pattern</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">HList.cons</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">τs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">HList</span> <span class=\"n\">τs</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">HList</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"o\">::</span> <span class=\"n\">τs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">HList.rec</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">τs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">HList</span> <span class=\"n\">τs</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"o\">[]</span> <span class=\"n\">HList.nil</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">τs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">HList</span> <span class=\"n\">τs</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n              <span class=\"n\">motive</span> <span class=\"n\">τs</span> <span class=\"n\">xs</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"o\">::</span> <span class=\"n\">τs</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HList.cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">))</span>\n    <span class=\"o\">{</span><span class=\"n\">τs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">HList</span> <span class=\"n\">τs</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">τs</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">τs</span><span class=\"o\">,</span> <span class=\"n\">xs</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"n\">PUnit.unit</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nil</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">::</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"o\">(</span><span class=\"n\">HList.rec</span> <span class=\"n\">nil</span> <span class=\"n\">cons</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 419717525,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707069283
    },
    {
        "content": "<p>I wonder if it's worth filing a Lean 4 issue for this feature?</p>\n<p>Are there other cases where large indices would be useful?</p>",
        "id": 419718067,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707069691
    },
    {
        "content": "<p>Side note, in what ways does the manual construction differ from an inductive type like List? Like, is the runtime representation any larger? My understanding is that it should be the same, but I'm not sure. Does the positivity checker recognize that <code>α</code> is positive in <code>HList (α::τ)</code> for either/both definitions?</p>",
        "id": 419718489,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1707069992
    },
    {
        "content": "<p>I think the runtime representation should be exactly the same between the <code>List.foldr</code> one and <code>HList</code> (if it worked)</p>",
        "id": 419718934,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707070321
    },
    {
        "content": "<p>Actually, the <code>List.foldr</code> seems to be more efficient. I'm seeing that the inductive type stores the list of types (but the elements of the list are cleared, since types have no runtime representation)</p>",
        "id": 419719252,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707070576
    },
    {
        "content": "<p>Huh! I would've thought <code>List X</code> got erased if <code>X</code> did</p>",
        "id": 419719272,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1707070608
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Universe.20level.20of.20heterogeneous.20list/near/419718067\">said</a>:</p>\n<blockquote>\n<p>I wonder if it's worth filing a Lean 4 issue for this feature?</p>\n<p>Are there other cases where large indices would be useful?</p>\n</blockquote>\n<p>I'd like to get a better understanding of the tradeoffs or how it works in other languages first, but it would be nice to have this definition accepted! I'm kind of shocked that heterogenous lists and arrays aren't in Std</p>",
        "id": 419719981,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1707071146
    },
    {
        "content": "<p>(my use case is for defining morphisms in a version of the TypeVec category based on vectors as a subtype of lists, because it would be useful in a formalization of multicategories based on lists I'm writing)</p>",
        "id": 419720138,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1707071266
    },
    {
        "content": "<p>IIRC, \"indices don't matter\" forces any <code>Eq</code>-like inductive definition to live in the lowest universe (Prop) and therefore implies UIP. I don't immediately recall the details.</p>",
        "id": 419720279,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1707071397
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Universe.20level.20of.20heterogeneous.20list/near/419676666\">said</a>:</p>\n<blockquote>\n<p>I'm curious about this too. It seems like the fact that <code>List (Type u)</code> is an index to the inductive type means that <code>{τ : Type u}</code> and <code>{τs : List (Type u)}</code> shouldn't be counted for the universe bump.</p>\n</blockquote>\n<p>It's the opposite: having them as indices rather than as parameters is what leads to the problem</p>",
        "id": 419721029,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707071997
    },
    {
        "content": "<p>Sure, parameters don't have this issue, but I mean that it seems like in principle constructor arguments that are constrained by the indices shouldn't necessarily lead to a universe bump</p>",
        "id": 419721189,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707072121
    },
    {
        "content": "<p>This is also known as \"non-uniform parameters\"</p>",
        "id": 419721234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707072135
    },
    {
        "content": "<p>it's a kernel extension which I don't think buys too much and increases the trust base so I'm not inclined toward it</p>",
        "id": 419721258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707072175
    },
    {
        "content": "<p>you can define such types by recursion so I don't see the point</p>",
        "id": 419721274,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707072191
    },
    {
        "content": "<p>that is, the <code>List (Type u)</code> argument is not quite an index but also not quite a parameter</p>",
        "id": 419721318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707072231
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Universe.20level.20of.20heterogeneous.20list/near/419721274\">said</a>:</p>\n<blockquote>\n<p>you can define such types by recursion so I don't see the point</p>\n</blockquote>\n<p>Just to check -- you mean like my code block implementing <code>HList</code>, right?</p>",
        "id": 419721403,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707072289
    },
    {
        "content": "<p>yes</p>",
        "id": 419721407,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707072294
    },
    {
        "content": "<p>you don't want it to be a proper index because then you need \"too many constructors\"</p>",
        "id": 419721408,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707072296
    },
    {
        "content": "<p>Do you think the <code>inductive</code> command could set up this recursion and implement the type?</p>",
        "id": 419721620,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707072460
    },
    {
        "content": "<p>Another classic example of non-uniform parameters is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">BalancedTree</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">BalancedTree</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pair</span> <span class=\"o\">:</span> <span class=\"n\">BalancedTree</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">BalancedTree</span> <span class=\"n\">α</span>\n</code></pre></div>",
        "id": 419721628,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707072476
    },
    {
        "content": "<p>(another fun encoding of <code>HList τs</code>, although it's still in universe <code>u+1</code>, is as <code>{ xs : List (Σ τ, τ) // xs.map Sigma.fst = τs }</code>. This requires way too much casting to use though)</p>",
        "id": 419721673,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1707072484
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Universe.20level.20of.20heterogeneous.20list/near/419721620\">said</a>:</p>\n<blockquote>\n<p>Do you think the <code>inductive</code> command could set up this recursion and implement the type?</p>\n</blockquote>\n<p>The lean 4 <code>inductive</code> command doesn't do inductive simulation anymore, so that seems possibly contentious</p>",
        "id": 419721714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707072547
    },
    {
        "content": "<p>I think we need a better story for doing simulations in <code>inductive</code> and <code>coinductive</code> but I don't think it's a year 1 goal</p>",
        "id": 419721740,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707072597
    },
    {
        "content": "<p>I've never really seen the point of an <code>HList</code> type, you can just use iterated products because the arity is fixed</p>",
        "id": 419721925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707072728
    },
    {
        "content": "<p>I guess a motivated individual could write <code>inductive!</code> to try hard to compile a type to <code>inductive</code> and then wire it up to look like the inductive you think it is...</p>",
        "id": 419721937,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707072746
    },
    {
        "content": "<p>There are two issues with that strategy:</p>\n<ol>\n<li>We really want to guarantee inductive-like ABI and compiler handling, most encodings have difficulty with this without special compiler support</li>\n<li>All the tactics need to not peek through the abstraction and treat it like an inductive type, necessitating many changes to the metaprogramming API</li>\n</ol>",
        "id": 419722061,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707072850
    },
    {
        "content": "<p>You also wouldn’t get nice pattern matching and would have to call your defined recursor yourself. Although, I do wonder how hard it would be to make the match compiler support custom recursors</p>",
        "id": 419892028,
        "sender_full_name": "Max Nowak 🐉",
        "timestamp": 1707154079
    }
]