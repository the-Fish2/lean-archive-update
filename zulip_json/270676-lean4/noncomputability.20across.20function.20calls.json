[
    {
        "content": "<p>I am a bit curious how the computability checker works across function call boundaries. Which arguments to a function does the computability checker ensure are computable? Is there a way to mark that an argument should not be used for computation in the body?</p>",
        "id": 421099024,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707761889
    },
    {
        "content": "<p>as an example, I have a definition</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">VEncCNF</span> <span class=\"o\">(</span><span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LitVar</span> <span class=\"n\">L</span> <span class=\"n\">ν</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ν</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">PropFun</span> <span class=\"n\">ν</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">EncCNF</span> <span class=\"n\">L</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">e.encodesProp</span> <span class=\"n\">P</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>where <code>EncCNF</code> is essentially just a state monad. The <code>Fintype</code> argument and the <code>P</code> argument should both always be treated noncomputably. For example I have a function for constructing these values:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">for_all</span> <span class=\"o\">(</span><span class=\"n\">arr</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">PropFun</span> <span class=\"n\">ν</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">VEncCNF</span> <span class=\"n\">L</span> <span class=\"n\">Unit</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n  <span class=\"o\">:</span> <span class=\"n\">VEncCNF</span> <span class=\"n\">L</span> <span class=\"n\">Unit</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">all</span> <span class=\"o\">(</span><span class=\"n\">arr.toList.map</span> <span class=\"n\">P</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>and Lean currently seems to be marking that <code>P</code> is used for computation (i.e. I call <code>for_all</code> elsewhere with a noncomputable <code>P</code> and it complains), when in reality it should not be used anywhere.</p>",
        "id": 421100586,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707762361
    },
    {
        "content": "<p>using mathlib <code>Erased</code> seems like way more effort than it is worth. In the <code>for_all</code> example I would need to use the monad instance on erased, which substantially increases my proof burden</p>",
        "id": 421100883,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707762450
    },
    {
        "content": "<p>I somewhat successfully used <code>Erased</code> to make an <code>ErasedFintype</code> typeclass to prevent lean from computing that <code>Fintype</code> argument at callsites, but now that the <code>P</code> argument is demanding the same treatment I am getting worn down</p>",
        "id": 421101584,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707762658
    },
    {
        "content": "<p>I think in Lean 3, using <code>@[inline]</code> allowed Lean to unfold definitions to see that their arguments were not used for computation</p>",
        "id": 421101690,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707762690
    },
    {
        "content": "<p>I thought there was a discussion a while ago about how computability shouldn't rely on these optimization annotations, but I don't know whether anything came of it.</p>",
        "id": 421101836,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707762728
    },
    {
        "content": "<p>(also, I have had to mark various definitions <code>noinline</code> and <code>nospecialize</code> at places to prevent Lean's optimizations from taking 30 seconds during compilation for a single def...)</p>",
        "id": 421102001,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707762785
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span></p>",
        "id": 421102027,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707762795
    },
    {
        "content": "<p>It seems <a href=\"#narrow/stream/270676-lean4/topic/noncomputable.20checker.20is.20too.20pesimistic\">here</a> the suggestion was <code>macro_inline</code>, I'm not sure that is a viable hack in this case</p>",
        "id": 421102278,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707762861
    },
    {
        "content": "<p>sorry, the best we have currently is <code>Erased</code></p>",
        "id": 421102364,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707762892
    },
    {
        "content": "<p>this is a known compiler issue but there isn't work on it these days</p>",
        "id": 421102440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707762916
    },
    {
        "content": "<p>using <code>inline</code> should help, assuming you can define the functions in terms of functions which do not take the erased values as arguments</p>",
        "id": 421102965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707763068
    },
    {
        "content": "<p>I could also put <code>PropFun</code> in Prop, since it is never intended for computation anyways...</p>",
        "id": 421105360,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707763761
    },
    {
        "content": "<p>what is it?</p>",
        "id": 421105416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707763779
    },
    {
        "content": "<p>certainly that will help</p>",
        "id": 421105435,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707763787
    },
    {
        "content": "<p>It is the inductive propositional formulas quotiented by equivalence</p>",
        "id": 421105819,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707763883
    },
    {
        "content": "<p>...</p>",
        "id": 421105877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707763899
    },
    {
        "content": "<p>that's explicitly computational</p>",
        "id": 421105938,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707763919
    },
    {
        "content": "<p>It's definitely computable, yes, it just shouldn't be used in computation. The reason I am marking things <code>noncomputable</code> here is for performance, because Lean is insisting on building very large lean objects that are never used in the computations.</p>",
        "id": 421106144,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707763980
    },
    {
        "content": "<p>have you looked at the IR? I can't see how lean could omit this if it wanted to</p>",
        "id": 421106258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707764013
    },
    {
        "content": "<p>Because <code>P</code> is an argument to these functions and Lean doesn't know that it should be erasing <code>P</code>?</p>",
        "id": 421106517,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707764091
    },
    {
        "content": "<p>I haven't looked at the IR, but I am guessing it is what we expect</p>",
        "id": 421106568,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707764110
    },
    {
        "content": "<p>to get erasure, you will have best results if all your erased indices are types and proofs</p>",
        "id": 421106985,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707764256
    },
    {
        "content": "<p>And that includes the index of <code>VEncCNF</code></p>",
        "id": 421107344,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707764375
    },
    {
        "content": "<p>The <code>Fintype</code> issue is pretty easy to solve, just use <code>Finite</code> instead</p>",
        "id": 421107395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707764397
    },
    {
        "content": "<p>got it :)</p>",
        "id": 421107541,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707764428
    },
    {
        "content": "<p>Could <code>PropFun ν</code> be defined as just e.g. <code>(ν -&gt; Prop) -&gt; Prop</code>? I realize that's not necessarily finitely supported but <code>encodesProp</code> should imply that it is</p>",
        "id": 421107874,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707764544
    },
    {
        "content": "<p>Hm, that’s definitely an idea. Since I have the <code>Fintype</code> argument there anyways. Will try it out</p>",
        "id": 421110068,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707765356
    }
]