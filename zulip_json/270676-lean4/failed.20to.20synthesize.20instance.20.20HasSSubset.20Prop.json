[
    {
        "content": "<p>This is the error I got in the definition of <code>only</code> when I tried to explore the automatic coercion from Prop to Set. What can be an alternative?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">people</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">live_in_dreadbury</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">people</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">live_in_dreadbury</span> <span class=\"n\">a</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">only</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">y</span> <span class=\"bp\">⊂</span>  <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">only</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 426009571,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1710191601
    },
    {
        "content": "<p>IIRC, in mathlib <code>Set x</code> is <em>defined</em> to be <code>x -&gt; Prop</code>, so the first <code>#check</code> involves no coercion - note that <code>R : x -&gt; Prop</code> is not itself a <code>Prop</code>, so there is no conversion from <code>Prop</code> to <code>Set</code> involved.<br>\nIf you replaced it with <code>#check fun (a : x) =&gt; (R a : Set x)</code> you would probably get an error.</p>\n<p>In the definition of <code>only</code> you have written <code>P y ⊂ P x</code> in a context where <code>P y</code> and <code>P x</code> are of type <code>Prop</code> (<strong>not</strong> <code>x -&gt; Prop</code> this time). There is no coercion from <code>Prop</code> to <code>Set x</code>.<br>\nThis notation is syntactic sugar, which is expanded using a typeclass, <code>HasSSubset</code> in this case.<br>\nIf someone had written an 'instance' of this typeclass for <code>Prop</code>, then Lean would interpret <code>P x ⊂ P y</code> as whatever that instance said. Since nobody has (and nobody should), you get the error you see.</p>",
        "id": 426027140,
        "sender_full_name": "Raghuram",
        "timestamp": 1710199601
    },
    {
        "content": "<p>As for an alternative, it's not clear to me what you want <code>only</code> to be.<br>\nThe condition looks like <code>only P</code> would require <code>P a</code> to hold for all <code>a : x</code> --- which already determines <code>P</code> uniquely (e.g., by <code>Set.ext</code>).</p>",
        "id": 426027504,
        "sender_full_name": "Raghuram",
        "timestamp": 1710199842
    },
    {
        "content": "<p>Are you trying to define the property of a predicate being satisfied by a unique element? That can be defined as follows (and is probably in Mathlib under some other name).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">isOnlyElement</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">b</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 426027826,
        "sender_full_name": "Raghuram",
        "timestamp": 1710200049
    },
    {
        "content": "<p>I appreciate your attention to my question. Indeed, after reading more carefully <a href=\"https://leanprover-community.github.io/mathematics_in_lean/C04_Sets_and_Functions.html#functions\">Mathematics in Lean</a>, I understand that <code>R : Set α</code> by definition is <code>R: α → Prop</code>.  But I didn't pay attention to <code>R (a : α)</code> meaning <code>a ∈ R</code>. If I want to say <code>A ⊂ B</code>, that means  I have two functions <code>A : α → Prop</code> and <code>B: α → Prop</code> such that  <code>∀ a, A a → B a</code>.</p>\n<p>The example came from a text on formal semantics for the natural language sentence:</p>\n<blockquote>\n<p>they are the only people who live therein. </p>\n</blockquote>\n<p>The presentation is confusing and I was trying to convert to Lean! It seems not a resonable formalization after all. </p>\n<blockquote>\n<p>[[people who live therein]] would be a property of sets of people living in Dreadbury<br>\n\\X -&gt; people(X) &amp; live_in_Dreadbury(X)</p>\n<p>and [[only]] would be a property modifier</p>\n<p>\\P \\X -&gt; P(X) &amp; forall Y: P(Y) =&gt; Y &lt; X</p>\n<p>(where Y &lt; X means that Y is a part of X)</p>\n<p>Putting them together, [[only people who live therein]] is</p>\n<p>\\X -&gt; people(X) &amp; live_in_Dreadbury(X) &amp; forall Y: (people(Y) &amp; live_in_Dreadbury(Y)) =&gt; Y &lt; X</p>\n<p>In words, this holds of X iff X is the maximal set of people living in Dreadbury.</p>\n</blockquote>",
        "id": 426038259,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1710207398
    },
    {
        "content": "<p>Continuing my goal to formalize plurals from natural language, I need a way to lift a predicate from an element to a set of elements.  My problem is that <code>live₁</code> and <code>live₂</code> below should be equal by definition. Why can't I finish the proof of the example with reflection? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">live</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">live₁</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">live₂</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">plur</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">live</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">plur</span> <span class=\"n\">live</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">u</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">plur</span> <span class=\"n\">live</span><span class=\"o\">)</span> <span class=\"n\">a</span>\n<span class=\"k\">#check</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">u</span><span class=\"o\">),</span> <span class=\"n\">live</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">live₁</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">live₂</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n <span class=\"n\">intro</span> <span class=\"n\">h</span>\n <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>The error I got is </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">HEq.rfl</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">HEq</span> <span class=\"bp\">?</span><span class=\"n\">m.229</span> <span class=\"bp\">?</span><span class=\"n\">m.229</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">live₁</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">live₂</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>",
        "id": 427692185,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1710854345
    },
    {
        "content": "<p><code>live₁</code> and <code>live₂</code> are two different predicates on sets, so there's no reason they need to be equal</p>",
        "id": 427813305,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710883121
    },
    {
        "content": "<p>I'm ashamed of my previous message... for some reason, my mind fixed a crazy interpretation of the code. Your message made me wake up... sorry for the question... hahaha</p>\n<p>Indeed, nothing tells me that the two properties with the same signature need to be equal -- even considering that all elements of a given type have the same value for the properties. Actually,  I was just trying to validate that a type for live1 also works for live2 (same signature). This can be verified with the simple #check below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">live₁</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">live₂</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 427926370,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1710940961
    }
]