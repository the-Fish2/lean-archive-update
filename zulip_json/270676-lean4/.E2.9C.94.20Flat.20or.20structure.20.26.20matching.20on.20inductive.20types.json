[
    {
        "content": "<p>As an introduction to/exercise in lean 4, I'm trying to make a flattened or. I have a few questions that feel like misunderstandings from my side, so I hope someone can clarify them for me. This is the definition I have so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">FlatOr</span> <span class=\"o\">(</span><span class=\"n\">ps</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">ps.length</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">ps.get</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">FlatOr</span> <span class=\"n\">ps</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FlatOr.ofOr</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">âˆ¨</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">FlatOr</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Or.inl</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">FlatOr.intro</span> <span class=\"o\">(</span><span class=\"n\">Fin.mk</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">))</span> <span class=\"n\">h</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Or.inr</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">FlatOr.intro</span> <span class=\"o\">(</span><span class=\"n\">Fin.mk</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">))</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>I started with a structure, but that gave me an error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">FlatOr</span> <span class=\"o\">(</span><span class=\"n\">ps</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">ps.length</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">ps.get</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"c1\">-- Error: (kernel) failed to generate projection 'FlatOr.i' for 'FlatOr', type is an inductive predicate, but field is not a proposition</span>\n</code></pre></div>\n<p>The inductive version works as far as I can see, so is this just a limitation I missed in the documentation or is something else the problem?</p>\n<p>Now my <code>ofOr</code> definition does not fully flatten the expression in the case of nested ors, so I figured, lets first start with trying to find an index into the FlatOr datastructure where there's an Or that can still be split. I wrote the following initial attempt:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">findNonFlat</span> <span class=\"o\">(</span><span class=\"n\">ps</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">ps</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">List.nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"n\">List.cons</span> <span class=\"n\">p</span> <span class=\"n\">ps</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">match</span> <span class=\"n\">p</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Or</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Unfortunately at the <code>Or</code> match the following error occurs:  \"invalid pattern, constructor or constant marked with '[match_pattern]' expected\". I guess it's not allowed to match only on type definitions? Is it somehow misguided to look for Or's in a list of Props like this, or do I simply have to do it a different way?</p>",
        "id": 420612630,
        "sender_full_name": "Bob Rubbens",
        "timestamp": 1707470392
    },
    {
        "content": "<p>You can't ask if a <code>Prop</code> is an Or, because to Lean <code>A \\or A = A</code></p>",
        "id": 420615214,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707471444
    },
    {
        "content": "<p>What you can ask is whether an <code>Expr</code>, or better, a <code>Q(Prop)</code>, is an <code>Or</code></p>",
        "id": 420615304,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707471478
    },
    {
        "content": "<p>Another option is to use type class search to perform the expression matching, by having an <code>[IsOr P Po] [IsOr Q Qo] : IsOr (P \\or Q) (Po ++ Qo)</code> instance do the work</p>",
        "id": 420615636,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707471603
    },
    {
        "content": "<p>Here, <code>IsOr P Po</code> would be a type class with a field <code>iff_flat : P \\iff FlatOr Po</code></p>",
        "id": 420615989,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707471725
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Flat.20or.20structure.20.26.20matching.20on.20inductive.20types/near/420615304\">said</a>:</p>\n<blockquote>\n<p>What you can ask is whether an <code>Expr</code>, or better, a <code>Q(Prop)</code>, is an <code>Or</code></p>\n</blockquote>\n<p>Okay, do I understand correctly that this flattening operation would then have to take place in tactic mode? It does not really make sense to transform Exprs outside of tactic mode, right?</p>",
        "id": 420616108,
        "sender_full_name": "Bob Rubbens",
        "timestamp": 1707471778
    },
    {
        "content": "<p>That would be okay, I think, but I was hoping to do some plain transformations in plain lean first</p>",
        "id": 420616157,
        "sender_full_name": "Bob Rubbens",
        "timestamp": 1707471806
    },
    {
        "content": "<p>It needs to happen during elaboration rather than within the lean type theory; tactics are overkill here, a term elaborator is sufficient. The typeclass approach I outline above takes advantage of some existing elaborator machinery to save you having to write a custom elaborator</p>",
        "id": 420619456,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707473033
    },
    {
        "content": "<p>That gives me plenty of material to read and terms to search for. Thank you very much!</p>",
        "id": 420624216,
        "sender_full_name": "Bob Rubbens",
        "timestamp": 1707474756
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"381694\">Bob Rubbens</span> has marked this topic as resolved.</p>",
        "id": 420625049,
        "sender_full_name": "Notification Bot",
        "timestamp": 1707475054
    }
]