[
    {
        "content": "<p>Hi, I'm getting a type mismatch error when trying to prove a theorem using proof terms:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n\n<span class=\"bp\">-</span><span class=\"w\">   </span><span class=\"n\">isRightAdjoint_of_preservesLimits_of_solutionSetCondition</span><span class=\"w\"> </span><span class=\"n\">fib_functor</span><span class=\"w\"> </span><span class=\"n\">fib_solset</span>\n\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">fib_functor</span><span class=\"bp\">.</span><span class=\"n\">IsRightAdjoint</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">fib_functor</span><span class=\"bp\">.</span><span class=\"n\">IsRightAdjoint</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>A similar issue arises in tactic mode, as such:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">apply'</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">unify</span>\n<span class=\"w\">  </span><span class=\"n\">fib_functor</span><span class=\"bp\">.</span><span class=\"n\">IsRightAdjoint</span>\n<span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"n\">fib_functor</span><span class=\"bp\">.</span><span class=\"n\">IsRightAdjoint</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">fib_functor</span><span class=\"bp\">.</span><span class=\"n\">IsRightAdjoint</span>\n</code></pre></div>\n<p>I also compared the on-hover information from both terms, and they are also identical:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- @Functor.IsRightAdjoint ℕ instCategoryNat_fibFunctor ℕ instCategoryNat_fibFunctor fib_functor : Prop</span>\n<span class=\"c1\">-- @Functor.IsRightAdjoint ℕ instCategoryNat_fibFunctor ℕ instCategoryNat_fibFunctor fib_functor : Prop</span>\n</code></pre></div>\n<p>So, I don't quite know what to do. I know that IsRightFunctor can also be used (/is meant to be used?) as a typeclass, but proving that is harder because I would have to provide an actual left adjoint vs proving existence using the adjoint functor theorem (the math is probably not super relevant here).</p>",
        "id": 444841469,
        "sender_full_name": "Aren Güralp",
        "timestamp": 1718439534
    },
    {
        "content": "<p>Hi is there any <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> for this?</p>",
        "id": 444844738,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1718442484
    },
    {
        "content": "<p>You might try <code>set_option pp.all true</code>. It will be ugly, but hopefully you will be able to see a difference.</p>",
        "id": 444845718,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1718443361
    },
    {
        "content": "<p>Here is a MWE, with the comment at the end being the types I'm now seeing.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PLift</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">dvd_refl</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">⟩⟩</span>\n<span class=\"w\">  </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">dvd_trans</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"bp\">⟩⟩</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fib_functor</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">fib</span>\n<span class=\"w\">  </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">fib_dvd</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"bp\">⟩⟩</span>\n<span class=\"w\">    </span><span class=\"c1\">-- TODO: prove fib_dvd yourself</span>\n<span class=\"w\">  </span><span class=\"n\">map_id</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">map_comp</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">HasLimitsOfSize</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">has_limits_of_shape</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">PreservesLimitsOfSize</span><span class=\"w\"> </span><span class=\"n\">fib_functor</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">preservesLimitsOfShape</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">nat_has_limits</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">HasLimits</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">fib_solset</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SolutionSetCondition</span><span class=\"w\"> </span><span class=\"n\">fib_functor</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">fib_has_left_adjoint</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">IsRightAdjoint</span><span class=\"w\"> </span><span class=\"n\">fib_functor</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">isRightAdjoint_of_preservesLimits_of_solutionSetCondition</span><span class=\"w\"> </span><span class=\"n\">fib_functor</span><span class=\"w\"> </span><span class=\"n\">fib_solset</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  @CategoryTheory.Functor.IsRightAdjoint.{?u.2263, ?u.2263, 0, 0} Nat</span>\n<span class=\"cm\">    CategoryTheory.instCategoryNat_fibFunctor.{?u.2263} Nat</span>\n<span class=\"cm\">    CategoryTheory.instCategoryNat_fibFunctor.{?u.2263}</span>\n<span class=\"cm\">    CategoryTheory.fib_functor.{?u.2263, ?u.2263} : Prop</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  @CategoryTheory.Functor.IsRightAdjoint.{u_1, u_2, 0, 0} Nat</span>\n<span class=\"cm\">    CategoryTheory.instCategoryNat_fibFunctor.{u_1} Nat</span>\n<span class=\"cm\">    CategoryTheory.instCategoryNat_fibFunctor.{u_2}</span>\n<span class=\"cm\">    CategoryTheory.fib_functor.{u_2, u_1} : Prop</span>\n<span class=\"cm\">    --/</span>\n</code></pre></div>\n<p>It seems it has some issue with the type universes- the term has a type that takes in a single universe and passes it into IsRightAdjoint (?u.2263) implicitly while the expected type seems to take in more than one type of universe (u_1, u_2). However, I'm still not sure how to fix this- the left adjoint in question would be Nat =&gt; Nat so it would be fine if the IsRightAdjoint prop assumed the universes were the same.</p>",
        "id": 444847433,
        "sender_full_name": "Aren Güralp",
        "timestamp": 1718444811
    },
    {
        "content": "<p>If you supply the universes explicitly then the problem goes away:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PLift</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">dvd_refl</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">⟩⟩</span>\n<span class=\"w\">  </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">dvd_trans</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"bp\">⟩⟩</span>\n\n<span class=\"bp\">...</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">fib_has_left_adjoint</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">IsRightAdjoint</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">fib_functor</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">isRightAdjoint_of_preservesLimits_of_solutionSetCondition</span><span class=\"w\"> </span><span class=\"n\">fib_functor</span><span class=\"w\"> </span><span class=\"n\">fib_solset</span>\n</code></pre></div>\n<p>(or at least I think it does; I'm on 4.9.0-rc1 which is a bit random)</p>",
        "id": 444848926,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1718445912
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/type.20mismatch.20with.20identical.20types.20-.20no.20pattern.20matching/near/444848926\">said</a>:</p>\n<blockquote>\n<p>If you supply the universes explicitly then the problem goes away</p>\n</blockquote>\n<p>This solves the problem, thank you!</p>",
        "id": 444852626,
        "sender_full_name": "Aren Güralp",
        "timestamp": 1718448482
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"638825\">Aren Güralp</span> has marked this topic as resolved.</p>",
        "id": 444852809,
        "sender_full_name": "Notification Bot",
        "timestamp": 1718448583
    },
    {
        "content": "<p>There's still an underlying question about why you have to do this, but as long as you're happy :-)</p>",
        "id": 444852897,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1718448614
    },
    {
        "content": "<p>The problem still goes away if I don't supply the universe to the Category instantiation of Nat-  I think what's happening is that <br>\n(1) lean correctly infers that fib_functor is Nat =&gt; Nat (and thus the proof term is correct in that it is compatible with the anonymous universe that Nat lives in) <br>\nbut <br>\n(2) IsRightAdjoint is defined in Mathlib such that the source and target category might live in different universes, and so it expects a proof term with arbitrary u_1 and u_2. </p>\n<p>Does this seem correct?</p>",
        "id": 444853908,
        "sender_full_name": "Aren Güralp",
        "timestamp": 1718449495
    },
    {
        "content": "<p>Yes, but if lean is happy to have u_1 and u_2 arbitrary in the lemma, why doesn't it decide to make them both <code>u</code>?</p>",
        "id": 444855557,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1718451039
    },
    {
        "content": "<p>I think I need to prove the lemma with u_1 and u_2 arbitrary, but fib_functor is defined on a particular Nat so the term I'm using in the proof bakes in that u_1 = u_2.</p>",
        "id": 444857785,
        "sender_full_name": "Aren Güralp",
        "timestamp": 1718453212
    }
]