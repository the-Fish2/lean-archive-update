[
    {
        "content": "<p>I want to complete a proof that for any function of three variables f : α × β × γ → δ, there is a function of a single variable f' : α → β → γ → δ that does the same thing, satisfying (((f' a) b) g) = f ⟨a,b,g⟩ for all a,b,g of types α,  β,  γ. This feels like it should be straightforward.</p>\n<p>I can define the function I want, or I think I can:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">witness</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">g</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>with that and some <code>intro</code>s and an invocation of <code>exists</code>, lean tells me my goal is to prove that <code>witness a b g = f (a, b, g)</code>.  witness exists in the context like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">witness</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Should I be able to use this in a rewrite somehow? What's going wrong? How do I apply the definition of witness?</p>",
        "id": 418251065,
        "sender_full_name": "Michael",
        "timestamp": 1706265979
    },
    {
        "content": "<p>Can you put in the full code that is failing for you?</p>",
        "id": 418251632,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706266225
    },
    {
        "content": "<p>(<a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>)</p>",
        "id": 418251649,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706266232
    },
    {
        "content": "<p>I'm working inside a MIL installation, so for total completeness I'll include the file header:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Lattice</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Prime</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Parity</span>\n<span class=\"kn\">import</span> <span class=\"n\">MIL.Common</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">δ</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span> <span class=\"bp\">×</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">,</span>\n          <span class=\"bp\">∃</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">,</span>\n          <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">γ</span><span class=\"o\">,</span>\n          <span class=\"o\">(((</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">z</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">f</span>\n  <span class=\"k\">let</span> <span class=\"n\">f_prime</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">z</span><span class=\"o\">⟩))</span>\n  <span class=\"n\">exists</span> <span class=\"n\">f_prime</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span>\n  <span class=\"c1\">-- where do I go from here?</span>\n  <span class=\"n\">done</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 418252116,
        "sender_full_name": "Michael",
        "timestamp": 1706266450
    },
    {
        "content": "<p><code>rfl</code> will close it! it's true by definition. if you want to unfold the let you can use <code>unfold_let(s) f_prime</code> or <code>simp only [f_prime]</code></p>",
        "id": 418252223,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706266511
    },
    {
        "content": "<p>Thanks!</p>\n<p>I feel that <code>rfl</code> is doing some work behind the scenes there that I'd like to know how to do manually. Can I manipulate this into a state where it tells me my goal is <code>f (x, y, z) = f (x, y, z)</code>?</p>",
        "id": 418252876,
        "sender_full_name": "Michael",
        "timestamp": 1706266796
    },
    {
        "content": "<p>Do the <code>unfold_let</code> or <code>simp</code> calls I mentioned above work? This is a specific rule of equality called zeta-reduction.</p>",
        "id": 418253534,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706267035
    },
    {
        "content": "<ol>\n<li><code>simp only [f_prime]</code> closes the goal, just like <code>rfl</code></li>\n<li><code>unfold_lets f_prime</code> complains that <code>unfold_lets</code> is an unknown tactic</li>\n<li><code>unfold_let f_prime</code> sets the goal to <code>(fun x y z =&gt; f (x, y, z)) x y z = f (x, y, z)</code>, which is a painfully obvious thing to have to prove, but hasn't quite gotten all the way to <code>f (x, y, z) = f (x, y, z)</code></li>\n</ol>",
        "id": 418254256,
        "sender_full_name": "Michael",
        "timestamp": 1706267324
    },
    {
        "content": "<p>I'm surprised the first one closes the goal! <code>simp</code> clearly did not obey the <code>only</code>... </p>\n<p>For the second two (sorry, I forgot whether there was an <code>s</code> on the tactic or not): what you then need to do is called eta-reduction. Again, there is a tactic for this somewhere if you want to have control about it, but in most real-life cases you'll use <code>simp</code> and it will eta reduce most things that you can. The correct tactic is <code>eta_reduce</code> in this case.</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Tactic/DefEqTransformations.lean\">here</a> are some tactics that do the same sorts of things</p>",
        "id": 418255649,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706267809
    },
    {
        "content": "<p>Thanks again!</p>",
        "id": 418255868,
        "sender_full_name": "Michael",
        "timestamp": 1706267903
    },
    {
        "content": "<p>If you use <code>set</code> rather than <code>let </code>, you can have it create a hypothesis that you can rewrite with</p>",
        "id": 418258165,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706268837
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/270676-lean4/topic/applying.20a.20function.20definition.20inside.20a.20proof/near/418255649\">said</a>:</p>\n<blockquote>\n<p>I'm surprised the first one closes the goal! <code>simp</code> clearly did not obey the <code>only</code>... </p>\n</blockquote>\n<p>Currently, <code>simp</code> unfolds local definitions unconditionally. See <a href=\"https://github.com/leanprover/lean4/pull/2682\">lean4#2682</a> for a discussion.</p>",
        "id": 418322156,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706290908
    }
]