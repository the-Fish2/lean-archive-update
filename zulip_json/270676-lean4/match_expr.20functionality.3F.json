[
    {
        "content": "<p>I was curious if there are any plans to extend the functionality of <code>match_expr</code>, or if its intended scope is specifically simple <code>.app</code> and <code>.const</code> matches.</p>\n<p>I tried replacing <code>Qq</code> matches in Mathlib with <code>match_expr</code>, and found that almost none of them could be replaced. Some necessary features simply weren't available, whereas some matches couldn't be replaced without making the code verbose and difficult to read. (Readability and brevity is especially important for maintainability here, of course, since the regions of code that require matching against expressions are often already verbose and relatively esoteric.)</p>\n<p>I'm not insisting that the scope be expanded if this is the intended scope, necessarily—I'm just curious as to what its intended role is and where it's going. :)</p>\n<p>If it's of interest, here are the issues I encountered.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<ul>\n<li>Inability to match against or bind universes</li>\n<li>Inability to match against nested <code>.app</code>s, leading to less-readable nested <code>match_expr</code>s with duplicated <code>_ =&gt;</code> branches</li>\n<li>Inability to match against multiple <code>Expr</code>s simultaneously (e.g. <code>match_expr a, b with | foo e, bar f =&gt; ...</code>), unlike <code>match</code>, leading to nested <code>match_expr</code>s and duplicated branches</li>\n<li>distinction from <code>match</code> means that you can't simultaneously match against some other non-<code>Expr</code> value (e.g. a <code>Level</code>, or a structure which contains an <code>Expr</code>) at the same time, leading to nested/interleaved <code>match</code>/<code>match_expr</code>s, often with duplicated <code>_ =&gt;</code> branches</li>\n<li>Matching only against the head means that we can't match on arguments—e.g. we'd like write something kind of like <code>match_expr e with | Eq Nat a b =&gt; ...</code> which only matched <code>Nat</code> equalities, but <code>Nat</code> is necessarily a variable name here (contrast with <code>match</code>). This likewise contributes to nested <code>match_expr</code>s or more verbose checks.</li>\n<li>Inability to use notation, meaning that matching against things like <code>+</code> (or worse) quickly becomes verbose and difficult to read (and would be even more difficult if nested matches were allowed)</li>\n<li>incompatibility with <code>Qq</code> while matching: one can't add Qq type annotations to the matched-against identifiers in the match itself, meaning that you need a string of <code>let a : Q(X) := a</code>'s in the body of each alt to use Qq, rendering it frequently impractical. (<code>Qq</code> is often necessary to legibly construct expressions, so abandoning it becomes impractical.)</li>\n</ul>\n<p>(Interestingly, inability to match against anything but constants and applications didn't actually come up.)</p>\n</div></div>",
        "id": 431706232,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1712438238
    },
    {
        "content": "<p>I think there's a more crucial gap there, which is  \"no defeq matching\", which is crucial for matching against <code>a + b</code></p>",
        "id": 431707052,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712439037
    },
    {
        "content": "<p>My main wish for <code>match_expr</code> would be for it to be generalized to extensible <code>match</code> handlers; <code>match_expr</code> could then be <code>match e with ~e(Nat.add $x $y) =&gt;</code>, and <code>Qq</code> could hook into the same machinery. A wide class of bugs in Qq (<code>return</code>, <code>continue</code>, <code>let mut</code> not working with it) are due to it being a second-class citizen that is not permitted to take part in the <code>do</code> control-flow rewriting</p>",
        "id": 431707157,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712439170
    },
    {
        "content": "<p>(Of course, <code>match_expr</code> is still great, and the choice to make it different syntax to <code>match</code> meant that it landed much more quickly than designing such an extension mechanism, leaving plenty of time to unify things the \"right\" way later)</p>",
        "id": 431707276,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712439329
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/match_expr.20functionality.3F/near/431707052\">said</a>:</p>\n<blockquote>\n<p>I think there's a more crucial gap there, which is  \"no defeq matching\", which is crucial for matching against <code>a + b</code></p>\n</blockquote>\n<p>I'm not 100% certain on this but as I understand <code>match_expr</code> is supposed to be a light weight tooling that does not call into potentially expensive things like <code>isDefEq</code>.</p>\n<p>Maybe <span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span>  can explain his vision for <code>match_expr</code>?</p>",
        "id": 431707292,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1712439354
    },
    {
        "content": "<p>To be clear, my point there was to say why match_expr is not a substitute for Qq; it certainly has a niche</p>",
        "id": 431707353,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712439381
    },
    {
        "content": "<p>And I think that niche is well-aligned with not supporting nested expressions or typeclass-based notation, as those are both places where using <code>whnfR</code> before matching isn't enough</p>",
        "id": 431707392,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712439428
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/match_expr.20functionality.3F/near/431707052\">said</a>:</p>\n<blockquote>\n<p>I think there's a more crucial gap there, which is  \"no defeq matching\", which is crucial for matching against <code>a + b</code></p>\n</blockquote>\n<p>True! It would be great to have a way to support defeq matching somehow, as it is not infrequently crucial, but I will note that many <code>Qq</code> matches in Mathlib did not seem to need defeq matching, and were blocked only by the other issues.</p>",
        "id": 431707433,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1712439460
    },
    {
        "content": "<p>Mathlib used to be full of defeq-matching mistakes, but it was hard to tell as an end-user; I fixed many of these in <a href=\"https://github.com/leanprover-community/mathlib/pull/18129\">!3#18129</a></p>",
        "id": 431707491,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712439496
    },
    {
        "content": "<p>Yeah, it is also possible that the defeq matching is actually crucial in most <code>~q</code> matches despite how it seemed on first glance...</p>",
        "id": 431707573,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1712439597
    }
]