[
    {
        "content": "<p>Something strange happens when using an implicit parameter such as the definition of P below. It makes an <code>exact h</code> fail unexpectedly in a proof.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">):</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">},</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span>    <span class=\"c1\">-- if you change {m} to m, the issue goes away</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">SomeNumbers</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">True</span><span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">SomeNumbers</span><span class=\"o\">):</span> <span class=\"n\">P</span> <span class=\"n\">n.val</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">n.property</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">this</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"c1\">-- at this point the infoview says both `h` and the goal are of type `P n.val`</span>\n  <span class=\"c1\">-- exact h</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> doesn't work:</span>\n<span class=\"cm\">  type mismatch</span>\n<span class=\"cm\">  h</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  n.val = ?m.84 : Prop        -- this is part of the definition of P</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  P n.val : Prop</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">assumption</span>  <span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 439475819,
        "sender_full_name": "Ted Hwa",
        "timestamp": 1716162325
    },
    {
        "content": "<p>Based on the type mismatch error, it seems like it forgot about the <code>∀</code> part of the type in P.</p>",
        "id": 439475992,
        "sender_full_name": "Ted Hwa",
        "timestamp": 1716162496
    },
    {
        "content": "<p>This is precisely why mathlib uses semi-implicits here. In mathlib style, your definition would be <code>def P (n : Nat) : Prop := ∀ ⦃m⦄, n = m</code>. Well actually it would not because the semi-implicit can never be filled in. But, assuming this is an overminimisation on your part, here is an example where it's actually useful: <code>def P (n : Nat) : Prop := ∀ ⦃m⦄, n = m → m = n</code>.</p>",
        "id": 439510564,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1716187210
    },
    {
        "content": "<p>See eg <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Convex#doc\">docs#Convex</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Pairwise#doc\">docs#Set.Pairwise</a> for a typical use</p>",
        "id": 439510614,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1716187233
    },
    {
        "content": "<p>Rather than <code>exact h</code>, you can use <code>exact @h</code> to account for the implicit parameter.</p>\n<p>It's a bit surprising that it's being so aggressive in unfolding <code>SomeNumbers</code> to see that there's an implicit parameter. I'm not sure exactly how intentional that is, but it makes some sense because constants are elaborated is if they're 0-argument applications, and applications aggressively unfold values to see how many arguments there are.</p>",
        "id": 439604856,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1716221365
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"715872\">Ted Hwa</span> has marked this topic as resolved.</p>",
        "id": 439717663,
        "sender_full_name": "Notification Bot",
        "timestamp": 1716258453
    }
]