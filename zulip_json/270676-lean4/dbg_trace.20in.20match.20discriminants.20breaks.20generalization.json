[
    {
        "content": "<p>If I use <code>dbg_trace</code> in a match discriminant, then it blocks generalization:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">dbg_trace</span> <span class=\"s2\">\"oh no\"</span><span class=\"bp\">;</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>  <span class=\"c1\">-- type error, because the goal is still `Fin x` and not `Fin (_ + 1)`</span>\n</code></pre></div>\n<p>is this a reasonable thing to want? Is it remotely possible to fix?</p>",
        "id": 409352080,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703152663
    },
    {
        "content": "<p>I lean toward \"it's not a reasonable thing to want\"</p>",
        "id": 409353953,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703153268
    },
    {
        "content": "<p>this is kind of part of the challenge of working in dependent type theory, you can inspect the code that was written just prior and if you add additional code then the types can break</p>",
        "id": 409354267,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703153366
    },
    {
        "content": "<p>The context here is trying to confirm how many times<code>f</code> is evaluated in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 409360979,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703155574
    },
    {
        "content": "<p>you can use the <code>motive :=</code> argument of <code>match</code> to explicitly generalize</p>",
        "id": 409361083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703155617
    },
    {
        "content": "<p>(and the context for <em>that</em> is to try and work out if <a href=\"https://github.com/leanprover-community/quote4/pull/31\">quote4#31</a> introduces any double-evaluation bugs)</p>",
        "id": 409361120,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703155629
    },
    {
        "content": "<p>I would expect it to only evaluate <code>f</code> once there</p>",
        "id": 409361168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703155651
    },
    {
        "content": "<p>looking at the generated IR for the example confirms it is only evaluated once</p>",
        "id": 409361316,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703155698
    },
    {
        "content": "<p>How hard would it be to implement <code>match?</code> that tells me the motive that was found automatically?</p>",
        "id": 409361322,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703155700
    },
    {
        "content": "<p>possible?</p>",
        "id": 409361425,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703155739
    },
    {
        "content": "<p>there is a lot of stuff going on in <code>match</code> though, you might have to do a lot of copy paste</p>",
        "id": 409361515,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703155768
    },
    {
        "content": "<p>Presumably it would be much easier to implement in core, which already has all the info?</p>",
        "id": 409361580,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703155794
    },
    {
        "content": "<p>you could also do it as a code action</p>",
        "id": 409361678,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703155813
    },
    {
        "content": "<p>might be nice to have \"insert type\" code actions in more places generally</p>",
        "id": 409361793,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703155857
    },
    {
        "content": "<p>in fact \"insert value of underscore\" would cover a pretty wide variety of insertion tasks</p>",
        "id": 409362001,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703155930
    },
    {
        "content": "<p>unfortunately using <code>match (motive := _)</code> doesn't work</p>",
        "id": 409362102,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703155969
    }
]