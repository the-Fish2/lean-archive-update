[
    {
        "content": "<p>Perhaps a contrived example, but the pretty printer struggles here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.debug</span> <span class=\"n\">true</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.rawOnError</span> <span class=\"n\">true</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">MetaM</span> <span class=\"n\">_</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n  <span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">debug</span><span class=\"o\">]</span> <span class=\"s2\">\"{← `(`($$x + 1))}\"</span>\n</code></pre></div>\n<p>which gives the output</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">debug</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Error</span> <span class=\"n\">pretty</span> <span class=\"n\">printing</span> <span class=\"n\">syntax</span><span class=\"o\">:</span> <span class=\"n\">unknown</span> <span class=\"kd\">constant</span> <span class=\"bp\">'</span><span class=\"n\">term.pseudo.antiquot'.</span> <span class=\"n\">Falling</span> <span class=\"n\">back</span> <span class=\"n\">to</span> <span class=\"n\">raw</span> <span class=\"n\">printer.</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">Term.quot</span> <span class=\"s2\">\"`(\"</span> <span class=\"o\">(</span><span class=\"bp\">«</span><span class=\"n\">term_</span><span class=\"bp\">+</span><span class=\"n\">_</span><span class=\"bp\">»</span> <span class=\"o\">(</span><span class=\"n\">term.pseudo.antiquot</span> <span class=\"s2\">\"$\"</span> <span class=\"o\">[]</span> <span class=\"bp\">`</span><span class=\"n\">x._</span><span class=\"bp\">@.</span><span class=\"n\">Qq.test._hyg.1</span> <span class=\"o\">[])</span> <span class=\"s2\">\"+\"</span> <span class=\"o\">(</span><span class=\"n\">num</span> <span class=\"s2\">\"1\"</span><span class=\"o\">))</span> <span class=\"s2\">\")\"</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 421320135,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707856049
    },
    {
        "content": "<p>It's not clear to me where <code>term.pseudo.antiquot</code> comes from in the first place, or how to teach the pretty printer how to print it</p>",
        "id": 421322486,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707857068
    },
    {
        "content": "<p><code> `(`($$x + 1))</code> evaluates to <code> `($x + 1)</code>, and the <code>term.pseudo.antiquot</code> node refers to <code>$x</code>. I'm not sure what the state of pretty printing antiquotations is, whether it's supposed to work or if it's not implemented.</p>",
        "id": 421332100,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707861421
    },
    {
        "content": "<p>What does <code>pseudo</code> refer to here?</p>",
        "id": 421332197,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707861480
    },
    {
        "content": "<p>There are two constructors for antiquotes, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Syntax.mkAntiquotNode#doc\">docs#Lean.Syntax.mkAntiquotNode</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parser.mkAntiquot#doc\">docs#Lean.Parser.mkAntiquot</a>, and the second mentions that pseudo indicates that the kind isn't checked in <code>match</code> expression patterns (but I'm not completely sure)</p>",
        "id": 421333026,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707861853
    },
    {
        "content": "<p>I guess don't really understand what \"checked\" means here</p>",
        "id": 421333657,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707862134
    },
    {
        "content": "<p>If you had the pattern <code>$x:ident + 1</code>, then it would want to check that <code>x</code> is referring to some syntax of kind <code>ident</code>, but in <code>$x + 1</code> it doesn't care what syntax kind that <code>x</code> has. (\"It\" being \"what the <code>match</code> expression compiles to\".)</p>",
        "id": 421334110,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707862391
    },
    {
        "content": "<p>There's a separate elaborator for <code>match</code> expressions for syntax patterns in Lean.Elab.Quotation, and it looks like <code>pseudo</code> controls whether to insert <code>Syntax.isOfKind</code> checks.</p>",
        "id": 421334807,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707862717
    },
    {
        "content": "<p>Ah, that helps a bit; in that case, this is a second pretty-printer failure (now about <code>ident.antiquot</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">MetaM</span> <span class=\"n\">_</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n  <span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">debug</span><span class=\"o\">]</span> <span class=\"s2\">\"{← `(`($$x:ident + 1))}\"</span>\n</code></pre></div>",
        "id": 421339098,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707865007
    },
    {
        "content": "<p>So maybe <code>antiquot</code> printing is not implemented at all, which would explain why I couldn't find it</p>",
        "id": 421339266,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707865085
    }
]