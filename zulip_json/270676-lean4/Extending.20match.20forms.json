[
    {
        "content": "<p>Hi yall!! Been playing aroud more with Lean and metaprogramming, and I've been trying recently to \"extend\" match with custom behaviours.</p>\n<p>My situation is , that I have a opaque type that contains external data in C and can't be matched on. <br>\nNow I have a function to convert this opaque type into a lean representation, but most of my API calls use the opaque type directly.</p>\n<p>To provide an ergonomic interface for the user, I'd like to make it such that the user can write code that matches on values of this type, but implicitly things are converted to the lean representation automatically (this I guess is kinda like how Int is handled in Lean, but for my custom type).</p>\n<p>I've manageed to kinda get it working by defining my own elab rules for match, which will try to infer the type of the discriminant, and insert the conversion function automatically:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">Symbol</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Repr</span> <span class=\"bp\">|</span> <span class=\"bp\">...</span>\n<span class=\"n\">opaque</span> <span class=\"n\">Symbol.Repr</span> <span class=\"o\">:</span> <span class=\"n\">Symbol</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Repr</span>\n\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"bp\">|</span> <span class=\"k\">match</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"k\">with</span> <span class=\"bp\">$</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">matchAlts</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n   <span class=\"k\">let</span> <span class=\"n\">x_stx</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Term.elabTerm</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Symbol</span><span class=\"o\">))</span>\n   <span class=\"k\">let</span> <span class=\"n\">ty</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Meta.inferType</span> <span class=\"n\">x_stx</span>\n   <span class=\"k\">let</span> <span class=\"n\">is_sym</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Meta.isDefEq</span> <span class=\"n\">ty</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Symbol</span><span class=\"o\">)</span>\n   <span class=\"k\">if</span> <span class=\"n\">not</span> <span class=\"n\">is_sym</span> <span class=\"k\">then</span> <span class=\"n\">throwUnsupportedSyntax</span>\n   <span class=\"n\">Term.elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">&lt;-</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"bp\">|</span> <span class=\"k\">match</span> <span class=\"n\">Symbol.repr</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"k\">with</span> <span class=\"bp\">$</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">matchAlts</span><span class=\"o\">))</span> <span class=\"n\">none</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Symbol</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n <span class=\"bp\">|</span> <span class=\"n\">Repr.Infimum</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n <span class=\"bp\">|</span> <span class=\"n\">Repr.Supremum</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n <span class=\"bp\">|</span> <span class=\"n\">Repr.Function</span> <span class=\"n\">name</span> <span class=\"n\">args</span> <span class=\"n\">positive</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n <span class=\"bp\">|</span> <span class=\"n\">Repr.String</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n <span class=\"bp\">|</span> <span class=\"n\">Repr.Number</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>I found this super nifty, but also seemed like a little bit of a hack.</p>\n<p>As such, I'd like to ask the lean developers, what would be the idiomatic way of doing this?</p>",
        "id": 436212465,
        "sender_full_name": "Kiran",
        "timestamp": 1714462434
    },
    {
        "content": "<p>Is there a reason you don't want to write <code>match n.Repr with</code>?</p>",
        "id": 436218069,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714464649
    },
    {
        "content": "<p>Sure, that would work, but maybe out of academic curiousity, I'd like to try extending the match either way.</p>\n<p>I guess kinda like the same reason that Lean doesn't make it's users call <code>.repr</code> on its ints before matching on them, like ease of use</p>",
        "id": 436221227,
        "sender_full_name": "Kiran",
        "timestamp": 1714465847
    },
    {
        "content": "<p>I'm not sure how many examples there are of overriding <code>match</code> out there. The two that come to mind: (1) in core Lean, there's <code>match</code> syntax for matching against <code>Syntax</code> in <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Quotation.lean\">https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Quotation.lean</a> and (2) in Qq, there's <code>match</code> syntax for <code>~q(...)</code> patterns for <code>Expr</code> in <a href=\"https://github.com/leanprover-community/quote4/blob/master/Qq/Match.lean\">https://github.com/leanprover-community/quote4/blob/master/Qq/Match.lean</a></p>\n<p>Both of these completely take over <code>match</code> elaboration.</p>",
        "id": 436229567,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714468987
    },
    {
        "content": "<p>Ah, yep! I had seen quotation's approach, of overriding the match elaborator, but for some reason, when I try to use the annotation <code>@[builtin_term_elab ...]</code> it doesn't seem to work the same:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">builtin_term_elab</span> <span class=\"bp\">«</span><span class=\"k\">match</span><span class=\"bp\">»</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">elabMatchSyntax</span> <span class=\"o\">:</span> <span class=\"n\">Elab.Term.TermElab</span> <span class=\"o\">:=</span> <span class=\"n\">Term.adaptExpander</span> <span class=\"k\">fun</span> <span class=\"n\">_stx</span> <span class=\"n\">_oexpr</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">dbg_trace</span> <span class=\"s2\">\"running custom match {_stx}\"</span>\n  <span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span> <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n</code></pre></div>\n<p>Prints 'true' and nothing else.</p>",
        "id": 436235826,
        "sender_full_name": "Kiran",
        "timestamp": 1714471182
    },
    {
        "content": "<p>Anything with <code>builtin_</code> is for boostrapping issues in core -- there's <code>@[term_elab]</code> for user notations</p>",
        "id": 436236681,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714471493
    },
    {
        "content": "<p>Ahhh, awesome! Thanks I changed it, and now it works! So I overriding the elaborator is the best way of implementing this kind of functionality (most idiomatic way maybe?):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span>\n\n<span class=\"n\">opaque</span> <span class=\"n\">Symbol</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">SymbolRepr</span> <span class=\"n\">where</span> <span class=\"bp\">|</span> <span class=\"n\">Infinimum</span> <span class=\"bp\">|</span> <span class=\"n\">Supremum</span> <span class=\"bp\">|</span> <span class=\"n\">Number</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span>\n<span class=\"n\">opaque</span> <span class=\"n\">Symbol.repr</span> <span class=\"o\">:</span> <span class=\"n\">Symbol</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">SymbolRepr</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"bp\">«</span><span class=\"k\">match</span><span class=\"bp\">»</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">elabMatchSyntax</span> <span class=\"o\">:</span> <span class=\"n\">Elab.Term.TermElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_stx</span> <span class=\"n\">_oexpr</span> <span class=\"bp\">=&gt;</span>\n   <span class=\"k\">match</span> <span class=\"n\">_stx</span> <span class=\"k\">with</span>\n   <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"bp\">|</span> <span class=\"k\">match</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"k\">with</span> <span class=\"bp\">$</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">matchAlts</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">x_stx</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Term.elabTerm</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Symbol</span><span class=\"o\">))</span>\n      <span class=\"k\">let</span> <span class=\"n\">ty</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Meta.inferType</span> <span class=\"n\">x_stx</span>\n      <span class=\"k\">let</span> <span class=\"n\">is_sym</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Meta.isDefEq</span> <span class=\"n\">ty</span> <span class=\"o\">(</span><span class=\"n\">mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Symbol</span><span class=\"o\">)</span>\n      <span class=\"k\">if</span> <span class=\"n\">not</span> <span class=\"n\">is_sym</span> <span class=\"k\">then</span> <span class=\"n\">throwUnsupportedSyntax</span>\n      <span class=\"n\">Term.elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">&lt;-</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"bp\">|</span> <span class=\"k\">match</span> <span class=\"n\">Symbol.repr</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"k\">with</span> <span class=\"bp\">$</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">matchAlts</span><span class=\"o\">))</span> <span class=\"n\">none</span>\n   <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Symbol</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">s</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">SymbolRepr.Infinimum</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 436237982,
        "sender_full_name": "Kiran",
        "timestamp": 1714472016
    },
    {
        "content": "<p>I think maybe this is _maybe_ an <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> problem; is your question actually</p>\n<blockquote>\n<p>If I have a type</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">SymbolRepr</span> <span class=\"n\">where</span> <span class=\"bp\">|</span> <span class=\"n\">Infinimum</span> <span class=\"bp\">|</span> <span class=\"n\">Supremum</span> <span class=\"bp\">|</span> <span class=\"n\">Number</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>how can I use <code>implemented_by</code> to give it a custom C in-memory implementation?</p>\n</blockquote>",
        "id": 436240234,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714472940
    },
    {
        "content": "<p>Oh, if there's a solution to that problem that would be great as well! </p>\n<p>(my question here was just about prompting for how Lean envisions the story for extending macros (in a programming context I guess, tactics being extensible is something well known from Rocq even))</p>",
        "id": 436240677,
        "sender_full_name": "Kiran",
        "timestamp": 1714473132
    },
    {
        "content": "<p>For <code>match</code>, I think a long-term ideal is to be able to reconfigure what the constructors are for a type (this might be RFC <a href=\"https://github.com/leanprover/lean4/pull/2716\">lean4#2716</a>) rather than solving the problem using just syntax transformations.</p>",
        "id": 436241310,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714473444
    },
    {
        "content": "<p>You'd want to be able to use these patterns everywhere patterns can be matched, and you want to be sure you're not accidentally getting in the way of any <code>match</code> features. An issue with your <code>match</code> macro is that it won't generalize the expected type and substitute in each match case, which is important for dependent types. But if the return type never depends on the variable you're matching against, this doesn't matter.</p>",
        "id": 436241591,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714473558
    }
]