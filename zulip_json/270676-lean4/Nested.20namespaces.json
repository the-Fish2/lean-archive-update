[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">A.a</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">A.B.b</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">B.b</span> <span class=\"o\">:</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">A</span>\n\n<span class=\"c1\">-- want to access `B.b` as `b`, but:</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">B</span>\n\n<span class=\"bp\">#</span><span class=\"n\">where</span> <span class=\"c1\">-- `open A.B`</span>\n<span class=\"k\">#check</span> <span class=\"n\">b</span> <span class=\"c1\">-- `A.B.b : 2 = 2`</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">_root_.B</span> <span class=\"c1\">-- `unknown namespace '_root_.B'`</span>\n</code></pre></div>\n<p>Is there a way to open namespace <code>B</code> (and <em>not</em> <code>A.B</code>) while in namespace <code>A</code>?</p>",
        "id": 430309912,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711741914
    },
    {
        "content": "<p>I don't believe so. Here's an issue you could <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> <a href=\"https://github.com/leanprover/lean4/pull/3045\">lean4#3045</a></p>",
        "id": 430311358,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711742667
    },
    {
        "content": "<p>(You could also add your example as a comment if it would be a helpful test case.)</p>",
        "id": 430311416,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711742700
    },
    {
        "content": "<p>I don't think the example really adds something here.</p>",
        "id": 430311580,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711742778
    },
    {
        "content": "<p>Would there be problems with <code>open</code> always using the root namespace by default? I would think that's the behavior that most people would expect.</p>",
        "id": 430311935,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1711742970
    },
    {
        "content": "<p>I think this was the lean3 behavior.<br>\nIf you really want <code>A.B</code>, you can write <code>open A.B</code>, I suppose... But this may be less nice when <code>A</code> is very long.</p>",
        "id": 430312110,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711743061
    },
    {
        "content": "<p>If we needed notation for that <code>open .B</code> might be a solution, but I would hope namespaces don't become that cumbersome.</p>",
        "id": 430312978,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1711743584
    },
    {
        "content": "<p>It's used pretty often, writing things like <code>open Lean Meta Elab Term PrettyPrinter Delaborator</code>, rather than <code>open Lean Lean.Meta Lean.Elab Lean.Elab.Term Lean.PrettyPrinter Lean.PrettyPrinter.Delaborator</code>.</p>\n<p>Writing <code>open Lean .Meta .Elab .Term .PrettyPrinter .Delaborator</code> wouldn't be so bad, though using <code>_root_</code> for absolute names is already a solution elsewhere in Lean.</p>",
        "id": 430314104,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711744208
    },
    {
        "content": "<p>What happens when there are namespaces <code>A</code>, <code>B</code>, <code>A.C</code>, <code>B.C</code> and I do <code>open A B C</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">A.a</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">B.b</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">A.C.c</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">B.C.c</span> <span class=\"o\">:</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span>\n<span class=\"bp\">#</span><span class=\"n\">where</span> <span class=\"c1\">-- `open A B B.C A.C`</span>\n</code></pre></div>\n<p>Is this what people would expect?</p>",
        "id": 430314395,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711744382
    },
    {
        "content": "<p>I think one problem is that after <code>namespace A</code>, <code>open B</code> one potentially has a different set of open namespaces than after <code>open A B</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">A.a</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">B.b</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">A.B.c</span> <span class=\"o\">:</span> <span class=\"mi\">4</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">A</span>\n<span class=\"kn\">open</span> <span class=\"n\">B</span>\n<span class=\"bp\">#</span><span class=\"n\">where</span> <span class=\"c1\">-- `namespace A, open A.B`</span>\n<span class=\"kd\">end</span> <span class=\"n\">A</span>\n\n<span class=\"bp\">#</span><span class=\"n\">where</span> <span class=\"c1\">-- In root namespace with initial scope</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">A</span> <span class=\"n\">B</span>\n<span class=\"bp\">#</span><span class=\"n\">where</span> <span class=\"c1\">-- `open A B A.B`</span>\n</code></pre></div>",
        "id": 430314566,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711744479
    },
    {
        "content": "<p>... and that the set of open namespaces can change by adding or removing declarations further up in the file.<br>\nE.g., removing the lemma <code>A.B.c</code> above replaces <code>open A.B</code> in the first <code>#where</code> by <code>open B</code>.</p>",
        "id": 430315703,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711745073
    },
    {
        "content": "<p>To tell the truth, I never really feel like I know what will be <code>open</code>. However, while I have few expectations on what <code>open</code> does, I do feel some surprise that <code>open A B C</code> opens four namespaces. There's a logic to it, but it's still unexpected.</p>",
        "id": 430315774,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711745109
    },
    {
        "content": "<p>...actually five when <code>A.B</code> also exists.</p>",
        "id": 430315816,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711745143
    },
    {
        "content": "<p>In any case, the mental model that <code>namespace A</code> includes the effect of <code>open A</code> is clearly wrong.</p>",
        "id": 430315939,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711745203
    },
    {
        "content": "<p>I should mention that a feature we rely on for this to not be total madness is that name resolution is partly type directed, so even if the same name is used across multiple namespaces, it can still often be disambiguated.</p>",
        "id": 430316028,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711745257
    },
    {
        "content": "<p>Indeed,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">A.a</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">B.b</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">A.B.c</span> <span class=\"o\">:</span> <span class=\"mi\">4</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">C.c</span> <span class=\"o\">:</span> <span class=\"mi\">37</span> <span class=\"bp\">=</span> <span class=\"mi\">37</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">A.C.d</span> <span class=\"o\">:</span> <span class=\"mi\">43</span> <span class=\"bp\">=</span> <span class=\"mi\">43</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">B.C.e</span> <span class=\"o\">:</span> <span class=\"mi\">389</span> <span class=\"bp\">=</span> <span class=\"mi\">389</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">C.A.f</span> <span class=\"o\">:</span> <span class=\"mi\">55</span> <span class=\"bp\">=</span> <span class=\"mi\">55</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- not this one, though!</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">A.B.C.x</span> <span class=\"o\">:</span> <span class=\"mi\">5077</span> <span class=\"bp\">=</span> <span class=\"mi\">5077</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span>\n<span class=\"bp\">#</span><span class=\"n\">where</span> <span class=\"c1\">-- `open A B A.B C A.B.C B.C A.C`</span>\n</code></pre></div>",
        "id": 430316241,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711745380
    },
    {
        "content": "<p>For that, you can probably add another <code>A</code> after <code>C</code>.</p>",
        "id": 430316354,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711745429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Nested.20namespaces/near/430316028\">said</a>:</p>\n<blockquote>\n<p>I should mention that a feature we rely on for this to not be total madness is that name resolution is partly type directed, so even if the same name is used across multiple namespaces, it can still often be disambiguated.</p>\n</blockquote>\n<p>I think the problem is not so much that too much is opened, but rather, too little (in the <code>namespace</code> case).</p>",
        "id": 430316363,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711745432
    },
    {
        "content": "<p>My usual approach is to try to avoid pushing the limits of <code>open/namespace</code> and try to rely on them in a conservative way.</p>",
        "id": 430316458,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711745489
    },
    {
        "content": "<p>So, would it be problematic if <code>namespace A</code>, <code>open B</code> would open <code>B</code> <em>and</em> <code>A.B</code>?</p>",
        "id": 430316461,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711745491
    },
    {
        "content": "<p>(so as to be consistent with <code>open A B</code>)</p>",
        "id": 430316508,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711745519
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/270676-lean4/topic/Nested.20namespaces/near/430316458\">said</a>:</p>\n<blockquote>\n<p>My usual approach is to try to avoid pushing the limits of <code>open/namespace</code> and try to rely on them in a conservative way.</p>\n</blockquote>\n<p>How do you deal with the problem that you <em>cannot</em> access a declaration <code>B.b</code> unqualified in namespace <code>A</code> when namespace <code>A.B</code> also exists?</p>",
        "id": 430316673,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711745599
    },
    {
        "content": "<p>If I really had to do that, I would probably close all namespaces and then use fully qualified names.  In my experience, I have not ran into this issue often enough to really be more than amused by it.</p>",
        "id": 430316868,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711745705
    },
    {
        "content": "<p>(One can do <code>open B</code>, <code>namespace A</code>,  but this does not work locally with <code>open B in</code>.)</p>",
        "id": 430317010,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711745780
    },
    {
        "content": "<p>Well, if you bring in <code>open ... in</code>, would you also then not expect <code>namespace X in ...</code> to work?  That's another \"feature\" that creates more asymmetries.</p>",
        "id": 430317185,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711745889
    },
    {
        "content": "<p>Why should this not work? (I know it doesn't, but is there a good reason?)</p>",
        "id": 430317361,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711746000
    },
    {
        "content": "<p>The reason is that <code>in</code> really expands to <code>section [unnamed] command end</code> and then if <code>command</code> has a <code>namespace</code>, it wants to close <em>itself</em>, not the unnamed <code>end</code>.</p>",
        "id": 430317525,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711746061
    },
    {
        "content": "<p>If you actually remove the <code>in</code> and add <code>section</code> before and <code>end</code> after, it will become clear.</p>",
        "id": 430317588,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711746100
    },
    {
        "content": "<p>Btw, this could be a \"fix\" for <code>namespace in</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kn\">namespace</span> <span class=\"bp\">$</span><span class=\"n\">id</span> <span class=\"k\">in</span> <span class=\"bp\">$</span><span class=\"n\">cmd</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kn\">section</span> <span class=\"kn\">namespace</span> <span class=\"bp\">$</span><span class=\"n\">id</span> <span class=\"bp\">$</span><span class=\"n\">cmd</span> <span class=\"kd\">end</span> <span class=\"bp\">$</span><span class=\"n\">id</span> <span class=\"kd\">end</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">X</span> <span class=\"k\">in</span>  <span class=\"c1\">-- works</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">intro</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">X.hi</span>  <span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 430319453,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711747099
    },
    {
        "content": "<p>I think that's equivalent to <code>theorem X.hi : True := .intro</code></p>",
        "id": 430319666,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711747253
    },
    {
        "content": "<p>(minus the extra <code>section</code>)</p>",
        "id": 430319722,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711747306
    },
    {
        "content": "<p>Take a look at the first case in the <code>match</code> in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Command.elabDeclaration#doc\">docs#Lean.Elab.Command.elabDeclaration</a></p>",
        "id": 430319731,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711747318
    },
    {
        "content": "<p>Yes, I also think that it is -- I was not seriously proposing it as an addition, just a way of \"restoring symmetry\".</p>",
        "id": 430319796,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711747348
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Nested.20namespaces/near/430319731\">said</a>:</p>\n<blockquote>\n<p>Take a look at the first case in the <code>match</code> in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Command.elabDeclaration#doc\">docs#Lean.Elab.Command.elabDeclaration</a></p>\n</blockquote>\n<p>Indeed, this is something that confused me very much the first time I ran into it.</p>",
        "id": 430319872,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711747412
    },
    {
        "content": "<p>(And, after the confusion, I find it useful!)</p>",
        "id": 430319946,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711747448
    },
    {
        "content": "<p>Another point of view is that the asymmetry is that <code>open X</code> \"cannot be closed\", while <code>namespace X</code> can.</p>",
        "id": 430320129,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711747567
    },
    {
        "content": "<p>That reminds me, there was an idea for <code>namespace X in</code> that would resolve <code>X</code> first, so that you could reliably add methods for dot notation, even if things got refactored. Implementation: <a href=\"#narrow/stream/270676-lean4/topic/More.20reliable.20.22methods.22.3F/near/399819556\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/More.20reliable.20.22methods.22.3F/near/399819556</a></p>",
        "id": 430320131,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711747569
    },
    {
        "content": "<p>Consider the following scenario.</p>\n<p>File <code>Y.lean</code> contains</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">X</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">B</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bar1</span> <span class=\"bp\">...</span> <span class=\"o\">:</span> <span class=\"bp\">...</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">bar2</span> <span class=\"bp\">...</span> <span class=\"o\">:</span> <span class=\"bp\">...</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">bar3</span> <span class=\"bp\">...</span> <span class=\"o\">:</span> <span class=\"bp\">...</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">B</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">A</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">B</span> <span class=\"k\">in</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"bp\">...</span> <span class=\"o\">:</span> <span class=\"bp\">...</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">proof</span> <span class=\"n\">uses</span> <span class=\"n\">bar1</span><span class=\"o\">,</span> <span class=\"n\">bar2</span><span class=\"o\">,</span> <span class=\"n\">bar3</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">A</span>\n</code></pre></div>\n<p>and everything works.</p>\n<p>Now at some later point, somebody adds a declaration <code>A.B.ohno</code> in file <code>X.lean</code>. The result is that the proof of theorem <code>A.foo</code> in <code>Y.lean</code> will break down, and whoever looks at it will have a hard time figuring out what the problem is. (Of course, it doesn't have to be <code>X.lean</code>; it could be any file in the transitive import closure, and whoever added <code>A.B.ohno</code> will likely have no idea of the ripple effects.)</p>\n<p>I think that <em>adding</em> stuff to imports leading to declarations no longer being available (without namespace qualification) downstream is rather bad behavior and should be avoided. (I know that , say, adding <code>simp</code> lemmas can also break proofs downstream if they use non-terminal <code>simp</code>, but this is a different matter.)</p>\n<p>I think a reasonable solution would be to have <code>open B</code> within <code>namespace A</code> behave like <code>open B</code> within <code>open A</code>, i.e., open all existing namespaces among <code>B</code> and <code>A.B</code>. Then the namespace <code>A.B</code> coming into existence will not remove access to <code>B</code>.</p>",
        "id": 430407558,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711820676
    },
    {
        "content": "<p>I also don't think it is good that, assuming namespaces <code>A</code>, <code>B</code>, <code>A.B</code> and <code>B.A</code> all exist, there is no way to <code>open</code> just <code>A</code> and <code>B</code> and not also <code>A.B</code> (with <code>open A B</code>) or <code>B.A</code> (with <code>open B A</code>).</p>\n<p>(This goes somewhat against what I suggested above, but my main point there is to avoid that establishing a namespace has surprising effects downstream.)</p>\n<p>Essentially, I would want to be able to figure out exactly which namespaces are open at a given location just by looking at the file it is in.</p>",
        "id": 430415858,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711828361
    },
    {
        "content": "<p><span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span> Can perhaps one (or more) of the developers comment on this? (Not sure who to ping here...)</p>",
        "id": 430956001,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1712135565
    },
    {
        "content": "<p>Doesn't seem particularly high priority to me? At least, I haven't been bitten by it.</p>",
        "id": 430962321,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1712137343
    },
    {
        "content": "<p>I'm not asking for an immediate fix, but I'd like to know if others also see this behavior as problematic.</p>",
        "id": 430962557,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1712137435
    }
]