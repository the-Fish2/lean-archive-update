[
    {
        "content": "<p>The Goldbach conjecture is that every even number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">n\\geq4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span></span></span></span> is the sum of two primes. It's still an open question. Computationally-inclined number theorists sometimes write computer programs to check it for all even <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>≤</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">n\\leq X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> grows slowly over time as computers get better. How big can we make <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> in Lean?</p>\n<p><a href=\"https://www.ams.org/journals/mcom/1993-61-204/S0025-5718-1993-1185250-6/S0025-5718-1993-1185250-6.pdf\">Here</a> is an example of a paper from 1993 by Sinisalo about numerically verifying the Goldbach conjecture up to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>11</mn></msup></mrow><annotation encoding=\"application/x-tex\">4\\times10^{11}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">11</span></span></span></span></span></span></span></span></span></span></span></span> (using non-formal techniques, as do all the papers I cite below). It's published in Math Comp, which was at that time the top journal for computational mathematics, so one can imagine that it was state of the art at the time. It doesn't do anything fancy involving zero estimates for the Riemann zeta functions (some other papers in this area do); it just does a brute force variant of Eratosthenes' sieve. The details of the algorithm are in <a href=\"https://www.researchgate.net/publication/241887101_Checking_the_Goldbach_conjecture_on_a_vector_computer\">this earlier paper</a> of Granville et al, where if you can HANDLE THE FORTRAN CODE they explain the very simple method (my understanding, at least, is that this is the algorithm Sinisalo used as well). It seems that in 1988 (Granville et al) they could get up to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>=</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>10</mn></msup></mrow><annotation encoding=\"application/x-tex\">X=2\\times10^{10}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">10</span></span></span></span></span></span></span></span></span></span></span></span>, in 1993 (Sinisalo) they had got as far as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>11</mn></msup></mrow><annotation encoding=\"application/x-tex\">4\\times 10^{11}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">11</span></span></span></span></span></span></span></span></span></span></span></span>, and the most recent paper I can find is by Oliviera e Silva, Herzog and Pardi <a href=\"https://www.semanticscholar.org/paper/Empirical-verification-of-the-even-Goldbach-and-of-Silva-Herzog/0bcebfe7cd9889039a36c73cf0a21609cb8867e2\">here</a> which push the calculations up to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding=\"application/x-tex\">4\\times10^{18}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">18</span></span></span></span></span></span></span></span></span></span></span></span> and again they are using very simple algorithms (they also give a history of the computational aspect of the problem at the beginning, and they explain their simple algorithms in the paper, but it's just Eratosthenes + some extra thought to make it computationally more efficient).</p>\n<p>Obviously computers are many times faster now than they were in 1993 (at the time of Sinisalo's paper), however formal proofs as opposed to Fortran proofs slow things down again. I was wondering how far one could get in Lean 4, using GMP if necessary (I would also be interested in whether GMP speeds things up or whether for numbers of this size it's of no use). It would be a pretty simple job to knock off a very naive algorithm to start verifying Goldbach, and if anyone gets the bug and wants to start setting formalisation records then these more advanced algorithms which seem to be giving state of the art results are really still extremely elementary in nature as you can see from their description in the linked papers. I have no idea what the record is for formalised computational Goldbach.</p>\n<p>Why am I interested? Well,  the ternary Goldbach conjecture is the weaker statement that every odd natural &gt;= 7 is the sum of three primes, and a proof was announced a few years ago by Helfgott. Helfgott's proof is in two completely different parts; he uses abstract techniques from analytic number theory to prove the results for odd numbers <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≥</mo><mn>8</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>31</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\geq 8\\times 10^{31}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">31</span></span></span></span></span></span></span></span></span></span></span></span> and then (with Platt -- see <a href=\"https://arxiv.org/abs/1305.3062\">here</a> does a brute force computer search to check the cases less than this bound. The proof of the abstract analytic number theory part of the argument is 300 pages long so is unlikely to be formalised any time soon, however the basic techniques used in it by Helfgott (the circle method etc) are used a lot in this area, and are being formalised by mathematicians in <a href=\"https://b-mehta.github.io/unit-fractions/\">this Lean project here</a>, so it led me to idly speculate about how feasible it would be to formalise the various parts of the proof of the ternary conjecture and in particular the computational part. For the computational part Helfgott uses the Oliviera e Silva, Herzog and Pardi result, which reduces the claim that ternary Goldbach is true up to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>8</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>31</mn></msup></mrow><annotation encoding=\"application/x-tex\">8\\times 10^{31}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">31</span></span></span></span></span></span></span></span></span></span></span></span> to the claim that there are no two consecutive primes in this range which are distance <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≥</mo><mn>4</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\geq 4\\times 10^{18}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">18</span></span></span></span></span></span></span></span></span></span></span></span> apart, and this is what he proves using a (unformalised) computer proof. I would imagine that formalised methods right now can't get close to Helfgott's unformalised bound but it seems to me that if the state of the art is being achieved with these essentially elementary arguments then it might make a good computational project for someone interested in seeing how far Lean 4 can get; certainly no maths library will be needed, for example.</p>",
        "id": 270963940,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644233022
    },
    {
        "content": "<p>This is very interesting. I guess a formal proof can simply be an enumeration, with even numbers listed as sums of pairs of primes and a proof of the equality.</p>",
        "id": 270966280,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1644234508
    },
    {
        "content": "<p>Exactly. But I have no feeling at all as to the complexity of doing this to a non-trivial bound in a formal setting. I know that they computed the <a href=\"https://arxiv.org/abs/1709.01743\">first million digits of pi in Coq</a> although <a href=\"https://en.wikipedia.org/wiki/Chronology_of_computation_of_%CF%80#2009%E2%80%93present\">the non-formal people are up to about 10^13 digits by now</a>.</p>",
        "id": 270966458,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644234640
    },
    {
        "content": "<p>A very nice feature of lean 4 compiled code is that proofs are eliminated at runtime after checking correctness while compiling. So there is hope the overhead is small.</p>",
        "id": 270967582,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1644235256
    },
    {
        "content": "<p>If Lean 4 uses GMP, then the implementation of GMP (in C, I guess) is part of the TCB, right?</p>",
        "id": 270970652,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1644237056
    },
    {
        "content": "<p>Or is there a verified reimplementation?</p>",
        "id": 270970678,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1644237073
    },
    {
        "content": "<p>there are plans for a verified (or at least homegrown and not GPL) reimplementation, but indeed that's the current state of things</p>",
        "id": 270970758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644237126
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mo>⋅</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding=\"application/x-tex\">4 \\cdot 10^{18}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">18</span></span></span></span></span></span></span></span></span></span></span></span> is around <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup><mi mathvariant=\"normal\">/</mi><mn>4.5</mn></mrow><annotation encoding=\"application/x-tex\">2^{64}/4.5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">64</span></span></span></span></span></span></span></span></span><span class=\"mord\">/4.5</span></span></span></span>; so I don't think GMP will be relevant to that part (and maybe this is why they stopped at that particular value).</p>",
        "id": 270971060,
        "sender_full_name": "Reid Barton",
        "timestamp": 1644237324
    },
    {
        "content": "<p>Aha, because if you off-load the bignum computations and the primality checks to a non-verified GMP, then there is little value in doing the project in Lean, methinks.</p>",
        "id": 270971105,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1644237349
    },
    {
        "content": "<p>the part of GMP in the lean TCB only includes <code>+ - * / %</code> on nat and int, not primality</p>",
        "id": 270971225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644237408
    },
    {
        "content": "<p>of course you can use FFI + implementedBy + reduceBool to add arbitrary C code to the TCB if you want</p>",
        "id": 270971337,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644237477
    },
    {
        "content": "<p>so for instance you could link to those GMP primality routines and add them to lean</p>",
        "id": 270971436,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644237512
    },
    {
        "content": "<p>Might also be interesting to do this verified Goldbach in MM0</p>",
        "id": 270971468,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1644237532
    },
    {
        "content": "<p>lol, it's always on my mind... I'm thinking to wait until I have verified computational reflection before tackling these kinds of problems though</p>",
        "id": 270971543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644237589
    },
    {
        "content": "<p>Maybe it might be better to start a little simpler, for example calculating the number of primes &lt;= 100000 in lean 4 compared to (pick your favorite other language)</p>",
        "id": 270971926,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644237769
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/lh1pJ_o_Wrtzrp57fs2teaty/image.png\">image.png</a> Here's a proof that the number of primes less than 100000 is 9592 in Lean 3</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/lh1pJ_o_Wrtzrp57fs2teaty/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/lh1pJ_o_Wrtzrp57fs2teaty/image.png\"></a></div>",
        "id": 298437314,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1663006727
    },
    {
        "content": "<p>And kernel typechecking time?</p>",
        "id": 298440104,
        "sender_full_name": "Reid Barton",
        "timestamp": 1663007719
    },
    {
        "content": "<p>How can I measure this?</p>",
        "id": 298440371,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1663007815
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/JMngEo2PBsDNIOZSL74mOejf/image.png\">image.png</a> Here's all the other things the profiler tells me (on this run it says execution was around 4.5s)</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/JMngEo2PBsDNIOZSL74mOejf/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/JMngEo2PBsDNIOZSL74mOejf/image.png\"></a></div>",
        "id": 298440605,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1663007899
    },
    {
        "content": "<p>But you didn't do this by explicitly computing all the primes less than 10^5, right?</p>",
        "id": 298492923,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1663024404
    },
    {
        "content": "<p>BTW if anyone has questions for Helfgott I'm at a conference with him this week</p>",
        "id": 298493015,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1663024471
    },
    {
        "content": "<p>I didn't, but I did also separately compute all the primes less than 2 * 10^5</p>",
        "id": 298494399,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1663025596
    },
    {
        "content": "<p>I've also managed to check Goldbach (again in Lean 3) up to 2*10^5. In particular the statement</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">goldbach_kevin</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"mi\">200000</span><span class=\"o\">,</span> <span class=\"mi\">4</span> <span class=\"bp\">≤</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">even</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">p.prime</span> <span class=\"bp\">∧</span> <span class=\"n\">q.prime</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"bp\">+</span> <span class=\"n\">q</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>is sorry-free</p>",
        "id": 298494440,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1663025638
    },
    {
        "content": "<p>This looks like fun learning experience.  I tried super simple Eratosthenes Sieve in Lean 4 but it runs out of stack space pretty quick:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">EratosthenesSieveSimple</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">ℕ</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">EratosthenesSieveSimple</span> <span class=\"o\">(</span><span class=\"n\">xs.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">y</span> <span class=\"bp\">%</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>So I used a StateM monad to allow some tail recursion:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">EratosthenesSieve</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">StateM</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"n\">xs</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs'</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">r</span> <span class=\"bp\">←</span> <span class=\"n\">get</span>\n    <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n    <span class=\"n\">EratosthenesSieve</span> <span class=\"o\">(</span><span class=\"n\">xs'.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">y</span> <span class=\"bp\">%</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>The compiled version of this can find the first 1 million primes in about 93 seconds on my AMD Ryzen 9 CPU. It found 78498 primes. I can then save this to a new lean source file containing <code>def primes := [2, 3, 5, 7, ...]</code> but when I try and compile this simple array the Lean compiler times out, which is odd:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">.\\.\\.\\</span><span class=\"n\">Primes1Million.lean</span><span class=\"o\">:</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"mi\">14</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">deterministic</span><span class=\"o\">)</span> <span class=\"n\">timeout</span> <span class=\"n\">at</span> <span class=\"bp\">'</span><span class=\"n\">isDefEq'</span><span class=\"o\">,</span> <span class=\"n\">maximum</span> <span class=\"n\">number</span> <span class=\"n\">of</span> <span class=\"n\">heartbeats</span> <span class=\"o\">(</span><span class=\"mi\">200000</span><span class=\"o\">)</span> <span class=\"n\">has</span> <span class=\"n\">b</span>                                             <span class=\"n\">een</span> <span class=\"n\">reached</span> <span class=\"o\">(</span><span class=\"n\">use</span> <span class=\"bp\">'</span><span class=\"kd\">set_option</span> <span class=\"n\">maxHeartbeats</span> <span class=\"bp\">&lt;</span><span class=\"n\">num</span><span class=\"bp\">&gt;'</span> <span class=\"n\">to</span> <span class=\"n\">set</span> <span class=\"n\">the</span> <span class=\"n\">limit</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I was thinking of saving this file as a cheat so we could use it to implement a more efficient <code>Nat.prime</code> function, e.g. use it to build a HashMap of all the numbers with a true false saying whether they are primes or not so <code>p.prime</code> becomes an O(1) lookup....</p>",
        "id": 299241049,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1663362148
    },
    {
        "content": "<p>how long is your list <code>def primes := [2, 3, 5, 7, ...]</code>?</p>",
        "id": 299243023,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663363230
    },
    {
        "content": "<p>Here's a MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"make_list\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"bp\">`</span><span class=\"o\">([</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkArray</span> <span class=\"mi\">5000</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">))),</span><span class=\"bp\">*</span><span class=\"o\">])</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"n\">make_list</span>\n</code></pre></div>\n<p>While I expect there to be problems eventually, 5000 seems unusually low for them to show up here. I think there are some issues in the scheme used for compiling list literals using nested <code>let</code> bindings.</p>",
        "id": 299243906,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663363743
    },
    {
        "content": "<p>It seems like there is some quadratic behavior here with it spending a huge amount of time in <code>elimMVarDeps</code> traversing the term to ensure no metavariables contain references to the newly introduced let bindings produced by the <code>[xs,* | tail]</code> notation</p>",
        "id": 299246244,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663364973
    },
    {
        "content": "<p>This is really unnecessary, this notation should just be an <code>elab</code> and produce a term directly instead of macro expanding to a pile of lets that have to be elaborated</p>",
        "id": 299246353,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663365019
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"434989\">@Chris Lovett</span> FYI, that's not the true sieve of Eratosthenes (though it's the one you see as a functional programming example, and <a href=\"https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf\">there's a paper about this</a>).</p>\n<p>Here's a simple implementation of the true one -- note that it doesn't have any modulo operators nor any checking that a given number is not divisible by <em>all</em> of the primes found so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">primes</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">res</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">buf</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">mkArray</span> <span class=\"n\">n</span> <span class=\"n\">True</span>\n  <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"n\">buf</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">!</span> <span class=\"k\">then</span>\n      <span class=\"n\">res</span> <span class=\"o\">:=</span> <span class=\"n\">res.push</span> <span class=\"n\">i</span>\n      <span class=\"n\">for</span> <span class=\"n\">j</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n        <span class=\"n\">buf</span> <span class=\"o\">:=</span> <span class=\"n\">buf.set</span><span class=\"bp\">!</span> <span class=\"n\">j</span> <span class=\"n\">False</span>\n  <span class=\"n\">return</span> <span class=\"n\">res</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">main</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">primes</span> <span class=\"mi\">1000000</span>\n  <span class=\"n\">for</span> <span class=\"n\">p</span> <span class=\"k\">in</span> <span class=\"n\">a</span> <span class=\"k\">do</span>\n    <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{p}\"</span>\n</code></pre></div>\n<p>Compiled, I get</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>$ time ./build/bin/primes\n...  78498 lines omitted ...\n./build/bin/primes  0.11s user 0.17s system 86% cpu 0.323 total\n</code></pre></div>\n<p>93 seconds seemed excessive for the primes less than a million!</p>",
        "id": 299250681,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1663367446
    },
    {
        "content": "<p>Ok, building on your nice fast primes function we can find the sum of 2 primes for every even <code>i &gt;= 4</code> with this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">NatMap</span> <span class=\"o\">:=</span> <span class=\"n\">HashMap</span> <span class=\"n\">Nat</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">goldback</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">primes</span> <span class=\"o\">:=</span> <span class=\"n\">primes</span> <span class=\"n\">n</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">HashMap.empty</span>\n  <span class=\"n\">for</span> <span class=\"n\">p</span> <span class=\"k\">in</span> <span class=\"n\">primes</span> <span class=\"k\">do</span>\n    <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">map.insert</span> <span class=\"n\">p</span> <span class=\"n\">p</span>\n  <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">4</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">found</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n    <span class=\"n\">for</span> <span class=\"n\">p</span> <span class=\"k\">in</span> <span class=\"n\">primes</span> <span class=\"k\">do</span>\n      <span class=\"k\">if</span> <span class=\"n\">p</span> <span class=\"bp\">&gt;</span> <span class=\"n\">i</span> <span class=\"k\">then</span>\n        <span class=\"n\">break</span>\n      <span class=\"k\">else</span>\n        <span class=\"k\">let</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"n\">p</span>\n        <span class=\"k\">if</span> <span class=\"n\">map.contains</span> <span class=\"n\">q</span> <span class=\"k\">then</span>\n          <span class=\"n\">found</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n          <span class=\"n\">break</span>\n    <span class=\"k\">if</span> <span class=\"n\">not</span> <span class=\"n\">found</span> <span class=\"k\">then</span>\n      <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{i} disproves goldback conjecture\"</span>\n      <span class=\"n\">break</span>\n</code></pre></div>\n<p>and the compiled version can prove a pair <code>p + q</code> exists for all 5,761,455 primes found under 100 million in 9 seconds which is not bad.</p>",
        "id": 299263849,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1663379441
    },
    {
        "content": "<p>The performance seems quite linear (it increases by a factor of 10 each time I increase <code>n</code> by a factor of 10) but of course this solution will not scale too far before running out of memory, we'd need a more compact collection for checking whether <code>q</code> is a prime number... or a SQLite database partitioned across a bunch of terabyte drives or something... but then of course all that will slow things down....</p>",
        "id": 299264131,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1663379730
    },
    {
        "content": "<p>I could fit 1 billion in memory which it did in 101 seconds... but I only have a piddly little 32GB RAM so 10 billion is where I run out.  I need one of those machine learning boxes with a terabyte of RAM :-)</p>",
        "id": 299265513,
        "sender_full_name": "Chris Lovett",
        "timestamp": 1663381304
    },
    {
        "content": "<p>For the sieve, you could start by using a bit-vector instead of a hashmap, which will reduce your space overhead significantly.<br>\nThen, you can also halve the memory used by only storing the odd numbers, since any prime must be odd. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 299492042,
        "sender_full_name": "Tom",
        "timestamp": 1663554064
    },
    {
        "content": "<p>There are also some sparse bitvector data structures which would allow you to take advantage of the fact that your bitvector will be mostly empty because of <a href=\"https://en.wikipedia.org/wiki/Prime_number_theorem\">https://en.wikipedia.org/wiki/Prime_number_theorem</a>.</p>",
        "id": 299492425,
        "sender_full_name": "Tom",
        "timestamp": 1663554489
    },
    {
        "content": "<p>I think these approaches do a different thing to what I did - evaluating whether such a counterexample exists doesn't give you a Lean 4 <em>proof</em> that none exist. Certainly for Lean 3 it's a lot faster to evaluate/run instead of proving, and I expect similar for Lean 4</p>",
        "id": 303348534,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1665452937
    },
    {
        "content": "<p>What's GMP and TCB?</p>",
        "id": 305066519,
        "sender_full_name": "joaogui1 (he/him)",
        "timestamp": 1666229367
    },
    {
        "content": "<p>GMP is the <a href=\"https://en.wikipedia.org/wiki/GNU_Multiple_Precision_Arithmetic_Library\">GNU MultiPrecision Library</a> it's a C library for doing integer arithmetic on numbers that are too big to fit into typical computer registers. TCB stands for \"trusted computing base\" - it means the set of all software we use when doing formally verification that we assume is bug-free.</p>",
        "id": 305067134,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1666229991
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 305109481,
        "sender_full_name": "joaogui1 (he/him)",
        "timestamp": 1666257595
    },
    {
        "content": "<p>I've noticed this stream only now - not sure anybody is still reading. </p>\n<ol start=\"0\">\n<li>A trick that most lazy schoolchildren learn: it is enough to check for divisibility by primes up to sqrt(N). Any composite number up to &lt;=N must have a prime factor &lt;=sqrt(N).</li>\n<li>The way you deal with limited in space (in any language) is by using a segmented sieve (... and that is efficient because of point 0. above): you can run a sieve of Erathostenes on a segment of the form [N,N+sqrt(N)] (say) in time roughly linear on sqrt(N).<br>\n(In fact you can go down to N^(1/3) if you are tricky, though that is more complicated.)</li>\n</ol>",
        "id": 429956589,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1711576855
    },
    {
        "content": "<ol start=\"3\">\n<li>The code examples given here simply run a sieve of Eratosthenes in Lean - in pretty much the same way and in the same sense as they would run it in any functional language (AFAIK). They are not giving a formal proof that the array that is being returned is actually telling us the truth.</li>\n</ol>\n<p>I imagine there are two options:<br>\n3a (faster but I was told a few years ago that this was science-fiction, at least in another theorem prover): write a formal proof that the code tells you the truth. The difficulty here (I was told) lies in proving that a loop does what it is supposed to do, without actually going through it N times. Not sure why this should be the case (obviously someone will say 'halting problem', but I am talking about this particular problem; living after Gödel doesn't keep us from doing math either)<br>\n3b: writing a formal proof in Lean that actually goes through N iterations of the loops and gives us a certificate at the end that an array is telling us the truth. </p>\n<p>I see no reason why 3b should be difficult for someone with experience in Lean. I am a rank beginner, so I have to ask how to go about it. I'd gladly help, in part so that I can learn more Lean.</p>\n<p>(Obviously we would want to keep the time complexity roughly linear; otherwise one might as well just churn a list of prime certificates in a more conventional way, one by one, using an existing primality checker.)</p>",
        "id": 429957743,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1711577450
    },
    {
        "content": "<blockquote>\n<p>The code examples given here simply run a sieve of Eratosthenes in Lean - in pretty much the same way and in the same sense as they would run it in any functional language (AFAIK). They are not giving a formal proof that the array that is being returned is actually telling us the truth.</p>\n</blockquote>\n<p>Note that this is generally not an issue. Once you have some code running in Lean, you can prove the correctness of the algorithm in O(1) work (possibly messy, but generally much less computational work than running the algorithm itself) and then combine it with the results of the algorithm to get a full formal proof out the other end</p>",
        "id": 429958266,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711577777
    },
    {
        "content": "<p>That is to say, 3a is not science fiction at all, and it doesn't require going through the loop multiple times, as it's pure symbolic reasoning</p>",
        "id": 429958379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711577838
    },
    {
        "content": "<p>I personally find proofs in the style of 3a (\"extrinsic verification\") preferable to 3b (\"intrinsic verification\") because it means it is easier to guarantee that the verification stuff does not interfere with the compiler producing efficient-enough code</p>",
        "id": 429958581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711577942
    },
    {
        "content": "<blockquote>\n<p>Note that this is generally not an issue. Once you have some code running in Lean, you can prove the correctness of the algorithm in O(1) work (possibly messy, but generally much less computational work than running the algorithm itself) and then combine it with the results of the algorithm to get a full formal proof out the other end<br>\n  11:17 PM</p>\n<p>That is to say, 3a is not science fiction at all, and it doesn't require going through the loop multiple times, as it's pure symbolic reasoning<br>\n</p>\n</blockquote>\n<p>That's excellent news - and would like to see how to do it, preferably on this particular example (which is easy and interesting, at least to me; it is a useful algorithm that is at least 19 centuries old -- possibly 24).</p>",
        "id": 429959430,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1711578458
    },
    {
        "content": "<p>FWIW, some related work to material discussed in this thread:</p>\n<ul>\n<li>The <a href=\"https://github.com/thery/coqprime/tree/master\">CoqPrime</a> library</li>\n<li>A verified analogue of GMP: <a href=\"https://inria.hal.science/hal-03233220/document\">paper</a> and <a href=\"https://gitlab.inria.fr/why3/whymp/\">code</a></li>\n</ul>",
        "id": 429965889,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1711582101
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"603502\">@Harald Helfgott</span> Currently, proving facts about <code>do</code> notation programs is a bit fiddly, so I've taken the liberty of rewriting the original function into a more continuation-passing style (which is compiled to better code, as well) rather than reasoning directly about all the <code>forIn</code> cominators etc. But we can still run it just as before, and we can prove properties about the function by using a bunch of lemmas about array operators and induction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Prime</span>\n\n<span class=\"c1\">-- def primes (n : Nat) : Array Nat := Id.run do</span>\n<span class=\"c1\">--   let mut res : Array Nat := #[]</span>\n<span class=\"c1\">--   let mut buf : Array Bool := .mkArray n true</span>\n<span class=\"c1\">--   for i in [2 : n] do</span>\n<span class=\"c1\">--     if buf[i]! then</span>\n<span class=\"c1\">--       res := res.push i</span>\n<span class=\"c1\">--       for j in [i * i : n : i] do</span>\n<span class=\"c1\">--         buf := buf.set! j false</span>\n<span class=\"c1\">--   return res</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">primes</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">loop1</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">//</span> <span class=\"n\">i</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">})</span>\n      <span class=\"o\">(</span><span class=\"n\">buf</span> <span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">arr</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Bool</span> <span class=\"bp\">//</span> <span class=\"n\">arr.size</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n    <span class=\"k\">if</span> <span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"k\">then</span>\n      <span class=\"k\">if</span> <span class=\"n\">buf.1</span><span class=\"o\">[</span><span class=\"n\">i.1</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">buf.2</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">hi</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n        <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">loop2</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n            <span class=\"o\">(</span><span class=\"n\">buf</span> <span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">arr</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Bool</span> <span class=\"bp\">//</span> <span class=\"n\">arr.size</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">arr</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Bool</span> <span class=\"bp\">//</span> <span class=\"n\">arr.size</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">}</span> <span class=\"o\">:=</span>\n          <span class=\"k\">if</span> <span class=\"n\">hj</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"k\">then</span>\n            <span class=\"n\">loop2</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"bp\">+</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"n\">buf.1.set</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">buf.2</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">hj</span><span class=\"o\">⟩</span> <span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">buf.2</span><span class=\"o\">]⟩</span>\n          <span class=\"k\">else</span>\n            <span class=\"n\">buf</span>\n        <span class=\"n\">termination_by</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">j</span>\n        <span class=\"n\">loop1</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">Nat.succ_pos</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">(</span><span class=\"n\">loop2</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">buf</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">res.push</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n      <span class=\"k\">else</span> <span class=\"n\">loop1</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">Nat.succ_pos</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"n\">buf</span> <span class=\"n\">res</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">res</span>\n  <span class=\"n\">termination_by</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">i.1</span>\n  <span class=\"n\">loop1</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"bp\">.</span><span class=\"n\">mkArray</span> <span class=\"n\">n</span> <span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n</code></pre></div>",
        "id": 429974821,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711587952
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">mem_primes_loop2</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">i</span> <span class=\"n\">hi</span> <span class=\"n\">buf</span> <span class=\"n\">buf'</span> <span class=\"n\">j</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">primes.loop1.loop2</span> <span class=\"n\">n</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span> <span class=\"n\">j</span> <span class=\"n\">buf</span> <span class=\"bp\">=</span> <span class=\"n\">buf'</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">j_eq</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span><span class=\"n\">k</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hk</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n      <span class=\"n\">buf'.1</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">buf'.2</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">hk</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"bp\">↔</span>\n      <span class=\"n\">buf.1</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">buf.2</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">hk</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"bp\">∧</span>\n      <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">≠</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">primes.loop1.loop2</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">eq</span><span class=\"bp\">;</span> <span class=\"n\">split</span> <span class=\"n\">at</span> <span class=\"n\">eq</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rename_i</span> <span class=\"n\">hj</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_primes_loop2</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"n\">j</span><span class=\"bp\">+</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">eq</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">j_eq</span><span class=\"o\">,</span> <span class=\"n\">Nat.succ_mul</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">])</span> <span class=\"n\">hk</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Array.get_set</span> <span class=\"o\">(</span><span class=\"n\">hj</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">buf.2</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">hk</span><span class=\"o\">)]</span><span class=\"bp\">;</span> <span class=\"n\">split</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rename_i</span> <span class=\"n\">jk</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span>\n    <span class=\"bp\">·</span> <span class=\"n\">cases</span> <span class=\"k\">show</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">k</span> <span class=\"k\">from</span> <span class=\"n\">jk</span>\n      <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">le_rfl</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">j_eq</span><span class=\"o\">⟩</span>\n    <span class=\"bp\">·</span> <span class=\"n\">refine</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">H</span> <span class=\"n\">h</span> <span class=\"n\">m'</span> <span class=\"n\">eq</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">H</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">H</span> <span class=\"o\">((</span><span class=\"n\">Nat.le_add_right</span> <span class=\"bp\">..</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">h</span><span class=\"o\">)⟩</span>\n      <span class=\"n\">refine</span> <span class=\"n\">H</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">eq</span>\n      <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">lt_of_le_of_ne</span> <span class=\"n\">h</span> <span class=\"n\">jk</span>\n      <span class=\"n\">subst</span> <span class=\"n\">eq</span> <span class=\"n\">j_eq</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_lt_add_iff_left</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n      <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.lt_of_mul_lt_mul_right</span> <span class=\"n\">this</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_le_add_iff_left</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Nat.succ_mul</span><span class=\"o\">]</span>\n      <span class=\"n\">exact</span> <span class=\"n\">Nat.mul_le_mul_right</span> <span class=\"n\">_</span> <span class=\"n\">this</span>\n  <span class=\"bp\">·</span> <span class=\"n\">subst</span> <span class=\"n\">eq</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hk.trans_le</span> <span class=\"o\">(</span><span class=\"n\">not_lt.1</span> <span class=\"n\">hj</span><span class=\"o\">)]</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">j</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_primes_loop1</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"n\">i</span> <span class=\"n\">hi</span> <span class=\"n\">buf</span> <span class=\"n\">res</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i2</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hi'</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">max</span> <span class=\"mi\">2</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hres</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">res.data</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span> <span class=\"bp\">∧</span> <span class=\"n\">Nat.Prime</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sz</span> <span class=\"o\">:</span> <span class=\"n\">buf.size</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hbuf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">buf</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"n\">sz</span> <span class=\"bp\">▸</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"bp\">↔</span>\n      <span class=\"bp\">∀</span> <span class=\"n\">q</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">q.Prime</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">≠</span> <span class=\"n\">q</span> <span class=\"bp\">*</span> <span class=\"n\">q</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">primes.loop1</span> <span class=\"n\">n</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">buf</span><span class=\"o\">,</span> <span class=\"n\">sz</span><span class=\"o\">⟩</span> <span class=\"n\">res</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">Nat.Prime</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">primes.loop1</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">split</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rename_i</span> <span class=\"n\">h1</span>\n  <span class=\"bp\">·</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">buf</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"bp\">↔</span> <span class=\"n\">i.Prime</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hbuf</span> <span class=\"n\">_</span> <span class=\"n\">h1</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span>\n      <span class=\"bp\">·</span> <span class=\"n\">refine</span> <span class=\"k\">fun</span> <span class=\"n\">h2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.prime_def_le_sqrt.2</span> <span class=\"o\">⟨</span><span class=\"n\">i2</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">m</span> <span class=\"n\">m2</span> <span class=\"n\">hm</span> <span class=\"n\">mi</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n        <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">pq</span><span class=\"o\">,</span> <span class=\"n\">qm</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.exists_prime_and_dvd</span> <span class=\"o\">(</span><span class=\"n\">Nat.ne_of_gt</span> <span class=\"n\">m2</span><span class=\"o\">)</span>\n        <span class=\"k\">have</span> <span class=\"n\">hq</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.le_sqrt.1</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_of_dvd</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_of_lt</span> <span class=\"n\">m2</span><span class=\"o\">)</span> <span class=\"n\">qm</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">hm</span>\n        <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">qm.trans</span> <span class=\"n\">mi</span>\n        <span class=\"k\">have</span> <span class=\"n\">qc</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">mul_le_mul_iff_of_pos_left</span> <span class=\"n\">pq.pos</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hq</span>\n        <span class=\"n\">apply</span> <span class=\"n\">h2</span> <span class=\"n\">q</span> <span class=\"o\">(</span><span class=\"n\">lt_mul_right</span> <span class=\"n\">pq.pos</span> <span class=\"o\">(</span><span class=\"n\">pq.two_le.trans</span> <span class=\"n\">qc</span><span class=\"o\">))</span> <span class=\"n\">pq</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">-</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">add_mul</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_sub_cancel'</span> <span class=\"n\">qc</span><span class=\"o\">,</span> <span class=\"n\">Nat.mul_comm</span><span class=\"o\">]</span>\n      <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">pi</span> <span class=\"n\">q</span> <span class=\"n\">qi</span> <span class=\"n\">pq</span> <span class=\"n\">m</span> <span class=\"n\">eq</span>\n        <span class=\"n\">exact</span> <span class=\"n\">qi.ne'</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">pi.dvd_iff_eq</span> <span class=\"n\">pq.ne_one</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">⟨</span><span class=\"n\">q</span><span class=\"bp\">+</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">add_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">]⟩</span>\n    <span class=\"n\">split</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rename_i</span> <span class=\"n\">pi</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">pi</span>\n    <span class=\"bp\">·</span> <span class=\"n\">generalize</span> <span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">primes.loop1.loop2</span> <span class=\"bp\">..</span> <span class=\"bp\">=</span> <span class=\"n\">buf'</span>\n      <span class=\"n\">refine</span> <span class=\"n\">mem_primes_loop1</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_succ_of_le</span> <span class=\"n\">i2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">le_max_of_le_right</span> <span class=\"n\">h1</span><span class=\"o\">)</span>\n        <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"n\">buf'.2</span> <span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"n\">hk</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n      <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hres</span><span class=\"o\">,</span> <span class=\"n\">Nat.lt_succ_iff_lt_or_eq</span><span class=\"o\">,</span> <span class=\"n\">or_and_right</span><span class=\"o\">]</span>\n        <span class=\"n\">exact</span> <span class=\"n\">or_congr_right</span> <span class=\"o\">(</span><span class=\"n\">and_iff_left_iff_imp.2</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">▸</span> <span class=\"n\">pi</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n      <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_primes_loop2</span> <span class=\"mi\">0</span> <span class=\"n\">eq</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"n\">hk</span><span class=\"o\">,</span> <span class=\"n\">hbuf</span> <span class=\"n\">_</span> <span class=\"n\">hk</span><span class=\"o\">]</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.lt_succ_iff_lt_or_eq</span><span class=\"o\">,</span> <span class=\"n\">or_imp</span><span class=\"o\">,</span> <span class=\"n\">forall_and</span><span class=\"o\">,</span> <span class=\"n\">pi</span><span class=\"o\">]</span>\n        <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">or_iff_not_imp_left.2</span> <span class=\"k\">fun</span> <span class=\"n\">h2</span> <span class=\"n\">m</span> <span class=\"n\">eq</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h2</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"bp\">▸</span> <span class=\"n\">Nat.le_add_right</span> <span class=\"bp\">..</span><span class=\"o\">)</span>\n    <span class=\"bp\">·</span> <span class=\"n\">refine</span> <span class=\"n\">mem_primes_loop1</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_succ_of_le</span> <span class=\"n\">i2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">le_max_of_le_right</span> <span class=\"n\">h1</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"n\">sz</span> <span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"n\">hk</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n      <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hres</span><span class=\"o\">,</span> <span class=\"n\">Nat.lt_succ_iff_lt_or_eq</span><span class=\"o\">]</span>\n        <span class=\"n\">refine</span> <span class=\"n\">and_congr_left</span> <span class=\"k\">fun</span> <span class=\"n\">pp</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">or_iff_left_of_imp</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n        <span class=\"n\">subst</span> <span class=\"n\">i</span><span class=\"bp\">;</span> <span class=\"n\">contradiction</span>\n      <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hbuf</span> <span class=\"n\">_</span> <span class=\"n\">hk</span><span class=\"o\">,</span> <span class=\"n\">Nat.lt_succ_iff_lt_or_eq</span><span class=\"o\">,</span> <span class=\"n\">or_imp</span><span class=\"o\">,</span> <span class=\"n\">forall_and</span><span class=\"o\">,</span> <span class=\"n\">pi</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">le_antisymm</span> <span class=\"n\">hi'</span> <span class=\"o\">(</span><span class=\"n\">max_le</span> <span class=\"n\">i2</span> <span class=\"o\">(</span><span class=\"n\">not_lt.1</span> <span class=\"n\">h1</span><span class=\"o\">))</span><span class=\"bp\">;</span> <span class=\"n\">subst</span> <span class=\"n\">this</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Array.mem_def</span><span class=\"o\">,</span> <span class=\"n\">hres</span><span class=\"o\">,</span> <span class=\"n\">lt_max_iff</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">and_congr_left</span> <span class=\"k\">fun</span> <span class=\"n\">pp</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">or_iff_right</span> <span class=\"n\">pp.two_le.not_lt</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">mem_primes</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">primes</span> <span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">p.Prime</span> <span class=\"o\">:=</span>\n  <span class=\"n\">mem_primes_loop1</span> <span class=\"n\">le_rfl</span> <span class=\"o\">(</span><span class=\"n\">le_max_left</span> <span class=\"bp\">..</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">p2</span> <span class=\"n\">pp</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pp.two_le.not_lt</span> <span class=\"n\">p2</span><span class=\"o\">)</span> <span class=\"n\">_</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"n\">hk</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">p2</span> <span class=\"n\">pp</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">pp.two_le.not_lt</span> <span class=\"n\">p2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 429974832,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711587962
    },
    {
        "content": "<p>(Note that we are all aware that this kind of proof is very difficult to write and maintain, and have a variety of ideas for being able to write better monadic verification code. But this at least shows that it is possible to do this kind of thing today, and indeed many of the algorithms in mathlib and std are verified in this way.)</p>",
        "id": 429975336,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711588348
    },
    {
        "content": "<p>And then:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Nat.Prime</span> <span class=\"mi\">101</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">mem_primes</span> <span class=\"mi\">200</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">native_decide</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n</code></pre></div>\n<p>?</p>",
        "id": 429975443,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1711588462
    },
    {
        "content": "<p>well, that's actually not the best way to verify primality of a single number. Eratosthenes is optimized for the case where you have a whole dense set of numbers you want to check primality for</p>",
        "id": 429975505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711588522
    },
    {
        "content": "<p>Sure.</p>",
        "id": 429976518,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1711589151
    },
    {
        "content": "<p>Ah, nice!</p>",
        "id": 429978639,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1711590635
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Note</span> <span class=\"n\">that</span> <span class=\"n\">we</span> <span class=\"n\">are</span> <span class=\"n\">all</span> <span class=\"n\">aware</span> <span class=\"n\">that</span> <span class=\"n\">this</span> <span class=\"n\">kind</span> <span class=\"n\">of</span> <span class=\"n\">proof</span> <span class=\"n\">is</span> <span class=\"n\">very</span> <span class=\"n\">difficult</span> <span class=\"n\">to</span> <span class=\"n\">write</span> <span class=\"n\">and</span> <span class=\"n\">maintain</span><span class=\"o\">,</span> <span class=\"n\">and</span> <span class=\"k\">have</span> <span class=\"n\">a</span> <span class=\"n\">variety</span> <span class=\"n\">of</span> <span class=\"n\">ideas</span> <span class=\"n\">for</span> <span class=\"n\">being</span> <span class=\"n\">able</span> <span class=\"n\">to</span> <span class=\"n\">write</span> <span class=\"n\">better</span> <span class=\"n\">monadic</span> <span class=\"n\">verification</span> <span class=\"n\">code.</span>\n</code></pre></div>\n<p>I'd say this is the natural next challenge: make the code and the proof readable, and the task of producing them accessible to a working mathematician who happens to use Lean.</p>",
        "id": 430043984,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1711624549
    },
    {
        "content": "<p>Is this an appropriate place to talk about ideas related to the Goldbach Conjecture? Or is this more about Lean specific discussions/efforts related to the Goldbach Conjecture? If it's not an appropriate place for some general, non-Lean related, discussions on GC, what would be an appropriate place for someone like myself to share some ideas?</p>",
        "id": 430077351,
        "sender_full_name": "Jonatas Miguel",
        "timestamp": 1711635420
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"495981\">@Jonatas Miguel</span> The thread in this stream is very much about formalization, and I would say only about weak GC, not GC.<br>\nIf your ideas are a mix of math but with formalization in mind, then <a class=\"stream\" data-stream-id=\"116395\" href=\"/#narrow/stream/116395-maths\">#maths</a> would be a good place. Otherwise, I would suggest a blogpost, or math.stackexchange or other online place where math is discussed.</p>",
        "id": 430078633,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711635755
    },
    {
        "content": "<p>Got it, yeah, I have some ideas and observations around patterns I've seen while playing around with the GC on my free time. But, I don't have proofs for anything just yet.</p>\n<p>I'm not very experienced with formalization. I'm trying to learn but it's a bit slow going for me. I'll keep on working at it though.</p>\n<p>Thanks for the response.</p>",
        "id": 430079295,
        "sender_full_name": "Jonatas Miguel",
        "timestamp": 1711635916
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"603502\">@Harald Helfgott</span> <a href=\"#narrow/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture/near/430043984\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Note that we are all aware that this kind of proof is very difficult to write and maintain, and have a variety of ideas for being able to write better monadic verification code.</p>\n</blockquote>\n<p>I'd say this is the natural next challenge: make the code and the proof readable, and the task of producing them accessible to a working mathematician who happens to use Lean.</p>\n</blockquote>\n<p>The ideas of the proof (and the proof strategy) are not that difficult: There is one function for every loop, and one theorem for every function which asserts what properties hold before and after the function. These are usually called \"loop invariants\" in software verification. Most of the loop invariants are just saying exactly what was done to the <code>buf</code> variable, and then there is an important <code>have : buf[i] = true ↔ i.Prime</code> subgoal in <code>mem_primes_loop1</code> which does the mathematically interesting work of proving that <code>∀ q &lt; i, q.Prime → ∀ m, i ≠ q * q + m * q</code> if and only if <code>i.Prime</code> (given <code>2 ≤ i</code>), which is a slightly obscured version of <code>∀ q ≤ sqrt i, q.Prime → ¬q ∣ i</code>.</p>\n<p>Then there is a bunch of boring and unnecessarily difficult work dealing with all the array get and set functions, and also to some extent the numeric manipulations can probably be simplified with <code>omega</code>, <code>linarith</code> and <code>aesop</code> for the general stuff. But if you look at the proof in the editor, the subgoals should all look reasonable.</p>",
        "id": 430160046,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711659012
    },
    {
        "content": "<p>Mario Carneiro: that's what I meant - it would be better for the system to be sufficiently developed for the ideas of the proof to be reasonably clear from a well-written formal proof, and for the code itself to remain relatively transparent.</p>",
        "id": 430169414,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1711663759
    },
    {
        "content": "<p>Just to get this right: from reading the code above, I get the impression that 'continuation-style code' consists in replacing each loop by a sub-procedure defined by means of tail recursion, with the loop variable becoming a parameter. Is this correct?</p>",
        "id": 430381992,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1711798029
    },
    {
        "content": "<p>Yes. When you use <code>for</code> loops in <code>do</code> notation, it's actually syntactic sugar for some combinators that are ultimately defined using tail recursion. It's the form that the compiler normally uses for loops, and using it directly gives you some additional flexibility compared to using the combinators. It definitely looks less clean than the imperative style though.</p>",
        "id": 430383600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711799446
    },
    {
        "content": "<p>Beginner's question: I'm trying to create a file to run the above code and the above proof.  I followed the instructions in <a href=\"https://gist.github.com/jcommelin/1d45a0ea7a84a87db8a28a12e93cac32\">https://gist.github.com/jcommelin/1d45a0ea7a84a87db8a28a12e93cac32</a> , Scenario 1. However, all I am getting in Lean Infoview with VS Code is \"Waiting for Lean server to start...\"</p>\n<p>What to do?</p>",
        "id": 430390373,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1711805417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"603502\">Harald Helfgott</span> <a href=\"#narrow/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture/near/430390373\">said</a>:</p>\n<blockquote>\n<p>[...] I followed the instructions in <a href=\"https://gist.github.com/jcommelin/1d45a0ea7a84a87db8a28a12e93cac32\">https://gist.github.com/jcommelin/1d45a0ea7a84a87db8a28a12e93cac32</a> , Scenario 1. However, all I am getting in Lean Infoview with VS Code is \"Waiting for Lean server to start...\" [...]</p>\n</blockquote>\n<p>Are people still using lean v3? The codebase that that gist refers to (specifically the link <a href=\"https://github.com/leanprover/mathlib/blob/master/leanpkg.toml#L4\">https://github.com/leanprover/mathlib/blob/master/leanpkg.toml#L4</a>) even says to use lean v4. </p>\n<p>The way that I got lean v4 working in VS Code was to install the <a href=\"https://marketplace.visualstudio.com/items?itemName=leanprover.lean4\">lean4</a> extension for VS Code and follow the instructions it outlines there once installed. Once I did that I was able to create projects from scratch or even download existing projects and run them, though, the latter required an extra step that I found <a href=\"https://leanprover-community.github.io/install/project.html#:~:text=Run%20lake%20exe%20cache%20get%20(note%3A%20this%20command%20currently%20only%20works%20in%20projects%20which%20import%20mathlib4%20as%20a%20dependency)\">here</a>. </p>\n<p>I hope this helps. <span aria-label=\"fingers crossed\" class=\"emoji emoji-1f91e\" role=\"img\" title=\"fingers crossed\">:fingers_crossed:</span></p>",
        "id": 430393101,
        "sender_full_name": "Jonatas Miguel",
        "timestamp": 1711807845
    },
    {
        "content": "<p>Well, I just came back from a \"Lean for the curious mathematician\" workshop - in which we used Lean 4, and in which everything seemed to go well. Once I came back home, I tried to just use VS code and start a new project, and the system told me that it knew of no such thing as mathlib. Hence my confusion (and my following outdated information).</p>",
        "id": 430395366,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1711809718
    },
    {
        "content": "<p>I would encourage you to create a thread in <a class=\"stream\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members\">#new members</a> if you are having trouble getting set up.</p>",
        "id": 430400860,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711814493
    },
    {
        "content": "<p>Thanks. All right, I am now working within the directory that I pulled using git during workshop, and Lean and mathlib are running. I'll figure out later how to install things on my own and not bother people here.</p>\n<p>Now, however, it seems I do not know how to use the above code. What do I do in order to get a table of the primes &lt;= 1000, or a proof that that table is correct?</p>",
        "id": 430406142,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1711819369
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">primes</span> <span class=\"mi\">1000</span>\n<span class=\"k\">#check</span> <span class=\"n\">mem_primes</span> <span class=\"mi\">1000</span>\n</code></pre></div>",
        "id": 430417236,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1711829537
    },
    {
        "content": "<p>Thanks. Why does mem_primes take an argument? Shouldn't an extrinsic proof work for all n? (That is, it should prove that the algorithm gives the correct result for arbitrary input.)</p>",
        "id": 430420523,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1711833256
    },
    {
        "content": "<p>Yes, sorry if that was unclear... <code>mem_primes</code> by itself is a proof that <code>∀ n, p ∈ primes n ↔ p &lt; n ∧ p.Prime</code>, so it doesn't need an input. However, you had asked about a proof that the table of primes generated by <code>primes 1000</code> is correct, so I wrote <code>mem_primes 1000</code> as a way of specifying that proof (since universal quantification is just a function from parameters to proofs).</p>",
        "id": 430423787,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1711836913
    },
    {
        "content": "<p>Or are you asking why a universally quantified proposition can be treated like a function?</p>",
        "id": 430423960,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1711837144
    },
    {
        "content": "<p>Ah, all right. On the last question: no, that was not my question, but I guess the answer is that that is just how Lean's syntax works? (Or, more strongly, and if I understand correctly: for Lean, \"prove that, for every $n\\in \\mathbb{N}$...\" and  \"For every $n\\in \\mathbb{N}$, return a proof...\" are one of the same thing.)</p>",
        "id": 430425063,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1711838303
    }
]