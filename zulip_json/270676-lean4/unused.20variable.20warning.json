[
    {
        "content": "<p>Doing basic logic with my class and in a lot of my proofs there are unused variables, e.g. I'm just getting them to prove dumb stuff like <code>P -&gt; True</code> and they do <code>intro hP; triv</code> or whatever and then get a warning that they didn't use hP. The second question is P -&gt; Q -&gt; P (an axiom of predicate logic) and <code>intro hP; intro hQ; exact hP</code> gives an unused variable warning, but this is week 1 of the course and I'm not sure that I want to trouble them with this at this point. Can I turn these warnings off for e.g. an entire file?</p>",
        "id": 413038053,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705357731
    },
    {
        "content": "<p><code>set_option linter.unusedVariables false</code></p>",
        "id": 413038147,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1705357797
    },
    {
        "content": "<p>the <code>set_option</code> version is the way to turn off \"core\" linters whereas the <code>@[nolint ...]</code> is the way to turn off \"Mathlib\" linters.</p>",
        "id": 413038327,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1705357886
    },
    {
        "content": "<p>Is there an easy way to tell whether a linter is a core one or a mathlib one? I wasn't even sure if this was the right stream for this question because I didn't really even know where to start looking.</p>",
        "id": 413038444,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705357938
    },
    {
        "content": "<p>(I think) the easy way is that the core ones trigger immediately, but the Mathlib ones you need to trigger manually with <code>#lint</code>.</p>",
        "id": 413038513,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1705357984
    },
    {
        "content": "<p>That's not quite true. There are two separate linting frameworks, and any project can add linters to either framework. One is defined in Lean, the other in Std.</p>",
        "id": 413046797,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1705363089
    },
    {
        "content": "<p>So what I said is true if you replace Mathlib with Std, right?</p>",
        "id": 413046976,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1705363202
    },
    {
        "content": "<p>Yes.</p>",
        "id": 413047054,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1705363220
    },
    {
        "content": "<p>By the way, I just reimplemented the unused variables linter in <a href=\"https://github.com/leanprover/lean4/pull/3186\">lean4#3186</a> and I was surprised to discover that a major part of the algorithm, and by far the slowest, is spent trawling all metavariable assignments in all intermediate elaborator states looking for fvars exactly because it is needed to support cases like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">implicitlyUsedVariable</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">HPQ</span>\n  <span class=\"k\">have</span> <span class=\"n\">HQ</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">And.right</span> <span class=\"n\">HPQ</span>\n  <span class=\"n\">assumption</span> <span class=\"c1\">-- HQ should count as used</span>\n</code></pre></div>\n<p>This surprises me because this is exactly the case which, like <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> , I had grown to think was not handled by the algorithm! So I guess whatever it is doing is not sufficient...</p>",
        "id": 413051219,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705364935
    },
    {
        "content": "<p>There are two kinds of \"unused variable\" warnings:</p>\n<ul>\n<li>a variable that got a pretty name, but that pretty name is never mentioned again in the user-written proof.</li>\n<li>a variable that is genuinely unused, it doesn't appear in the proof term (i.e., doesn't show up in the <code>pp.all</code> version of the proof)</li>\n</ul>\n<p>Both are useful. But my impression is that they currently aren't very distinguished, and both carry the same name.</p>",
        "id": 413210909,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1705428087
    },
    {
        "content": "<p>For example, the \"unused pretty name\" linter could (should?) complain in Mario's <code>HQ</code> example above.<br>\nBut the \"genuinely unused\" linter certainly shouldn't complain.</p>",
        "id": 413211062,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1705428129
    },
    {
        "content": "<p>the funny part is that one of the reasons we have to go to great lengths to justify that <code>HQ</code> is used is because many tactics will just skip it entirely, e.g. if <code>assumption</code> here was to close the goal using <code>And.right HPQ</code> instead of using <code>HQ</code> directly. Would <code>HQ</code> be \"genuinely unused\" in that case?</p>",
        "id": 413211446,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705428259
    },
    {
        "content": "<p>In such a case, if you look at the proof term you won't find <code>HQ</code> anywhere</p>",
        "id": 413211521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705428295
    },
    {
        "content": "<p>(this doesn't actually happen in this particular case, but I think it would if we used <code>haveI</code> instead of <code>have</code>)</p>",
        "id": 413211595,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705428317
    },
    {
        "content": "<p>I also thought of <code>haveI</code> and I agree it's a tricky one. So I'm glad that you went to great lengths (-;</p>",
        "id": 413213548,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1705428977
    },
    {
        "content": "<p>Is there an interface where a tactic can say \"I used this\"? I guess the algorithm is trawling through the infotrees since these are more-or-less already that interface?</p>\n<p>For the example of tactics that indirectly use a variable, maybe they could be sure to register that variable in the infotree.</p>",
        "id": 413214300,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705429251
    },
    {
        "content": "<p>That would be helpful. We have to look through the <em>entire</em> metavar context, every metavariable that has been created before or during the operation of the tactic, exactly because we have no clear idea of what the tactic did. I tried just looking at the assignments of the goals in the after state, but the after state is not necessarily \"after\" enough, it may still be partially unassigned and there is no \"final mvar context\" we can look at because elaboration can contain unrelated mvar contexts (e.g. evaluating the <code>(config := ...)</code> argument of a <code>simp</code> call)</p>",
        "id": 413216584,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705430171
    },
    {
        "content": "<p>Because this procedure is such a blunt instrument it also clearly has false negatives</p>",
        "id": 413216952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705430337
    },
    {
        "content": "<p>Yeah, a tactic could even elaborate a term, checkpoint the metavar context, and then repeatedly do further processing of that term from that checkpointed context to solve for multiple goals... It was kind of a shock to realize that not only is that there no final metavariable context, but there can't be one (short of doing a very large transformation and uniquifying metavariables between multiple contexts).</p>",
        "id": 413221834,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705432226
    }
]