[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">S</span> <span class=\"n\">where</span>\n  <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">True</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">BEq</span>\n</code></pre></div>\n<p>produces the error message</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">typeclass</span> <span class=\"kd\">instance</span> <span class=\"n\">problem</span> <span class=\"n\">is</span> <span class=\"n\">stuck</span><span class=\"o\">,</span> <span class=\"n\">it</span> <span class=\"n\">is</span> <span class=\"n\">often</span> <span class=\"n\">due</span> <span class=\"n\">to</span> <span class=\"n\">metavariables</span>\n  <span class=\"n\">BEq</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m.302</span> <span class=\"n\">x</span><span class=\"bp\">✝¹</span> <span class=\"n\">x</span><span class=\"bp\">✝</span> <span class=\"n\">a</span><span class=\"bp\">✝</span> <span class=\"n\">b</span><span class=\"bp\">✝</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I would have hoped that proof irrelevance makes this easy, so is it a bug?  I can file it if so.</p>",
        "id": 411260784,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704402129
    },
    {
        "content": "<p>The motivation is to able to make computational structures (i.e., those I actually want to compute with) that contain proof terms.</p>",
        "id": 411261961,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704402563
    },
    {
        "content": "<p>Right, that happens because <code>BEq</code> is parametrised by <code>Type u</code> instead of <code>Sort u</code></p>",
        "id": 411264277,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1704403749
    },
    {
        "content": "<p>That makes sense given that it isn't that useful for <code>Prop</code>, but it seems like it would be harmless to define <code>BEq</code> for all props trivially.</p>",
        "id": 411264473,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704403849
    },
    {
        "content": "<p>Doing so doesn't break anything meaningful in the test suite. You might want to submit an RFC if you want it changed. I am not sure it is a bug but more a choice.</p>",
        "id": 411264738,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1704404001
    },
    {
        "content": "<p>I'd say <code>BEq</code> over <code>Type</code> is a choice, but <code>deriving BEq</code> failing above seems like a bug.  I will file it.</p>",
        "id": 411264915,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704404088
    },
    {
        "content": "<p>RFC: <a href=\"https://github.com/leanprover/lean4/issues/3140\">https://github.com/leanprover/lean4/issues/3140</a></p>",
        "id": 411265758,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704404534
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"432410\">@Arthur Adjedj</span> I'm not sure I follow what you're saying -- here <code>S : Type</code> so <code>BEq</code> should make sense. If it were <code>structure S : Prop where ...</code> then it would make sense for there to be no <code>BEq</code> instance.</p>\n<p>The fact that the deriving handler fails here just seems like a bug to me.</p>",
        "id": 411271806,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704407447
    },
    {
        "content": "<p>The question is whether making <code>BEq</code> support <code>Prop</code> is the lowest effort way to fix the deriving handler, and whether that is also deemed a clean way.  I don’t have a particular preference.</p>",
        "id": 411271979,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704407544
    },
    {
        "content": "<p>As a workaround, are you able to do <code>deriving DecidableEq</code> instead for your structures?</p>",
        "id": 411272516,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704407874
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I see two solutions to the problem: either make <code>BEq</code> sort-polymorphic, or handle proof-irrelevant terms accordingly in the BEq handler. I believe to have already done the second solution in a local branch, but I’m not on a PC currently (it’s a two-liner AFAIR, and follows a similar fix which was done for another derive handler recently). I believe that a few types are limited to <code>Type</code> instead of <code>Sort</code> for performance reasons ? If so, I’d say that the second option is best.</p>",
        "id": 411273664,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1704408584
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Yes, I can do <code>DecidableEq</code>, and regardless this doesn’t block me since I can implement the <code>BEq</code> myself manually.</p>",
        "id": 411276147,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704409821
    }
]