[
    {
        "content": "<p>I'm in a situation where I need to somehow bundle a type into the data recorded by an attribute, and then recover this type in <code>CommandElabM</code>. For example, I was trying to do something schematically like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">MyData</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"c1\">-- other meaningful fields which depend on `carrier`</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">my_attr</span> <span class=\"n\">specific_instance</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">specificData</span> <span class=\"n\">where</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- e.g., ``specificName := `specific_instance`` returns `specificData`</span>\n<span class=\"kd\">def</span> <span class=\"n\">getMyDataFromMyAttr</span> <span class=\"o\">:</span> <span class=\"n\">Name</span> <span class=\"bp\">→</span> <span class=\"n\">CommandElabM</span> <span class=\"n\">MyData</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">useMyAttr</span> <span class=\"o\">(</span><span class=\"n\">specificName</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CommandElabM</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">myData</span> <span class=\"o\">:</span> <span class=\"n\">MyData</span> <span class=\"bp\">←</span> <span class=\"n\">getMyDataFromMyAttr</span> <span class=\"n\">specificName</span>\n  <span class=\"bp\">...</span>\n</code></pre></div>\n<p>The issue is that <code>MyData</code> lives in too big a universe for <code>CommandElabM</code>, which can only use a <code>Type</code>, so (the type of) <code>getMyDataFromMyAttr</code> can't even be written down. I don't think I can give <code>MyData</code> a parameter, either, because uses of <code>getMyDataFromMyAttr</code> have no way of inferring this type from the <code>Name</code> argument, which is all that's accessible at the point of use.</p>\n<p>I <em>think</em> I can find a workaround for my particular use case, but it's a little inelegant (involving aux decls), and I was wondering what the recommended way of dealing with this <em>kind</em> of situation was.</p>\n<p>Is this a case of \"you probably don't really want to do that\"? Is the restriction of Lean monads like <code>CommandElabM</code> to <code>Type</code> real or artificial? And is there a standard way around this?</p>",
        "id": 424767591,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1709595659
    },
    {
        "content": "<p>I have an RFC and example patch open against Lean for making IO universe-parametrized (<a href=\"https://github.com/leanprover/lean4/pull/3011\">lean4#3011</a>), from which presumably all the other Monads could follow</p>",
        "id": 424801820,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709618850
    }
]