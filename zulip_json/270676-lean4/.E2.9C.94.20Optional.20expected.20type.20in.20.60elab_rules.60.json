[
    {
        "content": "<p>I noticed that <code>elab_rules</code> and <code>elab</code> allow for an optional <code>&lt;= ident</code> in their syntax.<br>\nDigging into the Lean 4 source code, I see that this can be used to access the expected type in the elaboration code, which is very nice. However, it also results in the elaborator forcing the expected type to be determined before running (using <code>Lean.Elab.Command.withExpectedType</code>).</p>\n<p>Is there a reliable way to access the expected type in <code>elab_rules</code>/<code>elab</code> (as an <code>Option Expr</code>) without forcing it to be elaborated? I think there is a use case for this, rather than just switching to <code>@[&lt;cat&gt;_elab &lt;parser name&gt;] def &lt;elab function&gt; ...</code> in such a case, because <code>elab_rules</code> and <code>elab</code> can infer the parser to attach the <code>&lt;cat&gt;_elab</code> attribute to from the match syntax patterns (this could be especially useful for macros that expand to <code>elab</code>/<code>elab_rules</code> commands).</p>",
        "id": 425791354,
        "sender_full_name": "Raghuram",
        "timestamp": 1710093219
    },
    {
        "content": "<p>One possibiity that did occur to me other than modifying <code>elab_rules</code>/<code>elab</code> themselves is using <code>rename_i</code>. However, how many variables back the unnamed <code>Option Expr</code> variable is found seems to depend on the syntax pattern, so it's not obvious how to reliably get the optional expected type one.</p>",
        "id": 425791366,
        "sender_full_name": "Raghuram",
        "timestamp": 1710093231
    },
    {
        "content": "<p>I do not know the full answer to your question but have a look at this <a href=\"#narrow/stream/270676-lean4/topic/Getting.20expected.20type.20in.20TermElabM\">question</a>.</p>\n<p>In particular this example by Kyle</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">fooStx</span><span class=\"o\">)</span> <span class=\"s2\">\"foo%\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"n\">fooStx</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabFoo</span> <span class=\"o\">:</span> <span class=\"n\">Term.TermElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"n\">stx</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"bp\">%</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">...</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n</code></pre></div>",
        "id": 425793289,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1710094703
    },
    {
        "content": "<p>It would be nice if there were a way to bind the <code>expectedType?</code> for <code>elab_rules</code>/<code>elab</code>, without needing to write a separate <code>syntax</code>.</p>\n<p>One syntax option I'd thought about (which Sebastian wasn't fond of) was to change the meaning of the <code>&lt;=</code> clause to be for the optional expected type and have it so that <code>&lt;= some expectedType</code> was how you cause it to postpone until the expected type is known. That might be too much magic.</p>\n<p>Another option is <code>elab (expectedType? := e?)</code> to bind an expected type, perhaps with <code>elab (expectedType?)</code> as shorthand for <code>elab (expectedType? := expectedType?)</code>.</p>",
        "id": 425793853,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710095188
    },
    {
        "content": "<p>I was also thinking it would be nice  for the syntax to be extended.<br>\nAnother more backwards-compatible way would be: (omitted) for not capturing the expected type; <code>&lt;= name</code> for forcing and capturing; and <code>&lt;= name ?</code> (or any similar variant) for capturing without forcing.</p>",
        "id": 425794045,
        "sender_full_name": "Raghuram",
        "timestamp": 1710095337
    },
    {
        "content": "<p>Another alternative would be to look at the number of things matched on (when <code>&lt;= name</code> is not provided): if one, then hide the expected type; if two, match on the expected type as the second thing.</p>",
        "id": 425794313,
        "sender_full_name": "Raghuram",
        "timestamp": 1710095531
    },
    {
        "content": "<p>Just to put it out there, here is an implementation of both of the above alternatives I wrote.<br>\nI essentially copied the implementation of <code>elab_rules</code> and modified it, and I don't really understand metaprogramming that well (plus I only aimed to implement it, not organise the code), so it's a massive mess, but here it is.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Parser</span> <span class=\"o\">(</span><span class=\"n\">suppressInsideQuot</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Parser</span> <span class=\"kn\">renaming</span> <span class=\"n\">optional</span> <span class=\"bp\">→</span> <span class=\"n\">optional_</span> <span class=\"k\">in</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Parser.Command</span> <span class=\"o\">(</span><span class=\"n\">docComment</span> <span class=\"n\">optKind</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Parser.Term</span> <span class=\"o\">(</span><span class=\"n\">attributes</span> <span class=\"n\">attrKind</span> <span class=\"n\">ident</span> <span class=\"n\">matchAlts</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"sd\">/-- A variant of `elab_rules` that allows the expected type to be</span>\n<span class=\"sd\">bound without forcing its elaboration.</span>\n\n<span class=\"sd\">If `&lt;= expectedType?` is not provided, the expected type is hidden as usual.</span>\n<span class=\"sd\">If `&lt;= expectedType?` is provided, the expected type is forced as usual.</span>\n<span class=\"sd\">If `&lt;= ? expectedType?` is provided, the expected type is made available without forcing.</span>\n\n<span class=\"sd\">Additionally, if `&lt;= expectedType?` is not provided, but one of the</span>\n<span class=\"sd\">match alternatives has multiple patterns, then the expected type is</span>\n<span class=\"sd\">made into one of the match discriminants, allowing it to be matched</span>\n<span class=\"sd\">on. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">command_parser</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Parser.elab_rules'</span> <span class=\"o\">:=</span> <span class=\"n\">leading_parser</span> <span class=\"n\">suppressInsideQuot</span> <span class=\"bp\">&lt;|</span>\n  <span class=\"n\">optional_</span> <span class=\"n\">docComment</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">optional_</span> <span class=\"n\">attributes</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">attrKind</span> <span class=\"bp\">&gt;&gt;</span>\n  <span class=\"s2\">\"elab_rules'\"</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">optKind</span> <span class=\"bp\">&gt;&gt;</span>\n    <span class=\"n\">optional_</span> <span class=\"o\">(</span><span class=\"s2\">\" : \"</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">ident</span><span class=\"o\">)</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">optional_</span> <span class=\"o\">(</span><span class=\"s2\">\" &lt;= \"</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">optional_</span> <span class=\"s2\">\"?\"</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">ident</span><span class=\"o\">)</span> <span class=\"bp\">&gt;&gt;</span>\n  <span class=\"n\">matchAlts</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Elab.Command</span> <span class=\"o\">(</span><span class=\"n\">CommandElab</span> <span class=\"n\">CommandElabM</span>\n  <span class=\"n\">adaptExpander</span> <span class=\"n\">expandNoKindMacroRulesAux</span>\n  <span class=\"n\">resolveSyntaxKind</span> <span class=\"n\">checkRuleKind</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Elab</span> <span class=\"o\">(</span><span class=\"n\">throwUnsupportedSyntax</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">Lean.Elab.Command</span> <span class=\"k\">in</span> <span class=\"c1\">-- enable the `aux_def` command</span>\n<span class=\"kd\">@[</span><span class=\"n\">command_elab</span> <span class=\"n\">Parser.elab_rules'</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">Elab.elabRules'</span> <span class=\"o\">:</span> <span class=\"n\">CommandElab</span> <span class=\"o\">:=</span>\n  <span class=\"n\">adaptExpander</span> <span class=\"k\">fun</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">doc</span><span class=\"bp\">?</span><span class=\"o\">:</span><span class=\"n\">docComment</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"kd\">@[</span><span class=\"bp\">$</span><span class=\"n\">attrs</span><span class=\"bp\">?</span><span class=\"o\">:</span><span class=\"n\">attrInstance</span><span class=\"o\">,</span><span class=\"bp\">*</span><span class=\"kd\">]</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"n\">attrKind</span><span class=\"o\">:</span><span class=\"n\">attrKind</span>\n      <span class=\"n\">elab_rules'</span> <span class=\"bp\">$</span><span class=\"o\">[:</span> <span class=\"bp\">$</span><span class=\"n\">cat</span><span class=\"bp\">?</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">&lt;=</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">?%$</span><span class=\"n\">opt</span><span class=\"bp\">??</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"n\">type</span><span class=\"bp\">?</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">]</span><span class=\"bp\">?</span>\n      <span class=\"bp\">$</span><span class=\"n\">alts</span><span class=\"o\">:</span><span class=\"n\">matchAlt</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">expandNoKindMacroRulesAux</span> <span class=\"n\">alts</span> <span class=\"s2\">\"elab_rules'\"</span> <span class=\"k\">fun</span> <span class=\"n\">kind</span><span class=\"bp\">?</span> <span class=\"n\">alts</span> <span class=\"bp\">↦</span>\n      <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">doc</span><span class=\"bp\">?</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"kd\">@[</span><span class=\"bp\">$</span><span class=\"n\">attrs</span><span class=\"bp\">?</span><span class=\"o\">,</span><span class=\"bp\">*</span><span class=\"kd\">]</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"n\">attrKind</span>\n        <span class=\"n\">elab_rules'</span> <span class=\"bp\">$</span><span class=\"o\">[(</span><span class=\"n\">kind</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">kind</span><span class=\"bp\">?.</span><span class=\"n\">map</span> <span class=\"n\">Lean.mkIdent</span><span class=\"o\">))]</span><span class=\"bp\">?</span>\n          <span class=\"bp\">$</span><span class=\"o\">[:</span> <span class=\"bp\">$</span><span class=\"n\">cat</span><span class=\"bp\">?</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">&lt;=</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">?%$</span><span class=\"n\">opt</span><span class=\"bp\">??</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"n\">type</span><span class=\"bp\">?</span><span class=\"o\">]</span><span class=\"bp\">?</span>\n        <span class=\"bp\">$</span><span class=\"n\">alts</span><span class=\"o\">:</span><span class=\"n\">matchAlt</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">doc</span><span class=\"bp\">?</span><span class=\"o\">:</span><span class=\"n\">docComment</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"kd\">@[</span><span class=\"bp\">$</span><span class=\"n\">attrs</span><span class=\"bp\">?</span><span class=\"o\">:</span><span class=\"n\">attrInstance</span><span class=\"o\">,</span><span class=\"bp\">*</span><span class=\"kd\">]</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"n\">attrKind</span><span class=\"o\">:</span><span class=\"n\">attrKind</span>\n      <span class=\"n\">elab_rules'</span> <span class=\"o\">(</span><span class=\"n\">kind</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">kind</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"o\">[:</span> <span class=\"bp\">$</span><span class=\"n\">cat</span><span class=\"bp\">?</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">&lt;=%$</span><span class=\"n\">optTk</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">?%$</span><span class=\"n\">opt</span><span class=\"bp\">??</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"bp\">$</span><span class=\"n\">type</span><span class=\"bp\">?</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">]</span><span class=\"bp\">?</span>\n      <span class=\"bp\">$</span><span class=\"n\">alts</span><span class=\"o\">:</span><span class=\"n\">matchAlt</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">k</span> <span class=\"bp\">←</span> <span class=\"n\">resolveSyntaxKind</span> <span class=\"n\">kind.getId</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> This captures the four possible expected type behaviours. Specifically:</span>\n<span class=\"cm\">    * none              === match on expected type</span>\n<span class=\"cm\">    * some (.inr type?) === access as `type?` (if `none` then `_`, ie, don't access)</span>\n<span class=\"cm\">    * some (.inr type)  === force elaboration and access as `type` -/</span>\n    <span class=\"k\">let</span> <span class=\"n\">expectedTypeMode</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">Lean.Ident</span> <span class=\"bp\">⊕</span> <span class=\"n\">Lean.Ident</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n      <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"n\">type</span><span class=\"bp\">?</span> <span class=\"k\">then</span>\n        <span class=\"n\">some</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">if</span> <span class=\"n\">opt</span><span class=\"bp\">??.</span><span class=\"n\">get</span><span class=\"bp\">!.</span><span class=\"n\">isSome</span> <span class=\"k\">then</span> <span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">type</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">type</span>\n      <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">alts.any</span> <span class=\"k\">fun</span>\n        <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Lean.Parser.Term.matchAltExpr</span><span class=\"bp\">|</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">pats</span><span class=\"o\">,</span><span class=\"bp\">*</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pats.getElems.size</span> <span class=\"bp\">&gt;=</span> <span class=\"mi\">2</span>\n        <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n      <span class=\"k\">then</span> <span class=\"n\">none</span>\n      <span class=\"k\">else</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">none</span><span class=\"o\">)</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> Is it expensive that we iterate and parse `alts` twice? -/</span>\n    <span class=\"k\">let</span> <span class=\"n\">alts</span> <span class=\"bp\">←</span> <span class=\"n\">alts.mapM</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">alt</span> <span class=\"o\">:</span> <span class=\"n\">Lean.TSyntax</span> <span class=\"bp\">``</span><span class=\"n\">Lean.Parser.Term.matchAlt</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"k\">match</span> <span class=\"n\">alt</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Lean.Parser.Term.matchAltExpr</span><span class=\"bp\">|</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">pats</span><span class=\"o\">,</span><span class=\"bp\">*</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">rhs</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">let</span> <span class=\"n\">altError</span> <span class=\"o\">:=</span> <span class=\"n\">throwErrorAt</span> <span class=\"n\">alt</span> <span class=\"s2\">\"invalid elab_rules' alternative, </span><span class=\"err\">\\</span>\n<span class=\"s2\">                                                expected syntax node kind '{k}'\"</span>\n        <span class=\"k\">let</span> <span class=\"n\">pat</span> <span class=\"o\">:=</span> <span class=\"n\">pats.elemsAndSeps</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">!</span>\n        <span class=\"k\">if</span> <span class=\"bp\">!</span><span class=\"n\">pat.isQuot</span> <span class=\"k\">then</span> <span class=\"n\">throwErrorAt</span> <span class=\"n\">pat</span> <span class=\"s2\">\"elab_rules' pattern {pat} must be a syntax quotation\"</span> <span class=\"k\">else</span>\n        <span class=\"k\">let</span> <span class=\"n\">quoted</span> <span class=\"o\">:=</span> <span class=\"n\">Lean.Syntax.getQuotContent</span> <span class=\"n\">pat</span>\n        <span class=\"k\">let</span> <span class=\"n\">k'</span> <span class=\"o\">:=</span> <span class=\"n\">quoted.getKind</span>\n        <span class=\"k\">if</span> <span class=\"n\">checkRuleKind</span> <span class=\"n\">k'</span> <span class=\"n\">k</span> <span class=\"k\">then</span> <span class=\"n\">pure</span> <span class=\"n\">alt</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">k'</span> <span class=\"bp\">==</span> <span class=\"n\">Lean.choiceKind</span> <span class=\"k\">then</span>\n          <span class=\"k\">match</span> <span class=\"n\">quoted.getArgs.find</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">checkRuleKind</span> <span class=\"bp\">·.</span><span class=\"n\">getKind</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n          <span class=\"bp\">|</span> <span class=\"n\">none</span>        <span class=\"bp\">=&gt;</span> <span class=\"n\">altError</span>\n          <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">quoted</span> <span class=\"bp\">=&gt;</span>\n            <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Lean.Parser.Term.matchAltExpr</span><span class=\"bp\">|</span>\n              <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"o\">(⟨</span><span class=\"n\">pats.elemsAndSeps.set</span><span class=\"bp\">!</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">pat.setArg</span> <span class=\"mi\">1</span> <span class=\"n\">quoted</span><span class=\"o\">⟩),</span><span class=\"bp\">*</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">rhs</span><span class=\"o\">)</span>\n        <span class=\"k\">else</span> <span class=\"n\">altError</span>\n      <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n    <span class=\"k\">let</span> <span class=\"n\">mkAttrs</span> <span class=\"o\">(</span><span class=\"n\">kind</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CommandElabM</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n      <span class=\"o\">(</span><span class=\"n\">attrs</span><span class=\"bp\">?.</span><span class=\"n\">getD</span> <span class=\"bp\">∅</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">push</span> <span class=\"bp\">&lt;$&gt;</span>\n      <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Lean.Parser.Term.attrInstance</span><span class=\"bp\">|</span>\n        <span class=\"bp\">$</span><span class=\"n\">attrKind</span><span class=\"o\">:</span><span class=\"n\">attrKind</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">Lean.mkIdent</span> <span class=\"n\">kind</span><span class=\"o\">):</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">Lean.mkIdentFromRef</span> <span class=\"n\">k</span><span class=\"o\">):</span><span class=\"n\">ident</span><span class=\"o\">)</span>\n      <span class=\"c\">/-</span><span class=\"cm\"> pure &lt;| match attrs? with</span>\n<span class=\"cm\">        | some attrs =&gt; attrs.getElems.push attr</span>\n<span class=\"cm\">        | none =&gt; #[attr] -/</span>\n\n    <span class=\"k\">let</span> <span class=\"n\">catName</span> <span class=\"bp\">←</span>\n      <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">cat</span> <span class=\"o\">:=</span> <span class=\"n\">cat</span><span class=\"bp\">?</span> <span class=\"k\">then</span> <span class=\"n\">pure</span> <span class=\"n\">cat.getId</span>\n      <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">optTk.isSome</span> <span class=\"k\">then</span> <span class=\"n\">pure</span> <span class=\"bp\">`</span><span class=\"n\">term</span>\n      <span class=\"c1\">-- TODO: infer category from quotation kind, possibly even kind of quoted syntax?</span>\n      <span class=\"k\">else</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"invalid elab_rules' command, specify </span><span class=\"err\">\\</span>\n<span class=\"s2\">                         category using `elab_rules' : &lt;cat&gt; ...`\"</span>\n    <span class=\"k\">if</span> <span class=\"n\">catName</span> <span class=\"bp\">==</span> <span class=\"bp\">`</span><span class=\"n\">term</span> <span class=\"k\">then</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">elabDefBody</span> <span class=\"bp\">←</span> <span class=\"k\">match</span> <span class=\"n\">expectedTypeMode</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"c1\">-- allow expected type as a discriminant</span>\n          <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">alts</span><span class=\"o\">:</span><span class=\"n\">matchAlt</span><span class=\"bp\">*</span>\n                <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">no_error_if_unused</span><span class=\"bp\">%</span> <span class=\"n\">throwUnsupportedSyntax</span><span class=\"o\">)</span>\n        <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">type</span><span class=\"bp\">?</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"c1\">-- don't match on expected type, possibly make it accessible</span>\n          <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">type</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"n\">type</span><span class=\"bp\">?</span> <span class=\"k\">then</span> <span class=\"n\">type</span><span class=\"bp\">?</span> <span class=\"k\">else</span> <span class=\"bp\">←`</span><span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"bp\">↦</span>\n              <span class=\"k\">match</span> <span class=\"n\">stx</span> <span class=\"k\">with</span>\n              <span class=\"bp\">$</span><span class=\"n\">alts</span><span class=\"o\">:</span><span class=\"n\">matchAlt</span><span class=\"bp\">*</span> <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">no_error_if_unused</span><span class=\"bp\">%</span> <span class=\"n\">throwUnsupportedSyntax</span><span class=\"o\">)</span>\n        <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">type</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"c1\">-- force expected type</span>\n          <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"n\">type</span><span class=\"bp\">?</span> <span class=\"bp\">↦</span> <span class=\"n\">Lean.Elab.Command.withExpectedType</span> <span class=\"n\">type</span><span class=\"bp\">?</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">type</span> <span class=\"bp\">↦</span>\n              <span class=\"k\">match</span> <span class=\"n\">stx</span> <span class=\"k\">with</span>\n              <span class=\"bp\">$</span><span class=\"n\">alts</span><span class=\"o\">:</span><span class=\"n\">matchAlt</span><span class=\"bp\">*</span> <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">no_error_if_unused</span><span class=\"bp\">%</span> <span class=\"n\">throwUnsupportedSyntax</span><span class=\"o\">)</span>\n      <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">doc</span><span class=\"bp\">?</span><span class=\"o\">:</span><span class=\"n\">docComment</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"kd\">@[</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkAttrs</span> <span class=\"bp\">`</span><span class=\"n\">term_elab</span><span class=\"o\">),</span><span class=\"bp\">*</span><span class=\"kd\">]</span>\n        <span class=\"n\">aux_def</span> <span class=\"n\">elabRules'</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">Lean.mkIdent</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Elab.Term.TermElab</span> <span class=\"o\">:=</span>\n        <span class=\"bp\">$</span><span class=\"n\">elabDefBody</span><span class=\"o\">)</span>\n    <span class=\"k\">else</span> <span class=\"c1\">-- not term category</span>\n    <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">optTk</span> <span class=\"o\">:=</span> <span class=\"n\">optTk</span> <span class=\"k\">then</span>\n      <span class=\"n\">throwErrorAt</span> <span class=\"n\">optTk</span> <span class=\"s2\">\"syntax category '{catName}' does not support expected type specification\"</span>\n    <span class=\"k\">if</span> <span class=\"n\">catName</span> <span class=\"bp\">==</span> <span class=\"bp\">`</span><span class=\"n\">command</span> <span class=\"k\">then</span>\n      <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">doc</span><span class=\"bp\">?</span><span class=\"o\">:</span><span class=\"n\">docComment</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"kd\">@[</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkAttrs</span> <span class=\"bp\">`</span><span class=\"n\">command_elab</span><span class=\"o\">),</span><span class=\"bp\">*</span><span class=\"kd\">]</span>\n        <span class=\"n\">aux_def</span> <span class=\"n\">elabRules</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">Lean.mkIdent</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Elab.Command.CommandElab</span> <span class=\"o\">:=</span>\n        <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">alts</span><span class=\"o\">:</span><span class=\"n\">matchAlt</span><span class=\"bp\">*</span> <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">no_error_if_unused</span><span class=\"bp\">%</span> <span class=\"n\">throwUnsupportedSyntax</span><span class=\"o\">)</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">catName</span> <span class=\"bp\">==</span> <span class=\"bp\">`</span><span class=\"n\">tactic</span> <span class=\"bp\">||</span> <span class=\"n\">catName</span> <span class=\"bp\">==</span> <span class=\"bp\">`</span><span class=\"n\">conv</span> <span class=\"k\">then</span>\n      <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">doc</span><span class=\"bp\">?</span><span class=\"o\">:</span><span class=\"n\">docComment</span><span class=\"o\">]</span><span class=\"bp\">?</span> <span class=\"kd\">@[</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkAttrs</span> <span class=\"bp\">`</span><span class=\"n\">tactic</span><span class=\"o\">),</span><span class=\"bp\">*</span><span class=\"kd\">]</span>\n        <span class=\"n\">aux_def</span> <span class=\"n\">elabRules'</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">Lean.mkIdent</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Elab.Tactic.Tactic</span> <span class=\"o\">:=</span>\n        <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">alts</span><span class=\"o\">:</span><span class=\"n\">matchAlt</span><span class=\"bp\">*</span> <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">no_error_if_unused</span><span class=\"bp\">%</span> <span class=\"n\">throwUnsupportedSyntax</span><span class=\"o\">)</span>\n    <span class=\"k\">else</span>\n      <span class=\"c1\">-- We considered making the command extensible and support new user-defined categories. We think it is unnecessary.</span>\n      <span class=\"c1\">-- If users want this feature, they add their own `elab_rules` macro that uses this one as a fallback.</span>\n      <span class=\"n\">throwError</span> <span class=\"s2\">\"unsupported syntax category '{catName}'\"</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">Test</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">testFoo₁</span><span class=\"o\">)</span> <span class=\"s2\">\"foo₁\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">testFoo₂</span><span class=\"o\">)</span> <span class=\"s2\">\"foo₂\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">testFoo₃</span><span class=\"o\">)</span> <span class=\"s2\">\"foo₃\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">testFooCommand</span><span class=\"o\">)</span> <span class=\"s2\">\"foo\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Elab.definition</span> <span class=\"n\">true</span>\n<span class=\"n\">elab_rules'</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">foo₁</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Lean.Meta.mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">Nat.zero</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n<span class=\"n\">elab_rules'</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">type</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">foo₂</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">Elab.debug</span><span class=\"o\">]</span> <span class=\"s2\">\"{type}\"</span><span class=\"bp\">;</span> <span class=\"n\">Lean.Meta.mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">Nat.zero</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n<span class=\"n\">elab_rules'</span> <span class=\"bp\">&lt;=</span> <span class=\"bp\">?</span><span class=\"n\">type</span><span class=\"bp\">?</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">foo₃</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"n\">type</span><span class=\"bp\">?</span> <span class=\"k\">then</span> <span class=\"k\">do</span>\n    <span class=\"n\">Lean.Elab.Term.elabAppArgs</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">Lean.Meta.mkConstWithFreshMVarLevels</span> <span class=\"bp\">``</span><span class=\"n\">default</span><span class=\"o\">)</span>\n      <span class=\"bp\">#</span><span class=\"o\">[]</span> <span class=\"bp\">#</span><span class=\"o\">[]</span> <span class=\"n\">type</span> <span class=\"n\">false</span> <span class=\"n\">false</span> <span class=\"n\">false</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">Lean.Meta.mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">Nat.zero</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n<span class=\"c\">/-</span><span class=\"cm\"> Fails as expected with &lt;= type, although the error shows on the</span>\n<span class=\"cm\">entire first line instead of on the `&lt;=`. -/</span>\n<span class=\"n\">elab_rules'</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"c1\">-- &lt;= ?type</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Lean.Elab.Command.elabCommand</span> <span class=\"bp\">=&lt;&lt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">#print</span> <span class=\"s2\">\"Surprise!\"</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">foo₁</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Elab.debug</span> <span class=\"n\">true</span> <span class=\"k\">in</span> <span class=\"k\">#eval</span> <span class=\"n\">foo₂</span> <span class=\"c1\">-- expected type is a metavariable</span>\n<span class=\"k\">#eval</span> <span class=\"n\">foo₃</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Test</span>\n</code></pre></div>\n<p>Interestingly, in the test cases, specifically the <code>#eval foo₂</code>, even though the expected type is not available, the elaboration still proceeds by setting it to a metavariable.<br>\nWhat is the difference between <code>expectedType? : Option Expr</code> and <code>expectedType? : Expr</code> a metavariable? Can <code>Lean.Elab.Command.withExpectedType</code> always be used to convert the former to the latter?</p>",
        "id": 425853362,
        "sender_full_name": "Raghuram",
        "timestamp": 1710144179
    },
    {
        "content": "<p>Actually, on adding a further test</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">testFoo₄</span><span class=\"o\">)</span> <span class=\"s2\">\"foo₄\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"n\">elab_rules'</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">foo₄</span><span class=\"o\">),</span> <span class=\"n\">some</span> <span class=\"n\">type</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"n\">Lean.Meta.mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">Nat.succ</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Lean.Meta.mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">Nat.zero</span> <span class=\"bp\">#</span><span class=\"o\">[]]</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">foo₄</span><span class=\"o\">),</span> <span class=\"n\">none</span>      <span class=\"bp\">=&gt;</span> <span class=\"n\">Lean.Meta.mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">Nat.zero</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n</code></pre></div>\n<p>I realised that this part of the syntax doesn't work.</p>\n<p>One possible reason is that the mechanism used to auto-detect the parser to attach as a <code>term_elab</code> to (namely <code>Lean.Elab.Command.inferMacroRulesAltKind</code> used in <code>Lean.Elab.Command.expandNoKindMacroRulesAux</code>) assumes the match patterns have a single pattern (although this looks like it is trivially fixed by changing the pattern that is used by it to match <code>matchAltExpr</code>s).</p>\n<p>However, even when I write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">elab_rules'</span> <span class=\"o\">(</span><span class=\"n\">kind</span> <span class=\"o\">:=</span> <span class=\"n\">testFoo₄</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">foo₄</span><span class=\"o\">),</span> <span class=\"n\">some</span> <span class=\"n\">type</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"n\">Lean.Meta.mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">Nat.succ</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Lean.Meta.mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">Nat.zero</span> <span class=\"bp\">#</span><span class=\"o\">[]]</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">foo₄</span><span class=\"o\">),</span> <span class=\"n\">none</span>      <span class=\"bp\">=&gt;</span> <span class=\"n\">Lean.Meta.mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">Nat.zero</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n</code></pre></div>\n<p>so that the parser auto-detection is skipped, the error persists, so it seems like there is some other cause as well.</p>",
        "id": 425854013,
        "sender_full_name": "Raghuram",
        "timestamp": 1710144473
    },
    {
        "content": "<p>Anyway, my original question seems pretty answered now.</p>",
        "id": 425979897,
        "sender_full_name": "Raghuram",
        "timestamp": 1710179997
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"501683\">Raghuram</span> has marked this topic as resolved.</p>",
        "id": 425979908,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710180001
    }
]