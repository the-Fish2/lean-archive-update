[
    {
        "content": "<p>I'm getting the following error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">synthesized</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">definitionally</span> <span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"n\">expression</span> <span class=\"n\">inferred</span> <span class=\"kd\">by</span> <span class=\"n\">typing</span> <span class=\"n\">rules</span><span class=\"o\">,</span> <span class=\"n\">synthesized</span>\n  <span class=\"n\">h₁</span>\n<span class=\"n\">inferred</span>\n  <span class=\"n\">FullofFullFiberwise</span> <span class=\"n\">inferInstance</span>\n</code></pre></div>\n<p>In my code <code> h₁</code> is defined as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">h₁</span> <span class=\"o\">:=</span> <span class=\"n\">FullofFullFiberwise</span> <span class=\"n\">inferInstance</span>\n</code></pre></div>\n<p>So it seems very similar to the \"inferred\" term in the error message.</p>\n<p>Does anyone know what errors like this mean? My code is quite deep in this repository: <a href=\"https://github.com/Paul-Lez/Stacks-project\">https://github.com/Paul-Lez/Stacks-project</a>, so its hard for me to generate a mwe.  What's the difference between <code>synthesized</code> and <code>inferred</code> in this error message?</p>",
        "id": 433144933,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1713110347
    },
    {
        "content": "<p>If I try to remove <code>h₁</code>, then it can't synthesise the type class instance at all.</p>",
        "id": 433145083,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1713110457
    },
    {
        "content": "<p>What happens if you replace <code>haveI</code> with <code>let</code>?</p>",
        "id": 433145579,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1713110851
    },
    {
        "content": "<p>ie is it data or a prop?</p>",
        "id": 433146078,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713111303
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sébastien Gouëzel</span> <a href=\"#narrow/stream/270676-lean4/topic/Type.20class.20instance.20error.2C.20synthesised.20vs.20inferred/near/433145579\">said</a>:</p>\n<blockquote>\n<p>What happens if you replace <code>haveI</code> with <code>let</code>?</p>\n</blockquote>\n<p>It works, thanks a lot!</p>",
        "id": 433146960,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1713112117
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/Type.20class.20instance.20error.2C.20synthesised.20vs.20inferred/near/433146078\">said</a>:</p>\n<blockquote>\n<p>ie is it data or a prop?</p>\n</blockquote>\n<p>Okay so whenever I have a type class instance containing data I need to supply it using <code>let</code>?</p>",
        "id": 433147120,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1713112265
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n  <span class=\"k\">have</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  a : Nat := 2</span>\n<span class=\"cm\">  b : Nat</span>\n<span class=\"cm\">  ⊢ False</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>You can now prove <code>a = 2</code> with <code>rfl</code>, but proving <code>b = 3</code> is impossible. <code>let</code> remembers the answer. <code>have</code> is for proofs because you don't need to remember which proof it is, they're all equal.</p>",
        "id": 433147546,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713112662
    },
    {
        "content": "<p>Something I found interesting is that if I define <code>h₁</code> as <code>haveI h₁ := sorry</code>, then I get the exact same error, and not something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">synthesized</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">definitionally</span> <span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"n\">expression</span> <span class=\"n\">inferred</span> <span class=\"kd\">by</span> <span class=\"n\">typing</span> <span class=\"n\">rules</span><span class=\"o\">,</span> <span class=\"n\">synthesized</span>\n  <span class=\"n\">h₁</span>\n<span class=\"n\">inferred</span>\n  <span class=\"n\">something</span> <span class=\"k\">else</span> <span class=\"n\">here</span>\n</code></pre></div>\n<p>so does it still knows about <code>FullofFullFiberwise inferInstance</code> somehow? But it can't seem to infer that by itself without the <code>let</code> statement.</p>",
        "id": 433147716,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1713112790
    },
    {
        "content": "<p>This behavior is super confusing for new users, and should be changed: <a href=\"https://github.com/leanprover/lean4/pull/3559\">lean4#3559</a></p>",
        "id": 433242209,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1713173401
    },
    {
        "content": "<p>Please thumbs-up the issue if you agree! This is a nice quality-of-life issue with a relatively straightforward solution (once the devs have decided which solution to implement!), so it makes using Lean easier.</p>",
        "id": 433248125,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713175223
    },
    {
        "content": "<p>I've asked for comments internally at the FRO. Seems like an important papercut to me!</p>",
        "id": 433248213,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1713175261
    },
    {
        "content": "<p>I wrote a <code>have</code> vs <code>let</code> linter at <a href=\"https://github.com/leanprover-community/mathlib4/pull/12157\">#12157</a>, in case anyone is interested.  I have not yet had a chance to examine what it is flagging in mathlib, though.</p>",
        "id": 433326976,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713196256
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132603\">Calle Sönne</span> <a href=\"#narrow/stream/270676-lean4/topic/Type.20class.20instance.20error.2C.20synthesised.20vs.20inferred/near/433144933\">said</a>:</p>\n<blockquote>\n<p>Does anyone know what errors like this mean? My code is quite deep in this repository: <a href=\"https://github.com/Paul-Lez/Stacks-project\">https://github.com/Paul-Lez/Stacks-project</a>, so its hard for me to generate a mwe.  What's the difference between <code>synthesized</code> and <code>inferred</code> in this error message?</p>\n</blockquote>\n<p>To give a more general answer: as I understand it there are (at least) two different ways to come up with a typeclass instance when required. First is the usual implicit-argument inference: if some other, explicitly provided argument (or the expected type) references that argument in its definition, then we can just use that definition. For example, if you have </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">a</span>  <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>then the type of <code>h</code> only makes sense in the context of some specific <code>a</code>, and providing a proof of <code>h</code> <em>implicitly</em> defines what <code>a</code> has to be. </p>\n<p>(Unpopular opinion: This is part of why I actually really like the new <code>autoImplicit</code> feature. AFAICT, it introduces new implicit variables precisely when they would be inferred upon invocation; it's not only convenient, but also a method of checking as you write that your model of what the compiler can infer matches reality.)</p>\n<p>The other is the typeclass specific synthesis function. Which, tbqh, I don't understand nearly as well as implicits, but roughly speaking, it looks through all available instances for something of the right type (up to metavariables in the case of (semi)OutParam), looks back at the arguments to those instances, then tries to infer or synthesize the arguments recursively. </p>\n<p>In general, these are two distinct methods of generating instances and there's no guarantee they'll give the same result, but they will need to in order for the theorem invocation/function call to be sound -- after all, by the logic of the implicit argument inference, a specific instance is required for a later explicit argument to be defined in the first place. It <em>could</em> try and silently resolve in favor of one or the other (usually the implicit argument, I think), but that would be a bit of a footgun that would give surprising results -- this almost always means that there's an error in your code somewhere (usually an 'extra' or insufficiently-detailed instance definition), so better to 'fail fast' and report that error as soon as possible.</p>",
        "id": 433399093,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713220292
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"359992\">Robert Maxton</span> <a href=\"#narrow/stream/270676-lean4/topic/Type.20class.20instance.20error.2C.20synthesised.20vs.20inferred/near/433399093\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"132603\">Calle Sönne</span> <a href=\"#narrow/stream/270676-lean4/topic/Type.20class.20instance.20error.2C.20synthesised.20vs.20inferred/near/433144933\">said</a>:</p>\n<blockquote>\n<p>Does anyone know what errors like this mean? My code is quite deep in this repository: <a href=\"https://github.com/Paul-Lez/Stacks-project\">https://github.com/Paul-Lez/Stacks-project</a>, so its hard for me to generate a mwe.  What's the difference between <code>synthesized</code> and <code>inferred</code> in this error message?</p>\n</blockquote>\n<p>To give a more general answer: as I understand it there are (at least) two different ways to come up with a typeclass instance when required. First is the usual implicit-argument inference: if some other, explicitly provided argument (or the expected type) references that argument in its definition, then we can just use that definition. For example, if you have </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">a</span>  <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>then the type of <code>h</code> only makes sense in the context of some specific <code>a</code>, and providing a proof of <code>h</code> <em>implicitly</em> defines what <code>a</code> has to be. </p>\n<p>(Unpopular opinion: This is part of why I actually really like the new <code>autoImplicit</code> feature. AFAICT, it introduces new implicit variables precisely when they would be inferred upon invocation; it's not only convenient, but also a method of checking as you write that your model of what the compiler can infer matches reality.)</p>\n<p>The other is the typeclass specific synthesis function. Which, tbqh, I don't understand nearly as well as implicits, but roughly speaking, it looks through all available instances for something of the right type (up to metavariables in the case of (semi)OutParam), looks back at the arguments to those instances, then tries to infer or synthesize the arguments recursively. </p>\n<p>In general, these are two distinct methods of generating instances and there's no guarantee they'll give the same result, but they will need to in order for the theorem invocation/function call to be sound -- after all, by the logic of the implicit argument inference, a specific instance is required for a later explicit argument to be defined in the first place. It <em>could</em> try and silently resolve in favor of one or the other (usually the implicit argument, I think), but that would be a bit of a footgun that would give surprising results -- this almost always means that there's an error in your code somewhere (usually an 'extra' or insufficiently-detailed instance definition), so better to 'fail fast' and report that error as soon as possible.</p>\n</blockquote>\n<p>Thanks, this exlains a lot! Do typeclasses always have to be \"synthesized\"? Could it be that it finds no available instance of the right type, but it can infer one implicitly, then it just uses the inferred one? I'm guessing no, because if that was the case I should have just be able to delete the <code>haveI</code>  line, and get no errors.</p>",
        "id": 433528229,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1713275712
    },
    {
        "content": "<p>That gets into \"I would like to know that too\", honestly ^.^;. (c.f.  my question at <a href=\"#narrow/stream/287929-mathlib4/topic/Help.20with.20instance.20search.20and.20.28semi.29OutParam\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Help.20with.20instance.20search.20and.20.28semi.29OutParam</a>, for example, where despite having exactly one instance in scope instance search can't find it.) <code>inferInstance</code> doesn't quite do the same thing as normal synthesis; it's more targeted, and its purpose is to bring an inference into 'scope' for typeclass inference. </p>\n<p>Something to keep in mind though is that the use of implicit arguments is AFAIK explicitly about whether or not the argument is <em>determined by later arguments to the same function</em> -- in my case, for example, the fact that there's only one possible argument because there's only one instance in scope is only relevant to typeclass synthesis, it's expected that implicit-argument-inference won't find it in a case like that unless it's specifically used, directly or indirectly, by another argument.</p>",
        "id": 433629498,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713314892
    }
]