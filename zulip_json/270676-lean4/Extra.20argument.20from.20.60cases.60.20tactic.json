[
    {
        "content": "<p>The <code>Or.casesOn</code> function takes <code>6</code> arguments:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">Or.casesOn</span>\n<span class=\"n\">Or.casesOn</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">inl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">inr</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">t</span>\n</code></pre></div>\n<p>namely <code>a b motive t inl inr</code>.</p>\n<p>Consider the following proof of the commutativity of <code>Or</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">or_comm</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">h</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">rename_i</span> <span class=\"n\">a</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span>\n  <span class=\"n\">assumption</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span>\n  <span class=\"n\">assumption</span>\n</code></pre></div>\n<p>Printing out the value of <code>or_comm</code> shows that despite having two motives, there is an extra argument <code>(Eq.refl h)</code> being applied to the result of <code>Or.casesOn</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">Or.casesOn</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">h_1</span> <span class=\"n\">h_2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Eq.symm</span> <span class=\"n\">h_2</span> <span class=\"bp\">▸</span> <span class=\"n\">Or.inr</span> <span class=\"n\">h_1</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">h_1</span> <span class=\"n\">h_2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Eq.symm</span> <span class=\"n\">h_2</span> <span class=\"bp\">▸</span> <span class=\"n\">Or.inl</span> <span class=\"n\">h_1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Why does the <code>cases</code> tactic generate this extraneous <code>Eq.refl h</code> and why could it not be bundled into the <code>inl</code> and <code>inr</code> motives?</p>",
        "id": 415963751,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1705474525
    },
    {
        "content": "<p>I think you should generally not read too much into the exact terms generated by a tactic</p>",
        "id": 415964201,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1705474833
    },
    {
        "content": "<blockquote>\n<p>Why does the cases tactic generate this extraneous Eq.refl h and why could it not be bundled into the inl and inr motives?</p>\n</blockquote>\n<p>This is an extra assumption where it keeps track of the relation between the original value (<code>h</code>) and the concrete value in the branch (<code>inl a</code> resp. <code>inl b</code>). Since these are props it’s not so useful and it hides them from you, but if you case split on value you sometimes care a lot about that equality. It’s what you get when you write <code>match h : x with  …</code>.</p>",
        "id": 415975062,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705480109
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/Extra.20argument.20from.20.60cases.60.20tactic/near/415975062\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Why does the cases tactic generate this extraneous Eq.refl h and why could it not be bundled into the inl and inr motives?</p>\n</blockquote>\n<p>This is an extra assumption where it keeps track of the relation between the original value (<code>h</code>) and the concrete value in the branch (<code>inl a</code> resp. <code>inl b</code>). Since these are props it’s not so useful and it hides them from you, but if you case split on value you sometimes care a lot about that equality. It’s what you get when you write <code>match h : x with  …</code>.</p>\n</blockquote>\n<p>is there a case where this would be visible? Why not bundle the <code>Eq.refl</code> term into the two branches of the motives? For example maybe we could have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">Or.casesOn</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">h_1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Eq.symm</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">▸</span> <span class=\"n\">Or.inr</span> <span class=\"n\">h_1</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">h_1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Eq.symm</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"n\">h</span><span class=\"o\">)</span>  <span class=\"bp\">▸</span> <span class=\"n\">Or.inl</span> <span class=\"n\">h_1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 416337615,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1705526360
    },
    {
        "content": "<p>I found this in the documentation of <code>CasesOn.lean</code> and this seems to be related to the <strong>remaining</strong> term?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">  Given a `casesOn` application `c` of the form</span>\n<span class=\"sd\">  ```</span>\n<span class=\"sd\">  casesOn As (fun is x =&gt; motive[i, xs]) is major  (fun ys_1 =&gt; (alt_1 : motive (C_1[ys_1])) ... (fun ys_n =&gt; (alt_n : motive (C_n[ys_n]) remaining</span>\n<span class=\"sd\">  ```</span>\n<span class=\"sd\">  and an expression `e : B[is, major]`, construct the term</span>\n<span class=\"sd\">  ```</span>\n<span class=\"sd\">  casesOn As (fun is x =&gt; B[is, x] → motive[i, xs]) is major (fun ys_1 (y : B[C_1[ys_1]]) =&gt; (alt_1 : motive (C_1[ys_1])) ... (fun ys_n (y : B[C_n[ys_n]]) =&gt; (alt_n : motive (C_n[ys_n]) e remaining</span>\n<span class=\"sd\">  ```</span>\n<span class=\"sd\">  We use `kabstract` to abstract the `is` and `major` from `B[is, major]`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">CasesOnApp.addArg</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">CasesOnApp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">arg</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">checkIfRefined</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">CasesOnApp</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n</code></pre></div>",
        "id": 416454250,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1705529504
    },
    {
        "content": "<p>Does that typecheck? are you pondering a different type signature for <code>casesOn</code> here?</p>\n<p>Probably it’s possible to hard-code that feature (providing that equality in the branches) in the <code>casesOn</code> eliminator, but if it can be done using a suitable <code>motive</code> instantiation by the tactic, then that’s more flexible, isn't it?</p>",
        "id": 416530278,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705570190
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/Extra.20argument.20from.20.60cases.60.20tactic/near/416530278\">said</a>:</p>\n<blockquote>\n<p>Does that typecheck? are you pondering a different type signature for <code>casesOn</code> here?</p>\n<p>Probably it’s possible to hard-code that feature (providing that equality in the branches) in the <code>casesOn</code> eliminator, but if it can be done using a suitable <code>motive</code> instantiation by the tactic, then that’s more flexible, isn't it?</p>\n</blockquote>\n<p>I think the motive would have to be changed</p>",
        "id": 416635517,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1705605938
    }
]