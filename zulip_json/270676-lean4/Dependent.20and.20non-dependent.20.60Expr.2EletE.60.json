[
    {
        "content": "<p>In <code>inductive Expr</code> we have the let-in expression:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"sd\">/--</span>\n<span class=\"sd\">  Let-expressions.</span>\n\n<span class=\"sd\">  **IMPORTANT**: The `nonDep` flag is for \"local\" use only. That is, a module should not \"trust\" its value for any purpose.</span>\n<span class=\"sd\">  In the intended use-case, the compiler will set this flag, and be responsible for maintaining it.</span>\n<span class=\"sd\">  Other modules may not preserve its value while applying transformations.</span>\n\n<span class=\"sd\">  Given an environment, a metavariable context, and a local context,</span>\n<span class=\"sd\">  we say a let-expression `let x : t := v; e` is non-dependent when it is equivalent</span>\n<span class=\"sd\">  to `(fun x : t =&gt; e) v`. In contrast, the dependent let-expression</span>\n<span class=\"sd\">  `let n : Nat := 2; fun (a : Array Nat n) (b : Array Nat 2) =&gt; a = b` is type correct,</span>\n<span class=\"sd\">  but `(fun (n : Nat) (a : Array Nat n) (b : Array Nat 2) =&gt; a = b) 2` is not.</span>\n\n<span class=\"sd\">  The let-expression `let x : Nat := 2; Nat.succ x` is represented as</span>\n<span class=\"sd\">  ```</span>\n<span class=\"sd\">  Expr.letE `x (.const `Nat []) (.lit (.natVal 2)) (.app (.const `Nat.succ []) (.bvar 0)) true</span>\n<span class=\"sd\">  ```</span>\n<span class=\"sd\">  -/</span>\n  <span class=\"bp\">|</span> <span class=\"n\">letE</span> <span class=\"o\">(</span><span class=\"n\">declName</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">type</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">body</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nonDep</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>What makes the example type correct? Is it because the type of the interior of the let is only determined after the argument of the let is evaluated?</p>",
        "id": 431205728,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1712194552
    },
    {
        "content": "<p>Within the body of a let statement, the declared variable is definitionally equal to its value. This behavior is an intrinsic part of dependent type theory as implemented in the kernel. It's not really about evaluation order per se</p>",
        "id": 431206756,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712195238
    },
    {
        "content": "<p>The simplest way to define it is to say that to check that <code>(let x : T := v; e) : U</code>, it suffices that <code>v : T</code> and <code>e[v/x] : U</code></p>",
        "id": 431206925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712195348
    },
    {
        "content": "<p>in other words, we never check <code>e</code> alone, we first expand all occurrences of <code>x</code> in <code>e</code></p>",
        "id": 431207064,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712195419
    },
    {
        "content": "<p>this is by contrast to <code>(fun x : T =&gt; e) v : U</code>, where to check this we need to show <code>v : T</code> and <code>x : T |- e : U</code>, which is to say that when typechecking <code>e</code> you don't know anything in particular about <code>x</code> other than its type</p>",
        "id": 431208405,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712196293
    }
]