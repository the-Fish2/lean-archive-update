[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bar</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bar</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">U</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">U</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\">  </span><span class=\"c1\">-- invalid constructor ⟨...⟩, expected type must be an inductive type</span>\n</code></pre></div>\n<p>This used to work in earlier Lean versions, does anyone know what change broke this?</p>",
        "id": 445837700,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1718888445
    },
    {
        "content": "<p>Hmmm... the following example still succeeds:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">U</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">U</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 445843024,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1718889457
    },
    {
        "content": "<p>Just noticed that adding <code>@[reducible]</code> actually fixes it</p>",
        "id": 445843181,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1718889483
    },
    {
        "content": "<p>What is the meaning of <code>@[reducible]</code> and <code>@[semireducible]</code> nowadays? <span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> I think you told  me the other day...</p>",
        "id": 445843775,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1718889608
    },
    {
        "content": "<p><code>dsimp [Foo]</code> also fails to simplify the type (<code>simp [Foo]</code> succeeds, but modifies the constructed term).</p>",
        "id": 445843932,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1718889641
    },
    {
        "content": "<p>It means \"unfold this more eagerly\". The <del>unification algorithm</del> elaborator will unfold reducible definitions earlier, and many tactics will unfold reducible definitions, or index/match terms up to reducible definitions. This mostly affects <code>simp</code>, <code>rw</code> and similar tactics. But it's up to each tactic's implementation how it deals with reducible definitions, so it's hard to give a full list of what the attribute does.</p>",
        "id": 445844452,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1718889739
    },
    {
        "content": "<p><code>@[semireducible]</code> also suffices for the example to work correctly, so apparently the elaborator(?) also looks into the attribute?</p>",
        "id": 445845075,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1718889852
    },
    {
        "content": "<p>The elaborator definitely looks at these tags as well, but I'm surprised tagging it with <code>semireducible</code> fixes it, since I thought that was the default transparency. Maybe it isn't for definitions defined by well-founded recursion...?</p>",
        "id": 445846500,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1718890134
    },
    {
        "content": "<p>wfrec is now irreducible by default.</p>",
        "id": 445846722,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1718890180
    },
    {
        "content": "<p>For performance reasons?</p>",
        "id": 445846886,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1718890212
    },
    {
        "content": "<p>I think so. Evaluation of a function defined by wfrec involves the reduction of the accessibility proofs, which can be large. So it was decided that it's safer to mark these functions as irreducible by default (and you can still <code>simp</code> with the generated equation lemmas). However, tagging a wfrec function as semireducible manually is still fine and supported. (<code>reducible</code> shouldn't be used for recursive functions in general afaik.)</p>",
        "id": 445847692,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1718890398
    },
    {
        "content": "<p>It's not just performance. A wfrec function is defeq to some complicated construction involving <code>WellFounded.fix</code>, and this construction is supposed to be “internal” and not visible to the user. If a proof relies on this definitional equality somehow, then should the internal construction change, this may break the proof. This is maybe ok if the user asks for it explicitly (using <code>unseal</code> or <code>@[semireducible]</code>), but it seems the default should be the safer <code>@[irreducible]</code>.</p>",
        "id": 445856653,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1718892124
    }
]