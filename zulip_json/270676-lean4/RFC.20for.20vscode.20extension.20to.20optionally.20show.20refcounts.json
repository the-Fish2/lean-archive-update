[
    {
        "content": "<p>This is probably a moonshot request, but I wondered if it is possible for the extension to tag def parameters with their reference count in the definition (shown in faded small text like the rust extension does for showing types and lifetimes). This feature could be toggled by users.</p>",
        "id": 438559659,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715687748
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/RFC.20for.20vscode.20extension.20to.20optionally.20show.20refcounts/near/438559659\">said</a>:</p>\n<blockquote>\n<p>This is probably a moonshot request, but I wondered if it is possible for the extension to tag def parameters with their reference count in the definition (shown in faded small text like the rust extension does for showing types and lifetimes). This feature could be toggled by users.</p>\n</blockquote>\n<p>What do you mean by refcount here?</p>",
        "id": 438593153,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1715698187
    },
    {
        "content": "<p>I want to track whether a structure such as an array is updated in-place or a copy is made</p>",
        "id": 438607679,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715702655
    },
    {
        "content": "<p>I understand that this happens depending on the reference count for the object</p>",
        "id": 438607709,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715702668
    },
    {
        "content": "<p>Unfortunately, that's pretty moonshot: The refcount is a dynamic property that you cannot in general know until you run the program. It's at least as hard as wanting to see the value of a function's parameter, in other words, a debugger.</p>",
        "id": 438609019,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1715703092
    },
    {
        "content": "<p>Okay, but that's digging into FP's equivalent of a call stack. What about locally?</p>",
        "id": 438609479,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715703240
    },
    {
        "content": "<p>Surely if there are two copies of an object these copies are made locally</p>",
        "id": 438609630,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715703279
    },
    {
        "content": "<p>In some function</p>",
        "id": 438609648,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715703284
    },
    {
        "content": "<p>What would a pathological counterexample look like?</p>",
        "id": 438609753,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715703311
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/RFC.20for.20vscode.20extension.20to.20optionally.20show.20refcounts/near/438609479\">said</a>:</p>\n<blockquote>\n<p>Okay, but that's digging into FP's equivalent of a call stack. What about locally?</p>\n</blockquote>\n<p>There is no equivalent of a call stack, lean compiles to C, there is a real call stack.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/270676-lean4/topic/RFC.20for.20vscode.20extension.20to.20optionally.20show.20refcounts/near/438609630\">said</a>:</p>\n<blockquote>\n<p>Surely if there are two copies of an object these copies are made locally</p>\n</blockquote>\n<p>If you make a copy of something you do that because the RC was &gt; 1 but you wanted to change it. If you mean reference then you can still not figure them out statically. If you have a branch where one side uses a value and the other does not the ref count for that value after that branch is fuzzy. Same for passing values to other functions where they might or might not be referenced in the return value etc etc.</p>",
        "id": 438612025,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1715704015
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266262\">@Reed Mullanix</span> and I have been talking about implementing something like a linter for statically analyzing the IR to identify when things marked as linear are copied, using something like quantitative type theory. But it's all still very abstract. <span class=\"user-mention\" data-user-id=\"221921\">@Marc Huisinga</span> also had some work on this, unsure what state it ended up in though. I think it would be useful to try to get something working even if it has to be very approximate in cases, because debugging IR is no fun at all and it's not even good enough to write linear code by hand because the compiler itself breaks linearity accidentally.</p>",
        "id": 438651639,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1715718937
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> : I know this is not deterministically possible, but there must be some heuristics or some subset of cases where the extension could offer a clue by maybe just highlighting the references that are most definitely linear (in a conservative way)?</p>",
        "id": 438652231,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715719132
    },
    {
        "content": "<p>Sorry this message was in my drafts 3 hours ago</p>",
        "id": 438652266,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715719147
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> : Is it viable to have a shadow type system imposed on a language that checks linearity on the side using some conservative heuristics and reports violations, but doesn't interfere in compilation otherwise? I have in mind the way liquid haskell is integrated into haskell.</p>",
        "id": 438652655,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1715719293
    },
    {
        "content": "<p>The work by Marc mentioned by Mario is from here: <a href=\"https://pp.ipd.kit.edu/uploads/publikationen/huisinga23masterarbeit.pdf\">https://pp.ipd.kit.edu/uploads/publikationen/huisinga23masterarbeit.pdf</a> The closing remark reads:</p>\n<blockquote>\n<p>Our type theory lacks support for uniqueness attributes in higher-order functions, type inference, as well as support for attribute polymorphism. Our escape analysis produces non-satisfactory results on recursive functions over recursive types, inhibiting the borrowing of arguments to such functions.</p>\n<p>...</p>\n<p>For higher-order functions, we have evaluated all existing approaches known to us and made a recommendation for an approach that we think is the most suitable one to implement in the future. For borrowing, we have made suggestions to improve the implementation provided in this thesis. For the topics of type inference, polymorphism and Lean 4 integration, we have outlined steps that need to be taken in order to complete the implementation thereof.</p>\n</blockquote>\n<p>So even with this prior work there would still be a ton to do to make it feasible to have this in practice.</p>",
        "id": 438653520,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1715719604
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/RFC.20for.20vscode.20extension.20to.20optionally.20show.20refcounts/near/438651639\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"266262\">Reed Mullanix</span> and I have been talking about implementing something like a linter for statically analyzing the IR to identify when things marked as linear are copied, using something like quantitative type theory. But it's all still very abstract. <span class=\"user-mention silent\" data-user-id=\"221921\">Marc Huisinga</span> also had some work on this, unsure what state it ended up in though. I think it would be useful to try to get something working even if it has to be very approximate in cases, because debugging IR is no fun at all and it's not even good enough to write linear code by hand because the compiler itself breaks linearity accidentally.</p>\n</blockquote>\n<p>Note that the compiler does not only break linearity <em>accidentally</em> there are cases where it is straight up fine to break linearity. I encountered this in code where two arrays of equal size (but in fact different member type) are allocated after one another. The compiler will perform CSE on the array creating functions and copy the second array when it is modified for the first time. This is a completely fine modification as it doesn't induce any additional load that would have been there without CSE. So even properly detecting a linearity failure at runtime is non trivial. The best approach I've found so far (and how I e.g. tracked down the HashMap.erase issue) is to add a modification to the runtime that tracks \"generations of cloned arrays\" and if a generation chain copies arrays of non trivial size too many times in a row it is decided that its most likely a true linearity issue and I make it crash.</p>\n<p>If anyone was able to come up with a reliable way to perfectly detect linearity issues <em>at runtime</em> (without modifying the runtime and making it notably slower like I did) this would already be a gigantic step forward. <code>dbgTraceIfShared</code> is also suboptimal as simply introducing it <em>can</em> lead to linearity issues in of itself.</p>",
        "id": 438654344,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1715719862
    },
    {
        "content": "<blockquote>\n<p>I encountered this in code where two arrays of equal size (but in fact different member type) are allocated after one another. The compiler will perform CSE on the array creating functions and copy the second array when it is modified for the first time. This is a completely fine modification as it doesn't induce any additional load that would have been there without CSE.</p>\n</blockquote>\n<p>I assume this is only CSE after erasing types? In any case I don't really agree this is a good tradeoff, the compiler will often move array creation into statics, replacing a fresh allocation with a copy from an existing allocation, which isn't really better (the plain allocation function can often do a better job, e.g. if the fill value is a constant and can be built using <code>calloc</code> or <code>memset</code>, and the extra static allocation is pure overhead and might even cause memory issues if it's a really big fixed size array which now has to exist twice in the program).</p>",
        "id": 438670824,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1715725812
    },
    {
        "content": "<p>Yes this is CSE after partial type erasure.</p>",
        "id": 438671149,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1715725955
    },
    {
        "content": "<blockquote>\n<p>Note that the compiler does not only break linearity <em>accidentally</em> there are cases where it is straight up fine to break linearity.</p>\n</blockquote>\n<p>The version of this idea I was thinking about is that the user would annotate a particular variable as being unique, meaning either that the compiler should try to optimize the function with the incoming assumption that the value is unique and copy if needed <em>before</em> calling it rather than inside the function (this will often cut out an extra if statement in the inner loop of tight loops like <code>List.reverseCore</code>), or for linting purposes as an indication that any copies of the value in the function should be flagged.</p>",
        "id": 438671596,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1715726082
    },
    {
        "content": "<p>I think it is difficult for the compiler to do a better job of linearity analysis than it is doing already without additional annotations because the information is simply not present in the code. You might be able to do better with some kind of instrumented dynamic analysis but this doesn't sound very easy/noninvasive</p>",
        "id": 438671839,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1715726182
    }
]