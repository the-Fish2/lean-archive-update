[
    {
        "content": "<p>Hello,</p>\n<p>I'm currently trying to use dependently typed SQL quries to check for composition during compile time as part of my <a href=\"https://github.com/FWuermse/lean-postgres/blob/feature-pqlib-ffis/Postgres/Schema/QuerySyntax.lean#L248-L254\">Postgres library</a>.</p>\n<p>I'm having a type that uses a tactic as auto param:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">SQLQuery</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Field</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Field</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SQLSelect</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">SQLFrom</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">SQLProp</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">SQLQuery</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>During elaboration I use <code>mkAppM' (mkApp2 (mkConst `SQLQuery.mk) ftyp styp) #[sel, frm, whr]</code>, purpousely leaving out the auto param as I want to use simp for the subset proof of the Lists.</p>\n<p>When I check the syntax I get those types:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">schema</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Field</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"s2\">\"myTable\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field.nat</span><span class=\"w\"> </span><span class=\"s2\">\"id\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Field.nat</span><span class=\"w\"> </span><span class=\"s2\">\"name\"</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"s2\">\"otherTable\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field.date</span><span class=\"w\"> </span><span class=\"s2\">\"date\"</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">SELECT</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"n\">FROM</span><span class=\"w\"> </span><span class=\"n\">myTable</span><span class=\"w\"> </span><span class=\"n\">schema</span>\n<span class=\"k\">#check</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"c1\">-- x (h : [Field.nat \"name\"] ⊆ [Field.nat \"id\", Field.nat \"name\"] := by simp) : SQLQuery [Field.nat \"name\"]</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"k\">#check</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"c1\">-- y : SQLQuery [Field.nat \"name\"]</span>\n</code></pre></div>\n<p>I'm wondering if it's possible to fill that parameter with it's predefined auto param during elaboration (and solve the goal with simp) so that def x will already yield the type <code>SQLQuery [Field.nat \"id\", Field.nat \"name\"]</code>. I'm rather new to metaprogramming and couldn't find anything that could solve this problem when looking through Lean/Elab/*. Also I'd be happy to find out whether this is even the right approach to check List subsumtion of such queries at compile time.</p>",
        "id": 442519994,
        "sender_full_name": "Florian Würmseer",
        "timestamp": 1717504699
    },
    {
        "content": "<p>Good question, I don't see how to do this!</p>",
        "id": 442671958,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1717551859
    },
    {
        "content": "<p>I was able to achieve my expected behaviour by invoking <code>elabAppArgs</code> on the curry of the last argument. It seems to work but I don't exactly know what the main purpose of <code>elabAppArgs</code> is and whether I'm abusing it for this purpose. Is it this generally a good idea?</p>",
        "id": 442734274,
        "sender_full_name": "Florian Würmseer",
        "timestamp": 1717579001
    },
    {
        "content": "<p>I think using <code>elabAppArgs</code> is a good idea if you want to reproduce how function applications are actually elaborated, and if you're currently elaborating expressions. The <code>mkAppM</code> family of app builders do not integrate into the elaborator, and they are self-contained, which makes them less good in elaboration contexts.</p>",
        "id": 442856169,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1717610336
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466861\">Florian Würmseer</span> has marked this topic as resolved.</p>",
        "id": 442858303,
        "sender_full_name": "Notification Bot",
        "timestamp": 1717611023
    }
]