[
    {
        "content": "<p>I'm trying to write a function that iterates onver a <code>Subarray</code> of <code>BitVec</code> and appends them all together. I think I have something that should in principle work, but fails to typecheck because (I think) lean4 is unable to convince itself of the equality of syntactically different expressions in various <code>BitVec</code> indicies. Is there a way to help it along / is there a better way to write this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">joinBytes</span> <span class=\"o\">(</span><span class=\"n\">bytes</span> <span class=\"o\">:</span> <span class=\"n\">Subarray</span> <span class=\"o\">(</span><span class=\"n\">BitVec</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">BitVec</span> <span class=\"o\">(</span><span class=\"n\">bytes.size</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">go</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">bytes.size</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">:</span> <span class=\"n\">BitVec</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">BitVec</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n    <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n       <span class=\"c\">/-</span>\n<span class=\"cm\">       application type mismatch</span>\n<span class=\"cm\">         ite (n = ↑0) res</span>\n<span class=\"cm\">       argument</span>\n<span class=\"cm\">         res</span>\n<span class=\"cm\">       has type</span>\n<span class=\"cm\">         BitVec m : Type</span>\n<span class=\"cm\">       but is expected to have type</span>\n<span class=\"cm\">         BitVec (m + ↑n * b) : Type</span>\n<span class=\"cm\">       -/</span>\n       <span class=\"k\">then</span> <span class=\"n\">res</span>\n       <span class=\"k\">else</span> <span class=\"n\">go</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">BitVec.append</span> <span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">bytes</span><span class=\"o\">[</span><span class=\"n\">bytes.size</span> <span class=\"bp\">-</span> <span class=\"n\">n</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">)))</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  type mismatch</span>\n<span class=\"cm\">    go (Fin.last (Subarray.size bytes)) nil</span>\n<span class=\"cm\">  has type</span>\n<span class=\"cm\">    BitVec (0 + ↑(Fin.last (Subarray.size bytes)) * b) : Type</span>\n<span class=\"cm\">  but is expected to have type</span>\n<span class=\"cm\">    BitVec (Subarray.size bytes * b) : Type</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">go</span> <span class=\"o\">(</span><span class=\"n\">Fin.last</span> <span class=\"n\">bytes.size</span><span class=\"o\">)</span> <span class=\"n\">BitVec.nil</span>\n</code></pre></div>",
        "id": 432280284,
        "sender_full_name": "dxo",
        "timestamp": 1712678494
    },
    {
        "content": "<p>ah, I have discovered the <code>▸</code> operator!  this seems to be exactly what I need</p>",
        "id": 432299794,
        "sender_full_name": "dxo",
        "timestamp": 1712683832
    },
    {
        "content": "<p>I think you want <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BitVec.cast#doc\">docs#BitVec.cast</a> instead. <code>Eq.rec</code> (which that operator is notation for) tends to block reduction and be hard to prove equalities about, so we often use type-specific versions</p>",
        "id": 432313071,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1712687280
    },
    {
        "content": "<p>oh, nice tip thanks!</p>",
        "id": 432313814,
        "sender_full_name": "dxo",
        "timestamp": 1712687443
    },
    {
        "content": "<p>that cleaned things up a bit</p>",
        "id": 432313837,
        "sender_full_name": "dxo",
        "timestamp": 1712687448
    },
    {
        "content": "<p>I managed to get everything working with <code>▸</code>, but I'm still struggling with the proof of safe indexing</p>",
        "id": 432313966,
        "sender_full_name": "dxo",
        "timestamp": 1712687486
    },
    {
        "content": "<p>I think we have a version of this in mathlib called <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=finPiFinEquiv#doc\">docs#finPiFinEquiv</a></p>",
        "id": 432316171,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712688263
    },
    {
        "content": "<p>(though to use it you need to pull the sum through the exponent via a cast)</p>",
        "id": 432316348,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712688333
    },
    {
        "content": "<p>Finally have a version that type checks: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">joinBytes</span> <span class=\"o\">(</span><span class=\"n\">bytes</span> <span class=\"o\">:</span> <span class=\"n\">Subarray</span> <span class=\"o\">(</span><span class=\"n\">BitVec</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">BitVec</span> <span class=\"o\">(</span><span class=\"n\">bytes.size</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">BitVec.cast</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"n\">go</span> <span class=\"n\">bytes.size</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"n\">BitVec.nil</span>\n  <span class=\"n\">where</span>\n    <span class=\"n\">go</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">thm</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">bytes.size</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">:</span> <span class=\"n\">BitVec</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">BitVec</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n    <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BitVec.cast</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"n\">res</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">x</span>\n      <span class=\"bp\">=&gt;</span> <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">x</span>\n         <span class=\"k\">have</span> <span class=\"n\">add_thm</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n           <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.succ_mul</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_assoc</span><span class=\"o\">]</span>\n           <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_comm</span><span class=\"o\">]</span>\n         <span class=\"k\">have</span> <span class=\"n\">idx_thm</span> <span class=\"o\">:</span> <span class=\"n\">bytes.size</span> <span class=\"bp\">-</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">bytes.size</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n           <span class=\"k\">have</span> <span class=\"n\">npos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n           <span class=\"k\">have</span> <span class=\"n\">szpos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">bytes.size</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.lt_of_lt_of_le</span> <span class=\"n\">npos</span> <span class=\"n\">thm</span>\n           <span class=\"n\">apply</span> <span class=\"n\">Nat.sub_lt</span>\n           <span class=\"n\">apply</span> <span class=\"n\">szpos</span>\n           <span class=\"n\">assumption</span>\n         <span class=\"k\">let</span> <span class=\"n\">next</span> <span class=\"o\">:=</span> <span class=\"n\">BitVec.append</span> <span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">bytes</span><span class=\"o\">[</span><span class=\"n\">bytes.size</span> <span class=\"bp\">-</span> <span class=\"n\">n</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"n\">idx_thm</span><span class=\"o\">))</span>\n         <span class=\"n\">BitVec.cast</span> <span class=\"n\">add_thm</span> <span class=\"bp\">$</span> <span class=\"n\">go</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_of_succ_le</span> <span class=\"n\">thm</span><span class=\"o\">)</span> <span class=\"n\">next</span>\n</code></pre></div>",
        "id": 432317827,
        "sender_full_name": "dxo",
        "timestamp": 1712688923
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Joining.20an.20Array.20of.20.60BitVec.60.20into.20a.20larger.20.60BitVec.60/near/432316171\">said</a>:</p>\n<blockquote>\n<p>I think we have a version of this in mathlib called <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=finPiFinEquiv#doc\">docs#finPiFinEquiv</a></p>\n</blockquote>\n<p>Interesting! Thank you. I got rid of the <code>Fin</code> in the end, it was kinda too much to think about <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span>. Maybe I'll try again now I have a working version with nats and evidence passing.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Joining.20an.20Array.20of.20.60BitVec.60.20into.20a.20larger.20.60BitVec.60/near/432316348\">said</a>:</p>\n<blockquote>\n<p>(though to use it you need to pull the sum through the exponent via a cast)</p>\n</blockquote>\n<p>I don't understand this sentance at all I'm afraid <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 432318035,
        "sender_full_name": "dxo",
        "timestamp": 1712689007
    },
    {
        "content": "<p>Figured out a much cleaner version based on a dependent fold:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Vector</span>\n<span class=\"kn\">open</span> <span class=\"n\">Vector</span>\n<span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dfoldr</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n           <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">sz</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n           <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">tp</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n           <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">step</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">idx</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">tp</span> <span class=\"n\">idx</span> <span class=\"bp\">→</span> <span class=\"n\">tp</span> <span class=\"o\">(</span><span class=\"n\">idx</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n           <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:</span> <span class=\"n\">tp</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n           <span class=\"bp\">→</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">sz</span>\n           <span class=\"bp\">→</span> <span class=\"n\">tp</span> <span class=\"n\">sz</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">base</span><span class=\"o\">,</span> <span class=\"n\">Vector.nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">base</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">step</span><span class=\"o\">,</span> <span class=\"n\">base</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">step</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">head</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dfoldr</span> <span class=\"n\">p</span> <span class=\"n\">step</span> <span class=\"n\">base</span> <span class=\"o\">(</span><span class=\"n\">tail</span> <span class=\"n\">v</span><span class=\"o\">))</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">joinBytes</span> <span class=\"o\">(</span><span class=\"n\">bytes</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">BitVec</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">sz</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">BitVec</span> <span class=\"o\">(</span><span class=\"n\">sz</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"n\">cast_thm</span> <span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">mul_succ</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">]</span>\n  <span class=\"n\">dfoldr</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BitVec</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">val</span> <span class=\"n\">acc</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">BitVec.cast</span> <span class=\"n\">cast_thm</span> <span class=\"o\">(</span><span class=\"n\">BitVec.append</span> <span class=\"n\">val</span> <span class=\"n\">acc</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">BitVec.cast</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"n\">BitVec.nil</span><span class=\"o\">)</span>\n    <span class=\"n\">bytes</span>\n</code></pre></div>",
        "id": 432602233,
        "sender_full_name": "dxo",
        "timestamp": 1712790353
    },
    {
        "content": "<p>I couldn't find <code>dfoldr</code> or something like it anywhere in <code>Init</code> / <code>Std</code> /  <code>Mathlib</code>.Am I missing it somewhere? <code>joinBytes</code> was so much easier to write once I understood how to define <code>dfoldr</code>.</p>",
        "id": 432602875,
        "sender_full_name": "dxo",
        "timestamp": 1712790819
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"677008\">@dxo</span>, I have a PR about this at <a href=\"https://github.com/leanprover/lean4/pull/3727\">https://github.com/leanprover/lean4/pull/3727</a>. It's currently a bit abandoned, but if you wanted to review it / suggest changes, etc, perhaps we can resume progress on it.</p>",
        "id": 433641359,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1713324161
    }
]