[
    {
        "content": "<p>Hi all, I am going through FP in Lean. When reading about partial functions in <a href=\"https://lean-lang.org/functional_programming_in_lean/hello-world/cat.html\">https://lean-lang.org/functional_programming_in_lean/hello-world/cat.html</a> i saw: <code>The dump function is declared partial, because it calls itself recursively on input that is not immediately smaller than an argument.</code> which makes sense. However, in section below it where process is defined i see: <code>process does not need to be marked partial because it is structurally recursive. Each recursive call is provided with the tail of the input list, and all Lean lists are finite. Thus, process does not introduce any non-termination.</code>. However this did not make sense since process in turn invokes/composed from <code>dump</code> so if dump does not terminate, we can not say <code>process</code> will terminate. So why does <code>process</code> not require to be marked partial? Why is partial not transitive i.e. if you call func which is not guaranteed to terminate then calling function would also not terminate right?</p>\n<p>Would love to understand this better. Thanks for the help.</p>",
        "id": 420758821,
        "sender_full_name": "Param Reddy",
        "timestamp": 1707528635
    },
    {
        "content": "<p>Partial fulfills three main jobs:</p>\n<ol>\n<li>Allows you to define functions without termination proof</li>\n<li>Makes this sound in the type system by<br>\n  a) forcing you to prove that the return type is inhabited<br>\n  b) Makes it impossible to unwrap the function definition</li>\n</ol>\n<p>The last two things are what make it possible to use partial without infecting other functions. Even if you are defining a function that does not terminate using a partial one it will be impossible for you to show this because partial is completely opaque + you cannot use the return value that you get to prove false as that type must be inhabited.</p>",
        "id": 420784138,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1707555896
    },
    {
        "content": "<p>Thanks Henrik for the reply. Any reference where i can read for more details? Some things like \"unwrap  the function\", \"opaque\" are not clear to me to fully appreciate understanding this. </p>\n<p>Also Reg (1) I am guessing lean handles functions differently when it knows functions terminate. Any pointers to how lean treats functions which carry termination proof vs ones which dont?</p>",
        "id": 421327120,
        "sender_full_name": "Param Reddy",
        "timestamp": 1707859092
    },
    {
        "content": "<p>Hm, I don't see the opaque keyword explained in the user manual. Here's a quick rundown:</p>\n<ul>\n<li>Definitions<ul>\n<li>You can define a symbol as an abbreviation for another term. So <code>Nat.add</code> is a definition which abbreviates a term like <code>Nat.rec ...</code></li>\n<li>You can \"unfold\" definitions, so-called \"delta-reduction\", where you substitute a symbol's definition for the symbol. This is the <code>unfold</code> (or <code>rw</code> or <code>simp</code>) tactic in Lean, and also what the typechecker does when checking if two terms are definitionally equal, and also what happens during kernel reduction.</li>\n<li>Guaranteed sound: <code>def mySymbol : MyType := ...</code> since you provided a value of type <code>MyType</code>, the type is inhabited &amp; the definition is sound</li>\n<li>Computable in the kernel and the runtime (by substituting a symbol for its definition/\"running the function\")</li>\n</ul>\n</li>\n<li>Axioms<ul>\n<li>An axiom is a symbol added to the context without a definition</li>\n<li>This can be unsound, because for example I can say <code>axiom proofOfFalse : False</code> and Lean will not complain. We use axioms for e.g. <code>Classical.choice</code>, which we can prove at a meta-theoretic level is sound.</li>\n<li>Noncomputable in both the kernel and the runtime</li>\n</ul>\n</li>\n<li>Opaque definitions<ul>\n<li>Constants (old terminology) or \"opaque definitions\" are something between definitions and axioms</li>\n<li>The type <em>must be <code>Nonempty</code> or <code>Inhabited</code></em>, which guarantees opaque definitions are sound</li>\n<li>Cannot be unfolded in proofs, and noncomputable in the kernel</li>\n<li><em>Can be computable in the runtime</em>. In particular, you can provide a definition that the compiler compiles to C is then executable</li>\n</ul>\n</li>\n</ul>\n<p>So, with all that said, <code>partial</code> is an <code>opaque</code> definition, which uses the potentially non-terminating body of the function as the input to the compiler. So, for partial definitions:</p>\n<ul>\n<li>the type must be <code>Nonempty</code> or <code>Inhabited</code> (try <code>partial def whoops : False := whoops</code> to see that error message)</li>\n<li>it is computable at runtime, using the potentially non-terminating function body</li>\n<li>it is not reducible/unfoldable/computable in the kernel. in particular this means you cannot prove anything about what the symbol evaluates to exactly. it looks like an axiom, when doing proofs.</li>\n</ul>",
        "id": 421334005,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707862331
    },
    {
        "content": "<p>I'm not sure if the manual explains the distinction between kernel reduction and runtime execution, though there are probably some good explanations of that distinction somewhere on zulip :D</p>",
        "id": 421334655,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707862650
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/270676-lean4/topic/Usage.20of.20partial.20functions.20in.20total.20function/near/421334005\">said</a>:</p>\n<blockquote>\n<p>Hm, I don't see the opaque keyword explained in the user manual.</p>\n</blockquote>\n<p>(Does anyone know where I send a PR to add this to the manual?)</p>",
        "id": 421335528,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707863076
    },
    {
        "content": "<p>I assume it's the lean4 repo (since that seems to be where the manual source is?) but the contributing guidelines don't mention the manual from what I can see</p>",
        "id": 421335659,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707863153
    },
    {
        "content": "<p>Thanks James. Learning more here from this discussion.<br>\nIs there a place where i can read more about kernel vs runtime? Till now I was thinking that only way to compute in lean was through beta reduction and rec reduction on inductive types. From your description seems like there are two computation engines (kernel and runtime) which can marshal data back and forth? (Guessing this is because Lean4 is also a programming language also?)</p>",
        "id": 421337012,
        "sender_full_name": "Param Reddy",
        "timestamp": 1707863829
    },
    {
        "content": "<p>Maybe not reading but I feel like <span class=\"user-mention\" data-user-id=\"243791\">@David Renshaw</span>'s video could be helpful? <a href=\"https://www.youtube.com/watch?v=FOt-GsiNJmU\">https://www.youtube.com/watch?v=FOt-GsiNJmU</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"FOt-GsiNJmU\" href=\"https://www.youtube.com/watch?v=FOt-GsiNJmU\"><img src=\"https://uploads.zulipusercontent.net/2ff43a8d3c140fbd943fb008c78e6331a4cbb94b/68747470733a2f2f692e7974696d672e636f6d2f76692f464f742d4773694e4a6d552f64656661756c742e6a7067\"></a></div>",
        "id": 421341307,
        "sender_full_name": "Thea Brick",
        "timestamp": 1707866149
    },
    {
        "content": "<p>They are essentially completely disjoint modes of computation. If I understand correctly, there's actually 3 ways to run Lean</p>\n<ul>\n<li><em>kernel</em>: the soundness critical thing</li>\n<li><em>interpreter</em>: potentially unsound, but can see through <code>opaque</code>s, run <code>partial</code>s, and call out to external functions implemented in C*</li>\n<li><em>compiler</em>: same as the evaluator but AOT compiles your code down to C, which is then compiled to machine code via the LLVM toolchain<br>\n(*not 100% confident what the interpreter can do)</li>\n</ul>",
        "id": 421342507,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707866784
    },
    {
        "content": "<p>The kernels evaluation capabilities are also more powerful than the interpreter or compiler as it is able to operate on open terms.</p>",
        "id": 421343024,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1707867071
    },
    {
        "content": "<p>But of course interrpeter and compiler evaluation are drastically faster</p>",
        "id": 421343041,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1707867088
    },
    {
        "content": "<p>There is a way to get back from the interpreter/compiler to the kernel, relying on the \"trustCompiler\" axiom, called native decide. Not sure that is particularly relevant here, though</p>",
        "id": 421343298,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707867240
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/Usage.20of.20partial.20functions.20in.20total.20function/near/421343024\">said</a>:</p>\n<blockquote>\n<p>The kernels evaluation capabilities are also more powerful than the interpreter or compiler as it is able to operate on open terms.</p>\n</blockquote>\n<p>Wont capabilities be independent? Saying that since sems like kernel will not evaluate partials while kernel can evaluate open term.</p>\n<p>Also by open terms, I am guessing you eval 1 + x to x + 1?  Am i correct in understanding this?</p>",
        "id": 421517040,
        "sender_full_name": "Param Reddy",
        "timestamp": 1707938916
    },
    {
        "content": "<p>No 1+x is not reducible to x + 1 (actually im not sure withotu checking, it depends on which argument Nat.add recurses on). Open terms means that it can for example firgure out that (fun x =&gt; x + 2 + 3) is the same as (fun x =&gt; x + 5) because it can look under the binder without having an explicit value for x. So it will look just at <code>x + 2 + 3</code> and figure out stuff based on that.</p>",
        "id": 421526254,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1707942215
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"601254\">Thea Brick</span> <a href=\"#narrow/stream/270676-lean4/topic/Usage.20of.20partial.20functions.20in.20total.20function/near/421341307\">said</a>:</p>\n<blockquote>\n<p>Maybe not reading but I feel like <span class=\"user-mention silent\" data-user-id=\"243791\">David Renshaw</span>'s video could be helpful? <a href=\"https://www.youtube.com/watch?v=FOt-GsiNJmU\">https://www.youtube.com/watch?v=FOt-GsiNJmU</a></p>\n</blockquote>\n<p>Awesome video to understand this better. Thanks for the pointer. Looks like I keep getting more questions as i dig deeper. Why wellfounded and not direct recursion in the example. But will stop so that we don't overflow the stack for this thread.</p>",
        "id": 421550527,
        "sender_full_name": "Param Reddy",
        "timestamp": 1707952904
    }
]