[
    {
        "content": "<p>Hello everybody! I am tackling a programming <a href=\"https://dmoj.ca/problem/ccc19s2\">problem</a> that involves the <a href=\"https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\">Sieve of Eratosthenes</a>, meaning I want to precalculate the prime numbers up to 2000000 (2M). The first naive approach was the pure functional one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fromTo</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">·+</span><span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"bp\">-</span><span class=\"n\">l</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">primes</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">go</span> <span class=\"o\">(</span><span class=\"n\">fromTo</span> <span class=\"mi\">2</span> <span class=\"mi\">2000000</span><span class=\"o\">)</span>\n  <span class=\"n\">where</span>\n    <span class=\"n\">go</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span>\n    <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p</span> <span class=\"o\">::</span> <span class=\"n\">go</span> <span class=\"o\">(</span><span class=\"n\">xs.filter</span>  <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">%</span> <span class=\"n\">p</span> <span class=\"bp\">!=</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>No, it would'nt even run.<br>\nTo make it more feasible, i diverged to a imperative approach. Now I will try to generate a <code>is_prime : Array Bool</code> that tells me what I need to know. I arrived at this code, based on a Rust submission that worked:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Range with `[l,r)` step `s` -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">fromToStep</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">·+</span><span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">·*</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"n\">range</span> <span class=\"o\">((</span><span class=\"n\">r</span><span class=\"bp\">-</span><span class=\"n\">l</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">LIM</span> <span class=\"o\">:=</span> <span class=\"mi\">2000000</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sieve</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">Array.mk</span> <span class=\"bp\">$</span> <span class=\"n\">replicate</span> <span class=\"o\">(</span><span class=\"n\">LIM</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">true</span>\n  <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">p.set</span><span class=\"bp\">!</span> <span class=\"mi\">0</span> <span class=\"n\">false</span>\n  <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">p.set</span><span class=\"bp\">!</span> <span class=\"mi\">1</span> <span class=\"n\">false</span>\n  <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">fromToStep</span> <span class=\"mi\">4</span> <span class=\"o\">(</span><span class=\"n\">LIM</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"mi\">2</span> <span class=\"k\">do</span>\n    <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">p.set</span><span class=\"bp\">!</span> <span class=\"n\">i</span> <span class=\"n\">false</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n  <span class=\"n\">while</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">LIM</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"n\">p.get</span><span class=\"bp\">!</span> <span class=\"n\">i</span> <span class=\"k\">then</span>\n      <span class=\"n\">for</span> <span class=\"n\">j</span> <span class=\"k\">in</span> <span class=\"n\">fromToStep</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">*</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">LIM</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n        <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">p.set</span><span class=\"bp\">!</span> <span class=\"n\">j</span> <span class=\"n\">false</span>\n    <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n  <span class=\"n\">return</span> <span class=\"n\">p</span>\n</code></pre></div>\n<p>This attempt gave me a </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Stack</span> <span class=\"n\">overflow</span> <span class=\"n\">detected.</span> <span class=\"n\">Aborting.</span>\n</code></pre></div>\n<p>What can be done next? Can I use the heap? Happy to hear any pointers!</p>",
        "id": 426804171,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1710528938
    },
    {
        "content": "<p>Well, I can't help but say that if you're implementing the Sieve of Erastosthenes, then you should really have a look at this paper: <a href=\"https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf\">https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf</a></p>",
        "id": 426811021,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710531939
    },
    {
        "content": "<p>Barring that I have nothing meaningful to say .</p>",
        "id": 426811036,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710531950
    },
    {
        "content": "<p>My best attempt at implementing naive Eratosthenes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">specialize</span><span class=\"o\">,</span> <span class=\"n\">inline</span><span class=\"kd\">]</span>\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">iterfun</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">cond</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">iterfun</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">simpleSieve</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">n.toFloat.sqrt.ceil.toUInt64.toNat</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">loop</span> <span class=\"n\">i</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n    <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"bp\">≥</span> <span class=\"n\">s</span> <span class=\"k\">then</span>\n      <span class=\"n\">A.foldl</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">cond</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">R.push</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">j.succ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">#</span><span class=\"o\">[],</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">fst</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">loop</span> <span class=\"n\">i.succ</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">cond</span> <span class=\"n\">A</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">!</span>\n        <span class=\"o\">(</span><span class=\"n\">iterfun</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">/</span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">R.set</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"bp\">*</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"n\">j.succ</span><span class=\"o\">))</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">fst</span><span class=\"o\">)</span>\n        <span class=\"n\">A</span>\n  <span class=\"n\">loop</span> <span class=\"mi\">2</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Array.mkArray</span> <span class=\"n\">n.succ</span> <span class=\"n\">true</span>\n</code></pre></div>\n<p>This can sift up to a couple of billion integers in 30sec/1min.  All optimizations I tried on this code made it significantly slower, which is very frustrating.</p>",
        "id": 426821674,
        "sender_full_name": "Number Eighteen",
        "timestamp": 1710536591
    }
]