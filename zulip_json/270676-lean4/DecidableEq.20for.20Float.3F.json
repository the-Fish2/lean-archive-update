[
    {
        "content": "<p>It looks like <code>Float</code> doesn't have a <code>DecidableEq</code> instance.  Is that right, and is it intentional if so?  I realize it can't have <code>LawfulBEq</code> due to NaN, but that doesn't seem like it should block <code>DecidableEq</code>.</p>",
        "id": 411535202,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704571696
    },
    {
        "content": "<p>I suppose it would be easy to accidentally use <code>=</code> instead of <code>==</code> if <code>DecidableEq</code> existed, with resulting different behavior.</p>",
        "id": 411535835,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704572379
    },
    {
        "content": "<p>If it did, it would have to <code>NaN = NaN</code>, right?</p>",
        "id": 411537176,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1704573862
    },
    {
        "content": "<p>Yes, by <code>rfl</code>.</p>",
        "id": 411537185,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704573888
    },
    {
        "content": "<p><code>DecidableEq</code> is impossible for Float because you can't prove anything at all about float</p>",
        "id": 411537660,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704574409
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Float.html#Float.decLt\">https://leanprover-community.github.io/mathlib4_docs/Init/Data/Float.html#Float.decLt</a></p>",
        "id": 411537678,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704574440
    },
    {
        "content": "<p>Are you thinking of Lean 3?</p>",
        "id": 411537738,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704574460
    },
    {
        "content": "<p>Oh, I guess that's not quite true; you can prove everything that's in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FloatSpec#doc\">docs#FloatSpec</a></p>",
        "id": 411537748,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704574483
    },
    {
        "content": "<p>So it is indeed weird that <code>DecidableEq</code> is not in that structure, when everything else is</p>",
        "id": 411537850,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704574607
    },
    {
        "content": "<p>I think the foot canon of <code>=</code> vs. <code>==</code> when writing <code>Float</code> code might explain it.  I think it may be weird formally but not weird in practice because of that.</p>",
        "id": 411537882,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704574659
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"514145\">Geoffrey Irving</span> <a href=\"#narrow/stream/270676-lean4/topic/DecidableEq.20for.20Float.3F/near/411537882\">said</a>:</p>\n<blockquote>\n<p>I think the foot canon of <code>=</code> vs. <code>==</code> when writing <code>Float</code> code might explain it.  I think it may be weird formally but not weird in practice because of that.</p>\n</blockquote>\n<p>But how would you treat the NaN case? NaN is not supposed to be equal to itself.</p>",
        "id": 411537938,
        "sender_full_name": "Henrik BÃ¶ving",
        "timestamp": 1704574695
    },
    {
        "content": "<p>Sure, but plenty of languages fail at that anyway</p>",
        "id": 411537953,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704574719
    },
    {
        "content": "<p>We're not talking about changing any semantics: it has to be true that <code>NaN = NaN</code> and <code>NaN != NaN</code>.</p>",
        "id": 411537960,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704574734
    },
    {
        "content": "<p>And it is also true as a meta-mathematical fact that <code>=</code> is decidable over <code>Float</code>.</p>",
        "id": 411537971,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704574750
    },
    {
        "content": "<p>The only question is whether to make that fact available to programmers.</p>",
        "id": 411537982,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704574765
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/DecidableEq.20for.20Float.3F/near/411537953\">said</a>:</p>\n<blockquote>\n<p>Sure, but plenty of languages fail at that anyway</p>\n</blockquote>\n<p>To elaborate, python has a stronger version of <code>==</code> that sometimes surfaces from behind the scenes:</p>\n<div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">nan</span> <span class=\"o\">=</span> <span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"s1\">'nan'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">nan</span><span class=\"p\">:</span> <span class=\"s1\">'oh no'</span><span class=\"p\">}</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"n\">nan</span><span class=\"p\">]</span>\n<span class=\"s1\">'oh no'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"s1\">'nan'</span><span class=\"p\">)]</span>\n<span class=\"n\">Traceback</span> <span class=\"p\">(</span><span class=\"n\">most</span> <span class=\"n\">recent</span> <span class=\"n\">call</span> <span class=\"n\">last</span><span class=\"p\">):</span>\n  <span class=\"n\">File</span> <span class=\"s2\">\"&lt;stdin&gt;\"</span><span class=\"p\">,</span> <span class=\"n\">line</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"ow\">in</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span><span class=\"o\">&gt;</span>\n<span class=\"ne\">KeyError</span><span class=\"p\">:</span> <span class=\"n\">nan</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n</code></pre></div>",
        "id": 411538111,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704574846
    },
    {
        "content": "<p>If we want to guard against the <code>=</code> footgun on floats, that presumably can be handled by a linter; I don't think it is useful to cripple the <code>=</code> notation (by making it need <code>open Classical</code>, as it does today)</p>",
        "id": 411538214,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704574917
    },
    {
        "content": "<p>Here's a hack in the meantime that avoids needing to change core:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Logic.Basic</span>\n\n<span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">instDecidableEqFloatStupid</span> <span class=\"o\">:</span> <span class=\"n\">DecidableEq</span> <span class=\"n\">Float</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">toString</span> <span class=\"n\">f</span> <span class=\"bp\">==</span> <span class=\"n\">toString</span> <span class=\"n\">g</span> <span class=\"k\">then</span> <span class=\"bp\">.</span><span class=\"n\">isTrue</span> <span class=\"n\">lcProof</span> <span class=\"k\">else</span> <span class=\"bp\">.</span><span class=\"n\">isFalse</span> <span class=\"n\">lcProof</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">instance</span><span class=\"o\">,</span> <span class=\"n\">implemented_by</span> <span class=\"n\">instDecidableEqFloatStupid</span><span class=\"kd\">]</span>\n<span class=\"n\">opaque</span> <span class=\"n\">instDecidableEqFloat</span> <span class=\"o\">:</span> <span class=\"n\">DecidableEq</span> <span class=\"n\">Float</span> <span class=\"o\">:=</span> <span class=\"n\">Classical.decEq</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 411538416,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704575149
    },
    {
        "content": "<p>(it would be great if <a href=\"https://github.com/pygments/pygments/pull/2618\">https://github.com/pygments/pygments/pull/2618</a> could land so that <code>unsafe</code> and <code>opaque</code> got highlighted there...)</p>",
        "id": 411538480,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704575192
    },
    {
        "content": "<p>How does that work?  I don't think <code>Float.toString</code> is injective.</p>",
        "id": 411538514,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704575243
    },
    {
        "content": "<p>And of course, if we implement this, we do want the fast native version.</p>",
        "id": 411538599,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704575342
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"514145\">Geoffrey Irving</span> <a href=\"#narrow/stream/270676-lean4/topic/DecidableEq.20for.20Float.3F/near/411538514\">said</a>:</p>\n<blockquote>\n<p>How does that work?  I don't think <code>Float.toString</code> is injective.</p>\n</blockquote>\n<p>Ah, I guess we're in trouble because of how many different <code>NaN</code>s there are, which indeed share a <code>toString</code>.</p>",
        "id": 411538827,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704575592
    },
    {
        "content": "<p>Well, that's one problem...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"n\">e</span><span class=\"bp\">-</span><span class=\"mi\">10</span> <span class=\"o\">:</span> <span class=\"n\">Float</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toString</span>\n<span class=\"c1\">-- \"0.000000\"</span>\n</code></pre></div>",
        "id": 411538868,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704575644
    },
    {
        "content": "<p>Oh, I naively assumed that Lean would be using something like <a href=\"https://www.ryanjuckett.com/printing-floating-point-numbers-part-2-dragon4/\">dragon4</a> for unambiguous (finite) float printing like NumPy does</p>",
        "id": 411539079,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704575836
    },
    {
        "content": "<p>That would be better, I agree.  Though unrelated to <code>DecidableEq</code> which maps to a single assembly instruction.</p>",
        "id": 411539155,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704575893
    },
    {
        "content": "<p>I would certainly prefer it if <code>1e-10</code> didn't show up as 0, as it makes unit tests slightly harder to debug.</p>",
        "id": 411539170,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704575929
    },
    {
        "content": "<p>At risk of further derailment; is there any builtin way to print <code>1e-10</code> at higher precision?</p>",
        "id": 411539200,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704575972
    },
    {
        "content": "<p><code>printf(\"%.17g\", x)</code> is (mostly) injective in C, so if we have access to format strings then yes.</p>",
        "id": 411539305,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704576074
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> There is an implementation of <code>toStringFull</code> either in <a href=\"#narrow/stream/270676-lean4/topic/Printing.20all.20float.20digits/near/385571254\">zulip</a> or in std (<a href=\"https://github.com/leanprover/std4/pull/282\">std4#282</a>)</p>",
        "id": 411852973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704767447
    },
    {
        "content": "<p>My understanding of the lean model of Float is that it identifies all <code>NaN</code>s (sign included) and otherwise distinguishes all bit patterns (including <code>0</code> vs <code>-0</code>)</p>",
        "id": 411853329,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704767665
    }
]