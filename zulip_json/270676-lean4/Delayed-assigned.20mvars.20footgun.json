[
    {
        "content": "<p>At some point in Aesop I need to determine whether a partially completed proof <code>e : Expr</code> is <code>sorry</code>-free:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">hasSorry</span>\n</code></pre></div>\n<p>Of course I recognise Lean's biggest footgun, so I write instead:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">instantiateMVars</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hasSorry</span>\n</code></pre></div>\n<p>But in fact this is incorrect as well: if <code>e</code> contains a delayed-assigned mvar <code>?m</code>, then <code>?m</code> is not instantiated by <code>instantiateMVars</code> but its assignment may still contain <code>sorry</code>. So the (probably) correct version is something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">hasSorry</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">isSome</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">findM?</span><span class=\"w\"> </span><span class=\"bp\">λ</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mvar</span><span class=\"w\"> </span><span class=\"n\">mvarId</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">ass</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getDelayedMVarAssignment?</span><span class=\"w\"> </span><span class=\"n\">mvarId</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"n\">hasSorry</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mvar</span><span class=\"w\"> </span><span class=\"n\">ass</span><span class=\"bp\">.</span><span class=\"n\">mvarIdPending</span>\n<span class=\"w\">      </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">ass</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getExprMVarAssignment?</span><span class=\"w\"> </span><span class=\"n\">mvarId</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"n\">hasSorry</span><span class=\"w\"> </span><span class=\"n\">ass</span>\n<span class=\"w\">      </span><span class=\"k\">else</span>\n<span class=\"w\">        </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``sorryAx</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">false</span>\n</code></pre></div>\n<p>I figured this out when debugging an issue, so this is a real scenario (albeit a rare one because delayed-assigned mvars are rare). I suspect that a lot of core and Mathlib code contains this bug since <code>(&lt;- instantiateMVars e).foldM</code> or <code>(&lt;- instantiateMVars e).findM</code> is a common pattern.</p>",
        "id": 440383759,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1716492005
    },
    {
        "content": "<p>why does <code>instantiateMVars</code> not take into account delayed mvar assignments?</p>",
        "id": 440670474,
        "sender_full_name": "David Renshaw",
        "timestamp": 1716678789
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243791\">@David Renshaw</span> It does, but it only substitutes them in once the mvar it's been delayed assigned to itself instantiates to something without any mvars.</p>",
        "id": 440672394,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1716681548
    }
]