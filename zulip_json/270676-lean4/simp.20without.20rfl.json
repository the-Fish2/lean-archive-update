[
    {
        "content": "<p>I come from Coq. In Coq, if you want to prove <code>not true = false</code>, you have to first simplify <code>not true</code> to <code>false</code>, then use <code>rfl</code> to prove the equality by reflexivity. </p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Example</span> <span class=\"n\">not_true</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">negb</span> <span class=\"bp\">true</span><span class=\"o\">)</span> <span class=\"o\">=</span> <span class=\"bp\">false</span><span class=\"o\">.</span>\n<span class=\"kn\">Proof</span><span class=\"o\">.</span> <span class=\"k\">simpl</span><span class=\"o\">.</span> <span class=\"kp\">reflexivity</span><span class=\"o\">.</span> <span class=\"kn\">Qed</span><span class=\"o\">.</span>\n</code></pre></div>\n<p>But in lean, a single <code>simp</code> will finish the proof.  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"n\">not</span> <span class=\"n\">true</span> <span class=\"bp\">=</span> <span class=\"n\">false</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>\n<p>Is there any tactic to simplify terms without finishing the proof just like Coq? I know lean's behavior might be useful, but if I want to explain to others how a proof assistant works, I need those intermediate steps like <code>true=true</code> to illustrate Curry-Howard correspondence.</p>",
        "id": 437945138,
        "sender_full_name": "xiao",
        "timestamp": 1715329853
    },
    {
        "content": "<p>I don't believe so. You can use <code>rewrite [not]</code> or <code>unfold not</code> to unfold <code>not</code> without trying to close the goal, but this yields a match expression and the usual tool to reduce these, <code>dsimp only</code>, also tries to close syntactic reflexivity goals, and I don't believe there is a simp option to turn this off</p>",
        "id": 437947385,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1715330868
    },
    {
        "content": "<p>of course you can prevent it from closing the goal by not making it a syntactic reflexivity:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">myFalse</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n<span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"n\">not</span> <span class=\"n\">true</span> <span class=\"bp\">=</span> <span class=\"n\">myFalse</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">not</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- ⊢ false = myFalse</span>\n</code></pre></div>",
        "id": 437947747,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1715331017
    },
    {
        "content": "<p>Then it is a bit disappointing. I think the essence behind simp is trying all equalities, but they are propositional ones, while the simp in Coq only does beta reductions till a normal form, which is a judgemental(definitional) equality. I don’t understand why dsimp also tries to close a propositional equality as it is called definitional.</p>",
        "id": 437952155,
        "sender_full_name": "xiao",
        "timestamp": 1715333080
    },
    {
        "content": "<p>definitional equalities in lean are usually written using <code>=</code> and a proof using <code>rfl</code></p>",
        "id": 437952754,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1715333317
    },
    {
        "content": "<p><code>dsimp</code> tries only those <code>simp</code> lemmas that are definitional equalities (proved by <code>rfl</code>).</p>",
        "id": 437952874,
        "sender_full_name": "Joël Riou",
        "timestamp": 1715333357
    },
    {
        "content": "<p>ultimately this is just a tactic trying to be useful and not create busywork for the user</p>",
        "id": 437952896,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1715333362
    },
    {
        "content": "<p>it is possible to make your own <code>dsimp'</code> that skips this step</p>",
        "id": 437952926,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1715333373
    },
    {
        "content": "<p>oh, you can also use the <code>dsimp</code> conv it seems, this one does not try to close the goal... although I think the <code>conv</code> block itself might</p>",
        "id": 437953270,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1715333526
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MyDSimp</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Parser.Tactic</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">dsimp'</span><span class=\"o\">)</span> <span class=\"s2\">\"dsimp'\"</span> <span class=\"o\">(</span><span class=\"n\">config</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">discharger</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"bp\">&amp;</span><span class=\"s2\">\" only\"</span><span class=\"o\">)</span><span class=\"bp\">?</span>\n  <span class=\"o\">(</span><span class=\"s2\">\" [\"</span> <span class=\"n\">withoutPosition</span><span class=\"o\">((</span><span class=\"n\">simpErase</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">simpLemma</span><span class=\"o\">),</span><span class=\"bp\">*</span><span class=\"o\">,</span><span class=\"bp\">?</span><span class=\"o\">)</span> <span class=\"s2\">\"]\"</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">location</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span> <span class=\"n\">Meta</span> <span class=\"n\">Simp</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dsimpGoal'</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ctx</span> <span class=\"o\">:</span> <span class=\"n\">Simp.Context</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">simprocs</span> <span class=\"o\">:</span> <span class=\"n\">SimprocsArray</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[])</span> <span class=\"o\">(</span><span class=\"n\">simplifyTarget</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fvarIdsToSimp</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">FVarId</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[])</span>\n    <span class=\"o\">(</span><span class=\"n\">stats</span> <span class=\"o\">:</span> <span class=\"n\">Stats</span> <span class=\"o\">:=</span> <span class=\"o\">{})</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">MVarId</span> <span class=\"bp\">×</span> <span class=\"n\">Stats</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n   <span class=\"n\">mvarId.withContext</span> <span class=\"k\">do</span>\n    <span class=\"n\">mvarId.checkNotAssigned</span> <span class=\"bp\">`</span><span class=\"n\">simp</span>\n    <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">mvarIdNew</span> <span class=\"o\">:=</span> <span class=\"n\">mvarId</span>\n    <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">stats</span> <span class=\"o\">:</span> <span class=\"n\">Stats</span> <span class=\"o\">:=</span> <span class=\"n\">stats</span>\n    <span class=\"n\">for</span> <span class=\"n\">fvarId</span> <span class=\"k\">in</span> <span class=\"n\">fvarIdsToSimp</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">type</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">fvarId.getType</span><span class=\"o\">)</span>\n      <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">typeNew</span><span class=\"o\">,</span> <span class=\"n\">stats'</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">dsimp</span> <span class=\"n\">type</span> <span class=\"n\">ctx</span> <span class=\"n\">simprocs</span>\n      <span class=\"n\">stats</span> <span class=\"o\">:=</span> <span class=\"n\">stats'</span>\n      <span class=\"k\">if</span> <span class=\"n\">typeNew.isFalse</span> <span class=\"k\">then</span>\n        <span class=\"n\">mvarIdNew.assign</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkFalseElim</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mvarIdNew.getType</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mkFVar</span> <span class=\"n\">fvarId</span><span class=\"o\">))</span>\n        <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">stats</span><span class=\"o\">)</span>\n      <span class=\"k\">if</span> <span class=\"n\">typeNew</span> <span class=\"bp\">!=</span> <span class=\"n\">type</span> <span class=\"k\">then</span>\n        <span class=\"n\">mvarIdNew</span> <span class=\"bp\">←</span> <span class=\"n\">mvarIdNew.replaceLocalDeclDefEq</span> <span class=\"n\">fvarId</span> <span class=\"n\">typeNew</span>\n    <span class=\"k\">if</span> <span class=\"n\">simplifyTarget</span> <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"n\">target</span> <span class=\"bp\">←</span> <span class=\"n\">mvarIdNew.getType</span>\n      <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">targetNew</span><span class=\"o\">,</span> <span class=\"n\">stats'</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">dsimp</span> <span class=\"n\">target</span> <span class=\"n\">ctx</span> <span class=\"n\">simprocs</span> <span class=\"n\">stats</span>\n      <span class=\"n\">stats</span> <span class=\"o\">:=</span> <span class=\"n\">stats'</span>\n      <span class=\"c1\">-- if targetNew.isTrue then</span>\n      <span class=\"c1\">--   mvarIdNew.assign (mkConst ``True.intro)</span>\n      <span class=\"c1\">--   return (none, stats)</span>\n      <span class=\"c1\">-- if let some (_, lhs, rhs) := targetNew.consumeMData.eq? then</span>\n      <span class=\"c1\">--   if (← withReducible &lt;| isDefEq lhs rhs) then</span>\n      <span class=\"c1\">--     mvarIdNew.assign (← mkEqRefl lhs)</span>\n      <span class=\"c1\">--     return (none, stats)</span>\n      <span class=\"k\">if</span> <span class=\"n\">target</span> <span class=\"bp\">!=</span> <span class=\"n\">targetNew</span> <span class=\"k\">then</span>\n        <span class=\"n\">mvarIdNew</span> <span class=\"bp\">←</span> <span class=\"n\">mvarIdNew.replaceTargetDefEq</span> <span class=\"n\">targetNew</span>\n    <span class=\"k\">if</span> <span class=\"n\">ctx.config.failIfUnchanged</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">mvarId</span> <span class=\"bp\">==</span> <span class=\"n\">mvarIdNew</span> <span class=\"k\">then</span>\n      <span class=\"n\">throwError</span> <span class=\"s2\">\"dsimp made no progress\"</span>\n    <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">mvarIdNew</span><span class=\"o\">,</span> <span class=\"n\">stats</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dsimpLocation'</span> <span class=\"o\">(</span><span class=\"n\">ctx</span> <span class=\"o\">:</span> <span class=\"n\">Simp.Context</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">simprocs</span> <span class=\"o\">:</span> <span class=\"n\">Simp.SimprocsArray</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">loc</span> <span class=\"o\">:</span> <span class=\"n\">Location</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TacticM</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"n\">loc</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Location.targets</span> <span class=\"n\">hyps</span> <span class=\"n\">simplifyTarget</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">withMainContext</span> <span class=\"k\">do</span>\n      <span class=\"k\">let</span> <span class=\"n\">fvarIds</span> <span class=\"bp\">←</span> <span class=\"n\">getFVarIds</span> <span class=\"n\">hyps</span>\n      <span class=\"n\">go</span> <span class=\"n\">fvarIds</span> <span class=\"n\">simplifyTarget</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Location.wildcard</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">withMainContext</span> <span class=\"k\">do</span>\n      <span class=\"n\">go</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getMainGoal</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getNondepPropHyps</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">simplifyTarget</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">go</span> <span class=\"o\">(</span><span class=\"n\">fvarIdsToSimp</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">FVarId</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">simplifyTarget</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TacticM</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">withSimpDiagnostics</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">mvarId</span> <span class=\"bp\">←</span> <span class=\"n\">getMainGoal</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">result</span><span class=\"bp\">?</span><span class=\"o\">,</span> <span class=\"n\">stats</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">dsimpGoal'</span> <span class=\"n\">mvarId</span> <span class=\"n\">ctx</span> <span class=\"n\">simprocs</span> <span class=\"o\">(</span><span class=\"n\">simplifyTarget</span> <span class=\"o\">:=</span> <span class=\"n\">simplifyTarget</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fvarIdsToSimp</span> <span class=\"o\">:=</span> <span class=\"n\">fvarIdsToSimp</span><span class=\"o\">)</span>\n    <span class=\"k\">match</span> <span class=\"n\">result</span><span class=\"bp\">?</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">replaceMainGoal</span> <span class=\"o\">[]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">mvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">replaceMainGoal</span> <span class=\"o\">[</span><span class=\"n\">mvarId</span><span class=\"o\">]</span>\n    <span class=\"k\">if</span> <span class=\"n\">tactic.simp.trace.get</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getOptions</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n      <span class=\"n\">mvarId.withContext</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">traceSimpCall</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getRef</span><span class=\"o\">)</span> <span class=\"n\">stats.usedTheorems</span>\n    <span class=\"n\">return</span> <span class=\"n\">stats.diag</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">tactic</span> <span class=\"n\">dsimp'</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">evalDSimp'</span> <span class=\"o\">:</span> <span class=\"n\">Tactic</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">{</span> <span class=\"n\">ctx</span><span class=\"o\">,</span> <span class=\"n\">simprocs</span><span class=\"o\">,</span> <span class=\"bp\">..</span> <span class=\"o\">}</span> <span class=\"bp\">←</span> <span class=\"n\">withMainContext</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">mkSimpContext</span> <span class=\"n\">stx</span> <span class=\"o\">(</span><span class=\"n\">eraseLocal</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">kind</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">dsimp</span><span class=\"o\">)</span>\n  <span class=\"n\">dsimpLocation'</span> <span class=\"n\">ctx</span> <span class=\"n\">simprocs</span> <span class=\"o\">(</span><span class=\"n\">expandOptLocation</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">5</span><span class=\"o\">])</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MyDSimp</span>\n\n<span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"n\">not</span> <span class=\"n\">true</span> <span class=\"bp\">=</span> <span class=\"n\">false</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">dsimp'</span> <span class=\"o\">[</span><span class=\"n\">not</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 437953991,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1715333884
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"717159\">xiao</span> <a href=\"#narrow/stream/270676-lean4/topic/simp.20without.20rfl/near/437952155\">said</a>:</p>\n<blockquote>\n<p>Then it is a bit disappointing</p>\n</blockquote>\n<p>This is similar to my first frustration with Lean, since I had started learning about theorem proving in Coq and I wanted Lean to behave in the same way. But later on I realized that tactics are really customizable (though with a learning curve), as Mario has just shown</p>",
        "id": 437960421,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1715337014
    },
    {
        "content": "<p>and just to be clear, I didn't write all that code myself, it's a copy paste of the original <code>dsimp</code> with the offending lines commented out</p>",
        "id": 437968914,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1715341516
    },
    {
        "content": "<p>Thank you guys. I finally noticed that lean admits uniqueness of identity proof (uip), which is not admitted in Coq. Since I am learning homotopy type theory, the equalities used in definitions (judgemental, in meta language) and the provable equalities (propositional) are significantly different to me. This is why I tend to use a simplification only for computation (judgement). </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">uip.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}:</span> <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"bp\">=</span><span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 438025094,
        "sender_full_name": "xiao",
        "timestamp": 1715364234
    }
]