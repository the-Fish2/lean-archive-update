[
    {
        "content": "<p>I'm moving this here from <a href=\"#narrow/stream/287929-mathlib4/topic/Ways.20to.20speed.20up.20Mathlib/near/435440278\">this thread</a>, as it is not a Mathlib-specific problem.</p>\n<p>To save you having to follow the link, here is the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> I posted there:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">B</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">C</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">B_nat</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">DtoB</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">D</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.synthInstance</span> <span class=\"n\">true</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">A</span> <span class=\"n\">Nat</span>\n</code></pre></div>\n<p>which produces the fully expanded trace</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>[Meta.synthInstance] ❌ A Nat ▼\n  [] new goal A Nat ▼\n    [instances] #[test]\n  [] ✅ apply test to A Nat ▼\n    [tryResolve] ✅ A Nat ≟ A Nat\n    [] new goal B Nat ▼\n      [instances] #[DtoB, B_nat]\n  [] ✅ apply B_nat to B Nat ▼\n    [tryResolve] ✅ B Nat ≟ B Nat\n  [resume] propagating B Nat to subgoal B Nat of A Nat ▼\n    [] size: 1\n    [] no instances for C Nat ▼\n      [instances] #[]\n------------------------------------\n  [] ✅ apply DtoB to B Nat ▼\n    [tryResolve] ✅ B Nat ≟ B Nat\n    [] no instances for D Nat ▼\n      [instances] #[]\n</code></pre></div>\n<p>(separation added).</p>\n<p>As you can see, after an instance for <code>B Nat</code> is found, but none for <code>C Nat</code>, the instance search for <code>B Nat</code> <strong>continues</strong> (even though an instance is already known and <code>test</code> cannot possibly be used due to the lack of an instance for <code>C Nat</code>) -- this is the part of the trace below the separating line.</p>\n<p>It looks to me like this is a bug and that fixing it will likely speed up Mathlib by a fairly large amount (see the thread linked above).</p>",
        "id": 435564475,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1714129573
    },
    {
        "content": "<p>I agree that this is a strange behavior, and that it could have a very high performance impact. <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span>, do you have some thoughts on this?</p>",
        "id": 435565061,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1714129837
    },
    {
        "content": "<p>Sorry, I'm not familiar enough with the algorithm or implementation to give a quick assessment here</p>",
        "id": 435565598,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1714130081
    },
    {
        "content": "<p>Who would be the right person to ping here?</p>",
        "id": 435565656,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1714130104
    },
    {
        "content": "<p>Just guessing here, but maybe in general using a different instance for <code>B Nat</code> might instantiate some mvars differently, so with one instance the <code>C Nat</code> will fail, but with another instance it will succeeds? That would justify to continue the search. </p>\n<p>It may be nontrivial to notice that the instances in <code>test</code>’s type are independent enough so that it’s not worth going back?</p>",
        "id": 435573893,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1714133585
    },
    {
        "content": "<p>The design of typeclasses in mathlib (and in general in Lean, if I understand correctly) is that all instances should be the same, so if one instance fails all the other ones should also fail. That's not an intrinsic property of the system, but rather of the way we use the system. With this in mind, going back to see if another instance will succeed is just a waste of time everywhere throughout mathlib, and probably a very costly one.</p>",
        "id": 435574354,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1714133770
    },
    {
        "content": "<p>A related observation (which I also made in the mathlib thread:<br>\nIn the Lean 3 community version, I believe we changed the order of search for arguments of instances, from left-to-right to right-to-left, i.e. when applying the instance <code>test </code> searching first for <code>C α</code> and only then for <code>B α</code>. The reason is that more constraining type-classes are generally the right-most typeclasses, so they will fail more quickly.</p>\n<p>Was it a conscious decision in Lean 4 to do instance search from left-to-right?</p>",
        "id": 435575103,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1714134091
    },
    {
        "content": "<p>What is the performance cost (if any) in the synthesis step to trying the instance argument with the fewest available instances first?</p>",
        "id": 435576530,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1714134592
    },
    {
        "content": "<p>If the behavior I observed is a consequence of a conscious design decision, maybe it would be possible to make it configurable (so that in Mathlib we could switch it off)?</p>",
        "id": 435580573,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1714136052
    },
    {
        "content": "<p>Here is a variant:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">B</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">C</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">D</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">E</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">test</span> <span class=\"o\">[</span><span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">DtoB</span> <span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">EtoB</span> <span class=\"o\">[</span><span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instB</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instE</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.synthInstance</span> <span class=\"n\">true</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">A</span>\n</code></pre></div>\n<p>which gives</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>[Meta.synthInstance] ❌ A ▼\n  [] new goal A ▼\n    [instances] #[@test]\n  [] ✅ apply @test to A ▼\n    [tryResolve] ✅ A ≟ A\n    [] new goal B ▼\n      [instances] #[@DtoB, @EtoB, instB]\n  [] ✅ apply instB to B ▼\n    [tryResolve] ✅ B ≟ B\n  [resume] propagating B to subgoal B of A ▼\n    [] size: 1\n    [] no instances for C ▼\n      [instances] #[]\n  [] ✅ apply @EtoB to B ▼\n    [tryResolve] ✅ B ≟ B\n    [] new goal E ▼\n      [instances] #[instE]\n  [] ✅ apply instE to E ▼\n    [tryResolve] ✅ E ≟ E\n  [resume] propagating E to subgoal E of B ▼\n    [] size: 1\n  [] ✅ apply @DtoB to B ▼\n    [tryResolve] ✅ B ≟ B\n    [] no instances for D ▼\n      [instances] #[]\n</code></pre></div>\n<p>This shows that it even continues searching for <code>B</code> instances after it has found another one after backtracking. (Which explains the behavior we see in Mathlib, where the whole search tree is traversed in these cases).</p>",
        "id": 435583422,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1714137062
    },
    {
        "content": "<p>I have made an issue: <a href=\"https://github.com/leanprover/lean4/pull/3996\">lean4#3996</a></p>",
        "id": 435588159,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1714138600
    },
    {
        "content": "<p>I have observed many times that the same TC search seems to be attempted many times. But most of the examples are quite complex and difficult to make <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> s. Maybe the examples in <a href=\"#narrow/stream/287929-mathlib4/topic/TC.20slowness\">this thread</a> are relevant.</p>",
        "id": 435591480,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1714139700
    },
    {
        "content": "<p>Is there any chance one could set up a formal model of typeclass search and then use it to prove things about it?</p>",
        "id": 435606801,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1714144668
    },
    {
        "content": "<p>I think the original paper on the algorithm is most relevant to that: <a href=\"https://arxiv.org/abs/2001.04301\">https://arxiv.org/abs/2001.04301</a> . In particular, it does quite a lot to avoid repeated searches for the same thing, so it would be good to determine whether <a href=\"https://github.com/leanprover/lean4/pull/3996\">lean4#3996</a> represents a bug in the algorithm or in the implementation</p>",
        "id": 435608177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1714145124
    },
    {
        "content": "<p>Another <a href=\"#narrow/stream/113488-general/topic/Monthly.20Community.20Meeting/near/435605621\">meaning</a> of \"tabled\" <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 435608380,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1714145188
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span>  I've had a look at the paper and tried to follow the pseudocode to see what it is supposed to do in the following simple case:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">A</span>\n<span class=\"kd\">class</span> <span class=\"n\">B</span>\n<span class=\"kd\">class</span> <span class=\"n\">C</span>\n<span class=\"kd\">class</span> <span class=\"n\">D</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">test</span> <span class=\"o\">[</span><span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">A</span>\n<span class=\"kd\">instance</span> <span class=\"n\">DtoB</span> <span class=\"o\">[</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">B</span>\n<span class=\"kd\">instance</span> <span class=\"n\">instB</span> <span class=\"o\">:</span> <span class=\"n\">B</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">A</span>\n</code></pre></div>\n<p>but I had problems doing that, one reason being that there is no clear definition of the various data structures and another that it is not clear to me what happens if an instance like <code>instB</code> above is encountered that produces no subgoals: in line 20 the call to <code>NewConsumerNode</code> would receive an empty list of subgoals, but then the code is supposed to look at the first subgoal, which does not exist... Also it says \"for each solution to g\", but does not say how they are obtained. Can you help me understand what it is supposed to do?</p>\n<p>BTW, if I interpret footnote 6</p>\n<blockquote>\n<p>Note that the logics of Coq and Lean are so expressive that even for a given type<br>\nwith no unification variables, different choices of instances may indeed cause different<br>\ndownstream goals to succeed and fail; however, it is common practice in both systems<br>\nto ignore this possibility and to assume that instances are “morally canonical”.</p>\n</blockquote>\n<p>correctly, then it supports my claim that it should be considered a bug when the algorithm or its implementation keeps looking for solutions to a typeclass search problem after it has already found one.</p>",
        "id": 435637542,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1714155549
    },
    {
        "content": "<blockquote>\n<p>it is not clear to me what happens if an instance like <code>instB</code> above is encountered that produces no subgoals: in line 20 the call to <code>NewConsumerNode</code> would receive an empty list of subgoals, but then the code is supposed to look at the first subgoal, which does not exist...</p>\n</blockquote>\n<p>The actual code panics in this case, so I'm pretty sure it is handled elsewhere</p>",
        "id": 435638486,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1714155969
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Possible.20bug.20in.20typeclass.20search/near/435638486\">said</a>:</p>\n<blockquote>\n<p>The actual code panics in this case, so I'm pretty sure it is handled elsewhere</p>\n</blockquote>\n<p>I hope so; this is certainly a quite common situation!</p>",
        "id": 435638569,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1714156008
    },
    {
        "content": "<p>Does this mean that the description of the algorithm in the paper is incomplete?</p>",
        "id": 435640909,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1714157108
    },
    {
        "content": "<p>Here is an example where instance synthesis fails while it should succeed.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">C</span> <span class=\"n\">where</span>\n\n\n<span class=\"kd\">instance</span> <span class=\"n\">test'</span> <span class=\"o\">[</span><span class=\"n\">B</span> <span class=\"mi\">10</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">test</span> <span class=\"o\">[</span><span class=\"n\">B</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">B</span> <span class=\"n\">n.succ</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"n\">n</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instB</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"n\">n</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.synthInstance</span> <span class=\"n\">true</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">A</span>\n</code></pre></div>\n<p>It gets stuck trying (and infinitely often failing) to establish <code>A</code> via <code>test</code> and never gets to trying <code>test'</code>.<br>\n<span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span></p>",
        "id": 435734131,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1714208881
    },
    {
        "content": "<p>Putting <code>set_option synthInstance.maxHeartbeats 40</code> before the <code>#synth</code> stops VS code from crashing and produces a finite trace.</p>",
        "id": 435757068,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1714224259
    },
    {
        "content": "<p>A  <a href=\"https://github.com/leanprover/lean4/commit/917a31f694f0db44d6907cc2b1485459afe74d49\">fix</a> has just been merged. Now I'm eager to see its effect on Mathlib!</p>",
        "id": 435784970,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1714247204
    },
    {
        "content": "<p>Are you eager enough to learn how to see this effect yourself today? :-)</p>",
        "id": 435785345,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1714247642
    },
    {
        "content": "<p>Not that eager (it is getting late, and I'm watching the Snooker World Championship...). <span aria-label=\"billiards\" class=\"emoji emoji-1f3b1\" role=\"img\" title=\"billiards\">:billiards:</span></p>",
        "id": 435785406,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1714247698
    },
    {
        "content": "<p>Looking at <code>NumberTheory.RamificationInertia</code> on the <code>nightly-testing</code> branch (and after making two <code>_</code>s explicit, which had become <em>very</em> slow, cf. <a href=\"https://github.com/leanprover-community/mathlib4/pull/12412\">#12412</a>), I see that most of the slow <code>Subsingleton</code> instances are gone (with one exception), but <code>Module</code>, <code>AddCommMonoid</code> and <code>AddMonoidHomClass</code> are still often slow.</p>\n<p>Overall, it looks like typeclass inference only takes 50% of the time it took before <a href=\"https://github.com/leanprover/lean4/pull/4003\">lean4#4003</a>.</p>",
        "id": 435877479,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1714313546
    },
    {
        "content": "<p>Sorry, where did you get that 50% figure? I couldn't find it.</p>",
        "id": 435895044,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714327068
    },
    {
        "content": "<p>I put <code>set_option profiler true</code> at the beginning of the file and ran <code>lake build</code> on it. Then I compared the reported total time for \"typeclass inference\" with what I remembered from when experimenting with the file. <br>\nSo you could not possibly find that figure somewhere...</p>",
        "id": 435895474,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1714327286
    },
    {
        "content": "<p>The fix hasn't fixed every occurrence of the problem. In particular, what the fix does is make it so that every type class sub-goal (i.e. generator node) that does not have metavariables stops trying to find more than 1 solution. However, it is possible to have a sub-goal B with metavariables that would only every be useful for solving some other subgoal A that doesn't have metavariables. In this case it will still continue to try finding solutions to B even when A is already solved. Here is a minimal example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">A</span>\n<span class=\"kd\">class</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">C</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"mi\">0</span> <span class=\"n\">where</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">B</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">C</span> <span class=\"mi\">100000</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">D</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Nonempty</span> <span class=\"n\">Empty</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"n\">where</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">D</span>\n</code></pre></div>\n<p>But my guess would be that fixing this wouldn't give a significant speedup.</p>",
        "id": 438486079,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1715653436
    },
    {
        "content": "<p>I also have a converse. The following minimized example of a type class resolution worked in version 4.7.0, but fails since the fix:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">MulComm</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Monoid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Mul</span> <span class=\"n\">α</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">Monoid.mk</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">CommSemigroup</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Mul</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">MulComm</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">CommMonoid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Monoid</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">MulComm</span> <span class=\"n\">α</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">CommMonoid.mk</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommSemigroup</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.explicit</span> <span class=\"n\">true</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.proofs</span> <span class=\"n\">true</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">@CommMonoid.mk β (@Monoid.mk β (@CommSemigroup.toMul β inst✝))</span>\n<span class=\"cm\">  (@CommMonoid.toMulComm β</span>\n<span class=\"cm\">    (@CommMonoid.mk β (@Monoid.mk β (@CommSemigroup.toMul β inst✝))</span>\n<span class=\"cm\">      (@CommMonoid.toMulComm β</span>\n<span class=\"cm\">        (@CommMonoid.mk β (@Monoid.mk β (@CommSemigroup.toMul β inst✝)) (@CommSemigroup.toMulComm β inst✝)))))</span>\n<span class=\"cm\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">CommMonoid</span> <span class=\"n\">β</span>\n</code></pre></div>\n<p>When removing the redundant extra instance <code>[Monoid β]</code>, the resolution works. However the synthesized instance contains some duplication that should clearly not be there.</p>",
        "id": 438493562,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1715657476
    },
    {
        "content": "<p>The culprit for this weird behaviour is the type class parameter in the class <code>MulComm</code>, because it causes the following <strong><em>dependent</em></strong> instance: <code>CommMonoid.toMulComm.{u} {α : Type u} [self : CommMonoid α] : @MulComm α (@Monoid.toMul α (@CommMonoid.toMonoid α self))</code>.  When trying to use this instance, <code>isDefEq</code> needs to figure out the metavariable <code>self</code>, which requires a call to <code>synthPending</code>, which then starts synthesizing an instance of <code>CommMonoid β</code> all over again. This recursive loop happens two times, and the third time around it reaches the hard-coded recursion limit, at which point a different instance needs to be found. Then it finds <code>@CommMonoid.mk β (@Monoid.mk β (@CommSemigroup.toMul β inst✝)) (@CommSemigroup.toMulComm β inst✝)</code>. But because of the two extra layers of recursion, we get two extra applications of </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">CommMonoid.mk</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Monoid.mk</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommSemigroup.toMul</span> <span class=\"n\">β</span> <span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CommMonoid.toMulComm</span> <span class=\"n\">β</span>\n</code></pre></div>\n<p>I think the solution to this is now quite clear: tabled type class resolution caches all progress within a single <code>synthInstance</code> call. But recursive calls to <code>synthInstance</code> should be able to share the same table.</p>",
        "id": 438503650,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1715664455
    },
    {
        "content": "<p>I'm confused by <code>attribute [instance] (Comm)Monoid.mk</code>. Those aren't realistic are they?</p>",
        "id": 438503867,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1715664638
    },
    {
        "content": "<p>I encountered the example here: <a href=\"https://github.com/leanprover/lean4/blob/91244b2dd9d223006227648659203373f5a46b0b/tests/lean/run/KyleAlg.lean\">https://github.com/leanprover/lean4/blob/91244b2dd9d223006227648659203373f5a46b0b/tests/lean/run/KyleAlg.lean</a></p>",
        "id": 438504389,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1715665082
    },
    {
        "content": "<p>It would be useful for something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommSemigroup</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">CommMonoid</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>But I didn't realize that these kinds of instances are not in Mathlib.</p>",
        "id": 438505720,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1715666087
    },
    {
        "content": "<p>There is exactly one class in which the <code>.mk</code> constructor is marked with the instance attribute, namely</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">MonadError.mk</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">toMonadExceptOf</span> <span class=\"o\">:</span> <span class=\"n\">MonadExceptOf</span> <span class=\"n\">Exception</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">toMonadRef</span> <span class=\"o\">:</span> <span class=\"n\">MonadRef</span> <span class=\"n\">m</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">toAddErrorMessageContext</span> <span class=\"o\">:</span> <span class=\"n\">AddErrorMessageContext</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">MonadError</span> <span class=\"n\">m</span>\n</code></pre></div>\n<p>The consequence is that when synthesizing <code>MonadRef m</code>, the first thing it tries to do is to synthesize <code>MonadExceptOf Exception m</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.synthInstance</span> <span class=\"n\">true</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">MonadRef</span> <span class=\"n\">MetaM</span>\n</code></pre></div>",
        "id": 438517921,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1715672341
    }
]