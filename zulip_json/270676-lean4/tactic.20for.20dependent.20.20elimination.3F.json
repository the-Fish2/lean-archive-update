[
    {
        "content": "<p>The following case analysis fails:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">test_fam</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"n\">where</span>\n <span class=\"bp\">|</span> <span class=\"n\">Tr</span> <span class=\"o\">:</span> <span class=\"n\">test_fam</span> <span class=\"n\">true</span>\n <span class=\"bp\">|</span> <span class=\"n\">Fa</span> <span class=\"o\">:</span> <span class=\"n\">test_fam</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test_app_not_ok</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">test_fam</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>complaining that <code>dependent elimination failed, failed to solve equation f b = true</code>. The same <code>cases</code> tactic  however works as expected when <code>h</code> is changed for <code>(h : : forall b, test_fam (b) (b : Bool))</code>, as in:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">here</span>\n <span class=\"kd\">lemma</span> <span class=\"n\">test_app_ok</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">test_fam</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>What is the appropriate way of performing this case analysis?</p>",
        "id": 430089466,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1711638474
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110172\">@Assia Mahboubi</span> Do you by chance intend <code>cases f b</code>?</p>",
        "id": 430090098,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711638644
    },
    {
        "content": "<p>No, I really want to perform a case analysis on <code>h b : test_fam (f b)</code>.  I am expecting Lean to open two identical subgoals, identical to the initial state in this toy, reduced example.</p>",
        "id": 430090677,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1711638811
    },
    {
        "content": "<p>I can do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">test_app_not_ok</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">test_fam</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">match</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">Tr</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span>\n  <span class=\"bp\">|</span> <span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">Fa</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 430091263,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711638981
    },
    {
        "content": "<p>But I have no idea how to do cases directly on <code>h b</code></p>",
        "id": 430091326,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711638998
    },
    {
        "content": "<p>Indeed. Unfortunately, it is quite Inconvenient as such for the application I have in mind...</p>",
        "id": 430091741,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1711639097
    },
    {
        "content": "<p>And<code>case (h b)</code> works in  Rocq/Coq so I guess there must be a way in Lean too.</p>",
        "id": 430091995,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1711639175
    },
    {
        "content": "<p>According to the docstring for <code>cases</code> it should be possible to use <code>cases H : h b</code>. But it doesn't seem to do what it promises.</p>",
        "id": 430093552,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711639598
    },
    {
        "content": "<p>It is inconvenient, but generally when you get \"dependent elimination failed\" you can use <code>generalize</code> on indices manually.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">test_app_not_ok</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">test_fam</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"n\">b</span>\n  <span class=\"n\">generalize</span> <span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b'</span> <span class=\"n\">at</span> <span class=\"n\">x</span>\n  <span class=\"n\">cases</span> <span class=\"n\">x</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  case Tr</span>\n<span class=\"cm\">  f: Bool → Bool</span>\n<span class=\"cm\">  h: (b : Bool) → test_fam (f b)</span>\n<span class=\"cm\">  b: Bool</span>\n<span class=\"cm\">  hb: f b = true</span>\n<span class=\"cm\">  ⊢ b = b</span>\n\n<span class=\"cm\">  case Fa</span>\n<span class=\"cm\">  f: Bool → Bool</span>\n<span class=\"cm\">  h: (b : Bool) → test_fam (f b)</span>\n<span class=\"cm\">  b: Bool</span>\n<span class=\"cm\">  hb: f b = false</span>\n<span class=\"cm\">  ⊢ b = b</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>\n<p>There ought to be an extension to <code>cases</code> that lets you provide names to use for the equalities to generalize indices like this.</p>",
        "id": 430126029,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711646385
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"110172\">@Assia Mahboubi</span> wants to explicitly avoid writing out <code>f b</code>, because in her use case this is some horribly long expression. (I'm not 100% this is the reason, so please correct me if I'm wrong, Assia.)</p>",
        "id": 430131166,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711647771
    },
    {
        "content": "<p>Thanks for the suggestion! Indeed, I do not want this, first because my real example has many indices, and also because this is a building block of some automation, which becomes much less interesting if you have to potentially input these expressions.</p>",
        "id": 430136068,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1711649260
    },
    {
        "content": "<p>I would be curious to hear the authors of LeanSSR about the behavior of there variant of elimination tactic.</p>",
        "id": 430136250,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1711649305
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"702586\">@Ilya Sergey</span>  <span class=\"user-mention\" data-user-id=\"690517\">@Vladimir Gladstein</span> <span class=\"user-mention\" data-user-id=\"418216\">@George Pîrlea</span></p>",
        "id": 430136570,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1711649392
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> That's exactly why I think it's inconvenient and would want a tactic to do this — I almost mentioned it explicitly)</p>",
        "id": 430147099,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711653223
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110172\">@Assia Mahboubi</span> I'm not an author of LeanSSR, but I've been studying its code, and as far as I can tell the elimination tactic <a href=\"https://github.com/verse-lab/lean-ssr/blob/master/Ssreflect/Elim.lean#L34\">does <code>cases</code></a> without any additional index processing.</p>",
        "id": 430147261,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711653304
    },
    {
        "content": "<p>Mathlib 3 had fairly undocumented <code>induction'</code> and <code>cases'</code> tactics that I believe could handle this case. <a href=\"https://leanprover-community.github.io/mathlib_docs/tactic/induction.html\">https://leanprover-community.github.io/mathlib_docs/tactic/induction.html</a></p>\n<p>I don't believe they've been ported, and I also don't remember them giving you equalities for the indices.</p>",
        "id": 430147531,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711653423
    },
    {
        "content": "<p>Note that this is also part of the operation of <code>cases</code> itself: it already generalizes indices to equalities, then tries to eliminate those equalities using <code>injection</code> and <code>subst</code>, and the error you see about dependent elimination occurs when these methods fail. So another alternative would be to modify <code>cases</code> or add an option so that it passes these hypotheses back in the subgoals instead of failing if it can't eliminate them all.</p>",
        "id": 430157936,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711658072
    },
    {
        "content": "<p>A drawback is that there isn't really any place to put the hypothesis names, but you can always use <code>rename_i</code></p>",
        "id": 430158196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711658184
    },
    {
        "content": "<p>Let me change my example slightly so as to better illustrate what I would need:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">test_app_ok</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">test_fam</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"c1\">-- cases H : h b fails but the following works and is doing what I want</span>\n<span class=\"k\">have</span> <span class=\"n\">hh</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">test_fam.rec</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">bb</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">test_fam</span> <span class=\"n\">bb</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"n\">bb</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n<span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">hh</span> <span class=\"n\">_</span>  <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 430224766,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1711702959
    },
    {
        "content": "<p>The approach in  Rocq/Coq amounts to providing some support for helping the proof assistant with guessing the expected value of the <code>motive</code> argument of the eliminator. In this examples Rocq/Coq's unification does not need any extra information to guess this value, but some syntax is available for providing user input, as the general case is a too difficult higher-order unification problem.</p>",
        "id": 430225296,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1711703251
    },
    {
        "content": "<p>if that motive is sufficient, then you can just use <code>generalize : f b = bb</code> without introducing the equality</p>",
        "id": 430228270,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711704852
    },
    {
        "content": "<p>But again, you have to write out <code>f b</code>.</p>",
        "id": 430232041,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711706604
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110172\">@Assia Mahboubi</span> For what it's worth, <code>cases h b</code> is successfully computing a motive here. It even handles generalizing indices itself (like what Mario pointed out). As I understand it, <code>cases h b</code> is doing something like the following until it gets stuck on the last line:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">test_app_not_ok</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">test_fam</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"n\">b</span>\n  <span class=\"n\">generalize</span> <span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"n\">at</span> <span class=\"n\">this</span> <span class=\"bp\">⊢</span>\n  <span class=\"n\">cases</span> <span class=\"n\">this</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hx</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  dependent elimination failed, failed to solve equation</span>\n<span class=\"cm\">    true = f b</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>\n<p>(In actuality, things are set up so that <code>x = f b</code> is in the target when applying the eliminator, and then it does <code>intro</code> and tries to do dependent elimination.)</p>",
        "id": 430294779,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711734951
    },
    {
        "content": "<p>It would be neat being able to tell <code>cases</code> either to not do dependent elimination or to do it in a weak way.</p>",
        "id": 430297227,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711735837
    }
]