[
    {
        "content": "<p>We're facing an issue where semireducible <code>List</code> functions in the library are blocking type class inference, similar to this MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">myLength</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">::</span><span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">myLength</span> <span class=\"n\">t</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"c1\">-- works</span>\n<span class=\"k\">#check</span>  <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span>  <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">myLength</span> <span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">]))</span> <span class=\"c1\">-- works</span>\n<span class=\"k\">#check</span>  <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span>  <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">List.length</span> <span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">]))</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>\n<p>In Lean 3 I would have locally changed the reducibility of <code>List.length</code> but Lean 4 doesn't allow this. Is there a canonical workaround, outside of redefining the relevant functions with <code>@[reducible]</code>?</p>",
        "id": 411532428,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1704569993
    },
    {
        "content": "<p>In this case you could introduce something like the following (possibly inline in the problematic decl):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">List.length</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)))</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n  <span class=\"k\">show</span> <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"n\">_</span> <span class=\"k\">from</span> <span class=\"n\">inferInstance</span>\n</code></pre></div>",
        "id": 411619243,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1704650038
    },
    {
        "content": "<p>Of course that doesn't answer the actual question.</p>",
        "id": 411619324,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1704650093
    },
    {
        "content": "<p>For this specific case you can also fix things with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">NeZero</span> <span class=\"o\">(</span><span class=\"n\">List.length</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>(with <code>import Mathlib.Data.Fin.Basic</code>)</p>",
        "id": 411623030,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704652728
    },
    {
        "content": "<p>Thanks. Unfortunately I'm not sure either of these translate to our actual use case <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span>  We have a large class of these problems, some too long to reasonably unfold by hand, and they show up in definitions theorem statements that we expect users to write.</p>",
        "id": 411626781,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1704656125
    },
    {
        "content": "<p>Does <code>no_index</code> help at all here?</p>",
        "id": 411633801,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704663193
    },
    {
        "content": "<p>I can't actually find any documentation about <code>no_index</code>, but if I understand correctly what it does, then no. (The <code>Nat</code> in this mwe isn't relevant.)</p>",
        "id": 411635349,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1704664725
    },
    {
        "content": "<p>This came up in iris-lean and it was addressed by just copy pasting all the list defs as reducible</p>",
        "id": 411867389,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704778606
    },
    {
        "content": "<p>Is it even allowed to make recursive definitions reducible? I think Gabriel once told me that Lean assumes only nonrecursive definitions are reducible. The question came up in a discussion about discrimination trees, so maybe discrimination tree indexing relies on this invariant for correctness.</p>",
        "id": 411904717,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1704795963
    },
    {
        "content": "<p>you can put <code>@[reducible] def</code> on a recursive def, but not <code>abbrev</code> IIRC</p>",
        "id": 411940454,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704808892
    },
    {
        "content": "<p>Yes, iirc the discrimination tree module eagerly unfolds reducible definitions.  So if you declare an instance for <code>NeZero (a :: b).lengthReducible</code>, then it wouldn't apply to <code>NeZero (a :: b :: c).lengthReducible</code> because the two are reduced to <code>NeZero a.lengthReducible.succ</code> and <code>NeZero c.lengthReducible.succ.succ</code> as a preprocessing step.</p>",
        "id": 412201347,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1704912957
    }
]