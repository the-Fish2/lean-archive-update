[
    {
        "content": "<p>I'm trying to prove that function composition preserves injectivity, and I was able to produce the following</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Injective</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">):</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">inj</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u₃</span><span class=\"o\">}:</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">Injective</span> <span class=\"n\">f</span> <span class=\"bp\">∧</span> <span class=\"n\">Injective</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">Injective</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">∘</span><span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"c1\">-- omitted for brevity</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>This works just fine, but what I really want is a typeclass <code>CompositionPreserves</code> and then an instance of <code>CompositionPreserves Injective</code> to provide a bit more structure. (I'm open to the idea that I don't actually want this, but it seems nice to be able to talk generically about properties preserved by composition). So what I've tried is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">CompositionPreserves</span> <span class=\"o\">(</span><span class=\"n\">property</span><span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">proof</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u₃</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">):</span>\n    <span class=\"n\">property</span> <span class=\"n\">f</span> <span class=\"bp\">∧</span> <span class=\"n\">property</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">property</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">∘</span><span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This doesn't seem to type-check and I'm unclear as to what's going wrong. It says that <code>f</code> has type <code>β → γ</code> but should have type <code>β → ?m.128</code>, which I would expect to unify. Indeed, these symbols actually have mismatched sorts, where <code>β → γ: Sort (imax u₂ u₃)</code> but should match <code>β → ?m.128 : Sort u₂</code>.</p>\n<p>I'm unclear as to why the <code>imax</code> is coming in to play and why the universe constraints can't be resolved. Any pointers would be greatly appreciated.</p>",
        "id": 434603592,
        "sender_full_name": "Andy Soffer",
        "timestamp": 1713718667
    },
    {
        "content": "<p>Your declaration of <code>property</code> says that it expects  <code>alpha</code> to have <code>sort u1</code> and <code>beta</code> to have <code>sort u2</code> but clearly in the case of <code>f</code> that is not the case, its first argument has <code>sort u2</code> and the result has <code>sort u3</code></p>",
        "id": 434603986,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1713718995
    },
    {
        "content": "<p>In order to write this down in the most general way that you are aiming here Lean would have to support universe level parameters at that position which, afaik, it doesn't. You can aim for a lesser level of generality by saying that all should be in the same universe and that would typecheck.</p>",
        "id": 434604138,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1713719143
    },
    {
        "content": "<p>This is super helpful, thank you. I expected the universe variables to be shadowed, but I don't think that's what was going on. Renaming them does resolve that particular issue, and forcing all the types into the same universe does typecheck properly!</p>",
        "id": 434604637,
        "sender_full_name": "Andy Soffer",
        "timestamp": 1713719579
    },
    {
        "content": "<p>universe variables are only declared per declaration. So if you have a <code>class</code> all universe variables that you mention in its body will be paramters of the class itself, not individual parts of the body</p>",
        "id": 434604906,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1713719834
    }
]