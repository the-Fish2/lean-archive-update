[
    {
        "content": "<p>Hello,<br>\nI encountered a bug where I can get the kernel to complain <em>or not</em> about <code>a non valid occurrence of the datatypes being declared</code>. I triggered this with mutually inductive definitions.<br>\nHere's a MWE, plus, depending on whether I got this right or not, some additional test cases.</p>\n<p>What kind of bug is this? Should I post this on <a href=\"https://github.com/leanprover/lean4/issues\">https://github.com/leanprover/lean4/issues</a>? And how can I work around it? (I mean, is there a more elegant solution than adding this <code>f</code> in a mutual block <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> )</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> MWE -/</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">ISignature</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">symbols</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n  <span class=\"n\">indices</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">symbols</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">I</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">All</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">All</span> <span class=\"n\">P</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">All</span> <span class=\"n\">P</span> <span class=\"n\">xs</span> <span class=\"bp\">→</span> <span class=\"n\">All</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MWE</span>\n\n<span class=\"kd\">mutual</span> <span class=\"c\">/-</span><span class=\"cm\"> Comment `f` to get</span>\n<span class=\"cm\">  `(kernel) arg #6 of '_nested.All_1.cons' contains a non valid occurrence of the datatypes being declared`</span>\n<span class=\"cm\">  Why should the presence of `f` affect the validity of `Iμ`? -/</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">f</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ζ</span> <span class=\"o\">:</span> <span class=\"n\">ISignature.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Iμ</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ζ</span> <span class=\"o\">:</span> <span class=\"n\">ISignature.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ζ.symbols</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">All</span> <span class=\"o\">(</span><span class=\"n\">Iμ</span> <span class=\"n\">ζ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ζ.indices</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Iμ</span> <span class=\"n\">ζ</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">end</span> <span class=\"c1\">-- tested on nightly-2024-02-21</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MWE</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> Additional cases -/</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">PotentialTestCases</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">IInterp</span> <span class=\"o\">(</span><span class=\"n\">ζ</span> <span class=\"o\">:</span> <span class=\"n\">ISignature.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ζ.symbols</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">All</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">ζ.indices</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">IInterp</span> <span class=\"n\">ζ</span> <span class=\"n\">P</span> <span class=\"n\">i</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Case1</span>\n<span class=\"c\">/-</span><span class=\"cm\"> I'm not sure whether this is really strictly positive or not, should Lean accept this ? -/</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Iμ</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ζ</span> <span class=\"o\">:</span> <span class=\"n\">ISignature.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ζ.symbols</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">All</span> <span class=\"o\">(</span><span class=\"n\">Iμ</span> <span class=\"n\">ζ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ζ.indices</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Iμ</span> <span class=\"n\">ζ</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Case1</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Case2</span>\n<span class=\"c\">/-</span><span class=\"cm\"> If Case1 is OK (and if I got it right) Lean should accept this -/</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"I⟦ \"</span> <span class=\"n\">ζ</span> <span class=\"s2\">\" ⟧\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">IInterp</span> <span class=\"n\">ζ</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Iμ</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ζ</span> <span class=\"o\">:</span> <span class=\"n\">ISignature.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">I</span><span class=\"bp\">⟦</span> <span class=\"n\">ζ</span> <span class=\"bp\">⟧</span> <span class=\"o\">(</span><span class=\"n\">Iμ</span> <span class=\"n\">ζ</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">Iμ</span> <span class=\"n\">ζ</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Case2</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Case3</span>\n<span class=\"c\">/-</span><span class=\"cm\"> This is probably *not* a planned feature for Lean, but just for reference</span>\n<span class=\"cm\">  this is my best try at a faithful translation of the code. -/</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">i_universal</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">i</span>\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"∀[ \"</span> <span class=\"n\">P</span> <span class=\"s2\">\" ]\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">i_universal</span> <span class=\"n\">P</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">i_exponential</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"kn\">local</span> <span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">30</span> <span class=\"s2\">\" ⇒ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">i_exponential</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Iμ</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ζ</span> <span class=\"o\">:</span> <span class=\"n\">ISignature.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">[</span> <span class=\"n\">I</span><span class=\"bp\">⟦</span> <span class=\"n\">ζ</span> <span class=\"bp\">⟧</span> <span class=\"o\">(</span><span class=\"n\">Iμ</span> <span class=\"n\">ζ</span><span class=\"o\">)</span> <span class=\"bp\">⇒</span> <span class=\"n\">Iμ</span> <span class=\"n\">ζ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Case3</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">PotentialTestCases</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> This is from -- specifically 3.3</span>\n<span class=\"cm\">  Cas van der Rest, Casper Bach Poulsen, Arjen Rouvoet, Eelco Visser, and Peter Mosses. 2022</span>\n<span class=\"cm\">  Intrinsically-Typed Definitional Interpreters à la Carte</span>\n<span class=\"cm\">  https://doi.org/10.1145/3563355</span>\n\n<span class=\"cm\">  I'm trying to translate their code from Agda to Lean 4</span>\n<span class=\"cm\">  artifact https://doi.org/10.5281/zenodo.7074690</span>\n<span class=\"cm\">  oopsla-code/oopsla-src/Supplementary/Signature.agda, l.90-118</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>",
        "id": 422655207,
        "sender_full_name": "Julien Marquet",
        "timestamp": 1708532220
    },
    {
        "content": "<p>In your first example, it's not that with <code>f</code> you don't get the <code>arg #6 of '_nested.All_1.cons' contains a non valid occurrence</code> error, you get a different error <code>(kernel) declaration has free variables 'MWE.Iμ'</code> which is presumably shadowing the first error.</p>",
        "id": 422711657,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708552849
    },
    {
        "content": "<p>If I unfold the nested inductive use like so we get the <code>declaration has free variables</code> error again, so I think that's the original error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Iμ</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ζ</span> <span class=\"o\">:</span> <span class=\"n\">ISignature.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ζ.symbols</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">All_Iμ</span> <span class=\"n\">ζ</span> <span class=\"o\">(</span><span class=\"n\">ζ.indices</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Iμ</span> <span class=\"n\">ζ</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">All_Iμ</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ζ</span> <span class=\"o\">:</span> <span class=\"n\">ISignature.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">All_Iμ</span> <span class=\"n\">ζ</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">Iμ</span> <span class=\"n\">ζ</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">All_Iμ</span> <span class=\"n\">ζ</span> <span class=\"n\">xs</span> <span class=\"bp\">→</span> <span class=\"n\">All_Iμ</span> <span class=\"n\">ζ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 422712702,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708553347
    },
    {
        "content": "<p>unfolding the mutual as well results in something that passes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Iμ</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ζ</span> <span class=\"o\">:</span> <span class=\"n\">ISignature.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">⊕</span> <span class=\"n\">List</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ζ.symbols</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Iμ</span> <span class=\"n\">ζ</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"o\">(</span><span class=\"n\">ζ.indices</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">Iμ</span> <span class=\"n\">ζ</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">Iμ</span> <span class=\"n\">ζ</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"o\">[])</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">Iμ</span> <span class=\"n\">ζ</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Iμ</span> <span class=\"n\">ζ</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Iμ</span> <span class=\"n\">ζ</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 422712963,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708553486
    },
    {
        "content": "<p>Your <code>Case1</code> errors out because Lean tries to promote <code>Iμ</code>'s index (of type <code>I</code>) to a parameter, even though it shouldn't, and disabling that feature fixes the issue. However, there are no options currently to turn that off.</p>",
        "id": 422723380,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1708559739
    },
    {
        "content": "<p>It would be nice to have some kind of option to turn the promotion of indices to parameters off.</p>",
        "id": 422723527,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1708559860
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/bug.3A.20nonsensical.20disapperarence.20of.20kernel.20error.20message/near/422711657\">said</a>:</p>\n<blockquote>\n<p>In your first example, it's not that with <code>f</code> you don't get the <code>arg #6 of '_nested.All_1.cons' contains a non valid occurrence</code> error, you get a different error <code>(kernel) declaration has free variables 'MWE.Iμ'</code> which is presumably shadowing the first error.</p>\n</blockquote>\n<p>Are you testing this on nightly ? The <code>declaration has free variables</code> error should have been fixed in <a href=\"https://github.com/leanprover/lean4/pull/3246\">lean4#3246</a> (I don't get that error on nightly)</p>",
        "id": 422723798,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1708560039
    },
    {
        "content": "<p>Furthermore, your <code>Case2</code> shouldn't work, since a free variable appears in a parameter of <code>IInterp</code></p>",
        "id": 422725081,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1708560778
    },
    {
        "content": "<p>I did not test on nightly</p>",
        "id": 422728068,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708562979
    },
    {
        "content": "<p>I think Case1 reveals some issues in the promotion algorithm, which presumably are related to the fact that the elaborator currently doesn't try to simulate the nested inductive check at all and leaves the kernel to do all the error handling (even though generally this is something the elaborator tries to avoid elsewhere)</p>",
        "id": 422729015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708563681
    },
    {
        "content": "<p>Case2 also reveals issues in the promotion algorithm but in a different way: it's not always the case that promoting an index to a parameter makes it more usable. Using the trick of using mutual inductives to force no promotion, note that uncommenting <code>foo</code> makes <code>Iμ</code> pass:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n<span class=\"c1\">-- inductive foo (ζ : ISignature.{u,v} I) (P : I → Type w) : Type (max u v w)</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">IInterp</span> <span class=\"o\">(</span><span class=\"n\">ζ</span> <span class=\"o\">:</span> <span class=\"n\">ISignature.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ζ.symbols</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">All</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">ζ.indices</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">IInterp</span> <span class=\"n\">ζ</span> <span class=\"n\">P</span> <span class=\"n\">i</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">mutual</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">bar</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ζ</span> <span class=\"o\">:</span> <span class=\"n\">ISignature.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Iμ</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ζ</span> <span class=\"o\">:</span> <span class=\"n\">ISignature.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">IInterp</span> <span class=\"n\">ζ</span> <span class=\"o\">(</span><span class=\"n\">Iμ</span> <span class=\"n\">ζ</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">Iμ</span> <span class=\"n\">ζ</span> <span class=\"n\">i</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 422729273,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708563852
    },
    {
        "content": "<p>I think we should fix this by making the nested inductive algorithm allow such uses though</p>",
        "id": 422729290,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708563870
    },
    {
        "content": "<p>I believe there are a few things to look into here:</p>\n<ol>\n<li>There should be an option to turn off the auto-promotion from index to paramater, users shouldn't be expected to use the <code>mutual</code> trick for their things to work</li>\n<li>The promotion algorithm should be improved so that the index doesn't get promoted in <code>Case1</code> (i.e by seeing that the index doesn't appear in the <code>(Iμ ζ)</code> expression, meaning it’s not fixed)</li>\n<li>Lean could allow for more leniancy when it comes to having free variables in nested parameters. Note that Coq is already more lenient on that matter, but it's not clear why/how it should be justified, and whether this leads to theoretical issues. In particular, inductive types such as this one are accepted there:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Inductive</span> <span class=\"n\">EqBinTree</span> <span class=\"o\">:=</span>\n  <span class=\"o\">|</span> <span class=\"n\">node</span>\n  <span class=\"o\">|</span> <span class=\"n\">nil</span> <span class=\"o\">(</span><span class=\"n\">tree1</span> <span class=\"n\">tree2</span> <span class=\"o\">:</span> <span class=\"n\">EqBinTree</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tree1</span> <span class=\"o\">=</span> <span class=\"n\">tree2</span> <span class=\"o\">-&gt;</span> <span class=\"n\">EqBinTree</span><span class=\"o\">.</span>\n</code></pre></div>\n<p>Some Coq devs believe types such as this one could lead to a proof of UIP in Coq, which would be undesirable in their case. No-one has dived into the matter of nested inductives much in the type-theory community AFAIK.</p>",
        "id": 422754176,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1708582342
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/bug.3A.20nonsensical.20disapperarence.20of.20kernel.20error.20message/near/422729273\">said</a>:</p>\n<blockquote>\n<p>Using the trick of using mutual inductives to force no promotion, note that uncommenting <code>foo</code> makes <code>Iμ</code> pass:</p>\n</blockquote>\n<p>Thanks for this remark, this makes my code work again <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 423010323,
        "sender_full_name": "Julien Marquet",
        "timestamp": 1708692803
    }
]