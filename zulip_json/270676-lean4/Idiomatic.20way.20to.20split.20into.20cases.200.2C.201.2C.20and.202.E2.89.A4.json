[
    {
        "content": "<p>A couple of times now I had <code>n : ℕ</code> and wanted to split my proof into three cases, <code>n = 0</code>, <code>n = 1</code>, and <code>2 ≤ n</code>. I can get there using multiple <code>by_cases</code>, but I wonder if there is a more idiomatic way to get there. The most recent case also works as an mwe</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Nat.log2_eq_size_pred</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">log2</span> <span class=\"n\">n</span>  <span class=\"bp\">=</span> <span class=\"n\">size</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">using</span> <span class=\"n\">Nat.binaryRec</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">z</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">log2</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>In this case I want to split into the three cases for <code>bit b n</code>.</p>",
        "id": 438177647,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1715512408
    },
    {
        "content": "<p>This mwe uses Mathlib (due to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.size#doc\">docs#Nat.size</a>), but I would assume that splitting into those three cases could be done without relying on Mathlib.</p>",
        "id": 438177762,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1715512557
    },
    {
        "content": "<p>You can use the normal programming <code>match</code> in tactics as well to pattern match on some number arbitrarily</p>",
        "id": 438177941,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1715512775
    },
    {
        "content": "<p>Also, <code>rcases n with _|_|n</code> may get you to the right place (untested).</p>",
        "id": 438178161,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1715513029
    },
    {
        "content": "<p>I tried <code>match</code>, and I can split it into three cases, but how to I get the hypothesis <code>2 ≤ bit b n</code> in the last case?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Nat.log2_eq_size_pred</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">log2</span> <span class=\"n\">n</span>  <span class=\"bp\">=</span> <span class=\"n\">size</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">using</span> <span class=\"n\">Nat.binaryRec</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">z</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">log2</span>\n    <span class=\"k\">match</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">bit</span> <span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">m</span><span class=\"o\">]</span>\n      <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 438178245,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1715513102
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Nat.log2_eq_size_pred</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">log2</span> <span class=\"n\">n</span>  <span class=\"bp\">=</span> <span class=\"n\">size</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">using</span> <span class=\"n\">Nat.binaryRec</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">z</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">log2</span>\n    <span class=\"k\">match</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">bit</span> <span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"c1\">-- note that we explicitly match on x + 2 here and lean understands that the other cases are not possible</span>\n      <span class=\"c1\">-- You could explicitly derive it now but we can also just do</span>\n      <span class=\"n\">simp</span>\n      <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 438178813,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1715513785
    },
    {
        "content": "<p>This is how I completed the proof using <code>match</code>, <code>rcases n with _|_|n</code> works as well.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">bit_div_two</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">bit</span> <span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">bit_false</span><span class=\"o\">,</span> <span class=\"n\">bit_true</span><span class=\"o\">,</span> <span class=\"n\">Nat.bit1_div_two</span><span class=\"o\">,</span> <span class=\"n\">Nat.bit0_div_two</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">bit_true_zero</span> <span class=\"o\">:</span> <span class=\"n\">bit</span> <span class=\"n\">true</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">bit_false_zero</span> <span class=\"o\">:</span> <span class=\"n\">bit</span> <span class=\"n\">false</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">log2_eq_size_pred</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">log2</span> <span class=\"n\">n</span>  <span class=\"bp\">=</span> <span class=\"n\">size</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">using</span> <span class=\"n\">Nat.binaryRec</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">z</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">log2</span>\n    <span class=\"k\">match</span> <span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">bit</span> <span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ge_iff_le</span><span class=\"o\">,</span> <span class=\"n\">le_add_iff_nonneg_left</span><span class=\"o\">,</span> <span class=\"n\">_root_.zero_le</span><span class=\"o\">,</span> <span class=\"bp\">↓</span><span class=\"n\">reduceIte</span><span class=\"o\">]</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">succ_eq_add_one</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hm</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hm</span><span class=\"o\">]</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Nat.bit</span> <span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">omega</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">bit_div_two</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">Nat.size_bit</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">succ_eq_add_one</span><span class=\"o\">,</span> <span class=\"n\">add_tsub_cancel_right</span><span class=\"o\">]</span>\n      <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">induction</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hm</span>\n      <span class=\"bp\">|</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">apply</span> <span class=\"n\">Nat.sub_add_cancel</span>\n        <span class=\"n\">apply</span> <span class=\"n\">Nat.size_le_size</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n        <span class=\"n\">omega</span>\n</code></pre></div>",
        "id": 438180790,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1715515938
    },
    {
        "content": "<p>Are you looking for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.binaryRec%27#doc\">docs#Nat.binaryRec'</a> (the primed one)?</p>",
        "id": 438181854,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715517220
    },
    {
        "content": "<p>I see that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.binaryRec%27#doc\">docs#Nat.binaryRec'</a> allows me to replace the <code>induction b &lt;;&gt; simp at hm</code> line by a simple <code>simp_all</code>, but I don't see how it would have helped me with any of the case distinctions I made.</p>",
        "id": 438190896,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1715526430
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Nat.log2_eq_size_pred</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">log2</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">size</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">using</span> <span class=\"n\">Nat.binaryRecFromOne</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">z₀</span> <span class=\"bp\">|</span> <span class=\"n\">z₁</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"n\">n0</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">bit</span> <span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">bit_val</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">omega</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 438243107,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1715576086
    }
]