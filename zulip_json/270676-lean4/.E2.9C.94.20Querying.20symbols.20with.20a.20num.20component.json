[
    {
        "content": "<p>Some proofs (values of theorem symbols) contain references to symbols such as this one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Init.Data.Nat.Basic._auxLemma.4</span>\n</code></pre></div>\n<p>When I run <code>#check</code>, these symbols are not visible, and they cannot be used in a proof either:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- unknown identifier 'Init.Data.Nat.Basic._auxLemma'</span>\n<span class=\"k\">#check</span> <span class=\"n\">Init.Data.Nat.Basic._auxLemma.4</span>\n</code></pre></div>\n<p>This doesn't work even with French double quotes. How can I query information about and use this symbol in Lean?</p>",
        "id": 429772919,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1711507721
    },
    {
        "content": "<p>For example, in a proof like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">&lt;=</span> <span class=\"mi\">5</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">nat.le_trans</span>\n  <span class=\"bp\">.</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">.</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"mi\">2</span>\n</code></pre></div>\n<p>This proof was procedurally created since after the <code>apply</code> step there will be 3 goals:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>        <span class=\"bp\">?</span><span class=\"mi\">0</span><span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">?</span><span class=\"mi\">2</span>\n        <span class=\"bp\">?</span><span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"bp\">?</span><span class=\"mi\">2</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">5</span>\n        <span class=\"bp\">?</span><span class=\"mi\">2</span><span class=\"o\">:</span> <span class=\"n\">Nat</span>\n</code></pre></div>\n<p>and I wanted to assign to <code>?2</code> first. The result of the proof is something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Nat.le_trans</span> <span class=\"o\">(</span><span class=\"n\">of_eq_true</span> <span class=\"o\">(</span><span class=\"n\">Init.Data.Nat.Basic._auxLemma.4</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">of_eq_true</span> <span class=\"o\">(</span><span class=\"n\">eq_true_of_decide</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"n\">Bool.true</span><span class=\"o\">)))</span>\n</code></pre></div>\n<p>which contained a <code>_auxLemma</code> term. However when I feed this value back into Lean I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- unknown identifier 'Init.Data.Nat.Basic._auxLemma'</span>\n<span class=\"k\">#check</span> <span class=\"n\">Nat.le_trans</span> <span class=\"o\">(</span><span class=\"n\">of_eq_true</span> <span class=\"o\">(</span><span class=\"n\">Init.Data.Nat.Basic._auxLemma.4</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">of_eq_true</span> <span class=\"o\">(</span><span class=\"n\">eq_true_of_decide</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"n\">Bool.true</span><span class=\"o\">)))</span>\n</code></pre></div>",
        "id": 429794478,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1711522128
    },
    {
        "content": "<p>This isn't an XY problem because I'm writing machine learning algorithms that interface with Lean expression objects directly, and it needs to be able to determine the types of expression trees.</p>",
        "id": 429794698,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1711522285
    },
    {
        "content": "<p>You can assign implicit variables in two ways</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">&lt;=</span> <span class=\"mi\">5</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Nat.le_trans</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n  <span class=\"bp\">.</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">.</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">&lt;=</span> <span class=\"mi\">5</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">Nat.le_trans</span> <span class=\"n\">_</span> <span class=\"mi\">2</span> <span class=\"n\">_</span>\n  <span class=\"bp\">.</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">.</span> <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 429842196,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1711540539
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/stream/270676-lean4/topic/Querying.20symbols.20with.20a.20num.20component/near/429794698\">said</a>:</p>\n<blockquote>\n<p>This isn't an XY problem because I'm writing machine learning algorithms that interface with Lean expression objects directly, and it needs to be able to determine the types of expression trees.</p>\n</blockquote>\n<p>Thanks for explaining that â€” I believe then this <em>is</em> an XY problem! You should unfold these <code>_auxLemma</code> constants, since they hide the true lemma that <code>simp</code> used. Here is code I've used for this before:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span>\n\n<span class=\"sd\">/-- Whether the lemma has a name of the form produced by `Lean.Meta.mkAuxLemma`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Lean.Name.isAuxLemma</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"n\">matches</span> <span class=\"bp\">.</span><span class=\"n\">num</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">str</span> <span class=\"n\">_</span> <span class=\"s2\">\"_auxLemma\"</span><span class=\"o\">)</span> <span class=\"n\">_</span>\n\n<span class=\"sd\">/-- Unfold all lemmas created by `Lean.Meta.mkAuxLemma`. These end in `_auxLemma.nn` where `nn` is a number. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Lean.Meta.unfoldAuxLemmas</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">deltaExpand</span> <span class=\"n\">e</span> <span class=\"n\">Lean.Name.isAuxLemma</span>\n</code></pre></div>",
        "id": 429882515,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711552036
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> has marked this topic as resolved.</p>",
        "id": 430207105,
        "sender_full_name": "Notification Bot",
        "timestamp": 1711692112
    }
]