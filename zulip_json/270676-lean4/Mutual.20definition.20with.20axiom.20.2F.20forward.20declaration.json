[
    {
        "content": "<p>Hello, </p>\n<p>I am trying to write type whose constructor includes a predicate on this type, but I do not want to go into the definition of this predicate, I take it as given. In Agda I can write</p>\n<div class=\"codehilite\" data-code-language=\"Agda\"><pre><span></span><code><span class=\"kr\">data</span><span class=\"w\"> </span>MyType<span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span><span class=\"kt\">Set</span>\n\n<span class=\"kr\">postulate</span>\n<span class=\"w\">  </span><span class=\"nf\">MyPredicateOnType</span><span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span>MyType<span class=\"w\"> </span><span class=\"ow\">→</span><span class=\"w\"> </span>MyType<span class=\"w\"> </span><span class=\"ow\">→</span><span class=\"w\"> </span><span class=\"kt\">Set</span>\n\n<span class=\"kr\">data</span><span class=\"w\"> </span>MyType<span class=\"w\"> </span><span class=\"kr\">where</span>\n<span class=\"w\">    </span><span class=\"nf\">init</span><span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span>MyType\n<span class=\"w\">    </span><span class=\"nf\">cons</span><span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span><span class=\"o\">(</span>e1<span class=\"w\"> </span>e2<span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span>MyType<span class=\"o\">)</span><span class=\"w\"> </span><span class=\"ow\">→</span><span class=\"w\"> </span>MyPredicateOnType<span class=\"w\"> </span>e1<span class=\"w\"> </span>e2<span class=\"w\"> </span><span class=\"ow\">→</span><span class=\"w\"> </span>MyType\n</code></pre></div>\n<p>But I fail to write the Lean equivalent, as Lean does not seem to support this kind of forward declaration (see this thread <a href=\"#narrow/stream/270676-lean4/topic/forward.20declarations\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/forward.20declarations</a>), and I do not seem to be able use an axiom or an opaque definition in a mutual block.</p>\n<p>A workaround is defining two types, with the first one not including the predicate, whereas the second one would include it, something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">MyType1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">init</span> <span class=\"o\">:</span> <span class=\"n\">MyType1</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">MyType1</span> <span class=\"bp\">→</span> <span class=\"n\">MyType1</span> <span class=\"bp\">→</span> <span class=\"n\">MyType1</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">MyPredicateOnType</span> <span class=\"o\">:</span> <span class=\"n\">MyType1</span> <span class=\"bp\">→</span> <span class=\"n\">MyType1</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">MyType2</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">init</span> <span class=\"o\">:</span> <span class=\"n\">MyType1</span> <span class=\"bp\">→</span> <span class=\"n\">MyType2</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">e1</span> <span class=\"n\">e2</span> <span class=\"o\">:</span> <span class=\"n\">MyType1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">MyPredicateOnType</span> <span class=\"n\">e1</span> <span class=\"n\">e2</span> <span class=\"bp\">→</span> <span class=\"n\">MyType2</span>\n</code></pre></div>\n<p>But I'd prefer a clear solution. Is there any? Thank you!</p>",
        "id": 423848598,
        "sender_full_name": "bruno cuconato",
        "timestamp": 1709135617
    },
    {
        "content": "<p>I think the standard approach here is approximately what you've proposed:</p>\n<ol>\n<li>Define the inductive type without restricting to any predicates</li>\n<li>Define a recursive validity predicate on the initial inductive type</li>\n<li>Use the subtype defined by the validity predicate instead of the base type thereafter</li>\n</ol>\n<p>The Lean 4 manual has <a href=\"https://lean-lang.org/lean4/doc/examples/bintree.lean.html\">an example of this for a binary search tree data structure</a></p>",
        "id": 423849617,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709135928
    },
    {
        "content": "<p>Note that <code>MyType2</code> as you've defined it above isn't exactly what you want: it only ensures that the outermost cons-pair satisfies <code>MyPredicateOnType</code>, not that every cons-pair does so recursively</p>",
        "id": 423850407,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709136122
    },
    {
        "content": "<p>I doubt the agda behavior here was sound. If you just want to emulate what you were doing in Agda and bypass Lean's soundness checks, I imagine that one of your original ideas would work with <code>unsafe inductive</code></p>",
        "id": 423851603,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709136415
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"500038\">@Timo Carlin-Burns</span>! That helps. Out of curiosity, do you perchance have an example of how this Agda behaviour can lead to an unsoundness?</p>",
        "id": 423875761,
        "sender_full_name": "bruno cuconato",
        "timestamp": 1709144154
    },
    {
        "content": "<p>Lean has a number of limitations on inductive type definitions that mostly boil down to something called \"strict positivity\". \"strict positivity\" has <a href=\"https://lean-lang.org/theorem_proving_in_lean4/inductive_types.html#axiomatic-details\">a precise definition in Theorem Proving in Lean</a> but basically means that you only refer to your type within its own definition in certain positions:</p>\n<ul>\n<li>As the return type of a constructor</li>\n<li>As an argument to a constructor</li>\n<li>As the return type of a function which is an argument to a constructor</li>\n</ul>\n<p>So e.g. the following is fine:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">MyInfiniteTree</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">:</span> <span class=\"n\">MyInfiniteTree</span>\n<span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">MyInfiniteTree</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">MyInfiniteTree</span> <span class=\"c1\">-- each node has infinite children</span>\n<span class=\"c1\">--               ^ occurs as return type, not input type, of a function</span>\n</code></pre></div>\n<p>An example which is not fine is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Bad</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">ofFn</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Bad</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Bad</span>\n</code></pre></div>\n<p>Here <code>ofFn</code> is a constructor, and all constructors are injective, so we have an injective function from <code>(Bad -&gt; Bool) -&gt; Bad</code> which is impossible by cantor's diagonal argument.</p>\n<p>I don't know how to construct an example where you would try to define a type and a predicate on it in a mutual inductive fashion and it would lead to inconsistency, but in general, the strict positivity check means you're not really supposed to use your type as an input to anything while you're defining it.</p>",
        "id": 423905086,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709155268
    },
    {
        "content": "<p>Thanks for the explanation. Agda does not accept this <code>Bad</code> example, but I guess it accepts my former example because the expression <code>MyPredicateOnType e1 e2</code> has type <code>Set</code>. So I don't see why the strict positivity check would be a problem here, and thus I am led to think (maybe wrongly, I'll gladly take further corrections/explanations!) that Lean would accept my Lean code if I could forward declare <code>MyPredicateOnType</code> or mutually define it.</p>",
        "id": 424321316,
        "sender_full_name": "bruno cuconato",
        "timestamp": 1709325033
    },
    {
        "content": "<p>I believe Agda supports both <a href=\"https://ncatlab.org/nlab/show/inductive-inductive+type\">inductive-inductive datatypes</a> and <a href=\"https://ncatlab.org/nlab/show/inductive-recursive+type\">inductive-recursive datatypes</a>. Lean accepts neither of them.</p>\n<p>Your example is an inductive-inductive datatype (at least if <code>MyPredicateOnType</code> is data instead of a postulate). You can encode these in Lean, see for example <a href=\"#narrow/stream/113488-general/topic/inductive-inductive.20types\">this thread</a>. Inductive-recursive datatypes significantly increase the proof-theoretic strength of a system, hence cannot be encoded in Lean in general.</p>",
        "id": 424332818,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709330616
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"550232\">@bruno cuconato</span> Here's a basic example of issues that could come up if you aren't careful what is allowed in the definition of <code>MyPredicateOnType</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">MyType</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">init</span> <span class=\"o\">:</span> <span class=\"n\">MyType</span> <span class=\"bp\">→</span> <span class=\"n\">MyType</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">e1</span> <span class=\"n\">e2</span> <span class=\"o\">:</span> <span class=\"n\">MyType</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">MyPredicateOnType</span> <span class=\"n\">e1</span> <span class=\"n\">e2</span> <span class=\"bp\">→</span> <span class=\"n\">MyType</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MyPredicateOnType</span> <span class=\"o\">:</span> <span class=\"n\">MyType</span> <span class=\"bp\">→</span> <span class=\"n\">MyType</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">MyType.cons</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span> <span class=\"bp\">→</span> <span class=\"n\">False</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>This is only a lightly obfuscated version of the liar paradox:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">MyPredicateOnType</span> <span class=\"o\">:</span> <span class=\"n\">MyType</span> <span class=\"bp\">→</span> <span class=\"n\">MyType</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">¬</span> <span class=\"n\">MyPredicateOnType</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>which causes inconsistency in any system that allows the definition</p>",
        "id": 424368582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709358910
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>  and <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> ! That helped me understand why I should follow the Lean <em>modus operandi</em> and do something similar to the BST example Timo linked. I don't actually need inductive-inductive or inductive-recursive datatypes for what I'm doing after all :)</p>",
        "id": 426539518,
        "sender_full_name": "bruno cuconato",
        "timestamp": 1710422345
    }
]