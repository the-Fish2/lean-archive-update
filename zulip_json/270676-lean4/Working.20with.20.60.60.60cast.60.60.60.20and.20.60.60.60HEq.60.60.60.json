[
    {
        "content": "<p>Okay, so I'm not sure that I'm approaching this the right way... The original problem that I'm trying to solve is proving the following lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Finite</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Set.Finite</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">//</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"bp\">|</span>\n    <span class=\"n\">p.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">p.2.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I was able to write a proof, here it is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Finite</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Set</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Set.Finite</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">//</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"bp\">|</span>\n    <span class=\"n\">p.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">p.2.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">set</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">//</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"bp\">|</span>\n      <span class=\"n\">p.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">p.2.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.finite_def</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Nonempty.intro</span>\n  <span class=\"n\">set</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Finset.range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Finset.range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">×</span>\n        <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">|</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"o\">⟨⟨</span><span class=\"n\">p.1.1</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_range.mpr</span> <span class=\"n\">p.2.1</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">p.1.2.1</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_range.mpr</span> <span class=\"n\">p.2.2</span><span class=\"o\">⟩,</span> <span class=\"n\">p.1.2.2</span><span class=\"o\">⟩)</span>\n  <span class=\"n\">set</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Finset.range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Finset.range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">×</span>\n        <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">|</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n        <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">refine</span> <span class=\"o\">⟨⟨</span><span class=\"n\">p.1</span><span class=\"o\">,</span> <span class=\"n\">p.2.1</span><span class=\"o\">,</span> <span class=\"n\">p.2.2</span><span class=\"o\">⟩,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n                    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">coe_setOf</span><span class=\"o\">,</span> <span class=\"n\">mem_setOf_eq</span><span class=\"o\">]</span>\n                    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">Finset.mem_range.mp</span> <span class=\"n\">p.1.property</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_range.mp</span> <span class=\"n\">p.2.1.property</span><span class=\"o\">⟩</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">⟩</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">coe_setOf</span><span class=\"o\">,</span> <span class=\"n\">mem_setOf_eq</span><span class=\"o\">,</span> <span class=\"n\">Sigma.eta</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">⟩</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">coe_setOf</span><span class=\"o\">,</span> <span class=\"n\">mem_setOf_eq</span><span class=\"o\">,</span> <span class=\"n\">id_eq</span><span class=\"o\">]</span>\n  <span class=\"n\">set</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">≃</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Finset.range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Finset.range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">×</span>\n        <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">|</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n        <span class=\"o\">{</span><span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"n\">g</span>\n         <span class=\"n\">invFun</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n         <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"n\">h1</span>\n         <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"n\">h2</span><span class=\"o\">}</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Fintype.ofEquiv</span> <span class=\"n\">_</span> <span class=\"n\">e.symm</span>\n</code></pre></div>\n<p>However, it a bit clunky, and I have several similar results to prove (but not similar enough to have an obvious common generalizations:  the difference is that there are more or less factors in the product).</p>\n<p>So I though that the best would be to have a result saying \"if I have a map with a finite image and finite fibers, then its domain is finite\", or something slightly more general. This was easy, here it is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Finite</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Set.Finite.of_finite_image_of_finite_fibers</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hfin1</span> <span class=\"o\">:</span> <span class=\"n\">Set.Finite</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hfin2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">Set.Finite</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">y</span><span class=\"o\">}))</span> <span class=\"o\">:</span>\n    <span class=\"n\">Set.Finite</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Set.Finite.subset</span> <span class=\"o\">(</span><span class=\"n\">Set.Finite.biUnion</span> <span class=\"n\">hfin1</span> <span class=\"n\">hfin2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"bp\">↦</span> <span class=\"n\">Set.mem_biUnion</span>\n  <span class=\"o\">(</span><span class=\"n\">Set.mem_image_of_mem</span> <span class=\"n\">f</span> <span class=\"n\">hx</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_preimage</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_singleton_iff</span><span class=\"o\">]))</span>\n</code></pre></div>\n<p>But I ran into trouble when trying to apply it to my example. First I defined the function, the obvious idea is projection on the first two factors, here it is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">//</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨</span><span class=\"n\">p.1</span><span class=\"o\">,</span> <span class=\"n\">p.2.1</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>Okay, now I need to prove that the fibers of <code>f</code> are finie. So the most obvious is to define an injective map <code>g</code> from the fiber at <code>(k,l)</code> into <code>Finset (Fin (k + l))</code>, because that last thing is certainly finite. Here is the map <code>g</code>, already I am starting to struggle:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">⟩}</span> <span class=\"bp\">→</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n          <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">Prod.eq_iff_fst_eq_snd_eq.mp</span>\n                       <span class=\"o\">(</span><span class=\"n\">Set.mem_singleton_iff.mp</span> <span class=\"o\">(</span><span class=\"n\">Set.mem_preimage.mp</span> <span class=\"n\">x.2</span><span class=\"o\">))</span>\n                     <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n                     <span class=\"n\">refine</span> <span class=\"n\">cast</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"n\">x.1.2.2.1</span>\n                     <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">h.1</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">h.2</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Now I just need to prove that <code>g</code> is injective, except I can't seem to do it. I am battling expressions full of <code>cast</code> and <code>HEq</code> and I don't really know what to do. I can show you how I started, but very quickly I start going round in circles:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Function.Injective</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">k</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n  <span class=\"k\">have</span> <span class=\"n\">hx</span> <span class=\"o\">:=</span> <span class=\"n\">Prod.eq_iff_fst_eq_snd_eq.mp</span> <span class=\"o\">(</span><span class=\"n\">Set.mem_singleton_iff.mp</span> <span class=\"o\">(</span><span class=\"n\">Set.mem_preimage.mp</span> <span class=\"n\">x.2</span><span class=\"o\">))</span>\n  <span class=\"k\">have</span> <span class=\"n\">hy</span> <span class=\"o\">:=</span> <span class=\"n\">Prod.eq_iff_fst_eq_snd_eq.mp</span> <span class=\"o\">(</span><span class=\"n\">Set.mem_singleton_iff.mp</span> <span class=\"o\">(</span><span class=\"n\">Set.mem_preimage.mp</span> <span class=\"n\">y.2</span><span class=\"o\">))</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">f</span> <span class=\"n\">at</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"n\">at</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">ext</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hx.1</span><span class=\"o\">,</span> <span class=\"n\">hy.1</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">heq_of_cast_eq</span>\n</code></pre></div>\n<p>And so on...</p>",
        "id": 409637749,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703276345
    },
    {
        "content": "<p>I understand that of the problems is that, if even if, say, I know that <code>n = m</code>, then this does not mean that <code>Fin n = Fin m</code> and I need to use <code>cast</code> in order to move elements between these types. But that doesn't tell me how to use this strange <code>cast</code> function...</p>",
        "id": 409638328,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703276725
    },
    {
        "content": "<p>Certainly <code>m = n</code> implies <code>Fin m = Fin n</code>! What you mean is that the typechecker doesn't know they are equal unless you actually substitute the <code>m = n</code> equality.</p>",
        "id": 409638497,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703276828
    },
    {
        "content": "<p>Do you know about <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#subst\">tactic#subst</a> ?</p>",
        "id": 409638542,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703276862
    },
    {
        "content": "<p>I certainly don't know about that tactic. Let me check it out, thanks !</p>",
        "id": 409639121,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703277261
    },
    {
        "content": "<p>(Equality is complicated.)</p>",
        "id": 409639154,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703277299
    },
    {
        "content": "<p>Going back to the beginning, I think this would be easiest rewriting it as a product involving set products, and it's a product of finite sets.</p>",
        "id": 409639170,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703277310
    },
    {
        "content": "<p>Oh, oops, missed the dependence when reading it quickly.</p>",
        "id": 409639296,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703277384
    },
    {
        "content": "<p>Yeah, I'm in a noob but I'm not <em>that much</em> of a noob. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 409639393,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703277467
    },
    {
        "content": "<p>Okay, I can't really make <code>subst</code> work yet but also I have to go to bed because I have to catch a train super early tomorrow, so I'll think more about it and be back later.</p>",
        "id": 409639491,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703277523
    },
    {
        "content": "<p>I have to go, but this is what I'd use:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"bp\">×</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">q.1</span> <span class=\"bp\">+</span> <span class=\"n\">q.2</span><span class=\"o\">))</span> <span class=\"bp\">//</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">q.2</span><span class=\"o\">}</span> <span class=\"bp\">|</span>\n      <span class=\"n\">p.1.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">p.1.2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"bp\">=</span>\n      <span class=\"n\">Finset.sigma</span> <span class=\"o\">(</span><span class=\"n\">Finset.range</span> <span class=\"n\">n</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">Finset.range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"o\">(</span><span class=\"n\">Finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">({</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">q.1</span> <span class=\"bp\">+</span> <span class=\"n\">q.2</span><span class=\"o\">))</span> <span class=\"bp\">//</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">q.2</span><span class=\"o\">})))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">⟩</span>\n    <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 409639619,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703277607
    },
    {
        "content": "<p>That establishes <code>Set.Finite</code> for a related set, and then your theorem then is about reassociating that dependent product.</p>",
        "id": 409639649,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703277643
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> would you know if there's at least an equivalence to reassociate this dependent product?</p>",
        "id": 409639967,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703277848
    },
    {
        "content": "<p>To get the dependent type outside of the subtype?</p>",
        "id": 409640000,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703277887
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Working.20with.20.60.60.60cast.60.60.60.20and.20.60.60.60HEq.60.60.60/near/409639619\">said</a>:</p>\n<blockquote>\n<p>I have to go, but this is what I'd use:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"bp\">×</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">q.1</span> <span class=\"bp\">+</span> <span class=\"n\">q.2</span><span class=\"o\">))</span> <span class=\"bp\">//</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">q.2</span><span class=\"o\">}</span> <span class=\"bp\">|</span>\n      <span class=\"n\">p.1.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">p.1.2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"bp\">=</span>\n      <span class=\"n\">Finset.sigma</span> <span class=\"o\">(</span><span class=\"n\">Finset.range</span> <span class=\"n\">n</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">Finset.range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"o\">(</span><span class=\"n\">Finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">({</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">q.1</span> <span class=\"bp\">+</span> <span class=\"n\">q.2</span><span class=\"o\">))</span> <span class=\"bp\">//</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">q.2</span><span class=\"o\">})))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">⟩</span>\n    <span class=\"n\">simp</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>(Yes, I'm back. Only for a few minutes <span aria-label=\"fingers crossed\" class=\"emoji emoji-1f91e\" role=\"img\" title=\"fingers crossed\">:fingers_crossed:</span>, I wanted to check something in my code.)<br>\nInteresting, thanks ! I've been wondering about reassociating the dependent product myself, it seemed that it would make my life easier.</p>\n<p>I wanted to check what I did in the original proof: I construct an equivalence with <code>(k : Finset.range n) × (l : Finset.range n) × {s : Finset (Fin (k + l)) | s.card = l}</code>, and then poof, Lean knows that <em>that</em> one is finite ! (I know its <code>PSigma.fintype</code> working its magic in the background, but still, magic.) So maybe another way to go would be to make the construction of the equivalence more efficient... Okay, I'm really going to bed now, I swear.</p>",
        "id": 409642730,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703279486
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"318709\">@Sophie Morel</span> I realized right when I had to go that there's a more direct way to do this. It's still the same idea, write down a Finset expression that calculates the correct thing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Set.Finite</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">//</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"bp\">|</span>\n    <span class=\"n\">p.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">p.2.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">convert_to</span> <span class=\"n\">Set.Finite</span> <span class=\"o\">((</span><span class=\"n\">Finset.range</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sigma</span> <span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"o\">(</span><span class=\"n\">Finset.range</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sigma</span> <span class=\"k\">fun</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"o\">(</span><span class=\"n\">Finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">({</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">//</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">})))</span><span class=\"bp\">.</span><span class=\"n\">toSet</span>\n  <span class=\"bp\">·</span> <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">⟩</span>\n    <span class=\"n\">simp</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Finset.finite_toSet</span>\n</code></pre></div>",
        "id": 409646218,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703281808
    },
    {
        "content": "<p>I used <code>convert_to</code> rather than write a separate lemma that gives an equality of the sets.</p>",
        "id": 409646256,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703281839
    },
    {
        "content": "<p>Perhaps it might be easier to work with an equivalent set such as <code>{(k,l,s) : ℕ × ℕ × (Finset ℕ) | s ⊆ Finset.range (k+l) ∧ s.card = l ∧ k ∈ Finset.range n ∧ l ∈ Finset.range n}</code> throughout, to avoid dependent types entirely?  Note that this (up to coercions) is a subset of <code>(Finset.range n) × (Finset.range n)  × Finset (Finset.range (2*n))</code> so is manifestly finite.</p>",
        "id": 409669371,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703295564
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/270676-lean4/topic/Working.20with.20.60.60.60cast.60.60.60.20and.20.60.60.60HEq.60.60.60/near/409669371\">said</a>:</p>\n<blockquote>\n<p>Perhaps it might be easier to work with an equivalent set such as <code>{(k,l,s) : ℕ × ℕ × (Finset ℕ) | s ⊆ Finset.range (k+l) ∧ s.card = l ∧ k ∈ Finset.range n ∧ l ∈ Finset.range n}</code> throughout, to avoid dependent types entirely?  Note that this (up to coercions) is a subset of <code>(Finset.range n) × (Finset.range n)  × Finset (Finset.range (2*n))</code> so is manifestly finite.</p>\n</blockquote>\n<p>The thing is that I can't choose what I am working with unless I do some rewriting of already existing mathlib code, or unless I duplicate some work. These are from the calculation of the power series of <code>f(x + y)</code> from that of <code>f(x)</code>, I am proving that the new power series converges without any completeness assumptions if the original power series was finite. If I'm trying to minimize the amount of pain for myself, not rewriting all the technical lemmas there seems like a good option !</p>",
        "id": 409691290,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703314509
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Working.20with.20.60.60.60cast.60.60.60.20and.20.60.60.60HEq.60.60.60/near/409646218\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> I realized right when I had to go that there's a more direct way to do this. It's still the same idea, write down a Finset expression that calculates the correct thing:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Set.Finite</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">//</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"bp\">|</span>\n    <span class=\"n\">p.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">p.2.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">convert_to</span> <span class=\"n\">Set.Finite</span> <span class=\"o\">((</span><span class=\"n\">Finset.range</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sigma</span> <span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"o\">(</span><span class=\"n\">Finset.range</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sigma</span> <span class=\"k\">fun</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"o\">(</span><span class=\"n\">Finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">({</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">//</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">})))</span><span class=\"bp\">.</span><span class=\"n\">toSet</span>\n  <span class=\"bp\">·</span> <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">⟩</span>\n    <span class=\"n\">simp</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Finset.finite_toSet</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Great, thank you ! </p>\n<p>Is there a list of super-cool secret Lean4 tactics somewhere, with their documentation ? It seems that every time I ask a question, somebody answers \"oh, you don't know the <code>frobnicate</code> tactic, that's exactly the thing for this situation\".  Meanwhile I was struggling the other day to find the documentation of <code>rewrite</code>. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span><br>\n(ETA: I did figure it out, I just need to hover over the tactic name in vscode and a handy documentation pop ups. And here I was trying to find it in the mathlib documentation...)</p>",
        "id": 409691556,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703314772
    },
    {
        "content": "<p>Yes, mathlib documentation for tactics has disappeared in the port. This is something we're aware of but nobody fixed it yet.</p>",
        "id": 409692071,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703315183
    },
    {
        "content": "<p>Well, I've been examining Kyle's proof and it's pretty cool. I definitely have to learn more about <code>convert</code> and <code>convert_to</code>, because it seems like something I could have used in the past.  (I've finally learned how to use <code>calc</code> instead of piling 13 levels of <code>le_trans</code> and <code>lt_of_lt_and_le</code> etc, and I'm cursing myself for not taking the time to learn earlier.)</p>",
        "id": 409692204,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703315337
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/270676-lean4/topic/Working.20with.20.60.60.60cast.60.60.60.20and.20.60.60.60HEq.60.60.60/near/409692071\">said</a>:</p>\n<blockquote>\n<p>Yes, mathlib documentation for tactics has disappeared in the port. This is something we're aware of but nobody fixed it yet.</p>\n</blockquote>\n<p>Ah, that explains why I have a much harder time finding it now, it's not there ! <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> It's reassuring in a way, because I felt like I had become very stupid all of a sudden.</p>",
        "id": 409692311,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703315421
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> <a href=\"#narrow/stream/270676-lean4/topic/Working.20with.20.60.60.60cast.60.60.60.20and.20.60.60.60HEq.60.60.60/near/409691556\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Working.20with.20.60.60.60cast.60.60.60.20and.20.60.60.60HEq.60.60.60/near/409646218\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> I realized right when I had to go that there's a more direct way to do this. It's still the same idea, write down a Finset expression that calculates the correct thing:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Set.Finite</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">//</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"bp\">|</span>\n    <span class=\"n\">p.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">p.2.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">convert_to</span> <span class=\"n\">Set.Finite</span> <span class=\"o\">((</span><span class=\"n\">Finset.range</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sigma</span> <span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"o\">(</span><span class=\"n\">Finset.range</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sigma</span> <span class=\"k\">fun</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"o\">(</span><span class=\"n\">Finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">({</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">//</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">})))</span><span class=\"bp\">.</span><span class=\"n\">toSet</span>\n  <span class=\"bp\">·</span> <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">⟩</span>\n    <span class=\"n\">simp</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Finset.finite_toSet</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Great, thank you ! </p>\n<p>Is there a list of super-cool secret Lean4 tactics somewhere, with their documentation ? It seems that every time I ask a question, somebody answers \"oh, you don't know the <code>frobnicate</code> tactic, that's exactly the thing for this situation\".  Meanwhile I was struggling the other day to find the documentation of <code>rewrite</code>. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span><br>\n(ETA: I did figure it out, I just need to hover over the tactic name in vscode and a handy documentation pop ups. And here I was trying to find it in the mathlib documentation...)</p>\n</blockquote>\n<p>You can have a look <a href=\"https://github.com/haruhisa-enomoto/mathlib4-all-tactics/blob/main/all-tactics.md\">here</a>. It is just a copy paste of the official documentation, but at least it is a list of tactics.</p>",
        "id": 409698876,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1703321290
    },
    {
        "content": "<p>Thank you!<br>\nHahaha, I've been playing with <code>convert</code> and this thing is freaking dark magic!</p>",
        "id": 409700787,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703322625
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"318709\">@Sophie Morel</span> One of the things you can do with it is use to handle \"wrong\" <code>Fintype</code> and <code>DecidableEq</code> instances. If <code>exact</code> fails just because of differences in such instances, <code>convert</code> should succeed. (If it doesn't, ping me!)</p>\n<p>Other related tactics are:</p>\n<ul>\n<li><code>congr!</code> if the goal is an iff, eq, heq, or any other reflexive relation, and you want to reduce to the case of showing that corresponding sub-expressions are equal. (<code>convert</code>/<code>convert_to</code> are implemented using it)</li>\n<li><code>congrm</code> is similar, but you can provide a pattern with placeholders, where the placeholders are in positions where you want a new sub-goal</li>\n<li><code>gcongr</code> is for \"generalized congruence,\" which can handle relations like inequalities, vs equalities/iffs in the previous tactics. It is more opinionated about doing what makes sense in context.</li>\n<li><code>apply_fun</code> can handle applying a function at an equality hypothesis or, if it's injective, at the goal. It's not super related, but it's also got something to do with applying congruence lemmas so I'll include it.</li>\n</ul>",
        "id": 409729823,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703348226
    },
    {
        "content": "<p>Thank you for the list of useful tactics ! Even for the ones I already knew, you have just taught me about new ways to use them.</p>",
        "id": 409904941,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703505227
    }
]