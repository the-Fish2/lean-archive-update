[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"s2\">\"012\"</span><span class=\"bp\">.</span><span class=\"n\">splitOn</span> <span class=\"s2\">\"12\"</span> <span class=\"c1\">-- output: [\"0\", \"\"]</span>\n<span class=\"k\">#eval</span> <span class=\"s2\">\"007\"</span><span class=\"bp\">.</span><span class=\"n\">splitOn</span> <span class=\"s2\">\"07\"</span> <span class=\"c1\">-- [\"007\"]</span>\n</code></pre></div>\n<p>The value of the second expression above should be <code>[\"0\", \"\"]</code>. For more context, see <a href=\"https://github.com/leanprover/lean4/issues/3829\">https://github.com/leanprover/lean4/issues/3829</a>.</p>\n<p>It took more than 160 hours for me to find this counterexample. <span aria-label=\"melting face\" class=\"emoji emoji-1fae0\" role=\"img\" title=\"melting face\">:melting_face:</span></p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Issue</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<h3>Context</h3>\n<p>I was trying to prove <a href=\"https://github.com/leanprover/std4/pull/719/files#diff-b2fb96bb7d0273dbe3a81a67bb9b432c089139ac50e3e0b3578f40cac0de2a51R662-R672\"><code>String.splitOn_of_valid</code></a> in <code>Std.Data.List.Lemmas</code>, but I realized that the current definition of <code>String.splitOn</code> is flawed. See <a href=\"https://github.com/leanprover/std4/pull/719\">https://github.com/leanprover/std4/pull/719</a>.</p>\n<p>I think <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span>'s definition of <a href=\"https://github.com/leanprover/std4/pull/719/files#diff-da0f75af783a1dd2e2f8d5bd692a63a1d3b96cec323e322a21db342852d09c6eR97-R112\"><code>List.splitOnList</code></a> in <a href=\"https://github.com/leanprover/std4/pull/719/files#diff-da0f75af783a1dd2e2f8d5bd692a63a1d3b96cec323e322a21db342852d09c6e\"><code>Std.Data.List.SplitOnList</code></a> is correct, as can be seen below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.List.SplitOnList</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"s2\">\"012\"</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">splitOnList</span> <span class=\"s2\">\"12\"</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">String.mk</span> <span class=\"c1\">-- output: [\"0\", \"\"]</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"s2\">\"007\"</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">splitOnList</span> <span class=\"s2\">\"07\"</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">String.mk</span> <span class=\"c1\">-- [\"0\", \"\"]</span>\n</code></pre></div>\n<h3>Version</h3>\n<p>4.7.0-rc2</p>\n</div></div>",
        "id": 430930535,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1712127148
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, do you think we should replace the current definition of <code>String.splitOn</code> with the one below?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.List.SplitOnList</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">String.splitOn</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"n\">sep</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">List.splitOnList</span> <span class=\"n\">l.1</span> <span class=\"n\">sep.1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">String.mk</span>\n</code></pre></div>",
        "id": 430932452,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1712127999
    },
    {
        "content": "<p>Maybe for modeling purposes, but that's a wasteful implementation</p>",
        "id": 430932668,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712128094
    },
    {
        "content": "<p>actually we can't do that either, because String has so many non-WF cases that the equality theorem is false in full generality (maybe not for String because the inputs are simple, but definitely for Substring)</p>",
        "id": 430933018,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712128263
    },
    {
        "content": "<p>so it would need to be a lemma</p>",
        "id": 430933068,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712128289
    },
    {
        "content": "<p>Then I guess we should come up with a new definition.</p>",
        "id": 430933364,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1712128418
    },
    {
        "content": "<p>I'm also worried there may be other flawed definitions in Lean core.</p>",
        "id": 430933789,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1712128605
    },
    {
        "content": "<p>no need to worry about it, they will come out in the wash when we prove characterizing theorems</p>",
        "id": 430933917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712128659
    },
    {
        "content": "<p>Right, but it seems I'm the only one willing to prove the eleven theorems on the to-do list in <code>Std.Data.String.Lemmas</code>. It'll be a painful journey. <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 430934373,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1712128853
    },
    {
        "content": "<p>Still, thanks for guiding me all along!</p>",
        "id": 430934647,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1712128966
    },
    {
        "content": "<p>I've been on another lean project for a while, but I'm planning to return to Std development soon and fill out some of the lemmas. I don't have an immediate need for those extra String lemmas but I can try to write the fixed version of the String and Substring functions for splitOn</p>",
        "id": 430935007,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712129132
    },
    {
        "content": "<p>This bug was discussed before, I think (<a href=\"#narrow/stream/270676-lean4/topic/should.20we.20redefine.20.60String.2EsplitOnAux.60.3F\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/should.20we.20redefine.20.60String.2EsplitOnAux.60.3F</a>). I'd argue this is not a bug, since it's likely that all actual uses of splitOn use single characters as the second argument, and fixing it to work for all arguments would incur a performance penalty. I think adding extra hypotheses on the input makes more sense in this case.</p>",
        "id": 430989298,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712146621
    },
    {
        "content": "<p>I think this is definitely a bug, in that the function does not do what it says on an input it apparently allows. Possibly it could get an additional precondition if we don't expect it to work on this input, but if the split string was only supposed to be a single character we already have a type for that</p>",
        "id": 430989687,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712146730
    },
    {
        "content": "<p>the fact that fixing the bug could have a performance overhead doesn't make it any less of a bug</p>",
        "id": 430989804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712146774
    },
    {
        "content": "<p>but we also won't know that until we have an implementation for benchmarking</p>",
        "id": 430989891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712146798
    },
    {
        "content": "<p>I don't think these functions have gone through enough use and revisions to necessarily make it always reasonable to assume that any unusual behavior is there for a good reason</p>",
        "id": 430990294,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712146924
    },
    {
        "content": "<p>I guess implementing naive string search would be just as fast for single character delimiters</p>",
        "id": 430990726,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712147062
    },
    {
        "content": "<p>But I can't imagine Boyer-Moore/Boyer-Moore-Horspool/KMP not being overkill if the main use case is single-character delimiters</p>",
        "id": 430990861,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712147119
    },
    {
        "content": "<p>I'm not sure where you got the idea that we'd be using that algorithm</p>",
        "id": 430991150,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712147218
    },
    {
        "content": "<p>a plain loop seems appropriate here, since we're optimizing for the small pattern case</p>",
        "id": 430991232,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712147243
    },
    {
        "content": "<p>Plus, this has to be implemented in core and I'd rather not move the KMP code upstream</p>",
        "id": 430991318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712147272
    },
    {
        "content": "<p>I think I was primed by the fact that the upstream code looks like incomplete KMP</p>",
        "id": 430991475,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712147307
    },
    {
        "content": "<p>can you elaborate on what's incomplete about it?</p>",
        "id": 430991562,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712147338
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"325367\">Mauricio Collares</span> <a href=\"#narrow/stream/270676-lean4/topic/current.20definition.20of.20.60String.2EsplitOn.60.20is.20incorrect/near/430989298\">said</a>:</p>\n<blockquote>\n<p>This bug was discussed before, I think (<a href=\"#narrow/stream/270676-lean4/topic/should.20we.20redefine.20.60String.2EsplitOnAux.60.3F\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/should.20we.20redefine.20.60String.2EsplitOnAux.60.3F</a>).</p>\n</blockquote>\n<p>That was a different <del>bug</del> from this one.</p>",
        "id": 430991563,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1712147338
    },
    {
        "content": "<p>How is this bug different from <code>\"ababcab\".splitOn \"abc\"</code> failing? I don't get it</p>",
        "id": 430991685,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712147391
    },
    {
        "content": "<p>that one was fixed, no? There is at least a merged PR that came out of that discussion</p>",
        "id": 430991954,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712147477
    },
    {
        "content": "<p>There were two bugs discussed in the other thread, I'm talking about the second one.</p>",
        "id": 430992029,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712147501
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"325367\">Mauricio Collares</span> <a href=\"#narrow/stream/270676-lean4/topic/should.20we.20redefine.20.60String.2EsplitOnAux.60.3F/near/365905633\">said</a>:</p>\n<blockquote>\n<p>That being said, the original function looks a bit buggy. Does <code>\"ababcab\".splitOn \"abc\"</code> work there? It does look like it is missing some partial match handling (KMP-style or otherwise).</p>\n</blockquote>\n<p>Oh, you meant this one.</p>",
        "id": 430992190,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1712147548
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417769\">Bulhwi Cha</span> <a href=\"#narrow/stream/270676-lean4/topic/current.20definition.20of.20.60String.2EsplitOn.60.20is.20incorrect/near/430991563\">said</a>:</p>\n<blockquote>\n<p>That was a different <del>bug</del> from this one.</p>\n</blockquote>\n<p>What I fixed last year was one of the many weird behaviors of <code>String.splitOnAux</code>. If I remember correctly, this had nothing to do with <code>String.splitOn</code>. So you can say this wasn't a bug.</p>",
        "id": 430992919,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1712147778
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/current.20definition.20of.20.60String.2EsplitOn.60.20is.20incorrect/near/430991562\">said</a>:</p>\n<blockquote>\n<p>can you elaborate on what's incomplete about it?</p>\n</blockquote>\n<p>KMP would increase <code>b</code> (and decrement <code>j</code> appropriately) instead of increasing <code>i</code> at this line, according to a precomputed partial matching function: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Init/Data/String/Basic.lean#L262\">https://github.com/leanprover/lean4/blob/master/src/Init/Data/String/Basic.lean#L262</a></p>",
        "id": 430993026,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712147814
    },
    {
        "content": "<p>Oh I thought you meant that comment in regards to Std's actual KMP implementation</p>",
        "id": 430993308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712147883
    },
    {
        "content": "<p>Oh, sorry, I didn't know Std had a KMP implementation! I now understand what you mean</p>",
        "id": 430993399,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712147912
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"325367\">Mauricio Collares</span> <a href=\"#narrow/stream/270676-lean4/topic/current.20definition.20of.20.60String.2EsplitOn.60.20is.20incorrect/near/430989298\">said</a>:</p>\n<blockquote>\n<p>I'd argue this is not a bug, since it's likely that all actual uses of splitOn use single characters as the second argument, and fixing it to work for all arguments would incur a performance penalty. I think adding extra hypotheses on the input makes more sense in this case.</p>\n</blockquote>\n<p>Give me a week to take a good rest. I have a hunch that we only need to <em>slightly</em> modify the current definition of <code>String.splitOnAux</code>. By the way, I won't use KMP to redefine the function because I don't know what it is.</p>",
        "id": 430993490,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1712147957
    },
    {
        "content": "<p>Yes, you can add an extra parameter to splitOnAux that records where the current match starts, and then restart at the next position in case of failure (<code>b</code> is not where the current match starts, but rather where the current \"block\" starts)</p>",
        "id": 430994078,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712148127
    },
    {
        "content": "<p>I don't think I'll need more parameters. But we'll see.</p>",
        "id": 430994145,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1712148152
    },
    {
        "content": "<p>The type signature of <code>splitOnAux</code> is subject to change, it's not meant for direct use and should just do what it needs to do to get a correct result for <code>splitOn</code></p>",
        "id": 430994281,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712148205
    },
    {
        "content": "<p>which is why I find it a bit odd to be studying them separately like this</p>\n<p><span class=\"user-mention silent\" data-user-id=\"417769\">Bulhwi Cha</span> <a href=\"#narrow/stream/270676-lean4/topic/current.20definition.20of.20.60String.2EsplitOn.60.20is.20incorrect/near/430992919\">said</a>:</p>\n<blockquote>\n<p>What I fixed last year was one of the many weird behaviors of <code>String.splitOnAux</code>. If I remember correctly, this had nothing to do with <code>String.splitOn</code>. So you can say this wasn't a bug.</p>\n</blockquote>",
        "id": 430994521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712148267
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417769\">Bulhwi Cha</span> <a href=\"#narrow/stream/270676-lean4/topic/current.20definition.20of.20.60String.2EsplitOn.60.20is.20incorrect/near/430994145\">said</a>:</p>\n<blockquote>\n<p>I don't think I'll need more parameters. But we'll see.</p>\n</blockquote>\n<p>Fair. I guess you can do <code>s.prev i</code> and <code>sep.prev j</code> a bunch of times until you hit the beginning of the separator string, then advance <code>i</code> once (assuming there is a <code>prev</code> function). But that's more overhead. It would be easier to implement if you could do index operations in O(1) time, but that would introduce another class of bugs for strings which contain multi-byte characters.</p>",
        "id": 430994531,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712148270
    },
    {
        "content": "<p>you can do indexing in O(1)?</p>",
        "id": 430994660,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712148305
    },
    {
        "content": "<p>you should just be counting byte offsets not characters</p>",
        "id": 430994742,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712148325
    },
    {
        "content": "<p>Oh, is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Pos#doc\">docs#Pos</a> a byte offset?</p>",
        "id": 430994920,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712148373
    },
    {
        "content": "<p>Got it, so it should be enough to go from <code>b i j</code> to something like <code>b (s.next (i - j)) 0</code> in case of failure</p>",
        "id": 430995114,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712148440
    },
    {
        "content": "<p>no you don't want to use <code>nextn</code>, that's counting characters</p>",
        "id": 430995255,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712148478
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"325367\">Mauricio Collares</span> <a href=\"#narrow/stream/270676-lean4/topic/current.20definition.20of.20.60String.2EsplitOn.60.20is.20incorrect/near/430991685\">said</a>:</p>\n<blockquote>\n<p>How is this bug different from <code>\"ababcab\".splitOn \"abc\"</code> failing? I don't get it</p>\n</blockquote>\n<p>(Now I'm a bit sad because you already knew about the bug I found a few hours ago. <span aria-label=\"cry\" class=\"emoji emoji-1f622\" role=\"img\" title=\"cry\">:cry:</span>)</p>",
        "id": 430995262,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1712148480
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/current.20definition.20of.20.60String.2EsplitOn.60.20is.20incorrect/near/430995255\">said</a>:</p>\n<blockquote>\n<p>no you don't want to use <code>nextn</code>, that's counting characters</p>\n</blockquote>\n<p>That's what we want to do in this case</p>",
        "id": 430995366,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712148500
    },
    {
        "content": "<p>unclear why, but I haven't dug into this algorithm in depth</p>",
        "id": 430995456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712148525
    },
    {
        "content": "<p>there shouldn't be a single character count involved here</p>",
        "id": 430995549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712148548
    },
    {
        "content": "<p><code>splitOnAux s b i j</code> means \"try to find the j-th character of the pattern starting at position i of the text, where the block starts at b\"</p>",
        "id": 430995575,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712148555
    },
    {
        "content": "<p>where both i and j are byte offsets</p>",
        "id": 430995637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712148576
    },
    {
        "content": "<p>Yes, but if you discovered that something doesn't match, you need to start again at the next character, not next byte</p>",
        "id": 430995698,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712148599
    },
    {
        "content": "<p>so the difference between them is also a byte offset</p>",
        "id": 430995703,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712148600
    },
    {
        "content": "<p>you use <code>next</code> and <code>prev</code> to get the next byte offset, but there is no local variable saying this thing is N characters past that thing</p>",
        "id": 430996034,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712148685
    },
    {
        "content": "<p>every variable is in terms of byte measurements between parts of the string</p>",
        "id": 430996089,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712148706
    },
    {
        "content": "<p><code>i</code> means \"the currently matching text character is <code>i</code> bytes past the start\". So, for example, suppose you matched X characters (Y bytes) so far successfully, and then you got a failure. You want to look go back to the start of the string (that is, go back X characters or Y bytes starting from byte offset <code>i</code>) to get where the beginning of the match was, then advance that by one character and try to match the first character of the pattern again.</p>",
        "id": 430996578,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712148851
    },
    {
        "content": "<p>This looks a lot more complicated than it is because the start of the current match is not currently a parameter (b is something else)</p>",
        "id": 430996705,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712148886
    },
    {
        "content": "<p>right, so that's <code>i - Y</code></p>",
        "id": 430996736,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712148897
    },
    {
        "content": "<p>no <code>nextn</code> because we aren't storing X and it wouldn't be useful if we did</p>",
        "id": 430996822,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712148922
    },
    {
        "content": "<p>But that's the beginning of the current match, which we know failed. We want to start again at the next possible beginning position.</p>",
        "id": 430997007,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712148971
    },
    {
        "content": "<p><code>(i -Y).next</code></p>",
        "id": 430997058,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712148985
    },
    {
        "content": "<p>Oh, are you saying <code>Y</code> and <code>j</code> are different things because <code>j</code> is not an offset wrt the beginning of the pattern?</p>",
        "id": 430997185,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712149030
    },
    {
        "content": "<p><code>j</code> in the code is a <code>Pos</code> referring to the separator/pattern</p>",
        "id": 430997236,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712149048
    },
    {
        "content": "<p>(We're trying to match the character at offset <code>j</code> from <code>sep</code> to the character at offset <code>i</code> from <code>s</code>)</p>",
        "id": 430997449,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712149108
    },
    {
        "content": "<p>it measures two things, the byte offset in the pattern and also in the search string (relative to <code>i</code>), we know that they agree so far hence it's a valid offset in both</p>",
        "id": 430997460,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712149112
    },
    {
        "content": "<p>Yes, I agree, but you're claiming <code>s.next (i-j)</code> was wrong and I don't understand why (thanks for being patient by the way!)</p>",
        "id": 430997627,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712149163
    },
    {
        "content": "<p>I was claiming <code>s.nextn (i - j)</code> was wrong for \"typing reasons\"</p>",
        "id": 430997699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712149189
    },
    {
        "content": "<p>Oh, but I didn't mean <code>nextn</code>, I really did mean <code>next</code> (I didn't realize <code>nextn</code> existed, I thought it was just a typo)</p>",
        "id": 430998012,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712149266
    },
    {
        "content": "<p><code>nextn</code> is how you move N <em>characters</em> forward</p>",
        "id": 430998066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712149287
    },
    {
        "content": "<p>so if you had <code>X</code> around you would need it</p>",
        "id": 430998111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712149299
    },
    {
        "content": "<p>Yes, but I think <code>s.next x</code> finds the character immediately after the one at offset <code>x</code> (at least that's how the code uses it iiuc)</p>",
        "id": 430998263,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712149336
    },
    {
        "content": "<p>the offset of that character, that is</p>",
        "id": 430998392,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712149363
    },
    {
        "content": "<p>I don't understand how <code>nextn</code> entered the conversation in the first place. But regardless: Thanks for the explanation, it was very useful! I didn't know <code>Pos</code> was a byte offset.</p>",
        "id": 431000437,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712149963
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"325367\">Mauricio Collares</span> <a href=\"#narrow/stream/270676-lean4/topic/current.20definition.20of.20.60String.2EsplitOn.60.20is.20incorrect/near/430995114\">said</a>:</p>\n<blockquote>\n<p>Got it, so it should be enough to go from <code>b i j</code> to something like <code>b (s.next (i - j)) 0</code> in case of failure</p>\n</blockquote>\n<p>I misunderstood this as being about <code>nextn</code> because I think of <code>next</code> as being a unary function</p>",
        "id": 431000922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712150113
    },
    {
        "content": "<p>Ah, got it! I was just cargo-culting <code>splitOnAux</code>'s coding convention. I now know about <code>nextn</code>, which is nice :)</p>",
        "id": 431002168,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712150498
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417769\">Bulhwi Cha</span> <a href=\"#narrow/stream/270676-lean4/topic/current.20definition.20of.20.60String.2EsplitOn.60.20is.20incorrect/near/430995262\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"325367\">Mauricio Collares</span> <a href=\"#narrow/stream/270676-lean4/topic/current.20definition.20of.20.60String.2EsplitOn.60.20is.20incorrect/near/430991685\">said</a>:</p>\n<blockquote>\n<p>How is this bug different from <code>\"ababcab\".splitOn \"abc\"</code> failing? I don't get it</p>\n</blockquote>\n<p>(Now I'm a bit sad because you already knew about the bug I found a few hours ago. <span aria-label=\"cry\" class=\"emoji emoji-1f622\" role=\"img\" title=\"cry\">:cry:</span>)</p>\n</blockquote>\n<p>That's my fault, I didn't emphasize it because I thought fixing it would be a performance regression in some cases (as Mario pointed out, I saw the need for KMP where there was none). But replacing <code>splitOnAux s sep b (s.next i) 0 r</code> by <code>splitOnAux s sep b (s.next (i - j)) 0 r</code> is clearly \"free\" for single-character separators since <code>j</code> is always 0, so I'm really glad you investigated this issue.</p>",
        "id": 431003027,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1712150778
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/current.20definition.20of.20.60String.2EsplitOn.60.20is.20incorrect/near/430994521\">said</a>:</p>\n<blockquote>\n<p>which is why I find it a bit odd to be studying them separately like this</p>\n<p><span class=\"user-mention silent\" data-user-id=\"417769\">Bulhwi Cha</span> <a href=\"#narrow/stream/270676-lean4/topic/current.20definition.20of.20.60String.2EsplitOn.60.20is.20incorrect/near/430992919\">said</a>:</p>\n<blockquote>\n<p>What I fixed last year was one of the many weird behaviors of <code>String.splitOnAux</code>. If I remember correctly, this had nothing to do with <code>String.splitOn</code>. So you can say this wasn't a bug.<br>\n</p>\n</blockquote>\n</blockquote>\n<p>The weirder the auxiliary function, the harder it is to prove theorems about the main function.</p>",
        "id": 431116676,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1712157219
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>List.splitOnList</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.String.Lemmas</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.OpenPrivate</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">List</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">head_cons_tail</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">l</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">head</span> <span class=\"n\">α</span> <span class=\"n\">l</span> <span class=\"n\">h</span> <span class=\"o\">::</span> <span class=\"n\">l.tail</span> <span class=\"bp\">=</span> <span class=\"n\">l</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">::</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">IsPrefix.iff_isPrefixOf</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LawfulBEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">l₁</span> <span class=\"bp\">&lt;+</span><span class=\"o\">:</span> <span class=\"n\">l₂</span> <span class=\"bp\">↔</span> <span class=\"n\">isPrefixOf</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">match</span> <span class=\"n\">l₁</span><span class=\"o\">,</span> <span class=\"n\">l₂</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span>   <span class=\"n\">_</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nil_prefix</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">::</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">::</span><span class=\"n\">bs</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">⟩</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">cons_append</span><span class=\"o\">,</span> <span class=\"n\">cons.injEq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">ht</span>\n      <span class=\"k\">have</span> <span class=\"n\">hpf</span> <span class=\"o\">:</span> <span class=\"n\">as</span> <span class=\"bp\">&lt;+</span><span class=\"o\">:</span> <span class=\"n\">bs</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">ht.2</span><span class=\"o\">⟩</span>\n      <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">isPrefixOf</span><span class=\"o\">,</span> <span class=\"n\">ht.1</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">IsPrefix.iff_isPrefixOf.mp</span> <span class=\"n\">hpf</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">h</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">isPrefixOf</span><span class=\"o\">,</span> <span class=\"n\">Bool.and_eq_true</span><span class=\"o\">,</span> <span class=\"n\">beq_iff_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n      <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">IsPrefix.iff_isPrefixOf.mpr</span> <span class=\"n\">h.2</span>\n      <span class=\"n\">exists</span> <span class=\"n\">t</span>\n      <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">h.1</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">List</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">String</span>\n<span class=\"kn\">open</span> <span class=\"kn\">private</span> <span class=\"n\">add_csize_pos</span> <span class=\"k\">from</span> <span class=\"n\">Std.Data.String.Lemmas</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">utf8Len_pos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">utf8Len</span> <span class=\"n\">l</span> <span class=\"bp\">↔</span> <span class=\"n\">l</span> <span class=\"bp\">≠</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">l</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_csize_pos</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">String</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">String</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">List.splitOnList'</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"n\">sep</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Char</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">Char</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span> <span class=\"bp\">∨</span> <span class=\"n\">sep</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span> <span class=\"k\">then</span>\n    <span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span>\n  <span class=\"k\">else</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">hls</span><span class=\"o\">,</span> <span class=\"n\">hsp</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">not_or.mp</span> <span class=\"n\">h</span>\n    <span class=\"k\">if</span> <span class=\"n\">hpf</span> <span class=\"o\">:</span> <span class=\"n\">sep.isPrefixOf</span> <span class=\"n\">l</span> <span class=\"k\">then</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">utf8Len</span> <span class=\"o\">(</span><span class=\"n\">l.drop</span> <span class=\"n\">sep.length</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">utf8Len</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">IsPrefix.iff_isPrefixOf.mpr</span> <span class=\"n\">hpf</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">drop_left</span><span class=\"o\">,</span> <span class=\"n\">utf8Len_append</span><span class=\"o\">,</span> <span class=\"n\">gt_iff_lt</span><span class=\"o\">]</span>\n        <span class=\"n\">exact</span> <span class=\"n\">Nat.lt_add_of_pos_left</span> <span class=\"o\">(</span><span class=\"n\">utf8Len_pos.mpr</span> <span class=\"n\">hsp</span><span class=\"o\">)</span>\n      <span class=\"o\">[]</span> <span class=\"o\">::</span> <span class=\"n\">splitOnList'</span> <span class=\"o\">(</span><span class=\"n\">l.drop</span> <span class=\"n\">sep.length</span><span class=\"o\">)</span> <span class=\"n\">sep</span>\n    <span class=\"k\">else</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">utf8Len</span> <span class=\"n\">l.tail</span> <span class=\"bp\">&lt;</span> <span class=\"n\">utf8Len</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rhs</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">head_cons_tail</span> <span class=\"n\">l</span> <span class=\"n\">hls</span><span class=\"o\">,</span> <span class=\"n\">utf8Len_cons</span><span class=\"o\">]</span>\n        <span class=\"n\">exact</span> <span class=\"n\">Nat.lt_add_of_pos_right</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">csize_pos</span> <span class=\"o\">(</span><span class=\"n\">l.head</span> <span class=\"n\">hls</span><span class=\"o\">)</span>\n      <span class=\"n\">modifyHead</span> <span class=\"o\">(</span><span class=\"n\">l.head</span> <span class=\"n\">hls</span> <span class=\"o\">::</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">splitOnList'</span> <span class=\"n\">l.tail</span> <span class=\"n\">sep</span><span class=\"o\">)</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">utf8Len</span> <span class=\"n\">l</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">String.splitOn'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">sep</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">List.splitOnList'</span> <span class=\"n\">s.1</span> <span class=\"n\">sep.1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">mk</span>\n\n<span class=\"k\">#eval</span> <span class=\"s2\">\"012\"</span><span class=\"bp\">.</span><span class=\"n\">splitOn'</span> <span class=\"s2\">\"12\"</span> <span class=\"c1\">-- output: [\"0\", \"\"]</span>\n<span class=\"k\">#eval</span> <span class=\"s2\">\"007\"</span><span class=\"bp\">.</span><span class=\"n\">splitOn'</span> <span class=\"s2\">\"07\"</span> <span class=\"c1\">-- [\"0\", \"\"]</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">Lean.versionString</span> <span class=\"c1\">-- \"4.7.0-rc2\"</span>\n</code></pre></div>\n</div></div>\n<p>I think I found an easier way to define <code>List.splitOnList</code>. See the above code.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/current.20definition.20of.20.60String.2EsplitOn.60.20is.20incorrect/near/430932668\">said</a>:</p>\n<blockquote>\n<p>Maybe for modeling purposes, but that's a wasteful implementation</p>\n</blockquote>\n<blockquote>\n<p>actually we can't do that either, because String has so many non-WF cases that the equality theorem is false in full generality (maybe not for String because the inputs are simple, but definitely for Substring)</p>\n</blockquote>\n<p>Since we can't define <code>String.splitOn</code> as <code>(List.splitOnList s.1 sep.1).map mk</code>, I'll figure out a new definition of it.</p>",
        "id": 431119871,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1712158125
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417769\">Bulhwi Cha</span> has marked this topic as resolved.</p>",
        "id": 431120090,
        "sender_full_name": "Notification Bot",
        "timestamp": 1712158190
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417769\">Bulhwi Cha</span> has marked this topic as unresolved.</p>",
        "id": 431120117,
        "sender_full_name": "Notification Bot",
        "timestamp": 1712158201
    },
    {
        "content": "<p>If we have a proof that <code>String.IsPrefix sep s</code> is equivalent to <code>String.isPrefixOf sep s</code>, we can use it to define <code>String.splitOn</code> in a way similar to my definition of <code>List.splitOnList</code> above. We probably don't need to deal with byte offsets because <code>String.isPrefixOf</code> will do it for us.</p>\n<p>I really should rest now. <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span></p>",
        "id": 431125798,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1712159842
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/3832\">lean4#3832</a></p>",
        "id": 431229730,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712210097
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"325367\">Mauricio Collares</span> <a href=\"#narrow/stream/270676-lean4/topic/current.20definition.20of.20.60String.2EsplitOn.60.20is.20incorrect/near/431003027\">said</a>:</p>\n<blockquote>\n<p>But replacing <code>splitOnAux s sep b (s.next i) 0 r</code> by <code>splitOnAux s sep b (s.next (i - j)) 0 r</code> is clearly \"free\" for single-character separators since <code>j</code> is always 0, so I'm really glad you investigated this issue.</p>\n</blockquote>\n<p>Now I understand why we need this change. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 431232183,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1712211395
    },
    {
        "content": "<p>Allow me to prove <code>String.splitOnAux_of_valid</code> and <code>String.splitOn_of_valid</code>. I can do this.</p>",
        "id": 431232892,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1712211816
    },
    {
        "content": "<p>Another issue with <code>String.splitOn</code> is that it causes crashes (in compiled code as well) when it is fed a very large <code>String</code> (GB+), because of the limitations of the <code>List</code> type.  For myself, I had to write a <code>String.splitArrayOn</code> to do my work.</p>\n<p>Similar situations may occur in other places where things get turned to <code>List</code>; since Core functions are supposed to be the \"common standard\", is there any plan to either fix <code>List</code> crashes or make <code>Array</code> the default container for these actions?</p>",
        "id": 431312283,
        "sender_full_name": "Number Eighteen",
        "timestamp": 1712236848
    },
    {
        "content": "<p>As long as you handle the result well, the consequence of using <code>List</code> should not be that bad. <code>List</code> should still work with a billion elements in the list, but it has more overhead than array in that case. Are you sure the issue was actually with <code>splitOn</code> and not with subsequent calculation (like printing it to the screen)?</p>",
        "id": 431421015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712274549
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/current.20definition.20of.20.60String.2EsplitOn.60.20is.20incorrect/near/431421015\">said</a>:</p>\n<blockquote>\n<p>As long as you handle the result well, the consequence of using <code>List</code> should not be that bad. <code>List</code> should still work with a billion elements in the list, but it has more overhead than array in that case. Are you sure the issue was actually with <code>splitOn</code> and not with subsequent calculation (like printing it to the screen)?</p>\n</blockquote>\n<p>No, <code>splitOn</code> as a function was fine, it was subsequent handling of the <code>List</code> structure that caused the crash and made me write <code>splitArray</code>; but that is my point: since <code>List</code> is causing crashes where <code>Array</code> does not, either <code>List</code> needs to be reworked or <code>Array</code> needs to become the standard container for Core collections.  Core, or Std or however you call it, should to be as correct as possible since it is the reference library and the \"common dialect\" of Lean code (my opinion, at least this is how it works in all other languages I know).</p>",
        "id": 431509101,
        "sender_full_name": "Number Eighteen",
        "timestamp": 1712318495
    },
    {
        "content": "<p>you can convert the List to an Array using <code>toArray</code> and handle it as such if that helps</p>",
        "id": 431509265,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712318548
    },
    {
        "content": "<p>the issues that can occur with large lists can also occur for large arrays, depending on how the function is written</p>",
        "id": 431509376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712318596
    },
    {
        "content": "<p>Choosing data structures for standard types is not an easy task, because workloads can vary significantly and functions have multiple constraints on them: being usable in proofs, having good kernel performance, good interpreter performance and good compiled performance</p>",
        "id": 431509714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712318725
    },
    {
        "content": "<p>not everyone is making gigabyte large lists with <code>splitOn</code></p>",
        "id": 431509769,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712318745
    },
    {
        "content": "<p>it may be the case that you have an unusual workload and the best option is to write a bespoke version of the function</p>",
        "id": 431509859,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712318767
    },
    {
        "content": "<p>Having an array version of splitOn seems like a reasonable ask, although I would want to first review the existing uses of splitOn to see whether lists or arrays are better suited to the existing use cases in lean core</p>",
        "id": 431510050,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712318849
    },
    {
        "content": "<blockquote>\n<p>since <code>List</code> is causing crashes where <code>Array</code> does not</p>\n</blockquote>\n<p>just to be clear, it's not \"<code>List</code> causing crashes\", it's the use of a non-tail-recursive function on lists. I don't know which function you ran into but Lean/Std try to ensure that they don't handle list arguments in a way that will explode on long lists. One place which I know is non-tail-recursive is the list formatter, but this is unavoidable because it ends up in another, tree-like inductive type called <code>Format</code> which can explode when traversed. We would need to rewrite the formatter significantly or replace it entirely, and I am sure there is no appetite for that in lean core</p>",
        "id": 431510794,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712319116
    },
    {
        "content": "<p>especially when the obvious answer is \"stop trying to print a gigabyte long list\"</p>",
        "id": 431510934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712319157
    },
    {
        "content": "<blockquote>\n<p>Core, or Std or however you call it</p>\n</blockquote>\n<p>These are different projects. Lean 4 core is terminology referring to the lean4 repo <a href=\"https://github.com/leanprover/lean4/\">https://github.com/leanprover/lean4/</a>, and Std is <a href=\"https://github.com/leanprover/std4/\">https://github.com/leanprover/std4/</a> . The first repo is responsible for the language itself and everything you get with no imports at all, and the second repo provides things that you can import with <code>import Std.Data.Array.Basic</code> or the like. They both share some responsibility for defining core functions on Lists and Arrays. I am a Std maintainer, but this particular function <code>String.splitOn</code> happens to live in core and I have no authority to be making decisions of this kind on their behalf.</p>",
        "id": 431511704,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712319451
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"701522\">Number Eighteen</span> <a href=\"#narrow/stream/270676-lean4/topic/current.20definition.20of.20.60String.2EsplitOn.60.20is.20incorrect/near/431509101\">said</a>:</p>\n<blockquote>\n<p>either <code>List</code> needs to be reworked or <code>Array</code> needs to become the standard container for Core collections.</p>\n</blockquote>\n<p>I made an RFC recently with a very related proposal: <a href=\"#narrow/stream/113488-general/topic/.5BRFC.5D.20single.20list.20type/near/430304738\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/.5BRFC.5D.20single.20list.20type/near/430304738</a></p>",
        "id": 431537359,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1712327708
    }
]