[
    {
        "content": "<p>I have a situation that I'm currently MWEing, but I thought to ask about the general scenario in case someone has insights.<br>\nThe TL;DR is that two proofs of the same equality behave differently under <code>simp</code>: The proof of equality by <code>rfl</code> succeeds in <code>simp</code>ing. The proof that is more complex (ie, not <code>rfl</code>) does not <code>simp</code>, with the generic error <code>simp made no progress</code>. Also, <code>rw</code> fails in this context with \"motive is not type correct\",  so we really do need <code>simp</code> to exploit the equality.</p>\n<p>I'm wondering if it is expected behaviour that <code>rfl</code> proofs <code>simp</code> better than non-<code>rfl</code> proofs, in dependently typed contexts?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">ConcreteOrMVar.instantiate_mvar_zero'_by_rfl</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">ConcreteOrMVar.mvar</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩)</span><span class=\"bp\">.</span><span class=\"n\">instantiate</span> <span class=\"o\">(</span><span class=\"n\">Subtype.mk</span> <span class=\"o\">[</span><span class=\"n\">w</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ConcreteOrMVar.instantiate_mvar_zero'_by_norfl</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">ConcreteOrMVar.mvar</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩)</span><span class=\"bp\">.</span><span class=\"n\">instantiate</span> <span class=\"o\">(</span><span class=\"n\">Subtype.mk</span> <span class=\"o\">[</span><span class=\"n\">w</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">instantiate</span><span class=\"o\">,</span> <span class=\"n\">Vector.head</span><span class=\"o\">]</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> This one does not have the 'snoc' leftover. -/</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.proofs.withType</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ok</span> <span class=\"o\">:</span> <span class=\"n\">src</span> <span class=\"mi\">1</span>  <span class=\"bp\">⊑</span> <span class=\"n\">tgt</span> <span class=\"mi\">1</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"bp\">...</span>\n  <span class=\"c1\">-- simp only [ConcreteOrMVar.instantiate_mvar_zero'_rfl] -- succeeds</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ConcreteOrMVar.instantiate_mvar_zero'_norfl</span><span class=\"o\">]</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 434385068,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1713540215
    },
    {
        "content": "<p>Probably yes. These also apply with <code>dsimp</code></p>",
        "id": 434386772,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1713540766
    },
    {
        "content": "<p>Right. Can one characterise  which <code>simp</code> actions do not work in the non-rfl case? I'm trying to build a mental model of how much I can expect from non-rfl equalities in a heavily dependent typed context.</p>",
        "id": 434388372,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1713541291
    },
    {
        "content": "<p>curious about how the two terms differ, it sounds like some of the peskier <code>congr</code>'s could be added in the second case that are just 'regular' <code>Eq</code> in the first? (just a hunch)</p>",
        "id": 434390215,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1713541890
    },
    {
        "content": "<p>(I know that <code>simp</code> sometimes adds some <code>congr</code> lemmas that are especially annoying to deal with later when there's dependent types involved)</p>",
        "id": 434390529,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1713541991
    },
    {
        "content": "<p>Lemmas proved with <code>rfl</code> can be used to rewrite even when you have dependent types.<br>\nHere is a simple example that shows some differences:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fin.Basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">not_with_rfl</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">with_rfl</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">x.1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- simp [not_with_rfl] -- fails</span>\n  <span class=\"c1\">-- simp [with_rfl] -- works</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span>\n  <span class=\"c1\">-- simp [not_with_rfl] at x -- creates new copy of `x` that doesn't occur in the goal</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">with_rfl</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">x</span> <span class=\"c1\">-- changes the type of `x`</span>\n</code></pre></div>\n<p><code>dsimp</code> can be used to use <code>simp</code> only with rfl-lemmas</p>",
        "id": 434403787,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1713546653
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>. Out of interest, do you happen to know why simp would introduce a new copy of  <code>x</code>.  I am curious about the typical development flow in which this simplified copy of <code>x</code> is used.</p>",
        "id": 434420313,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1713553932
    },
    {
        "content": "<p>It's because <code>x</code> is used in the goal, and <code>simp</code> copies hypotheses in the situation where the new type isn't defeq to the old one.</p>",
        "id": 434422007,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713554653
    },
    {
        "content": "<p>It's sort of for the same reason that <code>simp [not_with_rfl]</code> fails before doing <code>intro</code>, due to the dependence.</p>",
        "id": 434422086,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713554683
    },
    {
        "content": "<p>Right. I am just curious why simp does then rewrite types at all in the hypothesis, if the hypothesis that is used remains unsimplified. Assuming I apply <code>simp [not_with_rfl]</code>, how am I then supposed to start using the new <code>x</code>, e.g., in the example above? If it is not possible to use the new x in the goal, would it then not make more sense for simp to just not do anything rather than introducing a hypothesis that cannot be effectively used?</p>",
        "id": 434425417,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1713556123
    },
    {
        "content": "<p>I don't have any immediate examples, but I've had a number of cases where this behavior was helpful (though of course it's not always helpful!). Potentially, though, it would lead to clearer proofs if you had to explicitly do <code>have x' := x; simp ... at x'</code></p>",
        "id": 434425825,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713556298
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>, I just found an interesting example where I feel the proof should be trivial, but it somehow is not:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">test_ok</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">BitVec</span> <span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">BitVec.toNat</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">of_length_zero</span><span class=\"o\">,</span> <span class=\"n\">toNat_ofNat</span><span class=\"o\">,</span> <span class=\"n\">pow_zero</span><span class=\"o\">,</span> <span class=\"n\">Nat.zero_mod</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test_broken</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">BitVec</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">BitVec.toNat</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">A</span>\n  <span class=\"c1\">-- w : ℕ</span>\n  <span class=\"c1\">-- A✝ : BitVec w</span>\n  <span class=\"c1\">-- h : w = 0</span>\n  <span class=\"c1\">-- A : BitVec 0</span>\n  <span class=\"c1\">-- BitVec.toNat A✝ = 0</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">of_length_zero</span><span class=\"o\">]</span> <span class=\"c1\">-- does not apply as A was replaced with A✝</span>\n</code></pre></div>",
        "id": 435722082,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1714201045
    },
    {
        "content": "<p>It would be type-incorrect to place the new A in the goal's conclusion. You'll need to apply the equality to the entire goal at once using <code>subst h</code></p>",
        "id": 435724072,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1714201594
    },
    {
        "content": "<p>Lovely! That works.</p>",
        "id": 435724276,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1714201824
    }
]