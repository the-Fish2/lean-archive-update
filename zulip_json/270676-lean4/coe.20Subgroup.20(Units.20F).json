[
    {
        "content": "<p>This code was produced from working Lean 3 code, but in Lean 4 theres an error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Polynomial.FieldDivision</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Sylow</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Subgroup.Finite</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Polynomial.Eval</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.OrderOfElement</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">Classical</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">k</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">vanishingPoly</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Subgroup</span> <span class=\"o\">(</span><span class=\"n\">Units</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Polynomial</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Polynomial.monomial</span> <span class=\"o\">(</span><span class=\"n\">Fintype.card</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">Polynomial.C</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">vanish_poly_for_subgroup_elem</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Subgroup</span> <span class=\"o\">(</span><span class=\"n\">Units</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">vanishingPoly</span> <span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">eval</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The issue is that it's not coercing the <code>g</code> to <code>k</code>. Can I do this somehow without having to write .val.val?</p>",
        "id": 368685200,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1687465263
    },
    {
        "content": "<p><code>((g : k\\^x) : k)</code>?</p>",
        "id": 368685377,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1687465320
    },
    {
        "content": "<p>Well yes, but without that either. It was one character before, can I just import something to get it to recognize it can coerce this?</p>",
        "id": 368685673,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1687465401
    },
    {
        "content": "<p>Coercions have totally changed in lean 4. Maybe you can add the appropriate coercion? I would tell you what this is but I don't understand the new system.</p>",
        "id": 368698302,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1687469314
    },
    {
        "content": "<p><a href=\"#narrow/stream/113488-general/topic/rage/near/418885474\">This</a> thread has gotten me thinking about my old pain points more and so I have been looking over my old issues, and this one was the one where I took the most extensive personal notes. For those who don't want to enter the Lean4 playground, there are two error messages emitted by the above declaration:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"kd\">instance</span>\n  <span class=\"n\">Semiring</span> <span class=\"bp\">↥</span><span class=\"n\">G</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">Polynomial.eval</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">vanishingPoly</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">vanishingPoly</span> <span class=\"n\">G</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">Polynomial</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">Polynomial</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">G</span> <span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n</code></pre></div>\n<p>Here are my notes:</p>\n<p>The problem essentially boils down to the fact that <code>g</code> in the definition has not been cast to a field element and needs to be.</p>\n<p>In the first error, Lean complains that it doesn't know how to derive that <code>{x // x \\in G}</code> is a <code>Semiring</code>. This is already confusing for two reasons: Firstly, it is not clear where in the definition <code>{x // x \\in G}</code> even comes up (the answer is that since <code>G</code> is a structure rather than itself a Type, g is technically not of type G but of type <code>coe_sort G</code> or <code>↥G</code> in lean 3 notation, which seems to be represented as <code>{x // x \\in G}</code> here). Secondly, it is not clear why we need to derive <code>Semiring</code> on it.</p>\n<p>The second error is also confusing. It claims that <code>vanishingPoly G</code> is expected to have a type <code>Polynomial { x // x ∈ G }</code> but doesn't explain why it is expected to have this type. The reason is that because <code>g</code> is of type <code>G</code>, the <code>eval</code> function infers that it is working on a polynomial over G, and then decides that <code>vanishingPoly G</code> should be a polynomial over G. It is only once we realize this that we see that both errors have the same root cause: we need to derive <code>semiring</code> on <code>G</code> because we think we are supposed to make a polynomial over it and types that we have polynomials over are supposed to be <code>semiring</code>s. We mismatch the type because <code>vanishingPoly G</code> is not a polynomial over <code>G</code> but over <code>k</code>.</p>\n<p>Still unclear is why the type inference system decided that <code>G</code> was the right type in the first place. Shouldn't it have looked at the first argument <code>vanishingPoly G</code> and seen that the polynomial was over <code>k</code> and complained about the <code>g</code> argument not having the right type instead? The trouble is, despite appearances, <code>vanishingPoly G</code> is <em>not</em> the first explicit argument to <code>eval</code>. The definition of <code>eval</code> is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- `eval x p` is the evaluation of the polynomial `p` at `x` -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">eval</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n  <span class=\"n\">eval₂</span> <span class=\"o\">(</span><span class=\"n\">RingHom.id</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>What the heck? If your docstring describes the operation you are performing as \"evaluation of the polynomial <code>p</code> at <code>x</code>\" shouldn't that tell you that the more natural definition of this function is to permute the arguments and give it the type <code>R[X] → R → R</code>. This would leave the first argument as the polynomial and respect the dot notation convention that the value before a dotted function is the first argument to it.</p>\n<p>Unfortunately, this was not done for <code>Polynomial.eval</code> - I believe the reason is that we wanted to have the map <code>Polynomial.eval x</code> be linear, as this is useful for some other definitions.</p>\n<p>Leaving this aside, could we not have been more intelligent about the inference? Maybe we could have seen that respecting the polynomial argument's type would have led to fewer errors? Unfortunately probably not without a more expensive typechecker.</p>\n<p>At the very least it seems like what would have been helpful here was:</p>\n<ol>\n<li>Putting the type ascription error first: If your types are not even right, why are we trying to synthesize instances for them at all? (Counterpoint: There is nothing wrong, prior to typeclass inference, with the types on the partially-applied function <code>eval g</code>, it's only after the second application that the second error arises. This is why the order of arguments on eval makes this so devilish)</li>\n<li>More information about why the type ascription happened. Something like:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"txt\"><pre><span></span><code>application type mismatch\n  Polynomial.eval g (vanishingPoly G)\nthe second explicit argument\n  vanishingPoly G\nhas type\n  Polynomial k : Type\nbut is expected to have type\n  Polynomial { x // x ∈ G } : Type\nbecause the first implicit argument to Polynomial.eval has been inferred as\n  { x // x ∈ G } : Type\nfrom the context of the first explicit argument\n  g\nhaving type\n  { x // x ∈ G }\n</code></pre></div>\n<p>If this error message is too big then perhaps we could have a dropdown menu for people to click listing the chain of type inferences that led to the current type mismatch error.</p>",
        "id": 418936301,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1706655925
    },
    {
        "content": "<p>What do people think? Does it make sense to suppress typeclass inference errors when type mismatch errors occur nearby? Are either of these solutions even feasible with lean4's current error system?</p>",
        "id": 418936519,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1706656025
    }
]