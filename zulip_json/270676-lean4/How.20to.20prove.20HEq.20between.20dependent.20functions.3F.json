[
    {
        "content": "<p>I'm trying to understand how the goal in this gist:  <a href=\"https://gist.github.com/amuricys/e6ad118dd28873c11779b64edf0268f9\">https://gist.github.com/amuricys/e6ad118dd28873c11779b64edf0268f9</a>.<br>\nAfter a bunch of simplifications, the goal is simply a heterogeneous equality between two functions that ignore their first argument, except the first one pattern matches on it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">HEq</span>\n  <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">px</span> <span class=\"n\">rd</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">px</span><span class=\"o\">,</span> <span class=\"n\">rd</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Sum.inr</span> <span class=\"n\">_ppos</span><span class=\"o\">,</span> <span class=\"n\">dir</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">dir</span><span class=\"o\">)</span>\n  <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>I've tried extracting a simple version of this to the top level as a lemma but can't even get it to type check.<br>\nIn the goal I'm trying all sorts of tricks, including going into conversion mode so that I can get rid of that HEq. When I do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">hmm</span> <span class=\"o\">{</span><span class=\"n\">pos</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">dir</span> <span class=\"o\">:</span> <span class=\"n\">pos</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">px</span> <span class=\"o\">:</span> <span class=\"mi\">ùü¨</span><span class=\"bp\">.</span><span class=\"n\">pos</span> <span class=\"bp\">‚äï</span> <span class=\"n\">pos</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rd</span> <span class=\"o\">:</span> <span class=\"n\">dir</span> <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">px</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">Sum.inr</span> <span class=\"n\">ppos</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ppos</span><span class=\"o\">)</span> <span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">px</span><span class=\"o\">,</span> <span class=\"n\">rd</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Sum.inr</span> <span class=\"n\">_ppos</span><span class=\"o\">,</span> <span class=\"n\">dir</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">dir</span><span class=\"o\">)</span>\n  <span class=\"bp\">=</span>\n  <span class=\"n\">rd</span>\n  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">cases</span> <span class=\"n\">px</span>\n    <span class=\"bp\">.</span> <span class=\"n\">contradiction</span>\n    <span class=\"bp\">.</span> <span class=\"n\">rfl</span>\n<span class=\"c1\">-- ...</span>\n<span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">lhs</span> <span class=\"c1\">-- this is: fun px rd =&gt; match px, rd with | Sum.inr _ppos, dir =&gt; dir</span>\n        <span class=\"n\">intro</span> <span class=\"n\">px</span> <span class=\"n\">rd</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hmm</span> <span class=\"n\">px</span> <span class=\"n\">rd</span><span class=\"o\">]</span> <span class=\"c1\">-- trying to rewrite with the non-heterogeneous equality lemma</span>\n      <span class=\"n\">_</span>\n</code></pre></div>\n<p>I get the most incredible type error at the application of <code>hmm</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">hmm</span> <span class=\"n\">px</span> <span class=\"n\">rd</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">rd</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">dir</span><span class=\"bp\">‚úù</span>\n    <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">px</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Sum.inr</span> <span class=\"n\">ppos</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ppos</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">dir</span><span class=\"bp\">‚úù</span>\n    <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">px</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Sum.inr</span> <span class=\"n\">ppos</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ppos</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n</code></pre></div>\n<p>This type is not equal to itself (?????). I'm very lost on how to proceed with this. I feel like there should be a <code>subst</code> somewhere, but I can't figure out where.</p>",
        "id": 430323565,
        "sender_full_name": "Andr√© Muricy Santos",
        "timestamp": 1711749758
    },
    {
        "content": "<p>(this is cross posted from stack exchange: <a href=\"https://proofassistants.stackexchange.com/questions/3856/lean4-how-to-construct-an-heq-between-dependent-functions?noredirect=1#comment7498_3856\">https://proofassistants.stackexchange.com/questions/3856/lean4-how-to-construct-an-heq-between-dependent-functions?noredirect=1#comment7498_3856</a>)</p>",
        "id": 430323659,
        "sender_full_name": "Andr√© Muricy Santos",
        "timestamp": 1711749826
    },
    {
        "content": "<p>I didn't think about the underlying problems, and I just plowed forward trying to close the goal using <code>congr!</code> and <code>split</code>, which was able to work.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">coproduct.leftUnitor.hom_inv_id</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Poly</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">composemap</span> <span class=\"o\">(</span><span class=\"n\">leftUnitor.hom</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">leftUnitor.inv</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">polyid</span> <span class=\"o\">(</span><span class=\"mi\">ùü¨</span> <span class=\"bp\">+</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">d</span>\n  <span class=\"bp\">.</span> <span class=\"n\">cases</span> <span class=\"n\">d</span>\n    <span class=\"bp\">.</span> <span class=\"n\">contradiction</span>\n    <span class=\"bp\">.</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">.</span> <span class=\"n\">cases</span> <span class=\"n\">p</span>\n    <span class=\"bp\">.</span> <span class=\"n\">unfold</span> <span class=\"n\">composemap</span>\n      <span class=\"n\">simp</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">inv</span>\n      <span class=\"n\">simp</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">hom</span>\n      <span class=\"n\">simp</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">polyid</span>\n      <span class=\"n\">simp</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">id</span>\n      <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">lhs</span>\n        <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">a</span>\n        <span class=\"n\">simp</span>\n      <span class=\"n\">congr</span><span class=\"bp\">!</span>\n      <span class=\"bp\">¬∑</span> <span class=\"n\">split</span>\n        <span class=\"n\">assumption</span>\n      <span class=\"n\">rename_i</span> <span class=\"n\">a1</span> <span class=\"n\">a2</span> <span class=\"n\">a3</span> <span class=\"n\">a4</span>\n      <span class=\"n\">cases</span> <span class=\"n\">a1</span>\n      <span class=\"n\">split</span>\n      <span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 430334487,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711756744
    },
    {
        "content": "<p>Cleaned up:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">coproduct.leftUnitor.hom_inv_id</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Poly</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">composemap</span> <span class=\"o\">(</span><span class=\"n\">leftUnitor.hom</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">leftUnitor.inv</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">polyid</span> <span class=\"o\">(</span><span class=\"mi\">ùü¨</span> <span class=\"bp\">+</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">d</span>\n  <span class=\"bp\">.</span> <span class=\"n\">cases</span> <span class=\"n\">d</span>\n    <span class=\"bp\">.</span> <span class=\"n\">contradiction</span>\n    <span class=\"bp\">.</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">.</span> <span class=\"n\">cases</span> <span class=\"n\">p</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hom</span><span class=\"o\">,</span> <span class=\"n\">inv</span><span class=\"o\">,</span> <span class=\"n\">composemap</span><span class=\"o\">,</span> <span class=\"n\">polyid</span><span class=\"o\">,</span> <span class=\"n\">Function.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">id_eq</span><span class=\"o\">]</span>\n    <span class=\"n\">congr</span><span class=\"bp\">!</span>\n    <span class=\"bp\">¬∑</span> <span class=\"n\">split</span>\n      <span class=\"n\">assumption</span>\n    <span class=\"bp\">¬∑</span> <span class=\"n\">split</span>\n      <span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 430334954,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711757001
    },
    {
        "content": "<p>Wow, thank you!  Could you explain to me what led you to apply <code>congr!</code>? I see that the goal it creates is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Sum.inr</span>\n    <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"bp\">‚úù</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Sum.inr</span> <span class=\"n\">ppos</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ppos</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"n\">a'</span><span class=\"bp\">‚úù</span>\n</code></pre></div>\n<p>Which you're able to <code>split</code> on; this is exactly what I would have gotten if I'd applied <code>funext</code> to a _homogeneous_ equality right?</p>\n<p>Also, why does using <code>simp only</code> help here at all? I thought that made the tactic less powerful since it ignores so many things it _could_ use. You also give it a lot of things that are not lemmas! In that case it just unfolds the definition?</p>",
        "id": 430563918,
        "sender_full_name": "Andr√© Muricy Santos",
        "timestamp": 1711961672
    },
    {
        "content": "<p>(the <code>rename</code> tactic is also gold, I'd been looking for a way to introduce hidden variable names forever)</p>",
        "id": 430564097,
        "sender_full_name": "Andr√© Muricy Santos",
        "timestamp": 1711961776
    },
    {
        "content": "<p>a good reason to use <code>simp only [...]</code> over <code>simp</code> is making the proof less sensitive to changes to what is and isn't a <code>@[simp]</code> lemma. furthermore, using just a bare line of <code>simp only</code> (or <code>simp only []</code>) allows you to reduce simple lambdas in goals, for example it reduces something like <code>{fst := foo; snd := bar}.fst</code> to <code>foo</code></p>",
        "id": 430595708,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711979498
    },
    {
        "content": "<p><code>congr!</code> is a tactic that tries to prove that the two sides of something that has two sides are equal, and it has different tricks to split things up. If there's a nasty <code>HEq</code>, sometimes <code>congr!</code> can make progress. (It also can do <code>funext</code> to show that two functions are equal.)</p>",
        "id": 430604617,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711982830
    },
    {
        "content": "<p>To get that <code>simp only</code> I used <code>simp?</code>. It's good practice for \"non-terminal <code>simp</code>s\" for the reason Edward mentioned.</p>",
        "id": 430604900,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711982932
    },
    {
        "content": "<p>awesome. thank you guys!</p>",
        "id": 430730211,
        "sender_full_name": "Andr√© Muricy Santos",
        "timestamp": 1712043765
    }
]