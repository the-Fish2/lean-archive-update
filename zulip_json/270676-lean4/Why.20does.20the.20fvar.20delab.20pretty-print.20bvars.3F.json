[
    {
        "content": "<p>Here's a MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Lean.PrettyPrinter.Delaborator</span>\n<span class=\"kn\">open</span> <span class=\"n\">Meta</span>\n<span class=\"kn\">open</span> <span class=\"n\">Parser.Term</span>\n<span class=\"kn\">open</span> <span class=\"n\">SubExpr</span>\n<span class=\"kn\">open</span> <span class=\"n\">TSyntax.Compat</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">delab</span> <span class=\"n\">fvar</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">delabFVar'</span> <span class=\"o\">:</span> <span class=\"n\">Delab</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n<span class=\"k\">let</span> <span class=\"n\">Expr.fvar</span> <span class=\"n\">fvarId</span> <span class=\"bp\">←</span> <span class=\"n\">getExpr</span> <span class=\"bp\">|</span> <span class=\"n\">unreachable</span><span class=\"bp\">!</span>\n<span class=\"c1\">-- Use internal name - when pp.showFVarIDs is true or when the variable is loose.</span>\n<span class=\"n\">maybeAddBlockImplicit</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">mkIdent</span> <span class=\"n\">fvarId.name</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n<span class=\"c1\">--open Qq</span>\n<span class=\"c1\">-- #eval q(∀ x : Nat, x = x)</span>\n</code></pre></div>\n<p><code>delabFVar'</code> is adapted from just the normal <code>delabFVar</code>; it prints the fvarid at all times instead. However, it prints <code>∀ (x : Nat), _pp_uniq.1 = _pp_uniq.1 : Prop</code> for this forall - even though this x is not an fvar, but a bvar. Is this configurable? I guess it's expected, sadly...</p>",
        "id": 425213871,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1709777725
    },
    {
        "content": "<p>Yes, that's expected. The forall delab function creates an fvar and instantiates the bvar as it enters its body, in the usual way.</p>",
        "id": 425216904,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709779904
    },
    {
        "content": "<p>Is the correct way to get around this just to match against _pp_uniq?</p>",
        "id": 425217828,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1709780555
    },
    {
        "content": "<p>What are you trying to get around?</p>",
        "id": 425217898,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709780606
    },
    {
        "content": "<p>I want to pretty-print fvars with the _uniq names, but bvars as their actual \"proper\" name</p>",
        "id": 425218086,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1709780718
    },
    {
        "content": "<p>Could you help me understand why you're wanting to do this?</p>",
        "id": 425218395,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709780944
    },
    {
        "content": "<p>I want to output a state with unique names, but this leaves (for example) for alls as <code>forall a, P _pp_uniq...</code> and these clearly don't match up.</p>",
        "id": 425218918,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1709781297
    },
    {
        "content": "<p>I think I haven't understood your question. Is it that if you override the <code>fvar</code> delaborator, the <code>x</code> in <code>∀ x</code> doesn't change with it?</p>",
        "id": 425219588,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709781667
    },
    {
        "content": "<p>What do you expect the output to be?</p>",
        "id": 425219651,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709781707
    },
    {
        "content": "<p>Any of <code>∀ _pp_uniq1, P _pp.uniq1 _uniq.234...</code> or <code>∀ a, P a _uniq.234...</code> work, with _uniq.234 some actual fvar. Or well, some other name that won't get messed up by shadowing. I can see how to hack to get the second output, but not sure how I'd get that first output.</p>",
        "id": 425220359,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1709782059
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/270676-lean4/topic/Why.20does.20the.20fvar.20delab.20pretty-print.20bvars.3F/near/425218086\">said</a>:</p>\n<blockquote>\n<p>but bvars as their actual \"proper\" name</p>\n</blockquote>\n<p>And what are you calling the proper name of a bvar?</p>",
        "id": 425220678,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709782317
    },
    {
        "content": "<p>Well, I mean whatever it pretty prints as. I'm not too fussed as long as I can have a consistent name for bvars throughout the expression</p>",
        "id": 425220878,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1709782450
    },
    {
        "content": "<p>I'm wanting to clarify this because loose bvars are never supposed to appear in what's being pretty printed, and if they do show up, they print as <code>#0</code>, <code>#1</code>, etc. The idea of locally nameless representations is that bvars themselves don't have names at all, other than this de Bruijn index.</p>\n<p>The <code>a</code> in <code>∀ a</code> is <em>not</em> a bvar to be clear.</p>",
        "id": 425221033,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709782571
    },
    {
        "content": "<p>This whole time I thought you were wanting bvars in the body to print as <code>#0</code>, <code>#1</code>, etc.</p>",
        "id": 425221045,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709782589
    },
    {
        "content": "<p>The default name for a binder is stored inside the forallE and lam expressions. You can transform your Expr to replace all the binders with unique names and then pass that to the pretty printer, if your end goal is having every binder being alpha renamed to be unique.</p>",
        "id": 425221088,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709782643
    },
    {
        "content": "<p>Oh right, that's the forallE! Makes sense. I'm not super worried about loose bvars - I see the confusion. Thanks, I'll try that solution.</p>",
        "id": 425223251,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1709784019
    }
]