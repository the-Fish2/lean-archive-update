[
    {
        "content": "<p>The lemma below is very simple but seemingly can't be proved without writing out a motive explicity. Simpler approaches result in \"motive is not type correct\" or similar. It seems like the proof in <code>head</code> is causing the issue.</p>\n<p>I want something that will generalize to arbitrary type for <code>state</code>  (not just <code>Nat</code>) and arbitrary <code>step</code> function as long as we can prove that it terminates for all <code>state</code>s.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">step</span> <span class=\"o\">(</span><span class=\"n\">state</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">):</span> <span class=\"n\">Option</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">state</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">none</span> <span class=\"k\">else</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">state</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">linter.unusedVariables</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">countdown</span> <span class=\"o\">(</span><span class=\"n\">state</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">step</span> <span class=\"n\">state</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">state</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">newState</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">state</span> <span class=\"o\">::</span> <span class=\"n\">countdown</span> <span class=\"n\">newState</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">state</span>\n<span class=\"n\">decreasing_by</span>\n  <span class=\"n\">simp_wf</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">step</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">split_ifs</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">omega</span>\n\n<span class=\"c1\">-- A very simple lemma</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">initial_state</span> <span class=\"o\">(</span><span class=\"n\">state</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"n\">countdown</span> <span class=\"n\">state</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">head</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">countdown</span><span class=\"bp\">;</span> <span class=\"n\">split</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">state</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">countdown</span>\n<span class=\"c\">/-</span><span class=\"cm\"> ⊢ (match h : step state with</span>\n<span class=\"cm\">      | none =&gt; [state]</span>\n<span class=\"cm\">      | some newState =&gt; state :: countdown newState).head</span>\n<span class=\"cm\">    ⋯ =</span>\n<span class=\"cm\">  state -/</span>\n  <span class=\"c1\">-- The conclusion looks very obvious at this point, but all simple tactics fail:</span>\n  <span class=\"c1\">-- simp       -- simp made no progress</span>\n  <span class=\"c1\">-- split      -- fails</span>\n  <span class=\"c1\">-- rcases h: step state    -- tactic 'generalize' failed, result is not type correct</span>\n  <span class=\"c1\">-- With a naive by_cases approach, the subsequent simp, rw, or simp_rw all fail.</span>\n  <span class=\"c1\">--  rw gives 'motive is not type correct'</span>\n  <span class=\"c1\">-- Instead, I have to write out the motive explicitly.</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">state</span><span class=\"o\">]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">newState</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">state</span> <span class=\"o\">::</span> <span class=\"n\">countdown</span> <span class=\"n\">newState</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">head</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">split</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">state</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">step</span> <span class=\"n\">state</span> <span class=\"bp\">=</span> <span class=\"n\">none</span>\n  <span class=\"bp\">·</span> <span class=\"k\">have</span><span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">step</span> <span class=\"n\">state</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">motive</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">motive</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n    <span class=\"n\">exact</span> <span class=\"n\">this</span>\n  <span class=\"bp\">·</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- this case is similar after converting h to step state = some newState</span>\n</code></pre></div>",
        "id": 437918707,
        "sender_full_name": "Ted Hwa",
        "timestamp": 1715311625
    },
    {
        "content": "<p>How about</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">step</span> <span class=\"o\">(</span><span class=\"n\">state</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">):</span> <span class=\"n\">Option</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">state</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">none</span> <span class=\"k\">else</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">state</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">linter.unusedVariables</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">countdown</span> <span class=\"o\">(</span><span class=\"n\">state</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">step</span> <span class=\"n\">state</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">state</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">newState</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">state</span> <span class=\"o\">::</span> <span class=\"n\">countdown</span> <span class=\"n\">newState</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">state</span>\n<span class=\"n\">decreasing_by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">initial_state</span> <span class=\"o\">(</span><span class=\"n\">state</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"n\">countdown</span> <span class=\"n\">state</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">head</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">countdown</span><span class=\"bp\">;</span> <span class=\"n\">split</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">state</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">countdown</span>\n  <span class=\"n\">generalize_proofs</span> <span class=\"n\">p</span>\n  <span class=\"n\">split</span> <span class=\"n\">at</span> <span class=\"n\">p</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 437923953,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1715316783
    },
    {
        "content": "<p>(Clue: all the incorrect motives must have been about the proof inside <code>.head</code>. So use <code>generalize_proofs</code> to get access to it directly.)</p>",
        "id": 437924002,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1715316843
    },
    {
        "content": "<p>Thank you, that was really helpful in eliminating motives from several of my proofs. However, there are still some others which I couldn't eliminate. In the more difficult cases, the motive has to include an equality hypothesis because the statement to be proved would be false for an arbitrary x. Then I had to fall back on <code>Eq.rec</code> to use the motive.  I don't have a minimized example yet.</p>",
        "id": 437933134,
        "sender_full_name": "Ted Hwa",
        "timestamp": 1715323796
    },
    {
        "content": "<p>Looking forward to seeing them! :-)</p>",
        "id": 437933536,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1715324038
    },
    {
        "content": "<p>Ok, here's a reasonably minimized example.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">step</span> <span class=\"o\">(</span><span class=\"n\">state</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">):</span> <span class=\"n\">Option</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">state</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">none</span> <span class=\"k\">else</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">state</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">linter.unusedVariables</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">countdown</span> <span class=\"o\">(</span><span class=\"n\">state</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">step</span> <span class=\"n\">state</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">state</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">newState</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">state</span> <span class=\"o\">::</span> <span class=\"n\">countdown</span> <span class=\"n\">newState</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">state</span>\n<span class=\"n\">decreasing_by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">tailLast</span> <span class=\"o\">(</span><span class=\"n\">state</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">):</span>\n    <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">countdown</span> <span class=\"n\">state</span><span class=\"o\">,</span>\n      <span class=\"n\">List.getLast</span> <span class=\"o\">(</span><span class=\"n\">countdown</span> <span class=\"n\">state</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n       <span class=\"n\">List.getLast</span> <span class=\"o\">(</span><span class=\"n\">countdown</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">suffixEqualsCountdownOfHead</span> <span class=\"o\">{</span><span class=\"n\">suffix</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">suffix_nonempty</span><span class=\"o\">:</span> <span class=\"n\">suffix</span> <span class=\"bp\">≠</span> <span class=\"o\">[])</span> <span class=\"o\">(</span><span class=\"n\">state</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">):</span>\n    <span class=\"n\">suffix</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">countdown</span> <span class=\"n\">state</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tails</span> <span class=\"bp\">→</span>\n      <span class=\"n\">suffix</span> <span class=\"bp\">=</span> <span class=\"n\">countdown</span> <span class=\"o\">(</span><span class=\"n\">suffix.head</span> <span class=\"n\">suffix_nonempty</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">tailLastSuffix</span> <span class=\"o\">(</span><span class=\"n\">state</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">suffix</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">suffix_nonempty</span><span class=\"o\">:</span> <span class=\"n\">suffix</span> <span class=\"bp\">≠</span> <span class=\"o\">[])</span> <span class=\"o\">(</span><span class=\"n\">suffix_in_tails</span><span class=\"o\">:</span> <span class=\"n\">suffix</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">countdown</span> <span class=\"n\">state</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tails</span><span class=\"o\">):</span>\n    <span class=\"n\">List.getLast</span> <span class=\"o\">(</span><span class=\"n\">countdown</span> <span class=\"n\">state</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n     <span class=\"n\">List.getLast</span> <span class=\"n\">suffix</span> <span class=\"n\">suffix_nonempty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"n\">tailLast</span> <span class=\"n\">state</span> <span class=\"o\">(</span><span class=\"n\">suffix.head</span> <span class=\"n\">suffix_nonempty</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"n\">foo2</span> <span class=\"o\">:=</span> <span class=\"n\">suffixEqualsCountdownOfHead</span> <span class=\"n\">suffix_nonempty</span> <span class=\"n\">state</span> <span class=\"n\">suffix_in_tails</span>\n  <span class=\"c1\">-- I want to do rw [foo2]. Here the equality hypothesis is needed in the motive</span>\n  <span class=\"c1\">-- because a general x could  be empty, then no proof is possible for x.getLast</span>\n  <span class=\"k\">let</span> <span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">:</span> <span class=\"n\">countdown</span> <span class=\"o\">(</span><span class=\"n\">suffix.head</span> <span class=\"n\">suffix_nonempty</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">List.getLast</span> <span class=\"o\">(</span><span class=\"n\">countdown</span> <span class=\"n\">state</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n      <span class=\"n\">x.getLast</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">h2</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">unfold</span> <span class=\"n\">countdown</span><span class=\"bp\">;</span> <span class=\"n\">split</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">Eq.rec</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"n\">motive</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">motive</span><span class=\"o\">]</span>\n      <span class=\"n\">apply</span> <span class=\"n\">foo</span>\n      <span class=\"gr\">sorry</span>  <span class=\"c1\">-- rest of the proof is not relevant to this issue</span>\n    <span class=\"o\">)</span> <span class=\"n\">suffix</span> <span class=\"n\">foo2.symm</span>\n  <span class=\"n\">exact</span> <span class=\"n\">this</span>\n</code></pre></div>",
        "id": 437934832,
        "sender_full_name": "Ted Hwa",
        "timestamp": 1715324780
    },
    {
        "content": "<p>Above code has been edited slightly to include the proof for x.getLast since that's important to the issue.</p>",
        "id": 437935633,
        "sender_full_name": "Ted Hwa",
        "timestamp": 1715325206
    },
    {
        "content": "<p>In my last example, if I do <code>simp_rw [foo2]</code> (on the line with the comment <code>I want to do rw [foo2]</code>), I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">tactic</span> <span class=\"bp\">'</span><span class=\"n\">simp'</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">nested</span> <span class=\"n\">error</span><span class=\"o\">:</span>\n<span class=\"n\">maximum</span> <span class=\"n\">recursion</span> <span class=\"n\">depth</span> <span class=\"n\">has</span> <span class=\"n\">been</span> <span class=\"n\">reached</span>\n</code></pre></div>\n<p>and after turning on diagnostics as suggested, I get the following output which I don't know how to interpret:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">used</span> <span class=\"n\">theorems</span> <span class=\"o\">(</span><span class=\"n\">max</span><span class=\"o\">:</span> <span class=\"mi\">99</span><span class=\"o\">,</span> <span class=\"n\">num</span><span class=\"o\">:</span> <span class=\"mi\">1</span><span class=\"o\">):</span> <span class=\"bp\">▼</span>\n  <span class=\"n\">_uniq.680</span> <span class=\"bp\">↦</span> <span class=\"mi\">99</span>\n<span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">tried</span> <span class=\"n\">theorems</span> <span class=\"o\">(</span><span class=\"n\">max</span><span class=\"o\">:</span> <span class=\"mi\">99</span><span class=\"o\">,</span> <span class=\"n\">num</span><span class=\"o\">:</span> <span class=\"mi\">1</span><span class=\"o\">):</span> <span class=\"bp\">▼</span>\n  <span class=\"n\">_uniq.680</span> <span class=\"bp\">↦</span> <span class=\"mi\">99</span><span class=\"o\">,</span> <span class=\"n\">succeeded</span><span class=\"o\">:</span> <span class=\"mi\">99</span>\n<span class=\"o\">[</span><span class=\"n\">reduction</span><span class=\"o\">]</span> <span class=\"n\">unfolded</span> <span class=\"n\">reducible</span> <span class=\"n\">declarations</span> <span class=\"o\">(</span><span class=\"n\">max</span><span class=\"o\">:</span> <span class=\"mi\">32</span><span class=\"o\">,</span> <span class=\"n\">num</span><span class=\"o\">:</span> <span class=\"mi\">1</span><span class=\"o\">):</span> <span class=\"bp\">▼</span>\n  <span class=\"n\">Ne</span> <span class=\"bp\">↦</span> <span class=\"mi\">32</span>\n</code></pre></div>",
        "id": 438077989,
        "sender_full_name": "Ted Hwa",
        "timestamp": 1715401484
    },
    {
        "content": "<p>I found a solution. The following code replaces the code starting with the <code>motive</code> line. But I don't really understand why <code>rw</code> or <code>simp_rw</code> sometimes works and sometimes doesn't in these situations.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">foo2</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">foo</span>\n<span class=\"n\">apply</span> <span class=\"n\">foo</span>\n<span class=\"gr\">sorry</span>  <span class=\"c1\">-- rest of proof is same as the last `sorry` before</span>\n</code></pre></div>",
        "id": 438139878,
        "sender_full_name": "Ted Hwa",
        "timestamp": 1715468296
    },
    {
        "content": "<p>The initial <code>generalize_proofs</code> solution doesn't seem to work on the latest nightly build (mathlib <code>nightly-testing-2024-06-05</code>, lean <code>nightly-2024-06-05</code>).  It works on 4.8.0. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">GeneralizeProofs</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">state</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">unusedVariables</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">countdown</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">state</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">state</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">newState</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">countdown</span><span class=\"w\"> </span><span class=\"n\">newState</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">state</span>\n<span class=\"n\">decreasing_by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">initial_state</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">state</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">countdown</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">countdown</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">countdown</span>\n<span class=\"w\">  </span><span class=\"n\">generalize_proofs</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">  </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\">   </span><span class=\"c1\">-- works on 4.8.0 but on latest nightly, gives tactic 'splitMatch' failed, nested error: 'applyMatchSplitter' failed, failed to generalize target</span>\n</code></pre></div>",
        "id": 442977480,
        "sender_full_name": "Ted Hwa",
        "timestamp": 1717654889
    },
    {
        "content": "<p>Filed a bug at <a href=\"https://github.com/leanprover/lean4/issues/4390\">https://github.com/leanprover/lean4/issues/4390</a></p>",
        "id": 443212894,
        "sender_full_name": "Ted Hwa",
        "timestamp": 1717737479
    }
]