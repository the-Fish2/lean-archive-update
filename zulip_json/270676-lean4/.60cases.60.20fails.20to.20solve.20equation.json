[
    {
        "content": "<p>Sometimes, given an equality proof <code>h</code>, then doing <code>cases h</code>, you get <code>dependent elimination failed, failed to solve equation a = b</code>. But in my context I have a proof of exactly <code>hab : a = b</code>. Is there a way to pass <code>hab</code> into <code>cases h</code>? Unfortunately, <code>hab</code> is not a proof by defeq.</p>",
        "id": 436845816,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1714727662
    },
    {
        "content": "<p>Maybe you can do <code>subst hab</code> first?</p>",
        "id": 436846717,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1714728089
    },
    {
        "content": "<p><code>hab</code> has non-variables on both sides, so <code>subst</code> doesn't work, unfortunately.</p>",
        "id": 436847893,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1714728611
    },
    {
        "content": "<p>You can always generalise one side to be a free variable, then <code>subst</code></p>",
        "id": 436847979,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1714728649
    },
    {
        "content": "<p>This error happens when case produces a <em>hypothesis</em> of the form <code>a = b</code> and tries to eliminate it using <code>subst</code>; it's not a goal so <code>hab</code> is not useful</p>",
        "id": 436848074,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1714728686
    },
    {
        "content": "<p>Generalising both sides fails, I may be doing some very cursed things :)...</p>",
        "id": 436864536,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1714735513
    },
    {
        "content": "<p>I don't fully understand how <code>cases</code> works. Why would it generate a hypothesis <code>a = b</code>? I would have assumed that <code>cases h</code> essentially does <code>apply (Eq.rec ...)</code>. My guess was that the equality proof expected to be passed to <code>Eq.rec ...</code> is <code>hab</code>, and Lean isn't smart enough to find it from the context.</p>",
        "id": 436864543,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1714735516
    },
    {
        "content": "<p>It's not that it's trying to prove <code>a = b</code>, but that it's trying to substitute all <code>a</code>'s for <code>b</code>'s, and the algorithm it's using to do that is to try to peel off matching constructors from both sides until one of them is a variable. Once one side is a variable, it can apply <code>Eq.rec</code> to substitute.</p>",
        "id": 436867685,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714736899
    },
    {
        "content": "<p>Or, <code>cases</code> might see that both sides have different constructors, and it can see this is a contradiction and close the goal.</p>",
        "id": 436867808,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714736970
    },
    {
        "content": "<p>If <code>cases h</code> leads to it saying it failed to solve <code>a = b</code> and you have <code>hab : a = b</code> in your context, then that means <code>cases h</code> is equivalent to <code>cases hab</code>.</p>",
        "id": 436867969,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714737039
    },
    {
        "content": "<p>But we have substitution via <code>Eq.rec</code>, which doesn't require its inputs to be variables. It is capable of terms in general. Or have I fundamentally misunderstood how substitution works?</p>",
        "id": 436872340,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1714738865
    },
    {
        "content": "<p>The idea is that if you have <code>h : x = v</code> with <code>x</code> a variable, then you can use <code>Eq.rec</code> to transform the entire goal, substituting all <code>x</code>'s for <code>v</code>, turning <code>h</code> into <code>rfl</code> itself.</p>",
        "id": 436874694,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714739783
    },
    {
        "content": "<p>If you just have <code>a = b</code>, you could use the kabstract algorithm in rw to find all <code>a</code>'s and replace them with <code>b</code>'s, but you haven't necessarily completely utilized the equation (and also that might result in a type-incorrect context)</p>",
        "id": 436875186,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714740002
    },
    {
        "content": "<p>Here's basically <code>cases h</code> when one side is a variable:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">Eq.rec</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n    <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"n\">h</span>\n  <span class=\"n\">clear</span> <span class=\"n\">a</span> <span class=\"n\">h</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">only</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  b : ‚Ñï</span>\n<span class=\"cm\">  ‚ä¢ 2 * (b + 1) + 1 = 2 * b + 3</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>\n<p>The motive is from just abstracting the variable, and it's safe to clear <code>h</code> because <code>a</code> is <code>b + 1</code>, so no information is lost.</p>",
        "id": 436876039,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714740339
    },
    {
        "content": "<p>Ah yeah, replacing one variable is guaranteed to type-check afterwards, but replacing a whole term is hard because functions may evaluate to that term, and, how would you even match against that in full generality. Hence why so often you have effectively \"manually unify\" the goal with a fitting helper lemma, where expressions are replaced with variables. Are there tools to automate that process? I have a lot of those goals.<br>\nI also remember you recommending to craft a specialised \"cast operator\", but I have so many slightly different goals that I would use every cast operator exactly once.</p>",
        "id": 436883910,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1714742967
    }
]