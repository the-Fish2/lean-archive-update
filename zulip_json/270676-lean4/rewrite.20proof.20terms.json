[
    {
        "content": "<p>I was looking at the kind of proof terms that <code>rewrite</code> produces, and they look rather complicated, with an <code>Eq.mp</code>, and <code>id</code>, an <code>Eq.ndrec</code> and an <code>Eq.refl</code>, when it seems that <code>Eq.ndrec</code> and (possibly <code>Eq.symm</code>) should suffice; e.g. see this example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.ShowTerm</span>\n\n<span class=\"n\">opaque</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"n\">opaque</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">a_eq_b</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n<span class=\"n\">opaque</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.explicit</span> <span class=\"n\">true</span>\n\n<span class=\"c1\">-- Using rw</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">show_term</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">a_eq_b</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n\n<span class=\"c1\">-- Using the proof term that rw produces</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">Eq.mpr</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Eq</span> <span class=\"kt\">Prop</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Eq.ndrec</span> <span class=\"n\">Nat</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_a</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">@</span><span class=\"n\">Eq</span> <span class=\"kt\">Prop</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">_a</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Eq.refl</span> <span class=\"kt\">Prop</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"n\">b</span> <span class=\"n\">a_eq_b</span><span class=\"o\">))</span>\n  <span class=\"n\">h</span>\n\n<span class=\"c1\">-- Using the proof term that I would have expected</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">Eq.ndrec</span> <span class=\"n\">Nat</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">P</span> <span class=\"n\">_a</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"n\">a_eq_b.symm</span>\n\n\n<span class=\"c1\">-- A slightly simpler proof term using congrArg</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">Eq.mpr</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Eq</span> <span class=\"kt\">Prop</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">congrArg</span> <span class=\"n\">Nat</span> <span class=\"kt\">Prop</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_a</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">_a</span><span class=\"o\">))</span> <span class=\"n\">a_eq_b</span><span class=\"o\">))</span>\n  <span class=\"n\">h</span>\n</code></pre></div>\n<p>Is there a good reason why <code>rewrite</code> uses a seemingly more convoluted proof term here?</p>",
        "id": 410166392,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1703689495
    },
    {
        "content": "<p>I did some code reading, and my current assumption is that we have these proof terms as a consequence of the meta programming structure.</p>\n<p>In particular, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.rewrite#doc\">docs#Lean.MVarId.rewrite</a> runs on on an <code>Expr</code> without knowing whether its the conclusion or a hypothesis of the current goal, and (effectively) returns <code>proof : (oldType = newType)</code>. Then <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Tactic.rewriteTarget#doc\">docs#Lean.Elab.Tactic.rewriteTarget</a> resp. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Tactic.rewriteLocalDecl#doc\">docs#Lean.Elab.Tactic.rewriteLocalDecl</a> apply that equality to the goal resp. the hypothesis using <code>Eq.mpr</code> resp. <code>Eq.mp</code>.</p>\n<p>I don’t know whether and why the <code>@id</code> term, added in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"k\">let</span> <span class=\"n\">newProof</span> <span class=\"bp\">←</span> <span class=\"n\">mkExpectedTypeHint</span> <span class=\"n\">eqProof</span> <span class=\"n\">eq</span>\n</code></pre></div>\n<p>in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.replaceTargetEq#doc\">docs#Lean.MVarId.replaceTargetEq</a>, is needed. Maybe I should remove it, run CI, see what breaks, and then add a comment.</p>\n<p>One could imagine that if <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.rewrite#doc\">docs#Lean.MVarId.rewrite</a> knew whether it should produce <code>oldType → newType</code> or <code>newType → oldType</code> it could produce simpler proof terms, but there may be more reasons behind the current structure that I don't see right now. I wonder if the effect on the mathlib <code>.olean</code> size is noticable, but with the term sharing probably not so much.</p>",
        "id": 410272909,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1703758854
    },
    {
        "content": "<p>Although even with that structure I wonder if <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.rewrite#doc\">docs#Lean.MVarId.rewrite</a> could return a (slightly) simpler proof using <code>congrArg</code> (added to the code snippet above). Maybe the problem here is that <code>congrArg</code> only works for non-dependent motives?</p>",
        "id": 410274264,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1703759364
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/rewrite.20proof.20terms/near/410272909\">said</a>:</p>\n<blockquote>\n<p>I don’t know whether and why the <code>@id</code> term, added in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"k\">let</span> <span class=\"n\">newProof</span> <span class=\"bp\">←</span> <span class=\"n\">mkExpectedTypeHint</span> <span class=\"n\">eqProof</span> <span class=\"n\">eq</span>\n</code></pre></div>\n<p>in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.replaceTargetEq#doc\">docs#Lean.MVarId.replaceTargetEq</a>, is needed. Maybe I should remove it, run CI, see what breaks, and then add a comment.</p>\n</blockquote>\n<p>The purpose of the <code>id</code> term is to get the kernel to use the correct type when typechecking the body. This is required in those rare cases where definitional equality as checked by the kernel is not transitive, but much more commonly it will be a situation where <code>A == B</code> and <code>B == C</code> are quick to check but <code>A == C</code> ends up unfolding unnecessary things and being much slower. This is used by <code>dsimp</code> to avoid the kernel having to work too much trying to reconstruct the proof that <code>dsimp</code> found.</p>",
        "id": 410320440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703783224
    },
    {
        "content": "<p>More generally, lean produces inefficient proofs in many places, and I assure you there is no grander reason for this than it has not been an optimization goal of the lean system to produce short proofs. There are plenty of low hanging fruits you could do in this space like not using <code>Eq.trans rfl</code> all the time. These arise because the simplest way to code the proof generator involves these redundancies.</p>",
        "id": 410320659,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703783357
    },
    {
        "content": "<p>Thanks! Is it worth plucking these fruits when coming across then, or is proof object size just too irrelevant to bother?</p>",
        "id": 410321378,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1703783847
    },
    {
        "content": "<p>Speaking for myself I would be very happy to see improvement in this area, I have wanted this for years. Proof object size is very much not irrelevant, it's one contributing factor to mathlib's 4GB</p>",
        "id": 410322590,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703784606
    },
    {
        "content": "<p>Although there the much lower hanging fruit is to simply not ship them by default, because unless you are running a proof checker you don't need them, do you?</p>",
        "id": 410322768,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1703784725
    },
    {
        "content": "<p><code>to_additive</code> reads proof terms</p>",
        "id": 410323052,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703784912
    },
    {
        "content": "<p>Ah, good point.</p>",
        "id": 410323108,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1703784945
    },
    {
        "content": "<p>I played with slightly smaller proof terms in <a href=\"https://github.com/leanprover/lean4/pull/3121\">https://github.com/leanprover/lean4/pull/3121</a>, and it almost goes through, but something odd is happening with the side-conditions from the lemma (different order, not filled with local assumptions by <code>rw?</code>), and I am bit confused how this rather simple change can affect such things.</p>",
        "id": 410324786,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1703785981
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/rewrite.20proof.20terms/near/410323052\">said</a>:</p>\n<blockquote>\n<p><code>to_additive</code> reads proof terms</p>\n</blockquote>\n<p>... although we've argued in the past that probably it should use transfer theorems and apply the multiplicative version instead</p>",
        "id": 410326740,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703787161
    }
]