[
    {
        "content": "<p>I cannot understand why is <code>@</code>needed when trying to produce something out of false:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">False.rec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"c1\">--works</span>\n</code></pre></div>\n<p>while</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">False.rec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"c1\">-- throws the error</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">application type mismatch</span>\n<span class=\"cm\">  False.rec ?m.29 fun x ↦ ℕ</span>\n<span class=\"cm\">argument</span>\n<span class=\"cm\">  fun x ↦ ℕ</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  ?m.31 → Type : Sort (max 2 ?u.30)</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  False : Prop</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>When I look at</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span><span class=\"w\"> </span><span class=\"n\">False.rec</span><span class=\"w\"> </span><span class=\"c1\">-- False.rec.{u} (motive : False → Sort u) (t : False) : motive t</span>\n</code></pre></div>\n<p>everything seems explicit, so I cannot see why <code>False.rec</code> and <code>@False.rec</code>  behave differently. As a bonus I would like to understand if/how I could have guess this behaviour while looking at <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#False\">the file</a> where <code>False</code> is defined in an apparently innocuous way.</p>\n<p>While playing the same game with <code>Nat.rec</code> (that looks defined in the same way, to me), I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span><span class=\"w\"> </span><span class=\"n\">Nat.rec</span><span class=\"w\"> </span><span class=\"c1\">-- Nat.rec.{u} {motive : ℕ → Sort u} (zero : motive Nat.zero) (succ : (n : ℕ) → motive n → motive n.succ) (t : ℕ) :  motive t</span>\n</code></pre></div>\n<p>and here the <code>motive</code> is implicit.</p>\n<p>Since I can of course fix the first example by doing</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">False.rec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>and I understand that without explicitly mentioning the <code>motive</code> Lean cannot go very far,  I guess that my question really is: why do I see explicit, rather than implicit, variables when <code>check</code>ing <code>False.rec</code>?</p>",
        "id": 442638039,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1717538227
    },
    {
        "content": "<p>there was a similar question recently... it has to do with how <code>False.rec</code> is elaborated as an eliminator.</p>",
        "id": 442638531,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1717538361
    },
    {
        "content": "<p><a href=\"#narrow/stream/270676-lean4/topic/Signature.20of.20.60False.2Erec.60/near/441354391\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Signature.20of.20.60False.2Erec.60/near/441354391</a></p>",
        "id": 442638584,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1717538379
    },
    {
        "content": "<p><a href=\"#narrow/stream/270676-lean4/topic/Signature.20of.20.60False.2Erec.60/near/441354391\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Signature.20of.20.60False.2Erec.60/near/441354391</a></p>",
        "id": 442638593,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1717538382
    },
    {
        "content": "<p>OK, thanks: I see that <span class=\"user-mention\" data-user-id=\"266304\">@Siddhartha Gadgil</span>  had the very same question indeed. But unfortunately I do not really understand the answers:</p>\n<ul>\n<li>\"The motive cannot be inferred later\" means that in the construction of <code>Blob.rec</code>, where <code>Blob</code> is any inductive type, <code>Lean</code> is able to understand if the way constructors are entangled with one another would allow to infer the type of the motive? For instance, in <code>Nat.rec</code> providing <code>motive n</code> in the second explicit variable (as second argument of <code>succ</code>) is enough? If so.. WOW!</li>\n<li><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> , can you be a bit more explicit about the \"ElabAsElim code\" explanation? I do not understand why it \"explains\"  what is going on; the only thing I figure out is that <code>False.rec'</code>  behaves more normally, is that right?</li>\n</ul>",
        "id": 442640268,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1717538831
    },
    {
        "content": "<p>The situation is too confusing, so I've created an issue: <a href=\"https://github.com/leanprover/lean4/pull/4347\">lean4#4347</a></p>",
        "id": 442641437,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1717539198
    },
    {
        "content": "<p>Wow, thanks! Let's wait and see <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 442641712,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1717539284
    },
    {
        "content": "<p>That 'explanation' involving ElabAsElim isn't really intelligible to anyone who isn't acquainted with Lean 4 internals, sorry.</p>\n<p>Here's another attempt: eliminators need special help during elaboration since their return type is the application of an unknown function. Somehow, given the expected type, <code>False.rec</code> needs to figure out what <code>motive</code> is. This is a \"higher-order unification problem\": unification needs to solve for a function rather than just a plain non-function value, and higher-order unification is undecidable, so Lean doesn't even try in most cases. So, special code kicks in for eliminators that identifies which argument needs to be solved for using higher-order unification (<code>motive</code> in this case) and then it completely takes over for that particular argument. It doesn't care whether or not that argument is explicit, and it will never look at positional arguments. I imagine this is an oversight.</p>\n<p>There are two ways to turn off this special feature. The first is explicit application (<code>@False.rec (fun _ ↦ ℕ) h</code> as you observed). Another is to use a keyword argument for the motive (<code>False.rec (motive := fun _ ↦ ℕ) h</code>).</p>",
        "id": 442642781,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1717539613
    },
    {
        "content": "<p>You can also turn it on for your own declarations by adding the <code>@[elab_as_elim]</code> attribute to them.</p>",
        "id": 442643037,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1717539718
    },
    {
        "content": "<p>OK, thanks. I think I had a blurry picture in mind of what you describe much more neatly, so this really helps. I will try to play around with this attribute to see if I understand a bit better what is happening under the rug.</p>",
        "id": 442643187,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1717539801
    },
    {
        "content": "<p>My impression with many of these higher order unification questions is that asker says \"this higher order unification question is easy to solve and so why doesn't Lean's algorithm solve it\" and the generic answer is \"there will always be examples that any algorithm can't solve because the problem is undecidable\". I think that what's surprising is that exanples of failure are so easy to come by, but there was an example in TPIL3 of a very simple problem which had four obvious solutions each one of which was right in one situation and wrong in the other three, and this was what made the penny drop that somehow the question is completely hopeless.</p>",
        "id": 442693452,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717562692
    }
]