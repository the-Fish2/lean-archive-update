[
    {
        "content": "<p>I changed the definition of an instance in mathlib to something which seems to be defeq in <a href=\"https://github.com/leanprover-community/mathlib4/pull/11413\">#11413</a> , but a few random files speed up (<a href=\"https://github.com/leanprover-community/mathlib4/pull/11413#issuecomment-2000607729\">speedcenter</a>). My understanding is that typeclass inference is super-fast for unifying \"reducibly rfl\" instances but can explode nowadays even with defeq instances (it starts unfolding and unfolding, and we have some pretty big structures; this is arguably a regression in the typeclass inference system from Lean 3, if my understanding is correct). In trying to understand this phenomenon better, I remembered some Lean code which someone had posted which could check whether two terms of the same typeclass were \"obviously equal\" for the typeclass inference algorithm but I can't find it now. Can someone show me how to check this?</p>\n<p>The un-xy: I find my graduate students complaining to me that things are slow (integer rings are slow, tensor products are slow, Hopf algebras are slow etc etc) and I look at their traces and I see stuff like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>            <span class=\"o\">[</span><span class=\"n\">tryResolve</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">284857</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">Coalgebra</span> <span class=\"n\">R</span> <span class=\"o\">((</span><span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">≟</span> <span class=\"n\">Coalgebra</span> <span class=\"n\">R</span> <span class=\"o\">((</span><span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">▼</span>\n              <span class=\"o\">[</span><span class=\"n\">isDefEq</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">146107</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">Coalgebra</span> <span class=\"n\">R</span> <span class=\"o\">((</span><span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">=?=</span> <span class=\"n\">Coalgebra</span> <span class=\"bp\">?</span><span class=\"n\">m.46814</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m.46815</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"bp\">?</span><span class=\"n\">m.46814</span><span class=\"o\">]</span> <span class=\"bp\">?</span><span class=\"n\">m.46816</span><span class=\"o\">)</span> <span class=\"bp\">▼</span>\n                <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">011000</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">NonUnitalNonAssocSemiring.toAddCommMonoid</span> <span class=\"bp\">=?=</span> <span class=\"n\">TensorProduct.addCommMonoid</span> <span class=\"bp\">▶</span>\n                <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">125267</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">Algebra.toModule</span> <span class=\"bp\">=?=</span> <span class=\"n\">TensorProduct.instModuleTensorProductToSemiringAddCommMonoid</span> <span class=\"bp\">▼</span>\n                  <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">125243</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">Module.mk</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=?=</span> <span class=\"n\">TensorProduct.instModuleTensorProductToSemiringAddCommMonoid</span> <span class=\"bp\">▼</span>\n                    <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">125235</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">Module.mk</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=?=</span> <span class=\"n\">TensorProduct.leftModule</span> <span class=\"bp\">▼</span>\n                      <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">125223</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">Module.mk</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=?=</span> <span class=\"n\">Module.mk</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">▼</span>\n                        <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">123805</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">DistribMulAction.mk</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=?=</span> <span class=\"n\">TensorProduct.leftDistribMulAction</span> <span class=\"bp\">▶</span>\n              <span class=\"o\">[</span><span class=\"n\">isDefEq</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">138644</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"bp\">?</span><span class=\"n\">m.46809</span> <span class=\"bp\">=?=</span> <span class=\"n\">Coalgebra.instTensorProduct</span> <span class=\"bp\">▶</span>\n</code></pre></div>\n<p>What sin have I committed here, that typeclass inference spends an age breaking up everything into small pieces interminably before saying \"oh yeah it was <code>rfl</code> after all\"?</p>",
        "id": 427149259,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710690093
    },
    {
        "content": "<p><code>by with_reducible rfl</code> is the way to check if two things are reducibly equal</p>",
        "id": 427161082,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710693152
    },
    {
        "content": "<p>So I am still confused. The change Eric made in  <a href=\"https://github.com/leanprover-community/mathlib4/pull/11413\">#11413</a> is changing an instance from something to something else which is reducibly defeq to the original instance...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Group.InjSurj</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">M₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">M₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Pow</span> <span class=\"n\">M₂</span> <span class=\"n\">ℕ</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Function</span>\n\n<span class=\"c1\">-- variants of `Function.Surjective.commMonoid`, pushing the monoid axioms along a surjection</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">commMonoid1</span> <span class=\"o\">[</span><span class=\"n\">CommMonoid</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M₁</span> <span class=\"bp\">→</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Surjective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">npow</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">CommMonoid</span> <span class=\"n\">M₂</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">hf.commSemigroup</span> <span class=\"n\">f</span> <span class=\"n\">mul</span><span class=\"o\">,</span> <span class=\"n\">hf.monoid</span> <span class=\"n\">f</span> <span class=\"n\">one</span> <span class=\"n\">mul</span> <span class=\"n\">npow</span> <span class=\"k\">with</span> <span class=\"o\">}</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">commMonoid2</span> <span class=\"o\">[</span><span class=\"n\">CommMonoid</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M₁</span> <span class=\"bp\">→</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Surjective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">npow</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">CommMonoid</span> <span class=\"n\">M₂</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">hf.monoid</span> <span class=\"n\">f</span> <span class=\"n\">one</span> <span class=\"n\">mul</span> <span class=\"n\">npow</span><span class=\"o\">,</span> <span class=\"n\">hf.commSemigroup</span> <span class=\"n\">f</span> <span class=\"n\">mul</span> <span class=\"k\">with</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">commMonoid1</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">commMonoid2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">with_reducible</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- works</span>\n</code></pre></div>\n<p>...except that in the PR we use <code>def</code> not <code>abbrev</code>, and then somehow this choice (which makes things less reducibly equal) causes a 10% speedup in some random files?</p>\n<p>My question is: why does the change from commMonoid1 to commMonoid2 ever make anything any better? What is the fundamental change we're making, which changes how typeclass inference behaves and explains the speedcenter link in the original post above?</p>",
        "id": 427532822,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710781112
    },
    {
        "content": "<p>I think maybe it helps if you put them in the same order as the <code>extends</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">CommMonoid</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Monoid</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">CommSemigroup</span> <span class=\"n\">M</span>\n</code></pre></div>",
        "id": 427533204,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1710781203
    },
    {
        "content": "<p>Yes, Ruben is right</p>",
        "id": 427533923,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710781369
    },
    {
        "content": "<p>Don't ask me why, though</p>",
        "id": 427534320,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1710781466
    },
    {
        "content": "<p>The point is that it's doing less unpacking and repacking all the structures involved (since these structures have overlapping fields and there is only one \"true\" parent).</p>",
        "id": 427534939,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710781643
    },
    {
        "content": "<p>I'm fairly certain that if the structures in the <code>extends</code> clause were disjoint then it wouldn't make any difference.</p>",
        "id": 427535311,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710781764
    },
    {
        "content": "<p>The PR uses <code>@[reducible] def</code> which is basically the same as <code>abbrev</code></p>",
        "id": 427540630,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710783486
    },
    {
        "content": "<p>I left this on the closed <a href=\"https://github.com/leanprover-community/mathlib4/pull/11368\">#11368</a> but probably no one will ever look there (lightly edited for sane reading)</p>\n<blockquote>\n<p>Currently the structure instance elaborator tries to populate all the fields one at a time, eta expanding any failed structure fields, and trying again. </p>\n<p>The problem with <code>with</code> was that it could never match on <code>toA</code> directly if you had an <code>A</code> in the sources itself or via some projection of the sources. The reason for this was very silly: <code>A</code> doesn't have a <code>self</code> field and we search through all fields in the structure for matching. </p>\n<p>This left the <code>toA</code> unfilled and resulted in the eta expansion in the next pass. </p>\n<p>The problem with the eta expansion is that unification defaults to eta expansion when two terms differ by a constructor application. So now where there might have been one quick check you are forced to check all the fields directly. If any of this contains data, then you are much worse off. </p>\n<p>So generally we want our terms to be as eta-reduced as possible still. Unification still takes them apart and looks at the pieces if they aren't. </p>\n<p>So we come to the issue here: Lean 4's preferred parent implementation means that if you can supply the instance of the preferred parent you want to do so to avoid eta expansion in their flavor of inheritance. </p>\n<p>Another change that landed with <code>with</code> fix was that the structure instance elaborator should now always fill the field with the first occurrence in the sources reading left to right. If the preferred parent comes second, then you are in trouble because it's very likely Lean will not use it whole and the end product will be eta expanded much more than necessary. </p>\n<p>Here our preferred parent is <code>Monoid</code>. It should go first in the list of supplied sources. When it doesn't, Lean sees it has a <code>mul</code> from the <code>CommSemigroup</code> instance. This blocks elaboration from using the <code>Monoid</code> source since <code>mul</code> occurs in <code>Monoid</code> also. So it uses that <code>mul</code> to build the <code>CommMonoid</code> instead of using <code>Monoid</code>. The result is that data, the multiplication, is exposed to unification each time this function is used to construct a <code>CommMonoid</code></p>\n</blockquote>",
        "id": 427543012,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1710784236
    },
    {
        "content": "<p>So let me get this straight. Typeclass inference can explode when trying to unify two terms which are reducibly defeq? And preferred parents in mathlib's algebra hierarchy are now actually a thing that people have agreed on as opposed to a theory?</p>",
        "id": 427579675,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710798082
    },
    {
        "content": "<p>There's two things at play here: typeclass inference exploding and spread notation exploding. The latter causes the former.</p>",
        "id": 427579865,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710798159
    },
    {
        "content": "<p>Preferred parents are a thing for non-flat structures. We haven't really given much thought about which parents should be preferred in mathlib</p>",
        "id": 427579924,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710798195
    },
    {
        "content": "<p>we've given thought, not sure we've put that thought into action</p>",
        "id": 427582906,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710799435
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/checking.20for.20reducible.20rfl/near/427579675\">said</a>:</p>\n<blockquote>\n<p>So let me get this straight. Typeclass inference can explode when trying to unify two terms which are reducibly defeq? And preferred parents in mathlib's algebra hierarchy are now actually a thing that people have agreed on as opposed to a theory?</p>\n</blockquote>\n<p>This happens independent of typeclass search. (TC synthesis just calls unifications a lot.) To my understanding, the whole point of transparency settings is to address exactly this problem. We don't want to completely unfold everything and normalize to check defeq because the terms are terribly large. </p>\n<p>I think there has been a fair bit of thought about the choice of preferred parents in mathlib but I think we have more experience since those design decisions were made. </p>\n<p>I know people have proposed more radical redesigns of the hierarchies motivated by this experience.</p>",
        "id": 427661904,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1710844501
    },
    {
        "content": "<p>Would this reasoning also apply <a href=\"https://github.com/leanprover-community/mathlib4/blob/c9a06998fe84b2f04365a09f8f597c5c620d79a7/Mathlib/LinearAlgebra/TensorProduct/Basic.lean#L336\">here</a>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">addCommMonoid</span> <span class=\"o\">:</span> <span class=\"n\">AddCommMonoid</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">TensorProduct.addCommSemigroup</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">TensorProduct.addZeroClass</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"k\">with</span>\n    <span class=\"n\">toAddSemigroup</span> <span class=\"o\">:=</span> <span class=\"n\">TensorProduct.addSemigroup</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n    <span class=\"n\">toZero</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">TensorProduct.addZeroClass</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toZero</span>\n    <span class=\"n\">nsmul</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span> <span class=\"bp\">•</span> <span class=\"n\">v</span>\n    <span class=\"n\">nsmul_zero</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">TensorProduct.zero_smul</span><span class=\"o\">]</span>\n    <span class=\"n\">nsmul_succ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">TensorProduct.one_smul</span><span class=\"o\">,</span> <span class=\"n\">TensorProduct.add_smul</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span>\n      <span class=\"n\">forall_const</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Or does the fact that <code>toAddSemigroup</code> and <code>toZero</code> are provided explicitly mean the order of the arguments before <code>with</code> doesn't matter?</p>",
        "id": 427729169,
        "sender_full_name": "Amelia Livingston",
        "timestamp": 1710857264
    },
    {
        "content": "<p>Providing <code>to</code> arguments explicitly indeed stops them from being filled in piecewise by a <code>with</code> clause</p>",
        "id": 427729421,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710857324
    },
    {
        "content": "<p>Mental model for filling order:</p>\n<ol>\n<li>anything <code>:=</code> </li>\n<li>find it in the sources before <code>with</code> going left to right</li>\n<li>try to synthesize it </li>\n</ol>\n<p>I think that default values goes between 2 and 3 but would need to check the code to be sure</p>",
        "id": 427744636,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1710860858
    },
    {
        "content": "<p>where exactly does the spread stuff fit in this model?</p>",
        "id": 427746063,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710861198
    },
    {
        "content": "<p>It is the same as a <code>with</code> clause</p>",
        "id": 427746349,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710861254
    },
    {
        "content": "<p>Having never actually looked at the spread notation, I would wildly speculate that <code>__ := </code> are sources and the named ones are <code>:=</code></p>",
        "id": 427746392,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1710861266
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/270676-lean4/topic/checking.20for.20reducible.20rfl/near/427746349\">said</a>:</p>\n<blockquote>\n<p>It is the same as a <code>with</code> clause</p>\n</blockquote>\n<p>I would swear it's not exactly the same, because I've had things break by switching between the two. But it's always possible I made some other mistake.</p>",
        "id": 427746803,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710861369
    },
    {
        "content": "<p>While the ordering of the sources here is basically irrelevant since only proof fields will be used, note that the <code>toZero := ...</code> will make the terms more expanded than, say, building a <code>AddMonoid</code> and then layering on <code>add_comm</code> proof. Does this matter? Probably not that much here, only if Lean is fine with all the <code>AddMonoid</code> instances it is seeing being \"clearly\" the same. Just don't inline the data if it can be helped</p>",
        "id": 427747486,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1710861538
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/270676-lean4/topic/checking.20for.20reducible.20rfl/near/427746803\">said</a>:</p>\n<blockquote>\n<p>I would swear it's not exactly the same</p>\n</blockquote>\n<p>The one difference I can think of is that <code>with</code> clauses always come last while spread clauses <em>might</em> be able to come before other clauses (I'm not quite sure)</p>",
        "id": 427747986,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710861654
    },
    {
        "content": "<p>Eg, here you don't want Lean to try to compute <code>n • v</code> every time it is unifying two <code>AddCommMonoid</code> instances on the tensor product. Since this is wrapped in a call to a notation typeclass, my experience makes me think it won't if can just unify the instance names without unfold the <code>SMul</code>. I could be quite wrong here though</p>",
        "id": 427748513,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1710861772
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/stream/270676-lean4/topic/checking.20for.20reducible.20rfl/near/427747486\">said</a>:</p>\n<blockquote>\n<p>While the ordering of the sources here is basically irrelevant since only proof fields will be used, note that the <code>toZero := ...</code> will make the terms more expanded than, say, building a <code>AddMonoid</code> and then layering on <code>add_comm</code> proof. Does this matter? Probably not that much here, only if Lean is fine with all the <code>AddMonoid</code> instances it is seeing being \"clearly\" the same. Just don't inline the data if it can be helped</p>\n</blockquote>\n<p>This does significantly speed up <code>Mathlib.Algebra.Category.AlgebraCat.Monoidal</code>, is <a href=\"https://github.com/leanprover-community/mathlib4/pull/11505\">#11505</a> worth existing?</p>",
        "id": 427775722,
        "sender_full_name": "Amelia Livingston",
        "timestamp": 1710869019
    },
    {
        "content": "<p>For a .25% overall improvement, I think so!</p>",
        "id": 427776500,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1710869233
    },
    {
        "content": "<p>Oh nice find!</p>",
        "id": 427795036,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710875630
    },
    {
        "content": "<p>I thought <code>TensorProduct.addMonoid</code>might speed things up because I'd seen a trace where stuff like <code>TensorProduct.addCommMonoid =?= AddCommGroup.toAddCommMonoid</code> was slowish and the preferred parent of <code>AddCommGroup</code> is <code>AddGroup</code></p>",
        "id": 427805458,
        "sender_full_name": "Amelia Livingston",
        "timestamp": 1710879839
    },
    {
        "content": "<p>On the other hand,  <a href=\"https://github.com/leanprover-community/mathlib4/blob/c9f13612c5f6500620f9b971f7ec57dda7fcd041/Mathlib/Algebra/Module/Basic.lean#L158\">here</a> in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Module.compHom</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→+*</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Module</span> <span class=\"n\">S</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">MulActionWithZero.compHom</span> <span class=\"n\">M</span> <span class=\"n\">f.toMonoidWithZeroHom</span><span class=\"o\">,</span> <span class=\"n\">DistribMulAction.compHom</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→*</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n    <span class=\"n\">add_smul</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">show</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_smul</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>the arguments before the <code>with</code> are also in the non-preferred order; similarly in <code>DistribMulAction.compHom</code>. I tried switching them in both declarations but bench said there were no significant changes. Is that expected? For the record I want to speed up <code>Mathlib.Algebra.Category.ModuleCat.ChangeOfRings</code> where <code>Module.compHom</code> is used heavily. but I'll try looking at more traces in that file</p>",
        "id": 427805661,
        "sender_full_name": "Amelia Livingston",
        "timestamp": 1710879936
    },
    {
        "content": "<p>It highly depends on what kind of things you are checking defeq with. If they are also of the form <code>Module.compHom</code>, there shouldn't be much speedup</p>",
        "id": 427806059,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710880116
    },
    {
        "content": "<p>I see, that makes sense</p>",
        "id": 427806619,
        "sender_full_name": "Amelia Livingston",
        "timestamp": 1710880334
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/270676-lean4/topic/checking.20for.20reducible.20rfl/near/427746803\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/270676-lean4/topic/checking.20for.20reducible.20rfl/near/427746349\">said</a>:</p>\n<blockquote>\n<p>It is the same as a <code>with</code> clause</p>\n</blockquote>\n<p>I would swear it's not exactly the same, because I've had things break by switching between the two. But it's always possible I made some other mistake.</p>\n</blockquote>\n<p>The way spread notation works is that every <code>__ :=</code> is collected up and placed in a <code>with</code> clause in order. If there was already a <code>with</code> clause, they're inserted after the existing sources. (See <code>Mathlib.Tactic.Spread</code> for the macro.)</p>\n<p>There's currently a hack I put into place to make it so every value from a <code>__ :=</code> can be used as a local instance. This has a very uncertain future, and it was just to help smooth over some changes during a recent Lean version bump.</p>\n<p>Minus this local instance feature of <code>__ :=</code>, it should be exactly the same as using a <code>with</code> clause.</p>",
        "id": 427811965,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710882562
    },
    {
        "content": "<blockquote>\n<p>I want to speed up <code>Mathlib.Algebra.Category.ModuleCat.ChangeOfRings</code> where <code>Module.compHom</code> is used heavily. but I'll try looking at more traces in that file</p>\n</blockquote>\n<p>I'm looking at some slow declarations now and I'm not sure that it's typeclass inference any more; there are at least two non-terminal <code>dsimp</code>s which are taking forever. For example changing the <code>dsimp</code> in <code>ModuleCat.ExtendRestrictScalarsAdj.HomEquiv.evalAt</code> (line 600 or so) to <code>dsimp only</code> changes the number of heartbeats from 87801 (2.6 seconds) to 13266 (0.3 seconds) on my machine.</p>",
        "id": 428005140,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710964266
    },
    {
        "content": "<p>Similarly <code>ModuleCat.restrictScalarsIsEquivalenceOfRingEquiv</code> is not slow becasue of typeclass inference, it's slow because an autoparam: <code>aesop_cat</code> is taking over 2 seconds to solve a goal.</p>",
        "id": 428005633,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710964461
    },
    {
        "content": "<p>Yeah, sorry, I should've edited this post because as soon as I started trying to make an MWE of my slow use-case (extension of scalars as a lax monoidal functor) by moving it into its own file on current mathlib, it went from taking 40 seconds to compile to about 4 <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span> so I am no longer bothered about the <code>ChangeOfRings</code> file <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 428006340,
        "sender_full_name": "Amelia Livingston",
        "timestamp": 1710964738
    },
    {
        "content": "<p>Yes, inserting quick clean up <code>dsimp</code> calls can make a big difference and the autoparams for <code>CategoryTheory</code> structures can awfully expensive.</p>",
        "id": 428006820,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1710964927
    },
    {
        "content": "<p>The current definition of <code>restrictScalarsIsEquivalenceOfRingEquiv</code> is the same as this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">restrictScalarsIsEquivalenceOfRingEquiv</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">≃+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsEquivalence</span> <span class=\"o\">(</span><span class=\"n\">ModuleCat.restrictScalars</span> <span class=\"n\">e.toRingHom</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">inverse</span> <span class=\"o\">:=</span> <span class=\"n\">ModuleCat.restrictScalars</span> <span class=\"n\">e.symm</span>\n  <span class=\"n\">unitIso</span> <span class=\"o\">:=</span> <span class=\"n\">NatIso.ofComponents</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">M</span> <span class=\"bp\">↦</span> <span class=\"n\">LinearEquiv.toModuleIso'</span>\n    <span class=\"o\">{</span> <span class=\"n\">__</span> <span class=\"o\">:=</span> <span class=\"n\">AddEquiv.refl</span> <span class=\"n\">M</span>\n      <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"bp\">↦</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e.right_inv</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n  <span class=\"n\">counitIso</span> <span class=\"o\">:=</span> <span class=\"n\">NatIso.ofComponents</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">M</span> <span class=\"bp\">↦</span> <span class=\"n\">LinearEquiv.toModuleIso'</span>\n    <span class=\"o\">{</span> <span class=\"n\">__</span> <span class=\"o\">:=</span> <span class=\"n\">AddEquiv.refl</span> <span class=\"n\">M</span>\n      <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">r</span> <span class=\"n\">m</span> <span class=\"bp\">↦</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">e.left_inv</span> <span class=\"n\">r</span><span class=\"o\">)})</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n  <span class=\"n\">functor_unitIso_comp</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">aesop_cat</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>where I've added in the three <code>by aesop_cat</code>s which are happening by autoparams. It's 107K heartbeats; if you sorry them all instead it's  20K heartbeats.</p>",
        "id": 428007038,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710965038
    },
    {
        "content": "<p>I once replaced something like this with <code>rfl</code> and it was glorious. Probably doesn’t apply here.</p>",
        "id": 428007537,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1710965233
    },
    {
        "content": "<p>they're all <code>intros; rfl</code> in fact:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">count_heartbeats</span> <span class=\"k\">in</span>\n<span class=\"kd\">instance</span> <span class=\"n\">restrictScalarsIsEquivalenceOfRingEquiv</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">≃+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsEquivalence</span> <span class=\"o\">(</span><span class=\"n\">ModuleCat.restrictScalars</span> <span class=\"n\">e.toRingHom</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">inverse</span> <span class=\"o\">:=</span> <span class=\"n\">ModuleCat.restrictScalars</span> <span class=\"n\">e.symm</span>\n  <span class=\"n\">unitIso</span> <span class=\"o\">:=</span> <span class=\"n\">NatIso.ofComponents</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">M</span> <span class=\"bp\">↦</span> <span class=\"n\">LinearEquiv.toModuleIso'</span>\n    <span class=\"o\">{</span> <span class=\"n\">__</span> <span class=\"o\">:=</span> <span class=\"n\">AddEquiv.refl</span> <span class=\"n\">M</span>\n      <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"bp\">↦</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e.right_inv</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n  <span class=\"n\">counitIso</span> <span class=\"o\">:=</span> <span class=\"n\">NatIso.ofComponents</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">M</span> <span class=\"bp\">↦</span> <span class=\"n\">LinearEquiv.toModuleIso'</span>\n    <span class=\"o\">{</span> <span class=\"n\">__</span> <span class=\"o\">:=</span> <span class=\"n\">AddEquiv.refl</span> <span class=\"n\">M</span>\n      <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">r</span> <span class=\"n\">m</span> <span class=\"bp\">↦</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">e.left_inv</span> <span class=\"n\">r</span><span class=\"o\">)})</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n  <span class=\"n\">functor_unitIso_comp</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>is 21K down from 107K.</p>",
        "id": 428009247,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710966020
    },
    {
        "content": "<p>Glorious</p>",
        "id": 428009663,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1710966218
    },
    {
        "content": "<p>I think we need an issue for aesop performance vs <code>fun _ =&gt; rfl</code> if this is the second incident</p>",
        "id": 428009881,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1710966311
    },
    {
        "content": "<p>We could also adjust the auto-param to <code>by try (intros; rfl); aesop_cat</code></p>",
        "id": 428010664,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1710966615
    },
    {
        "content": "<p>I'm making a speed-up PR. Here's another reason this file is slow: we keep having to do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>                                                    <span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">061262</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">HSMul</span> <span class=\"n\">S</span> <span class=\"bp\">↑</span><span class=\"o\">((</span><span class=\"n\">ModuleCat.restrictScalars</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">↑</span><span class=\"o\">((</span><span class=\"n\">ModuleCat.restrictScalars</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">▶</span>\n                                                    <span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">038096</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">HSMul</span> <span class=\"n\">S</span> <span class=\"bp\">↑</span><span class=\"o\">((</span><span class=\"n\">ModuleCat.restrictScalars</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">↑</span><span class=\"o\">((</span><span class=\"n\">ModuleCat.restrictScalars</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">▶</span>\n                                                    <span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">037499</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">HSMul</span> <span class=\"n\">S</span> <span class=\"bp\">↑</span><span class=\"o\">((</span><span class=\"n\">ModuleCat.restrictScalars</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">↑</span><span class=\"o\">((</span><span class=\"n\">ModuleCat.restrictScalars</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">▶</span>\n</code></pre></div>\n<p>We just did one computation three times and it took 0.12 seconds; we do this computation a lot of times in the file.</p>",
        "id": 428014549,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710968314
    },
    {
        "content": "<p>I'm sorry I'm so slow to understand all of this.</p>\n<p>I'm currently looking at a trace which contains this (on a fast machine):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">220873</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">⧸</span> <span class=\"n\">Ideal.span</span> <span class=\"o\">{</span><span class=\"n\">IsPrimitiveRoot.toInteger</span> <span class=\"n\">hζ</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">})</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>So that says \"for something which is obviously a ring (being a quotient of a ring by an ideal), Lean takes over 0.2 seconds to check that it has a zero\".  So there's presumably something wrong (and a bunch of professional mathematicians trying to do something completely mathematically innocuous at a conference in Luminy are struggling as a result). Digging a little further I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">141052</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">Module</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">=?=</span> <span class=\"n\">Module</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>so most of the time is spent checking that two module structures are defeq. The module structures aren't syntactically equal; one is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">Module</span> <span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">))</span> <span class=\"n\">Ring.toSemiring</span> <span class=\"n\">AddCommGroup.toAddCommMonoid</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n</code></pre></div>\n<p>and the other is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">Module</span> <span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Subalgebra.toSemiring</span> <span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">))</span> <span class=\"n\">NonUnitalNonAssocSemiring.toAddCommMonoid</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n</code></pre></div>\n<p>The next line of the trace is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">134164</span><span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">AddCommGroup.toAddCommMonoid</span> <span class=\"bp\">=?=</span> <span class=\"n\">NonUnitalNonAssocSemiring.toAddCommMonoid</span>\n</code></pre></div>\n<p>and then typeclass inference goes haywire, </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[]</span> <span class=\"bp\">✅</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">DenselyNormedField.toNontriviallyNormedField</span> <span class=\"n\">to</span> <span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>etc etc (over 500 lines of nonsense scanning many irrelevant instances). </p>\n<p>So I'm guessing the problem is that typeclass inference is refusing to believe that the two module structures are defeq. However</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">Module</span> <span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">))</span> <span class=\"n\">Ring.toSemiring</span> <span class=\"n\">AddCommGroup.toAddCommMonoid</span> <span class=\"bp\">=</span>\n          <span class=\"bp\">@</span><span class=\"n\">Module</span> <span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Subalgebra.toSemiring</span> <span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">))</span> <span class=\"n\">NonUnitalNonAssocSemiring.toAddCommMonoid</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">with_reducible</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>works fine. </p>\n<p>So is <code>with_reducible rfl</code> just a red herring?</p>",
        "id": 429641101,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711455102
    },
    {
        "content": "<p>Here's another one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">--  [] [0.132849s] ✅ 1 =?= 1</span>\n<span class=\"c1\">--    [] [0.132785s] ✅ One.toOfNat1 =?= One.toOfNat1</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">One.toOfNat1</span> <span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">⧸</span> <span class=\"n\">Ideal.span</span> <span class=\"o\">{</span><span class=\"bp\">λ</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">Ideal.Quotient.one</span> <span class=\"o\">(</span><span class=\"n\">Ideal.span</span> <span class=\"o\">{</span><span class=\"bp\">λ</span><span class=\"o\">}))</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">⧸</span> <span class=\"n\">Ideal.span</span> <span class=\"o\">{</span><span class=\"bp\">λ</span><span class=\"o\">})</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">One.toOfNat1</span> <span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">⧸</span> <span class=\"n\">Ideal.span</span> <span class=\"o\">{</span><span class=\"bp\">λ</span><span class=\"o\">})</span> <span class=\"n\">AddMonoidWithOne.toOne</span>                <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">⧸</span> <span class=\"n\">Ideal.span</span> <span class=\"o\">{</span><span class=\"bp\">λ</span><span class=\"o\">})</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">with_reducible</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- works fine</span>\n</code></pre></div>\n<p>This is all coming from the far-too-slow-for-my-liking <a href=\"https://github.com/riccardobrasca/flt3\">https://github.com/riccardobrasca/flt3</a></p>",
        "id": 429643296,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711455906
    },
    {
        "content": "<p>After more experiments, I think this all boils down to the issue (which I can't currently find) that typeclass inference checks the newest instances first. For example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>                <span class=\"o\">[]</span> <span class=\"n\">new</span> <span class=\"n\">goal</span> <span class=\"n\">Neg</span> <span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">⧸</span> <span class=\"n\">Ideal.span</span> <span class=\"o\">{</span><span class=\"n\">IsPrimitiveRoot.toInteger</span> <span class=\"n\">hζ</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">})</span> <span class=\"bp\">▼</span>\n                  <span class=\"o\">[</span><span class=\"n\">instances</span><span class=\"o\">]</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">InvolutiveNeg.toNeg</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">SubNegMonoid.toNeg</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">NegZeroClass.toNeg</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">AddGroupWithOne.toNeg</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">Ring.toNeg</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">LinearOrderedAddCommGroupWithTop.toNeg</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>This <code>Neg</code> typeclass is just a simple thing coming from ring theory, but the Lean happened to last import some exotic thing from order theory which applies, so Lean now just goes down some rabbithole looking at linearly ordered stuff <em>first</em>, before finding its way to the obvious instance :-(</p>",
        "id": 429645163,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711456563
    },
    {
        "content": "<p>Reducible rfl is no guarantee of performance. Though making things more opaque is a valid way to handle performance issues</p>",
        "id": 429646024,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711456911
    },
    {
        "content": "<p>“Lean don’t look there”</p>",
        "id": 429646120,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711456932
    },
    {
        "content": "<p>Performance is about how much data Lean has to check is the same. Ideally that would be none. But of course we can’t guarantee that. </p>\n<p>A hygienic rule is to make sure all data is separated from other data in a term so Lean can at least ask itself if it needs to unfold that or is fine without it.</p>",
        "id": 429646608,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711457117
    },
    {
        "content": "<p>I think here you have death by 1000 cuts where there are many instances to check against. In each one Lean has to defeq of some data (like <code>Neg</code>) which takes a small but nontrivial amount of time. Then it adds up. </p>\n<p>I would ask: is <code>Neg</code> exposed wherever it is declared?</p>",
        "id": 429647761,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711457452
    },
    {
        "content": "<p>I'm just increasing the priority of all the instances relevant to the project in order to work around this right now.</p>",
        "id": 429650536,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711458280
    },
    {
        "content": "<p>Under the things that were right under my face but only just realized: projections from class parents are NOT reducible. This is why we have <code>with_reducible_and_instances</code>. So breaking out parent classes is more opaque than parent structures which have reducible projections.</p>",
        "id": 429650734,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711458362
    },
    {
        "content": "<p>Why not demote the bad ones to make everyone’s life better? I don’t think most users are making a <code>LinearOrderedAddCommGroupWithTop</code> because they need that <code>Neg</code></p>",
        "id": 429651829,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711458773
    },
    {
        "content": "<p>yes demoting the bad instances is a much better choice!</p>",
        "id": 429652092,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711458878
    },
    {
        "content": "<p>I made an issue for mathlib <a href=\"https://github.com/leanprover-community/mathlib4/pull/11692\">#11692</a> so you can use this tag for each change. It should be linked to the existing lean issue. If things change, we can quickly find all the changes by grepping</p>",
        "id": 429660866,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711461431
    }
]