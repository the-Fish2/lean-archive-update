[
    {
        "content": "<p>In the following examples, the third case elaborates different from the first two:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"type_of\"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">withMainContext</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">ex</span> <span class=\"bp\">←</span> <span class=\"n\">Tactic.elabTerm</span> <span class=\"n\">t</span> <span class=\"n\">none</span>\n    <span class=\"k\">let</span> <span class=\"n\">ty</span> <span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">ex</span>\n    <span class=\"n\">IO.println</span> <span class=\"n\">ty</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">type_of</span> <span class=\"n\">h</span>\n  <span class=\"c1\">-- forall (x : Nat), Eq.{1} Nat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)) x) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) x (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">type_of</span> <span class=\"o\">(</span><span class=\"gr\">sorry</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- forall (x : Nat), Eq.{1} Nat (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)) x) (HAdd.hAdd.{0, 0, 0} Nat Nat Nat (instHAdd.{0} Nat instAddNat) x (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">type_of</span> <span class=\"n\">h</span>\n  <span class=\"c1\">-- forall (x : Nat), Eq.{?_uniq.1161} Nat (HAdd.hAdd.{?_uniq.1164, ?_uniq.1163, ?_uniq.1162} Nat Nat Nat (instHAdd.{0} Nat instAddNat) (OfNat.ofNat.{?_uniq.1167} Nat 1 (instOfNatNat 1)) x) (HAdd.hAdd.{?_uniq.1179, ?_uniq.1178, ?_uniq.1177} Nat Nat Nat (instHAdd.{0} Nat instAddNat) x (OfNat.ofNat.{?_uniq.1182} Nat 1 (instOfNatNat 1)))</span>\n</code></pre></div>\n<p>In particular, it contains lots of universe level metavariables. Why is that/ how can I have it elaborate to the same result as the other two cases?</p>",
        "id": 411028495,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1704294023
    },
    {
        "content": "<p>When you print with <code>IO.println</code>, it's using <code>toString</code> which has no access to the MetaM state.  Make sure to <code>instantiateMVars</code></p>",
        "id": 411029079,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704294222
    },
    {
        "content": "<p>Or, maybe instead do <code>logInfo m!\"{ty}\"</code> or similar. The <code>logInfo</code> function captures the MetaM state and does pretty printing.</p>",
        "id": 411029385,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704294315
    },
    {
        "content": "<p>You don't need to instantiateMVars in that case.</p>",
        "id": 411029451,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704294336
    },
    {
        "content": "<p>Using <code>instantiateMVars</code> on <code>ty</code> does indeed fix it. Why is the last case different from the other two in the first place though?</p>",
        "id": 411029597,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1704294368
    },
    {
        "content": "<p>The last case is how I'd expect it to normally be. There's no reason to assume that expressions have every metavariable's value substituted in.</p>",
        "id": 411030038,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704294521
    },
    {
        "content": "<p>I briefly tried looking into the source for why <code>(sorry : ∀ x : Nat, 1 + x = x + 1)</code> seems to instantiate all the metavariables in the type of <code>sorry</code>, and nothing popped out as being the reason.</p>",
        "id": 411030732,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704294807
    }
]