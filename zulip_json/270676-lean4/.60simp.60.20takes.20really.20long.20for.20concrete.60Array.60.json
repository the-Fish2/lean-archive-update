[
    {
        "content": "<p>In the following mwe, <code>simp</code> takes a really long time for what looks like a simple application of a lemma, while using <code>rw</code> works instantly. This is related to the size of the array, for <code>Fin 10</code>, <code>simp</code> also runs instantly.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">MyArray</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Array</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MyArray.mk</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyArray</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MyArray.toList</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">MyArray</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">Array.toList</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">mk_toList</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyArray.toList</span> <span class=\"o\">(</span><span class=\"n\">MyArray.mk</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a.toList</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">base</span> <span class=\"o\">:=</span> <span class=\"n\">Array.ofFn</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">1000</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">i.val</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">MyArray.toList</span> <span class=\"o\">(</span><span class=\"n\">MyArray.mk</span> <span class=\"n\">base</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">base.toList</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mk_toList</span><span class=\"o\">]</span> <span class=\"c1\">-- instantly</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">MyArray.toList</span> <span class=\"o\">(</span><span class=\"n\">MyArray.mk</span> <span class=\"n\">base</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">base.toList</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mk_toList</span><span class=\"o\">]</span> <span class=\"c1\">-- takes really long</span>\n</code></pre></div>\n<p>Is this a known bug? Is there a workaround other than avoiding <code>simp</code>?</p>",
        "id": 432702378,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1712840915
    },
    {
        "content": "<p>This sounds like a successor theorem applying 1000 times, cc: <span class=\"user-mention\" data-user-id=\"110994\">@Joe Hendrix</span></p>",
        "id": 432704054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712841497
    },
    {
        "content": "<p>What does <code>simp? [mk_toList]</code> say?</p>",
        "id": 432704178,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1712841545
    },
    {
        "content": "<p>It's not a theorem,  <code>simp only [mk_toList]</code> works, but takes just as long.</p>",
        "id": 432705886,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1712842068
    },
    {
        "content": "<p>Interesting.  I'll explore it a bit more, but the performance problem is the type checker and the definition <code>simp</code> produces rather than simp itself.  Here are the corresponding definitions.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">rw_def</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">MyArray.mk</span> <span class=\"n\">base</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toList</span> <span class=\"bp\">=</span> <span class=\"n\">base.toList</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Eq.mpr</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_a</span> <span class=\"bp\">=</span> <span class=\"n\">base.toList</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mk_toList</span> <span class=\"n\">base</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"n\">base.toList</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">simp_def</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">MyArray.mk</span> <span class=\"n\">base</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toList</span> <span class=\"bp\">=</span> <span class=\"n\">base.toList</span> <span class=\"o\">:=</span> <span class=\"n\">of_eq_true</span> <span class=\"o\">(</span><span class=\"n\">eq_self</span> <span class=\"n\">base.toList</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 432734833,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1712849918
    },
    {
        "content": "<p>That makes sense, it's basically equivalent to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">MyArray.toList</span> <span class=\"o\">(</span><span class=\"n\">MyArray.mk</span> <span class=\"n\">base</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">base.toList</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>which is also super slow</p>",
        "id": 432737226,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1712850613
    },
    {
        "content": "<p>To the original the question; I was a little surprised by the slowness here, but working with definitions that can expand to large terms (like an array with 1000 elements) can often lead to performance problems if the kernel needs reductions.</p>\n<p>I suspect this theorem is getting simplified to <code>rfl</code> so it could potentially be a definitional equality. <br>\n There are a variety of potential solutions, but changing the theorem opaque seems to make this problem go away:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">mk_toList</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyArray.toList</span> <span class=\"o\">(</span><span class=\"n\">MyArray.mk</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a.toList</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- fast now</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">MyArray.toList</span> <span class=\"o\">(</span><span class=\"n\">MyArray.mk</span> <span class=\"n\">base</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">base.toList</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mk_toList</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 432745669,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1712853143
    },
    {
        "content": "<p>Interesting, I'm not really familiar with <code>opaque</code>. What does it do and what's the downside?</p>",
        "id": 432770990,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1712862781
    },
    {
        "content": "<p>Is this something that would be fixed by eliminating <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.toList#doc\">docs#Array.toList</a> in favor of .data, as discussed elsewhere?</p>",
        "id": 432798357,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712874821
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I expected that would speed up the proof, but it doesn't after a bit of testing.</p>",
        "id": 432838884,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1712904233
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"654733\">Markus Schmaus</span> <a href=\"#narrow/stream/270676-lean4/topic/.60simp.60.20takes.20really.20long.20for.20concrete.60Array.60/near/432770990\">said</a>:</p>\n<blockquote>\n<p>Interesting, I'm not really familiar with <code>opaque</code>. What does it do and what's the downside?</p>\n</blockquote>\n<p>What's happening is that <code>simp</code> is seeing <code>mk_toList</code> is a <code>rfl</code> proof and as such omitting it as an explicit rewrite step with the expecation that <code>refl</code> will take care of it.  Using <code>opaque</code> is hiding the definition of the theorem from <code>simp</code> and so it can't treat it as a <code>rfl</code> proof.   </p>\n<p>I think the main downside is that this is a bit of a hack so it looks strange.  I'd recommend considering your usage.  It may be better to just keep it a theorem and use <code>rw</code>.  It'd be worth filing an issue with your example if that isn't working.</p>",
        "id": 432839993,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1712904859
    },
    {
        "content": "<p>you may also be able to prove the theorem by <code>id rfl</code> to hide the rfl-ness to simp</p>",
        "id": 432840219,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712904986
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.60simp.60.20takes.20really.20long.20for.20concrete.60Array.60/near/432840219\">said</a>:</p>\n<blockquote>\n<p>you may also be able to prove the theorem by <code>id rfl</code> to hide the rfl-ness to simp</p>\n</blockquote>\n<p>Just tested this, and it works. </p>\n<p>Which leaves me with the question, why I need to trick <code>simp</code> into being faster? To which the answer probably is that usually the default behavior is faster.</p>\n<p>Thank you all for explaining this.</p>",
        "id": 432860009,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1712911711
    },
    {
        "content": "<p>I think the primary motivation is that theorems provable via <code>rfl</code> can be used in places that non-rfl proofs cannot.  Specifically, <code>rfl</code> proofs can be used in dependent positions that may change the type of the term.  With Lean, constants that expand out to large constants such as <code>base</code> are fairly rare while dependent simplification is a bit more common (in my experience). </p>\n<p>It might be worth documenting the workaround eventually, but it's not clear where to me since this is pretty rate -- perhaps once we have a reference manual.</p>",
        "id": 432918160,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1712932663
    }
]