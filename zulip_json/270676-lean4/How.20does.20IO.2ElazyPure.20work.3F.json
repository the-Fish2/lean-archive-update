[
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/blob/5cc0c3f145ffa623a617ca31387d7f589802c1d3/src/Init/System/IO.lean#L172-L173\"><code>IO.lazyPure</code></a> has no doc string, but from the name what I expected it to do is evaluate the computation only once the returned IO monad is run.  But it doesn't seem to do that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">lazyPure</span> <span class=\"o\">(</span><span class=\"n\">fn</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">fn</span> <span class=\"o\">())</span>\n</code></pre></div>\n<p>If I'm reading that right, it <strong>first</strong> calls the function, then constructs an <code>IO</code> monad out of it, which if run will immediately return the result that was already computed when <code>lazyPure</code> was called.  Am I reading that right?</p>",
        "id": 420616775,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707472074
    },
    {
        "content": "<p>I'd expect it to look more like this, though I'm also not 100% sure this is lazy:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">lazyPure</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"o\">()</span>\n  <span class=\"n\">pure</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 420617410,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707472320
    },
    {
        "content": "<p>You cannot answer this question by looking only at the surface syntax. The IR looks correct.</p>",
        "id": 420619280,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1707472966
    },
    {
        "content": "<p>due to automatic eta expansion in the compiler</p>",
        "id": 420619520,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1707473047
    },
    {
        "content": "<p>How does it know to make correct IR?  Also, how do I look at the IR?</p>",
        "id": 420619544,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707473052
    },
    {
        "content": "<p>It's <code>trace.compiler.ir.result</code> but I didn't mention it since the output is probably not very meaningful unless you already know about the option :)</p>",
        "id": 420619706,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1707473119
    },
    {
        "content": "<p>I see, so the language itself has some laziness in the execution semantics.</p>",
        "id": 420619719,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707473124
    },
    {
        "content": "<p>I've written compilers.</p>",
        "id": 420619747,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707473132
    },
    {
        "content": "<p>Not sure that would've helped me personally speaking! But if you're interested in the details, the IR described in our Counting Immutable Beans paper is still relatively close to what's in Lean today</p>",
        "id": 420619958,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1707473202
    },
    {
        "content": "<p>What's the example where pure and lazyPure behave differently?</p>",
        "id": 420620015,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707473222
    },
    {
        "content": "<p>If you do <code>pure</code>, the computation happens in the outer function.  If you then don't inline <code>pure</code>, it's bad.  Here I think things only work since <code>pure</code> inlined into <code>lazyPure</code>.</p>",
        "id": 420620258,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707473298
    },
    {
        "content": "<p>The IR doesn't contain a <code>pure</code> call:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">result</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">BaseIO.lazyPure._rarg</span> <span class=\"o\">(</span><span class=\"n\">x_1</span> <span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x_2</span> <span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">x_3</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">ctor_0</span><span class=\"o\">[</span><span class=\"n\">PUnit.unit</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n  <span class=\"k\">let</span> <span class=\"n\">x_4</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">app</span> <span class=\"n\">x_1</span> <span class=\"n\">x_3</span><span class=\"bp\">;</span>\n  <span class=\"k\">let</span> <span class=\"n\">x_5</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">ctor_0</span><span class=\"o\">[</span><span class=\"n\">EStateM.Result.ok</span><span class=\"o\">]</span> <span class=\"n\">x_4</span> <span class=\"n\">x_2</span><span class=\"bp\">;</span>\n  <span class=\"n\">ret</span> <span class=\"n\">x_5</span>\n<span class=\"kd\">def</span> <span class=\"n\">BaseIO.lazyPure</span> <span class=\"o\">(</span><span class=\"n\">x_1</span> <span class=\"o\">:</span> <span class=\"bp\">◾</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">x_2</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">pap</span> <span class=\"n\">BaseIO.lazyPure._rarg</span><span class=\"bp\">;</span>\n  <span class=\"n\">ret</span> <span class=\"n\">x_2</span>\n</code></pre></div>",
        "id": 420620350,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707473342
    },
    {
        "content": "<p>For the sake of completeness it should also be mentioned that this function seems completely unused in core</p>",
        "id": 420620551,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1707473406
    },
    {
        "content": "<p>I don't think <code>pure</code> needs to be inlined for <code>lazyPure</code> to have the desired semantics. If we take as an assumption that the compiler always uncurries top-level definitions before compiling them, then because <code>IO α</code> is defined as <code>IO.RealWorld -&gt; EStateM.Result IO.Error IO.RealWorld α</code>, any function which is returning <code>IO α</code> will be compiled into a function taking <code>IO.RealWorld</code> as its final argument. In the example of <code>lazyPure</code>, that results in a definition like this, which will be lazy when partially applied regardless of whether <code>pure</code> is inlined.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">lazyPure</span> <span class=\"o\">(</span><span class=\"n\">fn</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">world</span> <span class=\"o\">:</span> <span class=\"n\">IO.RealWorld</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">EStateM.Result</span> <span class=\"n\">IO.Error</span> <span class=\"n\">IO.RealWorld</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">fn</span> <span class=\"o\">())</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">world</span>\n</code></pre></div>\n<p>I was confused about <a href=\"#narrow/stream/270676-lean4/topic/Issue.20using.20ffi.20api/near/400595040\">a similar situation with <code>IO</code> and FFI</a> before.</p>",
        "id": 420820352,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1707588094
    }
]