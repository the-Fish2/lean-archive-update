[
    {
        "content": "<p>how do i take a function definition with cases and turn it into simp lemmas?</p>",
        "id": 422712773,
        "sender_full_name": "Jared green",
        "timestamp": 1708553397
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Classical</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">normalizable</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">pred</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">atom</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">normalizable</span> <span class=\"n\">α</span> <span class=\"n\">pred</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">And</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">normalizable</span> <span class=\"n\">α</span> <span class=\"n\">pred</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">normalizable</span> <span class=\"n\">α</span> <span class=\"n\">pred</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">normalizable</span> <span class=\"n\">α</span> <span class=\"n\">pred</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Or</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">normalizable</span> <span class=\"n\">α</span> <span class=\"n\">pred</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">normalizable</span> <span class=\"n\">α</span> <span class=\"n\">pred</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">normalizable</span> <span class=\"n\">α</span> <span class=\"n\">pred</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Not</span> <span class=\"o\">:</span> <span class=\"n\">normalizable</span> <span class=\"n\">α</span> <span class=\"n\">pred</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">normalizable</span> <span class=\"n\">α</span> <span class=\"n\">pred</span>\n<span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">normalizable</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">toProp</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">normalizable</span> <span class=\"n\">α</span> <span class=\"n\">pred</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">atom</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pred</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">And</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span>  <span class=\"n\">toProp</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">toProp</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Or</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">toProp</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">toProp</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Not</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">toProp</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 422713011,
        "sender_full_name": "Jared green",
        "timestamp": 1708553520
    },
    {
        "content": "<p>What simp lemmas do you wish to obtain for it?</p>",
        "id": 422713968,
        "sender_full_name": "Emilie (Shad Amethyst)",
        "timestamp": 1708554001
    },
    {
        "content": "<p>toProp (Not a) &lt;-&gt; ¬(toProp a)</p>",
        "id": 422714147,
        "sender_full_name": "Jared green",
        "timestamp": 1708554085
    },
    {
        "content": "<p>I'd try <code>@[simps]</code> or <code>@[reducible]</code> on <code>toProp</code>, to see which suit you best</p>",
        "id": 422714339,
        "sender_full_name": "Emilie (Shad Amethyst)",
        "timestamp": 1708554192
    },
    {
        "content": "<p>what would that look like?</p>",
        "id": 422714401,
        "sender_full_name": "Jared green",
        "timestamp": 1708554232
    },
    {
        "content": "<p>Ah, <code>@[simps]</code> doesn't work because you don't have a <code>structure</code>. <code>@[reducible]</code> means that things like simp and instance synthetization will \"see through\" <code>toProp</code>, and be able to deduce facts directly from its definition.<br>\nThis means that when applying <code>@[reducible]</code>, <code>simp</code> will be able to treat <code>toProp (Not a)</code> as if you had written <code>¬toProp a</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">toProp</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">normalizable</span> <span class=\"n\">α</span> <span class=\"n\">pred</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Atom</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pred</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">And</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span>  <span class=\"n\">toProp</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">toProp</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Or</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">toProp</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">toProp</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Not</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">toProp</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">pred</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n₁</span> <span class=\"n\">n₂</span> <span class=\"o\">:</span> <span class=\"n\">normalizable</span> <span class=\"n\">α</span> <span class=\"n\">pred</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">toProp</span> <span class=\"o\">(</span><span class=\"n\">Or</span> <span class=\"o\">(</span><span class=\"n\">And</span> <span class=\"o\">(</span><span class=\"n\">Not</span> <span class=\"n\">n₁</span><span class=\"o\">)</span> <span class=\"n\">n₁</span><span class=\"o\">)</span> <span class=\"n\">n₂</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">toProp</span> <span class=\"n\">n₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>\n<p>Alternatively, proving the four simp theorems isn't too tedious in your example, since they are all defEq:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">toProp</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">normalizable</span> <span class=\"n\">α</span> <span class=\"n\">pred</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Atom</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pred</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">And</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span>  <span class=\"n\">toProp</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">toProp</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Or</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">toProp</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">toProp</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Not</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">toProp</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">pred</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n₁</span> <span class=\"n\">n₂</span> <span class=\"o\">:</span> <span class=\"n\">normalizable</span> <span class=\"n\">α</span> <span class=\"n\">pred</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">toProp_not</span> <span class=\"o\">:</span> <span class=\"n\">toProp</span> <span class=\"o\">(</span><span class=\"n\">Not</span> <span class=\"n\">n₁</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">¬</span> <span class=\"n\">toProp</span> <span class=\"n\">n₁</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">toProp_and</span> <span class=\"o\">:</span> <span class=\"n\">toProp</span> <span class=\"o\">(</span><span class=\"n\">And</span> <span class=\"n\">n₁</span> <span class=\"n\">n₂</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">toProp</span> <span class=\"n\">n₁</span> <span class=\"bp\">∧</span> <span class=\"n\">toProp</span> <span class=\"n\">n₂</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">toProp_or</span> <span class=\"o\">:</span> <span class=\"n\">toProp</span> <span class=\"o\">(</span><span class=\"n\">Or</span> <span class=\"n\">n₁</span> <span class=\"n\">n₂</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">toProp</span> <span class=\"n\">n₁</span> <span class=\"bp\">∨</span> <span class=\"n\">toProp</span> <span class=\"n\">n₂</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">toProp_atom</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">toProp</span> <span class=\"o\">(</span><span class=\"n\">Atom</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">normalizable</span> <span class=\"n\">α</span> <span class=\"n\">pred</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">pred</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">toProp</span> <span class=\"o\">(</span><span class=\"n\">Or</span> <span class=\"o\">(</span><span class=\"n\">And</span> <span class=\"o\">(</span><span class=\"n\">Not</span> <span class=\"n\">n₁</span><span class=\"o\">)</span> <span class=\"n\">n₁</span><span class=\"o\">)</span> <span class=\"n\">n₂</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">toProp</span> <span class=\"n\">n₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 422719951,
        "sender_full_name": "Emilie (Shad Amethyst)",
        "timestamp": 1708557342
    },
    {
        "content": "<p>Can't you just use <code>@[simp]</code> (not <code>simps</code>) on the definition?</p>",
        "id": 422729813,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708564262
    },
    {
        "content": "<p>I believe that adds the full function equation to the simp set, not the specialized variants corresponding to the cases? Although that may be a reasonable feature request. Code for that already exists for recursive definitions.</p>",
        "id": 422771193,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1708591598
    },
    {
        "content": "<p>If the function is non-recursive, it does what you say. If it is recursive, it does what I say. The lean3 behavior was to always do what I said.</p>",
        "id": 422777125,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708593824
    },
    {
        "content": "<p>And I'm guessing that related to this right?<br>\n<a href=\"#narrow/stream/270676-lean4/topic/getEqnsFor.3F.20non-recursive.20function/near/411706112\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/getEqnsFor.3F.20non-recursive.20function/near/411706112</a></p>",
        "id": 422802195,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1708603448
    }
]