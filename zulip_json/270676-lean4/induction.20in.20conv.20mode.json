[
    {
        "content": "<p>I would like to inductively rewrite terms in conv mode. My application would be to compute derivatives of recursively defined functions.</p>\n<p>I have a buggy prototype that can do induction over natural numbers. You can rewrite: <code>n+n</code> to <code>Nat.recOn n 0 fun n' xₙ =&gt; xₙ + 2</code> using conv command <code>induction n (simp) (rw[thm1,eq])</code>.</p>\n<p>Here is the full code:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Qq</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span> <span class=\"n\">Conv</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">:=</span><span class=\"n\">conv_induction</span><span class=\"o\">)</span> <span class=\"s2\">\"induction\"</span> <span class=\"n\">ident</span> <span class=\"n\">conv</span> <span class=\"n\">conv</span> <span class=\"o\">:</span> <span class=\"n\">conv</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">tactic</span> <span class=\"n\">conv_induction</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">convInduction</span> <span class=\"o\">:</span> <span class=\"n\">Tactic</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">conv</span><span class=\"bp\">|</span> <span class=\"n\">induction</span> <span class=\"bp\">$</span><span class=\"n\">n</span> <span class=\"bp\">$</span><span class=\"n\">baseConv</span> <span class=\"bp\">$</span><span class=\"n\">succConv</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mvarId</span> <span class=\"bp\">←</span> <span class=\"n\">getMainGoal</span>\n  <span class=\"n\">mvarId.withContext</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">lhs</span> <span class=\"bp\">←</span> <span class=\"n\">getLhs</span>\n    <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">decl</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getLCtx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">findFromUserName</span><span class=\"bp\">?</span> <span class=\"n\">n.getId</span>\n      <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"local variable {n} not found\"</span>\n\n    <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">Expr.fvar</span> <span class=\"n\">decl.fvarId</span>\n    <span class=\"k\">let</span> <span class=\"n\">lhsFun</span> <span class=\"bp\">←</span> <span class=\"n\">mkLambdaFVars</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">lhs</span>\n\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">x₀</span><span class=\"o\">,</span> <span class=\"n\">eq₀</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">lhsFun.beta</span> <span class=\"bp\">#</span><span class=\"o\">[(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Nat.zero</span> <span class=\"o\">[])])</span> <span class=\"o\">(</span><span class=\"n\">Tactic.evalTactic</span> <span class=\"n\">baseConv</span><span class=\"o\">)</span>\n\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">lhs'</span><span class=\"o\">,</span><span class=\"n\">prf</span><span class=\"o\">)</span> <span class=\"bp\">←</span>\n      <span class=\"n\">withLocalDeclD</span> <span class=\"bp\">`</span><span class=\"n\">n'</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Nat</span> <span class=\"o\">[])</span> <span class=\"k\">fun</span> <span class=\"n\">n'</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"n\">withLocalDeclD</span> <span class=\"bp\">`</span><span class=\"n\">xₙ</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">lhs</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">xₙ'</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"n\">withLocalDeclD</span> <span class=\"bp\">`</span><span class=\"n\">eq</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkEq</span> <span class=\"o\">(</span><span class=\"n\">lhsFun.beta</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">n'</span><span class=\"o\">])</span> <span class=\"n\">xₙ'</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">eqₙ'</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n\n        <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">xSucc</span><span class=\"o\">,</span> <span class=\"n\">eqSucc</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">lhsFun.beta</span> <span class=\"bp\">#</span><span class=\"o\">[(</span><span class=\"bp\">←</span> <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">Nat.succ</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">n'</span><span class=\"o\">])])</span> <span class=\"o\">(</span><span class=\"n\">Tactic.evalTactic</span> <span class=\"n\">succConv</span><span class=\"o\">)</span>\n\n        <span class=\"k\">let</span> <span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"n\">Expr.lam</span> <span class=\"n\">default</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">lhs</span><span class=\"o\">)</span> <span class=\"n\">default</span>\n        <span class=\"k\">let</span> <span class=\"n\">base</span> <span class=\"o\">:=</span> <span class=\"n\">x₀</span>\n        <span class=\"k\">let</span> <span class=\"n\">succ</span> <span class=\"bp\">←</span> <span class=\"n\">mkLambdaFVars</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">n'</span><span class=\"o\">,</span><span class=\"n\">xₙ'</span><span class=\"o\">]</span> <span class=\"n\">xSucc</span>\n        <span class=\"k\">let</span> <span class=\"n\">recDef</span> <span class=\"bp\">←</span> <span class=\"n\">mkLambdaFVars</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">n'</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkAppOptM</span> <span class=\"bp\">``</span><span class=\"n\">Nat.recOn</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">motive</span><span class=\"o\">,</span> <span class=\"n\">n'</span><span class=\"o\">,</span> <span class=\"n\">base</span><span class=\"o\">,</span> <span class=\"n\">succ</span><span class=\"o\">])</span>\n\n        <span class=\"k\">let</span> <span class=\"n\">motive</span> <span class=\"bp\">←</span> <span class=\"n\">mkLambdaFVars</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">n'</span><span class=\"o\">]</span> <span class=\"o\">((</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">eqₙ'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">replaceFVar</span> <span class=\"n\">xₙ'</span> <span class=\"o\">(</span><span class=\"n\">recDef.beta</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">n'</span><span class=\"o\">]))</span>\n        <span class=\"n\">withLocalDeclD</span> <span class=\"bp\">`</span><span class=\"n\">eq</span> <span class=\"o\">(</span><span class=\"n\">motive.beta</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">n'</span><span class=\"o\">])</span> <span class=\"k\">fun</span> <span class=\"n\">eqₙ''</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n        <span class=\"k\">let</span> <span class=\"n\">base</span> <span class=\"o\">:=</span> <span class=\"n\">eq₀</span>\n        <span class=\"k\">let</span> <span class=\"n\">succ</span> <span class=\"bp\">←</span> <span class=\"n\">mkLambdaFVars</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">n'</span><span class=\"o\">,</span><span class=\"n\">eqₙ''</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">eqSucc.replaceFVars</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">xₙ'</span><span class=\"o\">,</span><span class=\"n\">eqₙ''</span><span class=\"o\">]</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">recDef.beta</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">n'</span><span class=\"o\">],</span> <span class=\"n\">eqₙ''</span><span class=\"o\">])</span>\n        <span class=\"k\">let</span> <span class=\"n\">recProof</span> <span class=\"bp\">←</span> <span class=\"n\">mkAppOptM</span> <span class=\"bp\">``</span><span class=\"n\">Nat.recOn</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">motive</span><span class=\"o\">,</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"n\">base</span><span class=\"o\">,</span><span class=\"n\">succ</span><span class=\"o\">]</span>\n\n        <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">recDef.beta</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">],</span><span class=\"n\">recProof</span><span class=\"o\">)</span>\n\n    <span class=\"n\">updateLhs</span> <span class=\"n\">lhs'</span> <span class=\"n\">prf</span>\n\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">thm1</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">n.succ</span> <span class=\"bp\">+</span> <span class=\"n\">n.succ</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Nat.recOn</span> <span class=\"n\">n</span> <span class=\"mi\">0</span> <span class=\"k\">fun</span> <span class=\"n\">n'</span> <span class=\"n\">xₙ</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">xₙ</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">lhs</span>\n    <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">thm1</span><span class=\"o\">,</span><span class=\"n\">eq</span><span class=\"o\">])</span>\n</code></pre></div>\n</div></div>\n<p>Unfortunately it produces an error <code>(kernel) declaration has free variables '_example'</code>. What did I do wrong?</p>\n<p>Also compiler can't work with <code>Nat.recOn</code>, what should I do to produce executable code? How can I generalize this to any inductive type?</p>",
        "id": 422035696,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708196978
    },
    {
        "content": "<p>Check out <code>compile_inductive%</code> in mathlib. It's used to autogenerate compiled definitions for recursors, and for example there's <code>compile_inductive% Nat</code> already in Mathlib.Util.CompileInductive</p>",
        "id": 422035877,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708197151
    },
    {
        "content": "<p>This is very nice! I just include that file and I can eval <code>#eval (Nat.recOn (motive:=fun _ =&gt; Nat) 10 0 fun n' xₙ =&gt; xₙ + 2)</code></p>",
        "id": 422036135,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708197441
    },
    {
        "content": "<p>I found the mistake, instead of <code>replaceFVars #[xₙ',eqₙ'']</code> there should be <code>replaceFVars #[xₙ',eqₙ']</code> and the kernel error is gone.</p>",
        "id": 422039816,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708201075
    }
]