[
    {
        "content": "<p>Just started playing with Lean 4, with some but not much experience with Lean 3. I notice that the new proof environment automatically makes a number of variable definitions for things like instances or implicits; I also notice that the variable names aren't actually valid tokens, so they can't be invoked. I can generally define my own copy, but then I have my own copy of, say, the typeclass instance for a Category, and the compiler needs me to prove something with reference to its own, automatically generated instance.</p>",
        "id": 421368714,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1707884926
    },
    {
        "content": "<p>I assume I'm doing something wrong, but what?</p>",
        "id": 421368721,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1707884934
    },
    {
        "content": "<p>Concrete example: I'm implementing bits of CategoryTheory for practice.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Category.Init</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.Quiver.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.PPWithUniv</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Common</span>\n\n\n<span class=\"kd\">universe</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CategoryTheory</span>\n\n<span class=\"c1\">--Base scaffolding is copypasta'd from mathlib</span>\n\n  <span class=\"kd\">@[</span><span class=\"n\">pp_with_univ</span><span class=\"kd\">]</span>\n  <span class=\"kd\">class</span> <span class=\"n\">CategoryStruct</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Quiver.</span><span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">obj</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n    <span class=\"sd\">/--Axiom: Identity-/</span>\n    <span class=\"n\">id</span><span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">,</span> <span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">X</span>\n    <span class=\"sd\">/--Axiom: Composition of morphisms, written f ‚â´ g-/</span>\n    <span class=\"n\">comp</span><span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span><span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Z</span><span class=\"o\">)</span>\n\n  <span class=\"n\">initialize_simps_projections</span> <span class=\"n\">CategoryStruct</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">toQuiver_Hom</span><span class=\"o\">)</span>\n\n  <span class=\"sd\">/--Notation-/</span>\n  <span class=\"n\">scoped</span> <span class=\"kd\">notation</span> <span class=\"s2\">\"ùüô\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">CategoryStruct.id</span>\n  <span class=\"n\">scoped</span> <span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">80</span> <span class=\"s2\">\" ‚â´ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">CategoryStruct.comp</span>\n\n  <span class=\"kd\">@[</span><span class=\"n\">pp_with_univ</span><span class=\"kd\">]</span>\n  <span class=\"kd\">class</span> <span class=\"n\">Category</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">CategoryStruct.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">obj</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n    <span class=\"n\">id_comp</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Y</span><span class=\"o\">),</span> <span class=\"mi\">ùüô</span> <span class=\"n\">X</span> <span class=\"bp\">‚â´</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f</span>\n    <span class=\"n\">comp_id</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Y</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"bp\">‚â´</span> <span class=\"mi\">ùüô</span> <span class=\"n\">Y</span> <span class=\"bp\">=</span> <span class=\"n\">f</span>\n    <span class=\"n\">assoc</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">{</span><span class=\"n\">W</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Z</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">‚â´</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">‚â´</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">‚â´</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">‚â´</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n  <span class=\"n\">initialize_simps_projections</span> <span class=\"n\">Category</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">toCategoryStruct</span><span class=\"o\">)</span>\n\n  <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">Category.id_comp</span> <span class=\"n\">Category.comp_id</span> <span class=\"n\">Category.assoc</span>\n  <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">trans</span><span class=\"o\">]</span> <span class=\"n\">CategoryStruct.comp</span>\n\n  <span class=\"n\">abbrev</span> <span class=\"n\">LargeCategory</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span>\n  <span class=\"n\">abbrev</span> <span class=\"n\">SmallCategory</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">C</span>\n\n  <span class=\"kn\">section</span>\n\n  <span class=\"kd\">instance</span> <span class=\"n\">UnitCategoryStruct</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Unique</span> <span class=\"n\">Œ±</span><span class=\"o\">]:</span> <span class=\"n\">CategoryStruct</span> <span class=\"n\">Œ±</span> <span class=\"n\">where</span>\n    <span class=\"n\">Hom</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">‚Ü¶</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span> <span class=\"bp\">//</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">id</span><span class=\"o\">}</span>\n    <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">_</span> <span class=\"bp\">‚Ü¶</span> <span class=\"o\">‚ü®</span><span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©</span>\n    <span class=\"n\">comp</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">‚Ü¶</span> <span class=\"o\">‚ü®</span><span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©</span>\n\n  <span class=\"kd\">instance</span> <span class=\"n\">UnitCategory</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Unique</span> <span class=\"n\">Œ±</span><span class=\"o\">]:</span> <span class=\"n\">Category</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">UnitCategoryStruct</span> <span class=\"n\">Œ±</span> <span class=\"k\">with</span>\n    <span class=\"n\">id_comp</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">‚Ü¶</span> <span class=\"kd\">by</span>\n      <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Unique.eq_default</span> <span class=\"n\">X</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">Unique.default_eq</span> <span class=\"n\">Y</span>\n      <span class=\"n\">subst</span> <span class=\"n\">h</span>\n      <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">ùüô</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 421369002,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1707885135
    },
    {
        "content": "<p>At the end of that instance-in-progress, Lean reports a state that contains the variable <code>src‚úù: CategoryStruct.{u, u} Œ± := UnitCategoryStruct Œ±</code>. I need to prove <code>id_comp</code> with reference to <code>src‚úù</code>'s definition of <code>Hom X Y</code>; but I don't know how to <em>access</em> that definition, so I'm stuck. I could define my own <code>src: CategoryStruct.{u, u} Œ± := UnitCategoryStruct Œ±</code>, but proving <code>id_comp</code> against <code>src.Hom</code> does not prove <code>id_comp</code> against <code>src‚úù.Hom</code>.</p>",
        "id": 421369154,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1707885279
    },
    {
        "content": "<p>(I ended up solving this specific problem by realizing that there was a good reason the mathlib definition does the proof of the composition lemmas as defaults in the original <code>Category</code> definition and bypassing the problem entirely that way; but I'd still like to have an answer here in case it comes up again. Unless that <em>is</em> the standard fix?)</p>",
        "id": 421369904,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1707885924
    },
    {
        "content": "<p>Generally, you should name any variables that you need to refer to. This is part of Lean's macro hygiene features; if you didn't explicitly give it a name, you shouldn't be accessing it by name later on, since that would make your proofs break if the autogenerated names ever changed in the future.</p>\n<p>Most tactics that introduce hypotheses have a way to name hypotheses, e.g. <code>case</code> takes a list of hypothesis names. You can also use the <code>next a b c =&gt;</code> tactic to name the most recent inaccessible hypotheses (in this case giving them names <code>a</code>, <code>b</code>, <code>c</code> in that order). You can also use the <code>rename</code> tactic to \"look up\" an inaccessible value by its type and rename it.</p>",
        "id": 421382500,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707894503
    },
    {
        "content": "<blockquote>\n<p>Most tactics that introduce hypotheses have a way to name hypotheses, e.g. case takes a list of hypothesis names. </p>\n</blockquote>\n<p>You say that, but if <code>Foo</code> is a structure with multiple fields, <code>cases foo with | h</code> gives me a red squiggle under <code>h</code> with the error <code>invalid aIternative name 'h'</code> (sic) no matter what I use for <code>h</code>; presumably there's a way of providing a list of a name for each field but it's not clear how?</p>",
        "id": 421563420,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1707961052
    },
    {
        "content": "<p>Ah, I see. <code>mk</code> to match the constructor case, and then names for the variables. Still doesn't let me access inherited fields, though...</p>",
        "id": 421566253,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1707963089
    },
    {
        "content": "<p>This isn't exactly your question, but the standard way to add an instance for a new class that extends a class you already added an instance for is with <code>where</code>. This way there will only be one instance of <code>UnitCategoryStruct</code> in scope, the one registered in the previous declaration.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">UnitCategory</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Unique</span> <span class=\"n\">Œ±</span><span class=\"o\">]:</span> <span class=\"n\">Category</span> <span class=\"n\">Œ±</span> <span class=\"n\">where</span>\n  <span class=\"n\">id_comp</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">‚Ü¶</span> <span class=\"kd\">by</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Unique.eq_default</span> <span class=\"n\">X</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">Unique.default_eq</span> <span class=\"n\">Y</span>\n    <span class=\"n\">subst</span> <span class=\"n\">h</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">ùüô</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"n\">comp_id</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">assoc</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 421566661,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1707963393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"359992\">Robert Maxton</span> <a href=\"#narrow/stream/270676-lean4/topic/Accessing.2Fmaking.20use.20of.20automatic.20variables/near/421563420\">said</a>:</p>\n<blockquote>\n<p>presumably there's a way of providing a list of a name for each field but it's not clear how?</p>\n</blockquote>\n<p>for structures you can use lots of different syntaxes in a tactic block:</p>\n<ul>\n<li><code>match myVal with | {field1, field2} =&gt; ...</code> (whitespace sensitive)</li>\n<li><code>let {field1, field2} := myVal</code></li>\n<li><code>rcases myVal with \\&lt; field1, field2 \\&gt;</code></li>\n<li><code>cases myVal; case mk field 1 field2 =&gt; ...</code></li>\n</ul>",
        "id": 421605375,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707986797
    },
    {
        "content": "<p>you might wonder why so many different notations for the same thing, but they all have their place...</p>",
        "id": 421605485,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707986838
    }
]