[
    {
        "content": "<p>I'm getting a weird error which I'm not really sure what to do about it.<br>\nIt seems that the function <code>indexOf_eq_length</code> is expecting certain generated instance, and does not accept instBEqProd. Is there some way I could work around this limitation?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">List.indexOf_eq_length.mp</span> <span class=\"n\">hh</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">hh</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">List.indexOf</span> <span class=\"n\">A</span> <span class=\"n\">instBEqProd</span> <span class=\"n\">i</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">List.length</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">List.indexOf</span> <span class=\"n\">A</span> <span class=\"n\">instBEq</span> <span class=\"n\">i</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">List.length</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>Here's the MWE I was able to get:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.List.Basic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">CompletionOrder'</span> <span class=\"n\">where</span>\n  <span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">A</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n  <span class=\"n\">l_all_inst</span><span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span>\n\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">all_elements_are_in_completion_order</span> <span class=\"o\">(</span><span class=\"n\">ex</span><span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">CompletionOrder'</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">):</span> <span class=\"bp\">∀</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">ex.l.indexOf</span> <span class=\"n\">i</span> <span class=\"bp\">!=</span> <span class=\"n\">ex.l.length</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span> <span class=\"n\">i</span>\n  <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:=</span> <span class=\"n\">ex.l_all_inst</span> <span class=\"n\">i</span>\n  <span class=\"n\">generalize</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">ex.l</span> <span class=\"bp\">=</span> <span class=\"n\">l</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h'</span>\n  <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">hh</span>\n  <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">l.indexOf_eq_length</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:=</span> <span class=\"n\">i</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">hh</span>\n</code></pre></div>",
        "id": 431849759,
        "sender_full_name": "Zhuanhao Wu",
        "timestamp": 1712548615
    },
    {
        "content": "<p>Oof, that's a tricky one.  In the following, <code>convert hh</code> is <em>supposed</em> to work to handle this issue of there being multiple BEq instances involved, but it's having a hard time synthesizing the necessary <code>LawfulBEq</code> instances.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">all_elements_are_in_completion_order</span> <span class=\"o\">(</span><span class=\"n\">ex</span><span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">CompletionOrder'</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">):</span> <span class=\"bp\">∀</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">ex.l.indexOf</span> <span class=\"n\">i</span> <span class=\"bp\">!=</span> <span class=\"n\">ex.l.length</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span> <span class=\"n\">i</span>\n  <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:=</span> <span class=\"n\">ex.l_all_inst</span> <span class=\"n\">i</span>\n  <span class=\"n\">generalize</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">ex.l</span> <span class=\"bp\">=</span> <span class=\"n\">l</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h'</span>\n  <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">hh</span>\n  <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">l.indexOf_eq_length</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:=</span> <span class=\"n\">i</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mp</span>\n  <span class=\"n\">convert</span> <span class=\"n\">hh</span>\n  <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">lawful_beq_subsingleton</span> <span class=\"n\">A</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">instLawfulBEqInstBEq</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h'</span>\n</code></pre></div>",
        "id": 431852202,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712549271
    },
    {
        "content": "<p>(There might be a way to back up and try proving this a different way to avoid this obstacle, but at least there's a way to plow through it.)</p>",
        "id": 431852408,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712549319
    },
    {
        "content": "<p>(In case you haven't seen <code>convert</code>, it's like <code>exact</code> but can handle differences between the expected type and the actual type. It tries to handle differences automatically, but anything it can't handle turns into a new goal.)</p>",
        "id": 431852642,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712549413
    },
    {
        "content": "<p>Right, it seems that going forward, (by using unfolding etc), I ended up having to show two styles of <code>match</code> are equivalent, and I don't think I want to spend time on it. So for now, I decided to use a <code>structure</code> that wraps things up, and use the generated <code>DecidableEq</code> instead</p>\n<p>Thank you!</p>",
        "id": 431857185,
        "sender_full_name": "Zhuanhao Wu",
        "timestamp": 1712552173
    },
    {
        "content": "<p>Something small that would help here is giving <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instBEq#doc\">docs#instBEq</a> a longer name</p>",
        "id": 431891321,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712564668
    },
    {
        "content": "<p>Perhaps <code>DecidableEq.toBEq</code></p>",
        "id": 431891426,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712564695
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Application.20type.20mismatch.20due.20to.20BEq.20instance.20of.20a.20Prod.20type/near/431891321\">said</a>:</p>\n<blockquote>\n<p>Something small that would help here is giving <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instBEq#doc\">docs#instBEq</a> a longer name</p>\n</blockquote>\n<p>Not sure if this is what you meant, but adding the following would work as well </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">instructionBEq</span> <span class=\"o\">:</span> <span class=\"n\">BEq</span> <span class=\"n\">prog.Instruction</span> <span class=\"o\">:=</span> <span class=\"n\">instBEq</span>\n</code></pre></div>",
        "id": 431967381,
        "sender_full_name": "Zhuanhao Wu",
        "timestamp": 1712581949
    },
    {
        "content": "<p>(And equivalently?) We can provide it explicity to the theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">all_elements_are_in_completion_order'</span> <span class=\"o\">(</span><span class=\"n\">ex</span><span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">CompletionOrder'</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">):</span> <span class=\"bp\">∀</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">List.indexOf</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">A</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">instBEq</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"n\">ex.l</span> <span class=\"bp\">!=</span> <span class=\"n\">ex.l.length</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span> <span class=\"n\">i</span>\n  <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:=</span> <span class=\"n\">ex.l_all_inst</span> <span class=\"n\">i</span>\n  <span class=\"n\">generalize</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">ex.l</span> <span class=\"bp\">=</span> <span class=\"n\">l</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h'</span>\n  <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">hh</span>\n  <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">l.indexOf_eq_length</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:=</span> <span class=\"n\">i</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">hh</span>\n  <span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 431967841,
        "sender_full_name": "Zhuanhao Wu",
        "timestamp": 1712582067
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Application.20type.20mismatch.20due.20to.20BEq.20instance.20of.20a.20Prod.20type/near/431891426\">said</a>:</p>\n<blockquote>\n<p>Perhaps <code>DecidableEq.toBEq</code></p>\n</blockquote>\n<p>I think it will be <code>instBEqOfDecidableEq</code> in the next Lean release at least.</p>",
        "id": 431981660,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712585920
    }
]