[
    {
        "content": "<p>I defined a simple U32 machine integer type below, with some synctactic sugar to easily define constants:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">U32</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"bp\">//</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"bp\">∧</span> <span class=\"n\">v</span> <span class=\"bp\">≤</span> <span class=\"mi\">4294967295</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- Notation for constants</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"s2\">\"#u32\"</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span> <span class=\"o\">⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">U32</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"bp\">#</span><span class=\"n\">u32</span>\n\n<span class=\"c1\">-- We have to introduce a different notation for match patterns</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"s2\">\"#pat\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Subtype.mk</span> <span class=\"n\">x</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_zero</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">U32</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"bp\">#</span><span class=\"n\">pat</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">is_zero</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">#</span><span class=\"n\">u32</span><span class=\"o\">)</span> <span class=\"c1\">-- true</span>\n<span class=\"k\">#eval</span> <span class=\"n\">is_zero</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">#</span><span class=\"n\">u32</span><span class=\"o\">)</span> <span class=\"c1\">-- false</span>\n</code></pre></div>\n<p>I need to introduce two notations: <code>#u32</code> for the \"regular\" constants, and <code>#pat</code> for the case where we are inside a pattern. Is there a way of having a single notation, but which gets elaborated to different terms depending on whether we are inside a match pattern or not?</p>",
        "id": 425354665,
        "sender_full_name": "Son Ho",
        "timestamp": 1709831322
    },
    {
        "content": "<p>Should be doable, but it's not entirely trivial. You'd have to define a custom elaborator (<code>elab</code>). This operates in the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Term.TermElabM#doc\">docs#Lean.Elab.Term.TermElabM</a> monad, which gives you the info whether you're in a pattern or not. I can take a stab at this later.</p>",
        "id": 425355810,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1709831682
    },
    {
        "content": "<p>That would be great, thanks! :)</p>",
        "id": 425355872,
        "sender_full_name": "Son Ho",
        "timestamp": 1709831703
    },
    {
        "content": "<p>But I should be able to manage provided I have a few pointers ;)</p>",
        "id": 425355970,
        "sender_full_name": "Son Ho",
        "timestamp": 1709831737
    },
    {
        "content": "<p>By the way, Lean 4 comes with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UInt32#doc\">docs#UInt32</a>, and it has special runtime support.</p>",
        "id": 425356766,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709831993
    },
    {
        "content": "<p>You don't really need <code>#u32</code>, if you're ok with wraparound on overflow.</p>\n<p>In patterns, you can just write <code>0</code> rather than <code>0#pat</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Notation for constants</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"s2\">\"#u32\"</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(⟨</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span> <span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">UInt32</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">UInt32</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"bp\">#</span><span class=\"n\">u32</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_zero</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">UInt32</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">is_zero</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">#</span><span class=\"n\">u32</span><span class=\"o\">)</span> <span class=\"c1\">-- true</span>\n<span class=\"k\">#eval</span> <span class=\"n\">is_zero</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">#</span><span class=\"n\">u32</span><span class=\"o\">)</span> <span class=\"c1\">-- false</span>\n</code></pre></div>",
        "id": 425357268,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709832139
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Different.20elaboration.20inside.2Foutside.20of.20match.20patterns/near/425356766\">said</a>:</p>\n<blockquote>\n<p>By the way, Lean 4 comes with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UInt32#doc\">docs#UInt32</a>, and it has special runtime support.</p>\n</blockquote>\n<p>Yes, I'm aware of this, but it doesn't fit my use case.<br>\nThe example I show above is adapted from the <a href=\"https://github.com/AeneasVerif/aeneas\">Aeneas project</a> whose goal is to generate models of Rust programs for the purpose of verification. In Rust, overflows lead to panics, so we <em>do</em> need to model them by not wraping around (and using an error monad).</p>",
        "id": 425361901,
        "sender_full_name": "Son Ho",
        "timestamp": 1709833690
    },
    {
        "content": "<p>you should do this either by writing functions on <code>UInt32</code> with the desired (non-)wrapping behavior, or by newtype-wrapping <code>UInt32</code> so you can define what <code>+</code> etc do</p>",
        "id": 425362732,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709833983
    },
    {
        "content": "<p>Yes, but the example above is minimized: in practice I have to consider a whole family of machine integers, which include non-signed machine integers like i8 or i128, meaning I can't simply reuse a type like UInt32 or even Fin (the real definition I manipulate is parameterized by the bounds).</p>",
        "id": 425392047,
        "sender_full_name": "Son Ho",
        "timestamp": 1709844435
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/270676-lean4/topic/Different.20elaboration.20inside.2Foutside.20of.20match.20patterns/near/425355810\">said</a>:</p>\n<blockquote>\n<p>Should be doable, but it's not entirely trivial. You'd have to define a custom elaborator (<code>elab</code>). This operates in the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Term.TermElabM#doc\">docs#Lean.Elab.Term.TermElabM</a> monad, which gives you the info whether you're in a pattern or not. I can take a stab at this later.</p>\n</blockquote>\n<p>Doesn't look like this is possible actually. Lean analyses pattern <code>Syntax</code> <a href=\"https://github.com/leanprover/lean4/blob/ccac989ddab7aa0827c16f355c3cf305aa65fa8a/src/Lean/Elab/PatternVar.lean#L123\">here</a> and only allows certain <code>Syntax</code> in patterns. So macros work for patterns, but custom <code>elab</code>s generally don't. Here's how far I got:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Lean.Elab</span> <span class=\"n\">Lean.Elab.Term</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">U32</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"bp\">//</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"bp\">∧</span> <span class=\"n\">v</span> <span class=\"bp\">≤</span> <span class=\"mi\">4294967295</span> <span class=\"o\">}</span>\n\n<span class=\"n\">elab</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">num</span> <span class=\"n\">noWs</span> <span class=\"s2\">\"#u32\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"bp\">←</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">read</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inPattern</span> <span class=\"k\">then</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Subtype.mk</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"k\">else</span>\n    <span class=\"bp\">`</span><span class=\"o\">(⟨</span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">⟩)</span>\n  <span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">debug</span><span class=\"o\">]</span> <span class=\"s2\">\"before elabTerm\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">stx</span> <span class=\"bp\">$</span> <span class=\"n\">some</span> <span class=\"bp\">$</span> <span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">U32</span> <span class=\"o\">[]</span>\n  <span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">debug</span><span class=\"o\">]</span> <span class=\"s2\">\"after elabTerm\"</span>\n  <span class=\"n\">return</span> <span class=\"n\">e</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">U32</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"bp\">#</span><span class=\"n\">u32</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Elab.match</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.debug</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_zero</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">U32</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"bp\">#</span><span class=\"n\">u32</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">is_zero</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">#</span><span class=\"n\">u32</span><span class=\"o\">)</span> <span class=\"c1\">-- true</span>\n<span class=\"k\">#eval</span> <span class=\"n\">is_zero</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">#</span><span class=\"n\">u32</span><span class=\"o\">)</span> <span class=\"c1\">-- false</span>\n</code></pre></div>",
        "id": 425392257,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1709844495
    },
    {
        "content": "<p>Thanks for trying!<br>\nI had a look at the <a href=\"https://github.com/leanprover/lean4/blob/ccac989ddab7aa0827c16f355c3cf305aa65fa8a/src/Lean/Elab/PatternVar.lean#L123\">collect</a> function you pointed to and the fact that <code>_</code> terms are treated differently in patterns gave me the idea to use typeclasses. Reusing <a href=\"#narrow/stream/270676-lean4/topic/instance.20with.20tactic.20autoparam/near/343495807\">this</a>, I came up with the following (we solve the \"in bounds\" obligation by using a typeclass and <code>Decidable</code>: if outside a pattern Lean solves the typeclass, otherwise it treats it as a <code>_</code> pattern):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Lean.Elab</span> <span class=\"n\">Lean.Elab.Term</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">U32</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"bp\">//</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"bp\">∧</span> <span class=\"n\">v</span> <span class=\"bp\">≤</span> <span class=\"mi\">4294967295</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">InBounds</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"bp\">∧</span> <span class=\"n\">v</span> <span class=\"bp\">≤</span> <span class=\"mi\">4294967295</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">match_pattern</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">mkU32</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">InBounds</span> <span class=\"n\">v</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">U32</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">InBounds.h</span> <span class=\"o\">⟩</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">DecideInBounds</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">isTrue</span> <span class=\"o\">:</span> <span class=\"n\">p</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">DecideInBounds</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">isTrue</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">DecideInBounds.mk</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">DecideInBounds</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"bp\">∧</span> <span class=\"n\">v</span> <span class=\"bp\">≤</span> <span class=\"mi\">4294967295</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">InBounds</span> <span class=\"n\">v</span> <span class=\"n\">where</span>\n  <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">DecideInBounds.isTrue</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"s2\">\"#u32\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mkU32</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_zero</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">U32</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"bp\">#</span><span class=\"n\">u32</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">is_zero</span> <span class=\"mi\">0</span><span class=\"bp\">#</span><span class=\"n\">u32</span> <span class=\"c1\">-- true</span>\n<span class=\"k\">#eval</span> <span class=\"n\">is_zero</span> <span class=\"mi\">1</span><span class=\"bp\">#</span><span class=\"n\">u32</span> <span class=\"c1\">-- false</span>\n</code></pre></div>",
        "id": 425455284,
        "sender_full_name": "Son Ho",
        "timestamp": 1709879056
    },
    {
        "content": "<p>Very clever. I just played around a bit with the code and discovered that it breaks when <code>InBound</code> is a <code>Prop</code> rather than (implicitly) a <code>Type</code>. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 425494581,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1709895353
    },
    {
        "content": "<p>Ok, that's interesting <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 425497764,
        "sender_full_name": "Son Ho",
        "timestamp": 1709896479
    }
]