[
    {
        "content": "<p>I instantiated a complete lattice for a pointwise but non-dependent defined type using <code>Pi.instCompleteLattice</code>. This worked nicely. However, now that I would like to prove something on it, I get a weird dependent-looking type in the proofview. I think this is only cosmetic, it still bugs me, however. Is there maybe an easy solution to make the type look neat?</p>\n<p>An  MWE looks like this, where <code>b</code> has the weird dependent type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">ENNReal</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">cl</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CompleteLattice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">myType</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Pi</span><span class=\"bp\">.</span><span class=\"n\">instCompleteLattice</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">sideCondition</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s₁</span><span class=\"w\"> </span><span class=\"n\">s₂</span><span class=\"w\"> </span><span class=\"n\">s₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myMul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myType</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myType</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">sSup</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">s₁</span><span class=\"w\"> </span><span class=\"n\">s₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sideCondition</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">s₁</span><span class=\"w\"> </span><span class=\"n\">s₂</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">s₁</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">s₂</span><span class=\"o\">}</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P₁</span><span class=\"w\"> </span><span class=\"n\">P₂</span><span class=\"w\"> </span><span class=\"n\">Q₁</span><span class=\"w\"> </span><span class=\"n\">Q₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myType</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hP</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P₁</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">P₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hQ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q₁</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">Q₂</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">myMul</span><span class=\"w\"> </span><span class=\"n\">P₁</span><span class=\"w\"> </span><span class=\"n\">Q₁</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">myMul</span><span class=\"w\"> </span><span class=\"n\">P₂</span><span class=\"w\"> </span><span class=\"n\">Q₂</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">sSup_le</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 441006610,
        "sender_full_name": "Ira Fesefeldt",
        "timestamp": 1716890963
    },
    {
        "content": "<p>You can do <code>dsimp at b</code> to see that <code>b : ENNReal</code> and then you can change the <code>intro</code> line to <code>intro (b : ENNReal)</code> if you like.</p>",
        "id": 441009580,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1716892153
    },
    {
        "content": "<p>But assuming you want to do more <code>intro</code>s you might want to instead do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">s₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s₂</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>which just removes <code>b</code> from the picture completely.</p>",
        "id": 441009913,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1716892279
    },
    {
        "content": "<p>This seems to be a problem with the definitions of <code>Pi.preorder</code> <code>Pi.partialOrder</code> <code>Pi.instSemilatticeSup</code> <code>Pi.instLattice</code> <code>Pi.instCompleteLattice</code>. They all contain terms of the form <code>fun i =&gt; a i</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">CompleteLattice</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">explicit</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">def Pi.partialOrder.{u_2, u_1} : {ι : Type u_1} →</span>\n<span class=\"cm\">  {π : ι → Type u_2} → [inst : (i : ι) → PartialOrder (π i)] → PartialOrder ((i : ι) → π i) :=</span>\n<span class=\"cm\">fun {ι} {π} [inst : (i : ι) → PartialOrder (π i)] =&gt;</span>\n<span class=\"cm\">  let __spread.0 := @Pi.preorder ι (fun i =&gt; π i) fun i =&gt; @PartialOrder.toPreorder (π i) (inst i);</span>\n<span class=\"cm\">  @PartialOrder.mk ((i : ι) → π i) __spread.0 ⋯</span>\n<span class=\"cm\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">Pi</span><span class=\"bp\">.</span><span class=\"n\">partialOrder</span>\n</code></pre></div>",
        "id": 441305687,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1717012360
    },
    {
        "content": "<p>Here's a minimal example of this going badly in a definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">isDefEq</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)]</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Pi</span><span class=\"bp\">.</span><span class=\"n\">hasLe</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">inst</span>\n</code></pre></div>\n<p>The second <code>_</code> gets instantiated as <code>fun i =&gt; α i</code>, instead of <code>α</code>.<br>\nThe subset of the trace that instantiates the metavariable is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">✅</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">30</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">      </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">30</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">assignable</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">nonassignable</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">✅</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"m\">27</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n<span class=\"w\">        </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">✅</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">ι</span>\n<span class=\"w\">        </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">✅</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"m\">27</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span>\n</code></pre></div>\n<p>I think this is an inefficiency in the unification algorithm, not being able to properly deal with the unification problem <code>?m.30 i =?= α i</code>.</p>",
        "id": 441321123,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1717018124
    },
    {
        "content": "<p>I've had a crack at fixing this problem, and made an issue for it (<a href=\"https://github.com/leanprover/lean4/pull/4386\">lean4#4386</a>).</p>\n<p>I made a modification to the <code>mkLambdaFVars</code> function, adding a <code>etaReduce : Bool</code> parameter that determines whether a new lambda of the form <code>fun x =&gt; f x</code> should instead become <code>f</code>. I then set this option to true at <code>isDefEq</code> when processing metavariable assignments.</p>\n<p>Quite a number of proof in mathlib broke. Many of these involve removing a now unnecessary <code>simp only</code>. In other cases, a simp or rewrite doesn't work anymore because it relied on the bound variable that existed due to the eta expanded form, such as a <code>simp_rw [mul_comm]</code> that was used to rewrite <code>fun x =&gt; 2*x</code>, but now this term has turned into <code>HMul.hMul 2</code>. There were two strange cases where I had to replace a proof <code>h</code> with <code>by exact h</code>, because this changes the order in which metavariables are instantiated, avoiding a weird error.</p>\n<p>After fixing all the proofs, the change leads to a 0.6% improvement in build instructions (<a href=\"https://github.com/leanprover-community/mathlib4/pull/13601\">#13601</a>). Most notably, <code>Mathlib.Algebra.DirectLimit</code>, previously a top 50 slowest file, has sped up by 40%.</p>",
        "id": 443409570,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1717811462
    },
    {
        "content": "<p>After looking more closely at <code>Mathlib.Algebra.DirectLimit</code>, my best guess for where the dramatic speedup comes from is that there are unifications where the two expressions are the same big complicated expression, but on one side <code>G</code> has been replaced with <code>fun i =&gt; G i</code>.</p>",
        "id": 443423976,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1717821875
    }
]