[
    {
        "content": "<p>Hello! Suppose I'm working with a structure where some fields' types depend on others, e.g.:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">nfold</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">PUnit</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">n</span>\n<span class=\"kd\">structure</span> <span class=\"n\">L</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"n\">len</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n  <span class=\"n\">elems</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">len</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nfold.nil</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"o\">()</span>\n<span class=\"kd\">def</span> <span class=\"n\">L.nil</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">len</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">elems</span> <span class=\"o\">:=</span> <span class=\"n\">nfold.nil</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nfold.append</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.zero</span><span class=\"o\">,</span> <span class=\"o\">(),</span> <span class=\"n\">ys</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ys</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">xs</span><span class=\"o\">),</span> <span class=\"n\">ys</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">nfold.append</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">L.append</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">len</span> <span class=\"o\">:=</span> <span class=\"n\">ys.len</span> <span class=\"bp\">+</span> <span class=\"n\">xs.len</span>\n  <span class=\"o\">,</span> <span class=\"n\">elems</span> <span class=\"o\">:=</span> <span class=\"n\">nfold.append</span> <span class=\"n\">xs.elems</span> <span class=\"n\">ys.elems</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>In general, how does one prove propositional equality theorems about such structures? For example, I can prove:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">L.nil_append</span> <span class=\"o\">{</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">L.append</span> <span class=\"n\">L.nil</span> <span class=\"n\">xs</span> <span class=\"bp\">=</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>because this equality holds definitionally, by the happenstance of all the relevant functions being defined recursively on the right argument. However the converse is trickier:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">L.append_nil</span> <span class=\"o\">{</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">L.append</span> <span class=\"n\">xs</span> <span class=\"n\">L.nil</span> <span class=\"bp\">=</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Ultimately I want to proceed by induction on the length, but the dependent types are getting in the way.<br>\nIn a HoTT setting I would set up an extensionality lemma for the dependent pair involving a transport, and also formulate the append/nil lemma for <code>nfold</code> in terms of a transport as well, and those two pieces make up the puzzle:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">L.ext</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">l1</span> <span class=\"bp\">=</span> <span class=\"n\">l2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">▸</span> <span class=\"n\">e1</span> <span class=\"bp\">=</span> <span class=\"n\">e2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">L.mk</span> <span class=\"n\">l1</span> <span class=\"n\">e1</span> <span class=\"bp\">=</span> <span class=\"n\">L.mk</span> <span class=\"n\">l2</span> <span class=\"n\">e2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">q</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">nfold.append_nil</span> <span class=\"o\">{</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Nat.zero_add</span> <span class=\"n\">n</span> <span class=\"bp\">▸</span> <span class=\"n\">nfold.append</span> <span class=\"n\">xs</span> <span class=\"n\">nfold.nil</span> <span class=\"bp\">=</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nfold</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">xs</span>\n      <span class=\"n\">cases</span> <span class=\"n\">xs</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nfold.append</span><span class=\"o\">]</span>\n      <span class=\"c1\">-- α: Type</span>\n      <span class=\"c1\">-- n: ℕ</span>\n      <span class=\"c1\">-- ih: ∀ {xs : nfold α n}, (_ : 0 + n = n) ▸ append xs nil = xs</span>\n      <span class=\"c1\">-- x: α</span>\n      <span class=\"c1\">-- xs: nfold α n</span>\n      <span class=\"c1\">-- ⊢ (_ : 0 + Nat.succ n = Nat.succ n) ▸ (x, append xs nil) = (x, xs)</span>\n      <span class=\"gr\">sorry</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">L.append_nil</span> <span class=\"o\">{</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">L.append</span> <span class=\"n\">xs</span> <span class=\"n\">L.nil</span> <span class=\"bp\">=</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">L.ext</span>\n  <span class=\"n\">apply</span> <span class=\"n\">nfold.append_nil</span>\n</code></pre></div>\n<p>However to prove the inductive step I would need to use a bunch of facts about how transporting (▸) interacts with other types, based on the \"motive\" being used in the transport (e.g. Coq-HoTT calls these <code>transport_prod</code>, <code>transport_const</code>, etc). I wasn't able to find such a collection of facts in mathlib4 though. I could certainly implement them by hand but that seems counterproductive.</p>\n<p>When using <code>simp</code> on an equality of <code>L</code>'s, it seems to suggest that I <code>HEq</code> is the way forward:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">L.append_nil</span> <span class=\"o\">{</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">L.append</span> <span class=\"n\">xs</span> <span class=\"n\">L.nil</span> <span class=\"bp\">=</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">xs</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"n\">len</span> <span class=\"n\">elems</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">L.append</span><span class=\"o\">,</span> <span class=\"n\">L.nil</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- α: Type</span>\n  <span class=\"c1\">-- len: ℕ</span>\n  <span class=\"c1\">-- elems: nfold α len</span>\n  <span class=\"c1\">-- ⊢ HEq (nfold.append elems nfold.nil) elems</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>With <code>HEq</code> I can do pretty much the same thing: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">L.ext</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">l1</span> <span class=\"bp\">=</span> <span class=\"n\">l2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">e1</span> <span class=\"n\">e2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">L.mk</span> <span class=\"n\">l1</span> <span class=\"n\">e1</span> <span class=\"bp\">=</span> <span class=\"n\">L.mk</span> <span class=\"n\">l2</span> <span class=\"n\">e2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">q</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">nfold.append_nil</span> <span class=\"o\">{</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"o\">(</span><span class=\"n\">nfold.append</span> <span class=\"n\">xs</span> <span class=\"n\">nfold.nil</span><span class=\"o\">)</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nfold</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">xs</span>\n      <span class=\"n\">cases</span> <span class=\"n\">xs</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nfold.append</span><span class=\"o\">]</span>\n      <span class=\"c1\">-- α: Type</span>\n      <span class=\"c1\">-- n: ℕ</span>\n      <span class=\"c1\">-- ih: ∀ {xs : nfold α n}, HEq (append xs nil) xs</span>\n      <span class=\"c1\">-- x: α</span>\n      <span class=\"c1\">-- xs: nfold α n</span>\n      <span class=\"c1\">-- ⊢ HEq (x, append xs nil) (x, xs)</span>\n      <span class=\"gr\">sorry</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">L.append_nil</span> <span class=\"o\">{</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">L.append</span> <span class=\"n\">xs</span> <span class=\"n\">L.nil</span> <span class=\"bp\">=</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">L.ext</span>\n  <span class=\"bp\">.</span> <span class=\"n\">apply</span> <span class=\"n\">Nat.zero_add</span>\n  <span class=\"bp\">.</span> <span class=\"n\">apply</span> <span class=\"n\">nfold.append_nil</span>\n</code></pre></div>\n<p>But once again the inductive step relies on a theorem about <code>HEq</code> that I cannot find in mathlib4.</p>\n<p>What is the \"normal\" way to manipulate such dependent equalities?</p>",
        "id": 411470828,
        "sender_full_name": "mniip",
        "timestamp": 1704511955
    },
    {
        "content": "<p>I think the only way is to do manual generalizations at just the right moment to avoid any <code>HEq</code>s popping up :)</p>\n<p>This is very difficult, and painful, to do in general. I think that's just the reality of working with proof irrelevance; it's nice until it's not. </p>\n<p>The way we usually deal with this is to avoid as many dependent types as possible, and to build specialized \"cast\" functions for those datatypes which must appear in dependently typed situations (see eg <code>Fin.cast</code>).</p>",
        "id": 411489025,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1704531143
    },
    {
        "content": "<p>(I'm sure the proof wizards can finish your proof, but I tried to find the right generalization for a while and couldn't come up with one that worked <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span>)</p>",
        "id": 411489101,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1704531225
    },
    {
        "content": "<blockquote>\n<p>avoid as many dependent types as possible</p>\n</blockquote>\n<p>Yeah I wish I could do that. My main type looks something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Bazaar.Indexed</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">length</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n  <span class=\"n\">elements</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">length</span>\n  <span class=\"n\">continuation</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">β</span> <span class=\"n\">length</span> <span class=\"bp\">→</span> <span class=\"n\">τ</span>\n</code></pre></div>\n<blockquote>\n<p>build specialized \"cast\" functions for those datatypes which must appear in dependently typed situations (see e.g. Fin.cast)</p>\n</blockquote>\n<p>But <code>Fin.cast</code> is no different from a <code>▸</code> in that you have to prove lemmas about how it commutes with other data.</p>",
        "id": 411527626,
        "sender_full_name": "mniip",
        "timestamp": 1704566194
    },
    {
        "content": "<p>No it is different because <code>▸</code> can rewrite other things than just the indices you would like to rewrite.</p>",
        "id": 411528110,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704566552
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"678686\">@mniip</span> Here's how I might set this up. It's annoying having to flesh out the API for <code>cast</code>, but then you can avoid HEq</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Common</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">nfold</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nfold.cast</span> <span class=\"o\">(</span><span class=\"n\">elems</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">n'</span> <span class=\"o\">:=</span>\n  <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">elems</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">nfold.cast_cast</span> <span class=\"o\">(</span><span class=\"n\">elems</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">n'</span> <span class=\"bp\">=</span> <span class=\"n\">n''</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">elems.cast</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"n\">h'</span> <span class=\"bp\">=</span> <span class=\"n\">elems.cast</span> <span class=\"o\">(</span><span class=\"n\">h.trans</span> <span class=\"n\">h'</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">subst_vars</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">nfold.cast_rfl</span> <span class=\"o\">(</span><span class=\"n\">elems</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">elems.cast</span> <span class=\"n\">rfl</span> <span class=\"bp\">=</span> <span class=\"n\">elems</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nfold.append</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.zero</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">,</span> <span class=\"n\">ys</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ys</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">ys</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nfold.cons</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">xs.append</span> <span class=\"n\">ys</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">nfold.cons_cast</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">elems</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">nfold.cons</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">elems.cast</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">nfold.cons</span> <span class=\"n\">x</span> <span class=\"n\">elems</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">nfold.append_cast_left</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">xs.cast</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">append</span> <span class=\"n\">ys</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">xs.append</span> <span class=\"n\">ys</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">nfold.append_cast_right</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">xs.append</span> <span class=\"o\">(</span><span class=\"n\">ys.cast</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">xs.append</span> <span class=\"n\">ys</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">nfold.cons_append</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">nfold.cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">append</span> <span class=\"n\">ys</span> <span class=\"bp\">=</span> <span class=\"n\">nfold.cons</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">xs.append</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">L</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"n\">len</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n  <span class=\"n\">elems</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">len</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">L.nil</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">L.mk</span> <span class=\"mi\">0</span> <span class=\"n\">nfold.nil</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">L.ext</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">len</span> <span class=\"n\">len'</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">elems</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">len</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">elems'</span> <span class=\"o\">:</span> <span class=\"n\">nfold</span> <span class=\"n\">α</span> <span class=\"n\">len'</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hlen</span> <span class=\"o\">:</span> <span class=\"n\">len</span> <span class=\"bp\">=</span> <span class=\"n\">len'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">helems</span> <span class=\"o\">:</span> <span class=\"n\">elems.cast</span> <span class=\"n\">hlen</span> <span class=\"bp\">=</span> <span class=\"n\">elems'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">L.mk</span> <span class=\"n\">len</span> <span class=\"n\">elems</span> <span class=\"bp\">=</span> <span class=\"n\">L.mk</span> <span class=\"n\">len'</span> <span class=\"n\">elems'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">subst_vars</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">L.append</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">len</span> <span class=\"o\">:=</span> <span class=\"n\">ys.len</span> <span class=\"bp\">+</span> <span class=\"n\">xs.len</span>\n  <span class=\"n\">elems</span> <span class=\"o\">:=</span> <span class=\"n\">nfold.append</span> <span class=\"n\">xs.elems</span> <span class=\"n\">ys.elems</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">L.nil_append</span> <span class=\"o\">{</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">L.append</span> <span class=\"n\">L.nil</span> <span class=\"n\">xs</span> <span class=\"bp\">=</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">L.append_nil</span> <span class=\"o\">{</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">L.append</span> <span class=\"n\">xs</span> <span class=\"n\">L.nil</span> <span class=\"bp\">=</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">len</span><span class=\"o\">,</span> <span class=\"n\">elems</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">xs</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">append</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"n\">L.ext</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nil</span><span class=\"o\">]</span>\n  <span class=\"n\">induction</span> <span class=\"n\">len</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cases</span> <span class=\"n\">elems</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">len</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">elems'</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">elems</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nfold.cons_append</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">nfold.cons_cast</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">]</span>\n</code></pre></div>\n</div></div>\n<p>I've never tried handling this using lemmas on the structure of the motive of <code>Eq.rec</code>, which sounds like what transport lemmas might be similar to. Having a <code>cast</code> function is nice because it puts a constraint on what the motive can be, and it seems like it makes it easier to write simp lemmas.</p>",
        "id": 411564531,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704597801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"600428\">y-samuel</span> has marked this topic as resolved.</p>",
        "id": 411945138,
        "sender_full_name": "Notification Bot",
        "timestamp": 1704810455
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"600428\">y-samuel</span> has marked this topic as unresolved.</p>",
        "id": 411945168,
        "sender_full_name": "Notification Bot",
        "timestamp": 1704810463
    }
]