[
    {
        "content": "<p>Hi Folks,</p>\n<p>I'm trying to make a type class for numbers that can be added,<br>\nsubtracted, multiplied, divided, and a few other things.</p>\n<p>I thought I had succeeded, but the following inverse function is<br>\nnot behaving as I had expected.  I thought that when I use Float<br>\nas the particular type, then the division that occurs in the<br>\ninverse function would be floating point division.  But since the<br>\ninverse of ten evaluates to zero, I'm thinking that maybe Lean is<br>\ndoing Nat division for some reason and only subsequently<br>\nconverting the result to a Float.</p>\n<p>Can someone explain this behavior?</p>\n<p>Thanks.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Number</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Add</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Sub</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Mul</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Div</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Neg</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">OfNat</span> <span class=\"n\">n</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">OfNat</span> <span class=\"n\">n</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">OfNat</span> <span class=\"n\">n</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">OfNat</span> <span class=\"n\">n</span> <span class=\"mi\">6</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">inv</span> <span class=\"o\">[</span><span class=\"n\">Number</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Number</span> <span class=\"n\">Float</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ten</span> <span class=\"o\">:</span> <span class=\"n\">Float</span> <span class=\"o\">:=</span> <span class=\"mi\">10</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">inv</span> <span class=\"n\">ten</span>    <span class=\"c1\">-- 0.000000, why?</span>\n</code></pre></div>",
        "id": 434538798,
        "sender_full_name": "Scott N. Walck",
        "timestamp": 1713652342
    },
    {
        "content": "<p>Can you post a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ? Your question is very hard to answer coherently otherwise [edit: thanks for editing the question :-) ]</p>",
        "id": 434538850,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713652407
    },
    {
        "content": "<p>(It looks like the beginning got chopped off in a copy-paste)</p>",
        "id": 434538863,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1713652432
    },
    {
        "content": "<p>Lean has some counterintuitive behavior when you extend multiple structures which have projections with the same name. Here <code>Number</code> extends both <code>OfNat n 0</code> and <code>OfNat n 1</code>, both of which have a projection <code>ofNat</code>, and only the <code>OfNat n 0</code> ends up counting. You can see that <code>(1 : n)</code> is actually getting defined as <code>(0 : n)</code> through this example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Number</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">OfNat</span> <span class=\"n\">T</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">OfNat</span> <span class=\"n\">T</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Number</span> <span class=\"n\">Float</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Number.one</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Number</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">Number.one</span> <span class=\"o\">:</span> <span class=\"n\">Float</span><span class=\"o\">)</span> <span class=\"c1\">-- 0.000000</span>\n</code></pre></div>",
        "id": 434539430,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1713653010
    },
    {
        "content": "<p>The way mathlib works around this is that they define two classes <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Zero#doc\">docs#Zero</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=One#doc\">docs#One</a> which each have bidirectional instances with <code>OfNat</code> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddMonoidWithOne#doc\">docs#AddMonoidWithOne</a> extends <code>Zero T</code> and <code>One T</code> instead of <code>OfNat T 0</code> and <code>OfNat T 1</code>. You could do the same except have classes for <code>Zero</code>, <code>One</code>, <code>Two</code>, and <code>Six</code>.</p>",
        "id": 434539624,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1713653199
    },
    {
        "content": "<p>Wow.  That's very helpful.  Thanks.</p>",
        "id": 434539781,
        "sender_full_name": "Scott N. Walck",
        "timestamp": 1713653402
    },
    {
        "content": "<p>This feels like a bug to me; it seems like Lean should refuse to merge base classes which have different types</p>",
        "id": 434580634,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713697557
    },
    {
        "content": "<p>This also feels counterintuitive to me. But what exactly are you suggesting <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>? <code>@OfNat.ofNat T 0 _</code> and <code>@OfNat.ofNat T 1 _</code> both have type <code>T</code>, and I'm not quite sure in what way this example is different to merging the <code>mul</code> fields when extending <code>CommSemigroup</code> and <code>Monoid</code>.</p>",
        "id": 434729281,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1713787203
    },
    {
        "content": "<p>In that case the two base classes are both of type <code>Mul</code></p>",
        "id": 434729637,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713787296
    },
    {
        "content": "<p>The one place that we <em>might</em> run into trouble here is with the dependently-typed base classes of <code>Module</code>, but I think that's easiest to answer by implementing and seeing what breaks</p>",
        "id": 434729871,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713787356
    },
    {
        "content": "<p>I guess this would be a breaking change; field unification would no longer be nominal, and would only happen via explicit diamond inheritance</p>",
        "id": 434729991,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713787404
    },
    {
        "content": "<p>I expect there are some explicit fields (i.e. not through extend) in our algebraic hierarchy with the same name and type? And those would indeed break under your suggestion... But maybe that isn't too painful...</p>",
        "id": 434730229,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1713787479
    },
    {
        "content": "<p>I guess this rule only needs to apply for data fields, prop fields can always be merged</p>",
        "id": 434734006,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713788442
    },
    {
        "content": "<p>So the desired behavior is that extending both <code>OfNat T 0</code> and <code>OfNat T 1</code> results in <code>@[instance]</code> fields <code>toOfNat : OfNat T 0</code> and <code>toOfNat_0 : OfNat T 1</code>?</p>",
        "id": 434805947,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1713806724
    },
    {
        "content": "<p>Making the field names unique seems a little awkward. I wonder if the new instance naming algorithm could be reused</p>",
        "id": 434806163,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1713806792
    },
    {
        "content": "<p>At least you can always give your own names outside of extend, at the cost of needing to define the projection instances yourself. You do lose default values from pre-existing instances, but you can use autoParams as a hack:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Number</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Add</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Sub</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Mul</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Div</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Neg</span> <span class=\"n\">n</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">two</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">six</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"mi\">6</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Number</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">n</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Number.zero</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Number</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">n</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Number.one</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Number</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">n</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Number.two</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Number</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">n</span> <span class=\"mi\">6</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Number.six</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">inv</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Number</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Number</span> <span class=\"n\">Float</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ten</span> <span class=\"o\">:</span> <span class=\"n\">Float</span> <span class=\"o\">:=</span> <span class=\"mi\">10</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">inv</span> <span class=\"n\">ten</span>\n<span class=\"c1\">-- 0.100000</span>\n</code></pre></div>",
        "id": 434817555,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713809931
    },
    {
        "content": "<blockquote>\n<p>Making the field names unique seems a little awkward. I wonder if the new instance naming algorithm could be reused</p>\n</blockquote>\n<p>Name mangling is an option, but a problem here is that these names need to be used in user code when defining instances (unless there is an expectation that these fields <em>must</em> come from preexisting instances).</p>\n<p>Lean 3 had a feature where you could rename fields when you extended.</p>",
        "id": 434817967,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713810085
    },
    {
        "content": "<p>Oh right, I forgot about this design pattern, where you use encapsulation instead of extension:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Number</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Add</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Sub</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Mul</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Div</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Neg</span> <span class=\"n\">n</span> <span class=\"n\">where</span>\n  <span class=\"o\">[</span><span class=\"n\">ofNatZero</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">n</span> <span class=\"mi\">0</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">ofNatOne</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">n</span> <span class=\"mi\">1</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">ofNatTwo</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">n</span> <span class=\"mi\">2</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">ofNatSix</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">n</span> <span class=\"mi\">6</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Number</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">n</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">Number.ofNatZero</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Number</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">n</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">Number.ofNatOne</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Number</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">n</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">Number.ofNatTwo</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Number</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">n</span> <span class=\"mi\">6</span> <span class=\"o\">:=</span> <span class=\"n\">Number.ofNatSix</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">inv</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Number</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Number</span> <span class=\"n\">Float</span> <span class=\"n\">where</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ten</span> <span class=\"o\">:</span> <span class=\"n\">Float</span> <span class=\"o\">:=</span> <span class=\"mi\">10</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">inv</span> <span class=\"n\">ten</span>\n<span class=\"c1\">-- 0.100000</span>\n</code></pre></div>",
        "id": 434818248,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713810179
    },
    {
        "content": "<p>I wonder if the <code>class</code> command could have a way to say that certain fields are supposed to provide instances, to save needing to write these <code>instance</code> commands?</p>",
        "id": 434818421,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713810245
    },
    {
        "content": "<p>Is it accurate to say that this is exactly what <code>extend</code> desugars to, at least when the base structures have mutually exclusive fields? As long as we're not losing any special affordances that come from using <code>extend</code>, I think it would be a reasonable design to say that you must use this manual desugaring when you're extending distinct base structures which share a field with the same name. The nice thing about the desugared syntax is that it provides a natural way to specify the projection names.</p>",
        "id": 434823377,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1713811995
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Puzzling.20type.20class.20behavior/near/434818421\">said</a>:</p>\n<blockquote>\n<p>I wonder if the <code>class</code> command could have a way to say that certain fields are supposed to provide instances, to save needing to write these <code>instance</code> commands?</p>\n</blockquote>\n<p>Should we just make it the default that instance implicit class fields get projection instances automatically? I can't think of a reason you wouldn't want that, and if you really didn't, you could always get around it using <code>class inductive</code></p>",
        "id": 434824214,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1713812270
    },
    {
        "content": "<p>I think <code>attribute [instance] Number.ofNatZero</code> is the currently-idiomatic spelling?</p>",
        "id": 434868192,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713828608
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"500038\">Timo Carlin-Burns</span> <a href=\"#narrow/stream/270676-lean4/topic/Puzzling.20type.20class.20behavior/near/434824214\">said</a>:</p>\n<blockquote>\n<p>Should we just make it the default that instance implicit class fields get projection instances automatically? I can't think of a reason you wouldn't want that, and if you really didn't, you could always get around it using <code>class inductive</code></p>\n</blockquote>\n<p>If we do get this, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Bundled#doc\">docs#CategoryTheory.Bundled</a> would be a great first test subject, using it becomes nontrivially more convenient with an auto-instance for <code>c.str</code>.</p>",
        "id": 435379407,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1714048568
    }
]