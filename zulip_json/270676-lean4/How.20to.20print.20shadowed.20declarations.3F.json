[
    {
        "content": "<p>Take this code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Box</span> <span class=\"n\">where</span>\n  <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"n\">deriving</span> <span class=\"n\">BEq</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">instBEqBox</span> <span class=\"c1\">-- { beq := beqBox✝ }</span>\n</code></pre></div>\n<p>Turning on <code>pp.sanitizeNames</code> does let you access the underlying name of this, but this changes on the ngen and such like so we can't actually access it. It'd be really nice to print it so that I could modify the instance generated by <code>deriving</code> without having to rewrite the scaffolding.</p>",
        "id": 425999861,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1710187526
    },
    {
        "content": "<p>I was told about <code>open private</code> here but I just can't get it to work. I am told that there is private declarations, but can't seem to figure out the syntax to actually do the <code>open</code>ing.</p>",
        "id": 426032686,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1710203689
    },
    {
        "content": "<p>this is not a private declaration (well it is but that's not the problem because you are still in the same module as the declaration), it is a declaration with an inaccessible name. You can call <code>#print</code> if you construct the name manually:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Box</span> <span class=\"n\">where</span>\n  <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"n\">deriving</span> <span class=\"n\">BEq</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.sanitizeNames</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n<span class=\"k\">#print</span> <span class=\"n\">instBEqBox</span>\n<span class=\"c1\">-- def instBEqBox : BEq Box :=</span>\n<span class=\"c1\">-- { beq := beqBox.22 }</span>\n\n<span class=\"kd\">run_cmd</span> <span class=\"n\">Elab.Command.elabCommand</span> <span class=\"bp\">&lt;|←</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">#print</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"o\">(</span><span class=\"n\">addMacroScope</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getMainModule</span><span class=\"o\">)</span> <span class=\"bp\">`</span><span class=\"n\">beqBox</span> <span class=\"mi\">22</span><span class=\"o\">)))</span>\n<span class=\"c1\">-- private def beqBox._@.Mathlib.Test._hyg.22 : Box → Box → Bool :=</span>\n<span class=\"c1\">-- fun x x_1 ↦</span>\n<span class=\"c1\">--   match x, x_1 with</span>\n<span class=\"c1\">--   | { a := a, b := a_1 }, { a := b, b := b_1 } =&gt; true &amp;&amp; a == b &amp;&amp; a_1 == b_1</span>\n<span class=\"c1\">--   | x, x_2 =&gt; false</span>\n</code></pre></div>",
        "id": 426187413,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710267536
    },
    {
        "content": "<p>(The fact that several deriving instances produce global declarations with inaccessible names is a recurring source of issues, and I've been planning to write a PR to make them accessible for some time. For example this causes an issue if you want to prove that an autogenerated <code>Ord</code> or <code>BEq</code> instance is lawful.)</p>",
        "id": 426187822,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710267707
    },
    {
        "content": "<p>Thanks! This really does seem quite annoying. One thing I've been meaning to figure out is macro scopes - what are they and how should I use them?</p>",
        "id": 426188443,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1710267934
    },
    {
        "content": "<p>They're the scope of a macro :p. That is, the 'jurisdiction' of a macro over names and definitions. When a new macro is begun (controlled I think primarily <code>withNewMacroScope</code>?), it gets to include its macro scope (which is apparently implemented as just a unique number, probably encoding nesting of macros?) into the name of all (parsing) variables it introduces; this enforces hygiene requirements.</p>",
        "id": 426221907,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710281895
    },
    {
        "content": "<p>ah, yeah, here: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MacroScope#doc\">docs#Lean.MacroScope</a></p>",
        "id": 426221923,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710281907
    },
    {
        "content": "<p>So, in theory, you should introduce a new macro scope whenever there might be danger of name collision of parse variables. In practice I think it's not much used/handled for you when writing <code>notation</code> or simple <code>macro_rules</code> and <code>elab_rules</code>, but more involved elaborators pretty much all start with <code>withNewMacroScope do</code>, and also if you might collide with <em>yourself</em> (through a recursive call, for example) that should get a <code>withNewMacroScope do</code> as well.</p>",
        "id": 426222356,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710282139
    },
    {
        "content": "<p>Ahh, so that number <code>22</code> is a macro-scope in this case. It does seem odd to me because I feel like no macros have been involved here, but I guess (a) most things are macros in some way or another and (b) it's probably the macro scope of the <code>deriving</code> stuff. [Not sure whether multiple derivings would have same or different macro scopes, I guess it depends on the implementation...].</p>",
        "id": 426224043,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1710283028
    },
    {
        "content": "<p>It's possible to make a command that prints the value after unfolding all inaccessible constants (i.e., the ones with macro scopes):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Box</span> <span class=\"n\">where</span>\n  <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"n\">deriving</span> <span class=\"n\">BEq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Command</span> <span class=\"k\">in</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"#print_val \"</span> <span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">addCompletionInfo</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">CompletionInfo.id</span> <span class=\"n\">id</span> <span class=\"n\">id.getId</span> <span class=\"o\">(</span><span class=\"n\">danglingDot</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">{}</span> <span class=\"n\">none</span>\n  <span class=\"k\">let</span> <span class=\"n\">c</span> <span class=\"bp\">←</span> <span class=\"n\">resolveGlobalConstNoOverloadWithInfo</span> <span class=\"n\">id</span>\n  <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getEnv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"bp\">?</span> <span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"unknown identifier '{mkConst c}'\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">d.value</span><span class=\"bp\">?</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"no value for decl\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">val</span> <span class=\"bp\">←</span> <span class=\"n\">liftTermElabM</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Meta.transform</span> <span class=\"n\">val</span>\n    <span class=\"o\">(</span><span class=\"n\">pre</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"n\">n</span> <span class=\"bp\">..</span> <span class=\"o\">:=</span> <span class=\"n\">e.getAppFn'</span> <span class=\"k\">then</span>\n        <span class=\"k\">if</span> <span class=\"n\">n.hasMacroScopes</span> <span class=\"k\">then</span>\n          <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">e'</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.unfoldDefinition</span><span class=\"bp\">?</span> <span class=\"n\">e</span> <span class=\"k\">then</span>\n            <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">visit</span> <span class=\"n\">e'</span>\n      <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">continue</span><span class=\"o\">)</span>\n  <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{val}\"</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print_val</span> <span class=\"n\">instBEqBox</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">{</span>\n<span class=\"cm\">  beq := fun x x_1 ↦</span>\n<span class=\"cm\">    (fun motive x x_2 h_1 h_2 ↦ Box.casesOn x fun a b ↦ Box.casesOn x_2 fun a_1 b_1 ↦ h_1 a b a_1 b_1) (fun x x ↦ Bool)</span>\n<span class=\"cm\">      x x_1 (fun a a_1 b b_1 ↦ true &amp;&amp; a == b &amp;&amp; a_1 == b_1) fun x x ↦ false }</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 426226078,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710284208
    }
]