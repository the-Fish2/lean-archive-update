[
    {
        "content": "<p>I'm having issues when trying to do pattern matching and use that to build new terms because Lean doesn't unfold the definition, i.e. it \"forgets\" the pattern match. Here's an attempt at an MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">SomeType</span>\n  <span class=\"bp\">|</span> <span class=\"n\">someConstructor</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">SomeType</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">SomeType.getN</span> <span class=\"o\">:</span> <span class=\"n\">SomeType</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">someConstructor</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">DependentType</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">DependentType</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">SomeStruct</span> <span class=\"n\">where</span>\n  <span class=\"n\">ty</span> <span class=\"o\">:</span> <span class=\"n\">SomeType</span>\n  <span class=\"n\">depTy</span> <span class=\"o\">:</span> <span class=\"n\">DependentType</span> <span class=\"n\">ty.getN</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">someFunction</span> <span class=\"o\">:</span> <span class=\"n\">SomeStruct</span> <span class=\"bp\">→</span> <span class=\"n\">SomeStruct</span>\n  <span class=\"bp\">|</span> <span class=\"n\">struct</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">struct.ty</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|.</span><span class=\"n\">someConstructor</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">struct.ty.getN</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">SomeType.getN</span><span class=\"o\">]</span>\n        <span class=\"n\">rfl</span>\n      <span class=\"k\">let</span> <span class=\"n\">depTy</span> <span class=\"o\">:</span> <span class=\"n\">DependentType</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">struct.depTy</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">n.succ</span>\n      <span class=\"o\">{</span> <span class=\"n\">ty</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">someConstructor</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">depTy</span> <span class=\"o\">:=</span> <span class=\"n\">depTy</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Here, <code>struct.ty</code>should be replaced by <code>.someConstructor n</code> through the pattern match, and I should be able to prove that <code>h</code> basically with unfolding, but it doesn't work. The <code>rfl</code> tactic there fails with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"n\">SomeStruct</span>\n<span class=\"n\">struct</span><span class=\"o\">:</span> <span class=\"n\">SomeStruct</span> <span class=\"o\">:=</span> <span class=\"n\">x</span><span class=\"bp\">✝</span>\n<span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">x</span><span class=\"bp\">✝.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n<span class=\"n\">Messages</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">MWE.lean</span><span class=\"o\">:</span><span class=\"mi\">19</span><span class=\"o\">:</span><span class=\"mi\">8</span>\n<span class=\"n\">tactic</span> <span class=\"bp\">'</span><span class=\"n\">rfl'</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">equality</span> <span class=\"n\">lhs</span>\n  <span class=\"n\">x</span><span class=\"bp\">✝.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">definitionally</span> <span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"n\">rhs</span>\n  <span class=\"n\">n</span>\n<span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"n\">SomeStruct</span>\n<span class=\"n\">struct</span><span class=\"o\">:</span> <span class=\"n\">SomeStruct</span> <span class=\"o\">:=</span> <span class=\"n\">x</span><span class=\"bp\">✝</span>\n<span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">x</span><span class=\"bp\">✝.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>Somehow, the elaborator is building this extra <code>x</code> and there is no equality relating the pattern match (in this case <code>n</code> with <code>struct.ty</code>, i.e something like <code>struct.ty = .someConstructor n</code>. I think the <code>structure</code> is what's getting in the way here, but in my real case I also have (more complicated structures). Does anyone know if there's a way to get around this issue?</p>",
        "id": 420985872,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1707730511
    },
    {
        "content": "<p>When a <code>match</code> discriminant is given something that's not just a variable, it turns it into <code>let x := v; match x with ...</code></p>\n<p>Option 1: write <code>match h : struct.ty with</code> and then use this <code>h</code> equality in your proofs</p>\n<p>Option 2: fully destruct your <code>struct</code> and match on the resulting variable, like <code>| {ty, depTy} =&gt; match ty with</code></p>",
        "id": 421078792,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707756124
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 421080932,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1707756721
    }
]