[
    {
        "content": "<p>I'm trying to create a language parser and type checker with row types. Like a JSON type I need to have a recursive definition. I tried building on the PHOAS tutorial in the Lean4 manual.</p>\n<p>This is my naive attempt at defining a PHOAS with the row types Attrset</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n<span class=\"sd\">/-- Attribute set type this is supposed to be able to represent every available type</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">AttrsetTy</span>\n  <span class=\"bp\">|</span> <span class=\"n\">empty</span>\n  <span class=\"bp\">|</span> <span class=\"n\">merged</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">AttrsetTy</span><span class=\"o\">)</span>\n\n\n<span class=\"sd\">/-- Primitive types</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Ty</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">num</span>\n  <span class=\"bp\">|</span> <span class=\"n\">string</span>\n  <span class=\"bp\">|</span> <span class=\"n\">bool</span>\n  <span class=\"bp\">|</span> <span class=\"n\">lambda</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Ty</span>\n  <span class=\"c1\">-- Optimized primitives</span>\n  <span class=\"bp\">|</span> <span class=\"n\">list</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Ty</span>\n  <span class=\"bp\">|</span> <span class=\"n\">attrset</span> <span class=\"o\">:</span> <span class=\"n\">AttrsetTy</span> <span class=\"bp\">→</span> <span class=\"n\">Ty</span>\n<span class=\"kd\">end</span>\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Hetrogenous list of types paramtereized by ɑ</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">HList</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">HList</span> <span class=\"n\">β</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">HList</span> <span class=\"n\">β</span> <span class=\"n\">is</span> <span class=\"bp\">→</span> <span class=\"n\">HList</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">::</span><span class=\"n\">is</span><span class=\"o\">)</span>\n\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">67</span> <span class=\"s2\">\" :: \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">HList.cons</span>\n\n<span class=\"kd\">notation</span> <span class=\"s2\">\"[\"</span> <span class=\"s2\">\"]\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">HList.nil</span>\n\n\n<span class=\"sd\">/-- Member certificate for list elements</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Member</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">head</span> <span class=\"o\">:</span> <span class=\"n\">Member</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">as</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">tail</span> <span class=\"o\">:</span> <span class=\"n\">Member</span> <span class=\"n\">a</span> <span class=\"n\">bs</span> <span class=\"bp\">→</span> <span class=\"n\">Member</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">::</span><span class=\"n\">bs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">HList.get</span> <span class=\"o\">:</span> <span class=\"n\">HList</span> <span class=\"n\">β</span> <span class=\"n\">is</span> <span class=\"bp\">→</span> <span class=\"n\">Member</span> <span class=\"n\">i</span> <span class=\"n\">is</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">i</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">head</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">::</span><span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">tail</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">as.get</span> <span class=\"n\">h</span>\n\n\n<span class=\"kd\">mutual</span>\n<span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">AttrsetTy.denote</span> <span class=\"o\">:</span> <span class=\"n\">AttrsetTy</span> <span class=\"bp\">→</span> <span class=\"n\">AttrsetT</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">merged</span> <span class=\"n\">n</span> <span class=\"n\">t</span> <span class=\"n\">rest</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">List.cons</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rest.denote</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">empty</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">Ty.denote</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">num</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Number</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">string</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">String</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">bool</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Bool</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">lambda</span> <span class=\"n\">d</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">d.denote</span> <span class=\"bp\">→</span> <span class=\"n\">r.denote</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">list</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">List</span> <span class=\"n\">a.denote</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">attrset</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">merged</span> <span class=\"n\">n</span> <span class=\"n\">t</span> <span class=\"n\">rest</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">HList.cons</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">t.denote</span><span class=\"o\">)</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">attrset</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">empty</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">HList.nil</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>How do I properly denote a row type like attrset which is essentially a JSON-like structure?</p>",
        "id": 409999393,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1703583024
    },
    {
        "content": "<p>Perhaps looking at the implementation of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Json#doc\">docs#Lean.Json</a> can help?</p>",
        "id": 410020519,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703594693
    },
    {
        "content": "<p>I think <code>AttrsetT</code> is a typo there?</p>",
        "id": 410020649,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703594788
    },
    {
        "content": "<p>You might want to work with <code>set_option autoImplicit false</code> to catch this kind of error earlier</p>",
        "id": 410020688,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703594826
    },
    {
        "content": "<p>It is not a typo. I only included parts of the source. AttrsetT should however be Type, but this code is not correct anyway,  and I'm not sure if I'm way off.<br>\nLean.Json is nice, but it is not a type checker or a term based language. </p>\n<p>I'm trying to build a parser and type checker for a lambda calculus which includes </p>\n<p>I'm trying to adapt this PHOAS article to row types<br>\n<a href=\"https://lean-lang.org/lean4/doc/examples/phoas.lean.html\">https://lean-lang.org/lean4/doc/examples/phoas.lean.html</a></p>\n<p>My idea was to create a recursive type definition that can represent a JSON-like, nix expressions,  structure including lambda expressions.<br>\nSo for example </p>\n<div class=\"codehilite\" data-code-language=\"Nix\"><pre><span></span><code><span class=\"p\">{</span><span class=\"ss\">a</span> <span class=\"o\">=</span> <span class=\"no\">true</span><span class=\"p\">;</span> <span class=\"s2\">\"b\"</span> <span class=\"o\">=</span> <span class=\"s2\">\"string\"</span><span class=\"p\">}</span>\n</code></pre></div>\n<p>I can define a type L like this and map strings to types</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">strToType</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"s2\">\"b\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">String</span>\n  <span class=\"bp\">|</span> <span class=\"s2\">\"a\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Bool</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Unit</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">L</span> <span class=\"o\">:</span><span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">HList</span> <span class=\"n\">strToType</span> <span class=\"o\">[</span><span class=\"s2\">\"b\"</span><span class=\"o\">,</span> <span class=\"s2\">\"a\"</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Or something like that. I was hoping someone with type theory experience can help me.</p>",
        "id": 410031538,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1703600606
    },
    {
        "content": "<p>the type of the lambda does not look like PHOAS</p>",
        "id": 410032488,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703601184
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Nix\"><pre><span></span><code><span class=\"p\">{</span><span class=\"ss\">a</span> <span class=\"o\">=</span> b<span class=\"p\">:</span> b<span class=\"p\">}</span>\n</code></pre></div>\n<p>would have a type</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">strToType</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"s2\">\"a\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Any</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Any</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Unit</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">L</span> <span class=\"o\">:</span><span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">HList</span> <span class=\"n\">strToType</span> <span class=\"o\">[</span><span class=\"s2\">\"a\"</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 410039274,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1703604751
    },
    {
        "content": "<p>I almost got this working now :) I just need to prove termination. Any tips on how to do that?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">Ty.denote</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ty</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">num</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Number</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">string</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">String</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">bool</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Bool</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">lambda</span> <span class=\"n\">d</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">d.denote</span> <span class=\"bp\">→</span> <span class=\"n\">r.denote</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">list</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">List</span> <span class=\"n\">a.denote</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">attrset</span> <span class=\"n\">maps</span> <span class=\"n\">names</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">HList</span> <span class=\"o\">(</span><span class=\"n\">Ty.denote</span> <span class=\"bp\">∘</span> <span class=\"n\">maps</span><span class=\"o\">)</span> <span class=\"n\">names</span>\n</code></pre></div>",
        "id": 410048825,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1703610953
    },
    {
        "content": "<p>with mutual and nested inductives, it can be pretty hard to prove termination</p>",
        "id": 410061072,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1703620213
    },
    {
        "content": "<p>for the attrset case, you will essentially need to get a proof term passed to <code>Ty.denote</code> which says that the value being passed into it from <code>maps</code> is smaller than <code>ty</code>. and then you can use the <code>termination_by</code> syntax to prove termination</p>",
        "id": 410061449,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1703620504
    },
    {
        "content": "<p>there is an autogenerated notion of size called <code>sizeOf</code> (from the typeclass <code>SizeOf</code>) which might work for you. otherwise you'll have to define your own measure of size on <code>Ty</code>s</p>",
        "id": 410061553,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1703620567
    },
    {
        "content": "<p>I've gotten this far</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">Ty.denote</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ty</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">num</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Number</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">string</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">String</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">bool</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Bool</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">lambda</span> <span class=\"n\">d</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">d.denote</span> <span class=\"bp\">→</span> <span class=\"n\">r.denote</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">list</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">List</span> <span class=\"n\">a.denote</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">attrset</span> <span class=\"n\">maps</span> <span class=\"n\">names</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">HList</span> <span class=\"o\">(</span><span class=\"n\">Ty.denote</span> <span class=\"bp\">∘</span> <span class=\"n\">maps</span><span class=\"o\">)</span> <span class=\"n\">names</span>\n\n<span class=\"n\">termination_by</span> <span class=\"n\">denote</span> <span class=\"n\">ty</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"kd\">by</span> <span class=\"o\">{</span>\n      <span class=\"n\">cases</span> <span class=\"n\">ty</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">attrset</span> <span class=\"n\">maps</span> <span class=\"n\">names</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">apply</span> <span class=\"n\">sizeOf</span> <span class=\"n\">maps</span>\n      <span class=\"bp\">|</span> <span class=\"n\">lambda</span> <span class=\"n\">d</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">apply</span> <span class=\"n\">sizeOf</span> <span class=\"n\">d</span>\n      <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"mi\">0</span>\n    <span class=\"o\">}</span>\n</code></pre></div>\n<p>But it fails for the lambda case</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Header</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>failed to prove termination, possible solutions:<br>\n  - Use <code>have</code>-expressions to prove the remaining goals<br>\n  - Use <code>termination_by</code> to specify a different well-founded relation<br>\n  - Use <code>decreasing_by</code> to specify your own tactic for discharging this kind of goal</p>\n<p>d r: Ty<br>\n⊢ rec PUnit.unit (fun name type rest type_ih rest_ih =&gt; PUnit.unit) (fun h =&gt; 0) (fun h =&gt; 0) (fun h =&gt; 0)<br>\n    (fun a a_1 a_ih a_ih h =&gt; sizeOf a) (fun a a_ih h =&gt; 0) (fun maps names maps_ih h =&gt; 0) d (_ : d = d) &lt;<br>\n  sizeOf d</p>\n</div></div>",
        "id": 410065628,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1703623575
    },
    {
        "content": "<p>If you haven't yet, check out <a href=\"https://lean-lang.org/functional_programming_in_lean/programs-proofs/arrays-termination.html#proving-termination\">FPIL's section on proving termination</a></p>",
        "id": 410071407,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1703628113
    },
    {
        "content": "<p>oh, it doesn't actually have examples of putting <code>have</code>s in the body. let me look around for examples...</p>",
        "id": 410071526,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1703628153
    },
    {
        "content": "<p>basically you need a <code>have : the termination goal := proof</code> in scope at the recursive calls</p>",
        "id": 410071770,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1703628330
    },
    {
        "content": "<p>Thanks. I will try.</p>",
        "id": 410072248,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1703628768
    },
    {
        "content": "<p>I haven't been so successful proving termination. It seems like all the recursive terms are hard to show termination of. The proof needs to know that the recursion will never grow larger than Ty and shrink as the tree is traversed.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">Ty.denote</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">num</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Number</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">string</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">String</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">bool</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Bool</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">attrset</span> <span class=\"n\">maps</span> <span class=\"n\">names</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">HList</span> <span class=\"o\">(</span><span class=\"n\">Ty.denote</span> <span class=\"bp\">∘</span> <span class=\"n\">maps</span><span class=\"o\">)</span> <span class=\"n\">names</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">list</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">sizeOf</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">sizeOf</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.lt_succ_self</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_comm</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">Nat.lt_add_left</span><span class=\"o\">]</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">List</span> <span class=\"n\">a.denote</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">lambda</span> <span class=\"n\">d</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">sizeOf</span> <span class=\"n\">d</span> <span class=\"bp\">&lt;</span> <span class=\"n\">sizeOf</span> <span class=\"o\">(</span><span class=\"n\">Ty.lambda</span> <span class=\"n\">d</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.lt_succ_self</span><span class=\"o\">,</span><span class=\"n\">Nat.add_comm</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">Nat.lt_add_right</span><span class=\"o\">]</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">d.denote</span> <span class=\"bp\">→</span> <span class=\"n\">r.denote</span>\n\n<span class=\"n\">termination_by</span> <span class=\"n\">denote</span> <span class=\"n\">ty</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"kd\">by</span> <span class=\"o\">{</span>\n      <span class=\"n\">cases</span> <span class=\"n\">ty</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">attrset</span> <span class=\"n\">maps</span> <span class=\"n\">names</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">apply</span> <span class=\"n\">sizeOf</span> <span class=\"n\">names</span>\n      <span class=\"bp\">|</span> <span class=\"n\">lambda</span> <span class=\"n\">d</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">apply</span> <span class=\"n\">sizeOf</span> <span class=\"o\">(</span><span class=\"n\">lambda</span> <span class=\"n\">d</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n      <span class=\"bp\">|</span> <span class=\"n\">list</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">apply</span> <span class=\"n\">sizeOf</span> <span class=\"n\">a</span>\n      <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"mi\">0</span>\n    <span class=\"o\">}</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">prove</span> <span class=\"n\">termination</span><span class=\"o\">,</span> <span class=\"n\">possible</span> <span class=\"n\">solutions</span><span class=\"o\">:</span>\n  <span class=\"bp\">-</span> <span class=\"n\">Use</span> <span class=\"bp\">`</span><span class=\"k\">have</span><span class=\"bp\">`-</span><span class=\"n\">expressions</span> <span class=\"n\">to</span> <span class=\"n\">prove</span> <span class=\"n\">the</span> <span class=\"n\">remaining</span> <span class=\"n\">goals</span>\n  <span class=\"bp\">-</span> <span class=\"n\">Use</span> <span class=\"bp\">`</span><span class=\"n\">termination_by</span><span class=\"bp\">`</span> <span class=\"n\">to</span> <span class=\"n\">specify</span> <span class=\"n\">a</span> <span class=\"n\">different</span> <span class=\"n\">well</span><span class=\"bp\">-</span><span class=\"n\">founded</span> <span class=\"n\">relation</span>\n  <span class=\"bp\">-</span> <span class=\"n\">Use</span> <span class=\"bp\">`</span><span class=\"n\">decreasing_by</span><span class=\"bp\">`</span> <span class=\"n\">to</span> <span class=\"n\">specify</span> <span class=\"n\">your</span> <span class=\"n\">own</span> <span class=\"n\">tactic</span> <span class=\"n\">for</span> <span class=\"n\">discharging</span> <span class=\"n\">this</span> <span class=\"n\">kind</span> <span class=\"n\">of</span> <span class=\"n\">goal</span>\n\n<span class=\"n\">maps</span><span class=\"o\">:</span> <span class=\"n\">Name</span> <span class=\"bp\">→</span> <span class=\"n\">Ty</span>\n<span class=\"n\">names</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Name</span>\n<span class=\"n\">a</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"n\">Ty</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">rec</span> <span class=\"n\">PUnit.unit</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">name</span> <span class=\"n\">type</span> <span class=\"n\">rest</span> <span class=\"n\">type_ih</span> <span class=\"n\">rest_ih</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">PUnit.unit</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">a_1</span> <span class=\"n\">a_ih</span> <span class=\"n\">a_ih</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">a_1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">a_ih</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">maps</span> <span class=\"n\">names</span> <span class=\"n\">maps_ih</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">names</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"bp\">✝</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"bp\">✝</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"bp\">✝</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span>\n  <span class=\"n\">sizeOf</span> <span class=\"n\">names</span>\n</code></pre></div>\n<p>Any suggestions?</p>",
        "id": 410145920,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1703679387
    },
    {
        "content": "<p>have you tried defining it as two mutually recursive functions that match the mutually recursive structure of <code>Ty</code> and <code>AttrsetTy</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n<span class=\"kd\">def</span> <span class=\"n\">AttrsetTy.denote</span> <span class=\"o\">:</span> <span class=\"n\">AttrsetTy</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"bp\">...</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Ty.denote</span> <span class=\"o\">:</span> <span class=\"n\">Ty</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"bp\">...</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 410200611,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1703710471
    },
    {
        "content": "<p>That was my initial attempt yes. But it didn't work out</p>",
        "id": 410291035,
        "sender_full_name": "Anders Christiansen Sørby",
        "timestamp": 1703768751
    }
]