[
    {
        "content": "<p>Is it a known issue that if you use goto definition on <code>Nat</code> in:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>you get to <code>Nat</code>, but if you use it in the presence of a pattern:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>you go to <code>haveDecl</code>?</p>",
        "id": 423201591,
        "sender_full_name": "Julian Berman",
        "timestamp": 1708806549
    },
    {
        "content": "<p>This is an issue with the <code>let</code> tactic too, and it seems to be rooted in an issue with the <code>let</code> term. If you hover over any part of the type after the <code>:</code> it highlights the whole letDecl</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 423203771,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708808869
    },
    {
        "content": "<p>That issue seems to be rooted in turn in how <code>match</code> handles type ascriptions. Hovering over the type highlights the whole type ascription.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"o\">((</span><span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 423203859,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708808969
    },
    {
        "content": "<p>And it looks like it comes down to how type ascriptions themselves elaborate when the value is a tactic. Hovering over <code>Nat</code> gives information about the type ascription.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"gr\">sorry</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 423205438,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708810689
    },
    {
        "content": "<p>Going back up to the original <code>have</code> notation, avoiding a tactic makes hovering over <code>Nat</code> highlight just <code>Nat</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 423206320,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708811334
    },
    {
        "content": "<p>Thanks for the digging! You'd agree these are bugs I assume?</p>",
        "id": 423207956,
        "sender_full_name": "Julian Berman",
        "timestamp": 1708812815
    },
    {
        "content": "<p>It seems strange to me to even ever jump to / hover a tactic definition unless you specifically hover on the tactic name, but I'm not sure whether that's relevant / a good mental model in general for any possible tactic.</p>",
        "id": 423208030,
        "sender_full_name": "Julian Berman",
        "timestamp": 1708812869
    },
    {
        "content": "<p>Somehow the type in <code>(by sorry : ∃ n : Nat, 1 = 1)</code> is losing some TermInfo, and as a fallback it's looking outward to anything that annotates how the term was elaborated. Here, it's the type ascription, and in your <code>have</code> tactic, it's the <code>haveDecl</code> syntax, which itself looks out to the <code>have</code> when doing \"go to definition\".</p>",
        "id": 423208249,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708813055
    },
    {
        "content": "<p>There's a whole tree of nested info, and it walks up the tree as a fallback. The whole tactic range itself is annotated with the tactic itself. (For example, if you \"go to definition\" on the <code>=&gt;</code> in a tactic, it's associated to the tactic itself. That's a counterexample to \"only the tactic name itself refers to the tactic.\")</p>",
        "id": 423208359,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708813167
    },
    {
        "content": "<p>Yeah I figured something like that was going on (and I realize I'm just randomly talking) but to me it's odd even if pieces of syntax within a tactic end up jumping to the tactic</p>",
        "id": 423208430,
        "sender_full_name": "Julian Berman",
        "timestamp": 1708813219
    },
    {
        "content": "<p>At least it unifies things, because there are also tactics like <code>&lt;;&gt;</code> that have no head keyword</p>",
        "id": 423208488,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708813274
    },
    {
        "content": "<p>True.</p>",
        "id": 423208526,
        "sender_full_name": "Julian Berman",
        "timestamp": 1708813320
    },
    {
        "content": "<p>Weird, I don't see anything about the ascription in the info tree when there's a tactic. When it's just <code>(1 : Nat)</code>, there's <code>elabTypeAscription</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.Elab.info</span> <span class=\"n\">true</span>\n<span class=\"kd\">example</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">• command @ ⟨55, 0⟩-⟨55, 31⟩ @ Lean.Elab.Command.elabDeclaration</span>\n<span class=\"cm\">      • ℕ : Type @ ⟨55, 8⟩†-⟨55, 31⟩† @ Lean.Elab.Term.elabHole</span>\n<span class=\"cm\">      • _example (isBinder := true) : ℕ @ ⟨55, 0⟩†-⟨55, 31⟩†</span>\n<span class=\"cm\">      • Tactic @ ⟨55, 13⟩-⟨55, 23⟩</span>\n<span class=\"cm\">        (Term.byTactic \"by\" (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Tactic.exact \"exact\" (num \"1\"))])))</span>\n<span class=\"cm\">        before</span>\n<span class=\"cm\">        ⊢ ℕ</span>\n<span class=\"cm\">        after no goals</span>\n<span class=\"cm\">        • Tactic @ ⟨55, 13⟩-⟨55, 15⟩</span>\n<span class=\"cm\">          \"by\"</span>\n<span class=\"cm\">          before</span>\n<span class=\"cm\">          ⊢ ℕ</span>\n<span class=\"cm\">          after no goals</span>\n<span class=\"cm\">          • Tactic @ ⟨55, 16⟩-⟨55, 23⟩ @ Lean.Elab.Tactic.evalTacticSeq</span>\n<span class=\"cm\">            (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Tactic.exact \"exact\" (num \"1\"))]))</span>\n<span class=\"cm\">            before</span>\n<span class=\"cm\">            ⊢ ℕ</span>\n<span class=\"cm\">            after no goals</span>\n<span class=\"cm\">            • Tactic @ ⟨55, 16⟩-⟨55, 23⟩ @ Lean.Elab.Tactic.evalTacticSeq1Indented</span>\n<span class=\"cm\">              (Tactic.tacticSeq1Indented [(Tactic.exact \"exact\" (num \"1\"))])</span>\n<span class=\"cm\">              before</span>\n<span class=\"cm\">              ⊢ ℕ</span>\n<span class=\"cm\">              after no goals</span>\n<span class=\"cm\">              • Tactic @ ⟨55, 16⟩-⟨55, 23⟩ @ Lean.Elab.Tactic.evalExact</span>\n<span class=\"cm\">                (Tactic.exact \"exact\" (num \"1\"))</span>\n<span class=\"cm\">                before</span>\n<span class=\"cm\">                ⊢ ℕ</span>\n<span class=\"cm\">                after no goals</span>\n<span class=\"cm\">                • 1 : ℕ @ ⟨55, 22⟩-⟨55, 23⟩ @ Lean.Elab.Term.elabNumLit</span>\n<span class=\"cm\">      • _example (isBinder := true) : ℕ @ ⟨55, 0⟩-⟨55, 7⟩</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">example</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">1</span>            <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">• command @ ⟨88, 0⟩-⟨88, 31⟩ @ Lean.Elab.Command.elabDeclaration</span>\n<span class=\"cm\">      • ℕ : Type @ ⟨88, 8⟩†-⟨88, 31⟩† @ Lean.Elab.Term.elabHole</span>\n<span class=\"cm\">      • _example (isBinder := true) : ℕ @ ⟨88, 0⟩†-⟨88, 31⟩†</span>\n<span class=\"cm\">      • 1 : ℕ @ ⟨88, 11⟩-⟨88, 31⟩ @ Lean.Elab.Term.elabTypeAscription</span>\n<span class=\"cm\">        • ℕ : Type @ ⟨88, 27⟩-⟨88, 30⟩ @ Lean.Elab.Term.elabIdent</span>\n<span class=\"cm\">          • [.] Nat : some Sort.{?_uniq.17909} @ ⟨88, 27⟩-⟨88, 30⟩</span>\n<span class=\"cm\">          • ℕ : Type @ ⟨88, 27⟩-⟨88, 30⟩</span>\n<span class=\"cm\">        • 1 : ℕ @ ⟨88, 12⟩-⟨88, 13⟩ @ Lean.Elab.Term.elabNumLit</span>\n<span class=\"cm\">      • _example (isBinder := true) : ℕ @ ⟨88, 0⟩-⟨88, 7⟩</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 423209646,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708814387
    },
    {
        "content": "<p>(I am modifying my dreamed up rule to be \"hover and go to definition should work only on the first contiguous set of characters part of a tactic\" :P) -- or even better, use <code>textDocument/implementation</code> for jumping to tactic definitions themselves, though probably it bears checking how other language servers use textDocument/definition vs textDocument/implementation vs textDocument/declaration.</p>",
        "id": 423210822,
        "sender_full_name": "Julian Berman",
        "timestamp": 1708815527
    },
    {
        "content": "<p>Less idly I'm trying to understand what those mean. I assume you basically knew that that output somehow corresponds to how Lean is calculating what range to return for the hover?</p>",
        "id": 423210922,
        "sender_full_name": "Julian Berman",
        "timestamp": 1708815611
    },
    {
        "content": "<p>Oh OK I see, that's literally embedding those ranges in the text there, got it.</p>",
        "id": 423210995,
        "sender_full_name": "Julian Berman",
        "timestamp": 1708815675
    }
]