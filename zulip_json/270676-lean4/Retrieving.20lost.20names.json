[
    {
        "content": "<p>I am working on translating the tactic from my SNARK project into lean4. The tactic repeatedly splits hypotheses of the form <code>a * b = 0</code> into <code>a = 0 \\or b = 0</code> and simplifies. The trouble is, I keep overwriting the name <code>found_zero</code> so when the tactic doesn't close the goal, it leaves a bunch of hypotheses with inaccessible names.</p>\n<p>Is there some tactic that just assigns all the inaccessible names in the environment an arbitrary name so that I can work with them again?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Elab.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"integral_domain_tactic\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">macro_rules</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">integral_domain_tactic</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span>\n      <span class=\"n\">trace</span> <span class=\"s2\">\"Call to integral_domain_tactic\"</span><span class=\"bp\">;</span>\n      <span class=\"n\">trace_state</span><span class=\"bp\">;</span>\n      <span class=\"c1\">-- Factor statements of the form a * b = 0 into a = 0 ∨ b = 0</span>\n      <span class=\"c1\">-- Note that this also eliminates True and False hypotheses</span>\n      <span class=\"n\">simp_all</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">decide</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"n\">failIfUnchanged</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">})</span> <span class=\"n\">only</span> <span class=\"o\">[</span>\n            <span class=\"c1\">-- Basic arithmetic simplifications</span>\n            <span class=\"n\">add_zero</span><span class=\"o\">,</span> <span class=\"n\">zero_add</span><span class=\"o\">,</span> <span class=\"n\">mul_zero</span><span class=\"o\">,</span> <span class=\"n\">zero_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">,</span> <span class=\"n\">one_mul</span><span class=\"o\">,</span>\n            <span class=\"c1\">-- Simplifications for true and false</span>\n            <span class=\"n\">false_or</span><span class=\"o\">,</span> <span class=\"n\">or_false</span><span class=\"o\">,</span> <span class=\"n\">true_or</span><span class=\"o\">,</span> <span class=\"n\">or_true</span><span class=\"o\">,</span> <span class=\"n\">not_true</span><span class=\"o\">,</span> <span class=\"n\">not_false_iff</span><span class=\"o\">,</span>\n            <span class=\"n\">eq_self_iff_true</span><span class=\"o\">,</span> <span class=\"n\">Ne.def</span><span class=\"o\">,</span> <span class=\"n\">one_ne_zero</span><span class=\"o\">,</span> <span class=\"n\">mul_ne_zero_iff</span><span class=\"o\">,</span>\n            <span class=\"c1\">-- Key arithmetic simplification for integral domains: a * b = 0 ↔ a = 0 ∨ b = 0</span>\n            <span class=\"n\">mul_eq_zero</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n      <span class=\"n\">first</span>\n        <span class=\"c1\">-- If we are done, halt</span>\n        <span class=\"bp\">|</span> <span class=\"n\">done</span>\n        <span class=\"c1\">-- If we have a hypothesis of the form a * b = 0, split into a = 0 ∨ b = 0, and recurse</span>\n        <span class=\"bp\">|</span> <span class=\"c1\">--try clear found_zero</span>\n          <span class=\"n\">try</span> <span class=\"n\">rename'</span> <span class=\"n\">found_zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">found_zero_prev</span>\n          <span class=\"n\">try</span> <span class=\"n\">rename'</span> <span class=\"n\">found_zero_prev</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">found_zero_prev_prev</span>\n          <span class=\"n\">cases'</span> <span class=\"o\">‹</span><span class=\"n\">_</span> <span class=\"bp\">∨</span> <span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"k\">with</span> <span class=\"n\">found_zero</span> <span class=\"n\">found_zero</span>\n          <span class=\"n\">all_goals</span> <span class=\"n\">integral_domain_tactic</span>\n        <span class=\"c1\">-- If we cannot split, we skip, leaving the goal unsolved for the user to resolve</span>\n        <span class=\"bp\">|</span> <span class=\"n\">skip</span>\n   <span class=\"o\">)</span>\n\n\n<span class=\"kn\">section</span> <span class=\"n\">test</span>\n\n<span class=\"c1\">-- Per the docs: \"To obtain an integral domain use [CommRing α] [IsDomain α]\"</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsDomain</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n\n<span class=\"c1\">-- If the tactic can't solve the goal, it should leave the cases it found</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">e</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">e</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">integral_domain_tactic</span>\n</code></pre></div>\n<p>The test here results in the state with a case looking like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">case</span> <span class=\"n\">inl.inl</span>\n<span class=\"n\">FR</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝²</span><span class=\"o\">:</span> <span class=\"n\">Field</span> <span class=\"n\">F</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"n\">R</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"n\">IsDomain</span> <span class=\"n\">R</span>\n<span class=\"n\">abcde</span><span class=\"o\">:</span> <span class=\"n\">F</span>\n<span class=\"n\">h3</span><span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"n\">found_zero</span><span class=\"bp\">✝¹</span><span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"n\">found_zero</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">False</span>\n</code></pre></div>",
        "id": 411090661,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1704320150
    },
    {
        "content": "<p>The usual technique used here is to have the tactic accept a list of <code>binderIdent</code> which allows the user to name these variables as they wish</p>",
        "id": 411092338,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704321157
    },
    {
        "content": "<p>It is considered bad practice for a tactic to produce hypotheses with accessible names unless the user wrote them</p>",
        "id": 411092371,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704321181
    },
    {
        "content": "<p>Right, that definitely seems to be the case in the examples I am seeing in mathlib. </p>\n<p>The trouble is, I don't necessarily expect to know how many hypotheses will be split, so I wouldn't know what length of a list to provide. I would really be ok if the split Ors were just named after the hypotheses they split, but I'm not sure how to do that either.</p>",
        "id": 411092526,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1704321288
    },
    {
        "content": "<p>In the example above, for  instance, I could get 4 cases, and it would be cool if the <code>a = 0</code> and <code>c = 0</code> hypotheses were always named <code>h1</code> and the <code>b = 0 </code> and <code>d = 0</code> were always named <code>h2</code>. That seems like a capability that would only be applicable to casing on disjunctions, though.</p>",
        "id": 411092759,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1704321453
    },
    {
        "content": "<p>The idea is that you just have a list and pull things from the list whenever you need a name</p>",
        "id": 411092931,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704321571
    },
    {
        "content": "<p>And I guess I just call the tactic once with a bunch of random names, and then play with the list until the length is right and the names look reasonable?</p>",
        "id": 411093239,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1704321726
    },
    {
        "content": "<p>yeah pretty much</p>",
        "id": 411093272,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704321753
    },
    {
        "content": "<p>Have you ever used the <code>induction' e with ...</code> tactic?</p>",
        "id": 411093290,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704321768
    },
    {
        "content": "<p>you just hunt around with names and underscores until you have the right names in the right places</p>",
        "id": 411093322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704321789
    },
    {
        "content": "<p>I mean the code I provided above uses <code>cases'</code> it's just getting lost in the recursive call somehow.</p>",
        "id": 411093363,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1704321815
    },
    {
        "content": "<p>well you aren't actually passing in names from the caller there, that's why</p>",
        "id": 411093461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704321860
    },
    {
        "content": "<p>although it would be tricky to split a list of names properly in a macro tactic</p>",
        "id": 411093500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704321883
    },
    {
        "content": "<p>(Basically this code is all adapted from a tactic in lean3 from over a year ago, I recall you helped me with it a lot, but I think things work a little differently in lean 3 compared to lean 4)</p>",
        "id": 411093546,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1704321923
    }
]