[
    {
        "content": "<p>Inspired by <span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span>'s PR <a href=\"https://github.com/leanprover/std4/pull/748\">std4#748</a>, I'd like to talk about how we should approach the issue of types being used in nested inductives, in the manner of:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">MyDataStructure</span> <span class=\"n\">Foo</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Foo</span>\n</code></pre></div>\n<p>Let's say that we are making <code>MyDataStructure</code> and want users to be able to write the above. In this case:</p>\n<ul>\n<li><code>MyDataStructure</code> must be an inductive type <del>or definition wrapping one</del>. (In particular it cannot be <code>opaque</code>)</li>\n<li>it must not contain any proofs, subtypes, or well formedness assumptions in it, because these use the value negatively</li>\n</ul>\n<p>It is possible to encode a number of well formedness properties using only inductive types. I once saw a <a href=\"https://coq-workshop.gitlab.io/2023/slides/coq2023_krebbers.pdf\">Coq talk</a> on it. But my takeaway is that this is an extraordinarily painful road to take, and lean has been steadily evolving in the direction of more abstraction hiding and less reliance on definitional equality (e.g. using proofs by well founded recursion).</p>\n<p>Nested inductives, as they are currently designed, are fundamentally abstraction breaking. If you write an inductive such as the one above, the <code>Foo.rec</code> theorem will write out all the details of every inductive type involved in the definition of <code>MyDataStructure</code>. This does not have to be the case; the way inductives are handled in Isabelle, adapted to lean with the <a href=\"https://github.com/alexkeizer/QpfTypes\">QPF</a> package, uses something closer to typeclasses asserting that <code>MyDataStructure</code> is suitably functorial, and does not involve unwrapping any definitions.</p>\n<p>It is undeniably a use case that people will want these kind of inductive types, but I am not sure following that thread will take us in a good direction. I'm curious how other people think we should approach this issue in the standard library and elsewhere.</p>",
        "id": 433823306,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713369604
    },
    {
        "content": "<p>I had serious trouble recently because I could not nest under <code>IO</code>, even though if unrolled completely, it would be a positive occurrence, I believe, and had to work around it. So more flexibility here might have helped me.</p>",
        "id": 433827428,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713370713
    },
    {
        "content": "<p>ah, so actually my \"or definition wrapping one\" is not true</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"c1\">-- ok</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Foo</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">List'</span> <span class=\"o\">:=</span> <span class=\"n\">List</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Foo'</span> <span class=\"c1\">-- fail</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">List'</span> <span class=\"n\">Foo'</span> <span class=\"bp\">→</span> <span class=\"n\">Foo'</span>\n</code></pre></div>",
        "id": 433828197,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713371002
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/Nested-inductive-safe.20types/near/433827428\">said</a>:</p>\n<blockquote>\n<p>I had serious trouble recently because I could not nest under <code>IO</code>, even though if unrolled completely, it would be a positive occurrence, I believe, and had to work around it. So more flexibility here might have helped me.</p>\n</blockquote>\n<p>This is another case where if we had gone this way it would end up with backward incentives, since if we make <code>IO</code> nested-inductive-safe (and promise this for the future), then we can't also make it <code>opaque</code></p>",
        "id": 433829424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713371405
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> For something like <code>HashMap</code>, I would want to consider the following things to be the public API:</p>\n<ul>\n<li>That there is a type <code>HashMap</code> that is not necessarily safe to use in nested inductives</li>\n<li>That there is a type <code>HashMap.Imp</code> (perhaps deserving to be renamed) that is safe to use in nested inductives</li>\n<li>All of the operations on <code>HashMap</code> and <code>HashMap.Imp</code> like <code>insert</code>, <code>findEntry?</code>, etc.</li>\n<li>That there is a predicate <code>HashMap.Imp.WF</code> that is preserved by the operations that modify the hash map</li>\n<li>All of the (mostly yet-to-be-developed) lemmas for <code>HashMap.Imp</code> and <code>HashMap</code>, with the <code>HashMap.Imp</code> lemmas taking an extra <code>HashMap.Imp.WF</code></li>\n<li>(Maybe) an equivalence between <code>HashMap</code> and <code>{ m : HashMap.Imp // m.WF }</code> that is compatible with all of the operations</li>\n</ul>\n<p>There are other things that I would not consider to be part of the public API, for example</p>\n<ul>\n<li>The definitions of <code>HashMap.Imp</code> and <code>HashMap</code></li>\n<li>Things like <code>HashMap.rec</code> and <code>HashMap.Imp.rec</code></li>\n<li>Helper functions like <code>reinsertAux</code></li>\n</ul>\n<p>I agree that making sure that <code>HashMap.Imp</code> is usable in nested inductives now and in the future is somewhat annoying given what is currently possible in Lean. I also agree with you that today it is not possible to prevent users from relying on the things that I do not consider to be part of the public API on a technical level. I do however think that as long as we clearly communicate our promises and non-promises in the documentation, it's acceptable to be abstraction-breaking on a  technical level, and if users choose to ignore that, they will have to adapt their developments. I also think that it is worth the effort to support usability of our datastructures in nested inductives starting now, and that this does not prevent us from taking advantage of better technical solutions like the ones you referenced, should they become available in the future.</p>",
        "id": 434013032,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1713435124
    },
    {
        "content": "<p>Wouldn't it be preferable if <code>HashMap</code> was safe to use in nested inductives and <code>HashMap.Imp</code> could remain an implementation detail?</p>",
        "id": 434197886,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1713458110
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260921\">Markus Himmel</span> <a href=\"#narrow/stream/270676-lean4/topic/Nested-inductive-safe.20types/near/434013032\">said</a>:</p>\n<blockquote>\n<p>There are other things that I would not consider to be part of the public API, for example</p>\n<ul>\n<li>Things like <code>HashMap.rec</code> and <code>HashMap.Imp.rec</code></li>\n</ul>\n</blockquote>\n<p>Note that I didn't say <code>MyDataStructure.rec</code> in the above description, I said <code>Foo.rec</code>. When someone writes a nested inductive involving <code>HashMap.Imp</code>, the definition of <code>HashMap.Imp</code> is made visible as part of <code>Foo.rec</code>, and I regard this as a major privacy violation given that we can't reasonably ask people not to use <code>Foo.rec</code> (how else would they make use of the nested inductive they just defined?), but it still contains basically the same information as <code>HashMap.Imp.rec</code> (which we want to be private).</p>",
        "id": 434204168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713459867
    },
    {
        "content": "<blockquote>\n<p>I also think that it is worth the effort to support usability of our datastructures in nested inductives starting now, and that this does not prevent us from taking advantage of better technical solutions like the ones you referenced, should they become available in the future.</p>\n</blockquote>\n<p>When this means things like \"definitions are not allowed\", I just can't bring myself to agree with this. Nested inductives are a poorly supported feature in lean already, and they have some structural problems. Bending over backwards to support them in our data structures is going to actively make them worse along other axes and also will take more work to revert once we have a better mechanism that doesn't leak these details and will just allow people to write <code>inductive Foo | mk: HashMap A Foo -&gt; Foo</code> which is what they want anyway.</p>",
        "id": 434205201,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713460242
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Nested-inductive-safe.20types/near/434204168\">said</a>:</p>\n<blockquote>\n<p>When someone writes a nested inductive involving <code>HashMap.Imp</code>, the definition of <code>HashMap.Imp</code> is made visible as part of <code>Foo.rec</code>, and I regard this as a major privacy violation given that we can't reasonably ask people not to use <code>Foo.rec</code> (how else would they make use of the nested inductive they just defined?), but it still contains basically the same information as <code>HashMap.Imp.rec</code> (which we want to be private).</p>\n</blockquote>\n<p>This is a good point, however I would expect that almost everyone uses the equation compiler/pattern matching instead of invoking <code>Foo.rec</code> directly, and with that you only get exposed to the internals of the data structure if you actively force it. So I think this is a non-issue in almost all practical applications.</p>",
        "id": 434301904,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1713511579
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Nested-inductive-safe.20types/near/434205201\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I also think that it is worth the effort to support usability of our datastructures in nested inductives starting now, and that this does not prevent us from taking advantage of better technical solutions like the ones you referenced, should they become available in the future.</p>\n</blockquote>\n<p>When this means things like \"definitions are not allowed\", I just can't bring myself to agree with this. Nested inductives are a poorly supported feature in lean already, and they have some structural problems. Bending over backwards to support them in our data structures is going to actively make them worse along other axes and also will take more work to revert once we have a better mechanism that doesn't leak these details and will just allow people to write <code>inductive Foo | mk: HashMap A Foo -&gt; Foo</code> which is what they want anyway.</p>\n</blockquote>\n<p>I agree that the current state of what's possible in Lean is not great, and I think that it is a very good idea to explore ways to make this better. However, at least for the map-like data structures in Std, it's really not that bad: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.RBNode#doc\">docs#Std.RBNode</a> already works in nested inductive types without any changes, and the changes in <a href=\"https://github.com/leanprover/std4/pull/748\">std4#748</a> seem innocous enough to me.</p>",
        "id": 434303120,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1713512029
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260921\">Markus Himmel</span> <a href=\"#narrow/stream/270676-lean4/topic/Nested-inductive-safe.20types/near/434301904\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/Nested-inductive-safe.20types/near/434204168\">said</a>:</p>\n<blockquote>\n<p>When someone writes a nested inductive involving <code>HashMap.Imp</code>, the definition of <code>HashMap.Imp</code> is made visible as part of <code>Foo.rec</code>, and I regard this as a major privacy violation given that we can't reasonably ask people not to use <code>Foo.rec</code> (how else would they make use of the nested inductive they just defined?), but it still contains basically the same information as <code>HashMap.Imp.rec</code> (which we want to be private).</p>\n</blockquote>\n<p>This is a good point, however I would expect that almost everyone uses the equation compiler/pattern matching instead of invoking <code>Foo.rec</code> directly, and with that you only get exposed to the internals of the data structure if you actively force it. So I think this is a non-issue in almost all practical applications.</p>\n</blockquote>\n<p>I agree to an extent, but it is frequently the case that this is insufficient; we are still missing a lot of tools needed to be able to make definitions over such nested inductives such that well founded recursion works correctly. As long as it's all <code>partial</code> functions there isn't too much issue though.</p>",
        "id": 434324950,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713519526
    }
]