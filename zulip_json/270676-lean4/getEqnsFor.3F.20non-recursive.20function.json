[
    {
        "content": "<p>Is there a way to get nicer equational lemmas for non-recursive functions than what is currently returned by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.getEqnsFor%3F#doc\">docs4#Lean.Meta.getEqnsFor?</a>? For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Bool.toNat</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">Lean.Meta.getEqnsFor</span><span class=\"bp\">?</span> <span class=\"bp\">``</span><span class=\"n\">Bool.toNat</span> <span class=\"o\">(</span><span class=\"n\">nonRec</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">Bool.toNat._eq_1</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Bool.toNat._eq_1 (x✝ : Bool) :</span>\n<span class=\"cm\">  Bool.toNat x✝ =</span>\n<span class=\"cm\">    match x✝ with</span>\n<span class=\"cm\">    | false =&gt; 0</span>\n<span class=\"cm\">    | true =&gt; 1</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>When I was hoping it would return two equations:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Bool.toNat._eq_1</span> <span class=\"n\">false</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"n\">Bool.toNat._eq_2</span> <span class=\"n\">true</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Works great for recursive functions</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>Interestingly, it works great for recursive functions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fact</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">fact</span> <span class=\"n\">n</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">Lean.Meta.getEqnsFor</span><span class=\"bp\">?</span> <span class=\"bp\">``</span><span class=\"n\">fact</span>\n<span class=\"k\">#check</span> <span class=\"n\">fact._eq_1</span> <span class=\"c1\">-- fact._eq_1 : fact 0 = 1</span>\n<span class=\"k\">#check</span> <span class=\"n\">fact._eq_2</span> <span class=\"c1\">-- fact._eq_2 (n : Nat) : fact (Nat.succ n) = (n + 1) * fact n</span>\n</code></pre></div>\n<p>Though not for non-trivial ones:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Bool.toZero</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">_h</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">true</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">toZero</span> <span class=\"n\">false</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">toZero</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">b.toNat</span>\n<span class=\"n\">decreasing_by</span> <span class=\"n\">simp_wf</span><span class=\"bp\">;</span> <span class=\"n\">simp_arith</span> <span class=\"o\">[</span><span class=\"n\">Bool.toNat</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">Lean.Meta.getEqnsFor</span><span class=\"bp\">?</span> <span class=\"bp\">``</span><span class=\"n\">Bool.toZero</span>\n<span class=\"k\">#check</span> <span class=\"n\">Bool.toZero._eq_1</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Bool.toZero._eq_1 (b : Bool) :</span>\n<span class=\"cm\">  Bool.toZero b =</span>\n<span class=\"cm\">    match _h : b with</span>\n<span class=\"cm\">    | false =&gt; 0</span>\n<span class=\"cm\">    | true =&gt; Bool.toZero false</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n</div></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Sidenote on doc-gen4</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>It would also be nice to have this for doc-gen4, as currently the output for non-recursive definitions can be suboptimal (cf. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Bool.toLBool#doc\">docs4#Bool.toLBool</a>).</p>\n</div></div>",
        "id": 411706112,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1704708441
    },
    {
        "content": "<p>Pinging this, as I haven't found a solution yet.</p>",
        "id": 433986956,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1713427397
    },
    {
        "content": "<p>It's on the roadmap. We want </p>\n<ul>\n<li>equation lemmas and induction principles for all functions, not just recursive ones</li>\n<li>use the same case-splittint heuristic for all of them</li>\n</ul>",
        "id": 433988702,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713427987
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 433989393,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1713428225
    },
    {
        "content": "<p>Perhaps <a href=\"https://github.com/leanprover/lean4/pull/2042\">lean#2042</a> should be re-opened, which was intended to track this?</p>",
        "id": 433995390,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713429379
    }
]