[
    {
        "content": "<p>Hi! I just started learning Lean 4 and I cannot understand the precise semantics and differences between <code>let</code>, <code>have</code>, <code>show</code> and <code>assume</code>. I haven't found any reference that explains in detail. Can someone clarify this for me?</p>",
        "id": 426814536,
        "sender_full_name": "Artur Chakhvadze",
        "timestamp": 1710533429
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"701512\">@Artur Chakhvadze</span> <br>\n First, of those, only <code>let</code> can be used as a term; the rest are all only applicable in tactic mode.</p>\n<p><code>let</code> defines a variable (which can be a function or a type, since those are all 'first class' in Lean -- that is, you can compute on them.)</p>",
        "id": 426817847,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710534899
    },
    {
        "content": "<p><code>have</code> is like <code>let</code>, but assumes you only care about the type, so it throws away the actual definition. This is mostly useful for <code>Prop</code>s where the definition is a proof, and all you really care about is that the <code>Prop</code> is inhabited and not which specific proof you used to inhabit it (proof-irrelevance).</p>",
        "id": 426818012,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710534970
    },
    {
        "content": "<p><code>have</code> can be used in term mode too:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 426819182,
        "sender_full_name": "Julian Berman",
        "timestamp": 1710535557
    },
    {
        "content": "<p>... huh. I literally just tried that to double check and got errors<br>\noh, whoops, I typo'd. Nevermind! Then yes, <code>let</code> and <code>have</code> can both be used in term-mode</p>",
        "id": 426819293,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710535602
    },
    {
        "content": "<p>It looks like <code>show</code> works in term mode as well:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"k\">show</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"k\">from</span> <span class=\"n\">Eq.refl</span> <span class=\"mi\">2</span>\n</code></pre></div>",
        "id": 426819423,
        "sender_full_name": "Julian Berman",
        "timestamp": 1710535674
    },
    {
        "content": "<p>Ah, that's <code>show ... from...</code>, which is not the same as <code>show</code>. But I suppose that's a quibble.</p>",
        "id": 426819527,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710535712
    },
    {
        "content": "<p>I think the important bit is less what mode they work in. I'd add <code>obtain</code> and <code>rcases</code> as others which are \"kind of similar\".</p>",
        "id": 426819627,
        "sender_full_name": "Julian Berman",
        "timestamp": 1710535752
    },
    {
        "content": "<p>I'm actually typing up an explanation, but keep getting interrupted :v</p>",
        "id": 426819665,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710535774
    },
    {
        "content": "<p>Oh I'll keep quiet then :) go for it.</p>",
        "id": 426819779,
        "sender_full_name": "Julian Berman",
        "timestamp": 1710535806
    },
    {
        "content": "<p><code>show t</code> looks for a goal that unifies with <code>t</code>, which means it looks for a goal whose type is compatible with <code>t</code>. If <code>t</code> is a complete term, that means it needs to have the same type as <code>t</code>; if <code>t</code> has holes (<code>_</code>s) or metavariables (like <code>?foo</code>), it looks for a goal for which some substitution of the holes and metavariables <em>could</em> be the same type as <code>t</code>.  It makes that the current active goal and replaces the statement of the goal with <code>t</code>, with as many holes and metavariables filled in as it can infer.</p>\n<p>(There is a detail here I don't actually know, which is the precise transparency level <code>show</code> works on when unifying. I suspect it works up to reducibility, but it may only work up to definitional equality. For a good overview of the difference, see  <a href=\"#narrow/stream/270676-lean4/topic/is.20there.20a.20way.20to.20rename.20a.20type.20such.20as.20N.20.3A.3D.20Nat/near/412885883.\">this post</a>)</p>",
        "id": 426820112,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710535953
    },
    {
        "content": "<p>(I said I'd be quiet :), but since I suspect there's a chance someone new doesn't know what a few of those words mean, I think a \"simplified\" version of what <code>show</code> does is is it expresses \"I have some goal, but I think that goal is really equivalent to a different one, so I'm telling Lean I'm going to prove the other equivalent goal and that it should be happy with that\".</p>\n<p>The details of what \"equivalent\" and \"should be happy with\" are what Robert explained with more precise words.)</p>",
        "id": 426820567,
        "sender_full_name": "Julian Berman",
        "timestamp": 1710536150
    },
    {
        "content": "<p><code>show p from t</code> involves <code>let_fun</code>, which is a bit confusing (at least to me!) so I'm going to skim over the details; it essentially constructs a term of type <code>p</code> from the argument <code>t</code>. <code>from</code> means it's working in term mode, so <code>t</code> should be a 'function' (or theorem, which is just a function on <code>Prop</code>s) that returns something of type <code>p</code>.</p>\n<p>Alternatively, you can use <code>show p by t</code>, which is equivalent to <code>show p from by t</code> but looks less silly; it moves into tactic mode and constructs a <code>p</code> by the tactic(s) <code>t</code>.</p>",
        "id": 426821244,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710536414
    },
    {
        "content": "<p>aaaand I don't think <code>assume</code> is actually a thing! At least, Lean doesn't recognize it and I don't see any hits for <code>assume</code> outside of comments in the github.</p>",
        "id": 426821678,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710536593
    },
    {
        "content": "<p>aight, done, you can correct me at well now :p</p>",
        "id": 426821873,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710536676
    },
    {
        "content": "<p>Thanks a lot for explaining everything in such detail! It is a shame that the official documentation doesn't have a page with those explanations.</p>\n<p>I think I saw <code>assume</code> in some Lean 3 snippets and it probably isn't a thing in Lean 4 anymore.</p>\n<p>One last question I have -- why do two first examples typecheck and the last one with <code>have</code> shows an error?<br>\n<a href=\"/user_uploads/3121/O0OHqP-PEQHQJ5pDadG7Xpvn/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/O0OHqP-PEQHQJ5pDadG7Xpvn/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/O0OHqP-PEQHQJ5pDadG7Xpvn/image.png\"></a></div>",
        "id": 426822445,
        "sender_full_name": "Artur Chakhvadze",
        "timestamp": 1710536964
    },
    {
        "content": "<p>One thing I do recommend is to get your own copy of Mathlib in VSCode and abuse the hell out of the hover feature; it lets gives you quick access to all the docstring comments, which are honestly the principal source of documentation in Lean and Mathlib</p>",
        "id": 426823277,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710537353
    },
    {
        "content": "<p>it also lets you go-to-definition in a pinch, tho that can be very dense</p>",
        "id": 426823340,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710537369
    },
    {
        "content": "<p>w.r.t. example: so, as a side note, there's the <em>theorem</em> <code>rfl</code>, which is a term of type <code> ∀ {α : Sort u} {a : α}, a = a</code>; and then there's the <em>tactic</em> <code>rfl</code>, which is a much stronger low-level tactic that will do quite a bit more. so most of the time you will probably want <code>:= by rfl</code> instead of <code>:= rfl</code></p>\n<p>Anyway that's kind of orthogonal to your actual question lol. I'm not entirely sure why that happens, but I can at least give you the first step:</p>",
        "id": 426824035,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710537778
    },
    {
        "content": "<p>So, details on <code>show ... from ...</code> after all: <code>show p from t</code> is sugar for <code>((fun this =&gt; t) this) : p</code>; that is, it makes a constant function <code>fun _ =&gt; t</code>, calls it on a dummy value, and then asserts the output has type <code>p</code>. This expansion passes through a <code>let_fun</code> definition that I <em>believe</em> is also how top-level definitions and theorems are implemented under the hood; they're both defined in such a way that the unification/type inference system, which is pretty powerful in Lean, has a chance to compare the intended and actual results before the type checker has to do its final verification.</p>",
        "id": 426824837,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710538139
    },
    {
        "content": "<p>I had <em>thought</em> that <code>have</code> also went through <code>let_fun</code> like that, but maybe not? Or maybe I'm just barking up the wrong tree entirely</p>",
        "id": 426825214,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710538318
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"701512\">Artur Chakhvadze</span> <a href=\"#narrow/stream/270676-lean4/topic/Let.2C.20have.2C.20show.20and.20assume/near/426822445\">said</a>:</p>\n<blockquote>\n<p>I think I saw <code>assume</code> in some Lean 3 snippets and it probably isn't a thing in Lean 4 anymore.</p>\n</blockquote>\n<p>It's spelled <code>intro</code> now</p>",
        "id": 426829201,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710540211
    }
]