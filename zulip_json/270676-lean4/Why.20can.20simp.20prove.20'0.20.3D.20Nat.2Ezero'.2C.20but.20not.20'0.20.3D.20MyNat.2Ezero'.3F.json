[
    {
        "content": "<p>I'm using Lean 4.5.0-rc1.</p>\n<p>simp can prove <code>0 = Nat.zero</code>, in fact without using any identities at all:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">Nat.zero</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[]</span>\n</code></pre></div>\n<p>However now let's try it with my own definition MyNat of natural numbers:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">MyNat</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">â†’</span> <span class=\"n\">MyNat</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MyNat</span> <span class=\"o\">(</span><span class=\"n\">zero</span> <span class=\"n\">succ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">MyNat</span> <span class=\"mi\">0</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"n\">zero</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">MyNat.zero</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[]</span>\n</code></pre></div>\n<p>I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span> <span class=\"n\">made</span> <span class=\"n\">no</span> <span class=\"n\">progress</span>\n</code></pre></div>\n<p>Why is this?</p>\n<p>This may seem like a technicality, but actually it makes proving some theorems less convenient.  Consider this example from the chapter \"Inductive Types\" in \"Theorem Proving in Lean 4\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">zero_add</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">add_zero</span><span class=\"o\">,</span> <span class=\"n\">add_succ</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>It works with the builtin Nat type, but fails with MyNat, precisely because simp can't resolve the base case which is similar to <code>0 = Nat.zero</code>.</p>",
        "id": 418803278,
        "sender_full_name": "Adam Dingle",
        "timestamp": 1706609166
    },
    {
        "content": "<p>Does it work if you add an <code>instance : Zero MyNat</code> instead?</p>",
        "id": 418804840,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1706609777
    },
    {
        "content": "<p>OK, I just tried that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Zero</span> <span class=\"n\">MyNat</span> <span class=\"n\">where</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"n\">zero</span>\n</code></pre></div>\n<p>The result is the same: \"simp made no progress\".  (Actually I would have slightly surprised if this made a difference, since Zero is in MathLib and simp is outside it.)</p>",
        "id": 418826701,
        "sender_full_name": "Adam Dingle",
        "timestamp": 1706618087
    },
    {
        "content": "<p><code>set_option trace.Meta.Tactic.simp true in</code> before your declaration will tell what <code>simp</code> is thinking</p>",
        "id": 418827154,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1706618282
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/stream/270676-lean4/topic/Why.20can.20simp.20prove.20'0.20.3D.20Nat.2Ezero'.2C.20but.20not.20'0.20.3D.20MyNat.2Ezero'.3F/near/418827154\">said</a>:</p>\n<blockquote>\n<p><code>set_option trace.Meta.Tactic.simp true in</code> before your declaration will tell what <code>simp</code> is thinking</p>\n</blockquote>\n<p>That's a useful hint.  I just enabled this option.  When simp proves that <code>0 = Nat.zero</code>, it reports</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.rewrite</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">eq_self</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">Nat.zero</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">True</span>\n</code></pre></div>\n<p>I'm a bit surprised that it's using eq_self, since I thought that the <code>only</code> option tells it to use no identities at all, but perhaps eq_self is special.</p>\n<p>When it fails to prove that <code>0 = MyNat.zero</code>, it reports</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.unify</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">eq_self</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">unify</span>\n      <span class=\"bp\">?</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">?</span><span class=\"n\">a</span>\n    <span class=\"k\">with</span>\n      <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">MyNat.zero</span>\n</code></pre></div>",
        "id": 418831674,
        "sender_full_name": "Adam Dingle",
        "timestamp": 1706619941
    },
    {
        "content": "<p>I do think <code>Nat</code> has quite a lot of specific support written into the Lean tooling</p>",
        "id": 418833315,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706620607
    },
    {
        "content": "<p>Also, <code>simp only</code> really means that you ask <code>simp</code> to only use the <code>simpOnlyBuiltins</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Elab.Tactic.Simp</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">Lean.Elab.Tactic.simpOnlyBuiltins</span>\n<span class=\"c1\">--  [`eq_self, `iff_self]</span>\n</code></pre></div>",
        "id": 418847320,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1706625038
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/270676-lean4/topic/Why.20can.20simp.20prove.20'0.20.3D.20Nat.2Ezero'.2C.20but.20not.20'0.20.3D.20MyNat.2Ezero'.3F/near/418847320\">said</a>:</p>\n<blockquote>\n<p>Also, <code>simp only</code> really means that you ask <code>simp</code> to only use the <code>simpOnlyBuiltins</code></p>\n</blockquote>\n<p>Aha.  Thanks, that's helpful.</p>",
        "id": 418853823,
        "sender_full_name": "Adam Dingle",
        "timestamp": 1706626488
    }
]