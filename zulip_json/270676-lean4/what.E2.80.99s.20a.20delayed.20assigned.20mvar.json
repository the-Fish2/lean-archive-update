[
    {
        "content": "<p>Today, <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  very helpfully and patiently explained to me what delayed assigned mvars are to me, thanks for that! I thought I’d write down the explanation in my own words, in case it’s useful to anyone else.</p>\n<p>A crucial operations on expressions is substitution (<code>e[s/x]</code>). But our expression have holes (metavariables) <code>?m</code>, and we can’t perform the substitution until we know the value for <code>?m</code> and have replaced <code>?m</code> with that value. So what do we do?</p>\n<p>We <em>could</em> add explicit substitution to our <code>Expr</code>. But that would be annoying, it’s yet another constructor to worry about at each <code>Expr</code> traversal, and a complex one at that (as it would likely have to be simultaneous substitution, turning <code>Expr</code> into a nested inductive data type). And since we can’t do much with such a unresolved substitution, just like with a normal hole <code>?m</code>, we allow such substitions not everwhere, but only as the value of a MVar <code>?n</code> (the “delayed assigned MVar”), and around another MVar. And because it makes things simpler, we store in <code>?n</code> only <code>x</code> and <code>?m</code> (i.e. the hole we want to substitute into and the variable in <code>?m</code>’s context we want to substitute for), and keep <code>s</code> as an “argument” to <code>?n</code> (so <code>?n s</code> somewhere).</p>\n<p>Now when instantiating MVars, when we come across the application <code>?n s</code>, we can check if <code>?m</code> has been assigned (to <code>val</code>) and then replace <code>?n s</code> with <code>val[s/x]</code>.</p>\n<p>Maybe they should be called  “MVar substituting MVars” :-)</p>\n<p>TL;DR: If we had explicit substitution in <code>Expr</code>, we would not need delayed assigned mvars. In that sense, they are a mechanism that keeps such unresolved substitutions out of sight.</p>",
        "id": 424070237,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1709227497
    },
    {
        "content": "<p>It’s nice to take time to report on this, but it will get lost very quickly. Shouldn’t you try to put that somewhere in a docstring or comment?</p>",
        "id": 424071928,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709227975
    },
    {
        "content": "<p>Kyle has  a PR with helpful docstrings in <a href=\"https://github.com/leanprover/lean4/pull/3494\">https://github.com/leanprover/lean4/pull/3494</a>, so improvement will happen. I am not sure if my particular way of putting it is the most useful one, or even fully correct,  anyways :-)</p>",
        "id": 424072215,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1709228058
    },
    {
        "content": "<p>I think you need a 4 in your repo name: you can also just <a href=\"https://github.com/leanprover/lean4/pull/3494\">lean#3494</a></p>",
        "id": 424077746,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1709229752
    },
    {
        "content": "<p>That PR is an attempt to help make delayed assignment metavariables less mysterious.</p>\n<p>If you have ever been confused why writing <code>let f := fun x y =&gt; ?foo</code> results in <code>f := fun x y =&gt; ?m.123 x y</code>, what this PR does is make it pretty print as <code>f := fun x y =&gt; ?foo(x := x, y := y)</code> to show that what's under the binder is <code>?foo</code> with it's local variable <code>x</code> substituted for the binder <code>x</code> and it's local <code>y</code> for the binder <code>y</code>.</p>\n<p>This linkage between <code>?m.123</code> and <code>?foo</code> is called a delayed assignment. Lean maintains a table of these delayed assignments, but it does not currently expose the linkage to to the user.</p>",
        "id": 424082566,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709231430
    },
    {
        "content": "<p>Please give <a href=\"https://github.com/leanprover/lean4/pull/3494\">lean4#3494</a> a <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> if this is a feature you think would be helpful to have. It is not currently on the roadmap, and this would be used to gauge interest.</p>",
        "id": 424082714,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709231483
    },
    {
        "content": "<p>The syntax <code>?foo(x := a, y := b)</code> is meant to be the \"Lean version\" of <code>?foo[a/x,b/y]</code>. Using parentheses keeps it out of the way of GetElem notation, and it also can't be confused for function application since function application must have a space after the function.</p>",
        "id": 424083110,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709231619
    },
    {
        "content": "<p>To add a bit to this thread, here's what I've learned about delayed mvars (also mostly from <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, so thank you! :) )—it's meant to be a bit more long-form. I thought I'd put my perspective here just in case it aids understanding for anyone trying to learn about delayed mvars. :)</p>",
        "id": 424546576,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1709502881
    },
    {
        "content": "<p>Delayed-assigned mvars have two important (conceptual) properties that distinguish them from ordinary mvars: namely, they are what I’ll call “fvar-abstracting” and “instantiation-blocked”.</p>\n<p>Ordinary, run-of-the-mill metavariable assignment has two important aspects. it both:</p>\n<ol>\n<li>is constituted by data which tells us what expression a given mvar points to</li>\n<li>has the effect of allowing us to instantiate that mvar to its assignment in whatever expression it appears<br>\nThese usually go hand in hand: if we assign an mvar, then we can instantiate it. Not so with delayed-assigned mvars: we <em>have</em> the assignment data as soon as the delayed-assigned mvar is created: we record in a table that <code>?m.23</code> points to <code>?a</code>, for example. But this doesn’t have the same effect as an ordinary assignment, because we’re not allowed to <em>instantiate</em> the delayed-assigned mvar when it appears in expressions yet. In this sense a delayed-assigned mvar is <em>instantiation-blocked</em>.</li>\n</ol>\n<p>This is part of why the name “delayed-assigned metavariable” is a bit confusing: the assignment <em>itself</em> (considered as the recording of “pointing data”) has not been delayed. (In fact, it occurs immediately, as soon as the delayed-assigned mvar is formed.) However, the <em>effect</em> of that assignment <em>is</em> delayed.</p>\n<p>Another reason the name is a bit confusing is because it doesn’t mention the other distinctive function of delayed-assigned mvars. Delayed-assigned mvars are assigned to an mvar <code>?a</code> while being aware of certain extra fvars in its context, and those fvars are themselves part of the assignment data. We might schematically write <code>?m.23 := ([fvars], ?a)</code> where <code>[fvars]</code> is a list of (new) fvars in <code>?a</code>’s local context. This kind of looks and functions like a lambda-abstraction: we might suggestively imagine this assignment as representing <code>?m.23 := fun fvars =&gt; ?a</code>.</p>\n<p>It’s in this sense that a delayed-assigned mvar like <code>?m.23</code> is <em>fvar-abstracting</em>: it knows what fvars to abstract in whatever it’s assigned to.</p>\n<p>It’s important to note that an mvarId like <code>?a</code> which has its fvars “abstracted” by a delayed-assigned mvar like <code>?m.23</code> knows nothing about this abstraction. All of <code>?a</code>’s fvars are equivalent from <code>?a</code>’s perspective. The “binding” of these fvars is known only to the delayed-assigned mvar. Hence, different delayed-assigned mvars could in principle abstract different fvars of the same mvar! This never (directly) happens in practice (unless you’re using the sneak-preview of Kyle’s fvar-substitution elaborator). But if it did, nothing would go wrong. The substitution of other terms (<code>[xs]</code>) for certain fvars takes place when the delayed-assigned mvar can finally be instantiated, and the ordinary mvar it’s assigned to knows nothing about this process.</p>\n<p>There’s actually a third subtle difference between delayed-assigned mvars and ordinary ones which you’re likely implicitly aware of by now: delayed-assigned mvars are always assigned directly to ordinary mvarIds, as mvarIds are the only things that intrinsically have local contexts. It wouldn’t make sense to talk about the local context of an expression intrinsically (given how Lean works).</p>\n<p>But why did we need to do any of this? What problems do these two properties solve? The fundamental desire is to have a metavariable <code>?a</code> in <code>fun xs =&gt; ?a</code> whose local context effectively includes <code>xs</code>. Just as there are two distinctive properties of delayed-assigned mvars, there are two problems if we don’t have delayed-assigned mvars:</p>\n<ol>\n<li>if <code>?a</code> is unassigned, we don’t have a way of substituting in for the <code>xs</code> we want to be in its local context (suppose we were to e.g. try to beta-reduce <code>(fun xs =&gt; ?a) [ys]</code>)</li>\n<li>we have no mechanism of actually linking the bound variables <code>xs</code> in <code>fun xs</code> to the local decls in the new local context of <code>?a</code> in the first place.</li>\n</ol>\n<p>Instantiation-blocking solves the first problem, and fvar-abstraction solves the second.</p>\n<h3>Implementation sketch</h3>\n<p>To say that <code>?m.23</code> “behaves like a lambda expression” is equivalent to saying that for any sequence of ordinary terms <code>[xs]</code> which we wish to apply the lambda to, <code>?m.23 [xs] := ?a[fvars/xs]</code>. To evaluate the expression <code>?m.23 [xs]</code>, we substitute those arguments in for the fvars in <code>?a</code> which are recorded in the assignment data of <code>?m.23</code>, just as we would do if the fvars were actually bound in <code>?m.23</code> and we were performing beta reduction. This is why <code>fun xs =&gt; ?a</code> becomes <code>fun xs =&gt; ?m.23 xs</code>: this is morally the same as <code>fun xs =&gt; (fun fvars =&gt; ?a) xs</code>, which is morally equivalent to simply <code>fun fvars =&gt; ?a</code>.</p>\n<p>Lean’s implementation collapses the “abstraction” step and the “beta reduction” step into one step, and, when <code>?a</code> has been fully (recursively) assigned to some expression <code>e</code> not containing unassigned mvars, substitutes the arguments <code>[xs]</code> in for the fvars occurring in <code>e</code> directly.</p>\n<h3>Alternate universes</h3>\n<p>But it didn’t have to be this way: instead of substituting the <code>[xs]</code> directly into the (fully-instantiated) expression <code>?a</code> was assigned to, we could instantiate <code>?m.23</code> directly to an actual lambda <code>← mkLambdaFVars fvars q(?a)</code>, and then use beta-reduction on the application of this lambda to <code>[xs]</code>. There’s nothing wrong with this in principle—maybe performance concerns are relevant, though, I’m not sure.</p>\n<p>Further, we don’t actually have to wait until <code>?a</code> is fully-assigned to make progress during instantiation. As long as <code>?a</code> is at least <em>partially</em> assigned (that is, assigned to <em>something</em>, but such that instantiating <code>?a</code> may result in an expression with unassigned mvars), we could actually abstract the fvars with <code>mkLambdaFVars</code> during instantiation, which would “propagate the delayed assignment” by creating <em>new</em> delayed-assigned mvars whenever we encountered an unassigned mvar. That would abstract the appropriate fvars in <em>those</em> mvars. (This is how mkLambdaFvars works anyway. In fact, this is how delayed-assigned mvars get created behind the scenes when elaborating <code>fun x =&gt; ?a</code>!). Having created a lambda, we would then do ordinary beta reduction with <code>[xs]</code> instead of substituting them directly, and would be able to at least make progress instantiating a delayed-assigned mvar.</p>\n<h3>…and why we’re not in them</h3>\n<p>Another alternate way you might think of solving problem (2) (linking bound variables <code>fun xs</code> to the context of <code>?a</code>) is with <code>let</code> decls: e.g. <code>?a</code> gets the let decl <code>let x := x</code>. The reason we can’t simply do this in Lean, however, is that we’d be exposing a bound variable as a value in <code>?a</code>’s context—the <code>x</code> on the rhs of <code>let x := x</code> is really <code>#0</code>—which would break MetaM functions. (You can’t <code>inferType</code> on a <code>.bvar</code> like <code>#0 </code>, for instance.) Lean would require a third kind of declaration (a <code>.bdecl</code>?) to even try to handle things this way, and all the complication that brings with it. Plus, this would irrevocably tie <code>?a</code> to its use in that expression without careful transformations (what does <code>#0 </code> mean if you use <code>?a</code> somewhere else?), so there are probably other contracts that this approach would break.</p>\n<p>In a similar vein, we could use fvar-binding expression constructors: <code>fun x =&gt; ?a</code> could elaborate to <code>fun x =&gt; flet x := x; ?a</code> where <code>flet</code> actually did bind an fvar instead of using bound variables. This is basically equivalent to defining a substitution expression constructor, as mentioned above: <code>flet fvars := xs; e</code> is equivalent to <code>e[xs/fvars]</code> (Kyle’s elaborator essentially lets us emulate this in user-facing syntax using delayed-assigned mvars when <code>e</code> is a metavariable <code>?a</code> as <code>?a(fvar := x)</code>.) But this would require two things: 1) reduction of these <code>flet</code>s/substitutions would have to be analogously “zeta-blocked”  and respect mvar (un)assignment (you couldn’t reduce <code>flet x := x; ?a</code> to <code>?a</code> when <code>?a</code> is not assigned, for example) 2) you’d now need the MetaM functions to use <em>different</em> local contexts at different parts of the expression to talk about well-formedness with respect to fvars. Currently, you only need a single local context at any part of the expression—for instance, a delayed-assigned mvar <code>?m.23</code> has the ambient context. Only its assignment data knows about the fvars in <code>?a</code>’s local context, and that’s not part of the expression proper—it’s part of the <code>MetaM</code> state. But we do use telescopes to enter and manipulate binders anyway, so maybe doing the same with a <code>let</code> would at least be possible. Whether it would introduce more difficulties for technical reasons, though, I can’t say.</p>",
        "id": 424546612,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1709502918
    },
    {
        "content": "<p>If anyone would like to add an explanation along these lines to the metaprogramming book's MetaM chapter, that would be very welcome and I would be happy to review the PR. Back when I wrote that chapter, I only had a very vague understanding of delayed assignments, and the chapter reflects this.</p>",
        "id": 424665310,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1709561961
    }
]