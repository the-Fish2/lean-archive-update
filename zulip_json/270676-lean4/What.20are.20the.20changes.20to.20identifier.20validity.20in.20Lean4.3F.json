[
    {
        "content": "<p>I know that in Lean 4, we can now use <code>!</code> and <code>?</code> in (or at least, at the end of?) identifiers. Are there any other changes to the rules, or are all the rest copied from Lean 3?</p>",
        "id": 410623310,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704018211
    },
    {
        "content": "<p>(context: I want to ensure the regex used by pygments is correct)</p>",
        "id": 410623338,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704018240
    },
    {
        "content": "<p>I think that's the only change</p>",
        "id": 410638260,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704033634
    },
    {
        "content": "<p><code>!</code> and <code>?</code> can be used anywhere after the first character (they are in the \"identRest\" group)</p>",
        "id": 410638284,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704033672
    },
    {
        "content": "<p>there is a BNF at <a href=\"https://github.com/leanprover/lean4/blob/master/doc/lexical_structure.md#identifiers\">https://github.com/leanprover/lean4/blob/master/doc/lexical_structure.md#identifiers</a> but it was (temporarily?) removed from the manual for some reason</p>",
        "id": 410638619,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704034020
    },
    {
        "content": "<p>there are also <em>two</em> implemementations of the function in lean, one <a href=\"https://github.com/leanprover/lean4/blob/f54bce2abbbd7a379b0a1ad505d178384baad37d/src/Init/Meta.lean#L77-L101\">in Lean</a> and one <a href=\"https://github.com/leanprover/lean4/blob/f54bce2abbbd7a379b0a1ad505d178384baad37d/src/util/name.cpp#L32-L61\">in C++</a>... and they subtly differ! The lean version doesn't consider <code>0x207f</code> which is superscript-n <code>‚Åø</code> to be a letterlike symbol and hence an identRest.</p>",
        "id": 410639117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704034481
    },
    {
        "content": "<p>Is that a bug?</p>",
        "id": 410639734,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704035009
    },
    {
        "content": "<p>I have also confirmed that the BNF description matches the C++ one (it includes superscript-n in the right place), except it is missing the capture group <code>[ùíú-ùñü]</code>, described as \"Latin letters, Script, Double-struck, Fractur\" in the C++ source, in the <code>letterlike</code> group, and it also does not have <code>!</code> and <code>?</code> in the identRest group</p>",
        "id": 410639967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704035205
    },
    {
        "content": "<p>Lean 3 only has one implementation of this function, in C++, and unsurprisingly it almost exactly matches the lean 4 C++ code since the lean 4 code derives from the lean 3. The only difference is the inclusion of <code>!</code> and <code>?</code> in the identRest group</p>",
        "id": 410640247,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704035446
    },
    {
        "content": "<p>I think the lean 4 C++ definition is the correct one and all the other divergences are bugs</p>",
        "id": 410640274,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704035484
    },
    {
        "content": "<p>actually maybe not, there is a <code>kevin.lean</code> test (cc: <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> presumably) containing</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span><span class=\"o\">:</span><span class=\"mi\">10000</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\"‚Åø\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"bp\">`</span><span class=\"n\">n</span><span class=\"o\">))</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n‚Åø</span>\n</code></pre></div>\n<p>which would only work if <code>‚Åø</code> is not an identifier character. So possibly it was removed from the lean version and the other versions were not updated to match</p>",
        "id": 410640484,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704035727
    },
    {
        "content": "<p>Does your superscript parser supersede whatever that might have been for?</p>",
        "id": 410640673,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704035888
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/What.20are.20the.20changes.20to.20identifier.20validity.20in.20Lean4.3F/near/410638284\">said</a>:</p>\n<blockquote>\n<p><code>!</code> and <code>?</code> can be used anywhere after the first character (they are in the \"identRest\" group)</p>\n</blockquote>\n<p>I've updated <a href=\"https://github.com/pygments/pygments/pull/2618\">pygments/pygments#2618</a> accordingly</p>",
        "id": 410640815,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704036025
    },
    {
        "content": "<p>most likely, but it will have the same issue regarding identifier parsing, you have to put some whitespace if you want <code>a‚ÇÄ</code> to be treated as a subscript operator rather than one identifier</p>",
        "id": 410640984,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704036167
    },
    {
        "content": "<p><code>‚Åø</code> is the only superscript allowed by the C++ lexer as an identifier, so it is seemingly an outlier (possibly relating to its unusually early appearance in unicode next to the numeric subscripts)</p>",
        "id": 410641043,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704036234
    },
    {
        "content": "<p>I wanted to show an actual bug caused by the difference in the C++ lexer compared to the lean one, but actually it seems that the code is not reachable at all. It is only used by <code>name::escape</code> and this function is unused. The more common <code>name::to_string</code> just always skips escaping, which seems wrong but this function tends to be used only for advisory printing so it's probably not a big deal</p>",
        "id": 410641311,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704036419
    },
    {
        "content": "<p>the C++ <code>name::to_string</code> function can be seen in such examples as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">toString</span> <span class=\"o\">(</span><span class=\"n\">Lean.Expr.const</span> <span class=\"bp\">`¬´</span><span class=\"n\">foo.bar</span><span class=\"bp\">¬ª.</span><span class=\"n\">baz</span> <span class=\"o\">[])</span> <span class=\"c1\">-- implemented in C++</span>\n<span class=\"c1\">-- \"foo.bar.baz\"</span>\n<span class=\"k\">#eval</span> <span class=\"n\">toString</span> <span class=\"bp\">`¬´</span><span class=\"n\">foo.bar</span><span class=\"bp\">¬ª.</span><span class=\"n\">baz</span> <span class=\"c1\">-- implemented in lean</span>\n<span class=\"c1\">-- \"¬´foo.bar¬ª.baz\"</span>\n</code></pre></div>\n<p>Note that the C++ code knows how to do escaping, it just is disabled for some reason</p>",
        "id": 410641602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704036681
    }
]