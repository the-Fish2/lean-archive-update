[
    {
        "content": "<p>Could <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=equivShrink#doc\">docs#equivShrink</a> be made computable? And by that I mean in the same sense as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quot.mk#doc\">docs#Quot.mk</a> is computable, which in my understanding doesn't change anything about the object and it's implementation, it just moves it to the other type.</p>\n<p>I don't think it would have any implications on the soundness of Lean, as <code>equivShrink</code> can already be used inside proofs. Could this be done without compiler support inside a library? Or would this require changes to core?</p>\n<p>For background, I've been looking into types which are semantically equal to existing types, but have different performance characteristics. As a small, but useful, example consider that I want to <em>map</em> an <em>Array</em>, I could use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.map#doc\">docs#Array.map</a>, but this immediately destroys the original array or creates a full copy. But maybe, I only want to evaluate this computation for a couple of indices, in which case it would be useful to postpone computation until access. I've come up with an implementation which I quote at the end of this post.</p>\n<p>The resulting type <code>MappedArrayLarge</code> is of <code>Type 1</code>, I can show this type <em>0-small</em>, but this doesn't seem to be of much use if I want to use elements of this type in computations. I don't want to use the equivalence I used in the proof, since this would evaluate the computation eviscerating the reason why I constructed this type in the first place. The reason I want <code>MappedArray</code>, rather than <code>MappedArrayImp</code>, is that the former can be turned into a functor with all the benefits of this for reasoning about the code.</p>\n<p>Alternatively if someone know a way to get the same performance characteristics from a <code>Type 0</code>, without making <code>equivShrink</code> computable, that would be amazing.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">exampleArray</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">MappedArrayImp</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"n\">data</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">β</span>\n  <span class=\"n\">mapping</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MappedArrayImp</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">size</span> <span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">MappedArrayImp</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">self.data.size</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">get</span> <span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">MappedArrayImp</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">self.size</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">self.mapping</span> <span class=\"o\">(</span><span class=\"n\">self.data.get</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">fromArray</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">data</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MappedArrayImp</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">data</span> <span class=\"o\">:=</span> <span class=\"n\">data</span><span class=\"o\">,</span> <span class=\"n\">mapping</span> <span class=\"o\">:=</span> <span class=\"n\">id</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">coeArray</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">MappedArrayImp</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">fromArray</span><span class=\"o\">⟩</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">exampleArray</span> <span class=\"o\">:</span> <span class=\"n\">MappedArrayImp</span> <span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">⟩</span> <span class=\"c1\">-- 2</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">toArray</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">MappedArrayImp</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Array.ofFn</span> <span class=\"n\">a.get</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">setoid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">):</span> <span class=\"n\">Setoid</span> <span class=\"o\">(</span><span class=\"n\">MappedArrayImp</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">x.size</span> <span class=\"bp\">=</span> <span class=\"n\">y.size</span> <span class=\"bp\">∧</span>\n    <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x.size</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y.size</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">x.get</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"n\">y.get</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"n\">all_goals</span> <span class=\"n\">simp_all</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">forall_true_left</span><span class=\"o\">,</span> <span class=\"n\">implies_true</span><span class=\"o\">,</span> <span class=\"n\">forall_const</span><span class=\"o\">,</span> <span class=\"n\">and_self</span><span class=\"o\">,</span> <span class=\"n\">and_imp</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MappedArrayImp</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">MappedArrayLarge</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient</span> <span class=\"o\">(</span><span class=\"n\">MappedArrayImp.setoid</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">MappedArrayLarge</span> <span class=\"n\">Nat</span> <span class=\"c1\">-- Type 1</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MappedArrayLarge</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">size</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">MappedArrayLarge</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient.lift</span> <span class=\"n\">MappedArrayImp.size</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">HasEquiv.Equiv</span><span class=\"o\">,</span> <span class=\"n\">Setoid.r</span><span class=\"o\">,</span> <span class=\"n\">and_imp</span><span class=\"o\">]</span>\n  <span class=\"n\">omega</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">get</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">MappedArrayLarge</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">a.size</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n    <span class=\"n\">Quotient.hrecOn</span> <span class=\"n\">a</span> <span class=\"n\">MappedArrayImp.get</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">HasEquiv.Equiv</span><span class=\"o\">,</span> <span class=\"n\">Setoid.r</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">⟨</span><span class=\"n\">size_eq</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">Fin.heq_fun_iff</span> <span class=\"n\">size_eq</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">i.isLt</span> <span class=\"o\">(</span><span class=\"n\">size_eq</span> <span class=\"bp\">▸</span> <span class=\"n\">i.isLt</span><span class=\"o\">)</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">fromArray</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">data</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MappedArrayLarge</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">⟦</span><span class=\"n\">MappedArrayImp.fromArray</span> <span class=\"n\">data</span><span class=\"bp\">⟧</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">coeArray</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">MappedArrayLarge</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">fromArray</span><span class=\"o\">⟩</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">exampleArray</span> <span class=\"o\">:</span> <span class=\"n\">MappedArrayLarge</span> <span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">⟩</span> <span class=\"c1\">-- 2</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">toArray</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">MappedArrayLarge</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n    <span class=\"n\">Quotient.lift</span> <span class=\"n\">MappedArrayImp.toArray</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">HasEquiv.Equiv</span><span class=\"o\">,</span> <span class=\"n\">Setoid.r</span><span class=\"o\">,</span> <span class=\"n\">Array.data_length</span><span class=\"o\">,</span> <span class=\"n\">MappedArrayImp.get</span><span class=\"o\">,</span> <span class=\"n\">Array.get_eq_getElem</span><span class=\"o\">,</span>\n    <span class=\"n\">MappedArrayImp.toArray</span><span class=\"o\">,</span> <span class=\"n\">and_imp</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">size_eq</span> <span class=\"n\">h</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Array.ext</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp_all</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Array.size_ofFn</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">aesop</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">arrayEquiv</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">MappedArrayLarge</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"n\">toArray</span>\n  <span class=\"n\">invFun</span> <span class=\"o\">:=</span> <span class=\"n\">fromArray</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">a</span>\n    <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">a'</span><span class=\"o\">,</span> <span class=\"n\">a_def</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient.exists_rep</span> <span class=\"n\">a</span>\n    <span class=\"n\">subst</span> <span class=\"n\">a_def</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">fromArray</span><span class=\"o\">,</span> <span class=\"n\">MappedArrayImp.fromArray</span><span class=\"o\">,</span> <span class=\"n\">toArray</span><span class=\"o\">,</span> <span class=\"n\">Quotient.lift_mk</span><span class=\"o\">,</span>\n      <span class=\"n\">MappedArrayImp.toArray</span><span class=\"o\">,</span> <span class=\"n\">Array.data_length</span><span class=\"o\">,</span> <span class=\"n\">Quotient.eq</span><span class=\"o\">,</span> <span class=\"n\">HasEquiv.Equiv</span><span class=\"o\">,</span> <span class=\"n\">Setoid.r</span><span class=\"o\">,</span>\n      <span class=\"n\">Array.size_ofFn</span><span class=\"o\">,</span> <span class=\"n\">MappedArrayImp.get</span><span class=\"o\">,</span> <span class=\"n\">Array.get_eq_getElem</span><span class=\"o\">,</span> <span class=\"n\">Array.getElem_ofFn</span><span class=\"o\">,</span> <span class=\"n\">id_eq</span><span class=\"o\">,</span>\n      <span class=\"n\">implies_true</span><span class=\"o\">,</span> <span class=\"n\">forall_const</span><span class=\"o\">,</span> <span class=\"n\">and_self</span><span class=\"o\">]</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">a</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Array.ext</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">toArray</span><span class=\"o\">,</span> <span class=\"n\">fromArray</span><span class=\"o\">,</span> <span class=\"n\">MappedArrayImp.fromArray</span><span class=\"o\">,</span> <span class=\"n\">Quotient.lift_mk</span><span class=\"o\">,</span>\n        <span class=\"n\">MappedArrayImp.toArray</span><span class=\"o\">,</span> <span class=\"n\">Array.data_length</span><span class=\"o\">,</span> <span class=\"n\">Array.size_ofFn</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">toArray</span><span class=\"o\">,</span> <span class=\"n\">fromArray</span><span class=\"o\">,</span> <span class=\"n\">MappedArrayImp.fromArray</span><span class=\"o\">,</span> <span class=\"n\">Quotient.lift_mk</span><span class=\"o\">,</span>\n        <span class=\"n\">MappedArrayImp.toArray</span><span class=\"o\">,</span> <span class=\"n\">Array.data_length</span><span class=\"o\">,</span> <span class=\"n\">Array.size_ofFn</span><span class=\"o\">,</span> <span class=\"n\">Array.getElem_ofFn</span><span class=\"o\">,</span>\n        <span class=\"n\">MappedArrayImp.get</span><span class=\"o\">,</span> <span class=\"n\">Array.get_eq_getElem</span><span class=\"o\">,</span> <span class=\"n\">id_eq</span><span class=\"o\">,</span> <span class=\"n\">implies_true</span><span class=\"o\">,</span> <span class=\"n\">forall_const</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">small</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Small.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">MappedArrayLarge</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">equiv_small</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">use</span> <span class=\"n\">Array</span> <span class=\"n\">α</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"n\">exact</span> <span class=\"n\">arrayEquiv</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MappedArrayLarge</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MappedArray</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Shrink</span> <span class=\"o\">(</span><span class=\"n\">MappedArrayLarge</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">MappedArray</span> <span class=\"n\">Nat</span> <span class=\"c1\">-- Type 0</span>\n</code></pre></div>",
        "id": 425863891,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1710147689
    },
    {
        "content": "<p>What are you trying to accomplish with this <code>MappedArray</code>?</p>",
        "id": 425878969,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710153187
    },
    {
        "content": "<p>You can probably do most of what you want (that is, the <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> problem, not <code>equivShrink</code> itself) by exposing β as a parameter of <code>MappedArray</code></p>",
        "id": 425879210,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710153273
    },
    {
        "content": "<p>The question is how far down the xy problem do you want to go? My ultimate goal is that I want to be able to quickly write reliable code with good enough performance to solve my practical needs. </p>\n<p>I find that lawful monads are a good way to reason about code and show that it does what it is supposed to do, I've done so informally in the past, and I am excited that this can be done formally with Lean. Lean's <code>List</code> monad provides the semantics I want, but I know from prior experience (mostly with other programming languages), that the performance of linked lists isn't good enough for the kind of programs I want to write. The solution I've used in the past was to use arrays at the bottom, with delayed computation stacked on top, which get evaluated and cached at the appropriate times. Semantically that's equivalent to <code>List</code>, just like <code>Array</code> is semantically equivalent to <code>List</code>, and therefore it's a lawful monad. I can implement this in Lean (at least I am making good progress). I can even tell Lean about the monad semantics, by creating a <code>LawfulMonad</code> instance, which I can use to formally reason about my code. The only downside is that so far this monad is <code>Type u → Type u + 1</code>. </p>\n<p>I'm eager to talk about all the xs and ys of this project I'm working on, with anybody who's interested, but many of my ideas are still pretty intuitive, and I'm still in the process of formalizing this in Lean code, So in order to keep this question somewhat manageable I'm asking if it's possible to make <code>quivShrink</code> computable?</p>",
        "id": 425888582,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1710156607
    },
    {
        "content": "<p>I've thought about making <code>Small</code> a data-carrying class (or making a data-carrying version of <code>Small</code>), and I am in favor of it if it doesn't lead to serious diamonds. The reason is that in category theory etc. most use cases are saying something like <code>ULift.{u} X</code> is <code>Small.{v}</code> if <code>X : Type v</code>, in which case we have the canonical equivalence <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.ulift#doc\">docs#Equiv.ulift</a> and it would be preferable to use it rather than an arbitrarily chosen one.</p>",
        "id": 425968498,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1710176143
    },
    {
        "content": "<p>There is indeed some diamond issue though; both of the following <code>rfl</code> fail.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ULift.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ULift.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">ULift.</span><span class=\"o\">{</span><span class=\"n\">max</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c\">/-</span><span class=\"cm\"> fails -/</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ULift.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ULift.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">ULift.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ULift.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c\">/-</span><span class=\"cm\"> fails -/</span>\n</code></pre></div>",
        "id": 425975199,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1710178314
    },
    {
        "content": "<p>I believe you mean a data-carrying <code>Shrink</code>, as <code>Small</code> can already carry data, if I provide a computable <code>equiv_small</code> into a data-carrying type. I think the diamonds you are worried about would only occur if there is a <code>Small</code> instance for <code>Shrink</code>, but this could already be defined to day, so I don't see how making <code>Shrink</code> data-carrying changes this. Even if <code>Shrink</code> is data-carrying I don't think it would ever be a good choice for the canonical model in a <code>Small</code> instance, as it wouldn't be useful to reason about the type in the higher universe, the model from the <code>Small</code> which is used for the <code>Shrink</code> would even be useful to reason about the <code>Shrink</code> type.</p>",
        "id": 425986376,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1710182312
    },
    {
        "content": "<p><code>class Small (α : Type v) : Prop</code><br>\nIt would have to be <code>: Type _</code> instead of <code>Prop</code> to carry data.</p>",
        "id": 425992531,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1710184575
    },
    {
        "content": "<p>But making it data-carrying might cause diamonds (though Junyan's example is not an example of diamonds, I think, since the fact that the types are different, it means that there is not a risk of that being a diamond).</p>\n<p>If all instances of <code>Small</code> are type-directed (e.g., <code>F X Y</code> is small whenever <code>X</code> and <code>Y</code> are small), then I don't think there is a risk of diamonds.</p>",
        "id": 425992903,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1710184735
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"654733\">@Markus Schmaus</span> you might be interested in some stuff I've been doing <a href=\"https://github.com/JamesGallicchio/LeanColls\">here</a>. Maybe relevant things:</p>\n<ul>\n<li>experimental interface for <a href=\"https://gallicch.io/LeanColls/docs/LeanColls/Classes/Indexed/Basic.html#LeanColls.Indexed\">indexed</a> types like array</li>\n<li>foldable <a href=\"https://gallicch.io/LeanColls/docs/LeanColls/Data/Transformer/View.html#LeanColls.View\">View</a>s into data that allow for inlining data pipelines</li>\n<li><a href=\"https://gallicch.io/LeanColls/docs/LeanColls/Data/Transformer/Slice.html#LeanColls.Slice\">Slice</a>s into indexed types</li>\n</ul>",
        "id": 425999628,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1710187421
    },
    {
        "content": "<p>the terminology used in this library is very unintuitive and derived from many sources, and there's very little documentation, but I am happy to help if this library will be useful to you</p>",
        "id": 425999862,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1710187527
    },
    {
        "content": "<p>(also, the library's whole goal is to be more amenable to proof, but that is very much work-in-progress...)</p>",
        "id": 426000150,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1710187661
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407274\">@James Gallicchio</span> I had a look at your library and it looks interesting.</p>",
        "id": 426008667,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1710191174
    },
    {
        "content": "<p>I totally misremembered the definition of <code>Small</code>, but that also means, that making it carry data wouldn't help my use case, as this wouldn't help with making <code>equivShrink</code> computable.</p>",
        "id": 426088310,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1710237130
    },
    {
        "content": "<p>What's wrong with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">w</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">pp_with_univ</span><span class=\"kd\">]</span> <span class=\"kd\">class</span> <span class=\"n\">Small'</span> <span class=\"n\">where</span>\n  <span class=\"n\">Shrink</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span>\n  <span class=\"n\">equivShrink</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">Shrink</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Small'.equivShrink</span>\n<span class=\"c\">/-</span><span class=\"cm\"> Small'.equivShrink.{w, v} {α : Type v} [self : Small' α] : α ≃ Small'.Shrink α -/</span>\n</code></pre></div>\n<p>This <code>Small'.equivShrink</code> is computable. I'm simply replacing the existential with essentially a Sigma type.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/270676-lean4/topic/Computable.20.60equivShrink.60.3F/near/425992903\">said</a>:</p>\n<blockquote>\n<p>But making it data-carrying might cause diamonds (though Junyan's example is not an example of diamonds, I think, since the fact that the types are different, it means that there is not a risk of that being a diamond).</p>\n<p>If all instances of <code>Small</code> are type-directed (e.g., <code>F X Y</code> is small whenever <code>X</code> and <code>Y</code> are small), then I don't think there is a risk of diamonds.</p>\n</blockquote>\n<p>Yeah sorry I was confused, and I misremembered what my concern was. There won't be non-defeq synthesized <code>Small.{v} (ULift X)</code> instances for <code>X : Type v</code>, but the actual use case isn't this, instead it's about using Small to define UnivLE, and the actual diamond is the following (continued from above):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Small'.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">α</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Small'.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ULift.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">ulift</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">pp_with_univ</span><span class=\"kd\">]</span> <span class=\"n\">abbrev</span> <span class=\"n\">UnivLE'</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">Small'.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">UnivLE'.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n\n<span class=\"c1\">-- Analog of `univLE_of_max`, key instance for UnivLE to work</span>\n<span class=\"c1\">-- priority := low so that `#synth UnivLE'.{w,w}` gets the `.refl` instance</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">low</span><span class=\"o\">)</span> <span class=\"n\">univLE'OfMax</span> <span class=\"o\">[</span><span class=\"n\">UnivLE'.</span><span class=\"o\">{</span><span class=\"n\">max</span> <span class=\"n\">w</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">}]</span> <span class=\"o\">:</span> <span class=\"n\">UnivLE'.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">α</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨</span><span class=\"n\">Small'.Shrink</span> <span class=\"o\">(</span><span class=\"n\">ULift.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">.</span><span class=\"n\">ulift</span><span class=\"o\">)</span> <span class=\"n\">Small'.equivShrink</span><span class=\"o\">⟩</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">UnivLE'.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"c\">/-</span><span class=\"cm\"> fun α =&gt; instSmall' α -/</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">UnivLE'.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">max</span> <span class=\"n\">w</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"c1\">-- succeeds</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">UnivLE'.</span><span class=\"o\">{</span><span class=\"n\">max</span> <span class=\"n\">w</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">}]</span> <span class=\"o\">:</span> <span class=\"n\">UnivLE'.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span> <span class=\"c1\">-- succeeds</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Small'.trans_univLE'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Small'.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">UnivLE'.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">}]</span> <span class=\"o\">:</span> <span class=\"n\">Small'.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">Small'.Shrink</span> <span class=\"o\">(</span><span class=\"n\">Small'.Shrink</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">Small'.equivShrink.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">Small'.equivShrink</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">univLE'Trans</span> <span class=\"o\">[</span><span class=\"n\">UnivLE'.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">}]</span> <span class=\"o\">[</span><span class=\"n\">UnivLE'.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}]</span> <span class=\"o\">:</span> <span class=\"n\">UnivLE'.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">α</span> <span class=\"bp\">↦</span> <span class=\"n\">Small'.trans_univLE'</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">univLE'Trans.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">max</span> <span class=\"n\">w</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">max</span> <span class=\"n\">w</span> <span class=\"n\">v</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>\n<p>This means that even though UnivLE' enjoys transitivity, it's undesirable to use univLE'trans to construct instances.</p>",
        "id": 426276813,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1710316159
    },
    {
        "content": "<p>Making <code>Small</code> data carrying won't solve <span class=\"user-mention\" data-user-id=\"654733\">@Markus Schmaus</span> 's problem at all, because it will just end up being a convoluted way of defining <code>def MappedArray (α : Type) := Array α</code>. There is also the question of how you expect to have any operations on this type - the only method provided to you by the <code>Shrink</code> infrastructure is to use the equiv you are given, but this amounts to eagerly computing the map result, which defeats the point.</p>",
        "id": 426278550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710316924
    }
]