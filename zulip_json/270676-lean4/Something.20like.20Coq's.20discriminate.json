[
    {
        "content": "<p>Hi folks,</p>\n<p>I like to try to learn more about lean by writing tactics and<br>\nseeing what sort of proof term is created.  For this little<br>\ntheorem,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">zero_not_one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">zero_not_one</span>\n</code></pre></div>\n<p>I get </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">zero_not_one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"n\">of_eq_true</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">implies_congr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eq_false_of_decide</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">Init</span><span class=\"bp\">.</span><span class=\"n\">Core</span><span class=\"bp\">._</span><span class=\"n\">auxLemma</span><span class=\"bp\">.</span><span class=\"m\">4</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but what is Init.Core._auxLemma.4 ?  I looked in the source code<br>\nfor such a thing, but I couldn't find anything like it.</p>\n<p>A second question: Is there a tactic similar to Coq's<br>\n<code>discriminate</code>, one that could conclude a proof from a hypothesis<br>\nof the form c1 x = c2 y, where c1 and c2 are different<br>\nconstructors of some data type?</p>\n<p>Thanks!</p>",
        "id": 442327235,
        "sender_full_name": "Scott N. Walck",
        "timestamp": 1717436656
    },
    {
        "content": "<p>Please do not post the same message twice. The only possible effect of that strategy is that someone wastes time answering your question while someone already answered the other copy.</p>",
        "id": 442329035,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1717437112
    },
    {
        "content": "<p><code>Init.Core._auxLemma.4</code> is some internal lemma you shouldn’t try to access directly. For your second question, the answer is probably <code>injection</code> but it’s hard to tell without a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>.</p>",
        "id": 442329360,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1717437197
    },
    {
        "content": "<p>Sorry for the double post.  I didn't realize the first one went through.</p>",
        "id": 442329382,
        "sender_full_name": "Scott N. Walck",
        "timestamp": 1717437203
    },
    {
        "content": "<p>If you think Init.Core._auxLemma.4 is bad, try proving <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mi>y</mi><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">(x+y)^2=x^2+2xy+y^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.1944em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0085em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> with <code>ring</code> and inspecting the term that the tactic generates; it's completely incomprehensible. And other tactics are worse. My take on tactics is that they're exactly there to be used when you don't want to see the term, you just want to prove the theorem.</p>\n<p>I would imagine that <code>cases h</code> would close a goal if <code>h : c1 x = c2 y</code>.</p>",
        "id": 442329614,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717437266
    },
    {
        "content": "<p>Thanks for the advice. And</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">zero_is_not_one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>works just great.</p>",
        "id": 442331210,
        "sender_full_name": "Scott N. Walck",
        "timestamp": 1717437673
    },
    {
        "content": "<p>I think <code>injection h</code> should also work.</p>",
        "id": 442332108,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1717437898
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">zero_is_not_one'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">injection</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>also works great.  Thanks.</p>",
        "id": 442333418,
        "sender_full_name": "Scott N. Walck",
        "timestamp": 1717438291
    },
    {
        "content": "<p><code>Init.Core._auxLemma.4</code> is generated by <code>simp</code>. It's going to be wrapping a single simp lemma. If you use <code>simp?</code> you can see the list of simp lemmas that were used, and that will give you a good idea of what it could be. Mario gave <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Mathlib.2EAlgebra.2EGroup.2EDefs.2E_auxLemma.20.2C.20.20unknown.20identif.2E.2E.2E/near/404808175\">a hack</a> to print such a lemma if you want to dig in.</p>",
        "id": 442333437,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1717438297
    }
]