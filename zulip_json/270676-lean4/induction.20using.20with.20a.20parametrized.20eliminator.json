[
    {
        "content": "<p>Consider a function like <code>merge</code> (as known from merge sort:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">uu</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uu</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">r</span><span class=\"o\">]</span>\n<span class=\"kn\">local</span> <span class=\"kd\">infixl</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"s2\">\" ≼ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">r</span>\n<span class=\"kn\">open</span> <span class=\"n\">List</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">merge</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"o\">([],</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">l'</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"o\">[])</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">l</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"bp\">≼</span> <span class=\"n\">b</span> <span class=\"k\">then</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">merge</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">merge</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">l'</span><span class=\"o\">)</span>\n  <span class=\"n\">termination_by</span> <span class=\"n\">merge</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">length</span> <span class=\"n\">l.1</span> <span class=\"bp\">+</span> <span class=\"n\">length</span> <span class=\"n\">l.2</span>\n</code></pre></div>\n<p>When proving things about this, I might be inclined to define a custom induction principle, like the following, which will directly focus on the four cases and give me suitable induction hypotheses:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">merge.induct</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uu</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">r</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">case1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"o\">([],</span> <span class=\"n\">l'</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">case2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"o\">[])</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"o\">[]))</span>\n  <span class=\"o\">(</span><span class=\"n\">case3</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l'</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">case4</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">¬</span><span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l'</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But if I try to use it like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">perm_length</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">length</span> <span class=\"o\">(</span><span class=\"n\">merge</span> <span class=\"n\">r</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">length</span> <span class=\"n\">l.1</span> <span class=\"bp\">+</span> <span class=\"n\">length</span> <span class=\"n\">l.2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"n\">using</span> <span class=\"n\">merge.induct</span>\n</code></pre></div>\n<p>I get 6 goals, including two unwanted ones for <code>r</code> and <code>DecidbableRel r</code>.</p>\n<p>This is understandable, <code>induction</code> has no good way to knowing what <code>r</code> is. But how can I specify it? I can’t specify it as part of the “target”, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">induction</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">l</span> <span class=\"n\">using</span> <span class=\"n\">merge.induct</span>\n</code></pre></div>\n<p>but I also can’t give instantiations after <code>using</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>   <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"n\">using</span> <span class=\"n\">merge.induct</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>What I can do is artificially make the <code>motive</code> take the <code>r</code> as an argument:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">merge.induct2</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uu</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">r</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">case1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"n\">r</span> <span class=\"o\">([],</span> <span class=\"n\">l'</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">case2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"o\">[])</span> <span class=\"bp\">→</span>  <span class=\"n\">motive</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"o\">[]))</span>\n  <span class=\"o\">(</span><span class=\"n\">case3</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l'</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">case4</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">¬</span><span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l'</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>and now I can indicate the <code>r</code> as part of the target.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">perm_length</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">length</span> <span class=\"o\">(</span><span class=\"n\">merge</span> <span class=\"n\">r</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">length</span> <span class=\"n\">l.1</span> <span class=\"bp\">+</span> <span class=\"n\">length</span> <span class=\"n\">l.2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">l</span> <span class=\"n\">using</span> <span class=\"n\">merge.induct2</span>\n  <span class=\"n\">case</span> <span class=\"n\">case1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">merge</span><span class=\"o\">]</span>\n  <span class=\"n\">case</span> <span class=\"n\">case2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">merge</span><span class=\"o\">]</span>\n  <span class=\"n\">case</span> <span class=\"n\">case3</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"n\">b</span> <span class=\"n\">l'</span> <span class=\"n\">hr</span> <span class=\"n\">IH</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">merge</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">,</span> <span class=\"n\">IH</span><span class=\"o\">]</span>\n    <span class=\"n\">simp_arith</span>\n  <span class=\"n\">case</span> <span class=\"n\">case4</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"n\">b</span> <span class=\"n\">l'</span> <span class=\"n\">hr</span> <span class=\"n\">IH</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">merge</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">,</span> <span class=\"n\">IH</span><span class=\"o\">]</span>\n    <span class=\"n\">simp_arith</span>\n</code></pre></div>\n<p>Is that just a bad hack, or is that the way to go here?</p>\n<p>And if it is a bad hack, what should be the proper solution? Make <code>induction</code> accept explicit parameters of the induction principle in the target list, or maybe support arguments after <code>using</code>?</p>",
        "id": 411962502,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1704815463
    },
    {
        "content": "<p>Explicit parameters sound like the nice  solution to me, though I'm surprised your hack works!</p>",
        "id": 411977111,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704820033
    },
    {
        "content": "<p>Actually, it doesn't, I just noticed that I see red squiggly lines under <code>perm_length</code> saying</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">merge</span> <span class=\"n\">r</span>\n<span class=\"n\">argument</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"bp\">✝</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">function</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">DecidableRel</span> <span class=\"n\">r</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>so I guess the <code>induction</code> tactic does something weird with the hack.</p>",
        "id": 411977441,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1704820129
    },
    {
        "content": "<p>Ok, so ignoring the hack:</p>\n<p>One argument for supporting</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">induction</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">l</span> <span class=\"n\">using</span> <span class=\"n\">merge.induct</span>\n</code></pre></div>\n<p>is that to the user, given</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">merge</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">DecidableRel</span> <span class=\"n\">r</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>it’s not immediately clear why the function's parameter <code>r</code> and <code>l</code> need be treated differently.</p>",
        "id": 411978100,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1704820325
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">merge.induct2</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uu</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dr</span> <span class=\"o\">:</span> <span class=\"n\">DecidableRel</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">DecidableRel</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">case1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"n\">r</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"o\">([],</span> <span class=\"n\">l'</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">case2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"o\">[])</span> <span class=\"bp\">→</span>  <span class=\"n\">motive</span> <span class=\"n\">r</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"o\">[]))</span>\n  <span class=\"o\">(</span><span class=\"n\">case3</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">r</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">r</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l'</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">case4</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">¬</span><span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">r</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">r</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l'</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span>  <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">r</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">perm_length</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">r</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">length</span> <span class=\"o\">(</span><span class=\"n\">merge</span> <span class=\"n\">r</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">length</span> <span class=\"n\">l.1</span> <span class=\"bp\">+</span> <span class=\"n\">length</span> <span class=\"n\">l.2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"o\">‹</span><span class=\"n\">DecidableRel</span> <span class=\"n\">r</span><span class=\"o\">›,</span> <span class=\"n\">l</span> <span class=\"n\">using</span> <span class=\"n\">merge.induct2</span>\n  <span class=\"n\">case</span> <span class=\"n\">case1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">merge</span><span class=\"o\">]</span>\n  <span class=\"n\">case</span> <span class=\"n\">case2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">merge</span><span class=\"o\">]</span>\n  <span class=\"n\">case</span> <span class=\"n\">case3</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"n\">b</span> <span class=\"n\">l'</span> <span class=\"n\">hr</span> <span class=\"n\">IH</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">merge</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">,</span> <span class=\"n\">IH</span><span class=\"o\">]</span>\n    <span class=\"n\">simp_arith</span>\n  <span class=\"n\">case</span> <span class=\"n\">case4</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"n\">b</span> <span class=\"n\">l'</span> <span class=\"n\">hr</span> <span class=\"n\">IH</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">merge</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">,</span> <span class=\"n\">IH</span><span class=\"o\">]</span>\n    <span class=\"n\">simp_arith</span>\n</code></pre></div>",
        "id": 411981180,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704821284
    },
    {
        "content": "<p>There seem to be some rough edges here around binder types</p>",
        "id": 411981243,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704821304
    },
    {
        "content": "<p>I think your version fails because you generalized over <code>r</code> but not <code>: DecidableRel r</code></p>",
        "id": 411981293,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704821327
    },
    {
        "content": "<p>Thanks! Doesn’t make make me more confident that this is direction is a good workaround, compared to explicit support of some form.</p>",
        "id": 411981957,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1704821565
    },
    {
        "content": "<p>Edited one more time</p>",
        "id": 411982098,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704821631
    },
    {
        "content": "<p>I tried a variant of your working solution, where the motive takes implicit arguments:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">merge.induct2</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uu</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dr</span> <span class=\"o\">:</span> <span class=\"n\">DecidableRel</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">r</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">case1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"n\">r</span> <span class=\"o\">([],</span> <span class=\"n\">l'</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">case2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"o\">[])</span> <span class=\"bp\">→</span>  <span class=\"n\">motive</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"o\">[]))</span>\n  <span class=\"o\">(</span><span class=\"n\">case3</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l'</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">case4</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">¬</span><span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">l'</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l'</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span>  <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but both</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›,</span> <span class=\"n\">l</span> <span class=\"n\">using</span> <span class=\"n\">merge.induct2</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">l</span> <span class=\"n\">using</span> <span class=\"n\">merge.induct2</span>\n</code></pre></div>\n<p>say</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unexpected</span> <span class=\"n\">eliminator</span> <span class=\"n\">resulting</span> <span class=\"n\">type</span>\n  <span class=\"n\">motive</span> <span class=\"n\">r</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>But maybe <code>induction</code> can be taught about implicit parameters of the <code>motive</code>?</p>\n<p>It still feels wrong to put fixed parameters into the motive. Wouldn’t this also make <code>induction</code> needlessly generalize over these parameters?</p>",
        "id": 412118050,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1704885006
    },
    {
        "content": "<p>Let’s see what Isabelle does:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">Scratch</span><span class=\"w\"> </span><span class=\"kp\">imports</span><span class=\"w\"> </span><span class=\"n\">Main</span><span class=\"w\"> </span><span class=\"k\">begin</span>\n\n<span class=\"k\">context</span>\n<span class=\"kp\">fixes</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a ⇒ 'a ⇒ bool\"</span>\n<span class=\"k\">begin</span>\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">merge</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a list ⇒ 'a list ⇒ 'a list\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"merge [] l' = l'\"</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"merge l' [] = l'\"</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"merge (a # l) (b # l') =</span>\n<span class=\"s\">    (if r a  b then a # merge l (b # l') else b # merge (a # l)  l')\"</span>\n<span class=\"k\">end</span>\n\n<span class=\"kt\">thm</span><span class=\"w\"> </span><span class=\"n\">merge.induct</span>\n<span class=\"c\">(*</span>\n<span class=\"c\">(⋀l'. ?P [] l') ⟹</span>\n<span class=\"c\">(⋀v va. ?P (v # va) []) ⟹</span>\n<span class=\"c\">(⋀a l b l'.</span>\n<span class=\"c\">    (?r a b ⟹ ?P l (b # l')) ⟹</span>\n<span class=\"c\">    (¬ ?r a b ⟹ ?P (a # l) l') ⟹ ?P (a # l) (b # l')) ⟹</span>\n<span class=\"c\">?P ?a0.0 ?a1.0</span>\n<span class=\"c\">*)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\">  </span><span class=\"s\">\"length (merge r l1 l2) = length l1 + length l2\"</span>\n<span class=\"k\">by</span><span class=\"o\">(</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"n\">rule</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">merge.induct</span><span class=\"o\">[</span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n</code></pre></div>\n<p>If I pass the <code>r</code> parameter explicitly (but unchanged) through <code>merge</code>, it is added to the motive. If I make sure it is fixed (like in Isabelle) using the <code>context</code> construct, it becomes universally bound in the induction principle, and is <em>not</em> part of the target. I can however instantiate it with <code>[where r = r]</code>.</p>\n<p>So supporting</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"n\">using</span> <span class=\"n\">merge.induct</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>seems useful in any case.</p>\n<p>What I am unsure still is whether Lean, when autogenerating the inductive principle, should keep fixed parameters in the motive, or not. The former leads to nicer proofs (no need to generalize a fixed paramter), the latter is more predictable.</p>",
        "id": 412118892,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1704885325
    },
    {
        "content": "<p>How about existing induction theorems with extra parameters, like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Nat.decreasingInduction.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mn</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hP</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">m</span>\n</code></pre></div>\n<p>can we use them with the <code>induction</code>  tactic somehow? I couldn’t get it to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Basic</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Nat.decreasingInduction</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"mi\">10</span><span class=\"o\">):</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">using</span> <span class=\"n\">Nat.decreasingInduction</span>\n</code></pre></div>\n<p>With my proposed syntax, </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"mi\">10</span><span class=\"o\">):</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">using</span> <span class=\"n\">Nat.decreasingInduction</span> <span class=\"o\">(</span><span class=\"n\">mn</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>should ideally work. (Maybe only if the <code>mn</code> parameter is moved before <code>h</code>?)</p>",
        "id": 412511731,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705053656
    },
    {
        "content": "<p>I wonder if at some point it makes more sense to just do something uniform like <code>induction using &lt;term&gt;</code> where all remaining arguments are assumed to be minor premises. But yes, that would also require some parameter shuffling.</p>",
        "id": 412512385,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1705053845
    },
    {
        "content": "<p>Yeah, I’m actually reading through the code how much the <code>induction</code> needs to know from the actual <code>decl</code>, or whether it just cares about the thing’s type and a term there would be fine.</p>\n<p>If we say <code>&lt;term&gt;</code>, we still would want to interpret <code>using foo.induct</code> (without parameters) as <code>using @foo.induct</code>, right, and not instantiate implicit parameters during elaboration, right? I assume there is precedence for that  (maybe the arguments of <code>simp</code>)?</p>",
        "id": 412512821,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705053985
    },
    {
        "content": "<p>Yes, we sometimes do <code>ident &lt;|&gt; term</code> for that. I can't say whether it's necessary for induction.</p>",
        "id": 412513051,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1705054062
    },
    {
        "content": "<p>Or rather, just specializing <code>term</code>s that turn out to be <code>ident</code>s</p>",
        "id": 412513190,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1705054097
    },
    {
        "content": "<p>It does look at  an attribute <code>recursorAttribute</code> for “user defined recursor, numerical parameter specifies position of the major premise”…</p>",
        "id": 412513198,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705054100
    },
    {
        "content": "<p>Ah but my syntax does not distinguish a major premise :)</p>",
        "id": 412513293,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1705054135
    },
    {
        "content": "<p>Phew, there is quite a big surface area here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">RecursorInfo</span> <span class=\"n\">where</span>\n  <span class=\"n\">recursorName</span>  <span class=\"o\">:</span> <span class=\"n\">Name</span>\n  <span class=\"n\">typeName</span>      <span class=\"o\">:</span> <span class=\"n\">Name</span>\n  <span class=\"n\">univLevelPos</span>  <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">RecursorUnivLevelPos</span>\n  <span class=\"n\">depElim</span>       <span class=\"o\">:</span> <span class=\"n\">Bool</span>\n  <span class=\"n\">recursive</span>     <span class=\"o\">:</span> <span class=\"n\">Bool</span>\n  <span class=\"n\">numArgs</span>       <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"c1\">-- Total number of arguments</span>\n  <span class=\"n\">majorPos</span>      <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">paramsPos</span>     <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"c1\">-- Position of the recursor parameters in the major premise, instance implicit arguments are `none`</span>\n  <span class=\"n\">indicesPos</span>    <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"c1\">-- Position of the recursor indices in the major premise</span>\n  <span class=\"n\">produceMotive</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span> <span class=\"c1\">-- If the i-th element is true then i-th minor premise produces the motive</span>\n</code></pre></div>\n<p>But <code>mkRecursorInfoAux</code> seems to infer that from the type. So it might work.</p>\n<p>But </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">throwError</span><span class=\"s2\">\"invalid user defined recursor '{declName}', type of the major premise does not contain the recursor parameter</span>\n</code></pre></div>\n<p>indicates that that concept of recursor does not support parameters not appearing in the major premise.</p>\n<p>And this custom attribute to set the major premise is not used or tested in core and std, and has only two uses in mathlib <span aria-label=\"cold sweat\" class=\"emoji emoji-1f630\" role=\"img\" title=\"cold sweat\">:cold_sweat:</span></p>\n<p>Ah, <code>RecursorInfo</code> was the wrong tree to bark up. It seems that <code>getElimInfo</code> is the function used with <code>induction … using</code>, and while it takes a <code>declName</code>, it only looks at its type. So using <code>using &lt;term&gt;</code> might actually work nicely.</p>",
        "id": 412513560,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705054226
    },
    {
        "content": "<p>While this might work fine with parameters that don’t affect the resulting type, int he case of <code>decreasingInduction</code>, if we instantiate the <code>mn</code> parameter, like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Nat.decreasingInduction2.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">mn</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hP</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">Nat.decreasingInduction</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">P</span> <span class=\"n\">h</span> <span class=\"n\">mn</span> <span class=\"n\">hP</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"mi\">10</span><span class=\"o\">):</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">using</span> <span class=\"n\">Nat.decreasingInduction2</span> <span class=\"o\">(</span><span class=\"n\">mn</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>then the target gets instantiated (is no longer the motive applied to other paramters of the eliminator), confusing the <code>getElemInfo</code> code</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>Crudely checked using this code</p>\n<div class=\"codehilite\"><pre><span></span><code>import Mathlib.Data.Nat.Basic\nimport Mathlib.Tactic.Common\n\n#check Nat.decreasingInduction\n\n#eval Lean.Meta.getElimInfo ``Nat.decreasingInduction2\n\ndef Nat.decreasingInduction2.{u_1} {m n : ℕ} (mn : m ≤ n) {P : ℕ → Sort u_1} (hP : P n)  (h : (n : ℕ) → P (n + 1) → P n) : P m :=\n  @Nat.decreasingInduction m n P h mn hP\n\nexample (n : Nat) (h : n ≤ 10): n = n := by\n  induction n using Nat.decreasingInduction2 (mn := h)\n\nopen Lean Meta\ndef getElimInfoType (declType : Expr) (baseDeclName? : Option Name := none) : MetaM ElimInfo := do\n  forallTelescopeReducing declType fun xs type =&gt; do\n    let motive  := type.getAppFn\n    let targets := type.getAppArgs\n    unless motive.isFVar &amp;&amp; targets.all (·.isFVar) &amp;&amp; targets.size &gt; 0 do\n      throwError &quot;unexpected eliminator resulting type{indentExpr type}&quot;\n    let motiveType ← inferType motive\n    forallTelescopeReducing motiveType fun motiveArgs motiveResultType =&gt; do\n      unless motiveArgs.size == targets.size do\n        throwError &quot;unexpected number of arguments at motive type{indentExpr motiveType}&quot;\n      unless motiveResultType.isSort do\n        throwError &quot;motive result type must be a sort{indentExpr motiveType}&quot;\n    let some motivePos ← pure (xs.indexOf? motive) |\n      throwError &quot;unexpected eliminator type{indentExpr declType}&quot;\n    let targetsPos ← targets.mapM fun target =&gt; do\n      match xs.indexOf? target with\n      | none =&gt; throwError &quot;unexpected eliminator type{indentExpr declType}&quot;\n      | some targetPos =&gt; pure targetPos.val\n    let mut altsInfo := #[]\n    let env ← getEnv\n    for i in [:xs.size] do\n      let x := xs[i]!\n      if x != motive &amp;&amp; !targets.contains x then\n        let xDecl ← x.fvarId!.getDecl\n        if xDecl.binderInfo.isExplicit then\n          let numFields ← forallTelescopeReducing xDecl.type fun args _ =&gt; pure args.size\n          let name := xDecl.userName\n          let declName? := do\n            let base ← baseDeclName?\n            let altDeclName := base ++ name\n            if env.contains altDeclName then some altDeclName else none\n          altsInfo := altsInfo.push { name, declName?, numFields }\n    pure { name := `foo, motivePos, targetsPos, altsInfo }\n\ndef getElimInfo (declName : Name) (baseDeclName? : Option Name := none) : MetaM ElimInfo := do\n  let declInfo ← getConstInfo declName\n  getElimInfoType declInfo.type baseDeclName?\n\nexample (n : Nat) (h : n ≤ 10): n = n := by\n  #eval do\n    let s  ← `(@Nat.decreasingInduction2 (mn:=h))\n    let e ← (Lean.Elab.Term.elabTerm s none).run&#39; {}\n    getElimInfoType (← inferType e)\n</code></pre></div>\n</div></div>\n<p>So while it might help in the case of <code>merge.induct</code> above, it wouldn’t in the case of <code>decreasingInduction</code>.</p>",
        "id": 412522942,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705057513
    },
    {
        "content": "<p>It's not clear to me whether it is even useful to talk about a major premise and motive for this induction principle. But again I don't know the induction code very well, or how it could be generalized.</p>",
        "id": 412523629,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1705057797
    },
    {
        "content": "<p>Indeed, if “major premise” (the <code>m</code>, right) is something we expect to be able to generalize, then providing <code>m ≤ n</code> may prevent that generalization. Maybe the major premise here is actually <code>m≤n</code>?<br>\nIt may make sense to focus on the simpler case of parameters that don’t affect the targets, where the generalization to terms rather than identifiers might just work fine – if the term is elaborated carefully, i.e. like <code>@merge.induct  (r := …)</code>, not like <code>@merge.induct  (r := …)</code>.</p>",
        "id": 412524459,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705058160
    },
    {
        "content": "<p>I keep going back and forth. Maybe it is nicer after all to treat the <code>r</code> in <code>merge.induct</code> in the first post as a “fixed target”, so</p>\n<ul>\n<li>require it to be passed as a target it <code>induction r, l using merge.induct</code>, but</li>\n<li>do <em>not</em> generalize it (as it is fixed throughout the induction)<br>\nThis would require less syntax changes, is a bit more natural to a user who doesn’t spot the difference in how <code> r</code> and <code>l</code> is used in the recursion of <code>merge</code>. And (assuming I can recognize them reliably in <code>getElimInfo</code> the implementation wouldn’t be not too bad). </li>\n</ul>\n<p>Maybe the specification should be “a fixed parameter is one that is not implicit and bound before the motive”.</p>",
        "id": 412526734,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705059021
    },
    {
        "content": "<p>I'm always a bit skeptical about changing the behaviour of a tactic based on implicitness. Imo, changing the implicitness of an argument should only lead to the expected breakage, i.e. having to provide or omit the argument at use sites.</p>",
        "id": 412527441,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1705059339
    },
    {
        "content": "<p>But I think my proposal adheres to that expectation, if I understand you correctly: If the <code>r</code>  argument of <code>merge.induct</code> is implicit, you don’t have to mention it. If it is explicit, you have to mention it in the <code>induction … using</code> list of “targets”.</p>\n<p>Or put differently: The <code>targets</code> in the <code>induction … using</code> syntax are (already) a subset of the induction principle’s parameters, while other parameters are set up as as goals (the minor premises), calculated from the goal state (the major premise) or inferred (implicit arguments). My proposal extend that set of “explicit arguments”.</p>",
        "id": 412540110,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705064410
    },
    {
        "content": "<p>I’m recording/continuing this discussion on an RFC: <a href=\"https://github.com/leanprover/lean4/issues/3170\">https://github.com/leanprover/lean4/issues/3170</a></p>",
        "id": 412543758,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705065735
    },
    {
        "content": "<p>I would rather have implicitness affect the elaboration of applications and nothing else. Otherwise the simple explanation \"an implicit argument is inferred in applications\" becomes \"... and also a certain obscure form of induction may break\".</p>\n<p>Of course, I realise that my position is somewhat extreme, and maybe your design is, in fact, optimal in practice. I also agree that this proposed effect of implicitness is at least somewhat analogous to the standard effect.</p>",
        "id": 412557354,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1705070516
    },
    {
        "content": "<p>Well, <code>induction</code> is a form of application, and it already treats explicit and implicit parameters differently: Explicit ones (that aren’t the motive or a target) become alternative, implicit ones not (I believe). But I do see your point.</p>",
        "id": 412560541,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705071509
    },
    {
        "content": "<p>I think we should not confuse targets with parameters. Targets are the major premises and the indices of the inductive, parameters are things that do not depend on the major premise or the indices and on which everything else can depend</p>",
        "id": 412585289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705079088
    },
    {
        "content": "<p>m &lt;= n is not a parameter if m is the induction target</p>",
        "id": 412585349,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705079107
    },
    {
        "content": "<p>Agreed. So, what is <code>m &lt;= n</code>, and how should <code>induction</code> treat it?</p>\n<p>I guess  <code>n</code> is a proper parameter, and ideally instantateable (maybe using <code>(n := …)</code>), and then it's reasonable to treat <code>nm</code> like the induction cases.</p>",
        "id": 412587377,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705079794
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/induction.20using.20with.20a.20parametrized.20eliminator/near/412512821\">said</a>:</p>\n<blockquote>\n<p>and not instantiate implicit parameters during elaboration, right?</p>\n</blockquote>\n<p>The <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Tactic.elabTermForApply#doc\">docs#Lean.Elab.Tactic.elabTermForApply</a> elaboration function is how some tactics handle elaborating identifiers <code>f</code> as <code>@f</code></p>",
        "id": 412593724,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705082249
    },
    {
        "content": "<p>Thanks! That looks useful, I’ll play around with it.<br>\nI also found this idiom in the <code>simp</code> code of elaborating first, and then abstracting over mvars again:<br>\n<a href=\"https://github.com/leanprover/lean4/blob/b614ff1d12bc38f39077f9ce9f2d48b42c003ad0/src/Lean/Elab/Tactic/Simp.lean#L118-L129\">https://github.com/leanprover/lean4/blob/b614ff1d12bc38f39077f9ce9f2d48b42c003ad0/src/Lean/Elab/Tactic/Simp.lean#L118-L129</a><br>\n(but it may be that <code>simp [foo]</code> where <code>foo</code> is really just an ident has been handled before separately)</p>",
        "id": 412596180,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705083140
    },
    {
        "content": "<p>Yeah, <code>simp [foo]</code> and <code>simp [(foo)]</code> behave differently -- I believe it does something like <code>elabTermForApply</code> while processing the list of simp lemmas, but I'm not very confident about that. The second abstracts over mvars (and mathlib is taking advantage of this to work around how instances are synthesized in the first case...)</p>",
        "id": 412599304,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705084363
    },
    {
        "content": "<p>Hyrum's law is strong with us</p>",
        "id": 412599636,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705084492
    },
    {
        "content": "<p>Reading quickly, I think here's where identifiers are handled differently: <a href=\"https://github.com/leanprover/lean4/blob/b614ff1d12bc38f39077f9ce9f2d48b42c003ad0/src/Lean/Elab/Tactic/Simp.lean#L202\">https://github.com/leanprover/lean4/blob/b614ff1d12bc38f39077f9ce9f2d48b42c003ad0/src/Lean/Elab/Tactic/Simp.lean#L202</a></p>",
        "id": 412599646,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705084496
    },
    {
        "content": "<p>Playing around with this, but I think it’s not quite what I want. I'd like to elaborate <code>term</code> in  a mode  where, given <code>`ident : {motive : … } → { motive2 : … } … </code>,</p>\n<ul>\n<li><code>ident</code> is elaborated as <code>@ident</code> and not <code>@ident ?mvar</code></li>\n<li><code>ident (motive2 := m2)</code> is elaborated as <code>fun m1 =&gt; @ident m1 m2</code>, with type <code>{motive : … } → …</code> and not <code>@ident ?mvar m2</code></li>\n<li><code>ident a b</code> is elaborated normally, even if <code>ident</code> is marked as “<code>elab_as_elim</code>”<br>\nNot sure if that’s a reasonable thing to want :-)</li>\n</ul>\n<p><code>Lean.Elab.Tactic.addSimpTheorem</code> almost does that, but it forgets the names, for examples.</p>\n<p>Actually, <code>Lean.Elab.Tactic.addSimpTheorem</code> seems to kinda work. Pretty big hammer, but at least something (<a href=\"https://github.com/leanprover/lean4/pull/3188\">https://github.com/leanprover/lean4/pull/3188</a>). Doesn’t address the third point above.</p>\n<p>Maybe I should not use normal term elaboration at all, and instead parse</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">arg</span> <span class=\"o\">:=</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">…</span>\n</code></pre></div>\n<p>explicitly, supporting <em>only</em> <code>(arg := …)</code> syntax, and then doing the right thing behind the scenes. Probably much easier to control what’s happening this way, and also produce good error messages (e.g. when the user wants to set the motive or the target, which wouldn’t work.)</p>",
        "id": 416046943,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705503295
    }
]