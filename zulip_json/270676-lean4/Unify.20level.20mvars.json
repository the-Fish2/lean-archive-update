[
    {
        "content": "<p>I was hoping I could use <code>isDefEq</code> to unify level mvars, but apparently this doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span>\n\n<span class=\"c1\">-- Eq.{?_uniq.1061}</span>\n<span class=\"k\">#eval</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">e₁</span> <span class=\"o\">:=</span> <span class=\"n\">Expr.const</span> <span class=\"bp\">`</span><span class=\"n\">Eq</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">e₂</span> <span class=\"bp\">←</span> <span class=\"n\">mkConstWithFreshMVarLevels</span> <span class=\"bp\">`</span><span class=\"n\">Eq</span>\n  <span class=\"n\">unless</span> <span class=\"bp\">←</span> <span class=\"n\">isDefEq</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span> <span class=\"k\">do</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"not defeq\"</span>\n  <span class=\"n\">return</span> <span class=\"n\">e₂</span>\n</code></pre></div>\n<p>What would be the right approach here?</p>",
        "id": 416850652,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1705691926
    },
    {
        "content": "<p>Ah, as always the solution was <code>instantiateMVars e₂</code>.</p>",
        "id": 416851889,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1705692370
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"372804\">Marcus Rossel</span> has marked this topic as resolved.</p>",
        "id": 416851898,
        "sender_full_name": "Notification Bot",
        "timestamp": 1705692374
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"372804\">Marcus Rossel</span> has marked this topic as unresolved.</p>",
        "id": 416854007,
        "sender_full_name": "Notification Bot",
        "timestamp": 1705693151
    },
    {
        "content": "<p>Actually, in this example even instantiating mvars doesn't help:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">do</span> <span class=\"c1\">-- OfNat.ofNat.{?_uniq.1} Nat (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0)) instOfNatNat.{0}</span>\n  <span class=\"k\">let</span> <span class=\"n\">u</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshLevelMVar</span>\n  <span class=\"k\">let</span> <span class=\"n\">e₁</span> <span class=\"o\">:=</span> <span class=\"n\">mkAppN</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">`</span><span class=\"n\">OfNat.ofNat</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span> <span class=\"bp\">#</span><span class=\"o\">[(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">`</span><span class=\"n\">Nat</span> <span class=\"o\">[]),</span> <span class=\"o\">(</span><span class=\"n\">mkNatLit</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">`</span><span class=\"n\">instOfNatNat</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])]</span>\n  <span class=\"k\">let</span> <span class=\"n\">e₂</span> <span class=\"o\">:=</span> <span class=\"n\">mkAppN</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">`</span><span class=\"n\">OfNat.ofNat</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">])</span> <span class=\"bp\">#</span><span class=\"o\">[(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">`</span><span class=\"n\">Nat</span> <span class=\"o\">[]),</span> <span class=\"o\">(</span><span class=\"n\">mkNatLit</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">`</span><span class=\"n\">instOfNatNat</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])]</span>\n  <span class=\"n\">unless</span> <span class=\"bp\">←</span> <span class=\"n\">isDefEq</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span> <span class=\"k\">do</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"not defeq\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">e₂'</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"n\">e₂</span>\n  <span class=\"n\">IO.println</span> <span class=\"n\">e₂'</span>\n</code></pre></div>",
        "id": 416854043,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1705693170
    },
    {
        "content": "<p>isDefEq assumes that your expressions are well-typed. I wouldn't be surprised if it's skipping steps it knows it can skip with this assumption.</p>",
        "id": 416858547,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705694799
    },
    {
        "content": "<p>How are you in this situation where you have a metavariable in an expression like that, where it's not already constrained by the other arguments?</p>",
        "id": 416858598,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705694821
    },
    {
        "content": "<p>By the way, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.mkNatLit#doc\">docs#Lean.mkNatLit</a> is how you make a natlit expression for Nat</p>",
        "id": 416858798,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705694890
    },
    {
        "content": "<p>There's also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.mkNumeral#doc\">docs#Lean.Meta.mkNumeral</a> for general types</p>",
        "id": 416858960,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705694945
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Unify.20level.20mvars/near/416858598\">said</a>:</p>\n<blockquote>\n<p>How are you in this situation where you have a metavariable in an expression like that, where it's not already constrained by the other arguments?</p>\n</blockquote>\n<p>I'm using an external solver to generate a sequence of rewrites for a proof, and the expression language of that external solver doesn't have a notion universe levels. Now I'm trying to reconstruct Lean expressions from those external expression and my idea was to fill in the missing pieces with mvars which can then all be inferred during further steps.<br>\nIs there some other way to tell Lean to figure out the level mvars? Or is this not generally possible?</p>",
        "id": 416889953,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1705706378
    },
    {
        "content": "<p>I was expecting <code>instantiateLevelMVars</code> to help here, but it doesn't seem to</p>",
        "id": 416940993,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705713625
    }
]