[
    {
        "content": "<p>Consider a situation where we want to, for example, introduce an extensible class of headers for match alts.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">declare_syntax_category</span> <span class=\"n\">customAltHeader</span>\n</code></pre></div>\n<p>We'd want something <em>like</em> either of the following to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- `matchAlts` is not a leading parser, so fails</span>\n<span class=\"n\">syntax</span> <span class=\"n\">customMatches</span> <span class=\"o\">:=</span> <span class=\"n\">customAltHeader</span> <span class=\"n\">Lean.Parser.Term.matchAlts</span>\n\n<span class=\"c1\">-- `customAltHeader` is not even a parser, so this doesn't make sense</span>\n<span class=\"kd\">def</span> <span class=\"n\">Parser.customMatches</span> <span class=\"o\">:=</span> <span class=\"n\">leading_parser</span> <span class=\"n\">customAltHeader</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">Lean.Parser.Term.matchAlts</span>\n</code></pre></div>\n<p>I could wrap <code>matchAlts</code> in a leading_parser then use <code>syntax</code>, but I'm a bit wary of this—would it change the behavior of something that appears everywhere?</p>\n<p>What's the best way to accomplish this?</p>",
        "id": 424121901,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1709246350
    },
    {
        "content": "<p>(I'm also realizing that I have to do this with multiple non-leading parsers if I go the wrapping route, so I'm hoping for a more elegant solution! :) )</p>",
        "id": 424123587,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1709247166
    },
    {
        "content": "<p>I'm a little confused, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parser.Term.matchAlts#doc\">docs#Lean.Parser.Term.matchAlts</a> uses <code>leading_parser</code>, and you can use any <code>Parser</code> with <code>syntax</code> whether or not it's using <code>leading_parser</code>. That macro just sets up creating a Syntax node whose kind is given by the current declaration's identifier, as well as setting up being able to handle antiquotations.</p>\n<p>It seems like somehow <code>matchAlts</code> isn't working maybe because it's got an (optional) argument?</p>",
        "id": 424151309,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709261433
    },
    {
        "content": "<p>Making it not have an argument makes it work.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">declare_syntax_cat</span> <span class=\"n\">customAltHeader</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">myMatchAlts</span> <span class=\"o\">:=</span> <span class=\"n\">Lean.Parser.Term.matchAlts</span>\n\n<span class=\"n\">syntax</span> <span class=\"n\">customMatches</span> <span class=\"o\">:=</span> <span class=\"n\">customAltHeader</span> <span class=\"n\">myMatchAlts</span>\n</code></pre></div>",
        "id": 424151396,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709261518
    },
    {
        "content": "<p>Ah, ok, so when I wrapped it in <code>leading_parser</code> and it worked, I was really just eliminating the argument.</p>",
        "id": 424151483,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1709261566
    },
    {
        "content": "<p>(I’m realizing I mixed up a recent brush with “non-leading parsers don’t work in standalone syntax quotation matches” with “non-leading parsers don’t work in <code>syntax</code> declarations”, and was more ready to believe the leading_parser was the crucial bit…)</p>",
        "id": 424151620,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1709261663
    }
]