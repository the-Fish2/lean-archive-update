[
    {
        "content": "<p>Can someone explain why</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Inhabit</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">default</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">baddie</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Inhabit</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">b</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>gives this strange error message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">code</span> <span class=\"n\">generator</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"n\">support</span> <span class=\"n\">recursor</span> <span class=\"bp\">'</span><span class=\"n\">Inhabit.rec'</span> <span class=\"n\">yet</span><span class=\"o\">,</span> <span class=\"n\">consider</span> <span class=\"n\">using</span> <span class=\"bp\">'</span><span class=\"k\">match</span> <span class=\"bp\">...</span> <span class=\"k\">with</span><span class=\"bp\">'</span> <span class=\"n\">and</span><span class=\"bp\">/</span><span class=\"n\">or</span> <span class=\"n\">structural</span> <span class=\"n\">recursion</span>\n</code></pre></div>\n<p>(This is my minified example; obviously I don't actually want to do <code>s x</code>. But it is giving me real grief with things being noncomputable when I want them to be runnable.)</p>",
        "id": 428232986,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1711062634
    },
    {
        "content": "<p>Like, all the types here ... _look_ reasonable, to my naive eyes. I thought that, in Lean, if I write a type, I can get code generated for it. But somehow a type as simple as <code>Inhabited</code> is not able to get code?</p>",
        "id": 428233030,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1711062679
    },
    {
        "content": "<p>This <code>induction</code> uses the <code>Inhabit.rec</code> function, and the current compiler doesn't compile things with recursors in it.</p>\n<p>You can use <code>match</code> instead, which does produce compilable definitions.</p>",
        "id": 428233059,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711062710
    },
    {
        "content": "<p>There's also a command in mathlib to make recursors compilable (one at a time).</p>",
        "id": 428233128,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711062739
    },
    {
        "content": "<p>In general you almost never want to use tactics to define functions that you wish to do computations. A tactic's job is to generate some inhabitant of some type, not generate an efficient program that computes one.</p>",
        "id": 428233143,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1711062762
    },
    {
        "content": "<p>Check out <code>compile_inductive%</code> in Mathlib.Util.CompileInductive, if that's something you really want to do.</p>",
        "id": 428233152,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711062768
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/.22code.20generator.20does.20not.20support.20recursor.22/near/428233143\">said</a>:</p>\n<blockquote>\n<p>In general you almost never want to use tactics to define functions that you wish to do computations. A tactic's job is to generate some inhabitant of some time, not generate an efficient program that computes one.</p>\n</blockquote>\n<p>Right, I'm aware. But I was trying to prove a complicated <code>Decidable</code> instance, one that would be a pretty big mess to write as a proof term</p>",
        "id": 428233271,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1711062847
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/.22code.20generator.20does.20not.20support.20recursor.22/near/428233152\">said</a>:</p>\n<blockquote>\n<p>Check out <code>compile_inductive%</code> in Mathlib.Util.CompileInductive, if that's something you really want to do.</p>\n</blockquote>\n<p>very neat. I'll check it out. Thanks!</p>",
        "id": 428233283,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1711062857
    },
    {
        "content": "<p>You can do the computation with term mode and the proof with tactic mode, that's perfectly fine.</p>",
        "id": 428233304,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1711062873
    },
    {
        "content": "<p>One of the questions about recursors is \"what is the intended evaluation order\". They're not <em>really</em> normal functions. For example, in <code>Option.rec</code>, naively compiling it would cause it to evaluate the code for the <code>none</code> case even if it's for <code>some</code>.</p>",
        "id": 428233308,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711062877
    },
    {
        "content": "<blockquote>\n<p>But I was trying to prove a complicated <code>Decidable</code> instance, one that would be a pretty big mess to write as a proof term</p>\n</blockquote>\n<p>Even for <code>Decidable</code> instances, you generally want to avoid a tactic.</p>",
        "id": 428233340,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711062902
    },
    {
        "content": "<p>One tool you can use is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=decidable_of_iff#doc\">docs#decidable_of_iff</a></p>",
        "id": 428233366,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711062933
    },
    {
        "content": "<p>So, what, it would be something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">efficientFunc</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">proof</span> <span class=\"n\">term</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">efficientFunc_iff</span> <span class=\"o\">:</span> <span class=\"n\">efficientFunc</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span><span class=\"c1\">--&gt; x := by [tactics]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">decidable_of_iff</span> <span class=\"n\">efficientFunc_iff</span>\n</code></pre></div>\n<p>?</p>",
        "id": 428233462,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1711062993
    },
    {
        "content": "<p>(If this is for <code>DecidableEq</code> of your own inductive type, then make sure to try <code>deriving DecidableEq</code> first)</p>",
        "id": 428233469,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711062998
    },
    {
        "content": "<p>If you use tactics to create a <code>Decidable</code> instance, you can get into situations where the instance isn't reducible, which is a pain if you wanted to use <code>decide</code> to prove things using that instance.</p>",
        "id": 428233555,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711063062
    },
    {
        "content": "<p>Mm, okay, this still seems hard for me to use well. The real efficient code is a recursive call (hence the <code>induction</code>) with some natural numbers, but it calls itself with some smaller natural numbers. Defining the function requires strong induction on the naturals, then; I don't see a way to even <code>def</code> it without <code>Nat.strongInductionOn</code>. But that's a noncomputable definition because it relies on the recursor of <code>Acc</code> (whatever the heck that is :P )</p>",
        "id": 428233957,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1711063321
    },
    {
        "content": "<p>Do you know about well founded recursion and <code>termination_by</code>?</p>",
        "id": 428234035,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1711063366
    },
    {
        "content": "<p>I know about well-founded recursion; the frustrating part seems to be that all the lemmas for that in WF.lean seem noncomputable :) I've seen <code>termination_by</code> but don't really get how to use it.</p>",
        "id": 428234101,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1711063415
    },
    {
        "content": "<p>Right, generally speaking you are not supposed to use any of the well founded recursion stuff directly but instead do the following: Define your function in a way that you think terminates and then provide a term with <code>termination_by</code> that you know decreases every call. <code>termination_by</code> can often either:<br>\na) automatically figure out what this term should be on its own, in which case you don't need to provide it<br>\nb) automatically figure out that the term decreases if you provided one<br>\nIf both thing's don't work it will tell you which recursive calls it failed to verify and which \"this thing gets smaller\" proofs to provide.</p>",
        "id": 428234275,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1711063536
    },
    {
        "content": "<p>By doing this the compiler will generate exactly the efficient code that you wrote and the type theory part of Lean will be content, knowing that your function terminates.</p>",
        "id": 428234342,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1711063566
    },
    {
        "content": "<p>Neat! Alright, I'll give that a spin. Thanks!</p>",
        "id": 428234357,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1711063576
    },
    {
        "content": "<p>Yeah forking out the <code>def</code> from the correctness proof/instance, and using <code>termination_by</code>, seemed to be what I wanted :)</p>",
        "id": 428279016,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1711095279
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> has marked this topic as resolved.</p>",
        "id": 428279023,
        "sender_full_name": "Notification Bot",
        "timestamp": 1711095283
    }
]