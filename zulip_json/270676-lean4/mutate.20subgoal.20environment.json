[
    {
        "content": "<p>I'm in the middle of a tactic proof that looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">match</span> <span class=\"n\">s</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">or</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">have</span> <span class=\"n\">hff₁₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">Bool.or</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Model.value</span><span class=\"o\">,</span> <span class=\"n\">Interpretation.fns</span><span class=\"o\">]</span>\n  <span class=\"n\">conv</span> <span class=\"n\">at</span> <span class=\"n\">ih₁</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lhs</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Dual.dual</span><span class=\"o\">]</span>\n  <span class=\"n\">conv</span> <span class=\"n\">at</span> <span class=\"n\">ih₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lhs</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Dual.dual</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ih₁</span><span class=\"o\">,</span> <span class=\"n\">ih₂</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Dual.dual</span><span class=\"o\">,</span> <span class=\"n\">Signature.Formula.function</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[(</span><span class=\"kd\">by</span> <span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"bp\">~</span><span class=\"n\">w.vec</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">vec</span><span class=\"o\">),</span> <span class=\"n\">hf₁</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">hf₂</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">hff₁₂</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Bool.not_or</span><span class=\"o\">,</span> <span class=\"n\">Bool.not_and</span><span class=\"o\">]</span>\n\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">and</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">have</span> <span class=\"n\">hff₁₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">Bool.and</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Model.value</span><span class=\"o\">,</span> <span class=\"n\">Interpretation.fns</span><span class=\"o\">]</span>\n  <span class=\"n\">conv</span> <span class=\"n\">at</span> <span class=\"n\">ih₁</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lhs</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Dual.dual</span><span class=\"o\">]</span>\n  <span class=\"n\">conv</span> <span class=\"n\">at</span> <span class=\"n\">ih₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lhs</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Dual.dual</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ih₁</span><span class=\"o\">,</span> <span class=\"n\">ih₂</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Dual.dual</span><span class=\"o\">,</span> <span class=\"n\">Signature.Formula.function</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[(</span><span class=\"kd\">by</span> <span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"bp\">~</span><span class=\"n\">w.vec</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">vec</span><span class=\"o\">),</span> <span class=\"n\">hf₁</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">hf₂</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">hff₁₂</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Bool.not_or</span><span class=\"o\">,</span> <span class=\"n\">Bool.not_and</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Notice the proofs in each of the two arms are the same except for the first line. This first line in each arm introduces a new term into each of the arms' environments. Is there a way to do this and then \"return\" to the top level? I'm imagining some code like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">match</span> <span class=\"n\">s</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">or</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">have</span> <span class=\"n\">hff₁₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">Bool.or</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">and</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">have</span> <span class=\"n\">hff₁₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">Bool.and</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">  The two cases `and` and `or` would then return to being subgoals as they</span>\n<span class=\"cm\">  are not resolved(?) yet.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"n\">all_goals</span> <span class=\"o\">{</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Model.value</span><span class=\"o\">,</span> <span class=\"n\">Interpretation.fns</span><span class=\"o\">]</span>\n  <span class=\"n\">conv</span> <span class=\"n\">at</span> <span class=\"n\">ih₁</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lhs</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Dual.dual</span><span class=\"o\">]</span>\n  <span class=\"n\">conv</span> <span class=\"n\">at</span> <span class=\"n\">ih₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lhs</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Dual.dual</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ih₁</span><span class=\"o\">,</span> <span class=\"n\">ih₂</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Dual.dual</span><span class=\"o\">,</span> <span class=\"n\">Signature.Formula.function</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[(</span><span class=\"kd\">by</span> <span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"bp\">~</span><span class=\"n\">w.vec</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">vec</span><span class=\"o\">),</span> <span class=\"n\">hf₁</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">hf₂</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">hff₁₂</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Bool.not_or</span><span class=\"o\">,</span> <span class=\"n\">Bool.not_and</span><span class=\"o\">]</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 412736675,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705175583
    },
    {
        "content": "<p>May not apply in your case, but if the goals are the same after these lines(not just the tactics), and it's not too bad to spell it out, you can manually <code>have</code> the goal before the case, and then use <code>assumption</code> in the cases.</p>",
        "id": 412748003,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705182385
    },
    {
        "content": "<p>Or, rather than using <code>match</code>, you could use <code>cases</code> followed by <code>case'</code> blocks.</p>\n<p>Maybe something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">cases</span> <span class=\"n\">s</span>\n<span class=\"n\">case'</span> <span class=\"n\">or</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">have</span> <span class=\"n\">hff₁₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">Bool.or</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"n\">case'</span> <span class=\"n\">and</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">have</span> <span class=\"n\">hff₁₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">Bool.and</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"n\">all_goals</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Model.value</span><span class=\"o\">,</span> <span class=\"n\">Interpretation.fns</span><span class=\"o\">]</span>\n  <span class=\"n\">conv</span> <span class=\"n\">at</span> <span class=\"n\">ih₁</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lhs</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Dual.dual</span><span class=\"o\">]</span>\n  <span class=\"n\">conv</span> <span class=\"n\">at</span> <span class=\"n\">ih₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lhs</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Dual.dual</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ih₁</span><span class=\"o\">,</span> <span class=\"n\">ih₂</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Dual.dual</span><span class=\"o\">,</span> <span class=\"n\">Signature.Formula.function</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[(</span><span class=\"kd\">by</span> <span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"bp\">~</span><span class=\"n\">w.vec</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">vec</span><span class=\"o\">),</span> <span class=\"n\">hf₁</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">hf₂</span> <span class=\"o\">(</span><span class=\"bp\">~</span><span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">hff₁₂</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Bool.not_or</span><span class=\"o\">,</span> <span class=\"n\">Bool.not_and</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 412752068,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705185030
    },
    {
        "content": "<p>If you're using <code>match</code> for recursion, maybe you could use <code>induction</code> instead of <code>cases</code>. You might also be able to set up using some named metavariables in conjunction with <code>refine match s with ...</code> and do something like this <code>case'</code> option.</p>",
        "id": 412752146,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705185113
    },
    {
        "content": "<p>oh does <code>case'</code> not fail if the sub goals aren't resolved?</p>",
        "id": 412752641,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705185536
    },
    {
        "content": "<p>Yes. Here's its docstring:</p>\n<blockquote>\n<p><code>case'</code> is similar to the <code>case tag =&gt; tac</code> tactic, but does not ensure the goal has been solved after applying <code>tac</code>, nor admits the goal if <code>tac</code> failed. Recall that <code>case</code> closes the goal using sorry when <code>tac</code> fails, and the tactic execution is not interrupted.</p>\n</blockquote>",
        "id": 412753153,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705185941
    },
    {
        "content": "<p>Sweet, that's basically what I was looking for. Thanks!</p>",
        "id": 412753683,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705186423
    }
]