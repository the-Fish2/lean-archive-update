[
    {
        "content": "<p>Using  the dependent recursor<code>Nat.rec</code> for Lean's natural numbers, one gets a definition of the non-dependent recursor as a special case:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\">  </span><span class=\"c1\">-- Nat.rec.{u} {motive : Nat → Sort u} (zero : motive Nat.zero) (succ : (n : Nat) → motive n → motive n.succ) (t : Nat) : motive t</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"c1\">-- Nat.elim.{l} {X : Sort l} : X → (Nat → X → X) → Nat → X</span>\n</code></pre></div>\n<p>However, if I try to define the natural numbers myself, I can follow the same method and it seems to type check, but an error message appears that says <code>code generator does not support recursor 'myNat.rec' yet</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">myNat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myNat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">myNat</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">myNat</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\">  </span><span class=\"c1\">-- myNat.rec.{u} {motive : myNat → Sort u} (zero : motive myNat.zero) (succ : (a : myNat) → motive a → motive a.succ) (t : myNat) : motive t</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myNat</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">myNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">myNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\"> </span><span class=\"c1\">-- code generator does not support recursor 'myNat.rec' yet, consider using 'match ... with' and/or structural recursion</span>\n<span class=\"w\">  </span><span class=\"n\">myNat</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">myNat</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\">  </span><span class=\"c1\">-- myNat.elim.{l} {X : Sort l} : X → (myNat → X → X) → myNat → X</span>\n</code></pre></div>\n<p>Is there a way to fix this so I do not get the error message? Or should I not expect <code>myNat.rec</code> to work like this?</p>",
        "id": 443810211,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1718036531
    },
    {
        "content": "<p>I believe this is expected, and the reason is stated exactly in the error message. You can fix this by writing <code>elim</code> as a recursive function over the <code>myNat</code> argument (using <code>match</code>).</p>",
        "id": 443834348,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1718043177
    },
    {
        "content": "<p>Or import Mathlib and </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">suppress_compilation</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myNat</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">myNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">myNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 443839865,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1718044952
    },
    {
        "content": "<p>No need to import Mathlib, using <code>noncomputable def</code> is enough.</p>",
        "id": 443849330,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1718048288
    },
    {
        "content": "<p>Thank you all <span aria-label=\"blush\" class=\"emoji emoji-1f60a\" role=\"img\" title=\"blush\">:blush:</span> But why does this not happen with <code>Nat</code>only with <code>myNat</code>?</p>",
        "id": 443849872,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1718048469
    },
    {
        "content": "<p>I expect because of these lines in <code>Lean/Init/Data/Nat/Basic.lean</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Compiled version of `Nat.rec` so that we can define `Nat.recAux` to be defeq to `Nat.rec`.</span>\n<span class=\"sd\">This is working around the fact that the compiler does not currently support recursors. -/</span>\n<span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">recCompiled</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">t</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">zero</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">recCompiled</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">csimp</span><span class=\"kd\">]</span>\n<span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">rec_eq_recCompiled</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">recCompiled</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">recOn</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 443851229,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1718048916
    },
    {
        "content": "<p><code>@[csimp] theorem foo : a = b</code> means that the compiler will replace <code>a</code> by <code>b</code> everywhere, before actually compiling a definition.</p>",
        "id": 443851443,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1718048987
    },
    {
        "content": "<p>(This isn't answering any questions here, but I'll mention that Mathlib has a <code>compile_inductive%</code> command for constructing an auxiliary definition using <code>match</code> and auto-proving the <code>csimp</code> lemma.)</p>",
        "id": 444052984,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718124802
    },
    {
        "content": "<p>Oh, nice! Is the plan for this to eventually become part of the core commands?</p>",
        "id": 444081331,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1718133804
    },
    {
        "content": "<p>It's more likely that the compiler will just support recursors.</p>",
        "id": 444095336,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1718137925
    },
    {
        "content": "<p>Right, that makes more sense. But I'm curious: does support recursors mean more than having a command that creates the auxiliary definition  and proves the <code>csimp</code> lemma?</p>",
        "id": 444157953,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1718173874
    },
    {
        "content": "<p>In general we do not have recursors because they can easily be used to generate bad code with unforseen performance characteristics. If you inspect e.g. <code>Nat.rec</code> you will see that the <code>Nat.succ n</code> case always expects the result of the computation for the <code>n</code> already. This means that you can never early abort a computation that's done with a recursor. So if you say, implement <code>List.isEmtpy</code> with a recursor you will always iterate through the entire list despite knowing it is indeed empty (or not) after the first step.</p>\n<p>The way to fix this properly would be to have support in the code generator for a transformation that defers this recursive call(s) until they are actually required by the code that is using them. But that would be work for basically no result so that's why the state is like it currently is..</p>",
        "id": 444158446,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1718174102
    },
    {
        "content": "<p>Thanks for the explanation! <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span></p>",
        "id": 444165198,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1718177003
    }
]