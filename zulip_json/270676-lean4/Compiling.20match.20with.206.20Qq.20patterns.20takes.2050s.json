[
    {
        "content": "<p>Good evening everyone, I have another metaprogramming question, I have I'm not through my question credits yet...</p>\n<p>I'm at the following program now:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span> <span class=\"n\">Term</span> <span class=\"n\">Meta</span> <span class=\"n\">PrettyPrinter</span> <span class=\"n\">Qq</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">simplifyLocalDecl</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">localDecl</span> <span class=\"o\">:</span> <span class=\"n\">LocalDecl</span><span class=\"o\">):</span> <span class=\"n\">TacticM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">localDecl.fvarId</span>\n  <span class=\"k\">let</span> <span class=\"n\">xx</span> <span class=\"bp\">←</span> <span class=\"n\">inferTypeQ</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">fvar</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">res</span> <span class=\"bp\">←</span> <span class=\"k\">match</span> <span class=\"n\">xx</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">∨</span> <span class=\"n\">_</span><span class=\"o\">)),</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">none</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">∧</span> <span class=\"n\">_</span><span class=\"o\">)),</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">none</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">¬¬</span><span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">none</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">¬$</span><span class=\"n\">p</span><span class=\"o\">),</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">none</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">∧</span> <span class=\"n\">_</span><span class=\"o\">)),</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">none</span> <span class=\"c1\">-- A</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">((</span><span class=\"n\">_</span> <span class=\"bp\">∧</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">none</span> <span class=\"c1\">-- B</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">none</span>\n</code></pre></div>\n<p>It does exactly what I want, but it's a bit slow to compile. Without the lines marked A and B, its a second or so until the yellow bar on the left of the vscodeditor and the \"busy\" tooltip disappears. With the lines marked A and B included, it takes about 50 seconds. My laptop is by no means beefy but performance hasn't been a problem for me (yet...). </p>\n<p>In the MWE I factored out the two or patterns into a separate def that just returns a bool if it matches, which brings compile time down to 5, so I can probably continue with that workaround. But it's a bit of a strange case. Is this just me abusing/misusing Qq or should I post an issue for this somewhere?</p>",
        "id": 422037910,
        "sender_full_name": "Bob Rubbens",
        "timestamp": 1708199175
    },
    {
        "content": "<p>Is the issue the patterns themselves, or just the fact that there are lots of patterns?</p>",
        "id": 422318683,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708383852
    },
    {
        "content": "<p>Matches with many patterns, and each pattern looking deeply, have a known performance limitation. We'd like to have a language level fix, but realistically this is not within the next 6 months.</p>\n<p>My personal recommendation is to avoid the <code>quote4</code> library, and instead use nested match statements using <code>e.getAppFnArgs</code>.</p>",
        "id": 422322757,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1708387142
    },
    {
        "content": "<p>I'm surprised the depth of the pattern affects the <em>compilation</em> time in a major way</p>",
        "id": 422340511,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708401111
    },
    {
        "content": "<p>I wonder if Qq is just missing some type annotations internally that would stop what I assume is elaborate blow up</p>",
        "id": 422340641,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708401195
    },
    {
        "content": "<p>I agree that some of the issues with <code>~q</code> (<a href=\"https://github.com/leanprover-community/quote4/issues/21\">#21</a>, <a href=\"https://github.com/leanprover-community/quote4/issues/36\">#36</a>) are fixable only with language-level changes; <code>do</code> notation needs do extension hooks to allow custom matching, otherwise it's basically impossible to handle all the bells and whistles of <code>do</code> notation (<code>let mut</code>, <code>return</code>) correctly</p>",
        "id": 422340781,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708401318
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Compiling.20match.20with.206.20Qq.20patterns.20takes.2050s/near/422318683\">said</a>:</p>\n<blockquote>\n<p>Is the issue the patterns themselves, or just the fact that there are lots of patterns?</p>\n</blockquote>\n<p>Filed as <a href=\"https://github.com/leanprover-community/quote4/issues/37\">https://github.com/leanprover-community/quote4/issues/37</a> with a mwe</p>",
        "id": 422360447,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708414047
    },
    {
        "content": "<p>I'd be very happy to supervise a project to implement matching up to reducible defeq 'done right', if anyone is interested.</p>",
        "id": 422385778,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1708424202
    },
    {
        "content": "<p>I think the hard part is the syntax change to <code>do</code> notation and getting buy-in (of time spent reviewing an important part of Lean) from the FRO</p>",
        "id": 422389736,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708425640
    },
    {
        "content": "<p>Solving these issues would also be nice, but they don't bother me too much. What bothers me more, and what the proposed project would address, is that Qq matching is very wasteful. Currently, the <code>match</code> in the example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Lean.Elab.Tactic</span> <span class=\"n\">Qq</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TacticM</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">←</span> <span class=\"n\">inferTypeQ</span> <span class=\"n\">e</span>\n    <span class=\"bp\">|</span> <span class=\"n\">return</span>\n  <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">And</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f1</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Or</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">And</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f2</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Or</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Or</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f3</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">test</span>\n</code></pre></div>\n<p>essentially compiles to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">pat1</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">elabPattern</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">And</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"k\">if</span> <span class=\"n\">isDefEq</span> <span class=\"n\">e</span> <span class=\"n\">pat1</span> <span class=\"k\">then</span>\n  <span class=\"n\">f1</span>\n<span class=\"k\">else</span>\n  <span class=\"k\">let</span> <span class=\"n\">pat2</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">elabPattern</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Or</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">And</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">))</span>\n  <span class=\"k\">if</span> <span class=\"n\">isDefEq</span> <span class=\"n\">e</span> <span class=\"n\">pat2</span> <span class=\"k\">then</span>\n    <span class=\"n\">f2</span>\n  <span class=\"k\">else</span>\n    <span class=\"k\">let</span> <span class=\"n\">pat3</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">elabPattern</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Or</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Or</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">))</span>\n    <span class=\"k\">if</span> <span class=\"n\">isDefEq</span> <span class=\"n\">e</span> <span class=\"n\">pat3</span> <span class=\"k\">then</span>\n      <span class=\"n\">f3</span>\n    <span class=\"k\">else</span>\n      <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(Actually, Qq reorders the patterns for some reason.) This is a very effective hack, but what you would write by hand is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">match</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">whnf</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">And</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f1</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Or</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">whnf</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">And</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f2</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Or</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f3</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>So instead of three <code>isDefEq</code>s you have two <code>whnf</code>s, one for each level of the pattern. It's conceptually easy to derive the latter implementation from the <code>~q</code> match syntax, though the devil is probably in the details.</p>",
        "id": 422404986,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1708431383
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/270676-lean4/topic/Compiling.20match.20with.206.20Qq.20patterns.20takes.2050s/near/422404986\">said</a>:</p>\n<blockquote>\n<p>(Actually, Qq reorders the patterns for some reason.)</p>\n</blockquote>\n<p>Scratch this, I just didn't understand the code.</p>",
        "id": 422406627,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1708431984
    },
    {
        "content": "<blockquote>\n<p>is that Qq matching is very wasteful</p>\n</blockquote>\n<p>Just to be clear, the title of this thread is about wastefulness at elaboration time, whereas it sounds like you're suggesting reducing wastefulness at runtime. Of course, both would be beneficial!</p>",
        "id": 422410008,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708433322
    },
    {
        "content": "<blockquote>\n<p>Solving these issues would also be nice, but they don't bother me too much.</p>\n</blockquote>\n<p>I think <code>return</code> notation doing completely the wrong thing is pretty damning, and a big footgun</p>",
        "id": 422410168,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708433374
    },
    {
        "content": "<p>Sorry, what's the problem with <code>return</code>?</p>",
        "id": 422414161,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708434700
    },
    {
        "content": "<p>See Eric's example in <a href=\"https://github.com/leanprover-community/quote4/issues/21\">https://github.com/leanprover-community/quote4/issues/21</a></p>",
        "id": 422414853,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1708434894
    },
    {
        "content": "<p>The problem is that <code>¬q</code> doesn't (can't?) participate in the <code>do</code> notation magic, so has to try and build something on top of it. I think this is impossible to do correctly (without other bad choices like duplicating syntax)</p>",
        "id": 422415042,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708434954
    },
    {
        "content": "<p>the return behaves like rust and not like haskell (if I remember correctly)</p>",
        "id": 422415166,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1708434985
    },
    {
        "content": "<p>and for comparison:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo₃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"bp\">←</span> <span class=\"k\">match</span> <span class=\"n\">a</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">37</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">true</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">true</span>\n  <span class=\"n\">return</span> <span class=\"n\">false</span> <span class=\"c1\">-- `do` element is unreachable</span>\n</code></pre></div>",
        "id": 422416222,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1708435314
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Compiling.20match.20with.206.20Qq.20patterns.20takes.2050s/near/422410008\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>is that Qq matching is very wasteful</p>\n</blockquote>\n<p>Just to be clear, the title of this thread is about wastefulness at elaboration time, whereas it sounds like you're suggesting reducing wastefulness at runtime. Of course, both would be beneficial!</p>\n</blockquote>\n<p>Yes, sorry for the confusion. The alternative design I propose might also benefit elaboration, but only as a side effect.</p>",
        "id": 422418784,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1708436201
    }
]