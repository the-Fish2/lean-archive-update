[
    {
        "content": "<p>In our Coq formalisation, we sometimes resort to the following kind of pattern to define inductive propositions of a certain kind:</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Inductive</span> <span class=\"n\">R</span> <span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">|</span> <span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n<span class=\"o\">|</span> <span class=\"n\">ind</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">-&gt;</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"k\">forall</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">R</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">/\\</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">R</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">.</span>\n</code></pre></div>\n<p>The main thing of note is that the definition is dependent on <code>f</code> applied to a quantified <code>n</code>, and it is also passed to a relation <code>F</code> to show that the relation holds for a <code>b</code>.</p>\n<p>However, when I try to define the same relation in Lean, I get the following errors.  Even after removing the inner quantification and lifting it up to the top, it seems to have issues with the <code>/\\</code> specifically.  This is because in the last step, I just switch the and for implication and lean seems to accept that definition.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> (kernel) invalid nested inductive datatype 'And', nested inductive datatypes</span>\n<span class=\"cm\">parameters cannot contain local variables. -/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">R</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">ind</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">R</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> (kernel) invalid nested inductive datatype 'And', nested inductive datatypes</span>\n<span class=\"cm\">parameters cannot contain local variables. -/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">R'</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">R'</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">ind</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">R'</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">R'</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Works, but not the definition we need. -/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">R''</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">R''</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">ind</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">R''</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">R''</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>It's not clear to me exactly what lean is complaining about, and if it would be possible to encode the same kind of inductive predicate that we have in Coq in a different way in lean maybe.  </p>\n<p>Does someone have any insights into what might be causing the problem?</p>",
        "id": 419265713,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1706799878
    },
    {
        "content": "<p>AFAIK, the way Lean checks nested inductive types is that it encodes them as mutual inductives. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Tree</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Tree</span> <span class=\"bp\">→</span> <span class=\"n\">Tree</span>\n</code></pre></div>\n<p>Will be encoded as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Tree₂</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">:</span> <span class=\"n\">ListTree</span> <span class=\"bp\">→</span> <span class=\"n\">Tree₂</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">ListTree</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span>  <span class=\"o\">:</span> <span class=\"n\">ListTree</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">Tree₂</span> <span class=\"bp\">→</span> <span class=\"n\">ListTree</span> <span class=\"bp\">→</span> <span class=\"n\">ListTree</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>One drawback of doing things this way is that you cannot get free variables to appear in the parameters of your nested inductive type (in your case, <code>And</code>),  since the translation would fail (parameters are supposed to stay constant inside the mutual block). I don't see an easy way to do this, but more competent people might have some ideas.</p>",
        "id": 419317066,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1706815369
    },
    {
        "content": "<p>I was hoping something like this could work, but I get a not-so informative error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">ind</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">And₂</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">And₂</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">):</span> <span class=\"n\">R</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">And₂</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">f</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">end</span>\n<span class=\"c\">/-</span><span class=\"cm\">(kernel) declaration has free variables 'And₂'-/</span>\n</code></pre></div>",
        "id": 419322703,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1706817458
    },
    {
        "content": "<p>Thanks a lot, that does make sense.  And I've actually been trying to get the same to work, but get the same not-so-informative error, so I've been trying to minimise it but can't really identify what the issue is with this mutual definition either.</p>",
        "id": 419323201,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1706817632
    },
    {
        "content": "<p>OK, it seems to be a type mismatch actually, so by defining an arbitrary type that is shared between the two definitions, this mutual inductive definition can actually be defined.  I think that this mutual definition might be equivalent to the definition we have in Coq, I'll have to try and play with it now to see if it is easy to work with, but thank you for the help with this!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n\n<span class=\"kd\">mutual</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ind</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">And₂</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">And₂</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">):</span> <span class=\"n\">R</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">And₂</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">f</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 419325302,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1706818415
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"688543\">Yann Herklotz</span> has marked this topic as resolved.</p>",
        "id": 419325678,
        "sender_full_name": "Notification Bot",
        "timestamp": 1706818576
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"688543\">@Yann Herklotz</span> The easiest refactor to your original definition which works is to remove the use of <code>And</code> there and write this instead:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">R</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">ind</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">R</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">F</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n</code></pre></div>",
        "id": 419396120,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706858444
    },
    {
        "content": "<p>I would remark that the definition seems kind of odd, and based on your description it seems like you are using this as a general technique for something but I don't quite see how this achieves it...</p>",
        "id": 419396542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706858697
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> That is a very good point, I think with all the noise in our definition, I didn't see that you could just remove the <code>And</code> like that, it should indeed be equivalent.  That simplifies things I think!</p>\n<p>As for what we are using it for.  It definitely is a strange definition and you are maybe right that it may not be needed. This is actually why we are playing around with it in lean to understand if/why it is necessary. But for now such a pattern was needed to prove a specific simulation, where we wanted to keep track of how we got to a specific state using some event, because we needed to construct an alternative path that reached the same state.  We then had to deduce from the state what event was used to reach it, so we used functions from tags to states instead of just states.  It looks something like the following, but without going into detail about the proofs and where we were stuck it probably does not clarify things.  But you are right that the <code>And</code> is not actually needed, so it's quite straightforward to encode in lean.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">σₛ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">stepₛ</span> <span class=\"o\">:</span> <span class=\"n\">σₛ</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">σₛ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">initₛ</span> <span class=\"o\">:</span> <span class=\"n\">σₛ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">σₛ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">σₛ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">initₛ</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">s</span>\n<span class=\"bp\">|</span> <span class=\"n\">ind</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">σₛ</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">s'</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">stepₛ</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E.wr</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s'</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n  <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">s'</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 419418176,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1706866201
    },
    {
        "content": "<p>Do these definitions actually have names like  <code>R</code>, <code>F</code>, <code>E</code>? They seem not particularly descriptive</p>",
        "id": 419418621,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706866352
    },
    {
        "content": "<p><code>E</code> is <code>Event</code>, <code>R</code> is actually a relation on two evolving states of the implementation and the specification, and is the matching relation of the simulation (I just didn't put the implementation edges), finally <code>F</code> is just a bunch of well-formedness criteria that we need about the current state.</p>",
        "id": 419419116,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1706866540
    },
    {
        "content": "<p>Sorry I meant to put the def of <code>E</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">E</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">wr</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">E</span>\n</code></pre></div>",
        "id": 419419271,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1706866577
    },
    {
        "content": "<p>Do <code>s</code> and <code>s'</code> represent paths of execution? Because I would expect it to have something relating adjacent values, otherwise it's just omega many unconnected points in the space</p>",
        "id": 419419367,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706866620
    },
    {
        "content": "<p>They are functions from tags to states, and are normally related to the implementation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">E</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">wr</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">E</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">σ</span><span class=\"bp\">ᵢ</span> <span class=\"n\">σₛ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">step</span><span class=\"bp\">ᵢ</span> <span class=\"o\">:</span> <span class=\"n\">σ</span><span class=\"bp\">ᵢ</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">σ</span><span class=\"bp\">ᵢ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">init</span><span class=\"bp\">ᵢ</span> <span class=\"o\">:</span> <span class=\"n\">σ</span><span class=\"bp\">ᵢ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">stepₛ</span> <span class=\"o\">:</span> <span class=\"n\">σₛ</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">σₛ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">initₛ</span> <span class=\"o\">:</span> <span class=\"n\">σₛ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">σ</span><span class=\"bp\">ᵢ</span> <span class=\"bp\">→</span> <span class=\"n\">σₛ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">σ</span><span class=\"bp\">ᵢ</span> <span class=\"bp\">→</span> <span class=\"n\">σₛ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">init</span><span class=\"bp\">ᵢ</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">initₛ</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">i</span> <span class=\"n\">s</span>\n<span class=\"bp\">|</span> <span class=\"n\">ind</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">σₛ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">i'</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">σ</span><span class=\"bp\">ᵢ</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">i'</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s'</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"k\">forall</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">-&gt;</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">step</span><span class=\"bp\">ᵢ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E.wr</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i'</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">stepₛ</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E.wr</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s'</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n  <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">i'</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s'</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 419419586,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1706866693
    },
    {
        "content": "<p>I think my observation still applies, nothing here relates one <code>n</code> to another</p>",
        "id": 419419755,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706866757
    },
    {
        "content": "<p>Yeah, I need to understand better why exactly we needed this in the proof, and why it did not work before.</p>",
        "id": 419419833,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1706866799
    },
    {
        "content": "<p>if you are doing a simulation between <code>s</code> and <code>i</code> you would generally want <code>i n</code> and <code>i (n+1)</code> to be related by the implementation step function and <code>s n</code> and <code>s (n+1)</code> to be related by the abstract step function</p>",
        "id": 419419921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706866823
    },
    {
        "content": "<p>In this case though, n does not relate to time/steps taken, but instead it is an arbitrary tag that is associated with a state, which we later need to identify how we reached a particular state.</p>",
        "id": 419420337,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1706866974
    },
    {
        "content": "<p>but I don't see how you would be able to reconstruct how you reached a state from this information</p>",
        "id": 419420428,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706867025
    },
    {
        "content": "<p>actually never mind, I guess the idea is that you have omega many simulations proceeding from an initial state in lock step</p>",
        "id": 419420746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706867139
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> thinking about it more, I think you are right, we are not relating anything with the quantified <code>Nat</code>.  I think when we wrote it originally, <code> (∀ n, R F a (f n) ∧ F (f n) b)</code> we thought we were relating (f n) between <code>F</code> and <code>R</code>, but as you point out, that is actually not the case, and it's nearly pointless to have the <code>forall n</code>.  I just need to understand the proof more and figure out why we thought we needed it, because when the <code>forall n</code> is not relating anything it really isn't helping with anything.</p>",
        "id": 419424128,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1706868251
    }
]