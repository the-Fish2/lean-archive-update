[
    {
        "content": "<p>The following function obviously terminates, right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.List.Lemmas</span>\n\n<span class=\"n\">opaque</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">l.filter</span> <span class=\"n\">p</span>\n  <span class=\"k\">if</span> <span class=\"n\">m.isEmpty</span> <span class=\"k\">then</span> <span class=\"o\">[]</span> <span class=\"k\">else</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">l.diff</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I encourage anyone to try to prove termination by <code>l.length</code>. </p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Hints</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>The following lemmas might help:<br>\n* <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.diff_cons#doc\">docs#List.diff_cons</a><br>\n* <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.length_erase_of_mem#doc\">docs#List.length_erase_of_mem</a><br>\n* <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.mem_filter#doc\">docs#List.mem_filter</a><br>\n* <code>theorem List.diff_length_le [DecidableEq α] (l₁ l₂ : List α) : (l₁.diff l₂).length ≤ l₁.length := sorry</code></p>\n<p>Here's a start that drills right down to the meat of it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">termination_by</span> <span class=\"n\">l.length</span>\n<span class=\"n\">decreasing_by</span>\n  <span class=\"n\">simp_wf</span>\n  <span class=\"n\">cases</span> <span class=\"n\">l</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">List.isEmpty</span><span class=\"o\">,</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp_all</span> <span class=\"o\">[</span><span class=\"n\">m</span><span class=\"o\">]</span>\n    <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">hd'</span> <span class=\"n\">tl'</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp_arith</span>\n      <span class=\"gr\">sorry</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">hm: List.filter someFilter (hd :: tl) = hd' :: tl'</span>\n<span class=\"cm\">⊢ List.length (List.diff (hd :: tl) (hd' :: tl')) ≤ List.length tl</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n</div></div>\n<p>I found it surprisingly hard to prove this, as many theorems about <code>List.diff</code> require instances of <code>DecidableEq</code>, whereas the function itself only requires <code>BEq</code>. As a result, in my solution I ended up having to specify explicit instances for <code>List.diff</code> and <code>List.erase</code>. Is this just a hole in the API for <code>List.diff</code>, or is there some other problem here?</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>My Solution</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.List.Lemmas</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">List.diff'</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">List.diff</span> <span class=\"n\">_</span> <span class=\"n\">instBEq</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">List.diff_length_le</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">List.diff</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">≤</span> <span class=\"n\">l₁.length</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l₂</span> <span class=\"n\">generalizing</span> <span class=\"n\">l₁</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">List.diff</span><span class=\"o\">]</span>\n  <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">hi</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">split</span>\n    <span class=\"n\">case</span> <span class=\"n\">inr</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">hi</span>\n    <span class=\"n\">case</span> <span class=\"n\">inl</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">Nat.le_trans</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"bp\">..</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">List.length_erase_of_mem</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">List.length_erase_of_mem'</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">length</span> <span class=\"o\">(</span><span class=\"n\">l.erase</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Nat.pred</span> <span class=\"o\">(</span><span class=\"n\">length</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">List.length_erase_of_mem</span> <span class=\"n\">h</span>\n\n<span class=\"n\">opaque</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">l.filter</span> <span class=\"n\">p</span>\n  <span class=\"k\">if</span> <span class=\"n\">m.isEmpty</span> <span class=\"k\">then</span> <span class=\"o\">[]</span> <span class=\"k\">else</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">l.diff'</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">l.length</span>\n<span class=\"n\">decreasing_by</span>\n  <span class=\"n\">simp_wf</span>\n  <span class=\"n\">cases</span> <span class=\"n\">l</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">List.isEmpty</span><span class=\"o\">,</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp_all</span> <span class=\"o\">[</span><span class=\"n\">m</span><span class=\"o\">]</span>\n    <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">hd'</span> <span class=\"n\">tl'</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp_arith</span> <span class=\"o\">[</span><span class=\"n\">List.diff'</span><span class=\"o\">,</span> <span class=\"n\">hm</span><span class=\"o\">]</span>\n      <span class=\"k\">have</span> <span class=\"n\">h₀</span> <span class=\"o\">:=</span> <span class=\"n\">List.diff_length_le</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">List.erase</span> <span class=\"n\">_</span> <span class=\"n\">instBEq</span> <span class=\"o\">(</span><span class=\"n\">hd</span> <span class=\"o\">::</span> <span class=\"n\">tl</span><span class=\"o\">)</span> <span class=\"n\">hd'</span><span class=\"o\">)</span> <span class=\"n\">tl'</span>\n      <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:=</span> <span class=\"n\">hm.symm</span> <span class=\"bp\">▸</span> <span class=\"n\">List.mem_cons_self</span> <span class=\"n\">hd'</span> <span class=\"n\">tl'</span>\n      <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">List.mem_filter.mp</span> <span class=\"n\">h₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">left</span>\n      <span class=\"k\">have</span> <span class=\"n\">h₃</span> <span class=\"o\">:=</span> <span class=\"n\">List.length_erase_of_mem'</span> <span class=\"n\">h₂</span>\n      <span class=\"n\">exact</span> <span class=\"n\">Nat.le_trans</span> <span class=\"n\">h₀</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h₃</span><span class=\"o\">])</span>\n</code></pre></div>\n</div></div>",
        "id": 430568927,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1711964179
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/std4/pull/716\">std4#716</a></p>",
        "id": 430574743,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1711967787
    }
]