[
    {
        "content": "<p>I always forget that I have to write both <code>open Classical</code> and <code>noncomputable</code> before writing a definition that uses <code>if</code> on undecidable propositions (or rather on propositions that are not known to be decidable).</p>\n<p>I should perhaps learn what <code>open Classical</code> actually does. It seems that every other <code>open Foo</code> does two things:<br>\n(1) allows me to omit <code>Foo.</code> in names from given namespace;<br>\n(2) loads specific notations.<br>\nMy impression is that <code>open Classical</code> performs some magic beyond (1) and (2), but I don't know what the magic is. I know the usual comment that <code>open Classical</code> makes all propositions allowed in places where decidable propositions are required, but what exactly does it do? What does the term referencing undecidable proposition looks like and how does <code>open Classical</code> achieve it?</p>",
        "id": 443957802,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1718098524
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"c1\">-- error</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Classical</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"c1\">-- propDecidable p</span>\n</code></pre></div>",
        "id": 443960222,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1718099339
    },
    {
        "content": "<p>And looking at the code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">low</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">propDecidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 443960259,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1718099354
    },
    {
        "content": "<p>Does that help?</p>",
        "id": 443960267,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1718099357
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> has marked this topic as resolved.</p>",
        "id": 443961329,
        "sender_full_name": "Notification Bot",
        "timestamp": 1718099738
    },
    {
        "content": "<p>Oic! So <code>open scoped Classical</code> would do as well.</p>",
        "id": 443961517,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1718099800
    },
    {
        "content": "<p>As I understand it: when you have an object of type <code>Decidable p</code> (where <code>p : Prop</code>), which has two constructors <code>isFalse</code> and <code>isTrue</code>, each of which takes a proof, you can use <code>match</code> (or lower-level things like <code>Decidable.casesOn</code>) to obtain one of the proofs. That's what <code>ite</code> does. And in <code>Classical</code> there is this (and other similar instances):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- All propositions are `Decidable`. -/</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">low</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">propDecidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">em</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">isTrue</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">isFalse</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>which uses an axiom to construct a <code>Decidable</code> without either of the proofs.</p>",
        "id": 443961568,
        "sender_full_name": "Richard Copley",
        "timestamp": 1718099823
    },
    {
        "content": "<p>Another way to make <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.propDecidable#doc\">docs#Classical.propDecidable</a> iavailable to your  <code>if</code> is like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">propDecidable</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">false</span>\n</code></pre></div>",
        "id": 443969057,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1718102229
    },
    {
        "content": "<p>After trying several version, I chose <code>open scoped Classical in</code> because looks like the least violent way to write such a definition.<br>\n<a href=\"https://github.com/madvorak/vcsp/blob/3afca6c58514eab69f9ebfa59e9bf16de7a2dfeb/VCSP/LinearProgrammingE.lean#L40\">https://github.com/madvorak/vcsp/blob/3afca6c58514eab69f9ebfa59e9bf16de7a2dfeb/VCSP/LinearProgrammingE.lean#L40</a><br>\nI'm considering even that I could write a macro that does both <code>open scoped Classical in</code> and <code>noncomputable</code> in a single token, but I'm probably just overthinking. Writing two things is OK.</p>",
        "id": 443991522,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1718110014
    },
    {
        "content": "<p>It would also be possible to make a <code>cif</code> notation (\"classical if\") that uses <code>Classical.propDecidable</code> rather than looking for an instance.</p>",
        "id": 444050478,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718124009
    }
]