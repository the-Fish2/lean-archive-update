[
    {
        "content": "<p>I have an expression containing meta variables but some of them can be resolved. How can I do that? </p>\n<p>Example: let's have <code>x : X</code> and expression <code>@Prod.mk ?α ?β x ?b</code>. It can be inferred that <code>?α = X</code>. How can I do that?</p>\n<p>mwe</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">MetaM</span> <span class=\"n\">Unit</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">u</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshLevelMVar</span>\n  <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshLevelMVar</span>\n  <span class=\"k\">let</span> <span class=\"n\">α</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVar</span> <span class=\"o\">(</span><span class=\"n\">mkSort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">userName</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">β</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVar</span> <span class=\"o\">(</span><span class=\"n\">mkSort</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">userName</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVar</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">userName</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"n\">withLocalDeclD</span> <span class=\"bp\">`</span><span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Nat</span> <span class=\"o\">[])</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">mkAppN</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">`</span><span class=\"n\">Prod.mk</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">])</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"n\">β</span><span class=\"o\">,</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">]</span>\n\n    <span class=\"c1\">-- what to do here? Such that the next line prints `Nat`</span>\n\n    <span class=\"n\">IO.println</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">ppExpr</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 413178361,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1705418697
    },
    {
        "content": "<p>It seems that running <code>check</code> will instantiate these. Note that you got the level off by one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">MetaM</span> <span class=\"n\">Unit</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">u</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshLevelMVar</span>\n  <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshLevelMVar</span>\n  <span class=\"k\">let</span> <span class=\"n\">α</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVar</span> <span class=\"o\">(</span><span class=\"n\">mkSort</span> <span class=\"n\">u.succ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">userName</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">β</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVar</span> <span class=\"o\">(</span><span class=\"n\">mkSort</span> <span class=\"n\">v.succ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">userName</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVar</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">userName</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"n\">withLocalDeclD</span> <span class=\"bp\">`</span><span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Nat</span> <span class=\"o\">[])</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">mkAppN</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">`</span><span class=\"n\">Prod.mk</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">])</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"n\">β</span><span class=\"o\">,</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">]</span>\n    <span class=\"n\">check</span> <span class=\"n\">e</span>\n    <span class=\"c1\">-- what to do here? Such that the next line prints `Nat`</span>\n\n    <span class=\"n\">IO.println</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">ppExpr</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 413179988,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705419012
    },
    {
        "content": "<p>I think <code>mkAppM</code> will unify the types, and unlike <code>check</code> it doesn't recursively re-check the arguments, it just does enough to ensure the application is well typed if the arguments are</p>",
        "id": 413181153,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705419314
    },
    {
        "content": "<p>I have hard time using <code>mkAppM</code> in my use-case as it accepts only explicit arguments. </p>\n<p>Also <code>check</code> does not work in my use-case, but so far I'm unable to minimize the problem.</p>",
        "id": 413183763,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1705419973
    },
    {
        "content": "<p>There are also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.mkAppOptM#doc\">docs#Lean.Meta.mkAppOptM</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.mkAppOptM%27#doc\">docs#Lean.Meta.mkAppOptM'</a> allowing you to pass implicit arguments, in case this is helpful.</p>",
        "id": 413185436,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1705420404
    },
    {
        "content": "<p>Ok this works for me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">let</span> <span class=\"n\">type</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">thm.proof</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">bis</span><span class=\"o\">,</span> <span class=\"n\">type</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">forallMetaTelescope</span> <span class=\"n\">type</span>\n\n  <span class=\"c1\">-- fix some arguments of a theorem</span>\n  <span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"n\">id_f</span><span class=\"o\">]</span><span class=\"bp\">!.</span><span class=\"n\">mvarId</span><span class=\"bp\">!.</span><span class=\"n\">assign</span> <span class=\"n\">f</span>\n  <span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"n\">id_g</span><span class=\"o\">]</span><span class=\"bp\">!.</span><span class=\"n\">mvarId</span><span class=\"bp\">!.</span><span class=\"n\">assign</span> <span class=\"n\">g</span>\n\n  <span class=\"c1\">-- force some mvars to be resolved</span>\n  <span class=\"k\">let</span> <span class=\"n\">prf</span> <span class=\"bp\">←</span> <span class=\"n\">mkAppOptM'</span> <span class=\"o\">(</span><span class=\"n\">thm.proof</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs.map</span> <span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"o\">)</span>\n  <span class=\"n\">check</span> <span class=\"n\">prf</span>\n</code></pre></div>\n<p>Actually, this might be XY problem. I want to apply a theorem and to make unification easier/succeed I want to manually set some arguments of the theorem.</p>",
        "id": 413186112,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1705420587
    },
    {
        "content": "<p>Also <code>mkAppOptM</code> does not work as I would hope here, calling  <code>let e ← mkAppOptM ``Prod.mk (#[α,β,x,b].map .some)</code> in the original example gives an error </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">Prod.mk</span> <span class=\"n\">x</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">x</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">Nat</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">?</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"n\">u.1</span>\n</code></pre></div>",
        "id": 413191178,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1705421985
    },
    {
        "content": "<p>do those actually unify if you use <code>isDefEq</code>?</p>",
        "id": 413192314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705422324
    },
    {
        "content": "<p>It might be that it doesn't unify because you are at the wrong mvar depth or the universe variable is not assignable or something</p>",
        "id": 413192469,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705422364
    },
    {
        "content": "<p><code>mkAppOptM</code> can't assign to pre-existing metavariables because it bumps up the metavariables depth, right?</p>",
        "id": 413192560,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705422392
    },
    {
        "content": "<p>how would it ever work in that case then?</p>",
        "id": 413192799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705422475
    },
    {
        "content": "<p>(not saying you are wrong, I have seen issues of this kind before)</p>",
        "id": 413192948,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705422520
    },
    {
        "content": "<p>I think a mental model for <code>mkAppM</code> and <code>mkAppOptM</code> is that they do a meta telescope on the function's type, then unify each provided argument with a respective metavariable, and then do instance synthesis as for the instance arguments. (That's just a mental model because they're written in a more optimized way.)</p>",
        "id": 413193113,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705422582
    },
    {
        "content": "<p>And the metavariables created by the meta telescope are at a higher depth, and the isDefEq checks are also done in this higher depth.</p>",
        "id": 413193219,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705422607
    },
    {
        "content": "<p>(I never remember exactly what can unify with what when there are varying depths though.)</p>",
        "id": 413193519,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705422689
    },
    {
        "content": "<p>From that description it sounds like <code>mkAppOptM f (args.map some)</code> will indeed be equivalent to <code>mkAppN f args</code>, except that it fails if the types don't match</p>",
        "id": 413194258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705422878
    },
    {
        "content": "<p>that's awkward since it means that if you want the mvar to unify you have to pass <code>none</code>, but in that case you don't have the mvar afterward unless you look in the resulting expression</p>",
        "id": 413194458,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705422942
    },
    {
        "content": "<p>Here's the code done in an explicit way using a meta telescope and doing isDefEq directly, which works fine:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.Exact</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">MetaM</span> <span class=\"n\">Unit</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">u</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshLevelMVar</span>\n  <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshLevelMVar</span>\n  <span class=\"k\">let</span> <span class=\"n\">α</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVar</span> <span class=\"o\">(</span><span class=\"n\">mkSort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">userName</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">β</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVar</span> <span class=\"o\">(</span><span class=\"n\">mkSort</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">userName</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"bp\">←</span> <span class=\"n\">mkFreshExprMVar</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">userName</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"n\">withLocalDeclD</span> <span class=\"bp\">`</span><span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Nat</span> <span class=\"o\">[])</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">fn</span> <span class=\"bp\">←</span> <span class=\"n\">mkConstWithFreshMVarLevels</span> <span class=\"bp\">``</span><span class=\"n\">Prod.mk</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">mvars</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">forallMetaTelescope</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">fn</span><span class=\"o\">)</span>\n    <span class=\"n\">mvars</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">!.</span><span class=\"n\">mvarId</span><span class=\"bp\">!.</span><span class=\"n\">assignIfDefeq</span> <span class=\"n\">α</span>\n    <span class=\"n\">mvars</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">!.</span><span class=\"n\">mvarId</span><span class=\"bp\">!.</span><span class=\"n\">assignIfDefeq</span> <span class=\"n\">β</span>\n    <span class=\"n\">mvars</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"bp\">!.</span><span class=\"n\">mvarId</span><span class=\"bp\">!.</span><span class=\"n\">assignIfDefeq</span> <span class=\"n\">x</span>\n    <span class=\"n\">mvars</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"bp\">!.</span><span class=\"n\">mvarId</span><span class=\"bp\">!.</span><span class=\"n\">assignIfDefeq</span> <span class=\"n\">b</span>\n\n    <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"o\">(</span><span class=\"n\">mkAppN</span> <span class=\"n\">fn</span> <span class=\"n\">mvars</span><span class=\"o\">)</span>\n\n    <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"α = {← ppExpr α}\"</span>\n    <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"e = {← ppExpr e}\"</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">α = Nat</span>\n<span class=\"cm\">e = (x, ?b)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 413194878,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705423078
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/partially.20resolve.20mvars.20in.20expression/near/413194258\">said</a>:</p>\n<blockquote>\n<p>From that description it sounds like <code>mkAppOptM f (args.map some)</code> will indeed be equivalent to <code>mkAppN f args</code>, except that it fails if the types don't match</p>\n</blockquote>\n<p>I thought when you're in a higher metavariable context depth, then if isDefEq would need to assign a metavariable of a lower depth it fails. In Tomas's example, the problem is that <code>mkAppN</code> or <code>mkAppOptN</code> is needing to unify <code>Nat</code> with <code>α</code>, which in the context of these functions is at a lower metavariable context depth, so it fails.</p>",
        "id": 413195400,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705423262
    },
    {
        "content": "<p>Here is almost exactly what I'm trying to do. The main issue is to resolve the the type <code>β</code> in <code>Continuous_comp</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.NormedSpace.ContinuousLinearMap</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Qq</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Continuous_comp</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Continuous</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"n\">continuous_def.2</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">h.preimage</span> <span class=\"n\">hg</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">preimage</span> <span class=\"n\">hf</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">MetaM</span> <span class=\"n\">Unit</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">goal</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Continuous</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">),(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">x</span><span class=\"o\">)))</span>\n  <span class=\"k\">let</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ℝ</span><span class=\"bp\">×</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">),</span><span class=\"n\">x</span><span class=\"o\">))</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">x</span><span class=\"o\">))</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">info</span> <span class=\"bp\">←</span> <span class=\"n\">getConstInfo</span> <span class=\"bp\">``</span><span class=\"n\">Continuous_comp</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">type</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">info.value</span><span class=\"bp\">!</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">bis</span><span class=\"o\">,</span> <span class=\"n\">type</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">forallMetaTelescope</span> <span class=\"n\">type</span>\n\n  <span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"mi\">6</span><span class=\"o\">]</span><span class=\"bp\">!.</span><span class=\"n\">mvarId</span><span class=\"bp\">!.</span><span class=\"n\">assign</span> <span class=\"n\">g</span>\n  <span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"mi\">7</span><span class=\"o\">]</span><span class=\"bp\">!.</span><span class=\"n\">mvarId</span><span class=\"bp\">!.</span><span class=\"n\">assign</span> <span class=\"n\">f</span>\n\n\n  <span class=\"c1\">-- does not resolve ?β in Continuous_comp</span>\n  <span class=\"c1\">-- check (mkAppN info.value! xs)</span>\n\n  <span class=\"c1\">-- does resolve ?β in Continuous_comp</span>\n  <span class=\"c1\">-- let prf := (← instantiateMVars (← mkAppOptM' (info.value!) (xs.map .some)))</span>\n  <span class=\"c1\">-- check prf</span>\n\n  <span class=\"c1\">-- print `xs` and see if they have been resolved</span>\n  <span class=\"k\">if</span> <span class=\"bp\">←</span> <span class=\"n\">isDefEq</span> <span class=\"n\">type</span> <span class=\"n\">goal</span> <span class=\"k\">then</span>\n    <span class=\"n\">IO.println</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">xs.mapM</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">instantiateMVars</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">ppExpr</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 413196329,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1705423544
    },
    {
        "content": "<p>Note that <code>assign</code> just assigns. It doesn't do <em>any</em> isDefEq checks, which are necessary to propagate the assignment's type.</p>",
        "id": 413197160,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705423790
    },
    {
        "content": "<p>That's a reason I used std's <code>assignIfDefeq</code></p>",
        "id": 413197334,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705423831
    },
    {
        "content": "<p>(There are probably a good number of meta bugs out there from assigning metavariables but not unifying types.)</p>",
        "id": 413197506,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705423894
    },
    {
        "content": "<p>Cool! using <code>assignIfDefeq</code> fixed all the issues I had and I do not have to use <code>check</code> anymore.</p>",
        "id": 413197857,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1705424007
    },
    {
        "content": "<p>Added this problem to <a href=\"https://github.com/leanprover-community/mathlib4/wiki/Metaprogramming-gotchas\">https://github.com/leanprover-community/mathlib4/wiki/Metaprogramming-gotchas</a></p>",
        "id": 413199637,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705424479
    },
    {
        "content": "<p>Incidentally, the documentation for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.assign#doc\">docs#Lean.MVarId.assign</a> seems to be misleading. It claims you should do <code>isDefEq (mkMVar mvarId) x</code> as a safer alternative, but this doesn't assign the metavariable if these are proofs (and I seem to remember that there was a case where the types don't get unified). Better is what <code>assignIfDefeq</code> does: check it's not already assigned, check <code>isDefEq</code> on the types, and then assign.</p>",
        "id": 413200276,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705424659
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/2054\">lean4#2054</a> issue</p>",
        "id": 413201149,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705424902
    },
    {
        "content": "<p>Thanks a lot for the explanation!</p>",
        "id": 413231019,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1705435728
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 413244286,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1705441546
    }
]