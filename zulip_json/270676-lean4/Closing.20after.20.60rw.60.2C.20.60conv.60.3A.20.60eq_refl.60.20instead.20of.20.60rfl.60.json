[
    {
        "content": "<p>The tactics <code>rw</code> and <code>conv</code>, besides rewriting the goal, also try to close “trivial” goals.</p>\n<p>Right now, <code>rw</code> uses <code>try with_reducible rfl</code>, and <code>conv</code> uses <code>try rfl</code>. </p>\n<p>(Reminder: <code>rfl</code> is a macro that tries multiple tactics, including <code>eq_refl</code>, which is essentially <code>exact Eq.rfl</code>, and<br>\n<code>apply_rfl</code>, which uses <code>@[refl]</code>  to solve goals in other relations, like <code>Perm xs xs</code>).</p>\n<p>I think this can be refined:</p>\n<ul>\n<li>\n<p>It seems more predictable if the rewriting-like tactics <code>rw</code> and <code>conv</code> consider the same goals “trivial”.</p>\n</li>\n<li>\n<p>I’d argue that it’s not natural for <code>conv</code> or <code>rw</code> to solve non-Eq-goals like <code>Perm xs xs</code> – <code>conv</code> or <code>rw</code> have nothing to do with <code>Perm</code>, so why should it try<code>exact Perm.rfl</code>, but not other ways to close “trivial” goals (e.g. <code>assumption</code>). So these tactics should maybe use <code>eq_refl</code> instead of <code>rfl</code>, and when necessary the user has to close the goal explicitly with <code>rfl</code> or <code>exact Perm.rfl</code>.</p>\n</li>\n<li>\n<p>It may be ill-advised to run <code>try eq_refl</code> (or <code>try rfl</code>) in tactics without <code>with_reducible</code>. It may take a lot of unfolding until it is clear that a goal isn’t reflexive. This is probably why <code>rw</code> uses <code>with_reducible</code>, so <code>conv</code> should probably too. In the cases where this currently doesn't close the goal, the user will have to follow <code>conv</code> with an explicit <code>rfl</code>, but maybe that’s ok, given that something “nontrivial” happens then?</p>\n</li>\n</ul>\n<p>I did an experiment in <code>conv</code> changing <code>try refl</code> to <code>try eq_refl</code>, and the fallout in mathlib was okish.  I had to add a few <code>exact Iff.rfl</code> aftewards, but only few other relations (<code>Perm</code>,  <code>Associated.refl</code>, <code>le_rfl</code>), and for the latter at least I find it preferable to have that as a separate step.</p>\n<p>I’m less sure about <code>exact Iff.rfl</code>. Given that <code>rw</code> can rewrite with <code>Iff </code> as well, it seems natural that it would consider <code>Iff P P</code> a trivial goal. And by the first point above, then also <code>conv</code> should do so. Maybe here the pragmatic thing is to let <code>eq_refl</code> (and thus <code>MVarId.refl</code>) handle <code>Iff</code> in the same built-in manner. This comes at little extra cost.</p>\n<p>How does this sound? What did I miss?</p>\n<p>Pinging <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> and <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> , since this is related to a few disjoint threads of conversation.</p>",
        "id": 429851605,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1711543713
    },
    {
        "content": "<p>My personal view is that more automation is an improvement.  So, I am not too thrilled about weakening tactics that currently do their job well.  In case this is something that is desirable for other reasons, would it still be possible to access the current behaviour via something like <code>rw!</code>?</p>\n<p>For a point of comparison, notice that <code>rewrite</code> is essentially non-existent in mathlib and I wonder whether the \"new\" <code>rw</code> would also be similarly non-existent.</p>",
        "id": 429852658,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711544092
    },
    {
        "content": "<p>So, casting this more positively: bring on the same strong <code>rfl</code> for both <code>rw</code> and <code>conv</code>!</p>",
        "id": 429852922,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711544173
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/Closing.20after.20.60rw.60.2C.20.60conv.60.3A.20.60eq_refl.60.20instead.20of.20.60rfl.60/near/429851605\">said</a>:</p>\n<blockquote>\n<ul>\n<li>I’d argue that it’s not natural for <code>conv</code> or <code>rw</code> to solve non-Eq-goals like <code>Perm xs xs</code> – <code>conv</code> or <code>rw</code> have nothing to do with <code>Perm</code>, so why should it try<code>exact Perm.rfl</code>, but not other ways to close “trivial” goals (e.g. <code>assumption</code>). So these tactics should maybe use <code>eq_refl</code> instead of <code>rfl</code>, and when necessary the user has to close the goal explicitly with <code>rfl</code> or <code>exact Perm.rfl</code>.</li>\n</ul>\n</blockquote>\n<p>I think it's very natural to the extent that on paper a sequence of rewriting ends when the LHS and RHS are the same.</p>",
        "id": 429853006,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711544208
    },
    {
        "content": "<p>I understand that point of view. But if the stance is “more automation is better”, wouldn't you then simply expect every tactic to implicitly run <code>try trivial</code> in the end? So why <code>rfl</code> and not something else?</p>",
        "id": 429854157,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1711544571
    },
    {
        "content": "<p>... because that's what closes goals of the form <code>LHS ~ RHS</code> when <code>LHS</code> and <code>RHS</code> are the same?</p>",
        "id": 429854445,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711544660
    },
    {
        "content": "<p>On paper, you don't say \"and now we are done because the LHS and RHS are the same\", but you do say \"and now we are done by assumption\".</p>",
        "id": 429854602,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711544715
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/Closing.20after.20.60rw.60.2C.20.60conv.60.3A.20.60eq_refl.60.20instead.20of.20.60rfl.60/near/429854157\">said</a>:</p>\n<blockquote>\n<p>I understand that point of view. But if the stance is “more automation is better”, wouldn't you then simply expect every tactic to implicitly run <code>try trivial</code> in the end? So why <code>rfl</code> and not something else?</p>\n</blockquote>\n<p>I thought that the limitation to \"trying every tactic all the times\" was mostly an issue of slowing down.  I personally would be very happy if automation could tell me quickly \"I can take over from here!\".</p>",
        "id": 429855306,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711544963
    },
    {
        "content": "<p>Thus, I view it as a delicate balance between having a good response time and a good automation.  After all, with most trivial lemmas, I normally try <code>aesop</code> first, just in case... if Lean did that in the background, that would be awesome!</p>",
        "id": 429855693,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711545082
    },
    {
        "content": "<p>Maybe it could be an option that you can switch on/off, something like <code>set_option fancyRw true</code> and then you get the current behaviour and otherwise you use the better-performing, but less conclusive weaker <code>rw</code>?</p>",
        "id": 429857396,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711545642
    },
    {
        "content": "<p>Btw, in Lean 3 there was a misuse of <code>simpa</code> that meant that <code>simp; rfl</code> could be replaced by <code>simpa</code>: I know that Mario did not like this, but those who knew about this \"bug\" used it liberally... until they were caught out!</p>\n<p>This is to say: I suspect that in mathlib, a trend is to try to avoid seeing <code>rfl</code>s as much as possible.</p>",
        "id": 429858156,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711545901
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/270676-lean4/topic/Closing.20after.20.60rw.60.2C.20.60conv.60.3A.20.60eq_refl.60.20instead.20of.20.60rfl.60/near/429855693\">said</a>:</p>\n<blockquote>\n<p>Thus, I view it as a delicate balance between having a good response time and a good automation.  After all, with most trivial lemmas, I normally try <code>aesop</code> first, just in case... if Lean did that in the background, that would be awesome!</p>\n</blockquote>\n<p>Bumping this one last time: there is a <a href=\"https://github.com/leanprover-community/mathlib4/pull/6176\">PR</a> for Lean (with Mathlib) to do this in the background and this has been open for months. </p>\n<p>Assuming this dies again, in a few days I will try to make a minimal dependency repo so users can use it with/without Mathlib and also while developing in Mathlib (I hope).</p>",
        "id": 429859645,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1711546297
    },
    {
        "content": "<p>I think it’s difficult to have this discussion without any information about the actual speed difference.</p>",
        "id": 429863058,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1711547300
    },
    {
        "content": "<p>I admit for me the appeal isn’t (just) performance, but predictability and orthogonal building blocks – why should <code>conv</code> even close a goal at all. But I do understand that having to writing <code>rfl</code>  is tedious and pragmatically it’s nice if you don’t have to.</p>\n<p>I’ll run a speed center run to see if using <code>eq_refl</code> instead of <code>rfl</code> shows up. But I doubt it, it’s not that much on a hot path. I am worried a bit more if a user might run into a situation where <code>try rfl</code> blows up because it unfolds things it shouldn’t, and then they can’t use <code>conv</code> anymore. (I guess they can work around it with <code>with_reducible conv…</code>).</p>\n<p>I might not have peeked into this rabbit hole if there was a single commonly accepted tactic for “do trivial things we don’t want to see”, and that tactic was used by <code>rw</code> and <code>conv</code> etc. consistently (maybe <code>trivial</code> was intended to be this, although it seems too expensive to run unconditionally and opportunistically). Or is there a good reason that <code>rw</code> and <code>conv</code> each try a different tactic that I missed?</p>",
        "id": 429883839,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1711552405
    },
    {
        "content": "<p>For me, the main motivation is that, very often, <code>rfl, by rfl, exact rfl, trivial, tauto, aesop</code> are all a replacement for something that on paper is \"and we are done\" (or, better, \"and now we are <em>really</em> done\").</p>",
        "id": 429887920,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711553493
    },
    {
        "content": "<p>I think it makes sense doing a light <code>trivial</code> at the ends of tactics to close the goal in obvious cases for tactics that cannot close goals themselves, and closing in a <em>predictable</em> way.</p>\n<p>A full <code>trivial</code> is not very predictable, since it depends on the local context. The tactic should look at just the thing that was rewritten to see if it can close the goal.</p>\n<p>I looked at <code>simp</code> and <code>dsimp</code> as well to see how they close goals when operating on the target.</p>\n<ol>\n<li><code>simp</code> checks to see if the goal is <code>True</code>, and if so, closes it with <code>True.intro</code>.</li>\n<li><code>dsimp</code> (1) does the <code>True</code> check and (2) it does its own \"<code>try with_reducible exact rfl</code>\"</li>\n</ol>\n<p>The <code>simp</code> tactic doesn't need to do (2) since reflexivity of <code>Eq</code> is already a simp lemma.</p>\n<p>When <code>simp</code> and <code>dsimp</code> act on hypotheses, instead they both simply look for <code>False</code> and if so close the goal using <code>False.elim</code>.</p>",
        "id": 429888182,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711553564
    },
    {
        "content": "<p>I think <code>rw</code> should, like <code>simp</code> and <code>dsimp</code>, also close goals if the result after rewriting is a <code>True</code> or <code>False</code>, depending on whether it's in the target or a hypothesis.</p>",
        "id": 429888351,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711553619
    },
    {
        "content": "<p>So <code>trivial</code> isn’t trivial enough :-)</p>",
        "id": 429888544,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1711553673
    },
    {
        "content": "<p>I also think it makes sense for <code>rw</code> (and perhaps <code>dsimp</code> too!) to be aware of other reflexive relations and be able to close those.  Think about rewriting <code>x + x ≤ 2 * x</code> to <code>2 * x ≤ 2 * x</code>. Should I <em>really</em> need to do <code>rfl</code> after this?</p>",
        "id": 429888606,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711553689
    },
    {
        "content": "<p>Would you want <code>apply</code> or <code>refine</code> to also do this <code>try really_trivial</code>? Or by what criteria do we decide which tactics should and which shouldn’t close trivial goals?</p>",
        "id": 429888850,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1711553760
    },
    {
        "content": "<p>Those tactics should always have a tactic coming after them, so I don't think you'd expect them to finish automatically.</p>",
        "id": 429889005,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711553795
    },
    {
        "content": "<p>The theory I'm going by is that with <code>rw</code> you <em>could</em> use it to reduce an expression to <code>True</code> in principle, but there are a few sorts of obvious stopping points where it's not expensive to have the system finish up.</p>",
        "id": 429889387,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711553894
    },
    {
        "content": "<p>And also, <code>rw</code> can't close the goal itself.</p>",
        "id": 429889484,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711553922
    },
    {
        "content": "<p>Hmm, <code>simp</code>, <code>rw</code> and <code>conv</code>, by their own, even more so have always a tactic coming, because they just rewrite the goal. The trivial-closing functionality is bolted on and independent of their core functionality, so I don’t yet see how they are different from other tactics.</p>",
        "id": 429889501,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1711553927
    },
    {
        "content": "<p><code>apply</code> and <code>refine</code> <em>can</em> close the goal themselves</p>",
        "id": 429889573,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711553946
    },
    {
        "content": "<p>Speaking of <code>conv</code>, I think of that being more in the \"simp family\" since it's a way for the user to apply the congruence lemmas that simp uses to navigate into expressions. If it's like an interactive <code>simp</code>, then it's justified having it close the goal like <code>simp</code>/<code>dsimp</code>. A full <code>try rfl</code> is way too much without any reducibility restriction, I think.</p>",
        "id": 429889851,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711554016
    },
    {
        "content": "<p>Ok, then I misunderstood “Those tactics should always have a tactic coming after them”.</p>\n<p>Maybe the point is that <code>apply</code> and <code>refine</code> are more low-level and closer to  “constructing proof terms”, so more automation would be strange here.</p>",
        "id": 429889906,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1711554033
    },
    {
        "content": "<p>To take this to an extreme, I would be surprised by closing a goal with <code>refine ?_</code>.</p>",
        "id": 429890179,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711554112
    },
    {
        "content": "<p>There are two things I'm saying about <code>apply</code> and <code>refine</code>:</p>\n<ol>\n<li>They're able to close the goal themselves, unlike <code>rw</code></li>\n<li>Generally, you use <code>refine</code> to set up specific goal states. It would be very confusing if any of your <code>?_</code>'s did not appear afterwards. For <code>apply</code>, there's more leeway for auto-closing goals, and it might be appreciated, so long as it's not for any explicit <code>?_</code>s</li>\n</ol>",
        "id": 429890305,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711554138
    },
    {
        "content": "<blockquote>\n<p>A full try rfl is way too much without any reducibility restriction, I think.</p>\n</blockquote>\n<p>Ok, sounds like it would be worth to at least change <code>try rfl</code> to <code>try with_reducible rfl</code>, to make it behave more like <code>rw</code> and <code>dsimp</code>.</p>",
        "id": 429890812,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1711554273
    },
    {
        "content": "<p>Speaking of unexpected behaviour, this <em>is</em> a valid proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 429891556,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711554472
    },
    {
        "content": "<p>(I wonder whether the form <code>rw at</code> would find my support for <em>not</em> try any form of <code>rfl</code> after itself.)</p>",
        "id": 429892115,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711554614
    },
    {
        "content": "<p>I think the way <code>rw</code> does a blanket <code>with_reducible rfl</code> is not great. Ideally, it would only look at the thing being rewritten and use that to close the goal. There's no rewrite going on here, so I suppose it wouldn't even look at <code>h</code></p>",
        "id": 429892128,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711554616
    },
    {
        "content": "<p>Your idea makes sense. If there's no <code>at</code> clause, or if <code>|-</code> doesn't appear in the <code>at</code> clause, then don't do <code>with_reducible rfl</code>.</p>",
        "id": 429892300,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711554662
    },
    {
        "content": "<p>I like it a lot, perhaps just because I'm used to it. But agree that it only makes sense when rewriting the goal</p>",
        "id": 429892393,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1711554686
    },
    {
        "content": "<p>If there <em>is</em> an <code>at</code> clause, then it could also try using <code>False.elim</code> on each mentioned hypothesis.</p>",
        "id": 429892431,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711554698
    },
    {
        "content": "<p>Yes, I can get behind the <code>try rfl</code> only when the goal is involved in the rw.</p>",
        "id": 429892485,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711554713
    },
    {
        "content": "<p>Honestly, I would be curious to know where in Mathlib there are <code>rw at [not the goal]</code> that actually close the goal.</p>",
        "id": 429892739,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711554770
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/270676-lean4/topic/Closing.20after.20.60rw.60.2C.20.60conv.60.3A.20.60eq_refl.60.20instead.20of.20.60rfl.60/near/429892393\">said</a>:</p>\n<blockquote>\n<p>I like it a lot, perhaps just because I'm used to it. But agree that it only makes sense when rewriting the goal</p>\n</blockquote>\n<p>Could you clarify if you're disagreeing with anything here? Are you saying you like how <code>rw</code> closes the goal even if you didn't operate on the goal? (And if so, why you wouldn't do <code>rfl</code> instead?)</p>",
        "id": 429893441,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711554936
    },
    {
        "content": "<p>I like that it tries (weak) <code>rfl</code> when operating on the goal</p>",
        "id": 429893623,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1711554971
    },
    {
        "content": "<p>Ok, I thought \"it\" might have been Damiano's example.</p>",
        "id": 429893764,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711555010
    },
    {
        "content": "<p>I think that very few people would find <code>rw [] at h</code> as an idiomatic way of doing <code>rfl</code>.</p>",
        "id": 429893831,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711555026
    },
    {
        "content": "<p>One more tactic to think about is <code>rwa</code>, which intentionally does <code>assumption</code> at the end (one of the tactics that <code>trivial</code> tries).</p>\n<p>There's a bit of a bug since <code>rwa</code> does <code>rw</code> and then <code>assumption</code>, so it's possible to have it apply to the wrong goal. I guess <code>rwa</code> should focus on the main goal first?</p>",
        "id": 429902228,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711557317
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/270676-lean4/topic/Closing.20after.20.60rw.60.2C.20.60conv.60.3A.20.60eq_refl.60.20instead.20of.20.60rfl.60/near/429893831\">said</a>:</p>\n<blockquote>\n<p>I think that very few people would find <code>rw [] at h</code> as an idiomatic way of doing <code>rfl</code>.</p>\n</blockquote>\n<p>Note, this is something we can lint</p>",
        "id": 429935928,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711569107
    },
    {
        "content": "<p>I much prefer it when tactics have regular behavior, even if that behavior is silly sometimes, and we use linters to catch the case where silly behavior is exploited directly</p>",
        "id": 429936231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711569222
    },
    {
        "content": "<p>In fact, I would say that <code>rw [] (at ...)?</code> should be disallowed, just like \"<code>simp</code> made no progress\".</p>",
        "id": 429936258,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711569233
    },
    {
        "content": "<p>I don't agree, it means you can't just split a <code>rw</code> into pieces anymore</p>",
        "id": 429936385,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711569273
    },
    {
        "content": "<p>You can if the pieces perform at least one <code>rw</code>...</p>",
        "id": 429936487,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711569327
    },
    {
        "content": "<p>I'm very glad it wasn't <em>syntactically</em> disallowed like so many other \"1 or more\"'s in lean</p>",
        "id": 429936515,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711569347
    },
    {
        "content": "<p>because it is often the first step in deciding what to rewrite with</p>",
        "id": 429936551,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711569362
    },
    {
        "content": "<p>and I don't want the goal to be obscured at that point by a silly error I don't care about</p>",
        "id": 429936628,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711569382
    },
    {
        "content": "<p>Ah, I am happy that it is syntactically allowed, but it should still trigger <em>some</em> warning in final code.</p>",
        "id": 429936646,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711569391
    },
    {
        "content": "<p>again, linters</p>",
        "id": 429936662,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711569401
    },
    {
        "content": "<p>If the unused tactic linter were faster, that could be a job for it...</p>",
        "id": 429936746,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711569445
    },
    {
        "content": "<p>And then, also the \"<code>simp</code> made no progress\" would be caught by a linter.</p>",
        "id": 429936887,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711569490
    },
    {
        "content": "<p>that one is a bit different, there would be fallout from that change (as there was when changing it to fail in the first place) because it affects tactic control flow</p>",
        "id": 429937272,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711569628
    },
    {
        "content": "<p>but it would be nice to have a linter if you have a <code>try simp</code> (or even <code>try tac</code> in general) block which always fails and hence does nothing</p>",
        "id": 429937465,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711569691
    },
    {
        "content": "<p>but I guess your linter would also pick that up?</p>",
        "id": 429937482,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711569700
    },
    {
        "content": "<p>Yes, those \"unused <code>try ...</code>\" get caught.</p>",
        "id": 429937624,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711569743
    },
    {
        "content": "<p>Basically, any time that the goals do not change, the linter tells you.</p>",
        "id": 429937750,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711569789
    },
    {
        "content": "<p>(\"Change\" is conservative, in that it picks up on non pp-differences, since it looks at the mctx before and after each tactic application)</p>",
        "id": 429937803,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711569818
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/Closing.20after.20.60rw.60.2C.20.60conv.60.3A.20.60eq_refl.60.20instead.20of.20.60rfl.60/near/429883839\">said</a>:</p>\n<blockquote>\n<p>I’ll run a speed center run to see if using <code>eq_refl</code> instead of <code>rfl</code> shows up. But I doubt it, it’s not that much on a hot path. ```<br>\nI still can’t really read these reports, but looks like there isn’t much happening with that change:<br>\n<a href=\"http://speed.lean-fro.org/mathlib4/compare/15cb8470-fe7e-433b-b297-f5fd49de63a1/to/58cf4f76-662f-46e2-8f38-68d0457b2d89\">http://speed.lean-fro.org/mathlib4/compare/15cb8470-fe7e-433b-b297-f5fd49de63a1/to/58cf4f76-662f-46e2-8f38-68d0457b2d89</a></p>\n</blockquote>",
        "id": 430021283,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1711615996
    },
    {
        "content": "<p>Btw: I am very much in favor of weakening <code>conv</code>'s behavior to only apply reflexivity reducibly. Personally I think we shouldn't match things up to semireducible transparency if there is a reasonable chance that it will fail (in a proof script that itself works).</p>",
        "id": 430024907,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1711617412
    },
    {
        "content": "<p>Thanks, good to know. That’ll also make <code>conv</code> match <code>rw</code>’s behaviour.  I’ll try that today (<a href=\"https://github.com/leanprover/lean4/pull/3763\">https://github.com/leanprover/lean4/pull/3763</a>).</p>",
        "id": 430025069,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1711617465
    },
    {
        "content": "<p>Maybe <code>rfl</code> itself should be weaker and we should have <code>rfl!</code> for the more aggressive one</p>",
        "id": 430026097,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1711617725
    },
    {
        "content": "<p>That’s worth exploring. Although for interactive use, <code>rfl</code> is fine, I’d say  – you notice when it’s slow, and you usually only leave it in when it works. It’s mostly hidden uses in other tactics, with backtracking, where a possibly slow and failing run can remain and slow everything down.</p>",
        "id": 430026389,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1711617808
    },
    {
        "content": "<p>I agree with Joachim: if the user explicitly requests to do something, then we should try harder (i.e. up to semireducibility).</p>",
        "id": 430027765,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1711618426
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/Closing.20after.20.60rw.60.2C.20.60conv.60.3A.20.60eq_refl.60.20instead.20of.20.60rfl.60/near/430025069\">said</a>:</p>\n<blockquote>\n<p>Thanks, good to know. That’ll also make <code>conv</code> match <code>rw</code>’s behaviour.  I’ll try that today (<a href=\"https://github.com/leanprover/lean4/pull/3763\">https://github.com/leanprover/lean4/pull/3763</a>).</p>\n</blockquote>\n<p>Here is the impact on mathlib:<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/compare/nightly-testing...lean-pr-testing-3763\">https://github.com/leanprover-community/mathlib4/compare/nightly-testing...lean-pr-testing-3763</a><br>\nNothing surprising, just a bunch of proofs where after <code>conv</code> the goals weren’t syntactically equal, but some amount of reduction was needed. Not unreasonable to require an explicit <code>rfl</code> to say “and now solve by defeq”, I’d say.</p>\n<p>Nothing exciting happening <a href=\"http://speed.lean-fro.org/mathlib4/compare/15cb8470-fe7e-433b-b297-f5fd49de63a1/to/2e457fd0-d8f9-4350-b6e1-26364c66d094\">in the speedcenter</a>.</p>\n<p>With <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> and <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> in favor of applying reflexivity only reducibly, unless someone complains, I’ll go ahead with this in a while</p>",
        "id": 430088713,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1711638260
    }
]