[
    {
        "content": "<p>is there a way to rename a type such as N := Nat</p>",
        "id": 412854941,
        "sender_full_name": "Xiaoning Bian",
        "timestamp": 1705274642
    },
    {
        "content": "<p>abbrev? <code>abbrev N := Nat</code></p>",
        "id": 412855857,
        "sender_full_name": "Alok Singh",
        "timestamp": 1705275517
    },
    {
        "content": "<p>Or you can use notation like <code>ℕ</code> as defined in libraries</p>",
        "id": 412855928,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1705275594
    },
    {
        "content": "<p>thanks. 'abbrev' works! I used 'def' before, Lean4 cannot recognize elements of N. Strangely, I roughly went though some doc, but I didn't see any about 'abbrev'. Everyone is using Nat instead of N.</p>",
        "id": 412856369,
        "sender_full_name": "Xiaoning Bian",
        "timestamp": 1705275930
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/270676-lean4/topic/is.20there.20a.20way.20to.20rename.20a.20type.20such.20as.20N.20.3A.3D.20Nat/near/412855928\">said</a>:</p>\n<blockquote>\n<p>Or you can use notation like <code>ℕ</code> as defined in libraries</p>\n</blockquote>\n<p>Yes, I mean ℕ. Just don't know how to type it in chat. Thanks.</p>",
        "id": 412856461,
        "sender_full_name": "Xiaoning Bian",
        "timestamp": 1705275988
    },
    {
        "content": "<p>My point is that in Mathlib we have a line</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span> <span class=\"s2\">\"ℕ\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat</span>\n</code></pre></div>\n<p>which is probably closer to what you want than abbrev then</p>",
        "id": 412856883,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1705276362
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/270676-lean4/topic/is.20there.20a.20way.20to.20rename.20a.20type.20such.20as.20N.20.3A.3D.20Nat/near/412856883\">said</a>:</p>\n<blockquote>\n<p>My point is that in Mathlib we have a line</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span> <span class=\"s2\">\"ℕ\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat</span>\n</code></pre></div>\n<p>which is probably closer to what you want than abbrev then</p>\n</blockquote>\n<p>I see. Thanks. I just tried 'notation'. It works.</p>",
        "id": 412857181,
        "sender_full_name": "Xiaoning Bian",
        "timestamp": 1705276666
    },
    {
        "content": "<p>BTW, in Agda, 'N = Nat' works. '=' in Lean4 is used for equality. '=' in Agda is for any kinds of renaming: N = Nat, f = g, a = 1. the following code works in Agda.</p>\n<p>a = 1</p>\n<p>M = ℕ<br>\nf : M -&gt; M<br>\nf zero = a<br>\nf (suc x) = x</p>\n<p>g = f</p>\n<p>So, syntax in Lean4 is a little bit convoluted.</p>",
        "id": 412861220,
        "sender_full_name": "Xiaoning Bian",
        "timestamp": 1705278625
    },
    {
        "content": "<p>The equivalent of <code>N = Nat</code> in lean is <code>def N := Nat</code></p>",
        "id": 412878137,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705287762
    },
    {
        "content": "<p>it's just not necessarily what you want to do in this instance</p>",
        "id": 412878147,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705287773
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/is.20there.20a.20way.20to.20rename.20a.20type.20such.20as.20N.20.3A.3D.20Nat/near/412878137\">said</a>:</p>\n<blockquote>\n<p>The equivalent of <code>N = Nat</code> in lean is <code>def N := Nat</code></p>\n</blockquote>\n<p>For some reason, 'def N := Nat' won't work. I tried that.  E.g.</p>\n<p>-- These two worked.<br>\n-- notation \"ℕ\" =&gt; Nat<br>\n--abbrev ℕ := Nat</p>\n<p>-- But not this one:<br>\ndef ℕ := Nat</p>\n<p>inductive Ket : ℕ -&gt; Type where<br>\n  | Ket1 : Bool -&gt; (Ket 1)<br>\n  | KetS : {n : Nat} -&gt; Ket 1 -&gt; Ket n -&gt; Ket (n + 1)</p>",
        "id": 412878998,
        "sender_full_name": "Xiaoning Bian",
        "timestamp": 1705288470
    },
    {
        "content": "<p>that's because in lean <code>def</code>initions are opaque to typeclass inference (which is a feature, it means you can put different typeclasses on a newtype)</p>",
        "id": 412879448,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705288896
    },
    {
        "content": "<p>I think there is no such distinction in agda</p>",
        "id": 412879545,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705288944
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/is.20there.20a.20way.20to.20rename.20a.20type.20such.20as.20N.20.3A.3D.20Nat/near/412879448\">said</a>:</p>\n<blockquote>\n<p>that's because in lean <code>def</code>initions are opaque to typeclass inference (which is a feature, it means you can put different typeclasses on a newtype)</p>\n</blockquote>\n<p>1) Agda does not support typeclass (but you can code your own in Agda). It seems that once you use '=' in Agda, then lhs is rhs without any difference(I like it). <br>\n2) We can alway wrap a type in a new type if we want this feature in Agda:</p>\n<p>data NN : Set where<br>\n  Wrap : ℕ -&gt; NN</p>\n<p>This seems also the only way  to make new typeclass instances in Haskell  when a type already has such an instance. E.g. I might want a  different Show instance for Nat, then I have to wrap Nat in a new type.  We can do the same in Lean4.</p>\n<p>3)  <br>\ninstance OfNat ℕ n where<br>\n  ofNat := n</p>\n<p>worked, but it's very confusing, since the OfNat definition </p>\n<p>class OfNat (α : Type) (_ : Nat) where<br>\n  ofNat : α</p>\n<p>indicates n : Nat, but ofNat := n is of type ℕ . Why sometimes Lean4 reacognizes ℕ is Nat, and sometimes doesn't. Also, </p>\n<p>instance OfNat ℕ 0 where<br>\n  ofNat := 0</p>\n<p>won't typecheck. It worked for all n, but why not for an instance 0?</p>\n<p>4) I just checked, using 'def N := Nat' won't let you do pattern matching on N. So why are we using and allowing 'def N := Nat'? what's the purpose of 'def N := Nat'? what's the constructor of N?</p>",
        "id": 412884535,
        "sender_full_name": "Xiaoning Bian",
        "timestamp": 1705293282
    },
    {
        "content": "<p>Agda supports typeclasses, but during typeclass resolution, the same level of judgemental equality is used as implicit variable resolution.</p>",
        "id": 412884590,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1705293362
    },
    {
        "content": "<blockquote>\n<p>1) Agda does not support typeclass (but you can code your own in Agda). It seems that once you use '=' in Agda, then lhs is rhs without any difference(I like it). </p>\n</blockquote>\n<p>What do you mean by \"without any difference\"? There are clearly some differences, like the spelling. In lean there are quite a few notions of equality at different levels of strictness and <code>notation</code>, <code>abbrev</code>, <code>def</code> and <code>irreducible_def</code> produce things that are \"the same\" as their bodies at these different levels of strictness</p>",
        "id": 412884677,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705293435
    },
    {
        "content": "<p><code>notation</code> produces the strictest level of equality, the LHS is literally expanded to the RHS at parse time. But you certainly don't want to write a whole library development that way, terms would get exponentially large</p>",
        "id": 412884758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705293499
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"681355\">@Xiaoning Bian</span> Re 4, yes you can do pattern matching.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">N</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span>\n  <span class=\"bp\">|</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">m</span>\n  <span class=\"bp\">|</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 412885447,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705294051
    },
    {
        "content": "<p>Re 2, Haskell's <code>newtype</code> is like Lean's <code>def</code> (though not completely, since Lean's can still unfold), and Haskell's <code>type</code> is like Lean's <code>abbrev</code>. You can also use <code>data</code> in Haskell, or <code>data</code> in Agda, or <code>structure</code>/<code>inductive</code> in Lean to create a completely new type by wrapping.</p>",
        "id": 412885536,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705294136
    },
    {
        "content": "<p>Here's a demonstration of 5 different kinds of equality in lean and the things that differentiate them:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.IrreducibleDef</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Logic.Equiv.Basic</span>\n\n<span class=\"kd\">notation</span> <span class=\"s2\">\"T1\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">T2</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">def</span> <span class=\"n\">T3</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>\n<span class=\"n\">irreducible_def</span> <span class=\"n\">T4</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">structure</span> <span class=\"n\">T5</span> <span class=\"o\">:=</span> <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"c1\">-- syntactic equality means that there is no difference between x0 and x1</span>\n<span class=\"kd\">def</span> <span class=\"n\">x0</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>  <span class=\"k\">#print</span> <span class=\"n\">x0</span> <span class=\"c1\">-- def x0 : Type := T1</span>\n<span class=\"kd\">def</span> <span class=\"n\">x1</span> <span class=\"o\">:=</span> <span class=\"n\">T1</span>   <span class=\"k\">#print</span> <span class=\"n\">x1</span> <span class=\"c1\">-- def x1 : Type := T1</span>\n<span class=\"kd\">def</span> <span class=\"n\">x2</span> <span class=\"o\">:=</span> <span class=\"n\">T2</span>   <span class=\"k\">#print</span> <span class=\"n\">x2</span> <span class=\"c1\">-- def x2 : Type := T2</span>\n<span class=\"kd\">def</span> <span class=\"n\">x3</span> <span class=\"o\">:=</span> <span class=\"n\">T3</span>   <span class=\"k\">#print</span> <span class=\"n\">x3</span> <span class=\"c1\">-- def x3 : Type := T3</span>\n<span class=\"kd\">def</span> <span class=\"n\">x4</span> <span class=\"o\">:=</span> <span class=\"n\">T4</span>   <span class=\"k\">#print</span> <span class=\"n\">x4</span> <span class=\"c1\">-- def x4 : Type := T4</span>\n<span class=\"kd\">def</span> <span class=\"n\">x5</span> <span class=\"o\">:=</span> <span class=\"n\">T5</span>   <span class=\"k\">#print</span> <span class=\"n\">x5</span> <span class=\"c1\">-- def x5 : Type := T5</span>\n\n<span class=\"c1\">-- reducible equality means that tactics like simp will not differentiate them</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T1</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T2</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T3</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- failed</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T4</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- failed</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T5</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- failed</span>\n\n<span class=\"c1\">-- definitional equality means that rfl proves the equality</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T1</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T2</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T3</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T4</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- failed</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T5</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- failed</span>\n\n<span class=\"c1\">-- propositional equality means that the equality is provable</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T1</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T2</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T3</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T4</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">T4_def</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T5</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- not provable</span>\n\n<span class=\"c1\">-- equivalence means that the types have the same elements</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T1</span> <span class=\"bp\">≃</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">_</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T2</span> <span class=\"bp\">≃</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">_</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T3</span> <span class=\"bp\">≃</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">_</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T4</span> <span class=\"bp\">≃</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">T4_def</span> <span class=\"bp\">▸</span> <span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">_</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T5</span> <span class=\"bp\">≃</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">T5.val</span><span class=\"o\">,</span> <span class=\"n\">T5.mk</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 412885883,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705294367
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"404479\">Trebor Huang</span> <a href=\"#narrow/stream/270676-lean4/topic/is.20there.20a.20way.20to.20rename.20a.20type.20such.20as.20N.20.3A.3D.20Nat/near/412884590\">said</a>:</p>\n<blockquote>\n<p>Agda supports typeclasses, but during typeclass resolution, the same level of judgemental equality is used as implicit variable resolution.</p>\n</blockquote>\n<p>Thanks for pointing it out. Yeah, you can use \"instance argument\" to mimic typeclass. I mentioned you can code your own meaning using instance argument. Agda just doesn't have a 'typeclass' keyword as in Haskell, or 'class' as in Lean4. But you have to use the special syntax to open a record in Agda.</p>",
        "id": 412886307,
        "sender_full_name": "Xiaoning Bian",
        "timestamp": 1705294736
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"681355\">Xiaoning Bian</span> <a href=\"#narrow/stream/270676-lean4/topic/is.20there.20a.20way.20to.20rename.20a.20type.20such.20as.20N.20.3A.3D.20Nat/near/412884535\">said</a>:</p>\n<blockquote>\n<p>3)  <br>\ninstance OfNat ℕ n where<br>\n  ofNat := n</p>\n<p>worked, but it's very confusing, since the OfNat definition </p>\n<p>class OfNat (α : Type) (_ : Nat) where<br>\n  ofNat : α</p>\n<p>indicates n : Nat, but ofNat := n is of type ℕ .</p>\n</blockquote>\n<p>This works because the types <code>ℕ</code> and <code>Nat</code> are definitionally equal (the <code>rfl</code> test just above). Another place where definitional equality comes up is that if <code>x : A</code> and <code>A</code> and <code>B</code> are definitionally equal then lean accepts <code>x : B</code>.</p>\n<blockquote>\n<p>Why sometimes Lean4 reacognizes ℕ is Nat, and sometimes doesn't. Also, </p>\n<p>instance OfNat ℕ 0 where<br>\n  ofNat := 0</p>\n<p>won't typecheck. It worked for all n, but why not for an instance 0?</p>\n</blockquote>\n<p>This is because <code>0</code> is type-generic, it uses the <code>OfNat</code> instance to find it and since you are in the middle of defining that instance it of course can't find one yet. You could write <code>show Nat from 0</code> though to force lean to look for <code>0</code> as a <code>Nat</code>, and then assert that it has type <code>ℕ</code>, instead of looking for <code>0 : ℕ</code> directly which will require the <code>OfNat ℕ 0</code> instance.</p>",
        "id": 412886518,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705294871
    },
    {
        "content": "<blockquote>\n<p>4) I just checked, using 'def N := Nat' won't let you do pattern matching on N. So why are we using and allowing 'def N := Nat'? what's the purpose of 'def N := Nat'? what's the constructor of N?</p>\n</blockquote>\n<p>You can do pattern matching on <code>N</code>, you just can't use <code>0</code> and <code>+1</code> because these are generic operators and will cause instance search for <code>OfNat</code> and <code>HAdd</code> respectively, which will fail on the new type (unless you define these, of course). If you use <code>Nat.zero</code> and <code>Nat.succ</code> it will work</p>",
        "id": 412886667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705294957
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/is.20there.20a.20way.20to.20rename.20a.20type.20such.20as.20N.20.3A.3D.20Nat/near/412885536\">said</a>:</p>\n<blockquote>\n<p>Re 2, Haskell's <code>newtype</code> is like Lean's <code>def</code> (though not completely, since Lean's can still unfold), and Haskell's <code>type</code> is like Lean's <code>abbrev</code>. You can also use <code>data</code> in Haskell, or <code>data</code> in Agda, or <code>structure</code>/<code>inductive</code> in Lean to create a completely new type by wrapping.</p>\n</blockquote>\n<p>Thanks. I didn't know I need put a dot before a constuctor. I come from Agda, there, a dot pattern means a different thing. I am very happy to know \"type ~ abbrev\".  \"data = newtype ~ ~ def\" is also  good to know. Thanks.</p>",
        "id": 412887756,
        "sender_full_name": "Xiaoning Bian",
        "timestamp": 1705295795
    },
    {
        "content": "<p>This use of dot means \"use the expected type to figure out the namespace for the function\". It's able to unfold <code>def</code>s while figuring this out.</p>\n<p>Here's an alternative:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">N</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span>\n  <span class=\"bp\">|</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">m</span>\n  <span class=\"bp\">|</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Or you can write <code>Nat.zero</code> and <code>Nat.succ</code> instead of using <code>open Nat</code>.</p>",
        "id": 412888093,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705296093
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/is.20there.20a.20way.20to.20rename.20a.20type.20such.20as.20N.20.3A.3D.20Nat/near/412885883\">said</a>:</p>\n<blockquote>\n<p>Here's a demonstration of 5 different kinds of equality in lean and the things that differentiate them:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.IrreducibleDef</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Logic.Equiv.Basic</span>\n\n<span class=\"kd\">notation</span> <span class=\"s2\">\"T1\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">T2</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">def</span> <span class=\"n\">T3</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>\n<span class=\"n\">irreducible_def</span> <span class=\"n\">T4</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">structure</span> <span class=\"n\">T5</span> <span class=\"o\">:=</span> <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"c1\">-- syntactic equality means that there is no difference between x0 and x1</span>\n<span class=\"kd\">def</span> <span class=\"n\">x0</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>  <span class=\"k\">#print</span> <span class=\"n\">x0</span> <span class=\"c1\">-- def x0 : Type := T1</span>\n<span class=\"kd\">def</span> <span class=\"n\">x1</span> <span class=\"o\">:=</span> <span class=\"n\">T1</span>   <span class=\"k\">#print</span> <span class=\"n\">x1</span> <span class=\"c1\">-- def x1 : Type := T1</span>\n<span class=\"kd\">def</span> <span class=\"n\">x2</span> <span class=\"o\">:=</span> <span class=\"n\">T2</span>   <span class=\"k\">#print</span> <span class=\"n\">x2</span> <span class=\"c1\">-- def x2 : Type := T2</span>\n<span class=\"kd\">def</span> <span class=\"n\">x3</span> <span class=\"o\">:=</span> <span class=\"n\">T3</span>   <span class=\"k\">#print</span> <span class=\"n\">x3</span> <span class=\"c1\">-- def x3 : Type := T3</span>\n<span class=\"kd\">def</span> <span class=\"n\">x4</span> <span class=\"o\">:=</span> <span class=\"n\">T4</span>   <span class=\"k\">#print</span> <span class=\"n\">x4</span> <span class=\"c1\">-- def x4 : Type := T4</span>\n<span class=\"kd\">def</span> <span class=\"n\">x5</span> <span class=\"o\">:=</span> <span class=\"n\">T5</span>   <span class=\"k\">#print</span> <span class=\"n\">x5</span> <span class=\"c1\">-- def x5 : Type := T5</span>\n\n<span class=\"c1\">-- reducible equality means that tactics like simp will not differentiate them</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T1</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T2</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T3</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- failed</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T4</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- failed</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T5</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- failed</span>\n\n<span class=\"c1\">-- definitional equality means that rfl proves the equality</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T1</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T2</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T3</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T4</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- failed</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T5</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- failed</span>\n\n<span class=\"c1\">-- propositional equality means that the equality is provable</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T1</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T2</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T3</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T4</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">T4_def</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T5</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- not provable</span>\n\n<span class=\"c1\">-- equivalence means that the types have the same elements</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T1</span> <span class=\"bp\">≃</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">_</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T2</span> <span class=\"bp\">≃</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">_</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T3</span> <span class=\"bp\">≃</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">_</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T4</span> <span class=\"bp\">≃</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">T4_def</span> <span class=\"bp\">▸</span> <span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">_</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T5</span> <span class=\"bp\">≃</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">T5.val</span><span class=\"o\">,</span> <span class=\"n\">T5.mk</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>wow, thanks for the clarification. I didn't know there are so many layers of \"equality\".  Still one thing is strange:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T3</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- failed</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T3</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"c1\">-- worked</span>\n</code></pre></div>\n<p>If seems definitional equality implies reducible equality?</p>\n<p>Before, I only vaguely have two kinds of equality:  the '=' in Agda is like the syntactic equality here, and '≡' in Agda the definitional equality here. And also the equivalence in both Agda and here.</p>",
        "id": 412889642,
        "sender_full_name": "Xiaoning Bian",
        "timestamp": 1705297233
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/is.20there.20a.20way.20to.20rename.20a.20type.20such.20as.20N.20.3A.3D.20Nat/near/412886667\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>4) I just checked, using 'def N := Nat' won't let you do pattern matching on N. So why are we using and allowing 'def N := Nat'? what's the purpose of 'def N := Nat'? what's the constructor of N?</p>\n</blockquote>\n<p>You can do pattern matching on <code>N</code>, you just can't use <code>0</code> and <code>+1</code> because these are generic operators and will cause instance search for <code>OfNat</code> and <code>HAdd</code> respectively, which will fail on the new type (unless you define these, of course). If you use <code>Nat.zero</code> and <code>Nat.succ</code> it will work</p>\n</blockquote>\n<p>Yeah, it worked. Thanks.</p>",
        "id": 412890062,
        "sender_full_name": "Xiaoning Bian",
        "timestamp": 1705297555
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/is.20there.20a.20way.20to.20rename.20a.20type.20such.20as.20N.20.3A.3D.20Nat/near/412888093\">said</a>:</p>\n<blockquote>\n<p>This use of dot means \"use the expected type to figure out the namespace for the function\". It's able to unfold <code>def</code>s while figuring this out.</p>\n<p>Here's an alternative:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">N</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span>\n  <span class=\"bp\">|</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">m</span>\n  <span class=\"bp\">|</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Or you can write <code>Nat.zero</code> and <code>Nat.succ</code> instead of using <code>open Nat</code>.</p>\n</blockquote>\n<p>\"use the expected type to figure out the namespace for the function\" &lt;--- Nice!! Thanks.</p>",
        "id": 412890199,
        "sender_full_name": "Xiaoning Bian",
        "timestamp": 1705297637
    },
    {
        "content": "<blockquote>\n<p>If seems definitional equality implies reducible equality?</p>\n</blockquote>\n<p>Yes, it's also known as reducible defeq for this reason</p>\n<blockquote>\n<p>Before, I only vaguely have two kinds of equality: the '=' in Agda is like the syntactic equality here, and '≡' in Agda the definitional equality here. And also the equivalence in both Agda and here.</p>\n</blockquote>\n<p>Agda <code>=</code> is definitely not syntactic equality, but programming languages which are sufficiently restricted in metaprogramming and similar capabilities can sometimes present a notion of equality that is not observably different from syntactic equality</p>",
        "id": 412890794,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705298088
    },
    {
        "content": "<p>My guess is that agda <code>=</code> is most similar to reducible defeq, in that it is internally actually a different type and it is not eagerly expanded by the compiler, but all parts of the system unfold it on demand so as to treat them as equivalent for all user-visible purposes</p>",
        "id": 412890994,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705298258
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/is.20there.20a.20way.20to.20rename.20a.20type.20such.20as.20N.20.3A.3D.20Nat/near/412890994\">said</a>:</p>\n<blockquote>\n<p>My guess is that agda <code>=</code> is most similar to reducible defeq, in that it is internally actually a different type and it is not eagerly expanded by the compiler, but all parts of the system unfold it on demand so as to treat them as equivalent for all user-visible purposes</p>\n</blockquote>\n<p>Got it. Thanks. I am more of a user. I come here from Agda for efficency issues. There, a 2^12 case distinction, with each case being an easy computation, takes hours. I am translating my code to Lean4, hoping it works.</p>",
        "id": 412891655,
        "sender_full_name": "Xiaoning Bian",
        "timestamp": 1705298692
    },
    {
        "content": "<p>I don't think lean is that great at gigantic inductive types or case distinctions, but it should not be hours</p>",
        "id": 412892245,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705299080
    },
    {
        "content": "<p>Thanks a lot for the help, @everyone. I like here! Unlike the SSprove, I filed an issue 3 months ago on github, still wating for an answer.</p>",
        "id": 412892415,
        "sender_full_name": "Xiaoning Bian",
        "timestamp": 1705299205
    },
    {
        "content": "<p>Re q4: one purpose of allowing <code>def N := Nat</code> is that now I can define my own &lt;= on N, for example I can define a &lt;= b on N to mean a divides b in Nat.</p>",
        "id": 412901745,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705305086
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/is.20there.20a.20way.20to.20rename.20a.20type.20such.20as.20N.20.3A.3D.20Nat/near/412890794\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>If seems definitional equality implies reducible equality?</p>\n</blockquote>\n<p>Yes, it's also known as reducible defeq for this reason</p>\n<blockquote>\n<p>Before, I only vaguely have two kinds of equality: the '=' in Agda is like the syntactic equality here, and '≡' in Agda the definitional equality here. And also the equivalence in both Agda and here.</p>\n</blockquote>\n<p>Agda <code>=</code> is definitely not syntactic equality, but programming languages which are sufficiently restricted in metaprogramming and similar capabilities can sometimes present a notion of equality that is not observably different from syntactic equality</p>\n</blockquote>\n<p>Yeah, '=' is not the syntactic equality. 'pattern a = b' is, for which, you can use 'a' for 'b'  if 'b' is a constructor when pattern-matching.  We cannot if using '='.</p>",
        "id": 412921016,
        "sender_full_name": "Xiaoning Bian",
        "timestamp": 1705312557
    },
    {
        "content": "<p>in lean that's the <code>@[match_pattern]</code> attribute</p>",
        "id": 412921527,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705312713
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/is.20there.20a.20way.20to.20rename.20a.20type.20such.20as.20N.20.3A.3D.20Nat/near/412885883\">said</a>:</p>\n<blockquote>\n<p>Here's a demonstration of 5 different kinds of equality in lean and the things that differentiate them:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.IrreducibleDef</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Logic.Equiv.Basic</span>\n\n<span class=\"kd\">notation</span> <span class=\"s2\">\"T1\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">T2</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">def</span> <span class=\"n\">T3</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>\n<span class=\"n\">irreducible_def</span> <span class=\"n\">T4</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">structure</span> <span class=\"n\">T5</span> <span class=\"o\">:=</span> <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"c1\">-- syntactic equality means that there is no difference between x0 and x1</span>\n<span class=\"kd\">def</span> <span class=\"n\">x0</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>  <span class=\"k\">#print</span> <span class=\"n\">x0</span> <span class=\"c1\">-- def x0 : Type := T1</span>\n<span class=\"kd\">def</span> <span class=\"n\">x1</span> <span class=\"o\">:=</span> <span class=\"n\">T1</span>   <span class=\"k\">#print</span> <span class=\"n\">x1</span> <span class=\"c1\">-- def x1 : Type := T1</span>\n<span class=\"kd\">def</span> <span class=\"n\">x2</span> <span class=\"o\">:=</span> <span class=\"n\">T2</span>   <span class=\"k\">#print</span> <span class=\"n\">x2</span> <span class=\"c1\">-- def x2 : Type := T2</span>\n<span class=\"kd\">def</span> <span class=\"n\">x3</span> <span class=\"o\">:=</span> <span class=\"n\">T3</span>   <span class=\"k\">#print</span> <span class=\"n\">x3</span> <span class=\"c1\">-- def x3 : Type := T3</span>\n<span class=\"kd\">def</span> <span class=\"n\">x4</span> <span class=\"o\">:=</span> <span class=\"n\">T4</span>   <span class=\"k\">#print</span> <span class=\"n\">x4</span> <span class=\"c1\">-- def x4 : Type := T4</span>\n<span class=\"kd\">def</span> <span class=\"n\">x5</span> <span class=\"o\">:=</span> <span class=\"n\">T5</span>   <span class=\"k\">#print</span> <span class=\"n\">x5</span> <span class=\"c1\">-- def x5 : Type := T5</span>\n\n<span class=\"c1\">-- reducible equality means that tactics like simp will not differentiate them</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T1</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T2</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T3</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- failed</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T4</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- failed</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T5</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- failed</span>\n\n<span class=\"c1\">-- definitional equality means that rfl proves the equality</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T1</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T2</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T3</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T4</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- failed</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T5</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- failed</span>\n\n<span class=\"c1\">-- propositional equality means that the equality is provable</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T1</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T2</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T3</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T4</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">T4_def</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T5</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- not provable</span>\n\n<span class=\"c1\">-- equivalence means that the types have the same elements</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T1</span> <span class=\"bp\">≃</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">_</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T2</span> <span class=\"bp\">≃</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">_</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T3</span> <span class=\"bp\">≃</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">_</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T4</span> <span class=\"bp\">≃</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">T4_def</span> <span class=\"bp\">▸</span> <span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">_</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">T5</span> <span class=\"bp\">≃</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">T5.val</span><span class=\"o\">,</span> <span class=\"n\">T5.mk</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This deserves to be somewhere (the Lean manual?) where newbies to Lean can easily find it. I'm learning Lean and reading this was super useful, and I only stumbled upon it by browsing some Zulip threads.</p>",
        "id": 416457766,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1705531319
    },
    {
        "content": "<p>Adding them to the <a href=\"https://leanprover-community.github.io/glossary\">glossary</a> as terms seems like a decent idea (as well, not as a replacement)</p>",
        "id": 416464377,
        "sender_full_name": "Julian Berman",
        "timestamp": 1705535000
    }
]