[
    {
        "content": "<p>Consider the following code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">AnnType</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"n\">type</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span>\n  <span class=\"n\">ann</span> <span class=\"o\">:</span> <span class=\"n\">String</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">{</span> <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">ann</span> <span class=\"o\">:=</span> <span class=\"s2\">\"test\"</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">AnnType</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span> <span class=\"kd\">instance</span> <span class=\"n\">coeSort</span> <span class=\"o\">:</span> <span class=\"n\">CoeSort</span> <span class=\"n\">AnnType</span> <span class=\"o\">(</span><span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">AnnType.type</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">Negation</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span> <span class=\"n\">where</span>\n  <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"n\">α.type</span> <span class=\"bp\">→</span> <span class=\"n\">False</span>\n  <span class=\"n\">ann</span> <span class=\"o\">:=</span> <span class=\"s2\">\"Not \"</span> <span class=\"bp\">++</span> <span class=\"n\">α.ann</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">neg_type</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α.Negation.type</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">α.type</span> <span class=\"bp\">→</span> <span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"n\">scoped</span> <span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"¬\"</span> <span class=\"n\">α</span><span class=\"o\">:</span><span class=\"mi\">40</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">AnnType.Negation</span> <span class=\"n\">α</span>\n\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"bp\">¬</span><span class=\"n\">p</span>             <span class=\"c1\">-- fails; works</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span><span class=\"o\">)</span> <span class=\"c1\">-- works; works</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"n\">AnnType.ann</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"c1\">-- works; works</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ann</span>       <span class=\"c1\">-- fails; works</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>    <span class=\"c1\">-- fails; works</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>        <span class=\"bp\">↦</span> <span class=\"bp\">¬</span><span class=\"n\">p</span>             <span class=\"c1\">-- works; fails</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">And</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span> <span class=\"n\">where</span>\n  <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">∧</span> <span class=\"n\">β</span>\n  <span class=\"n\">ann</span> <span class=\"o\">:=</span> <span class=\"n\">α.ann</span> <span class=\"bp\">++</span> <span class=\"s2\">\" and \"</span> <span class=\"bp\">++</span> <span class=\"n\">β.ann</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">and_type</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α.And</span> <span class=\"n\">β</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">type</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">α.type</span> <span class=\"bp\">∧</span> <span class=\"n\">β.type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"n\">scoped</span> <span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">35</span> <span class=\"s2\">\" ∧ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">AnnType.And</span>\n\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span>               <span class=\"c1\">-- fails; works</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span><span class=\"o\">)</span>   <span class=\"c1\">-- works; works</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"n\">AnnType.ann</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"c1\">-- works; works</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ann</span>         <span class=\"c1\">-- fails; works</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>      <span class=\"c1\">-- fails; works</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>        <span class=\"bp\">↦</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span>               <span class=\"c1\">-- works; fails</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">AnnType</span>\n</code></pre></div>\n<p>I am overloading existing <code>Prop</code> notation, but 'morally' this shouldn't matter since the two possible interpretations of <code>¬p</code> as a <code>Prop</code> are equal (<code>@[reducible] def Negation</code> does not help BTW), and similarly for <code>∧</code>.</p>\n<p>If I set the priorities of the new <code>¬</code> and <code>∧</code> to <code>high</code>, then most of these examples work, but then the original notation for <code>Prop</code>s is no longer considered, as demonstrated by the last line in each of the <code>#check</code> sets.</p>\n<p>How can I set up the notations so that <code>¬p</code> and <code>p ∧ q</code> give me the expected result for both <code>AnnType</code>s and <code>Prop</code>s?<br>\nMore  generally:</p>\n<ul>\n<li>Where are insertions of coercions considered when elaborating multiple possible interpretations for a notation? I would have expected the second-last line to work, but apparently after <code>p ∧ q</code> is interpreted as <code>p.And q</code>, the coercion from <code>AnnType.{0}</code> to <code>Prop</code> is not considered.</li>\n<li>Can notation priorities be used so that one notation is preferred over the other, but only when elaboration allows both? It seems like when I set <code>priority := high</code>, the built-in <code>Prop</code> interpretations are discarded, and then this is not reconsidered when that fails to elaborate.</li>\n</ul>",
        "id": 425697417,
        "sender_full_name": "Raghuram",
        "timestamp": 1709999852
    },
    {
        "content": "<p>Do I have to write <code>elab</code> code to inspect the objects and decide which interpretation to use?<br>\nIt would be nice if this could be done with just <code>notation</code>.</p>",
        "id": 425697846,
        "sender_full_name": "Raghuram",
        "timestamp": 1710000169
    },
    {
        "content": "<p>Interesting; usually overloaded notation can be disambiguated by seeing which of the options successfully elaborate, but coe insertion makes all the interpretations elaboratable.</p>\n<p>The easy solution is to remove your coercion.</p>\n<p>Another solution is to make an elaborator for the pre-existing notations (rather than overriding the notations) that conditionally switch to your new notation if any of the arguments or expected type is an <code>AnnType</code>.</p>\n<p>Yet another is to make a typeclass for the notation and solve the problem by defining instances, though then the notation yields different (but defeq) terms for Prop.</p>",
        "id": 425698304,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710000515
    },
    {
        "content": "<p>This is what that last option looks like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">HasNot</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">not</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">¬</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">HasNot.not</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HasNot</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">not</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">Not</span> <span class=\"n\">p</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HasNot</span> <span class=\"n\">AnnType</span> <span class=\"n\">where</span>\n  <span class=\"n\">not</span> <span class=\"o\">:=</span> <span class=\"n\">AnnType.Negation</span>\n\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"bp\">¬</span><span class=\"n\">p</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"n\">AnnType.ann</span> <span class=\"bp\">¬</span><span class=\"n\">p</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ann</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>        <span class=\"bp\">↦</span> <span class=\"bp\">¬</span><span class=\"n\">p</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">This last one elaborates as fun p =&gt; HasNot.not p : Prop → Prop rather than with `Not`, which could cause issues with `rw`/`simp`.</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 425698647,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710000804
    },
    {
        "content": "<p>I thought about it and decided that I want the coercion.</p>\n<p>The non-defeq due to the typeclass is kind of annoying; for example, <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Overloading.20the.20propositional.20and.20.2F.5C.20notation/near/406615801\">see here</a>.<br>\nIs it possible to get the typeclass \"expanded out\" by</p>\n<ol>\n<li>reading <code>\\not p</code> into <code>@HasNot.not Prop &lt;inst&gt; p</code></li>\n<li>unfolding instance and simplifying to <code>Not p</code>?</li>\n</ol>\n<p>(E.g., does it help to mark the <code>HasNot Prop</code> instance reducible?)</p>\n<p>Otherwise, I think I'll try the elaborator option.</p>",
        "id": 425700312,
        "sender_full_name": "Raghuram",
        "timestamp": 1710002111
    },
    {
        "content": "<p>It occurred to me that we can slip in an elaborator to unfold a typeclass instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Meta</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">unfold</span><span class=\"o\">)</span> <span class=\"s2\">\"unfold% \"</span> <span class=\"n\">ident</span> <span class=\"n\">term</span><span class=\"o\">:</span><span class=\"n\">max</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"n\">unfold</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">elabUnfold</span> <span class=\"o\">:</span> <span class=\"n\">Elab.Term.TermElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"n\">stx</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">unfold</span><span class=\"bp\">%</span> <span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">args</span><span class=\"o\">]</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">f</span> <span class=\"bp\">←</span> <span class=\"n\">Term.resolveId</span><span class=\"bp\">?</span> <span class=\"n\">f</span> <span class=\"bp\">|</span> <span class=\"n\">throwUnknownConstant</span> <span class=\"n\">f.getId</span>\n    <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">Term.elabAppArgs</span> <span class=\"n\">f</span> <span class=\"bp\">#</span><span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"n\">args.map</span> <span class=\"bp\">.</span><span class=\"n\">stx</span><span class=\"o\">)</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n      <span class=\"o\">(</span><span class=\"n\">explicit</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ellipsis</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span>\n    <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">unfoldProjInst</span><span class=\"bp\">?</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getD</span> <span class=\"n\">e</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">HasNot</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">not</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">¬</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">unfold</span><span class=\"bp\">%</span> <span class=\"n\">HasNot.not</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HasNot</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">not</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">Not</span> <span class=\"n\">p</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HasNot</span> <span class=\"n\">AnnType</span> <span class=\"n\">where</span>\n  <span class=\"n\">not</span> <span class=\"o\">:=</span> <span class=\"n\">AnnType.Negation</span>\n\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"bp\">¬</span><span class=\"n\">p</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"n\">AnnType.ann</span> <span class=\"bp\">¬</span><span class=\"n\">p</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ann</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>        <span class=\"bp\">↦</span> <span class=\"bp\">¬</span><span class=\"n\">p</span>\n</code></pre></div>",
        "id": 425700610,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710002338
    },
    {
        "content": "<p>Just be aware that this is fragile, since it might not have the instance solved for by the time it tries <code>unfoldProjInst?</code></p>",
        "id": 425700769,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710002467
    },
    {
        "content": "<p>This would be more robust:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"n\">unfold</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">elabUnfold</span> <span class=\"o\">:</span> <span class=\"n\">Elab.Term.TermElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"n\">stx</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">unfold</span><span class=\"bp\">%</span> <span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">args</span><span class=\"o\">]</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">f</span> <span class=\"bp\">←</span> <span class=\"n\">Term.resolveId</span><span class=\"bp\">?</span> <span class=\"n\">f</span> <span class=\"bp\">|</span> <span class=\"n\">throwUnknownConstant</span> <span class=\"n\">f.getId</span>\n    <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">Term.withSynthesize</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.elabAppArgs</span> <span class=\"n\">f</span> <span class=\"bp\">#</span><span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"n\">args.map</span> <span class=\"bp\">.</span><span class=\"n\">stx</span><span class=\"o\">)</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n      <span class=\"o\">(</span><span class=\"n\">explicit</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ellipsis</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"n\">e</span>\n    <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">unfoldProjInst</span><span class=\"bp\">?</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getD</span> <span class=\"n\">e</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n</code></pre></div>\n<p>but it requires the instance to be solved for while this is being elaborated.</p>",
        "id": 425700914,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710002571
    },
    {
        "content": "<p>This is very interesting! I may try playing with this code later.<br>\nThat being said, if there are robustness issues, I think I'll try the elaborator in my current use case - I'm going to need exactly two possible interpretations and no more.</p>",
        "id": 425701565,
        "sender_full_name": "Raghuram",
        "timestamp": 1710003007
    },
    {
        "content": "<p>The <code>withSynthesize</code> solves the robustness issue I mentioned. It forces the instances to be solved for, and you will never see a not-unfolded term.</p>",
        "id": 425701669,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710003112
    },
    {
        "content": "<p>I see.</p>",
        "id": 425701727,
        "sender_full_name": "Raghuram",
        "timestamp": 1710003132
    },
    {
        "content": "<p>Although it wouldn't matter here, I realised that ideally <code>unfold%</code> should be recursive (possibly with a custom stopping condition, such as \"only unfold instance projections\" or maybe even \"only unfold certain registered projection functions\"): for example, if one wanted to unfold <code>x + y</code> but it turned out to be a <code>HAdd</code> instance coming from an <code>Add</code> instance, the <code>Add.add</code> should be unfolded as well.<br>\nI couldn't figure out how to do this because the elaborator function above takes a Syntax object as an argument, whereas in the recursive case, we have an <code>Expr</code> extracted from <code>\\l unfoldProjinst? e</code>.</p>",
        "id": 425715160,
        "sender_full_name": "Raghuram",
        "timestamp": 1710014753
    },
    {
        "content": "<p>For recursion, you could make a version of <code>unfoldProjInst?</code> called <code>unfoldProjInsts</code> that repeatedly applies <code>unfoldProjInst?</code> so long as it returns <code>some</code></p>",
        "id": 425715470,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710015023
    },
    {
        "content": "<p>Maybe something like reducing to normal form with transparency mode <code>instance</code> is designed for this?</p>",
        "id": 425715505,
        "sender_full_name": "Raghuram",
        "timestamp": 1710015083
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Interaction.20between.20notation.20and.20coercion/near/425715470\">said</a>:</p>\n<blockquote>\n<p>For recursion, you could make a version of <code>unfoldProjInst?</code> called <code>unfoldProjInsts</code> that repeatedly applies <code>unfoldProjInst?</code> so long as it returns <code>some</code></p>\n</blockquote>\n<p>Oh <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span>.</p>",
        "id": 425715516,
        "sender_full_name": "Raghuram",
        "timestamp": 1710015105
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">unfoldInsts</span><span class=\"o\">)</span> <span class=\"s2\">\"unfold% \"</span> <span class=\"n\">ident</span> <span class=\"n\">term</span><span class=\"o\">:</span><span class=\"n\">arg</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Meta</span> <span class=\"k\">in</span>\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">unfoldProjInsts</span> <span class=\"o\">(</span><span class=\"n\">expr</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Lean.Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">expr</span> <span class=\"bp\">←</span> <span class=\"n\">unfoldProjInst</span><span class=\"bp\">?</span> <span class=\"n\">expr</span> <span class=\"k\">then</span>\n    <span class=\"n\">unfoldProjInsts</span> <span class=\"n\">expr</span>\n  <span class=\"k\">else</span> <span class=\"n\">pure</span> <span class=\"n\">expr</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Elab</span> <span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"n\">unfoldInsts</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabUnfoldInsts</span> <span class=\"o\">:</span> <span class=\"n\">Term.TermElab</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">unfold</span><span class=\"bp\">%</span> <span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">args</span><span class=\"o\">]</span><span class=\"bp\">*</span><span class=\"o\">),</span> <span class=\"n\">type</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">f</span> <span class=\"bp\">←</span> <span class=\"n\">Term.resolveId</span><span class=\"bp\">?</span> <span class=\"n\">f</span> <span class=\"bp\">|</span> <span class=\"n\">Lean.throwUnknownConstant</span> <span class=\"n\">f.getId</span>\n    <span class=\"k\">let</span> <span class=\"n\">expr</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.instantiateMVars</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">←</span> <span class=\"n\">Term.withSynthesize</span> <span class=\"bp\">&lt;|</span>\n      <span class=\"n\">Term.elabAppArgs</span> <span class=\"n\">f</span> <span class=\"bp\">#</span><span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"n\">args.map</span> <span class=\"bp\">.</span><span class=\"n\">stx</span><span class=\"o\">)</span> <span class=\"n\">type</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">explicit</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ellipsis</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">)</span>\n    <span class=\"n\">unfoldProjInsts</span> <span class=\"n\">expr</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">↦</span> <span class=\"n\">unfold</span><span class=\"bp\">%</span> <span class=\"n\">HAdd.hAdd</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"c1\">-- fun x y =&gt; Nat.add x y : Nat → Nat → Nat</span>\n</code></pre></div>\n<p><span aria-label=\"party ball\" class=\"emoji emoji-1f38a\" role=\"img\" title=\"party ball\">:party_ball:</span></p>\n<p>Incidentally, this still doesn't work for some reason. But I can just always generate <code>unfold%</code>s with the typeclass operator rather than the notation.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">↦</span> <span class=\"n\">unfold</span><span class=\"bp\">%</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"c1\">-- fun x y =&gt; x + y : Nat → Nat → Nat</span>\n</code></pre></div>",
        "id": 425715869,
        "sender_full_name": "Raghuram",
        "timestamp": 1710015479
    },
    {
        "content": "<p>Here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">unfoldInsts</span><span class=\"o\">)</span> <span class=\"s2\">\"unfold% \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Meta</span> <span class=\"k\">in</span>\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">unfoldProjInsts</span> <span class=\"o\">(</span><span class=\"n\">expr</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Lean.Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">expr</span> <span class=\"bp\">←</span> <span class=\"n\">unfoldProjInst</span><span class=\"bp\">?</span> <span class=\"n\">expr</span> <span class=\"k\">then</span>\n    <span class=\"n\">unfoldProjInsts</span> <span class=\"n\">expr</span>\n  <span class=\"k\">else</span> <span class=\"n\">pure</span> <span class=\"n\">expr</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Elab</span> <span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"n\">unfoldInsts</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabUnfoldInsts</span> <span class=\"o\">:</span> <span class=\"n\">Term.TermElab</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">unfold</span><span class=\"bp\">%</span> <span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">),</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">expr</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.instantiateMVars</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">←</span> <span class=\"n\">Term.withSynthesize</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.elabTerm</span> <span class=\"n\">t</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n    <span class=\"n\">unfoldProjInsts</span> <span class=\"n\">expr</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">↦</span> <span class=\"n\">unfold</span><span class=\"bp\">%</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"c1\">-- fun x y =&gt; Nat.add x y : Nat → Nat → Nat</span>\n</code></pre></div>",
        "id": 425716604,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710016209
    },
    {
        "content": "<p>The first version I wrote was a hasty copy/paste from a bit of code I had lying around. I think the idea before was that <code>unfold%</code> would only unfold a particular function, but now that you're recursively unfolding, may as well make it take a single term.</p>",
        "id": 425717193,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710016848
    },
    {
        "content": "<p>BTW, I tried out the elaboration-based approach as well.<br>\nIs this roughly along the right lines?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"o\">(</span><span class=\"n\">Syntax</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Elab</span> <span class=\"o\">(</span><span class=\"n\">throwUnsupportedSyntax</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Elab.Term</span> <span class=\"o\">(</span><span class=\"n\">TermElab</span> <span class=\"n\">elabTerm</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Meta</span> <span class=\"o\">(</span><span class=\"n\">isDefEq</span> <span class=\"n\">inferType</span> <span class=\"n\">mkAppM</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"bp\">«</span><span class=\"n\">term</span><span class=\"bp\">¬</span><span class=\"n\">_</span><span class=\"bp\">»</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"bp\">«</span><span class=\"n\">_elab_term</span><span class=\"bp\">¬</span><span class=\"n\">__custom</span><span class=\"bp\">»</span> <span class=\"o\">:</span> <span class=\"n\">TermElab</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">¬$</span><span class=\"n\">p</span><span class=\"o\">),</span> <span class=\"n\">type</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">annType</span> <span class=\"bp\">←</span> <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">AnnType</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n  <span class=\"k\">let</span> <span class=\"n\">testArg</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">p</span> <span class=\"n\">none</span>\n    <span class=\"n\">pure</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">if</span> <span class=\"bp\">←</span> <span class=\"n\">isDefEq</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">annType</span> <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"n\">p</span> <span class=\"k\">else</span> <span class=\"n\">none</span>\n  <span class=\"k\">let</span> <span class=\"n\">testType</span> <span class=\"o\">(</span><span class=\"n\">type</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"n\">type</span><span class=\"bp\">?</span> <span class=\"bp\">|</span> <span class=\"n\">pure</span> <span class=\"n\">none</span>\n    <span class=\"n\">pure</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">if</span> <span class=\"bp\">←</span> <span class=\"n\">isDefEq</span> <span class=\"n\">type</span> <span class=\"n\">annType</span> <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"n\">type</span> <span class=\"k\">else</span> <span class=\"n\">none</span>\n\n  <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">type</span> <span class=\"bp\">←</span> <span class=\"n\">testType</span> <span class=\"n\">type</span><span class=\"bp\">?</span> <span class=\"k\">then</span>\n    <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">AnnType.Negation</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">p</span> <span class=\"n\">type</span><span class=\"o\">]</span>\n  <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">p</span> <span class=\"bp\">←</span> <span class=\"n\">testArg</span> <span class=\"n\">p</span> <span class=\"k\">then</span>\n    <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">AnnType.Negation</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span>\n  <span class=\"k\">else</span> <span class=\"n\">throwUnsupportedSyntax</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n</code></pre></div>\n<p>I think it's not triggered at all though, possibly because it has a lower priority than the default elaborator for the same syntax?</p>",
        "id": 425718957,
        "sender_full_name": "Raghuram",
        "timestamp": 1710018669
    },
    {
        "content": "<p>OK, so I have fixed the elaborator (I think). Here is the full code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">AnnType</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"n\">type</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span>\n  <span class=\"n\">ann</span> <span class=\"o\">:</span> <span class=\"n\">String</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">{</span> <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">ann</span> <span class=\"o\">:=</span> <span class=\"s2\">\"test\"</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">AnnType</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span> <span class=\"kd\">instance</span> <span class=\"n\">coeSort</span> <span class=\"o\">:</span> <span class=\"n\">CoeSort</span> <span class=\"n\">AnnType</span> <span class=\"o\">(</span><span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">AnnType.type</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Negation</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span> <span class=\"n\">where</span>\n  <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"n\">α.type</span> <span class=\"bp\">→</span> <span class=\"n\">False</span>\n  <span class=\"n\">ann</span> <span class=\"o\">:=</span> <span class=\"s2\">\"Not \"</span> <span class=\"bp\">++</span> <span class=\"n\">α.ann</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">neg_type</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α.Negation.type</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">α.type</span> <span class=\"bp\">→</span> <span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">And</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span> <span class=\"n\">where</span>\n  <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">∧</span> <span class=\"n\">β</span>\n  <span class=\"n\">ann</span> <span class=\"o\">:=</span> <span class=\"n\">α.ann</span> <span class=\"bp\">++</span> <span class=\"s2\">\" and \"</span> <span class=\"bp\">++</span> <span class=\"n\">β.ann</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">and_type</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α.And</span> <span class=\"n\">β</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">type</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">α.type</span> <span class=\"bp\">∧</span> <span class=\"n\">β.type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n\n\n<span class=\"n\">syntax</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"s2\">\"¬\"</span> <span class=\"n\">term</span><span class=\"o\">:</span><span class=\"mi\">40</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"bp\">«</span><span class=\"n\">term</span><span class=\"bp\">¬</span><span class=\"n\">_</span><span class=\"bp\">»</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"bp\">«</span><span class=\"n\">_elab_term</span><span class=\"bp\">¬</span><span class=\"n\">__default</span><span class=\"bp\">»</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Elab.Term.TermElab</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">¬$</span><span class=\"n\">p</span><span class=\"o\">),</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"n\">Lean.Meta.mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">Not</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Lean.Elab.Term.elabTerm</span> <span class=\"n\">p</span> <span class=\"n\">none</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Lean.Elab.throwUnsupportedSyntax</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"o\">(</span><span class=\"n\">Syntax</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Elab</span> <span class=\"o\">(</span><span class=\"n\">throwUnsupportedSyntax</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Elab.Term</span> <span class=\"o\">(</span><span class=\"n\">TermElab</span> <span class=\"n\">elabTerm</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Meta</span> <span class=\"o\">(</span><span class=\"n\">whnf</span> <span class=\"n\">inferType</span> <span class=\"n\">mkAppM</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"bp\">«</span><span class=\"n\">term</span><span class=\"bp\">¬</span><span class=\"n\">_</span><span class=\"bp\">»</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"bp\">«</span><span class=\"n\">_elab_term</span><span class=\"bp\">¬</span><span class=\"n\">__custom</span><span class=\"bp\">»</span> <span class=\"o\">:</span> <span class=\"n\">TermElab</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">¬$</span><span class=\"n\">p</span><span class=\"o\">),</span> <span class=\"n\">type</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">isAnnType</span> <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"k\">do</span> <span class=\"n\">pure</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">whnf</span> <span class=\"n\">type</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isAppOfArity'</span> <span class=\"bp\">``</span><span class=\"n\">AnnType</span> <span class=\"mi\">0</span>\n  <span class=\"k\">let</span> <span class=\"n\">testArg</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">Elab.debug</span><span class=\"o\">]</span> <span class=\"s2\">\"Testing arg: {x}...\"</span>\n    <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">x</span> <span class=\"n\">none</span>\n    <span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">Elab.debug</span><span class=\"o\">]</span> <span class=\"s2\">\"Arg obtained: {x}\"</span>\n    <span class=\"n\">pure</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">if</span> <span class=\"bp\">←</span> <span class=\"n\">isAnnType</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"n\">x</span> <span class=\"k\">else</span> <span class=\"n\">none</span>\n  <span class=\"k\">let</span> <span class=\"n\">testType</span> <span class=\"o\">(</span><span class=\"n\">type</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">Elab.debug</span><span class=\"o\">]</span> <span class=\"s2\">\"Testing type: {type?}...\"</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"n\">type</span><span class=\"bp\">?</span> <span class=\"bp\">|</span> <span class=\"n\">pure</span> <span class=\"n\">none</span>\n    <span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">Elab.debug</span><span class=\"o\">]</span> <span class=\"s2\">\"Type extracted: {type}\"</span>\n    <span class=\"n\">pure</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">if</span> <span class=\"bp\">←</span> <span class=\"n\">isAnnType</span> <span class=\"n\">type</span> <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"n\">type</span> <span class=\"k\">else</span> <span class=\"n\">none</span>\n\n  <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">type</span> <span class=\"bp\">←</span> <span class=\"n\">testType</span> <span class=\"n\">type</span><span class=\"bp\">?</span> <span class=\"k\">then</span>\n    <span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">Elab.debug</span><span class=\"o\">]</span> <span class=\"s2\">\"Type {type} triggered\"</span>\n    <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">AnnType.Negation</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">p</span> <span class=\"n\">type</span><span class=\"o\">]</span>\n  <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">p</span> <span class=\"bp\">←</span> <span class=\"n\">testArg</span> <span class=\"n\">p</span> <span class=\"k\">then</span>\n    <span class=\"n\">trace</span><span class=\"o\">[</span><span class=\"n\">Elab.debug</span><span class=\"o\">]</span> <span class=\"s2\">\"Arg {p} triggered\"</span>\n    <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">AnnType.Negation</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span>\n  <span class=\"k\">else</span> <span class=\"n\">throwUnsupportedSyntax</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"c1\">-- All work now!</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"bp\">¬</span><span class=\"n\">p</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"k\">from</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"n\">AnnType.ann</span> <span class=\"bp\">¬</span><span class=\"n\">p</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ann</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>        <span class=\"bp\">↦</span> <span class=\"bp\">¬</span><span class=\"n\">p</span>\n</code></pre></div>\n<p>The reintroduction of the <code>¬</code> syntax and default elaboration shouldn't be necessary, but as mentioned above, I can't find a way to add my elaborator to the default syntax (or at least, with higher priority than the default elaborator).</p>",
        "id": 425771056,
        "sender_full_name": "Raghuram",
        "timestamp": 1710075192
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Interaction.20between.20notation.20and.20coercion/near/425716604\">said</a>:</p>\n<blockquote>\n<p>Here:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">unfoldInsts</span><span class=\"o\">)</span> <span class=\"s2\">\"unfold% \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Meta</span> <span class=\"k\">in</span>\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">unfoldProjInsts</span> <span class=\"o\">(</span><span class=\"n\">expr</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Lean.Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">expr</span> <span class=\"bp\">←</span> <span class=\"n\">unfoldProjInst</span><span class=\"bp\">?</span> <span class=\"n\">expr</span> <span class=\"k\">then</span>\n    <span class=\"n\">unfoldProjInsts</span> <span class=\"n\">expr</span>\n  <span class=\"k\">else</span> <span class=\"n\">pure</span> <span class=\"n\">expr</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Elab</span> <span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"n\">unfoldInsts</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabUnfoldInsts</span> <span class=\"o\">:</span> <span class=\"n\">Term.TermElab</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">unfold</span><span class=\"bp\">%</span> <span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">),</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">expr</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.instantiateMVars</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">←</span> <span class=\"n\">Term.withSynthesize</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.elabTerm</span> <span class=\"n\">t</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n    <span class=\"n\">unfoldProjInsts</span> <span class=\"n\">expr</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">↦</span> <span class=\"n\">unfold</span><span class=\"bp\">%</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"c1\">-- fun x y =&gt; Nat.add x y : Nat → Nat → Nat</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Is it necessary to use <code>Term.withSynthesize</code> in every iteration of the loop to ensure the unfolding happens, or does it suffice to do it outside the recursion since the entire instance must have been solved for (so for example, if it's a <code>HAdd</code> coming from an <code>Add</code>, the <code>Add</code> has to have been solved for too)?</p>",
        "id": 425774491,
        "sender_full_name": "Raghuram",
        "timestamp": 1710078254
    },
    {
        "content": "<p>The single <code>withSynthesize</code> is sufficient -- it ensures that every pending instance problem that is created inside its body is solved for (along with coercions and tactics). Unfolding can't introduce new instance problems.</p>",
        "id": 425785122,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710087327
    },
    {
        "content": "<p>Here's another version of the elaborator you wrote, which passes along more expected type information, and which uses <code>elabAppArgs</code> instead of <code>mkAppM</code>, since it's the function for elaborating applications (rather than for constructing applications in meta code) and it's happy to assign metavariables along the way. In your code, you mostly pass along expected type information, but in the following example a <code>mkAppM</code> fails because it won't assign metavariables:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Here's the code</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">AnnType</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"n\">type</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span>\n  <span class=\"n\">ann</span> <span class=\"o\">:</span> <span class=\"n\">String</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">AnnType</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span> <span class=\"kd\">instance</span> <span class=\"n\">coeSort</span> <span class=\"o\">:</span> <span class=\"n\">CoeSort</span> <span class=\"n\">AnnType</span> <span class=\"o\">(</span><span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">AnnType.type</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Negation</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span> <span class=\"n\">where</span>\n  <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"n\">α.type</span> <span class=\"bp\">→</span> <span class=\"n\">False</span>\n  <span class=\"n\">ann</span> <span class=\"o\">:=</span> <span class=\"s2\">\"Not \"</span> <span class=\"bp\">++</span> <span class=\"n\">α.ann</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">neg_type</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α.Negation.type</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">α.type</span> <span class=\"bp\">→</span> <span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">And</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span> <span class=\"n\">where</span>\n  <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">∧</span> <span class=\"n\">β</span>\n  <span class=\"n\">ann</span> <span class=\"o\">:=</span> <span class=\"n\">α.ann</span> <span class=\"bp\">++</span> <span class=\"s2\">\" and \"</span> <span class=\"bp\">++</span> <span class=\"n\">β.ann</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">and_type</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">AnnType</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α.And</span> <span class=\"n\">β</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">type</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">α.type</span> <span class=\"bp\">∧</span> <span class=\"n\">β.type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"n\">syntax</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">negStx</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"s2\">\"¬\"</span> <span class=\"n\">term</span><span class=\"o\">:</span><span class=\"mi\">40</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span> <span class=\"n\">Meta</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">elabApp</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">args</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"n\">none</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TermElabM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">elabAppArgs</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkConstWithFreshMVarLevels</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">#</span><span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"n\">args.map</span> <span class=\"bp\">.</span><span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"n\">false</span> <span class=\"n\">false</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"n\">negStx</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabNegStx</span> <span class=\"o\">:</span> <span class=\"n\">TermElab</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">¬$</span><span class=\"n\">p</span><span class=\"o\">),</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">isAnnType</span> <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"k\">do</span> <span class=\"n\">pure</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">whnf</span> <span class=\"n\">type</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isAppOfArity'</span> <span class=\"bp\">``</span><span class=\"n\">AnnType</span> <span class=\"mi\">0</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">expectedType</span><span class=\"bp\">?.</span><span class=\"n\">mapM</span> <span class=\"n\">isAnnType</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getD</span> <span class=\"n\">false</span> <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">p</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n      <span class=\"n\">elabApp</span> <span class=\"bp\">``</span><span class=\"n\">AnnType.Negation</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span>\n    <span class=\"k\">else</span>\n      <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">p</span> <span class=\"n\">none</span>\n      <span class=\"k\">if</span> <span class=\"bp\">←</span> <span class=\"n\">isAnnType</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n        <span class=\"n\">elabApp</span> <span class=\"bp\">``</span><span class=\"n\">AnnType.Negation</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span>\n      <span class=\"k\">else</span>\n        <span class=\"n\">elabApp</span> <span class=\"bp\">``</span><span class=\"n\">Not</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- All work now!</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"bp\">¬</span><span class=\"n\">p</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"k\">from</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"n\">AnnType.ann</span> <span class=\"bp\">¬</span><span class=\"n\">p</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ann</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">↦</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>        <span class=\"bp\">↦</span> <span class=\"bp\">¬</span><span class=\"n\">p</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">AnnType.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">})</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n</code></pre></div>\n</div></div>",
        "id": 425786225,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710088364
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"501683\">Raghuram</span> <a href=\"#narrow/stream/270676-lean4/topic/Interaction.20between.20notation.20and.20coercion/near/425718957\">said</a>:</p>\n<blockquote>\n<p>I think it's not triggered at all though, possibly because it has a lower priority than the default elaborator for the same syntax?</p>\n</blockquote>\n<p>BTW, I figured out why this is: the default <code>¬</code> is implemented via notation, which uses a macro rule that directly replaces <code>¬p</code> by <code>Not p</code>. As I understand it, macro rules are considered before elaborator rules, so the new elaborator is never given a chance to run.</p>",
        "id": 425854953,
        "sender_full_name": "Raghuram",
        "timestamp": 1710144875
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> for all your help over the last few days (across multiple threads)! I've learnt a lot about meta-programming and spent a lot less time than usual banging my head against a wall trying to understand and fix errors.</p>",
        "id": 426025681,
        "sender_full_name": "Raghuram",
        "timestamp": 1710198765
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"501683\">Raghuram</span> has marked this topic as resolved.</p>",
        "id": 426025731,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710198785
    }
]