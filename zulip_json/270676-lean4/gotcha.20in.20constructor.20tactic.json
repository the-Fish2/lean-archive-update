[
    {
        "content": "<p>Currently, if multiple constructors of a type are applicable to a goal, the <code>constructor</code> tactic will apply the first one which works.  For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span> <span class=\"c1\">-- uses `Or.inl`, not `Or.inr`</span>\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.MeasurableSpace.Defs</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MeasurableSpace</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">GenerateMeasurable</span> <span class=\"n\">s</span> <span class=\"n\">U</span><span class=\"bp\">ᶜ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span> <span class=\"c1\">-- uses `GenerateMeasurable.basic`, not `GenerateMeasurable.compl`</span>\n</code></pre></div>\n<p>The first one (with \"or\") is a big footgun, I have seen many novice users be confused by this.</p>",
        "id": 410657715,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704053850
    },
    {
        "content": "<p>I was going to propose adding an option to make <code>constructor</code> fail when there were multiple applicable constructors.  Then I started to dream bigger, since a current theme of the FRO's work is \"eliminating papercuts.\"  Maybe the tactic could just be changed to have this behaviour always (not hiding it behind an option)?  Does anyone actually use the \"pick a random constructor\" behaviour of the <code>constructor</code> tactic?</p>",
        "id": 410657790,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704053940
    },
    {
        "content": "<p>I think <code>constructor</code> should just fail for inductive types with more than one constructor</p>",
        "id": 410658092,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1704054342
    },
    {
        "content": "<p>I think it would be reasonable if it threw an error if multiple constructors applied. If people want the \"pick a random constructor\" behavior, maybe it could be <code>constructor*</code> or something.</p>",
        "id": 410658101,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704054355
    },
    {
        "content": "<p>I sympathize, and if we have evidence for or good reason to believe that this hinders beginners, we should consider this. Do you have a sense how big the impact is, in terms of mathlib breakage? Probably hard to evaluate without just doing it.</p>",
        "id": 410658107,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1704054362
    },
    {
        "content": "<p>I don't think it should fail for multi-constructor inductive types. There are places, when there are indices, where there's obviously one constructor that would apply, and I don't see why <code>constructor</code> shouldn't work here.</p>",
        "id": 410658170,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704054413
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/gotcha.20in.20constructor.20tactic/near/410658107\">said</a>:</p>\n<blockquote>\n<p>Do you have a sense how big the impact is, in terms of mathlib breakage?</p>\n</blockquote>\n<p>My guess would be that the \"random constructor\" feature is used zero times in mathlib ... since people have been trained to use <code>left</code> and <code>right</code> there.  But I don't have a sense of whether the \"random constructor\" feature is used in other (more CS-y) projects.</p>",
        "id": 410658253,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704054486
    },
    {
        "content": "<p>It's possible that people order constructors in their inductive types so that it's a \"reasonable constructor\" rather than a \"random constructor\"</p>",
        "id": 410658281,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704054574
    },
    {
        "content": "<p>It's not random, it's “first that matches”. I can't think of a good reason to use that behavior besides somewhat shallow convenience, and helping beginners with a good error message is probably worth it.</p>",
        "id": 410658282,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1704054576
    },
    {
        "content": "<p>(You're right, my use of the terminology \"random\" here is more colourful than truthful.  I think it's an accurate description of how my students interpret it, though!)</p>",
        "id": 410658387,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704054708
    },
    {
        "content": "<p>I'm not sure how to solicit feedback from people who may be making use of the current behaviour.  Is an RFC the next move?</p>",
        "id": 410658544,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704054889
    },
    {
        "content": "<p>I should think so. And someone has to prepare a patch and see what breaks.</p>",
        "id": 410659070,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1704055475
    },
    {
        "content": "<p>Also, I would really like to have the version that tries all constructors and backtracks if necessary! There is currently no way to express this directly with tactics right now</p>",
        "id": 410659223,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704055672
    },
    {
        "content": "<p>Quick'n'dirty implementation (cf <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Meta/Tactic/Constructor.lean\">the current implementation</a>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Lean.Meta</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">When the goal `mvarId` type is an inductive datatype,</span>\n<span class=\"sd\">and exactly one constructor matches the goal,</span>\n<span class=\"sd\">the `constructor` tactic calls `apply` with that constructor.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">_root_.Lean.MVarId.constructor2</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cfg</span> <span class=\"o\">:</span> <span class=\"n\">ApplyConfig</span> <span class=\"o\">:=</span> <span class=\"o\">{})</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">mvarId.withContext</span> <span class=\"k\">do</span>\n    <span class=\"n\">mvarId.checkNotAssigned</span> <span class=\"bp\">`</span><span class=\"n\">constructor</span>\n    <span class=\"k\">let</span> <span class=\"n\">target</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.getType'</span>\n    <span class=\"n\">matchConstInduct</span> <span class=\"n\">target.getAppFn</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwTacticEx</span> <span class=\"bp\">`</span><span class=\"n\">constructor</span> <span class=\"n\">mvarId</span> <span class=\"s2\">\"target is not an inductive datatype\"</span><span class=\"o\">)</span>\n      <span class=\"k\">fun</span> <span class=\"n\">ival</span> <span class=\"n\">us</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n        <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">workingCtors</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n        <span class=\"n\">for</span> <span class=\"n\">ctor</span> <span class=\"k\">in</span> <span class=\"n\">ival.ctors</span> <span class=\"k\">do</span>\n          <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"bp\">←</span> <span class=\"n\">saveState</span>\n          <span class=\"n\">try</span>\n            <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.apply</span> <span class=\"o\">(</span><span class=\"n\">Lean.mkConst</span> <span class=\"n\">ctor</span> <span class=\"n\">us</span><span class=\"o\">)</span> <span class=\"n\">cfg</span>\n            <span class=\"n\">workingCtors</span> <span class=\"o\">:=</span> <span class=\"n\">workingCtors.push</span> <span class=\"n\">ctor</span>\n            <span class=\"n\">s.restore</span>\n          <span class=\"n\">catch</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n            <span class=\"n\">s.restore</span>\n        <span class=\"k\">match</span> <span class=\"n\">workingCtors</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"bp\">#</span><span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwTacticEx</span> <span class=\"bp\">`</span><span class=\"n\">constructor</span> <span class=\"n\">mvarId</span> <span class=\"s2\">\"no applicable constructor found\"</span>\n        <span class=\"bp\">|</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">ctor</span><span class=\"o\">]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"bp\">←</span> <span class=\"n\">mvarId.apply</span> <span class=\"o\">(</span><span class=\"n\">Lean.mkConst</span> <span class=\"n\">ctor</span> <span class=\"n\">us</span><span class=\"o\">)</span> <span class=\"n\">cfg</span>\n        <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwTacticEx</span> <span class=\"bp\">`</span><span class=\"n\">constructor</span> <span class=\"n\">mvarId</span> <span class=\"s2\">\"more than one applicable constructor found\"</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Lean.Meta</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"constructor2\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Lean.Elab.Tactic.liftMetaTactic</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">g.constructor2</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor2</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">tactic 'constructor' failed, more than one applicable constructor found</span>\n<span class=\"cm\">P Q : Prop</span>\n<span class=\"cm\">⊢ P ∨ Q</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 410659273,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704055694
    },
    {
        "content": "<p>This is one of the things that is difficult to implement without support for backtracking in the tactic state, but with some syntactic concessions it could have the form <code>constructor =&gt; tacs</code> which tries <code>tacs</code> after applying each constructor and takes the first one that works</p>",
        "id": 410659358,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704055804
    },
    {
        "content": "<p>so that you could write <code>example (hq : Q) : P \\/ Q := by constructor =&gt; assumption</code></p>",
        "id": 410659391,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704055855
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/gotcha.20in.20constructor.20tactic/near/410659070\">said</a>:</p>\n<blockquote>\n<p>And someone has to prepare a patch and see what breaks.</p>\n</blockquote>\n<p>I put this patch on<br>\n<a href=\"https://github.com/hrmacbeth/lean4/tree/HM-ambiguous-constructor\">https://github.com/hrmacbeth/lean4/tree/HM-ambiguous-constructor</a><br>\nI've never written something in Lean core before -- can I <code>lake build</code> locally?  Is there a way to run CI on it?</p>",
        "id": 410659786,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704056314
    },
    {
        "content": "<p>lean core doesn't use lake (I know...)</p>",
        "id": 410660086,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704056561
    },
    {
        "content": "<p>you should follow the instructions at <a href=\"https://lean-lang.org/lean4/doc/make/index.html\">https://lean-lang.org/lean4/doc/make/index.html</a></p>",
        "id": 410660132,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704056598
    },
    {
        "content": "<p>I <a href=\"#narrow/stream/270676-lean4/topic/clang.3A.20error.3A.20unknown.20argument.3A.20\" title=\"-fstack-clash-protection\">had some trouble</a> building Lean core locally, is there a way to get the main <code>lean4</code> repo's CI to run on it?  Can I just open a draft PR, or is that a nuisance?</p>",
        "id": 410663306,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704060567
    },
    {
        "content": "<p>yes you can</p>",
        "id": 410663328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704060600
    },
    {
        "content": "<p>not that I can speak for the team of course</p>",
        "id": 410663370,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704060612
    },
    {
        "content": "<p>and if you are just looking for tests you probably want to watch the Nix CI as that is usually the fastest by far</p>",
        "id": 410663396,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1704060664
    },
    {
        "content": "<p>The draft PR is <a href=\"https://github.com/leanprover/lean4/pull/3127\">lean4#3127</a>, and it passes Lean core's CI without any changes to the codebase.  How do I get the automated testing on Mathlib to run?  The bot says</p>\n<blockquote>\n<p>Mathlib CI can not be attempted yet, as the 'nightly-testing-2023-12-31' branch does not exist there yet.</p>\n</blockquote>",
        "id": 410666460,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704064083
    },
    {
        "content": "<p>I responded there, but for other curious souls: The most reliable way to get mathlib CI right away is to make sure your branch branches off <code>nightly-with-mathlib</code>. The error message from the bot isn’t most helpful about this; branching of <code>nightly</code> means you only get mathlib CI once that nightly has had a successful mathlib build.</p>",
        "id": 410722698,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1704115196
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/gotcha.20in.20constructor.20tactic/near/410658170\">said</a>:</p>\n<blockquote>\n<p>I don't think it should fail for multi-constructor inductive types. There are places, when there are indices, where there's obviously one constructor that would apply, and I don't see why <code>constructor</code> shouldn't work here.</p>\n</blockquote>\n<p>I'm no longer fully convinced by this; just because only one constructor unifies doesn't necessarily mean it's the one you want:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">possible</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">impossible</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"c1\">-- unsolvable</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Perhaps <code>constructor</code> should always error when there is more than one option, but do so with a <code>try this</code> that suggests all the constructors that unify (<code>apply Foo.impossible</code> here). That way, the <code>constructor</code> tactic is always \"safe\" (in the sense of aesop).</p>",
        "id": 410822849,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704190059
    },
    {
        "content": "<p>However I have some proofs (around <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sum.liftRel#doc\">docs#Sum.liftRel</a>) which really do use the fact that <code>constructor</code> picks the correct constructor itself.</p>",
        "id": 410823070,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704190166
    },
    {
        "content": "<p>So I would like the current behavior to stay available as <code>constructor!</code></p>",
        "id": 410823094,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704190193
    },
    {
        "content": "<p>For context, those proofs recombine inductive predicates by breaking everything down in a lot of cases, running <code>constructor</code> to find the one constructor that applies, then <code>assumption</code> to fill everything in. It looks like <code>cases _ &lt;;&gt; constructor &lt;;&gt; assumption</code>.</p>",
        "id": 410823407,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704190332
    },
    {
        "content": "<p>I think this is a place where Mario's <code>cases _ &lt;;&gt; any_constructor =&gt; assumption</code> syntax would make sense</p>",
        "id": 410823711,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704190514
    },
    {
        "content": "<p>Where is that?</p>",
        "id": 410823876,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704190607
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/gotcha.20in.20constructor.20tactic/near/410659358\">said</a>:</p>\n<blockquote>\n<p>This is one of the things that is difficult to implement without support for backtracking in the tactic state, but with some syntactic concessions it could have the form <code>constructor =&gt; tacs</code> which tries <code>tacs</code> after applying each constructor and takes the first one that works</p>\n</blockquote>",
        "id": 410824386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704190807
    },
    {
        "content": "<p>Presumably with the extra behavior that if none work, it prints the error message for each one</p>",
        "id": 410824499,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704190865
    },
    {
        "content": "<p>Like Eric says, when you actually try to use this \"first matching\" feature in a large scale situation it doesn't actually work out most of the time. A recent case that came up for me was the reflected typechecker in lean4lean, which is a <a href=\"https://github.com/digama0/lean4lean/blob/521d6b5557b8c8070c08c84e25964c185e2a9f53/Lean4Lean/Theory/Typing/Meta.lean#L37-L50\">low effort macro</a> but I would have preferred to just use <code>repeat constructor</code></p>",
        "id": 410824858,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704191051
    },
    {
        "content": "<p>Ah, I guess the <code>constructor =&gt;</code> spelling doesn't work with <code>repeat</code></p>",
        "id": 410825268,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704191270
    },
    {
        "content": "<p>it kind of does, you can write recursive macros</p>",
        "id": 410825386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704191316
    },
    {
        "content": "<p>But on the subject of that macro, it is really abhorrently slow, it kind of made me despair for being able to actually write nontrivial tactics using <code>macro_rules</code></p>",
        "id": 410825626,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704191460
    },
    {
        "content": "<p>I think one difference between maths and CS here is that in CS it's really normal to have inductive types with more than two constructors and in maths it's much rarer (auxiliary inductive types for defining quotients via a list of rules being the exception but these tend not to be used outside the immediate API building which occurs after their definition)</p>",
        "id": 410825905,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704191631
    },
    {
        "content": "<p>Wrt giving the first applicable constructor, I found this confusing, the first time that I saw it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">case h</span>\n<span class=\"cm\">⊢ ¬True</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>I think that at least some warning about the fact that another constructor was applicable would be helpful.</p>",
        "id": 410826539,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1704191944
    },
    {
        "content": "<p>Could <code>constructor</code> apply the <em>unique</em> possible constructor, if available, and give a helpful message otherwise?  Then <code>constructor!</code> could apply the <em>first</em> possible constructor and maybe <code>constructor n</code> apply the <code>n</code>-th one?</p>",
        "id": 410826833,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1704192079
    },
    {
        "content": "<p>that's what <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> implemented in <a href=\"https://github.com/leanprover/lean4/pull/3127\">lean4#3127</a></p>",
        "id": 410828320,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704192846
    },
    {
        "content": "<p>I don't like <code>constructor n</code> though, the constructor has a name and you should use it if you want it</p>",
        "id": 410828450,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704192925
    },
    {
        "content": "<p>For the most part constructor order doesn't matter but both <code>constructor!</code> and <code>constructor n</code> are order dependent</p>",
        "id": 410828580,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704192991
    },
    {
        "content": "<p>I think we should discourage any proof methods that are constructor order dependent, although one of the more common order dependent proof methods is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction</span> <span class=\"n\">n</span>\n<span class=\"bp\">·</span> <span class=\"n\">foo</span>\n<span class=\"bp\">·</span> <span class=\"n\">rename_i</span> <span class=\"n\">a</span><span class=\"bp\">;</span> <span class=\"n\">bar</span>\n<span class=\"bp\">·</span> <span class=\"n\">next</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">baz</span>\n</code></pre></div>",
        "id": 410828898,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704193165
    },
    {
        "content": "<p>We should discourage that too, in favor of <code>with |</code>, right?</p>",
        "id": 410829095,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704193257
    },
    {
        "content": "<p>I think? there are certain cases of that we certainly can't deprecate like induction on <code>Nat</code>, but I think it's okay to say that the constructor order of <code>Nat</code> is a stable guarantee</p>",
        "id": 410829221,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704193317
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> <a href=\"https://github.com/leanprover/lean4/issues/3129#issuecomment-1873878504\">said</a>:</p>\n<blockquote>\n<p>As discussed <a href=\"#narrow/stream/270676-lean4/topic/gotcha.20in.20constructor.20tactic\">here</a>, I would like the current behavior to stay available under a different syntax, probably <code>constructor!</code>. The reason is that I have proofs involving inductive predicates with six constructors that are of the form <code>by cases h &lt;;&gt; constructor &lt;;&gt; assumption</code>.</p>\n</blockquote>\n<p>Can you elaborate on why the new version would not work for your use case?</p>",
        "id": 410834992,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704196494
    },
    {
        "content": "<p>As long as the six constructors have disjoint applicability, there will be no problem. And if they don't, this proof strategy is already somewhat broken because if the wrong constructor is selected then <code>assumption</code> fails and it doesn't backtrack. You would need the <code>any_constructor =&gt;</code> combinator to handle this kind of proof correctly</p>",
        "id": 410835168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704196607
    },
    {
        "content": "<p>I think Yael is referring to why my proposed modification of requiring exactly one constructor would not work for that case</p>",
        "id": 410836601,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704197346
    },
    {
        "content": "<blockquote>\n<p>As long as the six constructors have disjoint applicability,</p>\n</blockquote>\n<p>Does Lean have a mechanism to \"know\" that constructors are disjoint that would return false on <a href=\"#narrow/stream/270676-lean4/topic/gotcha.20in.20constructor.20tactic/near/410822849\">my example</a> above?</p>",
        "id": 410836714,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704197411
    },
    {
        "content": "<p>No, but again I'd like to see the example</p>",
        "id": 410837786,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704198030
    },
    {
        "content": "<p>actually, your example is nonsense anyway, you can't do what you want by applying a constructor</p>",
        "id": 410837893,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704198088
    },
    {
        "content": "<p>I'm very confused, you and Yael seem to be arguing for different cases</p>",
        "id": 410838073,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704198174
    },
    {
        "content": "<p>IMO <code>constructor</code> should only ever do unification, not rewriting or anything else, and it should pick the unique one that unifies if there is one, and people should be discouraged from using <code>constructor</code> when multiple constructors are applicable (but it remains to be seen whether this can be disallowed, be a warning or ignored). That's why I want to see <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> 's example</p>",
        "id": 410838273,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704198281
    },
    {
        "content": "<p>Here it is: <a href=\"https://github.com/YaelDillies/LeanCamCombi/blob/formal_book/LeanCamCombi/Mathlib/Combinatorics/SimpleGraph/Triangle/Tripartite.lean#L183-L198\">https://github.com/YaelDillies/LeanCamCombi/blob/formal_book/LeanCamCombi/Mathlib/Combinatorics/SimpleGraph/Triangle/Tripartite.lean#L183-L198</a></p>",
        "id": 410838459,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704198381
    },
    {
        "content": "<p>I'm in the middle of porting, so I can't guarantee you it will compile, but you can see the constructors at least. Indeed, they have disjoint applicability.</p>",
        "id": 410838501,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704198417
    },
    {
        "content": "<p>in your example <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> there is exactly one constructor that applies, but you end up in an unsolvable state afterwards. That's okay, you just made a wrong move to apply <code>constructor</code> and you should back up and <code>rw [add_comm]</code> first.</p>",
        "id": 410838530,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704198430
    },
    {
        "content": "<p>The argument I am trying to make above is that we should design <code>constructor</code> such that it never makes a goal unprovable. If you want to take a possibly-incorrect step, you should be forced to name it</p>",
        "id": 410839019,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704198679
    },
    {
        "content": "<p><code>constructor</code> is never going to be a reversible step</p>",
        "id": 410839493,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704198948
    },
    {
        "content": "<p>It's always reversible if the type has exactly one constructor, isn't it?</p>",
        "id": 410839605,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704199004
    },
    {
        "content": "<p>not for existentials</p>",
        "id": 410839664,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704199051
    },
    {
        "content": "<p>Just a note that now there is an RFC for this issue, <a href=\"https://github.com/leanprover/lean4/pull/3129\">lean4#3129</a>; so people who support the change can upvote it.</p>\n<p>I added <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span>'s example there.</p>",
        "id": 410881352,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704217305
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/gotcha.20in.20constructor.20tactic/near/410839664\">said</a>:</p>\n<blockquote>\n<p>not for existentials</p>\n</blockquote>\n<p>I don't agree:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">refine</span> <span class=\"n\">Classical.choose_spec</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"c1\">-- back where we started:</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 410882192,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704217703
    }
]