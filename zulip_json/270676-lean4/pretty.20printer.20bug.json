[
    {
        "content": "<p>I noticed that when hovering over the <code>+</code> in then following example, it displays the information about <code>f</code> instead of <code>+</code>. This seems to be a general problem when using a <code>binop%</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"mi\">4</span>\n</code></pre></div>",
        "id": 420662236,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1707488652
    },
    {
        "content": "<p>I think this is the same as <a href=\"#narrow/stream/270676-lean4/topic/infoview.20inspects.20term.20for.20only.20one.20frame/near/417649451\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/infoview.20inspects.20term.20for.20only.20one.20frame/near/417649451</a></p>",
        "id": 420678937,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707493680
    },
    {
        "content": "<p>When there is a coercion involved, then the bug doesn't appear:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Poly</span> <span class=\"n\">Int</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"mi\">4</span>\n</code></pre></div>",
        "id": 420687407,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1707496066
    },
    {
        "content": "<p>You might want to continue the discussion at the other thread? Not sure. At the very least someone should check to see if there's already an issue, and then file one and link to the previous thread.</p>",
        "id": 420688834,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707496493
    },
    {
        "content": "<p>The fact that a coercion inhibits the bug makes sense.</p>\n<p>I'm pretty sure it has to do with the unexpander that the <code>notation</code>/<code>infixl</code>/<code>infixr</code>/... generates for the over-applied case. It doesn't have anything to do with <code>binop%</code> -- instead if you're testing only binary operators they all incidentally have a <code>binop%</code> macro. You can verify this by adding <code>macro_rules | `($x + $y) =&gt; `(HAdd.hAdd $x $y)</code> to turn off the <code>binop%</code> elaborator.</p>\n<p>I think there are two solutions:<br>\n1) Get to the bottom of why the refs for the syntax generated by the unexpander aren't right, and/or<br>\n2) Make the app delaborator responsible for overapplication, though that might be at the cost of a bit of quadratic runtime in the unexpanders. (The app delaborator can run app unexpanders with fewer and fewer arguments, if there is an unexpander for that head constant.)</p>",
        "id": 420691846,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707497380
    },
    {
        "content": "<p>I've taken a closer look at the syntax generated by <code>notation</code>, and it turns out that this minimal example is what's going wrong:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Pi.Algebra</span>\n<span class=\"kd\">@[</span><span class=\"n\">app_unexpander</span> <span class=\"n\">HAdd.hAdd</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">unexpand</span> <span class=\"o\">:</span> <span class=\"n\">Lean.PrettyPrinter.Unexpander</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">HAdd.hAdd</span> <span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">throw</span> <span class=\"o\">()</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">HAdd.hAdd</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"mi\">4</span>\n</code></pre></div>\n<p>And we can fix it by placing brackets around the <code>x</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Pi.Algebra</span>\n<span class=\"kd\">@[</span><span class=\"n\">app_unexpander</span> <span class=\"n\">HAdd.hAdd</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">unexpand</span> <span class=\"o\">:</span> <span class=\"n\">Lean.PrettyPrinter.Unexpander</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">HAdd.hAdd</span> <span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"bp\">`</span><span class=\"o\">((</span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">c</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">throw</span> <span class=\"o\">()</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">HAdd.hAdd</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"mi\">4</span>\n</code></pre></div>",
        "id": 420747622,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1707520547
    },
    {
        "content": "<p>Note this comment in the definition of the <code>Syntax.node</code> constructor</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"o\">(</span><span class=\"n\">Remark</span><span class=\"o\">:</span> <span class=\"n\">the</span> <span class=\"bp\">`</span><span class=\"n\">node</span><span class=\"bp\">`</span> <span class=\"n\">constructor</span> <span class=\"n\">did</span> <span class=\"n\">not</span> <span class=\"k\">have</span> <span class=\"n\">an</span> <span class=\"bp\">`</span><span class=\"n\">info</span><span class=\"bp\">`</span> <span class=\"n\">field</span> <span class=\"k\">in</span> <span class=\"n\">previous</span>\n  <span class=\"n\">versions.</span> <span class=\"n\">This</span> <span class=\"n\">caused</span> <span class=\"n\">a</span> <span class=\"n\">bug</span> <span class=\"k\">in</span> <span class=\"n\">the</span> <span class=\"n\">interactive</span> <span class=\"n\">widgets</span><span class=\"o\">,</span> <span class=\"n\">where</span> <span class=\"n\">the</span> <span class=\"n\">popup</span> <span class=\"n\">for</span>\n  <span class=\"bp\">`</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"bp\">`</span> <span class=\"n\">was</span> <span class=\"n\">the</span> <span class=\"n\">same</span> <span class=\"n\">as</span> <span class=\"n\">for</span> <span class=\"bp\">`</span><span class=\"n\">a</span><span class=\"bp\">`.</span> <span class=\"n\">The</span> <span class=\"n\">delaborator</span> <span class=\"n\">used</span> <span class=\"n\">to</span> <span class=\"n\">associate</span>\n  <span class=\"n\">subexpressions</span> <span class=\"k\">with</span> <span class=\"n\">pretty</span><span class=\"bp\">-</span><span class=\"n\">printed</span> <span class=\"n\">syntax</span> <span class=\"kd\">by</span> <span class=\"n\">setting</span> <span class=\"n\">the</span> <span class=\"o\">(</span><span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"n\">position</span>\n  <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">first</span> <span class=\"n\">atom</span><span class=\"bp\">/</span><span class=\"n\">identifier</span> <span class=\"n\">to</span> <span class=\"n\">the</span> <span class=\"o\">(</span><span class=\"n\">expression</span><span class=\"o\">)</span> <span class=\"n\">position</span> <span class=\"n\">of</span> <span class=\"n\">the</span>\n  <span class=\"n\">subexpression.</span> <span class=\"n\">For</span> <span class=\"kd\">example</span><span class=\"o\">,</span> <span class=\"n\">both</span> <span class=\"bp\">`</span><span class=\"n\">a</span><span class=\"bp\">`</span> <span class=\"n\">and</span> <span class=\"bp\">`</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"bp\">`</span> <span class=\"k\">have</span> <span class=\"n\">the</span> <span class=\"n\">same</span> <span class=\"n\">first</span>\n  <span class=\"n\">identifier</span><span class=\"o\">,</span> <span class=\"n\">and</span> <span class=\"n\">so</span> <span class=\"n\">their</span> <span class=\"n\">infos</span> <span class=\"n\">got</span> <span class=\"n\">mixed</span> <span class=\"n\">up.</span><span class=\"o\">)</span> <span class=\"bp\">-/</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span>   <span class=\"o\">(</span><span class=\"n\">info</span> <span class=\"o\">:</span> <span class=\"n\">SourceInfo</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">kind</span> <span class=\"o\">:</span> <span class=\"n\">SyntaxNodeKind</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">args</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Syntax</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span>\n</code></pre></div>",
        "id": 420750621,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1707522375
    },
    {
        "content": "<p>I think it would be a natural feature that hovering over the <code>+</code> in <code>(f + g) 4</code> gives you the information about <code>f + g</code>, so not the full application with the 4 at the end. However, this is impossible using an unexpander, and instead would require a delaborator. This is because the default delaborator will not compute the information for the partially applied <code>f + g</code>, and so the unexpander also doesn't have access to this.</p>",
        "id": 420752435,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1707523499
    },
    {
        "content": "<p>In the case of the <code>⁻¹</code> notation, if it is overapplied, the hovering works fine, and there are no needed brackets for the over-application. So what I could imagine is that there is a bug in the code that adds brackets to insufficiently bracketed syntax. The bug being that it tries to find hover information for the newly bracketed syntax, even when no such information is available. However I don't know where the code is that adds these brackets.</p>",
        "id": 420937669,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1707699763
    },
    {
        "content": "<p>I noticed that in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">True</span>\n</code></pre></div>\n<p>There is hover information on both <code>1 ≤ 2</code> and <code>(1 ≤ 2)</code>, which I find a bit weird.<br>\nSo the problem seems to lie in automatically generated brackets getting too many annotations.<br>\nDoes anyone have a pointer as to which code is responsible for this?</p>",
        "id": 422037371,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1708198567
    },
    {
        "content": "<p>By the way, for your original report for <code>(f + g) 4</code>, I have a PR in the works to fix the issue. <a href=\"https://github.com/leanprover/lean4/pull/3375\">lean4#3375</a></p>",
        "id": 422037727,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708198957
    },
    {
        "content": "<p>For the term parenthesizer, take a look at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.PrettyPrinter.Parenthesizer.term.parenthesizer#doc\">docs#Lean.PrettyPrinter.Parenthesizer.term.parenthesizer</a></p>",
        "id": 422037808,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708199064
    },
    {
        "content": "<p>I touched that last. The way it used to work is that the parentheses didn't get any annotation at all, so when you hovered over them it would highlight the expression outside the parentheses.</p>",
        "id": 422037836,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708199108
    },
    {
        "content": "<p>Now, you can hover over the parentheses, at the cost of a mild amount of duplication. Maybe if there's some nice way to strip off and transfer position information it might be nicer still.</p>",
        "id": 422037916,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708199185
    },
    {
        "content": "<p>Notice that the way it works at the moment is that it copies the position information from the syntax to the parenthesized syntax, without touching the inner syntax.</p>",
        "id": 422037953,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708199252
    },
    {
        "content": "<p>Or, rather than touching the parenthesizer, perhaps the Infoview widget code can detect this case and highlight the parentheses too when you hover over the inside since they have the same expr position?</p>",
        "id": 422038538,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708199821
    },
    {
        "content": "<p>When shift-clicking this already sort of happens. Shift-clicking on either the <code>1 ≤ 2</code> or <code>(1 ≤ 2)</code> makes the parentheses highlight, but with more transparency than the inner part.</p>",
        "id": 422038904,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1708200140
    }
]