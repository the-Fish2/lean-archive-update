[
    {
        "content": "<p>Right now, the <code>rfl</code>  tactic is a macro that tries (once you load std4) <code>exact HEq.rfl</code>, <code>exact Iff.rfl</code> and then <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.refl#doc\">docs#Lean.MVarId.refl</a>. A consequence of this implementation is that the the error message isn’t beginner friendly (talks about <code>Iff.rfl</code> or <code>HEq.rfl</code>), and maybe it is a tad slower than it needs to be when using the general macro/<code>exact</code> machinery.</p>\n<p>Since <code>Iff</code> and <code>HEq</code> are both in Core, I wonder  whether it would make sense to simply teach <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.refl#doc\">docs#Lean.MVarId.refl</a> (or a variant thereof) to support all these three relations directly. This might make it (a bit) faster (not sure how important that is, maybe <code>rfl</code> is used within other tactics a lot?)  and have a better error message when it fails.</p>",
        "id": 420826153,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1707592676
    },
    {
        "content": "<p>This might be fixed in the near future since lots of std tactics are getting upstreamed to core</p>",
        "id": 420826290,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707592766
    },
    {
        "content": "<p>Indeed, seeing the upstreaming PR of <code>Iff.rfl</code> and the error message regression is what made me ponder this question.</p>",
        "id": 420826416,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1707592872
    },
    {
        "content": "<p>So assuming all functionality is in core, is the <code>macro_rule</code> based implementation or the single-<code>MetaM</code>-function implementation preferrable?</p>",
        "id": 420826442,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1707592906
    },
    {
        "content": "<p>I would say single MetaM function</p>",
        "id": 420827164,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707593606
    },
    {
        "content": "<p>certainly it makes it easier to fix the error messages</p>",
        "id": 420827175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707593618
    },
    {
        "content": "<p>plus the relation rfl tactic (using <code>@[refl]</code> theorems) already subsumes all of the others</p>",
        "id": 420827234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707593647
    },
    {
        "content": "<p>Is that a separate tactic? (I thought something like this would exist, but didn't find it right away)</p>",
        "id": 420827282,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1707593712
    },
    {
        "content": "<p>Ah, found it. The <code>macro_rules</code> line isn’t on the same line as <code>rfl</code> and escaped my grepping :-).<br>\nLooks like the macro and attribute is defined in std4, but almost most attribute assignments are in Mathlib, including those duplicating that <code>macro_rules</code> with <code>exact Heq.rfl</code> and <code>Iff.rfl</code>. Hmm. Maybe I’ll wait for the upstreaming storm to settle before barging into this area :-)</p>",
        "id": 420827382,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1707593797
    },
    {
        "content": "<p>BTW, the error message for</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std</span>\n<span class=\"kd\">example</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">don't</span> <span class=\"n\">know</span> <span class=\"n\">how</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">implicit</span> <span class=\"n\">argument</span>\n  <span class=\"bp\">@</span><span class=\"n\">HEq.rfl</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m.16</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m.17</span> <span class=\"n\">P</span><span class=\"o\">)</span>\n<span class=\"n\">context</span><span class=\"o\">:</span>\n<span class=\"n\">P</span><span class=\"o\">:</span> <span class=\"bp\">?</span><span class=\"n\">m.2</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">?</span><span class=\"n\">m.16</span> <span class=\"n\">P</span>\n</code></pre></div>\n<p><span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span></p>",
        "id": 420827620,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1707594028
    },
    {
        "content": "<p>A bit better with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>but not much:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">HEq.rfl</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">HEq</span> <span class=\"bp\">?</span><span class=\"n\">m.10</span> <span class=\"bp\">?</span><span class=\"n\">m.10</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>",
        "id": 420827636,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1707594059
    },
    {
        "content": "<p>The first one looks like a mistake, presumably you wanted a colon before P</p>",
        "id": 420827952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707594366
    },
    {
        "content": "<p>I think this is one reason not to allow unparenthesized binders, they are much more likely to be typos of either the result type or the theorem name</p>",
        "id": 420827991,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707594425
    },
    {
        "content": "<p>Fair enough.</p>\n<p>BTW, is there a way to query the registered macro rules? I.e. list all rules that apply to a given syntax term?</p>",
        "id": 420829581,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1707595925
    },
    {
        "content": "<p><code>#help tactic</code> is similar but doesn't cover individual macro rules</p>",
        "id": 420829643,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707596007
    },
    {
        "content": "<p>Oh, this is already implemented as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.HelpCmd</span>\n\n<span class=\"k\">#help</span> <span class=\"n\">tactic</span><span class=\"bp\">+</span> <span class=\"n\">trivial</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"s2\">\"trivial\"</span><span class=\"bp\">...</span> <span class=\"o\">[</span><span class=\"n\">Lean.Parser.Tactic.tacticTrivial</span><span class=\"o\">]</span>\n  <span class=\"bp\">`</span><span class=\"n\">trivial</span><span class=\"bp\">`</span> <span class=\"n\">tries</span> <span class=\"n\">different</span> <span class=\"n\">simple</span> <span class=\"n\">tactics</span> <span class=\"o\">(</span><span class=\"n\">e.g.</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">rfl</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">contradiction</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">...</span><span class=\"o\">)</span>\n  <span class=\"n\">to</span> <span class=\"n\">close</span> <span class=\"n\">the</span> <span class=\"n\">current</span> <span class=\"n\">goal.</span>\n  <span class=\"n\">You</span> <span class=\"n\">can</span> <span class=\"n\">use</span> <span class=\"n\">the</span> <span class=\"n\">command</span> <span class=\"bp\">`</span><span class=\"n\">macro_rules</span><span class=\"bp\">`</span> <span class=\"n\">to</span> <span class=\"n\">extend</span> <span class=\"n\">the</span> <span class=\"n\">set</span> <span class=\"n\">of</span> <span class=\"n\">tactics</span> <span class=\"n\">used.</span> <span class=\"n\">Example</span><span class=\"o\">:</span>\n  <span class=\"bp\">```</span>\n  <span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">trivial</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">simp</span><span class=\"o\">)</span>\n  <span class=\"bp\">```</span>\n<span class=\"bp\">+</span> <span class=\"n\">macro</span> <span class=\"n\">Lean.Parser.Tactic._aux_Init_Tactics___macroRules_Lean_Parser_Tactic_tacticTrivial_6</span>\n<span class=\"bp\">+</span> <span class=\"n\">macro</span> <span class=\"n\">Lean.Parser.Tactic._aux_Init_Tactics___macroRules_Lean_Parser_Tactic_tacticTrivial_5</span>\n<span class=\"bp\">+</span> <span class=\"n\">macro</span> <span class=\"n\">Lean.Parser.Tactic._aux_Init_Tactics___macroRules_Lean_Parser_Tactic_tacticTrivial_4</span>\n<span class=\"bp\">+</span> <span class=\"n\">macro</span> <span class=\"n\">Lean.Parser.Tactic._aux_Init_Tactics___macroRules_Lean_Parser_Tactic_tacticTrivial_3</span>\n<span class=\"bp\">+</span> <span class=\"n\">macro</span> <span class=\"n\">Lean.Parser.Tactic._aux_Init_Tactics___macroRules_Lean_Parser_Tactic_tacticTrivial_2</span>\n<span class=\"bp\">+</span> <span class=\"n\">macro</span> <span class=\"n\">Lean.Parser.Tactic._aux_Init_Tactics___macroRules_Lean_Parser_Tactic_tacticTrivial_1</span>\n</code></pre></div>\n<p>The constant names are go-to-def-able (unfortunately I couldn't find a less noisy way to do that in the current infoview)</p>",
        "id": 420830202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707596546
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/rfl.20tactic.20without.20a.20macro/near/420827164\">said</a>:</p>\n<blockquote>\n<p>I would say single MetaM function</p>\n</blockquote>\n<p>JFTR: escalated this to an RFC at <a href=\"https://github.com/leanprover/lean4/issues/3302\">https://github.com/leanprover/lean4/issues/3302</a></p>",
        "id": 420923678,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1707687392
    }
]