[
    {
        "content": "<p>I'm trying to automate a long but tedious proof, and most cases are straightforward constructor applications, but there are some cases where it's only apparent that a constructor can be applied after some simp rules have been applied.</p>\n<p>I'm wondering, is there either</p>\n<ul>\n<li>A version of <code>constructor</code> that rewrites the type of the constructor according to e.g. some simp lemmas, or</li>\n<li>A version of <code>constructor</code> that applies a constructor, then produces as goals the equalities that must be satisfied for the constructor application  to be type-correct</li>\n</ul>",
        "id": 433449616,
        "sender_full_name": "Joey Eremondi",
        "timestamp": 1713248576
    },
    {
        "content": "<p>Sounds to me like Aesop is the type of tactic that you want.</p>",
        "id": 433450022,
        "sender_full_name": "Henrik BÃ¶ving",
        "timestamp": 1713248757
    },
    {
        "content": "<p>It could be helpful having some examples. Is it that indices aren't defeq?</p>",
        "id": 433450788,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713249088
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Simp.2FRewrite.20type.20of.20constructor/near/433450788\">said</a>:</p>\n<blockquote>\n<p>It could be helpful having some examples. Is it that indices aren't defeq?</p>\n</blockquote>\n<p>Yes exactly, the indices are propositionally equal but not definitionallly.</p>",
        "id": 433452189,
        "sender_full_name": "Joey Eremondi",
        "timestamp": 1713249723
    },
    {
        "content": "<p>This tactic doesn't exist, but I've been thinking about what it would take to make it.</p>\n<p>One issue that comes to mind is that, if you're able to create equalities, then usually <em>every</em> constructor is applicable (barring universe constraints). If you can name which constructor you want to apply, then I think it shouldn't be too much work to make a tactic that lets you apply it and create side goals for equalities.</p>",
        "id": 433578632,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713290681
    },
    {
        "content": "<p>It could be that you have to specify a discharger tactic (with perhaps <code>simp</code> as the default discharger), and it takes the first constructor such that the discharger is able to prove all the generated equalities.</p>",
        "id": 433578744,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713290724
    }
]