[
    {
        "content": "<p>In a hole in Agda, one can do C-c C-. to show the type of a current goal, but one can also do C-y C-. to show the type normalized - that is all computations that Agda can figure out about a type are performed. If some type is a result of a complex type-level function or something, the first command will show all these calls, and the second one will actually show the result. Often it reduces to just a sigma or pi type. In Lean I'm always looking at the infoview and performing these computations in my head or typing out patterns blindly to see the squiggles disappear.</p>",
        "id": 436921334,
        "sender_full_name": "Andr√© Muricy Santos",
        "timestamp": 1714754652
    },
    {
        "content": "<p>This is not exactly what you want, but I think the closest we have is probably <code>dsimp</code>.</p>",
        "id": 436921567,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714754763
    },
    {
        "content": "<p>But that requires that the relevant definitional lemmas are tagged <code>@[simp]</code>.</p>",
        "id": 436921681,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714754802
    },
    {
        "content": "<p>Are you looking for <code>whnf</code> or <code>reduce</code>? These are in <code>Mathlib.Tactic.DefEqTransformations</code> (which is imported by nearly anything in mathlib via <code>Mathlib.Tactic.Common</code>), but they might make their way into core Lean at some point.</p>",
        "id": 436939891,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714761867
    },
    {
        "content": "<p>ooh, I didn't know we had those as tactics</p>",
        "id": 436943912,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714763541
    }
]