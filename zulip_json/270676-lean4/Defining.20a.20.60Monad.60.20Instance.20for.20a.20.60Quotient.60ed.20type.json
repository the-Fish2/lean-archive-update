[
    {
        "content": "<p>I have some type function <code>Raw : Type → Type</code>, with <code>Q : Type → Type := fun α =&gt; Quotient _</code> defined as a <code>Quotient</code> over the <code>Raw</code> type. I've managed to define <code>bind (x : Raw α) (f : α → Raw β) : Raw β</code>, but I'm struggling with how to lift this function into a <code>bind</code> over <code>Q</code>.</p>\n<p><code>Quotient.lift\\2</code> does not work as-is, because it expects both arguments to be quotients, and in my case <code>f</code> is not a quotient, but a function returning a quotient.</p>\n<p>I've found <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Quot.html#Quotient.choice\">Quotient.choice</a>, which allows me to convert the \"function-of-quotients\" into a \"quotient of functions\", which I can then successfully lift. However, it's <code>noncomputable</code>, and I really want to be able to both reason about and compute with <code>Q</code>.</p>\n<p>I what I'm trying just fundamentally impossible? Or have I missed some other option?</p>",
        "id": 431291818,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1712230937
    },
    {
        "content": "<p>Can you make a mwe?</p>",
        "id": 431292213,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712231038
    },
    {
        "content": "<p>Sure! Here's a very simplified version (in reality, <code>Raw</code> is not just <code>Option</code>, and the quotient relation is not just equality, but I think it still has the same problem as I'm facing)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The `Raw` type, let's just take `Option` for the `MWE` -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Raw</span> <span class=\"o\">:=</span> <span class=\"n\">Option</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Raw.bind</span> <span class=\"o\">:</span> <span class=\"n\">Raw</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Raw</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Raw</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Option.bind</span>\n\n<span class=\"sd\">/-- For simplicity, we're just quotienting through equality -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Raw.setoid</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"o\">(</span><span class=\"n\">Raw</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">Eq</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"n\">refl</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"n\">Eq.symm</span>\n    <span class=\"n\">trans</span> <span class=\"o\">:=</span> <span class=\"n\">Eq.trans</span>\n  <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Define `Q` as a quotient over `Raw` -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Q</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient</span> <span class=\"o\">(</span><span class=\"n\">Raw.setoid</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Now, how do I actually define `bind` over `Q`? -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Q.bind</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 431292414,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1712231091
    },
    {
        "content": "<p>My first instinct was to use <code>Quotient.lift₂</code>, but that doesn't work with <code>f</code> a function</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Q.bind</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Quotient.lift₂</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"n\">f</span>\n<span class=\"c1\">--                     ^ `application type mismatch` (i.e., `f` is not a quotient)</span>\n</code></pre></div>",
        "id": 431293942,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1712231545
    },
    {
        "content": "<p>I think your missing piece is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">missing</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Raw</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>or perhaps</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">missing</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Raw</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"o\">(</span><span class=\"n\">Raw</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 431311414,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712236597
    },
    {
        "content": "<p>Hmm, I'm trying for <code>Raw (Raw α) -&gt; Raw α</code> at the moment, which sould be easy, since <code>Raw</code> is a <code>Monad</code> (just not a lawful one). Thanks for the extra inspiration!</p>",
        "id": 431312000,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1712236775
    },
    {
        "content": "<p>And then, hopefully I should be able to lift that into <code>Q (Q \\a) -&gt; Q(\\a)</code></p>",
        "id": 431312260,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1712236842
    },
    {
        "content": "<p>Something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Now, how do I actually define `bind` over `Q`? -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Q.bind</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">Quotient.lift</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Quotient.map'</span> <span class=\"o\">(</span><span class=\"n\">Raw.bind</span> <span class=\"bp\">·</span> <span class=\"n\">id</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">missing</span> <span class=\"o\">(</span><span class=\"n\">a.map</span> <span class=\"n\">f</span><span class=\"o\">)))</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"n\">x</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"n\">ha</span>\n    <span class=\"n\">dsimp</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 431312574,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712236928
    },
    {
        "content": "<p><code>Raw (Raw α) -&gt; Raw α</code> is <code>Raw.bind · id</code></p>",
        "id": 431312619,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712236945
    },
    {
        "content": "<p>Thanks! Unfortunately in my real code, <code>Raw</code> involves a universe bump, so I'm not quite there yet, but your snippet gives me a new direction to explore!</p>",
        "id": 431314317,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1712237483
    },
    {
        "content": "<p>I think if <code>Raw</code> bumps the universe then the only option you really have is to define <code>bind</code> and get the monad instance that way, since <code>Raw (Raw A)</code> wouldn't work</p>",
        "id": 431330661,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1712241974
    },
    {
        "content": "<p>I have defined <code>bind</code> on <code>Raw</code>, but how would I do so for the quotient <code>Q</code>, without going through <code>Raw (Raw A)</code>? Would <code>Raw (Q A)</code> work? I'd guess not, since <code>Q</code> also bumps the universe</p>",
        "id": 431331118,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1712242089
    },
    {
        "content": "<p>hmmmm I see the issue now.</p>",
        "id": 431332707,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1712242476
    },
    {
        "content": "<p>to define bind directly you would need to lift along the family <code>A -&gt; Q B</code> which would involve choice.</p>",
        "id": 431332861,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1712242526
    },
    {
        "content": "<p>are your <code>Raw A</code> actually in a higher universe, or only by accident due to some inductive construction? In other words, can you get rid of the universe bump?</p>",
        "id": 431333290,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1712242635
    },
    {
        "content": "<p>I suspect I can't get rid of the universe bump, but don't know for sure.</p>\n<p>To add some context: I'm trying to define a monad for potentially non-terminating computations which is both computable, and can be reasoned about. The design so far is to represent computations as state machines, so <code>Raw</code> is actually:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">PartialM.Raw</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">next</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">PartialStep</span> <span class=\"n\">σ</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">state</span> <span class=\"o\">:</span> <span class=\"n\">σ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I want to hide this state-machine encoding from the user, so I've made the state type <code>\\sigma</code> a field of the structure, and that is what causes the bump</p>",
        "id": 431334375,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1712242903
    },
    {
        "content": "<p>The quotient comes in because there can be different state machines that represent the same computation / final result, so I have to quotient the type to get a lawful monad</p>",
        "id": 431334647,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1712242971
    },
    {
        "content": "<p>Ooh, I might have a solution: if I fix the state <code>\\sigma</code> to live in <code>Type</code>, rather than the polymorphic <code>Type u</code>, then it might work out.</p>",
        "id": 431336278,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1712243369
    },
    {
        "content": "<p>No, the universe of this <code>Raw</code> will still be one higher since you're quantifying over sigma.</p>",
        "id": 431336507,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1712243421
    },
    {
        "content": "<p>The universe bump still happens, but I should be able to define <code>join : Raw (Raw A) -&gt; A</code> regardless.</p>",
        "id": 431336805,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1712243509
    },
    {
        "content": "<p>oh I see</p>",
        "id": 431336947,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1712243536
    },
    {
        "content": "<p>but then you will need <code>Raw</code> to be universe polymorphic.</p>",
        "id": 431337039,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1712243566
    },
    {
        "content": "<p>The problem I was running into was not the universe of the result, but rather that the joined state machine has to store the state of the originally nested state machine, which could have state in a higher universe</p>",
        "id": 431337073,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1712243578
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/270676-lean4/topic/Defining.20a.20.60Monad.60.20Instance.20for.20a.20.60Quotient.60ed.20type/near/431337039\">said</a>:</p>\n<blockquote>\n<p>but then you will need <code>Raw</code> to be universe polymorphic.</p>\n</blockquote>\n<p>Indeed, and it is (just not in the MWE, sorry for the confusion there)</p>",
        "id": 431337162,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1712243603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481133\">Alex Keizer</span> <a href=\"#narrow/stream/270676-lean4/topic/Defining.20a.20.60Monad.60.20Instance.20for.20a.20.60Quotient.60ed.20type/near/431334375\">said</a>:</p>\n<blockquote>\n<p>To add some context: I'm trying to define a monad for potentially non-terminating computations which is both computable, and can be reasoned about.</p>\n</blockquote>\n<p>This sounds a lot like what I have been trying to do recently. Very recently, I have come to the conclusion that there is a better approach. It should be possible to generalize the concept of a monad somewhat to allow for some heterogeneity, such that it's possible to use the state machine directly in monadic computations.</p>",
        "id": 431396573,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1712262558
    },
    {
        "content": "<p>Cool! I vaguely remember some talk about heterogenous bind on this chat, was that you? Is this available somewhere, I'd love to have a look.<br>\nStill, I would like to use this monad in a an existing development, which extensively uses <code>Monad</code> and <code>LawfulMonad</code>, so I'm still hoping I can get this through somehow</p>",
        "id": 431397018,
        "sender_full_name": "Alex Keizer",
        "timestamp": 1712262746
    },
    {
        "content": "<p>It wasn't me. This idea is very new, so I don't have any code yet, but I sent you a DM with the general outline.</p>",
        "id": 431401678,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1712264568
    }
]