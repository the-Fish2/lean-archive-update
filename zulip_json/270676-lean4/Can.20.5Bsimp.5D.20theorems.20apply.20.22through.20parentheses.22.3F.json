[
    {
        "content": "<p>Here's a theorem I have. It states that a simple reflection multiplied by itself gives the identity. (Here, <code>(s i)</code> refers to an element of a particular group.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">simple_mul_self</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>Now, suppose I have an expression like <code>g * (s i) * (s i)</code>. The simplifier can't correctly simplify this to <code>g</code> because it's really <code>(g * (s i)) * (s i)</code>, so <code>(s i) * (s i)</code> never actually appears anywhere. Is there any way to fix this?</p>",
        "id": 426467576,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1710390072
    },
    {
        "content": "<p>you can rewrite with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mul_assoc#doc\">docs#mul_assoc</a></p>",
        "id": 426467836,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710390271
    },
    {
        "content": "<p>What I mean is: is there any way to make the simplifier do it automatically?</p>",
        "id": 426467864,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1710390300
    },
    {
        "content": "<p>you mean beyond just doing <code>simp [mul_assoc]</code>? like marking <code>mul_assoc</code> as a simp lemma?</p>",
        "id": 426468162,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710390550
    },
    {
        "content": "<p>I'm not sure if there's a way to tell Lean \"<code>simp</code> should try <code>mul_assoc</code> before <code>simple_mul_self</code> if <code>simple_mul_self</code> doesn't work\" without making <code>mul_assoc</code> a simp lemma more generally... but there could be a trick I'm unaware of</p>",
        "id": 426468403,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710390715
    },
    {
        "content": "<p>I think I will just go with adding a separate theorem that says that <code>g * (s i) * (s i)</code> is equal to <code>g</code>, but I was wondering if there was a different solution.</p>",
        "id": 426468496,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1710390775
    },
    {
        "content": "<p>this is hard to automate in general, and I don't think there's a general-purpose way to get <code>simp</code> to do what you want. if there's more structure here then sometimes you can use stronger (but more specific) automation such as <code>ring</code> or <code>omega</code>, or you can use more bruteforce automation such as <code>aesop</code> which you can instruct to blindly apply associativity/commutativity in its search for proofs. but <code>simp</code> alone is not designed to handle this situation.</p>",
        "id": 426468666,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1710390923
    },
    {
        "content": "<p>That's probably easiest <span class=\"user-mention\" data-user-id=\"695266\">@Mitchell Lee</span>. Mathlib's category theory library has a <code>@[reassoc]</code> attribute that generates similar lemmas for compositions of morphisms in a category. There could be such a metaprogram for binary operations such as <code>*</code>.</p>",
        "id": 426468699,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710390950
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"695266\">Mitchell Lee</span> <a href=\"#narrow/stream/270676-lean4/topic/Can.20.5Bsimp.5D.20theorems.20apply.20.22through.20parentheses.22.3F/near/426468496\">said</a>:</p>\n<blockquote>\n<p>I think I will just go with adding a separate theorem that says that <code>g * (s i) * (s i)</code> is equal to <code>g</code>, but I was wondering if there was a different solution.</p>\n</blockquote>\n<p>This is exactly what <code>@[reassoc]</code> does (but for categorical composition, rather than multiplication).</p>\n<p>It works great, as far as it goes. :-)</p>",
        "id": 426468828,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710391064
    },
    {
        "content": "<p>Mathlib 3 also had the <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#assoc_rewrite\"><code>assoc_rewrite</code></a> tactic, which I'm not sure I ever used.</p>",
        "id": 426468922,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710391136
    }
]