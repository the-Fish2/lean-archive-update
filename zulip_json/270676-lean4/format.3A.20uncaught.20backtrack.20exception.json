[
    {
        "content": "<p>Minimized from mathlib:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">AddMonoidAlgebra</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">Unit</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">9000</span> <span class=\"n\">R</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"[\"</span> <span class=\"n\">A</span> <span class=\"s2\">\"]\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">AddMonoidAlgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span>\n\n<span class=\"c1\">-- format: uncaught backtrack exception</span>\n<span class=\"k\">#eval</span> <span class=\"k\">do</span> <span class=\"n\">PrettyPrinter.ppTerm</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"bp\">|</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]),</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 429966964,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711582826
    },
    {
        "content": "<p>This only seems to happen when the custom notation is used in a binder</p>",
        "id": 429966988,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711582848
    },
    {
        "content": "<p>It looks like this is interfering with array indexing notation?</p>",
        "id": 429968620,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711583840
    },
    {
        "content": "<p>the syntax quotation is producing a <code>choice</code> node</p>",
        "id": 429977932,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711590083
    },
    {
        "content": "<p>if you make the notation high or low priority then it will not do this</p>",
        "id": 429977957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711590111
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> It appears this is an unusual interaction of formatter combinators and ungrouped <code>optional</code> nodes. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"n\">syntax</span><span class=\"o\">:</span><span class=\"mi\">9000</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span><span class=\"o\">)</span> <span class=\"n\">term</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"  [\"</span> <span class=\"n\">term</span> <span class=\"s2\">\"-]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">syntax</span><span class=\"o\">:</span><span class=\"mi\">9000</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">foo2</span><span class=\"o\">)</span> <span class=\"n\">term</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\" [\"</span> <span class=\"n\">term</span> <span class=\"s2\">\"-]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"n\">run_meta</span>\n  <span class=\"c1\">-- let stx ← `(Parser.Term.bracketedBinderF| (f : R[A]))</span>\n  <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Parser.Term.bracketedBinderF</span><span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"bp\">-</span><span class=\"o\">]))</span>\n  <span class=\"n\">_</span> <span class=\"bp\">←</span> <span class=\"n\">PrettyPrinter.format</span> <span class=\"n\">Parser.Term.explicitBinder.formatter</span> <span class=\"n\">stx</span>\n</code></pre></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Here's my test after inlining things to add logging</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"n\">syntax</span><span class=\"o\">:</span><span class=\"mi\">9000</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span><span class=\"o\">)</span> <span class=\"n\">term</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"  [\"</span> <span class=\"n\">term</span> <span class=\"s2\">\"-]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">syntax</span><span class=\"o\">:</span><span class=\"mi\">9000</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">foo2</span><span class=\"o\">)</span> <span class=\"n\">term</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\" [\"</span> <span class=\"n\">term</span> <span class=\"s2\">\"-]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">PrettyPrinter</span> <span class=\"n\">Formatter</span> <span class=\"n\">Syntax.MonadTraverser</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">tag</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Formatter</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Formatter</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"bp\">←</span> <span class=\"n\">getCur</span>\n  <span class=\"k\">let</span> <span class=\"n\">t</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">inferInstance</span> <span class=\"o\">:</span> <span class=\"n\">Syntax.MonadTraverser</span> <span class=\"n\">FormatterM</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">st.get</span>\n  <span class=\"n\">logInfo</span> <span class=\"n\">f</span><span class=\"bp\">!</span><span class=\"s2\">\"{s} [{t.parents}]: {stx}\"</span>\n  <span class=\"n\">try</span>\n    <span class=\"n\">p</span>\n    <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"bp\">←</span> <span class=\"n\">getCur</span>\n    <span class=\"n\">logInfo</span> <span class=\"n\">f</span><span class=\"bp\">!</span><span class=\"s2\">\"after {s}: {stx}\"</span>\n  <span class=\"n\">catch</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{s} failed\"</span>\n    <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"bp\">←</span> <span class=\"n\">getCur</span>\n    <span class=\"n\">logInfo</span> <span class=\"n\">f</span><span class=\"bp\">!</span><span class=\"s2\">\"after {s}: {stx}\"</span>\n    <span class=\"n\">throw</span> <span class=\"n\">e</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Lean.Parser.Term.binderType.formatter'</span> <span class=\"o\">:</span> <span class=\"n\">Formatter</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">andthen.formatter</span> <span class=\"o\">(</span><span class=\"n\">Parser.symbol.formatter</span> <span class=\"s2\">\" : \"</span><span class=\"o\">)</span> <span class=\"n\">Parser.termParser.formatter</span>\n  <span class=\"k\">let</span> <span class=\"n\">kind</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">optional</span>\n  <span class=\"k\">let</span> <span class=\"n\">suffix</span> <span class=\"o\">:=</span> <span class=\"n\">Parser.symbol.formatter</span> <span class=\"s2\">\"?\"</span>\n  <span class=\"n\">optionalNoAntiquot.formatter</span> <span class=\"o\">(</span>\n    <span class=\"n\">tag</span> <span class=\"s2\">\"withAntiquot\"</span> <span class=\"bp\">&lt;|</span>\n    <span class=\"n\">orelse.formatter</span>\n      <span class=\"o\">(</span><span class=\"n\">tag</span> <span class=\"s2\">\"t1\"</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Parser.mkAntiquotSplice.formatter</span> <span class=\"n\">kind</span> <span class=\"o\">(</span><span class=\"n\">withoutInfo.formatter</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">suffix</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">tag</span> <span class=\"s2\">\"t2\"</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">withAntiquotSuffixSplice.formatter</span> <span class=\"n\">kind</span> <span class=\"n\">p</span> <span class=\"n\">suffix</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Lean.Parser.Term.explicitBinder.formatter'</span> <span class=\"o\">:</span> <span class=\"n\">Formatter</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Parser.ppGroup.formatter</span>\n    <span class=\"o\">(</span><span class=\"n\">Parser.leadingNode.formatter</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Term.explicitBinder</span> <span class=\"mi\">1024</span>\n      <span class=\"o\">(</span><span class=\"n\">andthen.formatter</span> <span class=\"o\">(</span><span class=\"n\">Parser.symbol.formatter</span> <span class=\"s2\">\"(\"</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">andthen.formatter</span>\n          <span class=\"o\">(</span><span class=\"n\">Parser.withoutPosition.formatter</span>\n            <span class=\"o\">(</span><span class=\"n\">andthen.formatter</span> <span class=\"o\">(</span><span class=\"n\">Parser.many1.formatter</span> <span class=\"n\">Parser.Term.binderIdent.formatter</span><span class=\"o\">)</span>\n              <span class=\"o\">(</span><span class=\"n\">andthen.formatter</span> <span class=\"n\">Parser.Term.binderType.formatter'</span>\n                <span class=\"o\">(</span><span class=\"n\">Parser.optional.formatter</span>\n                  <span class=\"o\">(</span><span class=\"n\">orelse.formatter</span> <span class=\"n\">Parser.Term.binderTactic.formatter</span> <span class=\"n\">Parser.Term.binderDefault.formatter</span><span class=\"o\">)))))</span>\n          <span class=\"o\">(</span><span class=\"n\">Parser.symbol.formatter</span> <span class=\"s2\">\")\"</span><span class=\"o\">))))</span>\n\n<span class=\"n\">run_meta</span>\n  <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Parser.Term.bracketedBinderF</span><span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"bp\">-</span><span class=\"o\">]))</span>\n  <span class=\"n\">_</span> <span class=\"bp\">←</span> <span class=\"n\">PrettyPrinter.format</span> <span class=\"n\">Parser.Term.explicitBinder.formatter'</span> <span class=\"n\">stx</span>\n</code></pre></div>\n</div></div>\n<p>When testing with the non-overloaded syntax <code>R[A]</code>, the optional node in <code>binderType</code> is of the form <code>[\":\" (term_[_] ...)]</code>, and <code>optionalNoAntiquot.formatter</code> zooms in on the first subterm <code>(term_[_] ...)</code>, which is consumed by <code>term</code> (which moves the cursor to <code>\":\"</code>) and then <code>\":\"</code> as intended.</p>\n<p>With the overloaded syntax <code>R[A-]</code>, the optional node is instead <code>[\":\" (choice (foo ...) (foo2 ...))]</code>, and again <code>optionalNoAntiquot.formatter</code> zooms in on <code>(choice (foo ...) (foo2 ...))</code>. But then we use <code>orelse.formatter</code> (actually <code>withAntiquot.formatter</code>) in order to try a possible antiquot at this position, and <code>orelse.formatter</code> strips choice nodes, so it zooms in further to <code>(foo2 ...)</code>; applying <code>term</code> here succeeds and moves to the left to <code>(foo ...)</code> and applying <code>\":\"</code> here fails.</p>",
        "id": 429986376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711595662
    },
    {
        "content": "<p>I think the issue is that <code>orelse.formatter</code> has an implementation which doesn't make sense if the provided formatters <code>p1</code> and <code>p2</code> have arity &gt; 1, which is the case here because <code>p2</code> is <code>\":\" &gt;&gt; term</code></p>",
        "id": 429986581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711595796
    },
    {
        "content": "<p>(<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=orelse.formatter#src\">src#orelse.formatter</a>)</p>",
        "id": 430001946,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711605673
    }
]