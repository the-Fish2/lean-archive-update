[
    {
        "content": "<p>I was tinkering with lean 4, and I ran into the following difference. Even though I use exactly the same lambda term to construct both a theorem and a def, lean handles them differently. Is there an explanation about how this is implemented, or can someone maybe explain it? Is it the fact that proof irrelevance requires that \"theorem5\" is actually allowed to behave differently from \"def5\", even though I used the exact same term, and Prop is nowhere in sight?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">def5</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">5</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">theorem5</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">def5</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">result5</span> <span class=\"o\">:</span> <span class=\"n\">def5</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">theorem5</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">hdef</span> <span class=\"o\">:</span> <span class=\"n\">def5</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rfl</span>\n    <span class=\"n\">done</span>\n  <span class=\"k\">have</span> <span class=\"n\">htheorem</span> <span class=\"o\">:</span> <span class=\"n\">theorem5</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"c1\">-- rfl -- Not sure what to do here, I would expect it would just become 5 but apparently for theorems this definition is not handled transparently...?</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hdef</span><span class=\"o\">,</span> <span class=\"n\">htheorem</span><span class=\"o\">]</span>\n  <span class=\"n\">done</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">def5</span> <span class=\"mi\">0</span> <span class=\"c1\">-- Ok, prints 5</span>\n<span class=\"k\">#eval</span> <span class=\"n\">theorem5</span> <span class=\"mi\">0</span> <span class=\"c1\">-- Error, \"failed to compile definition, consider marking it as 'noncomputable' because it depends on 'theorem5', and it does not have executable code\"</span>\n</code></pre></div>\n<p>Thanks for any tips, sources or explanations!</p>",
        "id": 420242042,
        "sender_full_name": "Bob Rubbens",
        "timestamp": 1707309359
    },
    {
        "content": "<p>Note that you get the same error for <code>def5</code> if you instead define it as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">def5</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">5</span>\n</code></pre></div>",
        "id": 420242686,
        "sender_full_name": "David Renshaw",
        "timestamp": 1707309563
    },
    {
        "content": "<p>Yes, excuse my slowness, in what way is that significant? They still reduce to exactly the same term, right?</p>",
        "id": 420242903,
        "sender_full_name": "Bob Rubbens",
        "timestamp": 1707309631
    },
    {
        "content": "<p>You can think of <code>theorem</code> as syntactic sugar for <code>noncomputable def</code> (plus maybe <code>@[irreducible]</code> and a few other attributes, I forget exactly which)</p>",
        "id": 420243251,
        "sender_full_name": "David Renshaw",
        "timestamp": 1707309765
    },
    {
        "content": "<p>This works for your <code>htheorem</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">have</span> <span class=\"n\">htheorem</span> <span class=\"o\">:</span> <span class=\"n\">theorem5</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">theorem5</span> <span class=\"n\">def5</span>\n    <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 420243755,
        "sender_full_name": "David Renshaw",
        "timestamp": 1707309941
    },
    {
        "content": "<p><code>theorem</code> is meant for theorems, not definitions. In particular, the value is not usable</p>",
        "id": 420249506,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1707311835
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243791\">David Renshaw</span> <a href=\"#narrow/stream/270676-lean4/topic/How.20does.20def.20differ.20from.20theorem.3F/near/420243251\">said</a>:</p>\n<blockquote>\n<p>You can think of <code>theorem</code> as syntactic sugar for <code>noncomputable def</code> (plus maybe <code>@[irreducible]</code> a few other attributes, I forget exactly which)</p>\n</blockquote>\n<p>there's also some stuff about when the expected type gets elaborated</p>",
        "id": 420250609,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1707312183
    },
    {
        "content": "<p>It would be cool if <code>theorem</code> had some hovertext that explained this stuff. Or maybe if jump-to-def on <code>theorem</code> took you to some helpful docs.</p>",
        "id": 420251145,
        "sender_full_name": "David Renshaw",
        "timestamp": 1707312337
    },
    {
        "content": "<p>PR's welcome...</p>",
        "id": 420251353,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707312390
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243791\">@David Renshaw</span> Ah thanks, I was wondering if something like that is possible. That kind of clears it up for me.</p>\n<p>Just out of academic interest, a follow up question: it is safe to unfold (supposedly) opaque definitions like this, as it is only possible to unfold them anyway in a theorem context? In other words, it is impossible to write a def which sneakily uses result5 to (indirectly) use theorem5 to compute a value?</p>\n<p>Sorry for being so specific, I am just very confused about where the line is in lean between computability and noncomputability, and how lean enforces this. On the one hand in lean it seems to be handled watertight, and on the other hand the approach of using \"noncomputable\" and some attributes here and there feels ad-hoc to me (and hence must be leading to problems somewhere, is my intuition).</p>",
        "id": 420253244,
        "sender_full_name": "Bob Rubbens",
        "timestamp": 1707312942
    },
    {
        "content": "<p>What lean calls \"computable\" is really \"try to compile it to executable code and error otherwise\". When you put <code>noncomputable</code> (or <code>theorem</code>) on a definition you are instructing the compiler not to generate code for it, so if you ever try to call this function later from compiled code (i.e. another computable <code>def</code> or directly in <code>#eval</code>) then it will cause an error because there is no function to call</p>",
        "id": 420257890,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707314381
    },
    {
        "content": "<p>it's not really a static analysis, it's directing the actual output of the process</p>",
        "id": 420258136,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707314427
    },
    {
        "content": "<p>Huh, okay. But I can see the term that is constructed using <code>#print</code>. So I guess the code generated and the term (which in my case happens to be computable) are different things deep inside lean, then, right?</p>",
        "id": 420258296,
        "sender_full_name": "Bob Rubbens",
        "timestamp": 1707314467
    },
    {
        "content": "<p>that's right</p>",
        "id": 420258392,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707314499
    },
    {
        "content": "<p>I see, okay. It feels like such a smart system though so I can't help myself wondering what it is doing behind the scenes</p>",
        "id": 420258412,
        "sender_full_name": "Bob Rubbens",
        "timestamp": 1707314506
    },
    {
        "content": "<p>the term is what is used by the kernel and elaborator</p>",
        "id": 420258501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707314523
    },
    {
        "content": "<p>(And also then how it guarantees soundness of it all. But I guess in code generation this is not so strict)</p>",
        "id": 420258511,
        "sender_full_name": "Bob Rubbens",
        "timestamp": 1707314525
    },
    {
        "content": "<p>the generated code is sort of separate / parallel to the rest of it</p>",
        "id": 420258563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707314544
    },
    {
        "content": "<p>I believe you can also <code>#print</code> generated code, it has some magic names derived from the original</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">5</span>\n<span class=\"k\">#print</span> <span class=\"n\">foo._cstage1</span> <span class=\"c1\">-- unsafe def foo._cstage1 : Nat := 5</span>\n<span class=\"k\">#print</span> <span class=\"n\">foo._cstage2</span> <span class=\"c1\">-- unsafe def foo._cstage2 : _obj := 5</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">foo'</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">5</span>\n<span class=\"k\">#print</span> <span class=\"n\">foo'._cstage1</span> <span class=\"c1\">-- unknown constant 'foo'._cstage1'</span>\n<span class=\"k\">#print</span> <span class=\"n\">foo'._cstage2</span> <span class=\"c1\">-- unknown constant 'foo'._cstage2'</span>\n</code></pre></div>",
        "id": 420258783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707314625
    },
    {
        "content": "<p>Why is <code>theorem foo : Nat := 1</code> legal in the first place?</p>",
        "id": 420347660,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707342026
    },
    {
        "content": "<p>It's not legal in mathlib in the sense that a linter will complain.</p>",
        "id": 420348822,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707342539
    },
    {
        "content": "<p>Right, but this regularly trips up new users who aren't working in mathlib or running the linter</p>",
        "id": 420442073,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707393721
    },
    {
        "content": "<p>And it's not clear that the current behavior is wanted by anyone</p>",
        "id": 420442140,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707393732
    },
    {
        "content": "<p>Would you prefer getting an error or warning when the type in a theorem statement is of a universe that doesn't make sense in the usual case you use Lean? Not trying to be annoying, just trying to make concrete  (and curious about) what the non-intuitive part is you are talking about here.</p>",
        "id": 420443295,
        "sender_full_name": "Bob Rubbens",
        "timestamp": 1707394193
    },
    {
        "content": "<p>I think it would be reasonable and relatively easy to upgrade the defTheorem linter to a core linter so that it triggers immediately without <code>#lint</code></p>",
        "id": 420474594,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707404032
    },
    {
        "content": "<p>there are use cases for <code>def</code>s of prop type but I don't know any for <code>theorem</code>s containing data. <code>@[irreducible] def</code> or <code>opaque</code> is the alternative I would suggest for those cases</p>",
        "id": 420474983,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707404138
    },
    {
        "content": "<p>What's the use case for <code>def</code> for proofs? I believe one could exist, but I can't think of one myself</p>",
        "id": 420500294,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707411191
    },
    {
        "content": "<p>In lean 3, one answer was that the def allowed an incomplete type so that you could work out the statement by writing the proof, but that doesn't work any more in lean 4</p>",
        "id": 420500559,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707411267
    },
    {
        "content": "<p>In lean 4 it's possible to omit the type entirely with <code>def</code> and therefore have a <code>def</code> lemma state whatever the proof ends up proving. I've written a <code>transform</code> tactic based on <code>conv</code> which uses this feature:</p>\n<p><a href=\"#narrow/stream/270676-lean4/topic/Using.20Tactics.20to.20Generate.20.60.3D.60.20Theorems/near/404933569\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Using.20Tactics.20to.20Generate.20.60.3D.60.20Theorems/near/404933569</a></p>",
        "id": 420506333,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1707413037
    },
    {
        "content": "<p>I had added an error for using <code>theorem</code> with data in Lean 3:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"c1\">-- error: theorems do not get VM compiled, use 'def' or add 'noncomputable' modifier to 'a'</span>\n</code></pre></div>\n<p>I don't remember if there were any use cases for <code>noncomputable theorem</code> though. (<a href=\"https://github.com/leanprover-community/lean/pull/704\">#704</a> and <a href=\"https://github.com/leanprover-community/lean/pull/712\">#712</a>)</p>",
        "id": 420507450,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707413409
    }
]