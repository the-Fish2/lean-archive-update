[
    {
        "content": "<p>Is it possible to define bounded search / the constructive epsilon / constructive indefinite description? It probably is, then the question boils down to how? I'm probably doing something stupid :)</p>\n<p>Constructive epsilon takes mere existence of a value that fulfills a decidable predicate to a concrete value that fulfills the predicate over natural numbers. A part of this is an algorithm that performs bounded search. Bounded search starts with 0 and checks whether the predicate is fulfilled at 0 using the decidability of the predicate. If it works, we are done, otherwise we continue looking for a successively bigger natural number, until we have found a value that works.</p>\n<p>The algorithm should terminate, because by mere existence of a value that fulfills the predicate we have an upper bound for the search. It is a bit unclear to me how to express this in Lean, any help is appreciated.</p>\n<p>I'm translating from Coq (<a href=\"https://www.cs.princeton.edu/courses/archive/fall07/cos595/stdlib/html/Coq.Logic.ConstructiveEpsilon.html\">https://www.cs.princeton.edu/courses/archive/fall07/cos595/stdlib/html/Coq.Logic.ConstructiveEpsilon.html</a>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- to avoid the Prop/Type/Sort stuff i have defined a custom PropSum that takes Props is a Type.</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">PropSum</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">):</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">PropSum</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inr</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">PropSum</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">infixl</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"s2\">\" ⊞ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">PropSum</span>\n\n<span class=\"c1\">-- a predicate is decidable, when forall n it either gives a proof or proof of the negation</span>\n<span class=\"kd\">class</span> <span class=\"n\">Dec</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">):</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span> <span class=\"n\">dec</span><span class=\"o\">:</span>   <span class=\"k\">forall</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"bp\">⊞</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span> <span class=\"n\">n</span>\n\n<span class=\"c1\">-- a predicate P is ale n, if there exists an m, m&gt;n for which it Pm holds</span>\n<span class=\"c1\">-- (this is supposed to give the mere existence of an upper bound)</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">ale</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">stp</span><span class=\"o\">:</span>     <span class=\"n\">P</span>           <span class=\"n\">n</span>  <span class=\"bp\">-&gt;</span> <span class=\"n\">ale</span> <span class=\"n\">P</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nxt</span><span class=\"o\">:</span> <span class=\"n\">ale</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ale</span> <span class=\"n\">P</span> <span class=\"n\">n</span>\n\n<span class=\"c1\">-- to avoid universe stuff, define custom sigma in type, with a prop parametrized by a type</span>\n<span class=\"kd\">class</span> <span class=\"n\">MySigma</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">):</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"n\">intro</span> <span class=\"o\">::</span>\n  <span class=\"n\">fst</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n  <span class=\"n\">snd</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">fst</span>\n\n<span class=\"c1\">-- search n=0,1,2,3,4,... by deciding for each number whether P n holds,</span>\n<span class=\"c1\">-- structurally recursive over the shrinking interval described by b</span>\n<span class=\"kd\">def</span> <span class=\"n\">search</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">Dec</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ale</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">):</span> <span class=\"n\">MySigma</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h.dec</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">yes</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">yes</span> <span class=\"o\">⟩</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">no</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">search</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">stp</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nomatch</span> <span class=\"n\">no</span> <span class=\"n\">p</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">nxt</span> <span class=\"n\">ps</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ps</span><span class=\"o\">)</span>\n\n<span class=\"n\">termination_by</span> <span class=\"n\">search</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>The following error is displayed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">b</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">ale</span> <span class=\"n\">P</span> <span class=\"n\">start</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">?</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"bp\">?</span><span class=\"n\">u.3456</span>\n</code></pre></div>\n<p>It seems its not possible to use a prop as a termination?</p>",
        "id": 427526414,
        "sender_full_name": "David Richter",
        "timestamp": 1710779370
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.indefiniteDescription#doc\">docs#Classical.indefiniteDescription</a></p>",
        "id": 427527202,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710779577
    },
    {
        "content": "<p>Also your <code>PropSum</code> is (basically) <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PSum#doc\">docs#PSum</a></p>",
        "id": 427527554,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710779627
    },
    {
        "content": "<p>That's noncomputable, im looking for the actual value to eval / print it?</p>",
        "id": 427527608,
        "sender_full_name": "David Richter",
        "timestamp": 1710779642
    },
    {
        "content": "<p>Ah, then look at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.find#doc\">docs#Nat.find</a> and around</p>",
        "id": 427527756,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710779676
    },
    {
        "content": "<p><code>Nat.find</code> is exactly that search algorithm. It uses <code>Decidable</code> rather than a new <code>Prop</code>-like type, which is \"<code>Bool</code> with a proof\"</p>",
        "id": 427528135,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710779792
    },
    {
        "content": "<p>It seemed simple enough, so i expected that would already have been done, I just didnt know where to look. I'll try it, thanks :)</p>",
        "id": 427529193,
        "sender_full_name": "David Richter",
        "timestamp": 1710780114
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687543\">David Richter</span> has marked this topic as resolved.</p>",
        "id": 427568197,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710793354
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687543\">David Richter</span> has marked this topic as unresolved.</p>",
        "id": 427588696,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710802083
    },
    {
        "content": "<p>Hi, how is Nat.find computable, given it uses WellFounded.fix which is noncomputable?<br>\nIn particular i noticed that if i reproduce the source code of Nat.find like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- import Mathlib.Tactics</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">lbp</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">acc_lbp</span> <span class=\"o\">(</span><span class=\"n\">pn</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">Acc</span> <span class=\"o\">(</span><span class=\"n\">lbp</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:=</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">m</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span>   <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"n\">kn</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Acc.intro</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nomatch</span> <span class=\"n\">a</span> <span class=\"n\">_</span> <span class=\"n\">kn</span> <span class=\"n\">pn</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"n\">kn</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Acc.intro</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"k\">fun</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">_a</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">acc_lbp</span> <span class=\"n\">pn</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_right_comm</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">kn</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">wf_lbp</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">WellFounded</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">lbp</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">pn</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">H</span><span class=\"bp\">;</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">acc_lbp</span> <span class=\"n\">pn</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_add_left</span> <span class=\"n\">n</span> <span class=\"n\">a</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">find</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidablePred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">n</span> <span class=\"bp\">//</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"o\">}</span> <span class=\"o\">:=</span>\n  <span class=\"n\">WellFounded.fix</span>\n    <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">{</span> <span class=\"n\">n</span> <span class=\"bp\">//</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"o\">})</span>\n    <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">lbp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hwf</span> <span class=\"o\">:=</span> <span class=\"n\">wf_lbp</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">m</span> <span class=\"n\">IH</span> <span class=\"n\">al</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">if</span> <span class=\"n\">pm</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">m</span> <span class=\"k\">then</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">pm</span><span class=\"o\">⟩</span> <span class=\"k\">else</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">inferInstance</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">isTrue</span> <span class=\"n\">yes</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">subst</span> <span class=\"n\">yes</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">pm</span>\n        <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">isFalse</span> <span class=\"n\">no</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">al</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">Nat.lt_of_le_of_ne</span> <span class=\"n\">h</span> <span class=\"n\">no</span><span class=\"o\">)</span>\n      <span class=\"n\">IH</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">this</span><span class=\"o\">⟩</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">this</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Nat.le_of_succ_le_succ</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nomatch</span> <span class=\"o\">(</span><span class=\"n\">Nat.not_lt_zero</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">find</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span><span class=\"bp\">=</span><span class=\"mi\">10</span> <span class=\"bp\">∨</span> <span class=\"n\">n</span><span class=\"bp\">=</span><span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">⟨</span> <span class=\"mi\">100</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span> <span class=\"o\">⟩</span> <span class=\"c1\">-- 10</span>\n</code></pre></div>\n<p>then i get the following error on <code>def find</code>: <code>failed to compile definition, consider marking it as 'noncomputable' because it depends on 'WellFounded.fix', and it does not have executable code</code></p>\n<p>(EDIT: the reproduced code works, if one imports <code>import Mathlib.Tactics</code>; but i'm not sure how that makes a noncomputable function computable?)</p>\n<p>(EDIT: I suppose this is relevant: <a href=\"https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Wellfounded.20recursion.html\">https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Wellfounded.20recursion.html</a>)</p>",
        "id": 427588722,
        "sender_full_name": "David Richter",
        "timestamp": 1710802087
    },
    {
        "content": "<p>The relevant import is <code>import Std.WF</code>, which defines <code>WellFounded.fixC</code> which is a computable version of <code>WellFounded.fix</code> and uses <code>@[csimp]</code> so that <code>WellFounded.fix</code> is considered computable after that point</p>",
        "id": 427590564,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710802883
    },
    {
        "content": "<p>(really <code>WellFounded.fix</code> should never have been noncomputable in the first place)</p>",
        "id": 427590854,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710803012
    },
    {
        "content": "<p>Thanks! Very interesting! The docs of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Std/WF.html\">https://leanprover-community.github.io/mathlib4_docs/Std/WF.html</a> indeed mention exactly this problem.</p>\n<p>I also looked at the source of the workaround <a href=\"https://github.com/leanprover/std4/blob/f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc/Std/WF.lean\">https://github.com/leanprover/std4/blob/f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc/Std/WF.lean</a> but that goes over my head, so i'll just use <code>import Std.WF</code> without understanding it :)</p>",
        "id": 427591517,
        "sender_full_name": "David Richter",
        "timestamp": 1710803367
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687543\">David Richter</span> has marked this topic as resolved.</p>",
        "id": 427594451,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710805131
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Constructive.20Epsilon.20.2F.20Recursion.20over.20Prop/near/427590854\">said</a>:</p>\n<blockquote>\n<p>(really <code>WellFounded.fix</code> should never have been noncomputable in the first place)</p>\n</blockquote>\n<p>Is this something we can upstream? It would be good to get this fixed.</p>",
        "id": 427596258,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710806282
    },
    {
        "content": "<p>Hmm, I unsuccessfully tried to put it into <code>Init.WF</code>. <code>Std.WF</code> depends on the <code>termination_by</code> machinery, which depends on <code>WellFounded.fix</code>, to eventually make the computable version and that csimp lemma.</p>",
        "id": 427599059,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710808035
    },
    {
        "content": "<p>That is kind of hilarious, and feels like we're cheating.</p>",
        "id": 427604050,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710811918
    },
    {
        "content": "<p>the less cheating (but still cheating in a different way) approach is to have a <code>partial</code> definition and use <code>implemented_by</code></p>",
        "id": 427674093,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710848861
    }
]