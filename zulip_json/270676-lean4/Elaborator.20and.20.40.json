[
    {
        "content": "<p>Suppose we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"k\">match</span> <span class=\"n\">Parser.runParserCategory</span>\n    <span class=\"o\">(</span><span class=\"n\">env</span> <span class=\"o\">:=</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">MonadEnv.getEnv</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">catName</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">term</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">input</span> <span class=\"o\">:=</span> <span class=\"s2\">\"Nat.brecOn\"</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">fileName</span> <span class=\"o\">:=</span> <span class=\"s2\">\"&lt;stdin&gt;\"</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"n\">syn</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">syn</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">error</span> <span class=\"n\">error</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"n\">error</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Elab.elabTerm</span> <span class=\"n\">e</span> <span class=\"bp\">.</span><span class=\"n\">none</span>\n</code></pre></div>\n<p>The inferred type of <code>e</code> is a metavariable, but if I replace <code>Nat.brecOn</code> with <code>@Nat.brecOn</code>, the inferred type becomes the full type of <code>Nat.brecOn</code>. How can I enforce this effect during elaboration? I remember in one of the tactics this <code>@</code> effect is enforced, but I forgot which one</p>",
        "id": 433364676,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1713207684
    },
    {
        "content": "<p>According to the documentation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">  Main function for elaborating terms.</span>\n<span class=\"sd\">  It extracts the elaboration methods from the environment using the node kind.</span>\n<span class=\"sd\">  Recall that the environment has a mapping from `SyntaxNodeKind` to `TermElab` methods.</span>\n<span class=\"sd\">  It creates a fresh macro scope for executing the elaboration method.</span>\n<span class=\"sd\">  All unlogged trace messages produced by the elaboration method are logged using</span>\n<span class=\"sd\">  the position information at `stx`. If the elaboration method throws an `Exception.error` and `errToSorry == true`,</span>\n<span class=\"sd\">  the error is logged and a synthetic sorry expression is returned.</span>\n<span class=\"sd\">  If the elaboration throws `Exception.postpone` and `catchExPostpone == true`,</span>\n<span class=\"sd\">  a new synthetic metavariable of kind `SyntheticMVarKind.postponed` is created, registered,</span>\n<span class=\"sd\">  and returned.</span>\n<span class=\"sd\">  The option `catchExPostpone == false` is used to implement `resumeElabTerm`</span>\n<span class=\"sd\">  to prevent the creation of another synthetic metavariable when resuming the elaboration.</span>\n\n<span class=\"sd\">  If `implicitLambda == false`, then disable implicit lambdas feature for the given syntax, but not for its subterms.</span>\n<span class=\"sd\">  We use this flag to implement, for example, the `@` modifier. If `Context.implicitLambda == false`, then this parameter has no effect.</span>\n<span class=\"sd\">  -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"n\">stx</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">catchExPostpone</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">implicitLambda</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TermElabM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span>\n  <span class=\"n\">withRef</span> <span class=\"n\">stx</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">elabTermAux</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"n\">catchExPostpone</span> <span class=\"n\">implicitLambda</span> <span class=\"n\">stx</span>\n</code></pre></div>\n<p>I tried to pass in <code>implicitLambda := true/false</code> but the result is the same. The elaboration generates a metavariable when there is no <code>@</code>.</p>",
        "id": 433434654,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1713238356
    },
    {
        "content": "<p><code>implicitLambda</code> is for <code>@fun ...</code> vs <code>fun ...</code></p>\n<p>Do you know about <code>Elab.elabAppArgs</code>?</p>",
        "id": 433435585,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713238885
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Elaborator.20and.20.40/near/433435585\">said</a>:</p>\n<blockquote>\n<p><code>implicitLambda</code> is for <code>@fun ...</code> vs <code>fun ...</code></p>\n<p>Do you know about <code>Elab.elabAppArgs</code>?</p>\n</blockquote>\n<p>yes, but I don't know how to use it in this case</p>",
        "id": 433435628,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1713238905
    },
    {
        "content": "<p>If I run the elaboration monad in <code>withoutHeedElabAsElim</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">  Execute `x` without heeding the `elab_as_elim` attribute. Useful when there is</span>\n<span class=\"sd\">  no expected type (so `elabAppArgs` would fail), but expect that the user wants</span>\n<span class=\"sd\">  to use such constants.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">withoutHeedElabAsElim</span> <span class=\"o\">[</span><span class=\"n\">MonadFunctorT</span> <span class=\"n\">TermElabM</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">monadMap</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">TermElabM</span><span class=\"o\">)</span> <span class=\"n\">withoutHeedElabAsElimImp</span>\n</code></pre></div>\n<p>The type of the elaborated symbol becomes</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Nat.below</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"bp\">?</span><span class=\"n\">m.67</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">?</span><span class=\"n\">m.67</span> <span class=\"n\">t</span>\n</code></pre></div>\n<p>which is almost correct except for that the motive argument is missing. The documentation of this function says without expected type (which is my use caes),<code>elabAppArgs</code> would fail, but I still can't replicate the behaviour of <code>@Nat.brecOn</code></p>",
        "id": 433436922,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1713239650
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Elaborator.20and.20.40/near/433435585\">said</a>:</p>\n<blockquote>\n<p><code>implicitLambda</code> is for <code>@fun ...</code> vs <code>fun ...</code></p>\n<p>Do you know about <code>Elab.elabAppArgs</code>?</p>\n</blockquote>\n<p>I don't think I can use this function since I in this use case I don't have the arguments to <code>Nat.brecOn</code> when I'm calling it. I just want to determine the type of this expression in context</p>",
        "id": 433565358,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1713285658
    },
    {
        "content": "<p>This is a MWE. I read in <code>Elab/Term.lean</code> that the automatic insertion of metavariables is related to <code>autoBoundImplicit</code> but disabling it in the elaboration context did not do anything:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">parseTerm</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">):</span> <span class=\"n\">CoreM</span> <span class=\"n\">Syntax</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"n\">Parser.runParserCategory</span>\n    <span class=\"o\">(</span><span class=\"n\">env</span> <span class=\"o\">:=</span> <span class=\"bp\">←</span> <span class=\"n\">MonadEnv.getEnv</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">catName</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">term</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">input</span> <span class=\"o\">:=</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">fileName</span> <span class=\"o\">:=</span> <span class=\"s2\">\"&lt;stdin&gt;\"</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">s</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">error</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"n\">e</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">termElabM</span> <span class=\"o\">:</span> <span class=\"n\">Elab.TermElabM</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span> <span class=\"s2\">\"Nat.brecOn\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">expr</span>  <span class=\"bp\">←</span> <span class=\"n\">Elab.Term.elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">parseTerm</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">none</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">type</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.inferType</span> <span class=\"n\">expr</span>\n  <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{← Meta.ppExpr expr}\"</span>\n  <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"  : {← Meta.ppExpr type}\"</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">unassigned</span> <span class=\"bp\">←</span> <span class=\"n\">Elab.Term.collectUnassignedMVars</span> <span class=\"n\">type</span>\n  <span class=\"n\">for</span> <span class=\"n\">mvarId</span> <span class=\"k\">in</span> <span class=\"n\">unassigned</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">mvarType</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.inferType</span> <span class=\"n\">mvarId</span>\n    <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{← Meta.ppExpr mvarId}: {← Meta.ppExpr mvarType}\"</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">main</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">options</span><span class=\"o\">:</span> <span class=\"n\">Options</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span>\n  <span class=\"k\">let</span> <span class=\"n\">options</span> <span class=\"o\">:=</span> <span class=\"n\">options.setNat</span> <span class=\"bp\">`</span><span class=\"n\">pp.deepTerms.threshold</span> <span class=\"mi\">100</span>\n  <span class=\"k\">let</span> <span class=\"n\">options</span> <span class=\"o\">:=</span> <span class=\"n\">options.setNat</span> <span class=\"bp\">`</span><span class=\"n\">pp.proofs.threshold</span> <span class=\"mi\">100</span>\n  <span class=\"k\">let</span> <span class=\"n\">env</span><span class=\"o\">:</span> <span class=\"n\">Environment</span> <span class=\"bp\">←</span> <span class=\"n\">importModules</span>\n    <span class=\"o\">(</span><span class=\"n\">imports</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"n\">Init</span><span class=\"o\">])</span>\n    <span class=\"o\">(</span><span class=\"n\">opts</span> <span class=\"o\">:=</span> <span class=\"o\">{})</span>\n    <span class=\"o\">(</span><span class=\"n\">trustLevel</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">termElabContext</span><span class=\"o\">:</span> <span class=\"n\">Elab.Term.Context</span> <span class=\"o\">:=</span>  <span class=\"o\">{</span>\n    <span class=\"n\">heedElabAsElim</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">,</span>\n    <span class=\"n\">declName</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">sandbox</span><span class=\"o\">,</span>\n    <span class=\"n\">errToSorry</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n  <span class=\"o\">}</span>\n  <span class=\"k\">let</span> <span class=\"n\">coreM</span> <span class=\"o\">:=</span> <span class=\"n\">Meta.MetaM.run'</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Elab.Term.TermElabM.run'</span> <span class=\"o\">(</span><span class=\"n\">ctx</span> <span class=\"o\">:=</span> <span class=\"n\">termElabContext</span><span class=\"o\">)</span> <span class=\"n\">termElabM</span>\n  <span class=\"k\">let</span> <span class=\"n\">coreContext</span><span class=\"o\">:</span> <span class=\"n\">Lean.Core.Context</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"n\">options</span><span class=\"o\">,</span>\n    <span class=\"n\">currNamespace</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">Example</span>\n    <span class=\"n\">openDecls</span> <span class=\"o\">:=</span> <span class=\"o\">[],</span>     <span class=\"c1\">-- No 'open' directives needed</span>\n    <span class=\"n\">fileName</span> <span class=\"o\">:=</span> <span class=\"s2\">\"&lt;stdin&gt;\"</span><span class=\"o\">,</span>\n    <span class=\"n\">fileMap</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">source</span> <span class=\"o\">:=</span> <span class=\"s2\">\"\"</span><span class=\"o\">,</span> <span class=\"n\">positions</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n  <span class=\"o\">}</span>\n  <span class=\"k\">match</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">coreM.run'</span> <span class=\"n\">coreContext</span> <span class=\"o\">{</span> <span class=\"n\">env</span> <span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">toBaseIO</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">error</span> <span class=\"n\">exception</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{← exception.toMessageData.toString}\"</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"o\">()</span>\n</code></pre></div>",
        "id": 433614650,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1713304912
    },
    {
        "content": "<p>I guess you are not in a situation where you can simply prepend <code>@</code> to whatever your input is?</p>",
        "id": 433617975,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1713306879
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Elaborator.20and.20.40/near/433617975\">said</a>:</p>\n<blockquote>\n<p>I guess you are not in a situation where you can simply prepend <code>@</code> to whatever your input is?</p>\n</blockquote>\n<p>The input is user supplied so I don't have control over it</p>",
        "id": 433617996,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1713306896
    },
    {
        "content": "<p>What kinds of inputs are allowed? If the input is <code>someConstant</code>, you could prepend <code>@</code>. Is <code>someConstant arg</code> allowed? In that case, should Lean also not put in any metavariables in the inferred type? For instance if <code>someConstant (a : Nat) {b : Nat} (c : Nat) : a = b := sorry</code>, do you expect <code>someConstant arg : ∀ {b : Nat}, Nat → 2 = b</code> (which you'd normally get from <code>@someConstant arg</code>?</p>",
        "id": 433618745,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1713307293
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/270676-lean4/topic/Elaborator.20and.20.40/near/433618745\">said</a>:</p>\n<blockquote>\n<p>What kinds of inputs are allowed? If the input is <code>someConstant</code>, you could prepend <code>@</code>. Is <code>someConstant arg</code> allowed? In that case, should Lean also not put in any metavariables in the inferred type? For instance if <code>someConstant (a : Nat) {b : Nat} (c : Nat) : a = b := sorry</code>, do you expect <code>someConstant arg : ∀ {b : Nat}, Nat → 2 = b</code> (which you'd normallly get from <code>@someConstant arg</code>?</p>\n</blockquote>\n<p>Yes. The goal here is to not generate any metavariables and infer the type signature of the input</p>",
        "id": 433618898,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1713307343
    },
    {
        "content": "<p>There might be an option in the elaborator that achieves this exact behavior, but I'm not sure what it is. How about traversing the <code>Term</code>'s syntax and prepending the <code>@</code> to the head function symbol that way?</p>",
        "id": 433619328,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1713307579
    },
    {
        "content": "<p>To be sure, this would break on any custom syntax like infix operators.</p>",
        "id": 433619383,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1713307624
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/stream/270676-lean4/topic/Elaborator.20and.20.40/near/433364676\">said</a>:</p>\n<blockquote>\n<p>Suppose we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"k\">match</span> <span class=\"n\">Parser.runParserCategory</span>\n    <span class=\"o\">(</span><span class=\"n\">env</span> <span class=\"o\">:=</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">MonadEnv.getEnv</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">catName</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">term</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">input</span> <span class=\"o\">:=</span> <span class=\"s2\">\"Nat.brecOn\"</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">fileName</span> <span class=\"o\">:=</span> <span class=\"s2\">\"&lt;stdin&gt;\"</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"n\">syn</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">syn</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">error</span> <span class=\"n\">error</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"n\">error</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Elab.elabTerm</span> <span class=\"n\">e</span> <span class=\"bp\">.</span><span class=\"n\">none</span>\n</code></pre></div>\n<p>The inferred type of <code>e</code> is a metavariable, but if I replace <code>Nat.brecOn</code> with <code>@Nat.brecOn</code>, the inferred type becomes the full type of <code>Nat.brecOn</code>. How can I enforce this effect during elaboration? I remember in one of the tactics this <code>@</code> effect is enforced, but I forgot which one</p>\n</blockquote>\n<p>As a side note, if all you want is to a real type instead of a metavariable, you can also use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.instantiateMVars#doc\">docs#Lean.instantiateMVars</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Qq.instantiateMVarsQ#doc\">docs#Qq.instantiateMVarsQ</a> as needed.</p>",
        "id": 433732890,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713353456
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"359992\">Robert Maxton</span> <a href=\"#narrow/stream/270676-lean4/topic/Elaborator.20and.20.40/near/433732890\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"599027\">Leni Aniva</span> <a href=\"#narrow/stream/270676-lean4/topic/Elaborator.20and.20.40/near/433364676\">said</a>:</p>\n<blockquote>\n<p>Suppose we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"k\">match</span> <span class=\"n\">Parser.runParserCategory</span>\n    <span class=\"o\">(</span><span class=\"n\">env</span> <span class=\"o\">:=</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">MonadEnv.getEnv</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">catName</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">term</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">input</span> <span class=\"o\">:=</span> <span class=\"s2\">\"Nat.brecOn\"</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">fileName</span> <span class=\"o\">:=</span> <span class=\"s2\">\"&lt;stdin&gt;\"</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"n\">syn</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">syn</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">error</span> <span class=\"n\">error</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"n\">error</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">Elab.elabTerm</span> <span class=\"n\">e</span> <span class=\"bp\">.</span><span class=\"n\">none</span>\n</code></pre></div>\n<p>The inferred type of <code>e</code> is a metavariable, but if I replace <code>Nat.brecOn</code> with <code>@Nat.brecOn</code>, the inferred type becomes the full type of <code>Nat.brecOn</code>. How can I enforce this effect during elaboration? I remember in one of the tactics this <code>@</code> effect is enforced, but I forgot which one</p>\n</blockquote>\n<p>As a side note, if all you want is to a real type instead of a metavariable, you can also use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.instantiateMVars#doc\">docs#Lean.instantiateMVars</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Qq.instantiateMVarsQ#doc\">docs#Qq.instantiateMVarsQ</a> as needed.</p>\n</blockquote>\n<p>I tried calling <code>instantiateMVars</code> on the mvar produced by <code>elabTerm</code> but it had no effect</p>",
        "id": 433846051,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1713377262
    }
]