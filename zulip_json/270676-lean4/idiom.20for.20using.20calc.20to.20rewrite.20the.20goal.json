[
    {
        "content": "<p>I am a big fan of <code>calc</code> proofs. If the goal is itself an equality (or other relation), I just just start with <code>calc</code>.</p>\n<p>But what if I want to rewrite the goal <code>p1</code> with <code>calc p1 =… ; _ = p2 := …</code> to get goal <code>p2</code>? Like in this example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">):</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span>\n    <span class=\"n\">Eq.mpr</span> <span class=\"bp\">&lt;|</span>\n      <span class=\"k\">calc</span>\n        <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n        <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Nat.one_mul</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n        <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Nat.mul_one</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n        <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">congrArg</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">Nat.zero_add</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>Is there an even nicer idiom than <code>apply Eq.mpr |&gt; calc …</code> that I can use here?</p>",
        "id": 424262916,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1709306247
    },
    {
        "content": "<p>I sometimes use <code>have := calc ...</code> and then you can do <code>rw [this]</code> afterwards. But that's perhaps just as cumbersome.</p>",
        "id": 424267169,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709306967
    },
    {
        "content": "<p>Would this be a job for <code>convert_to</code> + <code>calc</code>-block afterwards?</p>",
        "id": 424268963,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1709307323
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">convert_to</span> <span class=\"n\">h</span>\n<span class=\"k\">calc</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 424269023,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1709307335
    },
    {
        "content": "<p>Context: I am prototyping a tactic that will take a proof goal as produced by <code>simp</code> or <code>rw</code> and turn it into a small-step <code>calc</code> block:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">calcify</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.mul_one</span><span class=\"o\">,</span> <span class=\"n\">Nat.zero_add</span><span class=\"o\">]</span>\n<span class=\"sd\">/--</span>\n<span class=\"sd\">info: Try this: calc</span>\n<span class=\"sd\">  0 + n</span>\n<span class=\"sd\">  _ = n := (Nat.zero_add n)</span>\n<span class=\"sd\">  _ = 0 + n := (Eq.symm (Nat.zero_add n))</span>\n<span class=\"sd\">  _ = 0 + n * 1 := congrArg (fun _a =&gt; 0 + _a) (Eq.symm (Nat.mul_one n))</span>\n<span class=\"sd\">-/</span>\n</code></pre></div>",
        "id": 424269147,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1709307359
    },
    {
        "content": "<p>hmm, no <code>convert_to</code> in Core :-)</p>\n<p>Maybe the idiom that should work is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">calc</span> <span class=\"bp\">…</span>\n</code></pre></div>\n<p>Already I can write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">):</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">calc</span>\n    <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Nat.one_mul</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Nat.mul_one</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">congrArg</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">Nat.zero_add</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>but no reason not to lift <code>calc</code> to a conv tactic like other tactics?</p>",
        "id": 424269608,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1709307472
    },
    {
        "content": "<p>That seems a good idea, yes</p>",
        "id": 424269718,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1709307500
    },
    {
        "content": "<p>Issue at <a href=\"https://github.com/leanprover/lean4/issues/3557\">https://github.com/leanprover/lean4/issues/3557</a></p>",
        "id": 424271735,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1709308028
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/idiom.20for.20using.20calc.20to.20rewrite.20the.20goal/near/424269147\">said</a>:</p>\n<blockquote>\n<p>Context: I am prototyping a tactic that will take a proof goal as produced by <code>simp</code> or <code>rw</code> and turn it into a small-step <code>calc</code> block:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">calcify</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.mul_one</span><span class=\"o\">,</span> <span class=\"n\">Nat.zero_add</span><span class=\"o\">]</span>\n<span class=\"sd\">/--</span>\n<span class=\"sd\">info: Try this: calc</span>\n<span class=\"sd\">  0 + n</span>\n<span class=\"sd\">  _ = n := (Nat.zero_add n)</span>\n<span class=\"sd\">  _ = 0 + n := (Eq.symm (Nat.zero_add n))</span>\n<span class=\"sd\">  _ = 0 + n * 1 := congrArg (fun _a =&gt; 0 + _a) (Eq.symm (Nat.mul_one n))</span>\n<span class=\"sd\">-/</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>oh, that looks really neat! would that live in core or somewhere outside (e.g. std)?</p>",
        "id": 424272318,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1709308182
    },
    {
        "content": "<p>Probably in my separate repo, labeled “this is an experiment”, for a while :-D</p>",
        "id": 424272507,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1709308214
    },
    {
        "content": "<p>hehe, fair enough</p>",
        "id": 424272608,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1709308241
    },
    {
        "content": "<p>Although I hope it’ll be easier to use “dev dependencies”, i.e. commands that you don’t plan to commit (so they don’t need to be a dependency) and just want to add to your toolkit. then separate repo doesn’t sound too bad.</p>",
        "id": 424272664,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1709308254
    },
    {
        "content": "<p>Of course, if it turns out to be reliable and useful, it can be upstreamed. But it’s not on any roadmap as of now.</p>",
        "id": 424272766,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1709308271
    },
    {
        "content": "<p>I'll be looking out for that</p>",
        "id": 424272854,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1709308289
    },
    {
        "content": "<p>just curious, in the context of these experiments: do you think it might make sense to keep the rewrite list as passed to <code>rw</code> or <code>simp</code> in a single list and still have the declarative list of rewrites in <code>calc</code>? Something like (not talking about the concrete syntax here):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">calcify</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.mul_one</span><span class=\"o\">,</span> <span class=\"n\">Nat.zero_add</span><span class=\"o\">]</span>\n<span class=\"sd\">/--</span>\n<span class=\"sd\">info: Try this: calc'</span>\n<span class=\"sd\">  0 + n</span>\n<span class=\"sd\">  _ = n</span>\n<span class=\"sd\">  _ = 0 + n</span>\n<span class=\"sd\">  _ = 0 + n * 1 := by rw [Nat.mul_one, Nat.zero_add]</span>\n<span class=\"sd\">-/</span>\n</code></pre></div>",
        "id": 424274312,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1709308619
    },
    {
        "content": "<p>While I am at it: What are my options to eliminate the <code>congrArg (fun …)</code> wrappers around these equality proofs? </p>\n<p>We have the <code>▸</code> macro which does most of that works, and I can write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">((</span><span class=\"n\">Nat.one_mul</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">▸</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>instead, but that’s  a mouthful.  Is there some other syntax?</p>",
        "id": 424274341,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1709308625
    },
    {
        "content": "<p>context for the question above: we prototyped something along those lines for <a href=\"https://dl.acm.org/doi/10.1145/3632900\">this paper</a> for something a bit stronger than <code>simp</code> and it would be nice to do something much more full-fledged from it, where the declarative calc proof is easier to read and maintain, but can still be reconstructed with automation</p>",
        "id": 424275266,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1709308811
    },
    {
        "content": "<p>Hmm, not sure. One good thing about <code>calc</code> proofs is that each step has its own proof, so that they break individually when you refactor.</p>\n<p>If the goal is just to explain the simp, but keeping the simp, then something inspired like from <code>says</code> might work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.mul_one</span><span class=\"o\">,</span> <span class=\"n\">Nat.zero_add</span><span class=\"o\">]</span> <span class=\"n\">performs</span>\n   <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>Or, turning it around, roughly your syntax. Ok, that might be useful indeed.</p>\n<p>At this point, I wonder, is it useful to have this in the code, or would it suffice to be able to point at the proof and see it in the info view or so.</p>",
        "id": 424275857,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1709308967
    },
    {
        "content": "<p>is your primary goal readibility or performance?</p>",
        "id": 424276103,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1709309033
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/idiom.20for.20using.20calc.20to.20rewrite.20the.20goal/near/424274341\">said</a>:</p>\n<blockquote>\n<p>While I am at it: What are my options to eliminate the <code>congrArg (fun …)</code> wrappers around these equality proofs? </p>\n<p>We have the <code>▸</code> macro which does most of that works, and I can write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">((</span><span class=\"n\">Nat.one_mul</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">▸</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>instead, but that’s  a mouthful.  Is there some other syntax?</p>\n</blockquote>\n<p>for readibility I guess you could also just use the individual <code>rw</code> step here, no?</p>",
        "id": 424276305,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1709309077
    },
    {
        "content": "<p>Experimentation :-D</p>\n<p>And next explanation, mostly for people wanting to learn what <code>simp</code> does.</p>",
        "id": 424276319,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1709309080
    },
    {
        "content": "<p>Yes, <code>rw</code> or <code>simp only</code> are also options. The tactic should probably check if it works and fall back to the proof term if it doesn’t. Another variant could be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>          <span class=\"k\">calc</span>\n            <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n            <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">congr</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">Nat.one_mul</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n            <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">congr</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">Nat.mul_one</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n            <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">congr</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">Nat.zero_add</span> <span class=\"n\">n</span><span class=\"o\">))</span><span class=\"bp\">;</span>\n</code></pre></div>\n<p>(<code>rw</code> might fail once I do stuff underneath binders; not supported yet, but might come. Maybe <code>simp_rw only</code> is better.)</p>",
        "id": 424276449,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1709309117
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/idiom.20for.20using.20calc.20to.20rewrite.20the.20goal/near/424275857\">said</a>:</p>\n<blockquote>\n<p>Hmm, not sure. One good thing about <code>calc</code> proofs is that each step has its own proof, so that they break individually when you refactor.</p>\n<p>If the goal is just to explain the simp, but keeping the simp, then something inspired like from <code>says</code> might work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.mul_one</span><span class=\"o\">,</span> <span class=\"n\">Nat.zero_add</span><span class=\"o\">]</span> <span class=\"n\">performs</span>\n   <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>Or, turning it around, roughly your syntax. Ok, that might be useful indeed.</p>\n<p>At this point, I wonder, is it useful to have this in the code, or would it suffice to be able to point at the proof and see it in the info view or so.</p>\n</blockquote>\n<p>right, I think with <code>rw</code> that doesn't work as easily, but if it's <code>simp</code> then that would still be the case, i.e. if the same <code>simp</code> set is used for every individual proof in <code>calc</code>then in a refactor you would still have the individual step break the same way</p>",
        "id": 424277014,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1709309257
    },
    {
        "content": "<p>i.e. thinking of the <code>performs</code> as some sort of <code>&lt;;&gt;</code>instead</p>",
        "id": 424277289,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1709309322
    },
    {
        "content": "<p>I put my prototype on <a href=\"https://github.com/nomeata/lean-calcify\">https://github.com/nomeata/lean-calcify</a></p>",
        "id": 424284787,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1709311241
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/idiom.20for.20using.20calc.20to.20rewrite.20the.20goal/near/424269608\">said</a>:</p>\n<blockquote>\n<p>hmm, no <code>convert_to</code> in Core :-)</p>\n</blockquote>\n<p>Maybe we should fix that <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span> I think it has no prerequisites; the main one that was missing originally was <code>congr</code> but this has since moved to core.</p>",
        "id": 424369230,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709359550
    },
    {
        "content": "<p>Yes, I agree <code>convert</code> should be moved. It is super useful for everyone.</p>",
        "id": 424404750,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1709379740
    },
    {
        "content": "<p>If someone would like to make the PR and ping me I can merge it. If you know how to do the <code>@[builtin_tactic]</code> dance, great, if you don't, just note that you haven't done that in the PR description.</p>",
        "id": 424404797,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1709379798
    },
    {
        "content": "<p>PR for <code>conv =&gt; calc</code> at <a href=\"https://github.com/leanprover/lean4/pull/3659\">https://github.com/leanprover/lean4/pull/3659</a></p>",
        "id": 426152816,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1710257378
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> looks good. CI seems to have got stuck. Can you push an empty commit or similar?</p>",
        "id": 426230506,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710286773
    },
    {
        "content": "<p>I have seen CI getting stuck when I create a PR with <code>gh pr create</code> and add a label at that time.</p>",
        "id": 426285860,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1710319778
    }
]