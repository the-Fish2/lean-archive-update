[
    {
        "content": "<p>Am I correct that the compiler doesn't reuse constructors if the allocation is for a different type?<br>\nhere's an experiment on <code>v4.5.0-rc1</code> with different list types:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">L1</span> <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">L1</span> <span class=\"bp\">→</span> <span class=\"n\">L1</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">L2</span> <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">L2</span> <span class=\"bp\">→</span> <span class=\"n\">L2</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">List.toL1</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">L1</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">nil</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"n\">xs.toL1</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.compiler.ir.result</span> <span class=\"n\">true</span>\n<span class=\"kd\">def</span> <span class=\"n\">map1</span> <span class=\"o\">:</span> <span class=\"n\">L1</span> <span class=\"bp\">→</span> <span class=\"n\">L1</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">go1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">y</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">go1</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">xs</span>\n  <span class=\"n\">go1</span> <span class=\"bp\">.</span><span class=\"n\">nil</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">map2</span> <span class=\"o\">:</span> <span class=\"n\">L1</span> <span class=\"bp\">→</span> <span class=\"n\">L2</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">go2</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">y</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">go2</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">xs</span>\n  <span class=\"n\">go2</span> <span class=\"bp\">.</span><span class=\"n\">nil</span>\n</code></pre></div>\n<p>you can see that the second one does not have a branch that reuses the constructor.</p>\n<p>This is in the context of trying to make an FBIP <code>RBNode</code> traversal as in the Perceus paper; I found a hack to make it work without allocating, but preferably it would reuse constructors between the tree and the zipper.</p>\n<p>if this is a desired feature, could anyone give a pointer towards how to get started implementing it?</p>",
        "id": 416949428,
        "sender_full_name": "Scott Kovach",
        "timestamp": 1705721413
    },
    {
        "content": "<p>The current implementation does not do this AFAIK. There are papers that explain how to do this and expand further on the current FBIP implementation by other groups.</p>\n<p>That said the code generator/optimizer is currently not really open to feature or bug fixes unless really necessary, at least that was the policy so far. There is a bigger rewrite that will bring lots of improvements and bug fixes lined up in the future though.</p>",
        "id": 416976594,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1705744199
    },
    {
        "content": "<p>Scott and I spent some time poking around the compiler and we found where the restriction occurs: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/IR/ResetReuse.lean#L28\">https://github.com/leanprover/lean4/blob/master/src/Lean/Compiler/IR/ResetReuse.lean#L28</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">mayReuse</span> <span class=\"o\">(</span><span class=\"n\">c₁</span> <span class=\"n\">c₂</span> <span class=\"o\">:</span> <span class=\"n\">CtorInfo</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"n\">c₁.size</span> <span class=\"bp\">==</span> <span class=\"n\">c₂.size</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">c₁.usize</span> <span class=\"bp\">==</span> <span class=\"n\">c₂.usize</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">c₁.ssize</span> <span class=\"bp\">==</span> <span class=\"n\">c₂.ssize</span> <span class=\"bp\">&amp;&amp;</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> The following condition is a heuristic.</span>\n<span class=\"cm\">     We don't want to reuse cells from different types even when they are compatible</span>\n<span class=\"cm\">     because it produces counterintuitive behavior. -/</span>\n  <span class=\"n\">c₁.name.getPrefix</span> <span class=\"bp\">==</span> <span class=\"n\">c₂.name.getPrefix</span>\n</code></pre></div>\n<p>My understanding of the way reset/reuse insertion works is that</p>\n<ol>\n<li>It looks for objects that are cased on.</li>\n<li>Then it looks for the first constructor in each case arm that satisfies mayReuse, and this constructor is the one that can try to reuse the cased-on object. There are some considerations for variable liveness here too.</li>\n</ol>\n<p>Except for the liveness computations, it's making a local decision about whether a given constructor is an ok candidate. Likely, if code is doing case analysis on a constructor, and a constructor of the same type is in a case arm, and it's no longer alive from this point onward, then that constructor is the one that can be reused, if any can be reused at all. And the reset/reuse insertion can only choose <em>one</em> candidate.</p>",
        "id": 417048259,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705806241
    },
    {
        "content": "<p>I guess the “counterintuitive behavor” claim was refuted in this thread, where some intuitively assumed it would be re-used, and even have a use-case for it. So should could this just be dropped?<br>\nOr is there other surprising behavior than maybe “reused when not expected”?</p>",
        "id": 417084956,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705842112
    },
    {
        "content": "<p>I think one thing to be considered here is that minimal layout changes in a type can have drastic performance differences this way which would be a little counter intuitive to me without knowing about this precise behavior.</p>",
        "id": 417085128,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1705842213
    }
]