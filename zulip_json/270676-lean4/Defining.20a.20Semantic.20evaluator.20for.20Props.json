[
    {
        "content": "<p>While learning logic, I find the two definitions of consequence quite interesting:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Syntactic</span> <span class=\"n\">consequence</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊢</span> <span class=\"n\">φ</span> <span class=\"n\">says</span><span class=\"o\">:</span> <span class=\"n\">sentence</span> <span class=\"n\">φ</span> <span class=\"n\">is</span> <span class=\"n\">provable</span> <span class=\"k\">from</span> <span class=\"n\">the</span> <span class=\"n\">set</span> <span class=\"n\">of</span> <span class=\"n\">assumptions</span> <span class=\"bp\">Γ.</span>\n\n<span class=\"n\">Semantic</span> <span class=\"n\">consequence</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⊨</span> <span class=\"n\">φ</span> <span class=\"n\">says</span><span class=\"o\">:</span> <span class=\"n\">sentence</span> <span class=\"n\">φ</span> <span class=\"n\">is</span> <span class=\"n\">true</span> <span class=\"k\">in</span> <span class=\"n\">all</span> <span class=\"n\">models</span> <span class=\"n\">of</span> <span class=\"bp\">Γ.</span>\n</code></pre></div>\n<p>The <code>Syntactic consequence</code> is the natural way of proving theorems in lean, by manipulating assumptions. In this sense, I am interested in creating a <code>Semantic consequence</code> evaluation for some Prop in Lean. This function should try to valorate the atomic props in the context (Values that make all hypothesis true) and then derive true for the consequence in all these.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">semantic</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"k\">then</span> <span class=\"n\">true</span> <span class=\"k\">else</span> <span class=\"n\">false</span>\n</code></pre></div>\n<p>In this first implementation I am stuck with the error</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>failed to synthesize instance\n  Decidable α\n</code></pre></div>\n<p>Any suggestions?</p>",
        "id": 428332055,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1711114856
    },
    {
        "content": "<p>Reorder your arguments, you're asking for a property of \\a before you define \\a</p>",
        "id": 428339427,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1711117081
    },
    {
        "content": "<p>If you look in the infoview, you'll probably see there's two \\a's</p>",
        "id": 428339538,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1711117111
    },
    {
        "content": "<p>Given the fix, I wish it would prove statements like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">semantic</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"k\">then</span> <span class=\"n\">true</span> <span class=\"k\">else</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"k\">#eval</span> <span class=\"n\">semantic</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>In the sense that, choose either P is true or P is false, also for Q, the OR can be satisfied. But I am getting the same typeclass problem:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>failed to synthesize instance\n  Decidable (P ∨ Q)\n</code></pre></div>",
        "id": 428348249,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1711119320
    },
    {
        "content": "<p>That's because you are not providing <code>Decidable</code> instances for the propositions <code>P</code> an <code>Q</code> in your example.</p>",
        "id": 428348570,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1711119400
    },
    {
        "content": "<p>I might me wanting too much. How can I express the search for all possible values for P and Q and then find if some is proved?</p>",
        "id": 428349649,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1711119689
    },
    {
        "content": "<p>I don't really understand what you want to do here? your <code>semantic</code> function says \"I want a decidable property\" Deciding an or is only possible if the properties it is made of are decidable.</p>\n<p>Your example is basically telling Lean \"I have two properties P and Q that I know absolutely nothing about, figure out whether P or Q is decidable\" and of course it cannot do that, after all for all Lean knows both might be undecidable. If you provided it with this information like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">Q</span><span class=\"o\">]</span>\n<span class=\"k\">#check</span> <span class=\"n\">semantic</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It will happily do that. You can however still not evaluate this code because again <code>P</code> and <code>Q</code> are completely opaque propositions that we know nothing about.</p>",
        "id": 428350743,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1711119991
    },
    {
        "content": "<p>A search for \"all possible values of P and Q\" is not possible since there are infinitely many possible propositions out there. What you can do is use <code>Bool</code> instead of <code>Prop</code> and start working with either manual case bashing or LeanSAT: <a href=\"https://github.com/leanprover/leansat\">https://github.com/leanprover/leansat</a> to figure out whether your formula is satisfiable or not</p>",
        "id": 428351116,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1711120103
    },
    {
        "content": "<p>Interesting. Can I define P and Q to be either False or True but not a composite expression? This way I could try to evaluate them using excluded middle (maybe). This semantic argument is basically \"build the truth table for the hypothesis, filter the ones that make all hypothesis true. Then check if all them make the consequence true\" Hypothesis in this case is P, Q</p>",
        "id": 428351943,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1711120331
    },
    {
        "content": "<p>Are you looking for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Bool#doc\">docs#Bool</a> ?</p>",
        "id": 428353318,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711120747
    },
    {
        "content": "<p>Some cases of what I was hoping to achieve:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">semantic</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">\\</span><span class=\"n\">or</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">true</span>\n<span class=\"n\">semantic</span> <span class=\"o\">(</span><span class=\"bp\">\\</span><span class=\"n\">notP</span> <span class=\"bp\">\\</span><span class=\"n\">and</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">false</span>\n<span class=\"n\">semantic</span> <span class=\"o\">(</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">\\</span><span class=\"n\">r</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">\\</span><span class=\"n\">and</span> <span class=\"n\">P</span> <span class=\"bp\">\\</span><span class=\"n\">and</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">true</span>\n<span class=\"n\">semantic</span> <span class=\"o\">(</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">\\</span><span class=\"n\">r</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">\\</span><span class=\"n\">and</span> <span class=\"bp\">\\</span><span class=\"n\">notQ</span> <span class=\"bp\">\\</span><span class=\"n\">and</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">true</span>\n</code></pre></div>",
        "id": 428362812,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1711123467
    },
    {
        "content": "<p>It <em>sounds</em> like you want a function that returns whether a boolean formula is satisfiable</p>",
        "id": 428363896,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1711123811
    },
    {
        "content": "<p>Not sure why</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">semantic</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">\\</span><span class=\"n\">or</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">true</span>\n</code></pre></div>\n<p>would be obviously true. Is there a typo here?</p>",
        "id": 428365968,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1711124412
    },
    {
        "content": "<p>Yes, satisfiable. It means the expression is not a contradiction</p>",
        "id": 428370701,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1711125806
    },
    {
        "content": "<p>Thinking about it, I might need some metaprogramming, to handle the Prop type, parse it, then identify all free variables, then pick values for them, then map the operations to boolean ones (\\and to &amp;&amp;) and return true iff some satisfiable was found. Does this sound promising?</p>",
        "id": 428371474,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1711126038
    },
    {
        "content": "<p>Do you know about the two projects called Leansat?</p>",
        "id": 428374603,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711127034
    },
    {
        "content": "<p>I didn't know about it! I'll take a look now, thanks <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 429090549,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1711208246
    }
]