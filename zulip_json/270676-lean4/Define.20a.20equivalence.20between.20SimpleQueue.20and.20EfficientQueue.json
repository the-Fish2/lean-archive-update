[
    {
        "content": "<p>Following the <a href=\"https://browncs1951x.github.io/\">CS 1951x Course</a> that covers <a href=\"https://browncs1951x.github.io/static/files/hitchhikersguide.pdf\">The Hitchhiker's Guide to Logical Verification</a> book, we arrive at chapter 5, functional programming. We have already defined a <code>SimpleQueue</code> with these properties:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">*</span> <span class=\"bp\">`</span><span class=\"n\">SimpleQueue.emp</span> <span class=\"o\">:</span> <span class=\"n\">SimpleQueue</span> <span class=\"n\">α</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"n\">an</span> <span class=\"n\">empty</span> <span class=\"n\">queue</span>\n<span class=\"bp\">*</span> <span class=\"bp\">`</span><span class=\"n\">SimpleQueue.enq</span> <span class=\"o\">:</span> <span class=\"n\">SimpleQueue</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">SimpleQueue</span> <span class=\"n\">α</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">function</span> <span class=\"n\">that</span>\n  <span class=\"n\">enqueues</span> <span class=\"n\">a</span> <span class=\"n\">value</span> <span class=\"n\">onto</span> <span class=\"n\">an</span> <span class=\"n\">existing</span> <span class=\"n\">queue</span> <span class=\"o\">(</span><span class=\"n\">i.e.</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">SimpleQueue.enq</span> <span class=\"n\">sq</span> <span class=\"n\">x</span><span class=\"bp\">`</span> <span class=\"n\">should</span>\n  <span class=\"n\">evaluate</span> <span class=\"n\">to</span> <span class=\"n\">the</span> <span class=\"n\">queue</span> <span class=\"n\">resulting</span> <span class=\"k\">from</span> <span class=\"n\">sticking</span> <span class=\"bp\">`</span><span class=\"n\">x</span><span class=\"bp\">`</span> <span class=\"n\">at</span> <span class=\"n\">the</span> <span class=\"n\">back</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">queue</span>\n  <span class=\"n\">represented</span> <span class=\"kd\">by</span> <span class=\"bp\">`</span><span class=\"n\">sq</span><span class=\"bp\">`</span><span class=\"o\">)</span>\n<span class=\"bp\">*</span> <span class=\"bp\">`</span><span class=\"n\">SimpleQueue.deq</span> <span class=\"o\">:</span> <span class=\"n\">SimpleQueue</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">SimpleQueue</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">function</span>\n  <span class=\"n\">that</span> <span class=\"n\">dequeues</span> <span class=\"k\">from</span> <span class=\"n\">an</span> <span class=\"n\">existing</span> <span class=\"n\">queue.</span> <span class=\"n\">This</span> <span class=\"n\">should</span> <span class=\"n\">return</span> <span class=\"bp\">`</span><span class=\"n\">none</span><span class=\"bp\">`</span> <span class=\"k\">if</span> <span class=\"n\">called</span> <span class=\"n\">on</span>\n  <span class=\"n\">an</span> <span class=\"n\">empty</span> <span class=\"n\">queue</span><span class=\"bp\">;</span> <span class=\"n\">otherwise</span><span class=\"o\">,</span> <span class=\"n\">it</span> <span class=\"n\">should</span> <span class=\"n\">return</span> <span class=\"bp\">`</span><span class=\"n\">some</span><span class=\"bp\">`</span> <span class=\"n\">applied</span> <span class=\"n\">to</span> <span class=\"n\">a</span> <span class=\"n\">tuple</span>\n  <span class=\"n\">containing</span> <span class=\"n\">the</span> <span class=\"n\">dequeued</span> <span class=\"n\">element</span> <span class=\"k\">in</span> <span class=\"n\">the</span> <span class=\"n\">first</span> <span class=\"n\">position</span> <span class=\"n\">and</span> <span class=\"n\">the</span> <span class=\"n\">rest</span> <span class=\"n\">of</span> <span class=\"n\">the</span>\n  <span class=\"n\">queue</span> <span class=\"k\">in</span> <span class=\"n\">the</span> <span class=\"n\">second</span>\n</code></pre></div>\n<p>Now we want to prove that another implementation called <code>EfficientQueue</code> is equivalent to the naive approach (It uses two lists), meaning I have to define<br>\n<code>def Equiv {α : Type} : SimpleQueue α → EfficientQueue α → Prop</code><br>\nHowever, I am not sure what this should look like, as I never \"returned a Prop\" before. As a next step, I want to understand how am I supposed to use this to prove the base case, that two empty queues of both types are equivalent <code>theorem emp_equiv {α : Type} : Equiv (α := α) SimpleQueue.emp EfficientQueue.emp</code>.</p>\n<p>This is my attempt:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Equiv</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">SimpleQueue</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">EfficientQueue</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">sq</span> <span class=\"n\">eq</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">sq.deq</span> <span class=\"k\">with</span>\n   <span class=\"bp\">|</span> <span class=\"n\">none</span>         <span class=\"bp\">=&gt;</span> <span class=\"n\">eq.deq</span> <span class=\"bp\">=</span> <span class=\"n\">none</span>\n   <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">sq'</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">eq.deq</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n      <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">eq'</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Equiv</span> <span class=\"n\">sq'</span> <span class=\"n\">eq'</span><span class=\"o\">)</span>\n<span class=\"n\">decreasing_by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Note the sorry for termination. Is this the right track? I am open to suggestions!</p>",
        "id": 422871599,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1708624273
    },
    {
        "content": "<p>I think in this case the easiest thing to do is something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">SimpleQueue.toList</span> <span class=\"o\">:</span> <span class=\"n\">SimpleQueue</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n<span class=\"kd\">def</span> <span class=\"n\">EfficientQueue.toList</span> <span class=\"o\">:</span> <span class=\"n\">EfficientQueue</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Equiv</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">sq</span> <span class=\"o\">:</span> <span class=\"n\">SimpleQueue</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">EfficientQueue</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">sq.toList</span> <span class=\"bp\">=</span> <span class=\"n\">eq.toList</span>\n</code></pre></div>\n<p>to avoid the recursive definition and get access to all the nice <code>List</code> lemmas :)</p>",
        "id": 422894440,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1708631856
    },
    {
        "content": "<p>(and then you can prove stuff like <code>EfficientQueue.emp.toList = []</code> as lemmas, from which the equivalences should be straightforward)</p>",
        "id": 422894585,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1708631904
    },
    {
        "content": "<p>Interesting, from this suggestion I implemented the conversion:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">toList</span> <span class=\"o\">:</span> <span class=\"n\">SimpleQueue</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">toList</span> <span class=\"o\">:</span> <span class=\"n\">EfficientQueue</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">([],</span><span class=\"n\">xs</span><span class=\"o\">)</span>    <span class=\"bp\">=&gt;</span> <span class=\"n\">xs</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">xs.reverse</span> <span class=\"bp\">++</span> <span class=\"n\">ys</span>\n</code></pre></div>\n<p>This way the proof for equivalence for empty queues is <code>rfl</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">emp_equiv</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">Equiv</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">SimpleQueue.emp</span> <span class=\"n\">EfficientQueue.emp</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Now the complex part is to prove the equivalence for enqueuing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">enq_equiv</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">sq</span> <span class=\"o\">:</span> <span class=\"n\">SimpleQueue</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">EfficientQueue</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n  <span class=\"n\">Equiv</span> <span class=\"n\">sq</span> <span class=\"n\">eq</span> <span class=\"bp\">→</span> <span class=\"n\">Equiv</span> <span class=\"o\">(</span><span class=\"n\">sq.enq</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq.enq</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Any ideas here ?</p>",
        "id": 422949433,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1708663223
    },
    {
        "content": "<p>You should then be able to show that <code>(sq.enq x).toList = sq.toList ++ [x]</code> (or whichever side it's getting enqueued at) as a lemma, same for <code>eq</code>, and then the <code>enq_equiv</code> lemma is a matter of unfolding definitions and doing some rewrites</p>",
        "id": 422953470,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1708666674
    }
]