[
    {
        "content": "<p>I’d like to double-check my understanding of the lean type system here.</p>\n<p>Consider this code</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Test</span> <span class=\"n\">where</span>\n  <span class=\"n\">ty</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">ty</span>\n\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Test.mk</span> <span class=\"n\">Nat</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n<span class=\"k\">#check</span> <span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Test.mk</span> <span class=\"n\">Nat</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Command</span> <span class=\"n\">Meta</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"#test\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">runTermElabM</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">s</span>  <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Test.mk</span> <span class=\"n\">Nat</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">Lean.Elab.Term.elabTerm</span> <span class=\"n\">s</span> <span class=\"n\">none</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">run'</span> <span class=\"o\">{}</span>\n    <span class=\"n\">Lean.Meta.check</span> <span class=\"n\">e</span>\n    <span class=\"n\">Lean.logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"Expression: {Lean.indentExpr e}\"</span>\n    <span class=\"n\">Lean.logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"Type: {Lean.indentExpr (←inferType e)}\"</span>\n    <span class=\"n\">Lean.logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"arrow?: {(←inferType e).arrow?}\"</span>\n\n<span class=\"bp\">#</span><span class=\"n\">test</span>\n</code></pre></div>\n<p>The expression </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Test.mk</span> <span class=\"n\">Nat</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n</code></pre></div>\n<p>has type</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">{</span> <span class=\"n\">ty</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">ty</span>\n</code></pre></div>\n<p>so it is not obviously non-dependent. But according to the next <code>check</code>,  I <em>can</em> use it with <code>congrArg</code>, which requires a non-dependent function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">congrArg.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a₁</span> <span class=\"n\">a₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a₁</span> <span class=\"bp\">=</span> <span class=\"n\">a₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">a₁</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a₂</span>\n</code></pre></div>\n<p>I conclude that the type checker will reduce that expression enough to infer <code>β</code> as <code>Nat</code> here. And that passing such a function to <code>congrArg</code> is type-correct.</p>\n<p>Furthermore, Lean’s function <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Expr.isArrow#doc\">docs#Expr.isArrow</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Expr.arrow%3F#doc\">docs#Expr.arrow?</a>, which will <em>not</em> accept that type, are simply too conservative, and thus the helper function <a href=\"https://github.com/leanprover/lean4/blob/b614ff1d12bc38f39077f9ce9f2d48b42c003ad0/src/Lean/Meta/AppBuilder.lean#L168-L180\"><code>mkCongrArg</code>’s checks</a> are actually too strict, and just because that function complains does <em>not</em> mean I am building something invalid here.</p>\n<p>So far so correct? (Context is <a href=\"https://github.com/leanprover/lean4/pull/3121\">https://github.com/leanprover/lean4/pull/3121</a> where I’d be building such terms and I wonder if that is kosher.)</p>",
        "id": 412807469,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705232118
    },
    {
        "content": "<p>It's not the typechecker's responsibility to prove that this arrow is nondependent, it's the elaborator's</p>",
        "id": 412808230,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705232795
    },
    {
        "content": "<p>because you have to pass <code>α</code> and <code>β</code> to the function</p>",
        "id": 412808240,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705232812
    },
    {
        "content": "<p>the typechecker just ensures that the type of <code>f</code> is <code>α → β</code>, so the elaborator will work out that <code>α</code> and <code>β</code> are <code>Nat</code> and pass that, and then the typechecker verifies that <code>(n : Nat) → { ty := Nat, val := n }.ty</code> is defeq to <code>Nat -&gt; Nat</code>, which means that in context <code>n : Nat</code>, <code>{ ty := Nat, val := n }.ty == Nat</code>, which checks out</p>",
        "id": 412808338,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705232918
    },
    {
        "content": "<p>Ah, yes, that makes sense. And when I am the one constructing <code>Expr</code>s, it's my responsibility to figure out β.</p>\n<p><a href=\"https://github.com/leanprover/lean4/pull/3121/files\">In the context of my PR</a> I am using the type of <code>e</code> before abstraction, so _if_ the function is actually non-dependent, this should check out. If  it is properly dependent, then this will not type-check. Probably I should move the <code>unless (← isTypeCorrect motive) do</code> check further down, and run it on the full <code>eqPrf</code>.</p>\n<p>I wonder if I can construct a test case where this matters.</p>\n<p>Anyways, thanks for the clarification!</p>",
        "id": 412809176,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705233689
    },
    {
        "content": "<p>Here is a little puzzle for adversiarly minded minds who want to help me find good test cases:</p>\n<p>Can you pass an equality <code>heq</code> and some term <code>e</code> to this tactic so that  <code>isTypeCorrect motive</code> but not <code>isTypeCorrect eqPrf</code>, likely by passing something that’s causing the <code>motive</code> to be dependently typed?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Command</span> <span class=\"n\">Meta</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"test\"</span> <span class=\"n\">hs</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\" and \"</span> <span class=\"n\">es</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span><span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">heq</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.Elab.Term.elabTerm</span> <span class=\"n\">hs</span> <span class=\"n\">none</span>\n    <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.Elab.Term.elabTerm</span> <span class=\"n\">es</span> <span class=\"n\">none</span>\n    <span class=\"n\">Lean.Meta.check</span> <span class=\"n\">e</span>\n    <span class=\"n\">Lean.Meta.check</span> <span class=\"n\">heq</span>\n    <span class=\"k\">let</span> <span class=\"n\">heqType</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">heq</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">lhs</span><span class=\"o\">,</span> <span class=\"n\">rhs</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">matchEq</span><span class=\"bp\">?</span> <span class=\"n\">heqType</span> <span class=\"bp\">|</span> <span class=\"n\">unreachable</span><span class=\"bp\">!</span>\n    <span class=\"k\">let</span> <span class=\"n\">eAbst</span> <span class=\"bp\">←</span> <span class=\"n\">kabstract</span> <span class=\"n\">e</span> <span class=\"n\">lhs</span>\n    <span class=\"c1\">-- construct rewrite proof</span>\n    <span class=\"k\">let</span> <span class=\"n\">eNew</span> <span class=\"o\">:=</span> <span class=\"n\">eAbst.instantiate1</span> <span class=\"n\">rhs</span>\n    <span class=\"k\">let</span> <span class=\"n\">eNew</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"n\">eNew</span>\n    <span class=\"k\">let</span> <span class=\"n\">eType</span> <span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">e</span>\n    <span class=\"k\">let</span> <span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"n\">Lean.mkLambda</span> <span class=\"bp\">`</span><span class=\"n\">_a</span> <span class=\"n\">BinderInfo.default</span> <span class=\"n\">α</span> <span class=\"n\">eAbst</span>\n    <span class=\"n\">unless</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">isTypeCorrect</span> <span class=\"n\">motive</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n      <span class=\"n\">throwError</span> <span class=\"s2\">\"motive is not type correct\"</span>\n    <span class=\"k\">let</span> <span class=\"n\">u1</span> <span class=\"bp\">←</span> <span class=\"n\">getLevel</span> <span class=\"n\">α</span>\n    <span class=\"k\">let</span> <span class=\"n\">u2</span> <span class=\"bp\">←</span> <span class=\"n\">getLevel</span> <span class=\"n\">eType</span>\n    <span class=\"k\">let</span> <span class=\"n\">eqPrf</span> <span class=\"o\">:=</span> <span class=\"n\">mkApp6</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">congrArg</span> <span class=\"o\">[</span><span class=\"n\">u1</span><span class=\"o\">,</span> <span class=\"n\">u2</span><span class=\"o\">])</span> <span class=\"n\">α</span> <span class=\"n\">eType</span> <span class=\"n\">lhs</span> <span class=\"n\">rhs</span> <span class=\"n\">motive</span> <span class=\"n\">heq</span>\n    <span class=\"n\">unless</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">isTypeCorrect</span> <span class=\"n\">eqPrf</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n      <span class=\"n\">throwError</span> <span class=\"s2\">\"eqPrf is not type correct\"</span>\n    <span class=\"n\">Lean.logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"eqPrf: {Lean.indentExpr eqPrf}\"</span>\n    <span class=\"n\">Lean.logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"eqPrf type: {Lean.indentExpr (←inferType eqPrf)}\"</span>\n    <span class=\"n\">Lean.logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"eNew: {Lean.indentExpr eNew}\"</span>\n    <span class=\"n\">Lean.logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"eNew type: {Lean.indentExpr (←inferType eNew)}\"</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">D2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Bool.rec</span> <span class=\"n\">Unit</span> <span class=\"n\">Nat</span> <span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">()</span>\n  <span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">D3</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Unit</span>\n  <span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mwe2</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">=</span> <span class=\"n\">false</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- (P : (t : Nat) -&gt; D t)</span>\n  <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">D3</span> <span class=\"n\">false</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">D3</span> <span class=\"n\">true</span>\n  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">test</span> <span class=\"n\">h</span> <span class=\"n\">and</span> <span class=\"n\">i</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 412921664,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705312758
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mwe2</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">D</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">test</span> <span class=\"n\">h</span> <span class=\"n\">and</span> <span class=\"n\">f</span> <span class=\"n\">true</span>\n</code></pre></div>",
        "id": 412923445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705313314
    },
    {
        "content": "<p>Thanks! Almost what I need, let me make it a bit harder: The term <code>e</code> has to be a type, such as the current goal.</p>\n<p>Here is a variant of the puzzle using <code>getMainGoal</code>:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>import Lean\n\nopen Lean Elab Command Meta Tactic\n\nelab &quot;test&quot; hs:term : tactic =&gt;do\n    let heq ← Lean.Elab.Term.elabTerm hs none\n    let e ← (← getMainGoal).getType\n    Lean.Meta.check e\n    Lean.Meta.check heq\n    let heqType ← instantiateMVars (← inferType heq)\n    let some (α, lhs, rhs) ← matchEq? heqType | unreachable!\n    let eAbst ← kabstract e lhs\n    -- construct rewrite proof\n    let eNew := eAbst.instantiate1 rhs\n    let eNew ← instantiateMVars eNew\n    let eType ← inferType e\n    let motive := Lean.mkLambda `_a BinderInfo.default α eAbst\n    unless (← isTypeCorrect motive) do\n      throwError &quot;motive is not type correct&quot;\n    let u1 ← getLevel α\n    let u2 ← getLevel eType\n    let eqPrf := mkApp6 (.const ``congrArg [u1, u2]) α eType lhs rhs motive heq\n    unless (← isTypeCorrect eqPrf) do\n      throwError &quot;eqPrf is not type correct&quot;\n    Lean.logInfo m!&quot;eqPrf: {Lean.indentExpr eqPrf}&quot;\n    Lean.logInfo m!&quot;eqPrf type: {Lean.indentExpr (←inferType eqPrf)}&quot;\n    Lean.logInfo m!&quot;eNew: {Lean.indentExpr eNew}&quot;\n    Lean.logInfo m!&quot;eNew type: {Lean.indentExpr (←inferType eNew)}&quot;\n</code></pre></div>\n</div></div>",
        "id": 412954383,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705324267
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mwe2</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">D</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"n\">true</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">test</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 412960468,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705326326
    },
    {
        "content": "<p>Ah, but this gives “motive is not type correct”, not  “eqPrf is not type correct”.</p>\n<p>Basically I am trying to figure out if the check</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unless</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">isTypeCorrect</span> <span class=\"n\">eqPrf</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>is redundant or not (edited).</p>",
        "id": 412961289,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705326584
    },
    {
        "content": "<p>well it's clearly not here, since that's the error that triggers in this case</p>",
        "id": 412961440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705326624
    },
    {
        "content": "<p>Sorry,. I meant the other one :-)</p>",
        "id": 412961504,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705326648
    },
    {
        "content": "<p>I think it's not likely to be possible in this case, because the type of a type is a universe, and universes can't have essential dependencies on local variables</p>",
        "id": 412961693,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705326710
    },
    {
        "content": "<p>It seems for that I need to construct a goal whose sort(?) is dependent on <code>e</code>.</p>",
        "id": 412961702,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705326716
    },
    {
        "content": "<p>Great, that’s the kind of argument was looking for. Thanks!</p>",
        "id": 412962277,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705326879
    },
    {
        "content": "<p>note that the word \"essential\" there is important, it is possible for the type of a type to have inessential dependencies</p>",
        "id": 412962366,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705326911
    },
    {
        "content": "<p>example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">y</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">K</span> <span class=\"n\">b</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">test</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>This works however because it's okay to type both sides of the equality as <code>K true Type</code> in this example</p>",
        "id": 412962814,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705327077
    },
    {
        "content": "<p>Thanks, I’ll throw this into the test suite</p>",
        "id": 412963273,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705327219
    },
    {
        "content": "<p>Oh but here's a counterexample after all:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mwe2</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"k\">if</span> <span class=\"n\">b</span> <span class=\"k\">then</span> <span class=\"kt\">Prop</span> <span class=\"k\">else</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">test</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 412963315,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705327233
    },
    {
        "content": "<p>Oh, darn. This would (if I leave out the second check and use that in <code>rw</code>) lead to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"k\">if</span> <span class=\"n\">b</span> <span class=\"k\">then</span> <span class=\"kt\">Prop</span> <span class=\"k\">else</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"c1\">-- Error: type expected</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>i.e. an error at the <code>by</code> rather than the <code>rw</code>.</p>\n<p>So I have these options</p>\n<ul>\n<li>Include both checks in the code (slower than the status quo, maybe a worry in something as common as <code>rw</code>?)</li>\n<li>Only do the second check, maybe change the error message to “motive not well-typed or dependent”</li>\n<li>Only do the first check, because these situations are quite unlikely</li>\n<li>Don't mess with rw :-)</li>\n</ul>",
        "id": 412964713,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705327694
    },
    {
        "content": "<p>I'm not clear on why you don't just check that <code>motive</code> is a nondependent arrow</p>",
        "id": 412965251,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705327841
    },
    {
        "content": "<p>Because of this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">./././</span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">/</span><span class=\"n\">Limits</span><span class=\"bp\">/</span><span class=\"n\">IsLimit.lean</span><span class=\"o\">:</span><span class=\"mi\">538</span><span class=\"o\">:</span><span class=\"mi\">20</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">AppBuilder</span> <span class=\"n\">for</span> <span class=\"bp\">'</span><span class=\"n\">congrArg'</span><span class=\"o\">,</span> <span class=\"n\">non</span><span class=\"bp\">-</span><span class=\"n\">dependent</span> <span class=\"n\">function</span> <span class=\"n\">expected</span>\n  <span class=\"k\">fun</span> <span class=\"n\">_a</span> <span class=\"bp\">↦</span> <span class=\"o\">{</span> <span class=\"n\">pt</span> <span class=\"o\">:=</span> <span class=\"n\">pt</span><span class=\"bp\">✝</span><span class=\"o\">,</span> <span class=\"n\">π</span> <span class=\"o\">:=</span> <span class=\"n\">_a</span> <span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">π.app</span> <span class=\"n\">j</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"o\">(</span><span class=\"n\">_a</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Functor.cones</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">pt</span><span class=\"bp\">✝</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">const</span> <span class=\"n\">J</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">{</span> <span class=\"n\">pt</span> <span class=\"o\">:=</span> <span class=\"n\">pt</span><span class=\"bp\">✝</span><span class=\"o\">,</span> <span class=\"n\">π</span> <span class=\"o\">:=</span> <span class=\"n\">_a</span> <span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">pt</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">j</span> <span class=\"bp\">⟶</span> <span class=\"n\">F.obj</span> <span class=\"n\">j</span>\n</code></pre></div>\n<p>so at least using <code>arrow?</code> is too picky, it seems.</p>",
        "id": 412965355,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705327881
    },
    {
        "content": "<p>This already comes up elsewhere in the elaborator, it is addressed by using whnf to try to eliminate the fvar</p>",
        "id": 412965531,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705327930
    },
    {
        "content": "<p>Oh, does weak  <em>head</em> normal form help? Didn’t expect that</p>",
        "id": 412965630,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705327960
    },
    {
        "content": "<p>not in general, but it works in a lot of real world cases</p>",
        "id": 412965735,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705328004
    },
    {
        "content": "<p>But if some are left and <code>rw</code> doesn’t work there then that’s bad, isn’t it?<br>\nAh, I guess i should just check</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unless</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">isTypeCorrect</span> <span class=\"n\">eqPrf</span><span class=\"o\">)</span>\n<span class=\"bp\">``</span>\n<span class=\"n\">and</span> <span class=\"n\">only</span> <span class=\"k\">if</span> <span class=\"n\">that</span> <span class=\"n\">fails</span><span class=\"o\">,</span> <span class=\"n\">check</span> <span class=\"n\">some</span> <span class=\"n\">more</span> <span class=\"n\">things</span> <span class=\"n\">for</span> <span class=\"n\">good</span> <span class=\"n\">error</span> <span class=\"n\">messages.</span>\n</code></pre></div>",
        "id": 412965984,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705328081
    },
    {
        "content": "<blockquote>\n<p>But if some are left and rw doesn’t work there then that’s bad, isn’t it?</p>\n</blockquote>\n<p>rw never claimed to be complete, IMO this is a courtesy to avoid the \"motive is not type correct\" error</p>",
        "id": 412966152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705328142
    },
    {
        "content": "<p>in most cases where this comes up you should really have used <code>dsimp</code> first</p>",
        "id": 412966232,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705328165
    },
    {
        "content": "<p>I think that even just using <code>arrow?</code> is fine</p>",
        "id": 412966329,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705328197
    },
    {
        "content": "<p>besides, this is just an optimization, right? You can still use <code>Eq.rec</code> which allows a dependent function there</p>",
        "id": 412966670,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705328292
    },
    {
        "content": "<p>Not sure what you mean is an optimization there? The check?</p>\n<p>(It’s an “optional convenience” in the sense that if we’d not do the check, stuff fails later.)</p>\n<blockquote>\n<p>I think that even just using arrow? is fine</p>\n</blockquote>\n<p>That would make that refactoring a breaking change. But I see the point: The motive in the <code>IsLimit</code> example is dependent (if only in a superficial sense) and <code>rw</code> doesn’t do dependent rewrites, and it’s reasonable for it to fail.</p>",
        "id": 412970276,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705329347
    },
    {
        "content": "<p>How does</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>          <span class=\"n\">unless</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">isTypeCorrect</span> <span class=\"n\">eqPrf</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n            <span class=\"n\">unless</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">isTypeCorrect</span> <span class=\"n\">motive</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n              <span class=\"n\">throwTacticEx</span> <span class=\"bp\">`</span><span class=\"n\">rewrite</span> <span class=\"n\">mvarId</span> <span class=\"s2\">\"motive is not type correct\"</span>\n            <span class=\"n\">unless</span> <span class=\"n\">motive.isArrow</span> <span class=\"k\">do</span>\n              <span class=\"n\">throwTacticEx</span> <span class=\"bp\">`</span><span class=\"n\">rewrite</span> <span class=\"n\">mvarId</span> <span class=\"s2\">\"motive is dependent\"</span>\n            <span class=\"n\">throwTacticEx</span> <span class=\"bp\">`</span><span class=\"n\">rewrite</span> <span class=\"n\">mvarId</span> <span class=\"s2\">\"equality proof is not type correct\"</span>\n</code></pre></div>\n<p>look? In the happy path only one <code>isTypeCorrect</code> is used, and in the unhappy path we put in a little low-cost effort to print a somewhat helpful error message, leading to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"k\">if</span> <span class=\"n\">b</span> <span class=\"k\">then</span> <span class=\"kt\">Prop</span> <span class=\"k\">else</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- tactic 'rewrite' failed, motive is dependent</span>\n    <span class=\"n\">exact</span> <span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 412971222,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705329620
    },
    {
        "content": "<blockquote>\n<p>Not sure what you mean is an optimization there? The check?</p>\n</blockquote>\n<p>You haven't really said what all this is for, but I'm guessing that you are testing an improved version of <code>rw</code> which uses <code>congrArg</code> instead of <code>Eq.rec</code>. What I'm saying is that if you can't use <code>congrArg</code> because of the requirement on <code>f</code>, then just fall back to the original proof method with <code>Eq.rec</code> and that way no existing cases break</p>",
        "id": 412971637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705329769
    },
    {
        "content": "<p>Using <code>congrArg</code> is fine (as far as I can tell), even in the example above, as you explained: Once I specify <code>β</code> it’s ok if the motive is “superficially dependent”. But the <code>.arrow?</code> function wouldn’t allow it, so I can’t use it (without breaking code) to bail out early with a helpful error message.</p>",
        "id": 412972017,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705329903
    },
    {
        "content": "<p>This is for  <a href=\"https://github.com/leanprover/lean4/pull/3121\">https://github.com/leanprover/lean4/pull/3121</a></p>",
        "id": 412972107,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705329937
    },
    {
        "content": "<p>Using <code>isTypeCorrect</code> is a heavy hammer here in the first place. You just need to check whether two things are defeq</p>",
        "id": 412972997,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705330226
    },
    {
        "content": "<p>I didn’t dare to remove Chersterton’s hammer yet :-)</p>",
        "id": 412973493,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705330381
    },
    {
        "content": "<p>well you need one of them, you are adding a second fence though</p>",
        "id": 412973873,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705330501
    },
    {
        "content": "<p>The <code>isTypeCorrect eqPrf</code> should be rather close in effect to the old <code>isTypeCorrect motive</code> (note that the old motive was <code>fun a =&gt; @Eq eType e (e[a/lhs])</code>, so type-checking that prevented unwanted dependencies). Looking at it like this I am make more fuss about this than I needed to, I guess.</p>",
        "id": 412974457,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705330678
    },
    {
        "content": "<p>here's the two things:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"n\">unless</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">withLocalDeclD</span> <span class=\"bp\">`</span><span class=\"n\">_a</span> <span class=\"n\">α</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isDefEq</span> <span class=\"o\">(</span><span class=\"n\">eAbst.instantiate1</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">eType</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n      <span class=\"n\">throwError</span> <span class=\"s2\">\"eqPrf is not type correct\"</span>\n</code></pre></div>",
        "id": 412974836,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705330787
    },
    {
        "content": "<p><code>isTypeCorrect motive</code> + that should ensure <code>eqPrf</code> is valid</p>",
        "id": 412975004,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705330827
    },
    {
        "content": "<p>Thanks! I was wonder how I can just do the that <code>isDefEq</code> easily, but was shying away from that because of that bit of midly noisy context manipulation. But it’s not too bad after all.</p>",
        "id": 412987258,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705334241
    },
    {
        "content": "<p>This check seems stricter than <code>isTypeCorrect eqPrf</code>, however: It now complains about</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">y</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">=</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">K</span> <span class=\"n\">b</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h2</span>\n</code></pre></div>\n<p>(the “non-essential dependency”), where <code>isTypeCorrect eqPrf</code> was happy, it seems.</p>\n<p>Not that I mind rejecting that example, just checking if this is expected.</p>",
        "id": 412988289,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705334530
    },
    {
        "content": "<p>Ignore that. After changing it to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"n\">unless</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">withLocalDeclD</span> <span class=\"bp\">`</span><span class=\"n\">_a</span> <span class=\"n\">α</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"n\">isDefEq</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"o\">(</span><span class=\"n\">eAbst.instantiate1</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"n\">eType</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n</code></pre></div>\n<p>(which I think you intended) it’s still happy with that example.</p>",
        "id": 413001547,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705338596
    },
    {
        "content": "<p>Have you seen that <code>simp</code> tries to replace its auto-generated congruence lemmas (which are proved with nested <code>Eq.rec</code>s) with <code>congrFun</code>, <code>congrArg</code>, and <code>congr</code>? This seems similar in spirit to what you seem to be up to, which I'm guessing is replacing <code>rw</code>'s <code>Eq.rec</code> proof in a similar way.</p>",
        "id": 413004930,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705339928
    }
]