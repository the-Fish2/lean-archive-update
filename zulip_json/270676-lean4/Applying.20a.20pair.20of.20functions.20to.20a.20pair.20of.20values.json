[
    {
        "content": "<p>Is there a canonical way to apply a pair of functions to a pair of values?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"s2\">\"hello \"</span> <span class=\"bp\">++</span> <span class=\"n\">a</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"s2\">\"world\"</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"c1\">-- doesn't work</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">&lt;*&gt;</span> <span class=\"o\">(</span><span class=\"s2\">\"world\"</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"c1\">-- doesn't work</span>\n</code></pre></div>",
        "id": 419593713,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1706953985
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Prod.map#doc\">docs#Prod.map</a></p>",
        "id": 419593839,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706954083
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"654733\">Markus Schmaus</span> has marked this topic as resolved.</p>",
        "id": 419593937,
        "sender_full_name": "Notification Bot",
        "timestamp": 1706954156
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"654733\">Markus Schmaus</span> has marked this topic as unresolved.</p>",
        "id": 419594468,
        "sender_full_name": "Notification Bot",
        "timestamp": 1706954461
    },
    {
        "content": "<p>Thanks for the quick reply, but this isn't quite what I was looking for. <code>Prod.map</code> expects the two functions as individual values, but it can't handle the pair <code>(g, f)</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n<span class=\"kd\">def</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"s2\">\"hello \"</span> <span class=\"bp\">++</span> <span class=\"n\">a</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">Prod.map</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"s2\">\"world\"</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"c1\">-- doesn't work</span>\n<span class=\"k\">#eval</span> <span class=\"n\">Prod.map</span> <span class=\"n\">g</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"s2\">\"world\"</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"c1\">-- intended use</span>\n</code></pre></div>",
        "id": 419594713,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1706954655
    },
    {
        "content": "<p>Why do you care about providing the functions as a pair?</p>",
        "id": 419594847,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706954767
    },
    {
        "content": "<p>If you really do, then you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.uncurry#doc\">docs#Function.uncurry</a>, as in <code>Function.uncurry Prod.map (g, f) (\"world\", 0)</code></p>",
        "id": 419594893,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706954795
    },
    {
        "content": "<p>I'm looking into products of Functors and I'm trying to decide whether it makes sense to use the existing <code>Prod</code> type or define my own structure from scratch.</p>",
        "id": 419595374,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1706955197
    },
    {
        "content": "<p>I'm not sure what that has to do with pairs of functions. Can you clarify?</p>",
        "id": 419596999,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706956535
    },
    {
        "content": "<p>I mean I guess this could be a <code>Functor</code> instance?</p>",
        "id": 419599365,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706958429
    },
    {
        "content": "<p>ah, no, only the boring one for <code>Prod x x</code></p>",
        "id": 419599585,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706958613
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> You can make a category whose object type is <code>Type × Type</code> and whose morphism type for <code>(α, β) ⟶ (α', β')</code> is <code>(α → α') × (β → β')</code>.)</p>",
        "id": 419625969,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706981189
    },
    {
        "content": "<p>Yeah but that's only useful in a categorical setting, no?</p>",
        "id": 419626125,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706981369
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"654733\">@Markus Schmaus</span> If you're hoping to restrict to only functions that come from pairs, I think you're out of luck with Functor, since it allows any Type* -&gt; Type* function, not just the ones that would respect cartesian products.</p>\n<p>One thing you could do is create a CoeFun coercion to make tuples of functions be able to be used as functions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">α'</span> <span class=\"n\">β'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">CoeFun</span> <span class=\"o\">((</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">α'</span> <span class=\"bp\">→</span> <span class=\"n\">β'</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α'</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">×</span> <span class=\"n\">β'</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">Function.uncurry</span> <span class=\"n\">Prod.map</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"s2\">\"hello \"</span> <span class=\"bp\">++</span> <span class=\"n\">a</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"s2\">\"world\"</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 419626476,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706981692
    },
    {
        "content": "<p>Though using the uncurried <code>Prod.map</code> seems more reliable:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Prod.map'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">α'</span> <span class=\"n\">β'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">α'</span> <span class=\"bp\">→</span> <span class=\"n\">β'</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α'</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">×</span> <span class=\"n\">β'</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Prod.map</span> <span class=\"n\">f.1</span> <span class=\"n\">f.2</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">Prod.map'</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"s2\">\"world\"</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map'</span> <span class=\"o\">(</span><span class=\"s2\">\"world\"</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 419626502,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706981716
    },
    {
        "content": "<p>It's quite easy to create what I want as a new <code>structure</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">ProductF</span> <span class=\"o\">(</span><span class=\"n\">F₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">fst</span> <span class=\"o\">:</span> <span class=\"n\">F₁</span> <span class=\"n\">α</span>\n  <span class=\"n\">snd</span> <span class=\"o\">:</span> <span class=\"n\">F₂</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">ProductF.instFunctor</span> <span class=\"o\">{</span><span class=\"n\">F₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">F₁</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">F₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">F₂</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">Functor</span> <span class=\"o\">(</span><span class=\"n\">ProductF</span> <span class=\"n\">F₁</span> <span class=\"n\">F₂</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ProductF</span> <span class=\"n\">F₁</span> <span class=\"n\">F₂</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"o\">⟨</span><span class=\"n\">f</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">x.fst</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">x.snd</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>Of course since this is a new structure, none of the lemmas in Lean or Mathlib apply to it. So I was wondering if I could build this up using pre-existing constructions, which already have some lemmas proven about them. Based on notation I know from category theory, I would have written this as (F₁, F₁) ο Δ, where Δ is the diagonal map x ↦ (x, x). But since this doesn't seem to translate to Lean, the above construction works fine.</p>",
        "id": 419700313,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1707054768
    },
    {
        "content": "<p>By the way, the following will do for the instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">F₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">F₁</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">F₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">F₂</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">Functor</span> <span class=\"o\">(</span><span class=\"n\">ProductF</span> <span class=\"n\">F₁</span> <span class=\"n\">F₂</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">f</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">x.fst</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">x.snd</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>You could keep the <code>fun</code>, but you can omit the implicit arguments and the types.</p>",
        "id": 419715323,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707067778
    },
    {
        "content": "<p>You can also reuse Prod using a sort of type synonym that's opaque to typeclass inference.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ProdF</span> <span class=\"o\">(</span><span class=\"n\">F₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">F₁</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">F₂</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">F₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">F₁</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">F₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">F₂</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">Functor</span> <span class=\"o\">(</span><span class=\"n\">ProdF</span> <span class=\"n\">F₁</span> <span class=\"n\">F₂</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">Prod.map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"bp\">·</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 419715632,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707067974
    },
    {
        "content": "<p>With <code>(F₁, F₁) ο Δ</code>, I'm not exactly sure what<code>(F₁, F₁)</code> means. It seems like it would be a functor for the product category <code>Type u × Type u</code>? That's what I was sort of referring to earlier -- <code>Functor</code> doesn't let you deal with any category but <code>Type u</code>. There's a category theory library with its own notion of functor that should let you express this, but it's not connected to <code>Functor</code>, which is more for programming.</p>",
        "id": 419715989,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707068201
    }
]