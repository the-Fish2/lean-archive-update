[
    {
        "content": "<p>In a learning seminar on Lean the question arose as possible ways to define an inductive type for ordered lists, where the constructors already guarantee the ordering. Here is what we tried without success:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Real</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">MyList</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyList</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nil</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyList</span> <span class=\"c1\">-- faisl with: invalid universe level in constructor 'MyList.cons',...</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons'</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyList</span>\n</code></pre></div>\n<p>I know how to do this using a structure that hold the list and with some helper functions, but the question is how to make it directly using an inductive definition. Thanks for the help!</p>",
        "id": 435121863,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1713941468
    },
    {
        "content": "<p><code>set_option autoImplicit false</code> is always a good first step here. Does this change the error?</p>",
        "id": 435124459,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713942505
    },
    {
        "content": "<p>Many people asking questions about inductive types seem to be victims of this footgun.</p>",
        "id": 435124797,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713942643
    },
    {
        "content": "<p>No, it doesn't... Here's the full error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"kd\">universe</span> <span class=\"n\">level</span> <span class=\"k\">in</span> <span class=\"n\">constructor</span> <span class=\"bp\">'</span><span class=\"n\">MyList.cons'</span><span class=\"o\">,</span> <span class=\"kd\">parameter</span> <span class=\"bp\">'</span><span class=\"n\">nil'</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.24</span> <span class=\"n\">y</span>\n<span class=\"n\">at</span> <span class=\"kd\">universe</span> <span class=\"n\">level</span>\n  <span class=\"bp\">?</span><span class=\"n\">u.9</span>\n<span class=\"n\">it</span> <span class=\"n\">must</span> <span class=\"n\">be</span> <span class=\"n\">smaller</span> <span class=\"n\">than</span> <span class=\"n\">or</span> <span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"n\">the</span> <span class=\"kd\">inductive</span> <span class=\"n\">datatype</span> <span class=\"kd\">universe</span> <span class=\"n\">level</span>\n  <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 435124809,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1713942648
    },
    {
        "content": "<p>I have no idea what <code>(nil x)</code> is supposed to mean. It's a random term in a bracket, not a variable name or anything</p>",
        "id": 435125071,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713942740
    },
    {
        "content": "<p>Do you mean <code>(x : \\R)</code>?</p>",
        "id": 435125542,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713942923
    },
    {
        "content": "<p>I understand that by \"I\" you mean \"Lean\". I would like to match against the previous constructor, and this is precisely what I don't know hot to do. That is, you can construct an ordered list by either:</p>\n<ol>\n<li>Pass one real.</li>\n<li>Pass one real, a list created using the previous constructor, and a proof that this new real is smaller than the x used in the first instance.</li>\n<li>Pass one real, a list created the second constructor, and a proof that this new real is smaller than the term used in the other constructor.</li>\n</ol>\n<p>This would make sense, right? It's similar to creating a list in the usual inductive definition, but at each step you ensure that your new element is sorted relative to the others.</p>",
        "id": 435125594,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1713942942
    },
    {
        "content": "<p>But a list is called <code>(L : MyList)</code> not <code>(nil x)</code></p>",
        "id": 435125777,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713942996
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/Inductive.20definition.20of.20an.20ordered.20list/near/435125542\">said</a>:</p>\n<blockquote>\n<p>Do you mean <code>(x : \\R)</code>?</p>\n</blockquote>\n<p>Yes, and I would want to write MyList.nil (x : R) but this does not work either...</p>",
        "id": 435125805,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1713943008
    },
    {
        "content": "<p>I don't understand why you want to pass the list and not just x</p>",
        "id": 435125890,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713943038
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/Inductive.20definition.20of.20an.20ordered.20list/near/435125777\">said</a>:</p>\n<blockquote>\n<p>But a list is called <code>(L : MyList)</code> not <code>(nil x)</code></p>\n</blockquote>\n<p>Yes, I want this constructor to only take mylists created using the first constructor, not any mylist.</p>",
        "id": 435125911,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1713943048
    },
    {
        "content": "<p>In the usual inductive definition of a list, the <code>cons</code> constructor you pass an element and a list to it, too.</p>",
        "id": 435126095,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1713943106
    },
    {
        "content": "<p>Do you want to disallow empty lists?</p>",
        "id": 435126173,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1713943131
    },
    {
        "content": "<p>Yes, this proposal would not allow empty lists. I guess if I wanted an empty list then I would add one empty constructor.</p>",
        "id": 435126612,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1713943283
    },
    {
        "content": "<p>Do you want to allow lists of length bigger than 3? Because you're not getting those either, right?</p>",
        "id": 435127515,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713943589
    },
    {
        "content": "<p>That's a worse problem, I am trying to work out a solution for that. But the first problem will still be there: Lean does not take my definition...</p>",
        "id": 435127705,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1713943681
    },
    {
        "content": "<p>Do you even know that it's possible to express the idea using a bare inductive type (as opposed to using inbuilt <code>List</code>, which your structure solution presumably does)?</p>",
        "id": 435127881,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713943739
    },
    {
        "content": "<p>If you mean from a type theoretical point of view, the answer is: I have no clue. If you mean \"intuitively\", then my idea is that what I am constructing has a \"last added value\" and I should be able to access that value and compare it with my new value...</p>",
        "id": 435128200,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1713943847
    },
    {
        "content": "<p>Record the last inserted object as a type parameter:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">MyList</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyList</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyList</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">MyList</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 435144701,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1713949702
    },
    {
        "content": "<p>That's exactly what I was trying to accomplish, thank you all for looking into this!</p>",
        "id": 435150055,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1713951433
    },
    {
        "content": "<p>If the type parameter is bothersome, you can wrap it in a sigma type</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">MyActualList</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"n\">MyList</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>or an equivalent custom structure type.</p>",
        "id": 435152027,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1713952088
    },
    {
        "content": "<p>I think(?) this would also be a nice place for induction-recursion, something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">MyList</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">MyList</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tl</span> <span class=\"o\">:</span> <span class=\"n\">MyList</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">ltList</span> <span class=\"n\">tl</span> <span class=\"n\">hd</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyList</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ltList</span> <span class=\"o\">:</span> <span class=\"n\">MyList</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℝ</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span>          <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">hd</span>\n</code></pre></div>\n<p>I don't think lean can do induction-recursion at the moment, and I don't think it's on the roadmap, but this is a nice simple example of induction-recursion in the wild</p>",
        "id": 436948119,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1714765217
    },
    {
        "content": "<p>It cannot, It is not on the immediate roadmap but we are definitely not opposed to having this feature and it might be added eventually (eventually is an unknown far away moment in the future here)</p>",
        "id": 436949079,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1714765626
    },
    {
        "content": "<p>How would you expect ind-rec to be added to Lean? It would require modifying the kernel, as it’s not reducible to lean’s current type theory</p>",
        "id": 437586871,
        "sender_full_name": "Max Nowak 🐉",
        "timestamp": 1715150203
    },
    {
        "content": "<p>We have not thought about it at all (to my knowledge). It is just something that we want to have eventually</p>",
        "id": 437617359,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1715162371
    }
]