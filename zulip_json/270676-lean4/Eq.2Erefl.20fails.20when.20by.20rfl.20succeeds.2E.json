[
    {
        "content": "<p>The terms Lean4 equation compiler generates for these 2 definitions</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">div2</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">div2</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">m</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">div2'</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">div2'</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">m</span>\n</code></pre></div>\n<p>are identical (both compile to eliminators). Naturally, I expected that the equality of those two could be proven with reflexivity. However,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">my_div2_is_div2'</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">div2</span> <span class=\"n\">div2'</span> <span class=\"o\">:=</span> <span class=\"n\">Eq.refl</span> <span class=\"n\">div2</span>\n</code></pre></div>\n<p>does not type-check:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">Eq.refl</span> <span class=\"n\">div2</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">div2</span> <span class=\"bp\">=</span> <span class=\"n\">div2</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">div2</span> <span class=\"bp\">=</span> <span class=\"n\">div2'</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>despite the fact that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">div2_is_div2'</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">div2</span> <span class=\"n\">div2'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>does, in fact, type-check. Actually, when printed out, we get the same exact term as earlier:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">div2_is_div2'</span> <span class=\"o\">:</span> <span class=\"n\">div2</span> <span class=\"bp\">=</span> <span class=\"n\">div2'</span> <span class=\"o\">:=</span> <span class=\"n\">Eq.refl</span> <span class=\"n\">div2</span>\n</code></pre></div>\n<p>What is going on here? I have tested this with the online playground, version \"4.7.0-rc2\".</p>",
        "id": 426185503,
        "sender_full_name": "Iurii Zamiatin",
        "timestamp": 1710266855
    },
    {
        "content": "<p>One little-known feature of the <code>rfl</code> tactic is that if there are no free variables, it will essentially try <code>rfl</code> with no transparency constraints, using the way the kernel would check <code>Eq.refl</code>. Here, it looks like not even <code>by with_unfolding_all exact rfl</code> is as powerful as <code>by rfl</code>.</p>",
        "id": 426189047,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710268148
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Eq.2Erefl.20fails.20when.20by.20rfl.20succeeds.2E/near/426189047\">said</a>:</p>\n<blockquote>\n<p>One little-known feature of the <code>rfl</code> tactic is that if there are no free variables, it will essentially try <code>rfl</code> with no transparency constraints, using the way the kernel would check <code>Eq.refl</code>. Here, it looks like not even <code>by with_unfolding_all exact rfl</code> is as powerful as <code>by rfl</code>.</p>\n</blockquote>\n<p>Sorry, I don’t quite understand what “no transparency constraints” means here. Could you expand on that? The issue here is that <code>Eq.refl</code> fails to prove equality of two identical terms, but <code>by rfl</code> manages to somehow (with #print suggesting it’s also done through <code>Eq.refl</code>).</p>\n<p>I would expect any tactic to produce a term kernel can type check, but this doesn’t seem to hold here.</p>",
        "id": 426190757,
        "sender_full_name": "Iurii Zamiatin",
        "timestamp": 1710268788
    },
    {
        "content": "<p>For performance, there's such a thing as \"transparency\" which allows some expressions not to be unfolded during defeq checks. The level of transparency you want to unfold to can be modified, depending on whether you want the evaluation of <code>isDefEq</code> to be fast and maybe give you a false negative, or slower with less false negatives. These reducibility settings in your particular example prevent most tactics from evaluating this equality to really truly be an equality, but this special feature of <code>rfl</code>, which uses the kernel's equality checker, allows this to go through.</p>",
        "id": 426191757,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1710269174
    },
    {
        "content": "<p>I see, thanks. In that case wouldn’t it make sense for the proof term generated with by rfl to indicate that higher evaluation depth is needed?</p>",
        "id": 426192361,
        "sender_full_name": "Iurii Zamiatin",
        "timestamp": 1710269391
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"573659\">Iurii Zamiatin</span> has marked this topic as resolved.</p>",
        "id": 426193231,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710269731
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>'s point here is that the the evaluation depth accessible by <code>rfl</code> (which is a very low level command/tactic apparently) is otherwise unaccessible.</p>",
        "id": 426212937,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710277732
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"573659\">Iurii Zamiatin</span> has marked this topic as unresolved.</p>",
        "id": 426214235,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710278307
    },
    {
        "content": "<p>Are the rules for determining which definitions are considered to be transparent by the elaborator documented somewhere?</p>",
        "id": 426214238,
        "sender_full_name": "Iurii Zamiatin",
        "timestamp": 1710278308
    },
    {
        "content": "<p>Are the rules for determining which bindings are transparent documented somewhere?<br>\nEDIT: Sorry, I am not sure why the message got posted twice, I am new to Zulip.</p>",
        "id": 426214326,
        "sender_full_name": "Iurii Zamiatin",
        "timestamp": 1710278341
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"573659\">Iurii Zamiatin</span> has marked this topic as resolved.</p>",
        "id": 426214833,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710278565
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"359992\">Robert Maxton</span> has marked this topic as unresolved.</p>",
        "id": 426215326,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710278783
    },
    {
        "content": "<p>When you resolve a topic, the thread title changes, which changes the link, and the same is true of unresolving it. (I believe this is the reason you need to be a mod to resolve/unresolve old topics -- people may have created links that they expected to be permanent in that time, and resolving/unresolving the topic will break their links.)</p>\n<p>I infer from the above behavior that this is in fact implemented as a new topic; Zulip attempts to intelligently move all the messages in a given topic to the \"new\" topic, but if you unresolve and post twice in short succession, it can end up associating one of your messages to the \"other\"/\"old\" topic instead.</p>",
        "id": 426215366,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710278809
    },
    {
        "content": "<p>(I'm assuming you did intend to unresolve this topic, so I did it for you so as to avoid a repeat)</p>",
        "id": 426215443,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1710278847
    },
    {
        "content": "<p>in general, in this zulip instance we avoid resolving topics for this sort of reason</p>",
        "id": 426217601,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1710279878
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"573659\">Iurii Zamiatin</span> <a href=\"#narrow/stream/270676-lean4/topic/Eq.2Erefl.20fails.20when.20by.20rfl.20succeeds.2E/near/426192361\">said</a>:</p>\n<blockquote>\n<p>I see, thanks. In that case wouldn’t it make sense for the proof term generated with by rfl to indicate that higher evaluation depth is needed?</p>\n</blockquote>\n<p>It's weird that <code>Eq.refl</code> is the proof generated by <code>by rfl</code>, right?</p>\n<p>There are two type checkers in the Lean system: the elaborator's and the kernel's. The kernel typechecker is simpler (you might say it's \"lean\"), and the elaborator's typechecker is meant to help with everything that needs to be done during elaboration. The elaborator's typechecker tends to be more conservative than the kernel's, and it also has these different definition transparency levels to help control what gets unfolded and when.</p>\n<p>Tactics do not need to create proof terms that would pass the elaborator's typechecker (so long as they pass the kernel's), and apparently <code>rfl</code> in this case is generating such a proof term.</p>\n<p>It's possible that it's not a matter of transparency — that was just a guess — and it could be from some other difference between the elaborator and the kernel.</p>",
        "id": 426224386,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710283255
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Eq.2Erefl.20fails.20when.20by.20rfl.20succeeds.2E/near/426224386\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"573659\">Iurii Zamiatin</span> <a href=\"#narrow/stream/270676-lean4/topic/Eq.2Erefl.20fails.20when.20by.20rfl.20succeeds.2E/near/426192361\">said</a>:</p>\n<blockquote>\n<p>I see, thanks. In that case wouldn’t it make sense for the proof term generated with by rfl to indicate that higher evaluation depth is needed?</p>\n</blockquote>\n<p>It's weird that <code>Eq.refl</code> is the proof generated by <code>by rfl</code>, right?</p>\n<p>There are two type checkers in the Lean system: the elaborator's and the kernel's. The kernel typechecker is simpler (you might say it's \"lean\"), and the elaborator's typechecker is meant to help with everything that needs to be done during elaboration. The elaborator's typechecker tends to be more conservative than the kernel's, and it also has these different definition transparency levels to help control what gets unfolded and when.</p>\n<p>Tactics do not need to create proof terms that would pass the elaborator's typechecker (so long as they pass the kernel's), and apparently <code>rfl</code> in this case is generating such a proof term.</p>\n<p>It's possible that it's not a matter of transparency — that was just a guess — and it could be from some other difference between the elaborator and the kernel.</p>\n</blockquote>\n<p>Thanks, I understand that now. I do wonder how elaborator chooses which terms to expand though. Originally I thought it didn’t look inside any top level definitions, but that doesn’t seem to be the case - simple definitions like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">two</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">two</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">Eq.refl</span> <span class=\"n\">two</span> <span class=\"mi\">2</span>\n</code></pre></div>\n<p>are accepted by the elaborator. What is the cutoff? Is it based on term size?</p>",
        "id": 426227671,
        "sender_full_name": "Iurii Zamiatin",
        "timestamp": 1710285024
    },
    {
        "content": "<p>In Lean 3, definitions were semireducible by default, and maybe the same is true in Lean 4. semireducible is one of three transparency levels (the middle one).</p>",
        "id": 426227901,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710285160
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">irreducible</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">two</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">two</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">Eq.refl</span> <span class=\"n\">two</span> <span class=\"c1\">-- fails -- but `by rfl` works</span>\n</code></pre></div>",
        "id": 426227984,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710285220
    },
    {
        "content": "<p>No, it's not based on term size, and it (usually) has to do with the reducibility of a definition: <code>@[reducible]</code>, class projections of instances, semireducible, and <code>@[irreducible]</code>, like what Kevin is saying.</p>\n<p>In this case, it turns out to do with a feature called \"smart unfolding\". This causes recursive definitions to unfold in a nicer way that omits the internal details of recursors.</p>\n<p>One way to avoid this is the <code>delta</code> tactic, which unfolds without doing smart unfolding:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">div2</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">div2</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">m</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">div2'</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">div2'</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">m</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">div2</span> <span class=\"n\">div2'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">delta</span> <span class=\"n\">div2</span> <span class=\"n\">div2'</span>\n  <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Another is to turn off smart unfolding:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">smartUnfolding</span> <span class=\"n\">false</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">div2</span> <span class=\"n\">div2'</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 426228335,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710285395
    }
]