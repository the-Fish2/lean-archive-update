[
    {
        "content": "<p>I'm wondering a few things:</p>\n<ol>\n<li>How do I debug a case where two things should be equal, but aren't. I've got a situation where two things in the goal are exactly equal except for parts that are in Prop, so I'm not sure why <code>rfl</code> isn't working on them.</li>\n<li>Is there a way to avoid DTT hell when dealing with over-categories? I'm trying to prove a lemma about Grothendieck Topologies on over-categories. Is there a better solution than pattern-matching when going between properties of arrows in the base and over-categories?</li>\n</ol>\n<p>Here's a working example, maybe not too minimal but at least self-contained. It's trying to formalize part of C2.2.17 from Sketches of an Elephant. At the end I get an error trying to unify <code>(hₖs (CommaMorphism.mk θ rt) (_ : R.arrows (CommaMorphism.mk θ rt))).left</code> and <code>(hₖs (CommaMorphism.mk θ rt) inR).left</code> which are (as far as I can see) equal except for Prop-valued proofs.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Category.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Functor.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Comma.Over</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Sites.Over</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Sites.Sieves</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">cat</span> <span class=\"o\">:</span> <span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v'</span><span class=\"o\">}</span>  <span class=\"n\">C</span><span class=\"o\">]</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">baseFamily</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">⟶</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">⟶</span> <span class=\"n\">U</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">Sieve</span> <span class=\"o\">(</span><span class=\"n\">Over.mk</span> <span class=\"n\">f</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">hₖs</span> <span class=\"o\">:</span> <span class=\"n\">Presieve.FamilyOfElements</span> <span class=\"o\">(</span><span class=\"n\">yoneda.obj</span> <span class=\"o\">(</span><span class=\"n\">Over.mk</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"n\">R.arrows</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">Presieve.FamilyOfElements</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">yoneda.obj</span> <span class=\"n\">W</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">Sieve.overEquiv</span> <span class=\"o\">(</span><span class=\"n\">Over.mk</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">arrows</span>\n    <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intros</span> <span class=\"n\">k</span> <span class=\"n\">hk</span> <span class=\"n\">in_hₖs</span>\n      <span class=\"k\">let</span> <span class=\"n\">inR</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Sieve.overEquiv_iff</span> <span class=\"n\">R</span> <span class=\"n\">hk</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">in_hₖs</span>\n      <span class=\"k\">let</span> <span class=\"n\">sliceArrow</span> <span class=\"o\">:=</span> <span class=\"n\">hₖs</span> <span class=\"n\">_</span> <span class=\"n\">inR</span>\n      <span class=\"n\">apply</span> <span class=\"n\">sliceArrow.left</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">baseArrowsIff</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">⟶</span> <span class=\"n\">U</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">Sieve</span> <span class=\"o\">(</span><span class=\"n\">Over.mk</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Over</span> <span class=\"n\">U</span><span class=\"o\">))</span>\n  <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">Over</span> <span class=\"n\">U</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">θ</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Over.mk</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">R.arrows</span> <span class=\"n\">θ</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">Sieve.overEquiv</span> <span class=\"o\">(</span><span class=\"n\">Over.mk</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">θ.left</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">have</span> <span class=\"n\">unfld</span> <span class=\"o\">:</span>  <span class=\"n\">R.arrows</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Sieve.overEquiv</span> <span class=\"o\">(</span><span class=\"n\">Over.mk</span> <span class=\"n\">f</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">Sieve.overEquiv</span> <span class=\"o\">(</span><span class=\"n\">Over.mk</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">unfld</span><span class=\"o\">]</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Sieve.overEquiv_symm_iff</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">overPreserveAmalg</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span>  <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">⟶</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">⟶</span> <span class=\"n\">W</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">Sieve</span> <span class=\"o\">(</span><span class=\"n\">Over.mk</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span><span class=\"o\">)))</span>\n<span class=\"o\">{</span><span class=\"n\">hₖs</span> <span class=\"o\">:</span> <span class=\"n\">Presieve.FamilyOfElements</span> <span class=\"o\">(</span><span class=\"n\">yoneda.obj</span> <span class=\"o\">(</span><span class=\"n\">Over.mk</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"n\">R.arrows</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">isAmalg</span> <span class=\"o\">:</span> <span class=\"n\">Presieve.FamilyOfElements.IsAmalgamation</span> <span class=\"o\">(</span><span class=\"n\">baseFamily</span> <span class=\"n\">R</span> <span class=\"n\">hₖs</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"o\">)</span>\n    <span class=\"o\">:</span> <span class=\"n\">Presieve.FamilyOfElements.IsAmalgamation</span> <span class=\"n\">hₖs</span> <span class=\"o\">(</span><span class=\"n\">Over.homMk</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Presieve.FamilyOfElements.IsAmalgamation</span><span class=\"o\">,</span> <span class=\"n\">baseFamily</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">isAmalg</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Presieve.FamilyOfElements.IsAmalgamation</span><span class=\"o\">,</span> <span class=\"n\">baseFamily</span><span class=\"o\">]</span>\n    <span class=\"n\">intros</span> <span class=\"n\">Y</span> <span class=\"n\">θ</span> <span class=\"n\">inR</span>\n    <span class=\"n\">simp_all</span> <span class=\"o\">[</span><span class=\"n\">Over.homMk</span><span class=\"o\">,</span> <span class=\"n\">CostructuredArrow.homMk</span><span class=\"o\">]</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">θ</span><span class=\"o\">,</span> <span class=\"n\">rt</span><span class=\"o\">,</span> <span class=\"n\">eq</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">θ</span>\n    <span class=\"k\">let</span> <span class=\"n\">inRbase</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">baseArrowsIff</span> <span class=\"n\">R</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">inR</span>\n    <span class=\"k\">let</span> <span class=\"n\">lem</span> <span class=\"o\">:=</span> <span class=\"n\">isAmalg</span> <span class=\"n\">θ</span> <span class=\"n\">inRbase</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Over.OverMorphism.ext</span>\n    <span class=\"n\">simp</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Eq.trans</span> <span class=\"n\">lem</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Presieve.FamilyOfElements</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hₖs</span>\n    <span class=\"k\">have</span> <span class=\"n\">eqrt</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">:</span>  <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">rt</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop_cat</span>\n    <span class=\"k\">have</span> <span class=\"n\">eqinR</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">:</span>  <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">inR</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop_cat</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">eqrt</span><span class=\"o\">,</span> <span class=\"n\">eqinR</span><span class=\"o\">]</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Eq.refl</span>\n</code></pre></div>",
        "id": 439281217,
        "sender_full_name": "Joey Eremondi",
        "timestamp": 1715974350
    },
    {
        "content": "<p>One trick is to use <code>convert</code> in place of <code>exact</code> or <code>congr!</code> in place of <code>rfl</code>. These try to tear through expressions, reducing the issue to the parts that aren't obviously defeq. (They can also sometimes prove equalities that aren't true by defeq.)</p>",
        "id": 439287909,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715977894
    },
    {
        "content": "<p>In this case, the structure morphism of <code>Y/U</code> are different on the two sides. It is <code>θ ≫ h ≫ g</code> on the LHS and <code>Y.hom</code> on the RHS.</p>",
        "id": 439288298,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1715978083
    }
]