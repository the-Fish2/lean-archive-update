[
    {
        "content": "<p>I have the following minified problem, where applying the equation <code>h</code> doesn't work, which is likely because <code>D t</code> depends on <code>t</code> as in the definition of <code>S</code>, but I have no idea how to work around this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">def</span> <span class=\"n\">mwe</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">t</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">D</span> <span class=\"n\">t</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">d</span>\n  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"c1\">-- tactic 'rewrite' failed, motive is not type correct</span>\n  <span class=\"c1\">-- I want the goal to become `P t d`</span>\n</code></pre></div>",
        "id": 409266443,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1703109270
    },
    {
        "content": "<p>What does your <code>D</code> type look like in the non-minified example? Is it a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subsingleton#doc\">docs#Subsingleton</a> ?</p>",
        "id": 409267401,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703109721
    },
    {
        "content": "<p>Try <code>simp only [h]</code> or <code>simp_rw [h]</code>.(but I guess I'm not optimistic). Your diagnosis is correct but sometimes these hacks get around it. What do you expect the rewrite to turn <code>d</code> into?</p>",
        "id": 409267426,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1703109724
    },
    {
        "content": "<p>Your goal definitely can't be <code>P t d</code>, but you can rewrite <code>t</code> if you're willing to insert an <code>Eq.rec</code>. Here's one way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mwe</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">t</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">D</span> <span class=\"n\">t</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">d</span>\n  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">convert_to</span> <span class=\"n\">P</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">‚ñ∏</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n  <span class=\"bp\">¬∑</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">heq_rec_iff_heq</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- ‚ä¢ P t (h ‚ñ∏ d)</span>\n</code></pre></div>",
        "id": 409267902,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703109919
    },
    {
        "content": "<p>It is not a subsingleton, it can have many different values.</p>",
        "id": 409267905,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1703109921
    },
    {
        "content": "<p>Ok, I asked about subsingletons because if it is you can write a congr lemma to deal with the issue and get <code>simp</code> to be able to rewrite the <code>t</code> argument (assuming <code>P</code> is an actual predicate you have somewhere, rather than an argument to a <code>def</code>)</p>",
        "id": 409268039,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703109986
    },
    {
        "content": "<p>Here's another way that does essentially the same thing as <code>convert_to</code> but it's more explicit.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mwe</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">t</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">D</span> <span class=\"n\">t</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">d</span>\n  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">P</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">‚ñ∏</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">congr</span><span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">$</span><span class=\"n\">h</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">heq_of_eq_rec_left</span> <span class=\"n\">h</span> <span class=\"n\">rfl</span><span class=\"o\">))</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- ‚ä¢ P t (h ‚ñ∏ d)</span>\n</code></pre></div>",
        "id": 409268242,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703110086
    },
    {
        "content": "<p>(These \"congr quotations\" come from <code>Mathlib.Tactic.TermCongr</code>)</p>",
        "id": 409268338,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703110147
    },
    {
        "content": "<p>This should be a <code>theorem</code> not a <code>def</code> because <code>P _ _</code> is a <code>Prop</code></p>",
        "id": 409268437,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703110202
    },
    {
        "content": "<p>I don't have mathlib set up right now unfortunately, but if none of the other approaches work I'll give it a try tomorrow at the latest.</p>",
        "id": 409268483,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1703110209
    },
    {
        "content": "<p>Ah they all need mathlib stuff :)</p>",
        "id": 409268542,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1703110246
    },
    {
        "content": "<p>It's worth knowing how to do it by hand:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">mwe</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">t</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">D</span> <span class=\"n\">t</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">d</span>\n  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">P</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">‚ñ∏</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span> <span class=\"n\">d</span>\n    <span class=\"n\">subst</span> <span class=\"n\">h</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- ‚ä¢ P t (h ‚ñ∏ d)</span>\n</code></pre></div>",
        "id": 409268800,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703110347
    },
    {
        "content": "<p>The mathlib stuff automates this sort of thing.</p>",
        "id": 409268843,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703110368
    },
    {
        "content": "<p>The key here is that when there are complicated dependent types, you need to write a \"congruence lemma\", where everything that could be rewritten is a free variable, and the proof is just <code>subst</code> of all the equality hypotheses followed by <code>rfl</code>.</p>",
        "id": 409268962,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703110428
    },
    {
        "content": "<p>That sounds like a good strategy, I'll definitely keep that in mind!</p>",
        "id": 409269423,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1703110647
    },
    {
        "content": "<p>(Some probably needless context: The original <code>D</code> type is the displayed algebra, i.e. the stuff you put into a recursor. I am trying to implement section 2.3.2, definition \\iota^E, of <a href=\"https://andraskovacs.github.io/pdfs/phdthesis_compact.pdf\">https://andraskovacs.github.io/pdfs/phdthesis_compact.pdf</a> .)</p>",
        "id": 409269743,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1703110813
    },
    {
        "content": "<p>One design decision you might want to make is to create a <code>D.cast</code> operation that is for restricting the <code>Eq.rec</code> to just the type parameter/index. You can make better simp lemmas for <code>D.cast</code> than you can for unrestricted <code>Eq.rec</code>.</p>",
        "id": 409270721,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703111353
    },
    {
        "content": "<p>That is a good idea! I hope I get that far to actually need simp lemmas.</p>",
        "id": 409271128,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1703111539
    },
    {
        "content": "<p>Your strategy worked, Kyle, and I managed to <em>finally</em> close my goal after half a day of confusion. Thank you so much!</p>",
        "id": 409273435,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1703112787
    },
    {
        "content": "<p>I'm definitely taking the \"congruence lemma\" trick away from this!</p>",
        "id": 409273473,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1703112810
    }
]