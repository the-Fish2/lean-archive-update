[
    {
        "content": "<p>In a forthcoming analytic number theory formalization project, we would like to use <code>Nat.ArithmeticFunction</code> as well as complex analysis.  In analytic number theory it is traditional to write the complex variable as <code>s = σ + I*t</code>, which causes a conflict because <code>Nat.ArithmeticFunction</code> includes <code>scoped</code> <code>notation</code> (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.ArithmeticFunction#doc\">docs#Nat.ArithmeticFunction</a>.termσ) that defines <code>σ</code> as <code>Nat.ArithmeticFunction.sigma</code>, thus for instance the following code fails unless <code>ArithmeticFunction</code> is not <code>open</code>ed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Complex</span> <span class=\"n\">Nat</span> <span class=\"n\">ArithmeticFunction</span>\n\n<span class=\"n\">proof_wanted</span> <span class=\"n\">riemann_hypothesis</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">riemannZeta</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">+</span> <span class=\"n\">I</span><span class=\"bp\">*</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>Is there a way to hide the <code>scoped</code> <code>notation</code> <code>σ</code> from the <code>open</code>ing of <code>ArithmeticFunction</code>?  I tried <code>open ArithmeticFunction hiding termσ</code> and <code>open ArithmeticFunction hiding sigma</code> but these did not work. One could of course rename the variable <code>σ</code> to something else like <code>σ'</code> but we don't plan on using <code>Nat.ArithmeticFunction.sigma</code> and it would be more elegant to somehow suppress the notation while retaining access to the arithmetic functions (such as <code>Λ</code>, the von Mangoldt function) that we do wish to use.</p>",
        "id": 418117690,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706200185
    },
    {
        "content": "<p>This is a ridiculously hacky workaround that is honestly a bug, but if you do <code>open ArithmeticFunction renaming ... -&gt; ...</code> it should work. This is because the <code>renaming</code> elaborator forgets to run <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=activateScoped#doc\">docs#activateScoped</a></p>",
        "id": 418122574,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706201613
    },
    {
        "content": "<p>(do that in the next line, and with the ... being some name in the ArithmeticFunction namespace - you can rename something to itself)</p>",
        "id": 418122663,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706201642
    },
    {
        "content": "<p>(<a href=\"https://github.com/leanprover/lean4/blob/b614ff1d12bc38f39077f9ce9f2d48b42c003ad0/src/Lean/Elab/Open.lean#L60-L97\">https://github.com/leanprover/lean4/blob/b614ff1d12bc38f39077f9ce9f2d48b42c003ad0/src/Lean/Elab/Open.lean#L60-L97</a> if anyone wants to file a core bug)</p>",
        "id": 418122855,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706201697
    },
    {
        "content": "<p>Could you provide a mwe of your hack?  The <code>...</code> does not compile, and replacing it with say <code>σ</code> doesn't seem to work either.</p>",
        "id": 418124911,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706202311
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Complex</span> <span class=\"n\">Nat</span>\n<span class=\"kn\">open</span> <span class=\"n\">ArithmeticFunction</span> <span class=\"kn\">renaming</span> <span class=\"n\">sigma</span> <span class=\"bp\">→</span> <span class=\"n\">sigma</span>\n\n<span class=\"n\">proof_wanted</span> <span class=\"n\">riemann_hypothesis</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">riemannZeta</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">+</span> <span class=\"n\">I</span><span class=\"bp\">*</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 418126109,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706202652
    },
    {
        "content": "<p>Hmm.  Unfortunately that also disables the notation that we <em>did</em> want to use from <code>Nat.ArithmeticFunction</code>, such as <code> Λ</code>, so now other parts of the code stop working (in this case, the second <code>proof_wanted</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Complex</span> <span class=\"n\">Nat</span>\n<span class=\"kn\">open</span> <span class=\"n\">ArithmeticFunction</span> <span class=\"kn\">renaming</span> <span class=\"n\">sigma</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">sigma</span>\n\n\n<span class=\"n\">proof_wanted</span> <span class=\"n\">riemann_hypothesis</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">riemannZeta</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">+</span> <span class=\"n\">I</span><span class=\"bp\">*</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">coe</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">ofReal</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ArithmeticFunction</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ArithmeticFunction</span> <span class=\"n\">ℂ</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">n</span>\n  <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Nat.ArithmeticFunction.map_zero</span><span class=\"o\">,</span> <span class=\"n\">ofReal_zero</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">realCoe</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">ArithmeticFunction</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ArithmeticFunction</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">ofReal</span><span class=\"o\">⟩</span>\n\n<span class=\"n\">proof_wanted</span> <span class=\"n\">von_mangoldt_and_zeta</span> <span class=\"o\">(</span><span class=\"n\">σ'</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">σ'</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">LSeries</span> <span class=\"bp\">Λ</span> <span class=\"o\">(</span><span class=\"n\">σ'</span> <span class=\"bp\">+</span> <span class=\"n\">I</span><span class=\"bp\">*</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span> <span class=\"n\">deriv</span> <span class=\"n\">riemannZeta</span> <span class=\"o\">(</span><span class=\"n\">σ'</span> <span class=\"bp\">+</span> <span class=\"n\">I</span><span class=\"bp\">*</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"n\">riemannZeta</span> <span class=\"o\">(</span><span class=\"n\">σ'</span> <span class=\"bp\">+</span> <span class=\"n\">I</span><span class=\"bp\">*</span><span class=\"n\">t</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 418126616,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706202797
    },
    {
        "content": "<p>from reading the code, I don't think there's currently any way to do this, sadly. I think there's a good case for it, however</p>",
        "id": 418129781,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706203753
    },
    {
        "content": "<p>Huh.  Hopefully there will be a better fix in the future.  I guess for now we just use <code>σ'</code> instead of <code>σ</code>.</p>",
        "id": 418130369,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706203940
    },
    {
        "content": "<p>Your second <code>proof_wanted</code> is available in my <a href=\"https://github.com/MichaelStollBayreuth/EulerProducts\">EulerProducts</a> repository, BTW. (In terms of a complex variable <code>s</code> with real part <code>&gt; 1</code>.)</p>",
        "id": 418133976,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706205044
    },
    {
        "content": "<p>Guess my project is 50% complete then <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 418135622,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706205604
    },
    {
        "content": "<p>I don't think there's a way to turn off notation after it's been added.</p>\n<p>I think we should be more careful about which namespace notation goes in. In this case, perhaps it would be better in <code>Nat.ArithmeticFunction.Notation</code></p>",
        "id": 418141810,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706207871
    },
    {
        "content": "<p>Off-topic: I think the \"Nat.\" part in <code>Nat.ArithmeticFunction</code> is a bit redundant. Maybe we can just use <code>ArithmeticFunction</code> for the namespace?</p>",
        "id": 418142780,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706208230
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/How.20do.20you.20hide.20scoped.20notation/near/418141810\">said</a>:</p>\n<blockquote>\n<p>I don't think there's a way to turn off notation after it's been added.</p>\n<p>I think we should be more careful about which namespace notation goes in. In this case, perhaps it would be better in <code>Nat.ArithmeticFunction.Notation</code></p>\n</blockquote>\n<p>In the code above, Terry seems to want some of the notation in that namespace and not some of the others. Wasn't there going to be a change to force notations to be named?</p>",
        "id": 418143015,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706208320
    },
    {
        "content": "<p>So can one import only selected notations?</p>",
        "id": 418143119,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706208361
    },
    {
        "content": "<p>(instead of hiding some)</p>",
        "id": 418143179,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706208373
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> Oh, I see. Even if notations are named, right now it seems you can't turn any off (<code>term_parser</code> is one of those un-erasable attributes)</p>",
        "id": 418143732,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706208608
    },
    {
        "content": "<p>It seems to be possible to import individual notations, if you know the name of their parser:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Complex</span> <span class=\"n\">Nat</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">term_parser</span><span class=\"o\">]</span> <span class=\"n\">ArithmeticFunction.term</span><span class=\"bp\">Λ</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">Λ</span>\n</code></pre></div>\n<p>That doesn't enable the pretty printer however.</p>",
        "id": 418144033,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706208736
    },
    {
        "content": "<p>I suppose another solution then is to have a separate namespace per notation, so that way you can <code>open scoped</code> whatever you want to enable.</p>",
        "id": 418144150,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706208796
    },
    {
        "content": "<p>I think separately from this specific use-case it'd be nice to have some version of <code>open</code> that didn't <code>open scoped</code>, (well, without the current hacky workaround)</p>",
        "id": 418144758,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706209028
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/How.20do.20you.20hide.20scoped.20notation/near/418144150\">said</a>:</p>\n<blockquote>\n<p>I suppose another solution then is to have a separate namespace per notation, so that way you can <code>open scoped</code> whatever you want to enable.</p>\n</blockquote>\n<p>Actually I imagine that would come with its own problems, for instance in this particular case the <code>σ</code> notation is used in the statement of several further lemmas in <code>ArithmeticFunction</code> and so it doesn't seem obvious to me how to select  lemmas and notation \"a la carte\" without having to unfold any notation in a lemma that one opened without opening the supporting notation.  For this particular use case we plan to use quite a few tools and notations from <code>ArithmeticFunction</code>, so selectively introducing a handful of targeted notations and lemmas isn't ideal here, but it's good to know that <em>some</em> option to partially introduce notation from a namespace exists.</p>",
        "id": 418163262,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706216172
    },
    {
        "content": "<p>It might be possible (using either current or potential future features) to have a la carte scoped notations that can be bundled up into a particular other namespace.</p>\n<p>For example, we currently have <code>export</code> as an alternative to <code>open</code> to cause certain names to be available to those who <code>open</code> the namespace they were <code>export</code>ed to. I don't know how scoped interacts with export at the moment.</p>\n<p>I don't know if this would help you, but I'm interested in figuring out what would be helpful and am exploring the nearby design space.</p>",
        "id": 418164741,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706216747
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/How.20do.20you.20hide.20scoped.20notation/near/418164741\">said</a>:</p>\n<blockquote>\n<p>It might be possible (using either current or potential future features) to have a la carte scoped notations that can be bundled up into a particular other namespace.</p>\n<p>For example, we currently have <code>export</code> as an alternative to <code>open</code> to cause certain names to be available to those who <code>open</code> the namespace they were <code>export</code>ed to. I don't know how scoped interacts with export at the moment.</p>\n<p>I don't know if this would help you, but I'm interested in figuring out what would be helpful and am exploring the nearby design space.</p>\n</blockquote>\n<p>I could imagine an a la carte bundling option to be useful for educational purposes.  For instance to create \"natural number game\" like environments where a select number of tools from a namespace (together with whatever notation was needed in order to state those tools) were made readily available without access to the entire namespace.</p>",
        "id": 418166958,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706217772
    },
    {
        "content": "<p><code>open scoped SomeNamespace (nameOfSomeNotation nameOfSomeOtherNotation)</code> is the syntax I would be expecting</p>",
        "id": 418171017,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706219799
    },
    {
        "content": "<p>For the time being, <a href=\"https://github.com/leanprover-community/mathlib4/pull/10403\">#10403</a> adds separate scopes for the notations for arithmetic functions (like <code>ArithmeticFunction.sigma</code> or <code>ArithmeticFunction.vonMangoldt</code>), so that it will be possible to make a selection of the notations one would like to import. (<code>open scoped ArithmeticFunction</code> will still give access to all of them.)</p>",
        "id": 420804355,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1707575357
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/10403\">#10403</a> has just been merged.</p>",
        "id": 421023913,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1707742516
    },
    {
        "content": "<p>Should we also move notation for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.primeCounting#doc\">docs#Nat.primeCounting</a> to another scope? Currently <code>open scoped Nat Real</code> creates a conflict for <code>π</code> (I wanted to have notation for <code>Real.pi</code> and <code>Nat.factorial</code> in one file).</p>",
        "id": 422745955,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708575715
    }
]