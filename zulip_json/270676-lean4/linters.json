[
    {
        "content": "<p>Hi, where can I read about (a) builtin linters; (b) std4 linters? What is the difference between two approaches? I want to forward-port some missing linters from mathlib3 and add new ones, and I need docs and/or examples to do that.</p>",
        "id": 418001120,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706152000
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span>?</p>",
        "id": 418193086,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706233017
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span></p>\n<p>The mathlib linters from lean 3 were ported to what are now the std linters. These run at the end of processing a file or the whole library, using <code>#lint</code> or in a separate stage in CI. They see all declarations in the environment, so they are good for things where even autogenerated definitions need to be linted, but they don't have access to the original syntax so they can't detect things like using the wrong tactics to do something, or bad formatting. These linters are disabled using <code>@[nolint foo]</code> or the <code>nolints.json</code> file.</p>\n<p>The lean core linters are new in lean 4, and they trigger immediately after parsing each command. As a result they are better for giving \"live feedback\", but they are only given the syntax of the command, which means it can be difficult to even determine what things in the environment correspond to it. The elaboration info tree is available however, so these are well suited to linters that want to remark on syntactic things like use of deprecated definitions, unreachable tactics, or unused variables, and the results appear immediately in the editor. These lints are disabled using <code>set_option linter.foo false</code> before the command.</p>\n<p>All unported linters are of the std linter kind, because that was the only kind we had in lean 3. But it's possible that they can be reimagined as lean core linters. (We also need better names for both kinds of linters, because neither one really subsumes the other and it's confusing to call them the same.)</p>",
        "id": 418386221,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706329495
    },
    {
        "content": "<p>Is there any documentation for people who want to write these linters (of either kind), or should I look at the source of existing linters and learn from there?</p>",
        "id": 418460991,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706404610
    },
    {
        "content": "<p>there is nothing I am aware of. The linter APIs themselves are fairly simple, but you will want to copy other linters anyway to see the techniques for doing useful things from them</p>",
        "id": 418461563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706405246
    },
    {
        "content": "<p>example of a std linter: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.Tactic.Lint.defLemma#src\">src#Std.Tactic.Lint.defLemma</a></p>",
        "id": 418461644,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706405325
    },
    {
        "content": "<p>Thank you! I'll start porting the <code>fintype</code>/<code>decidable</code>/<code>encodable</code>/... linter and ask more questions here tomorrow.</p>",
        "id": 418462160,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706405908
    },
    {
        "content": "<p>I would love to see some of the knowledge one can get from analyzing the existing linters to be put down into text somewhere, so it can become less of an arcane art</p>",
        "id": 418517007,
        "sender_full_name": "Emilie (Shad Amethyst)",
        "timestamp": 1706460411
    },
    {
        "content": "<p>How do I run a specific linter on a specific declaration?</p>",
        "id": 419646243,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706998286
    },
    {
        "content": "<p>Another question: given a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr#doc\">docs#Lean.Expr</a> of the form <code>.forallE name type body info</code>, how do I check if <code>body</code> uses this variable?</p>",
        "id": 419654756,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707006904
    },
    {
        "content": "<p>If you want to run a linter on a declaration using the metaprogramming API it looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"k\">#eval</span> <span class=\"n\">Option.isSome</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">Std.Tactic.Lint.docBlame.test</span> <span class=\"bp\">``</span><span class=\"n\">foo</span>\n</code></pre></div>",
        "id": 419658918,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707011522
    },
    {
        "content": "<p>If your expression has no loose bvars (which is generally an invariant for expressions in MetaM) then you can use <code>!body.hasLooseBVars</code> to check if the forall is dependent (or call <code>isArrow</code> which does both this and the <code>forallE</code> match)</p>",
        "id": 419659019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707011638
    },
    {
        "content": "<p>And what's the right way to descend inside an expr to maintain the \"no loose bvars\" invariant?</p>",
        "id": 419659095,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707011718
    },
    {
        "content": "<p>either instantiate <code>body</code> with an expression of type <code>type</code> if you have one, or instantiate it with a fresh mvar of that type, or use <code>withLocalDecl</code> to create a fvar of the type and instantiate <code>body</code> with that</p>",
        "id": 419659168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707011792
    },
    {
        "content": "<p>using <code>instantiate1</code></p>",
        "id": 419659175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707011812
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>: I need Lean 4 version of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/get_pi_binders_nondep\">docs3#get_pi_binders_nondep</a> for the linter.</p>",
        "id": 419659190,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707011826
    },
    {
        "content": "<p>I'll try.</p>",
        "id": 419659215,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707011864
    },
    {
        "content": "<p>I would suggest modeling that function after <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.forallTelescope#src\">src#Lean.Meta.forallTelescope</a></p>",
        "id": 419659277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707011908
    },
    {
        "content": "<p>in particular, it needs to pass its return variables in continuation passing style because the local variables have to exist in an extended context</p>",
        "id": 419659298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707011944
    },
    {
        "content": "<p>in fact, you might even just do this by calling <code>forallTelescope</code> and postprocessing the returned <code>Array Expr</code> into the desired form</p>",
        "id": 419659478,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707012091
    },
    {
        "content": "<p>and then you don't have to worry about the instantiating and local variable creation</p>",
        "id": 419659493,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707012122
    },
    {
        "content": "<p>AFAICS, <code>forallTelescope</code> won't allow me to use <code>isArrow</code></p>",
        "id": 419663788,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707015902
    },
    {
        "content": "<p>Maybe you could take a look at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.getFunInfo#doc\">docs#Lean.Meta.getFunInfo</a>, which processes dependencies between arguments</p>",
        "id": 419664283,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707016542
    },
    {
        "content": "<p>I'll have a look</p>",
        "id": 419664428,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707016698
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 419664431,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707016703
    },
    {
        "content": "<p>Maybe would be a good chapter for the metaprogramming book</p>",
        "id": 419665614,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707018148
    },
    {
        "content": "<p>(linters, as a topic)</p>",
        "id": 419665618,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707018159
    },
    {
        "content": "<p>You may want to do too many things in a linter...</p>",
        "id": 419665640,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707018193
    },
    {
        "content": "<p>BTW, where can I read about <code>for</code> loops in Lean 4?</p>",
        "id": 419666146,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707018841
    },
    {
        "content": "<p><a href=\"https://lean-lang.org/papers/do.pdf\">https://lean-lang.org/papers/do.pdf</a> ?</p>",
        "id": 419666832,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707019612
    },
    {
        "content": "<p>or are you looking for the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ForIn#doc\">docs#ForIn</a> class?</p>",
        "id": 419666849,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707019630
    },
    {
        "content": "<p>Thank you for both links! It looks like I need neither of them right now but I'll read them tomorrow or on Monday.</p>",
        "id": 419666923,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707019693
    },
    {
        "content": "<p>How do I check if a given <code>Expr</code> is of the form <code>∀ _ _ _, Decidable _</code>?</p>",
        "id": 419668096,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707021166
    },
    {
        "content": "<p>Use <code>forallTelescopeReducing</code> (reducing is for handling <code>DecidableRel</code> and such, do <code>forallTelescope</code> if you don't want that), and then for the expr <code>e</code> that it passes to the continuation, do <code>e.isAppOfArity ``Decidable 2</code></p>",
        "id": 419668381,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707021439
    },
    {
        "content": "<p>I'm using <code>t.getForallBody.isAppOf</code></p>",
        "id": 419668386,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707021452
    },
    {
        "content": "<p>Ok, that's fine -- equivalent to using <code>forallTelescope</code>, but faster since it doesn't instantiate anything, which you don't need here if you're just checking for <code>Decidable</code>.</p>",
        "id": 419668478,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707021559
    },
    {
        "content": "<p>First draft: <a href=\"https://github.com/leanprover-community/mathlib4/tree/YK-dec-lint\">branch#YK-dec-lint</a></p>",
        "id": 419668890,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707021976
    },
    {
        "content": "<p>Heavily based on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.Tactic.Lint.impossibleInstance#doc\">docs#Std.Tactic.Lint.impossibleInstance</a></p>",
        "id": 419668906,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707022009
    },
    {
        "content": "<p>I know that it doesn't auto ignore decls in <code>Decidable.</code> yet.</p>",
        "id": 419668920,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707022051
    },
    {
        "content": "<p>Three comments:</p>\n<ul>\n<li>Rather than <code>(← inferType (← mkConstWithLevelParams declName))</code> you can do <code>(← getConstInfo declName).type</code> like before</li>\n<li>Rather than <code>if !... then</code> you can use <code>unless ... do</code></li>\n<li>I'm not sure they ever appear in the wild, but to deal with optParams and such you can do <code>t.cleanupAnnotations.getForallBody.isAppOf</code></li>\n</ul>",
        "id": 419669914,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707023101
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 419670136,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707023367
    },
    {
        "content": "<p>I'll wait for the CI, then fix the issues.</p>",
        "id": 419670205,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707023430
    },
    {
        "content": "<p>While I'm fixing issues found by this linter, I would appreciate hints for writing a more advanced linter that also catches <code>def</code>initions that assume <code>[Decidable _]</code>, then use it for proofs only.</p>",
        "id": 419680146,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707034859
    },
    {
        "content": "<p>I think that would just be asserting that the <code>[Decidable _]</code> binder is nondependent in the theorem's type</p>",
        "id": 419680219,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707034926
    },
    {
        "content": "<p>I meant telling</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ex1</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>from</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ex1</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp'</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">//</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"n\">hp</span> <span class=\"n\">h</span> <span class=\"k\">else</span> <span class=\"n\">hp'</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 419680389,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707035136
    },
    {
        "content": "<p>(of course, IRL <code>p</code> will depend on <code>n</code>)</p>",
        "id": 419680452,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707035166
    },
    {
        "content": "<p>The current implementation does what mathlib3 version did (minus ignoring <code>Decidable.*</code> and <code>Encodable.*</code> for now) but while looking at lint errors, I found some definitions that use decidability for proofs only.</p>",
        "id": 419680617,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707035366
    },
    {
        "content": "<p>hm, I'll take a look at that tomorrow</p>",
        "id": 419680728,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707035459
    },
    {
        "content": "<p>BTW, how do I ask if the definition is computable?</p>",
        "id": 419681021,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707035791
    },
    {
        "content": "<p>I haven't tested it, but something you could do is take the body and erase all the proofs with something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">eraseProofs</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Meta.transform</span> <span class=\"n\">e</span>\n    <span class=\"o\">(</span><span class=\"n\">pre</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">Meta.isProof</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n        <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">done</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkSyntheticSorry</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n      <span class=\"k\">else</span>\n        <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">continue</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and then check whether the fvars for the Decidable instances are present.</p>\n<p>For interfacing the forallTelescope with the declaration value to get the body, you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr.beta#doc\">docs#Lean.Expr.beta</a> rather than mkAppN</p>\n<p><code>Expr.beta</code> is to make sure the fvars actually get sunk into the expression. This erasure idea though doesn't detect whether there's some <code>have</code>/<code>let</code> outside the proof that's only used within the proof. I guess for this the transform could also do zeta reduction if that's something you want to handle?</p>",
        "id": 419681022,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707035793
    },
    {
        "content": "<p>IMHO, noncomputable definitions should be treated like theorems: there is no reason to assume <code>[Decidable]</code> if you're not using it in the type and you aren't going to create a computable definition.</p>",
        "id": 419681074,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707035875
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Thanks, I'll test it tomorrow.</p>",
        "id": 419681124,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707035890
    },
    {
        "content": "<p>I'm not sure I agree with that; you can still compute definitions using <code>Decidable</code> using <code>rfl</code> / <code>by decide</code> even if they are noncomputable</p>",
        "id": 419681177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707035971
    },
    {
        "content": "<p>Let's talk about some specific definition tomorrow. I'm going to bed soon.</p>",
        "id": 419681285,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707036086
    },
    {
        "content": "<p>Sometimes you have a structure with multiple fields, and even though one field is non-computable, you want the other one to be defeq to some other computable construction</p>",
        "id": 419703621,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707057881
    },
    {
        "content": "<p>The one I feel strongly about is Finsupp.single, which really ought to be defeq to Pi.single (but due to the classical decidable stuff in finsupp it currently isn't)</p>",
        "id": 419703642,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707057904
    },
    {
        "content": "<p>This could also be solved with nonconstructive finsupps, right?</p>",
        "id": 419712471,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707065757
    },
    {
        "content": "<p>I suggest the following: once I fix all theorems, I run the linter on noncomputable <code>def</code>s, get a list of matches, then we'll discuss whether it's better to enable it on noncomputable <code>def</code>s and add <code>nolint</code>s or disable it.</p>",
        "id": 419729028,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707078989
    },
    {
        "content": "<p>Another linter idea: find cases of <code>letI</code> or <code>haveI</code> that occur inside proofs, since they could be replaced by <code>let</code> or <code>have</code>, and they're almost certainly accidentally from the port, or from people thinking that the <code>I</code> still stands for \"instance\" (like from Lean 3) rather than \"inline\" (which is now what it is in Lean 4).</p>\n<p>The condition can't just be \"in a proof\". Maybe if the expected type at the <code>letI</code> or <code>haveI</code> is a Prop?</p>\n<p>This would have to be done in consultation with the InfoTrees, since <code>letI</code> and <code>haveI</code> are not present in the elaborated expression.</p>",
        "id": 419729563,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707079485
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/linters/near/419729563\">said</a>:</p>\n<blockquote>\n<p>Another linter idea: find cases of <code>letI</code> or <code>haveI</code> that occur inside proofs, since they could be replaced by <code>let</code> or <code>have</code>, and they're almost certainly accidentally from the port, or from people thinking that the <code>I</code> still stands for \"instance\" (like from Lean 3) rather than \"inline\" (which is now what it is in Lean 4).</p>\n</blockquote>\n<p>Note that it was a conscious decision in mathport to align <code>letI</code> to <code>letI</code> even though the semantics are different, because these are normally used for instances, and it turns out that we generally want them to be inlined too</p>",
        "id": 419743095,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707090326
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I updated the linter so that it should work for <code>def</code>s now (tested on the examples from this thread, awaiting CI).</p>",
        "id": 419761288,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707105925
    }
]