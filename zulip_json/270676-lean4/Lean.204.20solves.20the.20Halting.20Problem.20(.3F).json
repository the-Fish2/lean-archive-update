[
    {
        "content": "<p>What I find remarkable in Lean4 is that when a recursive function is written, some proof of termination is required. In this sense, the programmer is required to have a code terminate in order to have it compile! In this way, does Lean 4 avoid the Halting Problem alltogether or is there any false claims above?</p>",
        "id": 421237991,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1707828843
    },
    {
        "content": "<p>Almost: <em>You</em> have to prove the halting problem. At least if you want to be able to write <em>any</em> terminating function :-)</p>",
        "id": 421238189,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1707828907
    },
    {
        "content": "<p>You can also get around this restriction by using a <code>partial def</code>which is still sound in the type theory due to the tricks involved but can be a non terminating function internally.</p>",
        "id": 421239261,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1707829269
    },
    {
        "content": "<p>Interesting. Another question that comes to mind is whether any termination is provable, or if the proof system will not accept any proof for some programs that arguably terminate. In any sense, the little extent of which i l loooked at termination_by and decreasing_by arguably cover only some \"happy cases\" which have simpler termination proofs</p>",
        "id": 421240862,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1707829891
    },
    {
        "content": "<p>I expect that there are terminating programs for which no proof of termination can be expressed within lean. Maybe Gödel can tell us more.</p>",
        "id": 421242380,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1707830500
    },
    {
        "content": "<p>I think there's some also fundamental limitations to what can be proved to be terminating in Lean, iirc</p>",
        "id": 421243567,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1707830899
    },
    {
        "content": "<p>There's a chance that the Collatz conjecture is true but not provable -- Conway proved that a certain generalisation had this property. So this would give us a function which is impossible to define without sorries or <code>partial</code> / <code>unsafe</code>.</p>",
        "id": 421245185,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707831479
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/Lean.204.20solves.20the.20Halting.20Problem.20.28.3F.29/near/421242380\">said</a>:</p>\n<blockquote>\n<p>I expect that there are terminating programs for which no proof of termination can be expressed within lean. Maybe Gödel can tell us more.</p>\n</blockquote>\n<p>The classic example is the lean typechecker, but that doesn't really work since the typechecker actually doesn't halt under some circumstances. I think the Coq typechecker would work as an example here (i.e. Lean can't prove that the Coq typechecker halts, even though it is believed to halt with suitable large cardinal assumptions)</p>",
        "id": 421245396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707831546
    },
    {
        "content": "<p>However lean's termination checker is \"complete\" in the sense that if you can prove a function terminates, then you can prove it in a <code>termination_by</code> statement</p>",
        "id": 421246769,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707832052
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/Lean.204.20solves.20the.20Halting.20Problem.20.28.3F.29/near/421242380\">said</a>:</p>\n<blockquote>\n<p>I expect that there are terminating programs for which no proof of termination can be expressed within lean. Maybe Gödel can tell us more.</p>\n</blockquote>\n<p>You can't enumerate a set of programs which cover all total computable functions from Nat to Nat (follows from Rice's theorem) but you can enumerate all provably terminating functions in Lean from Nat to Nat (just go through all Lean files and all amounts of time you are willing to wait for the type checker) so there must be total functions which terminate but Lean can't prove.  (Also, it isn't hard to see that terminating is the only issue.  <code>partial def</code> is Turing complete in that you can express all partial computable functions from Nat to Nat.)</p>",
        "id": 421284567,
        "sender_full_name": "Jason Rute",
        "timestamp": 1707842907
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/270676-lean4/topic/Lean.204.20solves.20the.20Halting.20Problem.20.28.3F.29/near/421245185\">said</a>:</p>\n<blockquote>\n<p>There's a chance that the Collatz conjecture is true but not provable</p>\n</blockquote>\n<p>True in the standard model of natural numbers but unprovable in Peano arithmetic?</p>",
        "id": 421299780,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1707848387
    },
    {
        "content": "<p>It looks like the termination of any turing machine can be converted to asking whether or not some generalized Collatz function reaches 1 on a specific input, so Collatz could theoretically be independent of ZFC.</p>",
        "id": 421310565,
        "sender_full_name": "Nir Paz",
        "timestamp": 1707852192
    },
    {
        "content": "<p>ZF+C+CH+CC (collatz conjecture)</p>",
        "id": 421335841,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1707863241
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"565854\">Nir Paz</span> <a href=\"#narrow/stream/270676-lean4/topic/Lean.204.20solves.20the.20Halting.20Problem.20.28.3F.29/near/421310565\">said</a>:</p>\n<blockquote>\n<p>It looks like the termination of any turing machine can be converted to asking whether or not some generalized Collatz function reaches 1 on a specific input, so Collatz could theoretically be independent of ZFC.</p>\n</blockquote>\n<p>Do you have details on this? I haven't heard of \"generalized Collatz\" being turing complete</p>",
        "id": 421369846,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707885876
    },
    {
        "content": "<p>(depending on how much you want to generalize...)</p>",
        "id": 421369886,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707885912
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/FRACTRAN\">FRACTRAN</a> is the most similar turing complete language I'm aware of</p>",
        "id": 421369922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707885940
    },
    {
        "content": "<p>By a generalized Collatz function I mean a function <code>g(n)=n⬝a_(n mod p)+b_(n mod p)</code> where  <code>aᵢ, bᵢ</code> are rationals chosen so that the output is always an integer (the usual function is <code>p=2, a₀=0.5, a₁=3, b₁=1</code>). But for the undecidability we can even let the <code>b</code>'s be <code>0</code>.</p>\n<p>I found the original paper referenced on wikipedia (Unpredictable Iterations, Conway 1972) in a book and went over it, and the proof basically shows that if <code>g</code> is the \"next step function\" of a fractran program, then it's also a collatz function. The proof is surprisingly simple, so modulo the undecidability of fractran it's very short:</p>\n<p>If <code>a₁ / b₁,..., aₙ / bₙ</code> are the rational numbers describing a fractran program, define <code>g(n) = n ⬝ aᵢ / bᵢ</code> for the minimal <code>i</code> such that this is an integer. The completeness of fractran says that the termination of <code>g</code> on a particular input is undecidable (I think?).</p>\n<p>Now look at <code>g(n) / n</code>. This function is periodic, with period some divisor of the lcd of all denominators on the list (I don't see why this is true, but it sounds like pretty simple number theory). So if we name the period <code>P</code>, we get that <code>g(Pk+r)/(Pk+r)=g(r)/r</code>, or <code>g(Pk+r)=g(r)/r⬝(Pk+r)</code>. So <code>g</code> is actually a generalized collatz function!</p>",
        "id": 421496540,
        "sender_full_name": "Nir Paz",
        "timestamp": 1707931844
    },
    {
        "content": "<p>Well I just realized this just shows the undecidability of the question of, given a finite list of rationals, whether a Collatz function reaches a value that doesn't multiply to an integer with of them is, rather than whether it reaches <code>1</code>. If someone is interested they can go look at the paper, it's a bit too much for me.</p>",
        "id": 421497998,
        "sender_full_name": "Nir Paz",
        "timestamp": 1707932378
    }
]