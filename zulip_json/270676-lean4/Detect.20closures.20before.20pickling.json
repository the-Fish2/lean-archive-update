[
    {
        "content": "<p>To prevent the \"closures cannot be compacted\" error, I'm wondering if there's a lean-internal way to detect if a given object has closures before attempting to pickle it. E.g. I'd like to be able to write something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">unless</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">hasClosures</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"n\">pickle</span><span class=\"w\"> </span><span class=\"s2\">\"/file/path\"</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>I'm also a little unclear as to what \"closure\" is referring to in this context. My understanding of \"closure\" is, roughly, \"unevaluated expression involving variables + variable assignments\", but what sorts of variables and assignments are being talked about in this context?</p>",
        "id": 443116596,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1717694409
    },
    {
        "content": "<p>I'd assume it's any value of function type.</p>",
        "id": 443129224,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1717698187
    },
    {
        "content": "<p>Hmm, it does seem that those give that error, but that's not my understanding of what a \"closure\" is...</p>",
        "id": 443129645,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1717698327
    },
    {
        "content": "<p>Is the actual class of things that can't be serialized broader than things of function type, or does \"closure\" not mean what I think it means (either in this context or in general)?</p>",
        "id": 443130050,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1717698448
    },
    {
        "content": "<p>And, another question, I suppose: how does Lean manage to store e.g. the declaration <code>def foo (x : Nat) := x + 1</code> in an olean if it can't store objects of function type? (I figure we bypass lean objecthood somehow, but how?)</p>",
        "id": 443131633,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1717698799
    },
    {
        "content": "<p>Also: unfortunately simply unfolding the type as much as possible isn't always sufficient for detecting closures, as there's sometimes opacity in the way.</p>\n<p>Maybe something like <code>@[extern \"lean_is_closure\"]</code> after <code>LEAN_EXPORT</code>(?) would work? Though I'm not used to fiddling with C files, and I'd want to have some confidence this makes any sense before I spend time on it <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 443135787,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1717699734
    },
    {
        "content": "<blockquote>\n<p>I'd like to be able to write something like</p>\n</blockquote>\n<p>What's the broader context?</p>",
        "id": 443137002,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1717700173
    },
    {
        "content": "<p>It's similar to <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4/topic/Best.20way.20to.20.E2.80.9Ccompile.E2.80.9D.20an.20attribute-based.20function\">#lean4 &gt; Best way to “compile” an attribute-based function</a>, but a more general case: I need to pickle as much of the environment as I can so that I can look at it elsewhere/later. It would be great to pickle the state of persistent env extensions directly when possible, and indirectly when not. But that requires discriminating based on their picklability—and unless you know the specific env extensions you want to pickle in advance (I don't, this is meant to be generic), it's difficult (impossible?) to access the \"true\" type of their state, which is hidden behind an opaque <code>EnvExtensionState</code>.</p>",
        "id": 443143124,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1717702066
    },
    {
        "content": "<p>This doesn't seem like a good direction to go in. Why do you want to conditionally store data in two different ways rather than in a uniform way?</p>\n<p>Are you working on something that you can't talk about? Or can you give an outline of your project?</p>",
        "id": 443145801,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1717702898
    },
    {
        "content": "<p>Sorry, indeed I'm not allowed to give too many details! <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> The main reasons here are performance and fidelity; there is a tradeoff between fidelity and consistency, but that's ok in this case. I suppose it's possible that the nonuniformity will cause a performance hit? But I don't know that yet.</p>",
        "id": 443153663,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1717705368
    }
]