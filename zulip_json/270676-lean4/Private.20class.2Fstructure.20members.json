[
    {
        "content": "<p>Lean has a really useful property where members with the same name are \"coalesced\" when inheriting as a mechanism to resolve the diamond-inheritance problem. One negative side-effect of this is that the coalescing happens by default, even if I don't want it to. I can of course give complex names to fields in the hopes that no one else uses that name, but I'm wondering if there is another mechanism to ensure that names aren't merged.</p>\n<p>One could imagine, for example, having Monoid and Group classes each with an <code>op</code> field, and wanting them to be coalesced in some cases, but not for Ring where the Monoid is for multiplication and the group is the additive group.</p>",
        "id": 438216022,
        "sender_full_name": "Andy Soffer",
        "timestamp": 1715552142
    },
    {
        "content": "<p>I think if you avoid <code>extends</code> then it doesn't happen? But I'm not sure and I seem to recall that I've been surprised before.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">pig1</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Monoid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"kd\">class</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Ring</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Monoid</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">Group</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Ring.toMonoid.op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Ring.toGroup.op</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span> <span class=\"c1\">-- succeeds</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">pig1</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">pig2</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Monoid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"kd\">class</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Ring</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"c1\">-- much like the above but done by hand</span>\n  <span class=\"n\">toMonoid</span> <span class=\"o\">:</span> <span class=\"n\">Monoid</span> <span class=\"n\">α</span>\n  <span class=\"n\">toGroup</span> <span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Ring.toMonoid.op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Ring.toGroup.op</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span> <span class=\"c1\">-- fails</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">pig2</span>\n</code></pre></div>",
        "id": 438220471,
        "sender_full_name": "A.",
        "timestamp": 1715557422
    },
    {
        "content": "<p>This is a reasonable workaround, but comes with a tradeoff I don't really like, which is that I <em>don't</em> get the field merging when I want it. Without it as I build up each class I need to effectively determine all the fields I would want transitively and place them in each class, since I'm not getting them via inheritance.</p>\n<p>I guess I was hoping for something like being able to annotate fields as private so they'd be accessible explicitly via <code>myRing.toGroup.op</code> but have the others merged.</p>",
        "id": 438225870,
        "sender_full_name": "Andy Soffer",
        "timestamp": 1715563064
    },
    {
        "content": "<p>Nothing like this exists at present.</p>",
        "id": 438226338,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1715563570
    },
    {
        "content": "<blockquote>\n<p>One could imagine, for example, having Monoid and Group classes each with an <code>op</code> field, and wanting them to be coalesced in some cases, but not for Ring where the Monoid is for multiplication and the group is the additive group.</p>\n</blockquote>\n<p>The way this is done in practice (in mathlib) is to have <code>AddGroup</code>, which has its own <code>add</code> field and <code>+</code> notation, and <code>Monoid</code>, which has its own <code>mul</code> field and <code>*</code> notation.</p>\n<p>Do you have other concrete use cases for this?</p>",
        "id": 438226345,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715563577
    },
    {
        "content": "<p>I remember now that what surprised me was the merging of fields that hadn't been introduced through the <code>extends</code> mechanism. I wonder would anything be lost if merging were restricted to such fields only? So that <code>pig1</code> would no longer work but this <code>pig3</code> still would.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">pig3</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Op</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Monoid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Op</span> <span class=\"n\">α</span>\n<span class=\"kd\">class</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Op</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Ring</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Monoid</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">Group</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Ring.toMonoid.toOp</span> <span class=\"o\">:</span> <span class=\"n\">Op</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Ring.toGroup.toOp</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">pig3</span>\n</code></pre></div>",
        "id": 438301002,
        "sender_full_name": "A.",
        "timestamp": 1715588150
    },
    {
        "content": "<p>No other use cases (all flavors of this problem). There are definitely solutions in practice... I'm really just playing around and trying things out.</p>\n<p>Thanks for the help!</p>",
        "id": 438395831,
        "sender_full_name": "Andy Soffer",
        "timestamp": 1715615698
    }
]