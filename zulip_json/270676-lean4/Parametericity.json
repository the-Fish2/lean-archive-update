[
    {
        "content": "<p>I'm wondering if these types of statements are provable in Lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"c1\">--If I can make a β from an α and an (α→β), it must be the function applied.</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">func_eq_apply</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"n\">f</span> <span class=\"bp\">↦</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">--If I can make a β from an (α→β), it must be a particular value plugged in.</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_domain</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">f</span> <span class=\"bp\">↦</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">--A function that compares elements of any DecidableEq type must be either a constant,</span>\n<span class=\"c1\">-- the equality function, or the nonequality function.</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">compare_four_options</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">F</span> <span class=\"bp\">∈</span> <span class=\"o\">({</span>\n        <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">true</span><span class=\"o\">,</span>\n        <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">false</span><span class=\"o\">,</span>\n        <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">instBEq</span> <span class=\"n\">_</span> <span class=\"n\">i</span><span class=\"bp\">;</span> <span class=\"n\">x</span> <span class=\"bp\">==</span> <span class=\"n\">y</span><span class=\"o\">),</span>\n        <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">instBEq</span> <span class=\"n\">_</span> <span class=\"n\">i</span><span class=\"bp\">;</span> <span class=\"n\">x</span> <span class=\"bp\">!=</span> <span class=\"n\">y</span><span class=\"o\">)}</span>\n      <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">--Example usage of func_eq_apply: knowing what \"applier\" must be based on its type signature.</span>\n<span class=\"n\">opaque</span> <span class=\"n\">applier</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"n\">f</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">must_be_applier</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">applier</span> <span class=\"n\">a</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">func_eq_apply</span> <span class=\"bp\">@</span><span class=\"n\">applier</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I know that these are provable in some type systems; I've been told repeatedly by different people that, for instance, the Haskell compiler knows theorems like this about its type system</p>",
        "id": 428030280,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1710976190
    },
    {
        "content": "<p>These theorems become false if, for instance, you allow functions to \"inspect\" arbitrary data they know nothing about. For instance, I could make a function that takes two <code>α</code>s with <code>[DecidableEq α]</code>, looks at the first bit of their representation in memory, and then returns <code>true</code> if either of those bits is a one. That would contradict <code>compare_four_options</code>. But I think that with the functions you can 'normally' build in Lean those three examples all hold.</p>",
        "id": 428030849,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1710976509
    },
    {
        "content": "<p>If Lean doesn't support proving those statements as-is, is there maybe a (finite list of) axioms that one could add that would all these statements provable...?</p>",
        "id": 428030887,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1710976547
    },
    {
        "content": "<p>It looks like you're thinking along the lines of Wadler's paper \"Theorems for free!\" <a href=\"https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf\">https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf</a></p>",
        "id": 428031048,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710976641
    },
    {
        "content": "<p>In Lean, I'm pretty sure each of your examples are false, because you can make a function that does different things depending on what the type equals.</p>\n<p>You need some sort of naturality condition on the function (I don't know exactly what I'm talking about, so I can't say <em>exactly</em> what I mean), or know something about the syntax of the function to be able to deduce that.</p>",
        "id": 428031283,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710976795
    },
    {
        "content": "<p>Here's a contradiction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">func_eq_apply</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"n\">f</span> <span class=\"bp\">↦</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">Classical</span> <span class=\"k\">in</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">badF</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">=</span> <span class=\"n\">Bool</span> <span class=\"k\">then</span>\n    <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">true</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">f</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">func_eq_apply</span> <span class=\"n\">badF</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">congrFun</span> <span class=\"o\">(</span><span class=\"n\">congrFun</span> <span class=\"o\">(</span><span class=\"n\">congrFun</span> <span class=\"o\">(</span><span class=\"n\">congrFun</span> <span class=\"n\">this</span> <span class=\"n\">Unit</span><span class=\"o\">)</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">())</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span><span class=\"o\">)</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">badF</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n</code></pre></div>",
        "id": 428031887,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710977123
    },
    {
        "content": "<p>I was actually just writing something almost identical to try myself. :) </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">bad_applier</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">f</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 428031936,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1710977152
    },
    {
        "content": "<p>(That doesn't compile because it needs to be marked <code>noncomputable</code>)</p>",
        "id": 428031992,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1710977164
    },
    {
        "content": "<p>I think the only \"naturality\" condition needed is that it's all computable.</p>",
        "id": 428032012,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1710977179
    },
    {
        "content": "<p>I think it's possible to avoid choice and make it computable.</p>",
        "id": 428032070,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710977215
    },
    {
        "content": "<p>Ah, that would be interesting to see. I'm skeptically disagreeing atm but would <em>love</em> to see an example if you can!</p>",
        "id": 428032129,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1710977243
    },
    {
        "content": "<p>If you can do it with computable functions then I accept that this is not a thing that should be provable in Lean because it's wrong :P</p>",
        "id": 428032211,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1710977281
    },
    {
        "content": "<p>if you computable functions are safe, then I guess my question becomes \"is it possible to prove these things for computable functions\" and in particular \"is it even possible to add syntactic constraints that functions are computable\"</p>",
        "id": 428032322,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1710977316
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Type-based.20operational.20inference.20in.20Lean/near/428031048\">said</a>:</p>\n<blockquote>\n<p>It looks like you're thinking along the lines of Wadler's paper \"Theorems for free!\" <a href=\"https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf\">https://people.mpi-sws.org/~dreyer/tor/papers/wadler.pdf</a></p>\n</blockquote>\n<p>and yes that's what I was thinking of, forgot the name. It looks like there might be relevant axioms in there,  now I have some search terms I'll see what I can glean</p>",
        "id": 428032445,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1710977372
    },
    {
        "content": "<p>There's at least the problem that you can prove a contradiction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">func_eq_apply</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"n\">f</span> <span class=\"bp\">↦</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">classical</span>\n  <span class=\"k\">let</span> <span class=\"n\">badF</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n    <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">=</span> <span class=\"n\">Bool</span> <span class=\"k\">then</span>\n      <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">true</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">f</span> <span class=\"n\">x</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">func_eq_apply</span> <span class=\"n\">badF</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">congrFun</span> <span class=\"o\">(</span><span class=\"n\">congrFun</span> <span class=\"o\">(</span><span class=\"n\">congrFun</span> <span class=\"o\">(</span><span class=\"n\">congrFun</span> <span class=\"n\">this</span> <span class=\"n\">Unit</span><span class=\"o\">)</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">())</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span><span class=\"o\">)</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">badF</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n</code></pre></div>\n<p><code>let</code> bindings inside of proofs don't need to pass the computability checker.</p>",
        "id": 428033048,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710977719
    },
    {
        "content": "<p>Right yeah, I see that, so <code>func_eq_apply</code> is clearly false as written. That's why I'm asking if it's possible to write something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">func_eq_apply</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"n\">Computable</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"n\">f</span> <span class=\"bp\">↦</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>that might work instead.</p>",
        "id": 428033270,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1710977852
    },
    {
        "content": "<p>That certainly seems plausible to me. <code>Computable F</code> could be defined by saying that <code>F</code> is could be put into a particular form that you can use to inductively prove this statement. (It could be a theorem, not an axiom.)</p>",
        "id": 428033604,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710978049
    },
    {
        "content": "<p>Mm. And then we'd either need (1) a bunch of instances generating instances enough to synthesize that wherever needed; or (2) an axiom / something in the kernel to automatically synthesize <code>Computable F</code> whenever <code>F</code> isn't <code>noncomputable</code>.</p>",
        "id": 428033764,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1710978148
    },
    {
        "content": "<p><code>noncomputable</code> is a concept that's outside Lean's type theory (and outside the kernel). It's whether the compiler was able to figure out how to lower the definition down into something that can be compiled to C</p>",
        "id": 428033793,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710978179
    },
    {
        "content": "<p>Alright. I guess that's what I was afraid to hear (esp the \"outside the type theory\") part.</p>",
        "id": 428033837,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1710978209
    },
    {
        "content": "<p>but that's not to say that you can't formalize something that says \"these functions are [insert the name of the right notion for getting theorems for free]\" yourself and make some automation to try to derive proofs from definitions</p>",
        "id": 428033923,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710978253
    },
    {
        "content": "<p>Right. Might be a fun thing to try... I've been writing some Decidability instances for fun, maybe this could be a fun thing to try and see if it's scalable or just pain</p>",
        "id": 428033970,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1710978293
    },
    {
        "content": "<p>I guess a first step is to figure out how to write that predicate so that you get theorems for free. One element I was imagining is an inductive type that represents all the kinds of expressions you can deal with, along with an evaluation function. Then the predicate would be that there exists an expression of this type whose evaluation is equal.</p>",
        "id": 428034244,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710978468
    },
    {
        "content": "<p>(I've never done this before, so take this suggestion with a grain of salt.)</p>",
        "id": 428034360,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710978528
    },
    {
        "content": "<p>Yeah. I think \"constant functions\" and \"func_eq_apply\" as two constructors might get 80% of the way there. (In that sense, func_eq_apply is sort of being used an 'axiom'). Terms and functions, right? :P</p>",
        "id": 428034368,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1710978538
    },
    {
        "content": "<p>I'mma try this and report back <span aria-label=\"saluting face\" class=\"emoji emoji-1fae1\" role=\"img\" title=\"saluting face\">:saluting_face:</span></p>",
        "id": 428034383,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1710978548
    },
    {
        "content": "<p>... brain melted, giving up for now. Side question: is there a good way to prove stupid \"type confusion\" questions like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⊢</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"kt\">Prop</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Empty</span> <span class=\"bp\">→</span> <span class=\"n\">Empty</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>or (equivalently, probably)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⊢</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 428039306,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1710981815
    },
    {
        "content": "<p>I think you can only prove those using a cardinality argument.</p>",
        "id": 428039444,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710981914
    },
    {
        "content": "<p>Though it'd be best if you could avoid needing to prove any types are not equal to each other!</p>",
        "id": 428039486,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710981960
    },
    {
        "content": "<p>I agree! This is coming from a stupid (and probably not actually working) attempt at a proof by contradiction on a certain toy case. It's not promising, but, I was stuck there anyway and curious</p>",
        "id": 428039624,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1710982080
    },
    {
        "content": "<p>I could prove that Prop ≠ Empty I think but wasn't sure how to turn my thing into that</p>",
        "id": 428039689,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1710982119
    },
    {
        "content": "<p>Here's using <code>congr</code> quotations to apply <code>Fintype.card</code> (<code>congr</code> quotations are a mathlib extension that makes it easy to create congruences, even if there are complexities, like typeclass synthesis in this case).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"kt\">Prop</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Empty</span> <span class=\"bp\">→</span> <span class=\"n\">Empty</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">congr</span><span class=\"o\">(</span><span class=\"n\">Fintype.card</span> <span class=\"bp\">$</span><span class=\"n\">h</span><span class=\"o\">)</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n</code></pre></div>",
        "id": 428039842,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710982244
    },
    {
        "content": "<p>I guess this works too</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"kt\">Prop</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Empty</span> <span class=\"bp\">→</span> <span class=\"n\">Empty</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">congrArg</span> <span class=\"n\">Nat.card</span> <span class=\"n\">h</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n</code></pre></div>",
        "id": 428039906,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710982298
    },
    {
        "content": "<p>(this is in a file with <code>import Mathlib</code>)</p>",
        "id": 428039922,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710982315
    },
    {
        "content": "<p>Nice! Thanks.</p>",
        "id": 428040025,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1710982366
    },
    {
        "content": "<p>Reading more about it, it seems like there's a decent attempt in Coq at this kind of stuff (by way of custom tactics to synthesize proofs from syntax trees) here: <a href=\"https://github.com/mit-plv/reification-by-parametricity/\">https://github.com/mit-plv/reification-by-parametricity/</a><br>\naccompanying paper at <a href=\"http://adam.chlipala.net/papers/ReificationITP18/ReificationITP18.pdf\">http://adam.chlipala.net/papers/ReificationITP18/ReificationITP18.pdf</a></p>",
        "id": 428182812,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1711042307
    },
    {
        "content": "<p>That's very cool!</p>",
        "id": 428191555,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1711045428
    },
    {
        "content": "<p>I've always wished I understood <a href=\"https://golem.ph.utexas.edu/category/2013/04/scones_logical_relations_and_p.html\">https://golem.ph.utexas.edu/category/2013/04/scones_logical_relations_and_p.html</a>, but still don't. :-)</p>",
        "id": 428217134,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1711054831
    },
    {
        "content": "<blockquote>\n<p>but I hope I’ve convinced you that at least one reasonable possibility to consider for  is the scone of : the comma category of IdSet over the global sections functor �=hom(1,−):Syn�→Set.</p>\n</blockquote>\n<p>I'm sure he would have convinced me if I knew what that meant! <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 428218475,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1711055380
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"448405\">@Alex Meiburg</span> I'm pretty sure your <code>func_eq_apply</code> is exactly the statement of the Yoneda lemma in <strong>Type</strong> for the functor <code>Id</code>. (Note that the type signature of <code>F</code> is just a curried functorial map with the arguments swapped.) I'm still working on formalizing the proof, but if I'm right, the requirements you need are the category theory axioms for functors -- namely that they map identity to identity and compositions to compositions. In practical terms, in addition to rigorizing \"naturality\", that also means no side effects, no global state, and a very restricted subset of dependent functions... though that seems like it might prove too much, since I think Haskell also has dependent functions and otherwise Lean is largely pure-functional?</p>\n<p>(It  does also rule out both of the contradictions above; the <code>bad_applier</code>s above don't map identity to identity on all types, which can then be detected purely at the type level via composition. It's not a coincidence that both of <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> 's counterexamples derive <code>False</code> through applications of <code>congrFun</code>.)</p>",
        "id": 432221083,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712664863
    },
    {
        "content": "<p><del>Right, here you go:</del></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Types</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Yoneda</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span> <span class=\"n\">Opposite</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">LawfulEvaluator</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">eval</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F.obj</span> <span class=\"n\">β</span>\n  <span class=\"n\">map_comp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">},</span> <span class=\"n\">eval</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">F.map</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">yoneda_Types</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">LawfulEvaluator</span> <span class=\"n\">F</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">F.obj</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">F'</span> <span class=\"o\">:=</span> <span class=\"n\">unopUnop</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">⋙</span> <span class=\"n\">F</span>\n  <span class=\"k\">have</span> <span class=\"n\">yoneda</span> <span class=\"o\">:=</span> <span class=\"n\">yonedaEquiv</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"n\">F'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">op</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"n\">unfold_let</span> <span class=\"n\">F'</span> <span class=\"n\">at</span> <span class=\"n\">yoneda</span><span class=\"bp\">;</span> <span class=\"n\">unfold</span> <span class=\"n\">yoneda</span> <span class=\"n\">at</span> <span class=\"n\">yoneda</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">yoneda</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Equiv.trans</span> <span class=\"n\">_</span> <span class=\"n\">yoneda</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">unopUnop</span> <span class=\"n\">Functor.comp</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span>\n      <span class=\"bp\">λ</span> <span class=\"n\">eval'</span> <span class=\"bp\">↦</span>\n        <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"o\">⟨⟨</span><span class=\"n\">β</span><span class=\"o\">⟩⟩</span> <span class=\"n\">f</span> <span class=\"bp\">↦</span> <span class=\"n\">eval'.eval</span> <span class=\"o\">(</span><span class=\"n\">f.unop</span><span class=\"o\">),</span>\n        <span class=\"bp\">λ</span> <span class=\"o\">⟨⟨</span><span class=\"n\">β</span><span class=\"o\">⟩⟩</span> <span class=\"o\">⟨⟨</span><span class=\"n\">γ</span><span class=\"o\">⟩⟩</span> <span class=\"n\">f</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">nat</span><span class=\"o\">⟩,</span>\n      <span class=\"bp\">λ</span> <span class=\"n\">η</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨</span>\n        <span class=\"bp\">@λ</span> <span class=\"n\">β</span> <span class=\"n\">f</span> <span class=\"bp\">↦</span> <span class=\"n\">η.app</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">((</span><span class=\"bp\">↾</span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"o\">),</span>\n        <span class=\"bp\">@λ</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">map_comp</span><span class=\"o\">⟩,</span> <span class=\"bp\">?</span><span class=\"n\">left_inv</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">right_inv</span><span class=\"o\">⟩</span>\n  <span class=\"n\">case</span> <span class=\"n\">map_comp</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">η</span> <span class=\"bp\">⊢</span>\n    <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">op_comp</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">eta_reduce</span>\n    <span class=\"k\">let</span> <span class=\"n\">naturality</span> <span class=\"o\">:=</span>\n      <span class=\"n\">FunctorToTypes.naturality</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:=</span> <span class=\"n\">op</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">op</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">CategoryTheory.yoneda.obj</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">op</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">F'</span> <span class=\"n\">η</span> <span class=\"o\">((</span><span class=\"bp\">↾</span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op.op</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"bp\">↾</span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"o\">)</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">F'</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">naturality</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">naturality</span><span class=\"o\">]</span>\n  <span class=\"n\">case</span> <span class=\"n\">nat</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">ext</span> <span class=\"n\">g</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">⊢</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">types_comp</span><span class=\"o\">,</span> <span class=\"n\">LawfulEvaluator.map_comp</span> <span class=\"n\">eval'</span><span class=\"o\">]</span>\n  <span class=\"n\">case</span> <span class=\"n\">left_inv</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">aesop_cat</span>\n  <span class=\"n\">case</span> <span class=\"n\">right_inv</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">aesop_cat</span>\n</code></pre></div>",
        "id": 432354758,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712702867
    },
    {
        "content": "<p><del>If we impose the additional restriction that a <code>LawfulEvaluator</code> be compatible with composition and the <code>.map</code> of a functor <code>F</code>, then the type of valid evaluators on <code>α</code> is equivalent to the type <code>F.obj α</code>, i.e they're basically just \"hiding\" a value of <code>F.obj α</code> and evaluating on it. In particular, if <code>F</code> is the identity functor, the extra constraint <code>map_comp</code> reduces to <code>eval (g ∘ f) = g ∘ eval f)</code>, and there is exactly one lawful evaluator for every value of <code>α</code>, which evaluates all functions on that fixed value. More interestingly: even if <code>F</code> is not the identity, as long as <code>F.obj</code> is the identity (it sends α to α for all <code>α : Type u</code>), it is still true that any <code>eval'</code> can only differ from <code>eval</code> in a functorial (i.e. composable) way. </del></p>\n<p>Nevermind, that doesn't quite prove what I wanted it to prove -- it just says that you have to be evaluating <em>some</em> function, calculated from <code>f</code> in  functorial manner.</p>",
        "id": 432355497,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712703247
    }
]