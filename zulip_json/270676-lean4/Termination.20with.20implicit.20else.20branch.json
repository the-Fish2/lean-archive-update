[
    {
        "content": "<p>This does not compile:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">go</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">):</span> <span class=\"n\">IO</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"bp\">≥</span> <span class=\"n\">n</span> <span class=\"k\">then</span>\n    <span class=\"n\">return</span> <span class=\"n\">a</span>\n  <span class=\"n\">go</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n  <span class=\"n\">termination_by</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>which shows</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">prove</span> <span class=\"n\">termination</span><span class=\"o\">,</span> <span class=\"n\">possible</span> <span class=\"n\">solutions</span><span class=\"o\">:</span>\n  <span class=\"bp\">-</span> <span class=\"n\">Use</span> <span class=\"bp\">`</span><span class=\"k\">have</span><span class=\"bp\">`-</span><span class=\"n\">expressions</span> <span class=\"n\">to</span> <span class=\"n\">prove</span> <span class=\"n\">the</span> <span class=\"n\">remaining</span> <span class=\"n\">goals</span>\n  <span class=\"bp\">-</span> <span class=\"n\">Use</span> <span class=\"bp\">`</span><span class=\"n\">termination_by</span><span class=\"bp\">`</span> <span class=\"n\">to</span> <span class=\"n\">specify</span> <span class=\"n\">a</span> <span class=\"n\">different</span> <span class=\"n\">well</span><span class=\"bp\">-</span><span class=\"n\">founded</span> <span class=\"n\">relation</span>\n  <span class=\"bp\">-</span> <span class=\"n\">Use</span> <span class=\"bp\">`</span><span class=\"n\">decreasing_by</span><span class=\"bp\">`</span> <span class=\"n\">to</span> <span class=\"n\">specify</span> <span class=\"n\">your</span> <span class=\"n\">own</span> <span class=\"n\">tactic</span> <span class=\"n\">for</span> <span class=\"n\">discharging</span> <span class=\"n\">this</span> <span class=\"n\">kind</span> <span class=\"n\">of</span> <span class=\"n\">goal</span>\n<span class=\"n\">n</span> <span class=\"n\">i</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>but this does</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">go</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">):</span> <span class=\"n\">IO</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"bp\">≥</span> <span class=\"n\">n</span> <span class=\"k\">then</span>\n    <span class=\"n\">return</span> <span class=\"n\">a</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">go</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n  <span class=\"n\">termination_by</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>What causes this behaviour? The two expressions are identical</p>",
        "id": 433357771,
        "sender_full_name": "Leni Aniva",
        "timestamp": 1713205256
    },
    {
        "content": "<p>It's most likely due to the way that the <code>if</code> gets lowered by do notation. The code gets compiled to a join point which does not have access to the fact that <code>¬i ≥ n</code> which causes the automated proof to fail.</p>\n<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> is this something easy to support by changing the do elaborator?</p>",
        "id": 433359728,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1713205901
    },
    {
        "content": "<p>I would like to know more about how <code>termination_by</code> acquires the assumption <code>i &gt;= n</code> in the second case. This seems kind of magical since it's not a <code>dite</code> application, it must be using some congr lemma or something to descend into it and pick up the relevant fact</p>",
        "id": 433366328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713208223
    },
    {
        "content": "<p>whatever it is, I want to extend it to work on <code>List.map</code> so I can write my nested inductive recusions</p>",
        "id": 433366415,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713208261
    },
    {
        "content": "<p>The well-founded definition processing replaces all <code>ite</code>s with <code>dites</code>, relatively early in the pipeline<br>\n<a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/PreDefinition/WF/Ite.lean\">https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/PreDefinition/WF/Ite.lean</a><br>\n(<a href=\"https://github.com/leanprover/lean4/commit/c95d5f25a35d9e4a7d48d587cc0ecd6e4df59eec\">since 2022</a>)</p>",
        "id": 433379762,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713212603
    },
    {
        "content": "<p>Unfortunately, it’s not using congr lemmas like Isabelle does, that would be neat, but it seems that our logic doesn’t quite allow that (although I’m happy to be proven wrong)</p>",
        "id": 433380009,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713212667
    },
    {
        "content": "<p>Hmm, since we are in non-constructive mode anyways with well-founded recursion, I wonder if we can prove termination using congr lemmas the way Isabelle does. It would probably need a fixed point that instead of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">fix</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">WellFounded</span> <span class=\"n\">r</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>says something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">fix'</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span>  <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>(unconstrained ih!) and a separate theorem</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">fix_eq</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">WellFounded</span> <span class=\"n\">r</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">termination</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih1</span> <span class=\"n\">ih2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">eq_on_smaller</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">ih1</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">ih2</span> <span class=\"n\">y</span><span class=\"o\">)</span>  <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">ih1</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">F</span> <span class=\"n\">ih2</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">fix'</span> <span class=\"n\">F</span> <span class=\"bp\">=</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">fix'</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>where the <code>termination</code> side condition essentially says “even though <code>F</code> is defined on all <code>α</code>, only smaller ones affect the outcome” as an extrinsic variant of “<code>F</code> is defined only on smaller α”.</p>\n<p>Is something like this plausible? Desirable? Maybe only if <code>C x</code> is a-priori non-empty?</p>",
        "id": 433382046,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713213434
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/Termination.20with.20implicit.20else.20branch/near/433379762\">said</a>:</p>\n<blockquote>\n<p>The well-founded definition processing replaces all <code>ite</code>s with <code>dites</code>, relatively early in the pipeline<br>\n<a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/PreDefinition/WF/Ite.lean\">https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/PreDefinition/WF/Ite.lean</a><br>\n(<a href=\"https://github.com/leanprover/lean4/commit/c95d5f25a35d9e4a7d48d587cc0ecd6e4df59eec\">since 2022</a>)</p>\n</blockquote>\n<p>Doesn't it need to prove equivalence somehow? This seems like it's only transforming the term itself</p>",
        "id": 433394341,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713218092
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/270676-lean4/topic/Termination.20with.20implicit.20else.20branch/near/433380009\">said</a>:</p>\n<blockquote>\n<p>Unfortunately, it’s not using congr lemmas like Isabelle does, that would be neat, but it seems that our logic doesn’t quite allow that (although I’m happy to be proven wrong)</p>\n</blockquote>\n<p>I'm not sure I understand the concern. The way I would propose to implement this is to do something similar to the <code>ite</code> -&gt; <code>dite</code> transformation and replace uses of <code>List.map</code> with <code>List.pmap</code> (ideally in some extensible way so that we can also do something similar for <code>List.foldl</code>, <code>Array.forM</code>, etc), and then do the termination proof in that extended context</p>",
        "id": 433394739,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713218279
    },
    {
        "content": "<p>I was just rambling about how to do termination proofs without rewriting the terms (using compositional congr lemmas after the fact). If we want to stick to rewriting, then yes, that is the way to go.</p>\n<p>Does this compose well? What if the code has <code>xs |&gt;.map f |&gt;. filter g |&gt;. foldl h</code>, and the recursive call is in <code>h</code>? It seems nontrivial to me to thread the <code>x \\in xs</code> information through such a pipeline in an automatic and general way.</p>\n<p>And then we still have to prove that to be equal to the original code when proving the unfolding lemma. And the user might be confused when they see code they didn't write in the context of their termination proofs.</p>\n<p>Sounds worth a master thesis and a paper to me :-). Or do we know of systems that do this already?</p>",
        "id": 433454179,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713250648
    }
]