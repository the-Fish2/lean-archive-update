[
    {
        "content": "<p>When you turn off <code>zeta</code> simp still destroys let bindings inside of projection application.</p>\n<p>mwe</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">id</span> <span class=\"mi\">7</span>\n     <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">42</span>\n     <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n    <span class=\"bp\">=</span>\n    <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">id</span> <span class=\"mi\">7</span>\n    <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">42</span>\n    <span class=\"n\">b</span>\n    <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">lhs</span>\n    <span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">zeta</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">})</span> <span class=\"n\">only</span> <span class=\"o\">[]</span>\n    <span class=\"n\">trace_state</span>\n</code></pre></div>\n<p>prints <code>id 7 + 42</code> but I'm expecting</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">id</span> <span class=\"mi\">7</span>\n    <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">42</span>\n    <span class=\"n\">b</span>\n</code></pre></div>\n<p>Is this intended behavior or is that considered as a bug?</p>",
        "id": 421337625,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707864176
    },
    {
        "content": "<p>Ohh I just found out that setting <code>proj:=false</code> fixes this. I clearly misunderstood this option and never tried it until now.</p>",
        "id": 421467219,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707923733
    },
    {
        "content": "<p>I think what's happening is that when <code>proj := true</code> then the projection function is being unfolded, but to unfold it it has to put the argument into whnf.  This is independent of <code>zeta</code>, which is just about whether simp itself will eliminate a <code>let</code>.</p>\n<p>Here's the simp reduction code: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Meta/Tactic/Simp/Main.lean#L149\">https://github.com/leanprover/lean4/blob/master/src/Lean/Meta/Tactic/Simp/Main.lean#L149</a></p>",
        "id": 421488804,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707929597
    },
    {
        "content": "<p>Maybe if there were a way to have simp configure <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.WhnfCoreConfig#doc\">docs#Lean.Meta.WhnfCoreConfig</a> you could turn this kind of zeta reduction off too, while still keeping projection reduction.</p>",
        "id": 421489140,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707929691
    },
    {
        "content": "<p>Another approach is to pull let bindings out of applications. </p>\n<p>In my own fork of simp I  implemented different version of <code>reduceProjFn?</code> but updating to <code>lean4:v4.6.0-rc1</code> broke everything. So now I'm trying to figure out an approach without forking simp :)</p>",
        "id": 421489849,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707929898
    },
    {
        "content": "<p>I suppose you could use the mathlib <code>lift_lets</code> for that</p>",
        "id": 421491688,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707930449
    },
    {
        "content": "<p>That could also probably be a pre-simproc. You'd have to decide how deep into an expression you want to look for <code>let</code>s though, if you care about quadratic performance.</p>",
        "id": 421492172,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707930580
    },
    {
        "content": "<p>Yeah I experimented with it. I'm afraid that as I'm already running simp, calling lift lets might add extra power to the O(n^*)</p>",
        "id": 421492316,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707930619
    },
    {
        "content": "<p>Hmm limiting the depth of lift_lets is a good idea!</p>",
        "id": 421492518,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707930678
    },
    {
        "content": "<p>However, I'm also doing few extra stuff though. For example, I'm splitting let binding of structure constructors into multiple let bindings. And I'm doing it as pre-simproc now as you suggest.</p>",
        "id": 421493147,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707930846
    }
]