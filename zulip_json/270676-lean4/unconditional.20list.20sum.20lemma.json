[
    {
        "content": "<p>Not very deep, and certainly no surprise to most here, but still slightly amusing that this is a lemma for all lists:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">xs.sum</span> <span class=\"bp\">=</span> <span class=\"n\">xs.head</span><span class=\"bp\">!</span> <span class=\"bp\">+</span> <span class=\"n\">xs.tail</span><span class=\"bp\">!.</span><span class=\"n\">sum</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">xs</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 434441284,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713563620
    },
    {
        "content": "<p>That's because <code>Inhabited Nat</code> picks <code>0</code> as the default and <code>panic!</code> uses that in <code>head! []</code>? Morally it feels wrong that this goes through -- should the value underlying <code>panic!</code>not be opaque to proofs? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 434466774,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713585506
    },
    {
        "content": "<p>It’s just like <code>0-1=0</code> – morally wrong, but too useful to not do it this way :-)</p>",
        "id": 434478204,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713597677
    },
    {
        "content": "<p>Hm, I'm not sure. I feel one shouldn't be able to prove anything specific about a panic'ing computation -- ideally it wouldn't even have a value, but that seems to be a formal necessity.</p>\n<p>I think it would be more natural if <code>panic!</code> would wrap <code>default</code> in a way that can never be unfolded, or at least is not unfolded by standard tactics like the ones you use above?</p>",
        "id": 434501615,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713620097
    },
    {
        "content": "<p>This was the original design (it was an <code>opaque</code>), but this causes problems of its own, for example you can't prove that <code>(l : List A).head?.get! = l.head!</code> and other things like that. (I was the one who lobbied to make it a regular definition.)</p>",
        "id": 434502185,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713620521
    },
    {
        "content": "<p>And there are various cases where you want to panic and still return a well formed result (because you have to return some result and some are worse than others)</p>",
        "id": 434502308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713620607
    },
    {
        "content": "<p>For example a recent proof I needed to do was that <code>Array.qsort</code> doesn't change the length of the array, which is true even though it can panic in various places</p>",
        "id": 434502413,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713620672
    },
    {
        "content": "<p>If <code>panic!</code> aborted the program, I think this would be slightly more reasonable, but in lean it doesn't, at least not under default settings, so programs have to prepare to handle what happens after a panic</p>",
        "id": 434502546,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713620777
    },
    {
        "content": "<p>Thank you for the perspectives, <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, the example of <code>(l : List A).head?.get! = l.head!</code>is an interesting one. Would this not still be provable even if one used an opaque wrapper? Whatever one chooses, generic equations like <code>x=x</code> will still hold for the 'panic element' (for that reason, the equivalent of the lemma above is true in Isabelle, for example, even though Isabelle's <code>undefined</code> element is indeed opaque)</p>",
        "id": 434506074,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713623723
    },
    {
        "content": "<p>The issue is that there isn't just one \"panic element\", it is a function which takes e.g. the panic message</p>",
        "id": 434506168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713623799
    },
    {
        "content": "<p>and the line/col of the occurrence of the <code>panic!</code> macro</p>",
        "id": 434506177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713623814
    },
    {
        "content": "<p>so one of them would reduce to <code>panic \"List.head! []\"</code> and the other would reduce to <code>panic \"none.get!\"</code> or similar</p>",
        "id": 434506205,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713623846
    },
    {
        "content": "<p>Got it. So I suppose there are more than two option here: On one extreme, <code>panic</code> itself could be opaque, in which case you can't prove anything about different invocations of panic, unless the arguments are exactly the same. One step more 'transparent' would be to transparently define <code>panic</code> via a one-per-type <code>undefined</code> element (as in Isabelle), but make _that_ element opaque -- then, your lemma would still hold, but e.g. <span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span>'s list lemma wouldn't. And finally, what we have now, is completely transparent, where <code>panic</code> unfolds to <code>default</code> which is transparent for any specific type, so one can prove things about it.</p>",
        "id": 434506306,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713623921
    },
    {
        "content": "<p>Even if you set things up to ignore that, the choice definitely has to depend on the inhabited instance</p>",
        "id": 434506318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713623939
    },
    {
        "content": "<p>By the way, regarding \"tactics shouldn't automatically reduce it\", I believe it is currently set to be semireducible, meaning that it won't be unfolded unless the user explicitly asks for it (and it's not like there is a simp lemma that unfolds <code>panic</code> invocations), but <code>rfl</code> counts as \"asking for it\" in this case</p>",
        "id": 434506446,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713624057
    },
    {
        "content": "<p>Ah! That's interesting.</p>",
        "id": 434506463,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713624080
    },
    {
        "content": "<p>we could make it <code>@[irreducible]</code>, which would still make it provable but only with more elaborate mechanisms</p>",
        "id": 434506468,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713624086
    },
    {
        "content": "<p>but I'm not sure that would actually help very much, because it would just make the theorems that want to do this unfolding have to write that in a more obtuse way</p>",
        "id": 434506546,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713624124
    },
    {
        "content": "<p>Yes, though one could argue that's then by design? Lemmas like Joachim's are only true by accident. For example, <code>xs.prod = xs.head! * xs.tail!.prod</code> would not be true.</p>\n<p>I guess it's a trade-off between conceptual clarity and convenience. I personally feel that having an opaque one-per-type 'undefined' element is a good middle-ground, as it means e.g. that equality of potentially-panicking functions means \"Panic on the same inputs and are otherwise equal\", but that's rather subjective.</p>",
        "id": 434507342,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713624709
    },
    {
        "content": "<p>\"by accident\" is not quite the right word</p>",
        "id": 434507406,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713624731
    },
    {
        "content": "<p>the choice of Inhabited values is done to maximize the number of such \"accidental theorems\"</p>",
        "id": 434507438,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713624769
    },
    {
        "content": "<p>and in most cases it is documented to have a given value, sometimes called the \"zero value\" in other programming languages</p>",
        "id": 434507490,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713624821
    },
    {
        "content": "<p>Yes, though one would rather have a separate type class for that? (<code>Zero</code> or similar)</p>",
        "id": 434507589,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713624908
    },
    {
        "content": "<p>All of the same properties you are describing hold if you replace <code>head!</code> and <code>tail!</code> with <code>headI</code> and <code>tailI</code>, or <code>headD default</code> and <code>tailD default</code></p>",
        "id": 434507605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713624931
    },
    {
        "content": "<p>At least currently, this is what <code>Inhabited</code> means, it is a designated canonical element</p>",
        "id": 434507976,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713625017
    },
    {
        "content": "<p><code>Nonempty</code> is closer to being the class for \"inhabited but no canonical element\"</p>",
        "id": 434508059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713625039
    },
    {
        "content": "<p>Ah, I wasn't aware of <code>Nonempty</code>.</p>\n<p>Thanks Mario for your thoughts <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span></p>",
        "id": 434508079,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713625068
    },
    {
        "content": "<p><code>Zero</code> already exists in mathlib for algebraic zero</p>",
        "id": 434508083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713625077
    },
    {
        "content": "<p>these types of course aren't always equipped with an algebraic structure such that <code>default</code> acts like a zero</p>",
        "id": 434508136,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713625108
    },
    {
        "content": "<p>One caveat of the current approach is that when code-extracting to a language which has a native <code>panic</code>, it would be nice if at least the presence/absence of panics [in the extracted code] would be preserved under function equality [before extraction]. But that's not the case, as e.g. Joachim's example shows. However, it is impossible to avoid this entirely without adding a separate language construct for <code>panic!</code> (e.g. how would one distinguish the identity function on the unit type from a <code>panic!</code> -- those will always be provably equal no matter whether <code>panic</code> is opaque or not); Isabelle suffers from this, too, though not 'as much' since <code>undefined</code> is opaque, so you wouldn't be able to prove e.g. Joachim's lemma.</p>",
        "id": 434525057,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713638659
    },
    {
        "content": "<p>Isabelle also has <code>0 - 1 = 0</code>, and not <code>0 - 1 = undefined</code>.  It's a trade off between “some lemmas are more convenient because they don't need extra preconditions” and “bad inputs should lead to unprovable goals as much as possible”. As long as nobody assumes that “verified lean code doesn't panic” or “verified lean code terminates” it doesn't matter much either way, I'd say.</p>",
        "id": 434526045,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713639599
    },
    {
        "content": "<p>note that making <code>panic</code> opaque does not ensure the property \"verified lean code doesn't panic\" either. The best way to ensure that errors don't occur in lean code is to use <code>Option</code> or <code>Expect</code> so that the presence of the error is expressible in the type system</p>",
        "id": 434526182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713639718
    },
    {
        "content": "<p>Agreed (and fwiw, I don't want <code>0-1=undefined</code> :-) )</p>",
        "id": 434526269,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713639785
    }
]