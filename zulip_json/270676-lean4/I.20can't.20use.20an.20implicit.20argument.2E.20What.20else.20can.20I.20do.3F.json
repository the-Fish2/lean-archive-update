[
    {
        "content": "<p>I am currently working on the theory of Coxeter groups. The specifics aren't important; what's important is that for every matrix <code>M : Matrix B B ℕ</code>, we have a group <code>CoxeterGroup M</code>. I have also defined a function <code>wordProd</code> that takes as input a <code>List B</code> and outputs an element of <code>CoxeterGroup M</code>; see below.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Matrix.Notation</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.PresentedGroup</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.SpecificGroups.Coxeter</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CoxeterGroup</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">List</span> <span class=\"n\">Matrix</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">B</span> <span class=\"n\">B</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">simpleReflection</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CoxeterGroup</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">PresentedGroup.of</span> <span class=\"n\">i</span>\n<span class=\"kd\">def</span> <span class=\"n\">wordProd</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CoxeterGroup</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">simpleReflection</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">ω</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">wordProd_append</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"n\">ω'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">wordProd</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"bp\">++</span> <span class=\"n\">ω'</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">wordProd</span> <span class=\"n\">M</span> <span class=\"n\">ω</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">wordProd</span> <span class=\"n\">M</span> <span class=\"n\">ω'</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">CoxeterGroup</span>\n</code></pre></div>\n<p>Now, let's say that I am planning to have many more theorems like <code>wordProd_append</code> in the same file. I don't want to type <code>wordProd M ω</code> every time I use the <code>wordProd</code> function; I would rather type something like <code>wordProd ω</code> or <code>π ω</code> or something similar. This should be fine because the matrix M is \"staying the same\" throughout the section.</p>\n<p>(The equivalent in informally written mathematics would be something like \"Fix a matrix M, and let π = π_M be the associated word product function\". From then on, I could just write π and it would be understood to mean π_M.)</p>\n<p>Normally, I would accomplish this by making the argument <code>M</code> implicit in <code>wordProd</code>. However, I can't do that here. The problem is that Lean does not have any way to infer the implicit argument, because the only other place that <code>M</code> appears in the signature of <code>wordProd</code> is in the return type.</p>\n<p>What are my options?</p>",
        "id": 425756146,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1710059986
    },
    {
        "content": "<p>If <code>M</code> is declared as <code>{M}</code>, then you should be able to write <code>wordProd ω : CoxeterGroup M</code> or <code>wordProd (M := M) ω</code> (warning: untested). However, in this particular situation, instead of using the type <code>CoxeterGroup M</code>, I would suggest using <code>cs : CoxeterSystem M W</code> as a variable (and use dot notation, like <code>cs.wordProd ...</code>), so that the API applies not only to the group <code>CoxeterGroup M</code> but to any group <code>W</code> that is part of a Coxeter system.</p>",
        "id": 425779235,
        "sender_full_name": "Joël Riou",
        "timestamp": 1710082177
    },
    {
        "content": "<p>Incidentally, (independent of the suggestion above) Lean 3 used to have a command just for this: <code>parameter</code>. I don't know whether any analogue has been implemented in Lean 4 / Mathlib4.</p>",
        "id": 425788872,
        "sender_full_name": "Raghuram",
        "timestamp": 1710090889
    },
    {
        "content": "<p>The only analogue is making a <code>local notation</code>, which works since local notations are allowed to refer to variables</p>",
        "id": 425789511,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710091530
    },
    {
        "content": "<p>Thanks for the suggestions.</p>\n<p>I have tried multiple ways to make the argument <code>M</code> implicit. I have gotten it to work by doing this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Matrix.Notation</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.PresentedGroup</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.SpecificGroups.Coxeter</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CoxeterGroup</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">List</span> <span class=\"n\">Matrix</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">B</span> <span class=\"n\">B</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">simpleReflection</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CoxeterGroup</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">PresentedGroup.of</span> <span class=\"n\">i</span>\n<span class=\"kd\">def</span> <span class=\"n\">wordProd</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CoxeterGroup</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">simpleReflection</span> <span class=\"n\">ω</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">wordProd_append</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"n\">ω'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">wordProd</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"bp\">++</span> <span class=\"n\">ω'</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">wordProd</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">ω</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">wordProd</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">ω'</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">CoxeterGroup</span>\n</code></pre></div>\n<p>I can do the same thing with a type annotation on each use of <code>wordProd</code>. But, of course, this is even more cumbersome than writing just writing <code>wordProd M ω</code>. Removing any one of the occurrences of <code>(M := M)</code>or any one of the type annotations yields an error message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">deterministic</span><span class=\"o\">)</span> <span class=\"n\">timeout</span> <span class=\"n\">at</span> <span class=\"bp\">'</span><span class=\"n\">whnf'</span><span class=\"o\">,</span> <span class=\"n\">maximum</span> <span class=\"n\">number</span> <span class=\"n\">of</span> <span class=\"n\">heartbeats</span> <span class=\"o\">(</span><span class=\"mi\">200000</span><span class=\"o\">)</span> <span class=\"n\">has</span> <span class=\"n\">been</span> <span class=\"n\">reached</span> <span class=\"o\">(</span><span class=\"n\">use</span> <span class=\"bp\">'</span><span class=\"kd\">set_option</span> <span class=\"n\">maxHeartbeats</span> <span class=\"bp\">&lt;</span><span class=\"n\">num</span><span class=\"bp\">&gt;'</span> <span class=\"n\">to</span> <span class=\"n\">set</span> <span class=\"n\">the</span> <span class=\"n\">limit</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I don't know whether this is intended behavior.</p>\n<p>The notation idea is working great, though. Thank you for the suggestion.</p>",
        "id": 425799717,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1710099785
    },
    {
        "content": "<p>Yes, it does seem like I really want something like <code>parameter</code>, though.</p>",
        "id": 425800042,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1710100041
    }
]