[
    {
        "content": "<p>Basic question, as usual. Here's a simplified example of what I'm trying to do, which involves reflection of some non-computable things into syntax.:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MyNat</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">toMyNat</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">myPlus</span> <span class=\"o\">:</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span> <span class=\"bp\">→</span> <span class=\"n\">MyNat</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">↦</span> <span class=\"n\">Nat.add</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">reify</span> <span class=\"o\">:</span> <span class=\"n\">Syntax</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">MyNat</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">num</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"bp\">$</span> <span class=\"n\">toMyNat</span> <span class=\"n\">n.getNat</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Nat.add</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">$</span><span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">vt</span> <span class=\"bp\">←</span> <span class=\"n\">reify</span> <span class=\"n\">t</span>\n    <span class=\"k\">let</span> <span class=\"n\">vu</span> <span class=\"bp\">←</span> <span class=\"n\">reify</span> <span class=\"n\">u</span>\n    <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"bp\">$</span> <span class=\"n\">myPlus</span> <span class=\"n\">vt</span> <span class=\"n\">vu</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">none</span>\n\n\n<span class=\"k\">#check</span> <span class=\"n\">reify</span> <span class=\"o\">(</span><span class=\"n\">Syntax.mkApp</span> <span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"bp\">`</span><span class=\"n\">Nat.add</span><span class=\"o\">)</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">Syntax.mkNumLit</span> <span class=\"s2\">\"0\"</span><span class=\"o\">,</span> <span class=\"n\">Syntax.mkNumLit</span> <span class=\"s2\">\"1\"</span><span class=\"o\">])</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">myPlus</span> <span class=\"o\">(</span><span class=\"n\">toMyNat</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">toMyNat</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">reify</span> <span class=\"o\">(</span><span class=\"n\">Syntax.mkApp</span> <span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"bp\">`</span><span class=\"n\">Nat.add</span><span class=\"o\">)</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">Syntax.mkNumLit</span> <span class=\"s2\">\"0\"</span><span class=\"o\">,</span> <span class=\"n\">Syntax.mkNumLit</span> <span class=\"s2\">\"1\"</span><span class=\"o\">])</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Perhaps unsurprisingly, <code>rfl</code> fails. Additionally, the <code>reify</code> definition gives an error: </p>\n<p><code>compiler IR check failed at 'reify', error: unknown declaration 'myPlus'</code></p>\n<p>My high-level questions are:</p>\n<ul>\n<li>Am I going about this all wrong? Should I be using a different type instead of <code>Syntax</code> (maybe <code>Lean.Expr</code>)? Is there a worked example somewhere? I'm trying to stare at \"Metaprogramming in Lean\", but I'm not sure where to start.</li>\n<li>How would I go about debugging my code? The \"guess the value and try <code>rfl</code>\" technique is going to stop working pretty quickly I'd guess.</li>\n</ul>",
        "id": 424956550,
        "sender_full_name": "Cody Roux",
        "timestamp": 1709672493
    },
    {
        "content": "<p><a href=\"#narrow/stream/287929-mathlib4/topic/Pretty-printing.20of.20sums/near/355279588\">Here's a diagram</a> that might help with understanding Syntax vs Expr.</p>\n<p>I sort of think about this as</p>\n<ol>\n<li>Lean has an algebraic textual language, but</li>\n<li>it gets parsed to use a Lisp-like data structure (the Syntax type)</li>\n<li>and this then gets elaborated into an actual Expr expression, with all the types all worked out.</li>\n</ol>\n<p>I don't think anyone uses Syntax for reflection. There aren't really any computations you can do on Syntax directly that you can prove anything about -- the Syntax doesn't \"mean\" anything except for what it elaborates to. Most of the Lean system works on Exprs, which you can do various computations on.</p>",
        "id": 424965067,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709676039
    },
    {
        "content": "<p>Regarding your <code>reify</code> function, you marked <code>myPlus</code> as noncomputable, so in <code>.some $ myPlus vt vu</code> what is it supposed to compute? That \"compiler IR check\" is trying to say that it can't compile <code>reify</code> into executable code.</p>",
        "id": 424965208,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709676106
    },
    {
        "content": "<p>The <code>reduce</code> tactic can sometimes be useful for trying to figure out why <code>rfl</code> doesn't work. But, a big obstruction here is that <code>reify</code> is marked <code>partial</code>, which causes the function to not be something you can prove anything about.</p>",
        "id": 424965812,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709676361
    },
    {
        "content": "<p>Thanks, this is quite helpful.</p>",
        "id": 425015767,
        "sender_full_name": "Cody Roux",
        "timestamp": 1709706411
    },
    {
        "content": "<p>Slightly more advanced question:</p>\n<p>Suppose I want a tactic to</p>\n<ul>\n<li>Grab the \"main\" goal</li>\n<li>apply a <code>reify_and_eval : Expr -&gt; Prop</code> function to it</li>\n<li>replace the goal with the result</li>\n</ul>\n<p>How would I do this?</p>\n<p>what I have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">elab</span> <span class=\"s2\">\"reify_goal_fol\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span>\n <span class=\"n\">Lean.Elab.Tactic.withMainContext</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">goal</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.Elab.Tactic.getMainGoal</span>\n  <span class=\"k\">let</span> <span class=\"n\">goalDec</span> <span class=\"bp\">←</span> <span class=\"n\">goal.getDecl</span>\n  <span class=\"k\">let</span> <span class=\"n\">goalTy</span> <span class=\"o\">:=</span> <span class=\"n\">goalDec.type</span>\n  <span class=\"n\">dbg_trace</span> <span class=\"n\">f</span><span class=\"bp\">!</span><span class=\"s2\">\"goal: {goal.name}\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">newRepr</span> <span class=\"o\">:=</span> <span class=\"n\">reifySentence</span> <span class=\"n\">goalTy</span>\n  <span class=\"k\">match</span> <span class=\"n\">newRepr</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"n\">φ</span> <span class=\"bp\">=&gt;</span> <span class=\"c1\">-- here we want to replace the goal with `eval φ`, say `suffices eval φ by rfl`</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">error</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Lean.Meta.throwTacticEx</span> <span class=\"bp\">`</span><span class=\"n\">reify_goal_fol</span> <span class=\"n\">goal</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 425605592,
        "sender_full_name": "Cody Roux",
        "timestamp": 1709931272
    },
    {
        "content": "<p>You could use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.replaceTargetDefEq#doc\">docs#Lean.MVarId.replaceTargetDefEq</a> to change the target to something that is definitionally equal.</p>",
        "id": 425647514,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1709959118
    },
    {
        "content": "<p>Yes! Now my \"final\" issue: the target is of type <code>Prop</code>, but it needs to be of type <code>Lean.Expr</code>. I suspect there's some function to get the syntax back out?</p>",
        "id": 425701069,
        "sender_full_name": "Cody Roux",
        "timestamp": 1710002693
    },
    {
        "content": "<p>If your term of type <code>Prop</code> was produced by applying your <code>reify_and_eval</code> function to the target, you can do <code>mkApp (mkConst ``reify_and_eval []) goalTy</code> to get the new target as an expression.</p>",
        "id": 425702116,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1710003411
    },
    {
        "content": "<p>I'm doing something wrong here: In reality I have a function <code>reify : Expr -&gt; Option MySyntax</code> and a function <code>eval : MySyntax -&gt; Prop</code>. If all goes well <code>reify gType</code> returns a <code>.some syn</code> and <code>eval syn</code> returns something definitionally equal to <code>gType</code>.</p>\n<p>But I have to deal with that option type. Surely I'm doing something wrong?</p>\n<p>The X/Y problem here: I have a theorem of the form <code>eval Foo &lt;-&gt; Bar</code> which I want to apply, but my goal is not of the form <code>eval Foo</code>.</p>",
        "id": 425704124,
        "sender_full_name": "Cody Roux",
        "timestamp": 1710004947
    },
    {
        "content": "<p>Maybe you could apply <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Option.get%21#doc\">docs#Option.get!</a> on the output of <code>reify</code> to avoid having to keep the <code>Option</code> type (this is probably not the most principled way to deal with it, but it may be good enough for this situation). This will require synthesizing an instance of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Inhabited#doc\">docs#Inhabited</a> for <code>MySyntax</code>.</p>",
        "id": 425750150,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1710053414
    },
    {
        "content": "<p>Ok, <em>here's</em> the X/Y problem, summarized conveniently with  the <a href=\"https://github.com/leanprover-community/quote4\">Qq</a> package:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Qq</span>\n\n\n<span class=\"kd\">inductive</span> <span class=\"n\">BoolTree</span> <span class=\"o\">:=</span>\n<span class=\"bp\">|</span> <span class=\"n\">trueLeaf</span> <span class=\"o\">:</span> <span class=\"n\">BoolTree</span>\n<span class=\"bp\">|</span> <span class=\"n\">falseLeaf</span> <span class=\"o\">:</span> <span class=\"n\">BoolTree</span>\n<span class=\"bp\">|</span> <span class=\"n\">andNode</span> <span class=\"o\">:</span> <span class=\"n\">BoolTree</span> <span class=\"bp\">→</span> <span class=\"n\">BoolTree</span> <span class=\"bp\">→</span> <span class=\"n\">BoolTree</span>\n<span class=\"bp\">|</span> <span class=\"n\">orNode</span> <span class=\"o\">:</span> <span class=\"n\">BoolTree</span> <span class=\"bp\">→</span> <span class=\"n\">BoolTree</span> <span class=\"bp\">→</span> <span class=\"n\">BoolTree</span>\n<span class=\"bp\">|</span> <span class=\"n\">negNode</span> <span class=\"o\">:</span> <span class=\"n\">BoolTree</span> <span class=\"bp\">→</span> <span class=\"n\">BoolTree</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">evalsToTrue</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">BoolTree</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">trueLeaf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">falseLeaf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">andNode</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">evalsToTrue</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"n\">evalsToTrue</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">orNode</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">evalsToTrue</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">||</span> <span class=\"o\">(</span><span class=\"n\">evalsToTrue</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">negNode</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">!</span><span class=\"o\">(</span><span class=\"n\">evalsToTrue</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">evalsToTrue</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">negNode</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">andNode</span> <span class=\"bp\">.</span><span class=\"n\">trueLeaf</span> <span class=\"bp\">.</span><span class=\"n\">falseLeaf</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">interp</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">BoolTree</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">trueLeaf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">falseLeaf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">andNode</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">interp</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">interp</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">orNode</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">interp</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">interp</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">negNode</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">interp</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- tedious but straightforward</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">evalsToTrue_interp_aux</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">evalsToTrue</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">interp</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">evalsToTrue</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">false</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span> <span class=\"n\">interp</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">interp</span><span class=\"o\">,</span> <span class=\"n\">evalsToTrue</span><span class=\"o\">]</span>\n  <span class=\"n\">case</span> <span class=\"n\">andNode</span> <span class=\"n\">ih₁</span> <span class=\"n\">ih₂</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">case</span> <span class=\"n\">orNode</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">case</span> <span class=\"n\">negNode</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">evalsToTrue_interp_true</span> <span class=\"o\">:</span> <span class=\"n\">evalsToTrue</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">interp</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">evalsToTrue_interp_aux.1</span>\n\n<span class=\"c1\">-- FIXME: find a better way to do this</span>\n<span class=\"kd\">def</span> <span class=\"n\">map₂</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">av</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">bv</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">av</span> <span class=\"n\">bv</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">none</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">toInterp</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Prop</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">BoolTree</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n<span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">True</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"bp\">.</span><span class=\"n\">trueLeaf</span>\n<span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"bp\">.</span><span class=\"n\">falseLeaf</span>\n<span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">let</span> <span class=\"n\">av</span> <span class=\"bp\">←</span> <span class=\"n\">toInterp</span> <span class=\"n\">a</span>\n  <span class=\"k\">let</span> <span class=\"n\">bv</span> <span class=\"bp\">←</span> <span class=\"n\">toInterp</span> <span class=\"n\">b</span>\n  <span class=\"n\">return</span> <span class=\"n\">map₂</span> <span class=\"n\">BoolTree.andNode</span> <span class=\"n\">av</span> <span class=\"n\">bv</span>\n<span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">let</span> <span class=\"n\">av</span> <span class=\"bp\">←</span> <span class=\"n\">toInterp</span> <span class=\"n\">a</span>\n  <span class=\"k\">let</span> <span class=\"n\">bv</span> <span class=\"bp\">←</span> <span class=\"n\">toInterp</span> <span class=\"n\">b</span>\n  <span class=\"n\">return</span> <span class=\"n\">map₂</span> <span class=\"n\">BoolTree.orNode</span> <span class=\"n\">av</span> <span class=\"n\">bv</span>\n<span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">¬</span> <span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">let</span> <span class=\"n\">av</span> <span class=\"bp\">←</span> <span class=\"n\">toInterp</span> <span class=\"n\">a</span>\n  <span class=\"n\">return</span> <span class=\"n\">Option.map</span> <span class=\"n\">BoolTree.negNode</span> <span class=\"n\">av</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">none</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">toInterp</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">True</span> <span class=\"bp\">∧</span> <span class=\"n\">True</span> <span class=\"bp\">∨</span> <span class=\"n\">False</span><span class=\"o\">))</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"reflect_tac\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span>\n <span class=\"n\">Lean.Elab.Tactic.withMainContext</span> <span class=\"k\">do</span>\n <span class=\"n\">Lean.Elab.Tactic.withMainContext</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">goal</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.Elab.Tactic.getMainGoal</span>\n  <span class=\"k\">let</span> <span class=\"n\">goalDec</span> <span class=\"bp\">←</span> <span class=\"n\">goal.getDecl</span>\n  <span class=\"k\">let</span> <span class=\"n\">goalTy</span> <span class=\"o\">:=</span> <span class=\"n\">goalDec.type</span>\n  <span class=\"n\">dbg_trace</span> <span class=\"n\">f</span><span class=\"bp\">!</span><span class=\"s2\">\"goal: {goal.name}\"</span>\n  <span class=\"k\">match</span> <span class=\"bp\">←</span> <span class=\"n\">toInterp</span> <span class=\"n\">goalTy</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">dbg_trace</span> <span class=\"n\">f</span><span class=\"bp\">!</span><span class=\"s2\">\"Failed to reify\"</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">tree</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">qtree</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">BoolTree</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">tree</span><span class=\"o\">)</span> <span class=\"c1\">-- &lt;-- this is the problematic line!</span>\n    <span class=\"k\">let</span> <span class=\"n\">newGoal</span> <span class=\"bp\">←</span> <span class=\"n\">MVarId.replaceTargetDefEq</span> <span class=\"n\">goal</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">interp</span> <span class=\"bp\">$</span><span class=\"n\">qtree</span><span class=\"o\">)</span>\n    <span class=\"n\">Elab.Tactic.replaceMainGoal</span> <span class=\"o\">[</span><span class=\"n\">newGoal</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"bp\">∧</span> <span class=\"n\">True</span> <span class=\"bp\">∨</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">reflect_tac</span>\n  <span class=\"n\">apply</span> <span class=\"n\">evalsToTrue_interp_true</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>The issue is that I reify from \"meta land\" into \"object land\" and want to be able to go back with a dynamically constructed value. IMHO this is how reflection is done in dependently typed languages, but maybe I'm working against the grain here.</p>\n<p>The <code>Option</code> vs not <code>Option</code> is a red herring, I think. <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> or <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> any thoughts?</p>",
        "id": 425838380,
        "sender_full_name": "Cody Roux",
        "timestamp": 1710133845
    },
    {
        "content": "<p>For BoolTree, change the <code>deriving</code> line to <code>deriving Repr, ToExpr</code>, assuming you are using Mathlib, which has a ToExpr deriver</p>",
        "id": 425838875,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710134356
    },
    {
        "content": "<p>That creates a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.ToExpr#doc\">docs#Lean.ToExpr</a> instance for reifying a runtime value to an Expr</p>",
        "id": 425838896,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710134387
    },
    {
        "content": "<p>With that, the proof goes through as-is.</p>\n<p>Here's some additional refinement of your tactic though:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">elab</span> <span class=\"s2\">\"reflect_tac\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span>\n <span class=\"n\">Lean.Elab.Tactic.withMainContext</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">goal</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.Elab.Tactic.getMainGoal</span>\n  <span class=\"k\">let</span> <span class=\"n\">goalTy</span> <span class=\"bp\">←</span> <span class=\"n\">goal.getType</span>\n  <span class=\"k\">match</span> <span class=\"bp\">←</span> <span class=\"n\">toInterp</span> <span class=\"n\">goalTy</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"Failed to reify\"</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">tree</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">qtree</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">BoolTree</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">tree</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">newGoal</span> <span class=\"bp\">←</span> <span class=\"n\">MVarId.replaceTargetDefEq</span> <span class=\"n\">goal</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">interp</span> <span class=\"bp\">$</span><span class=\"n\">qtree</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"o\">[</span><span class=\"n\">newGoal</span><span class=\"o\">]</span> <span class=\"bp\">←</span> <span class=\"n\">newGoal.applyConst</span> <span class=\"bp\">``</span><span class=\"n\">evalsToTrue_interp_true</span> <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"Failure applying lemma\"</span>\n    <span class=\"n\">newGoal.refl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"bp\">∧</span> <span class=\"n\">True</span> <span class=\"bp\">∨</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">reflect_tac</span>\n</code></pre></div>",
        "id": 425839095,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710134633
    },
    {
        "content": "<p>Thank you this was extraordinarily helpful!</p>",
        "id": 426039749,
        "sender_full_name": "Cody Roux",
        "timestamp": 1710208597
    }
]