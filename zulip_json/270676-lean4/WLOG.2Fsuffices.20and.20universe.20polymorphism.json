[
    {
        "content": "<p>I'm proving a theorem of the form,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foobar.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">,</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">tx</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ty</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">|</span><span class=\"n\">some_func</span> <span class=\"n\">tx</span> <span class=\"bp\">-</span> <span class=\"n\">some_func</span> <span class=\"n\">ty</span><span class=\"bp\">|</span> <span class=\"bp\">&lt;=</span>\n   <span class=\"n\">other_func</span> <span class=\"n\">tx</span> <span class=\"bp\">+</span> <span class=\"n\">other_func</span> <span class=\"n\">ty</span>\n</code></pre></div>\n<p>Now what I <em>really</em> want to bother proving is that <code>some_func tx - some_func ty &lt;= other_func tx + other_func ty</code>, and then I take the max on the left hand side, and swap x and y if needed. So I write something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">wlog</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">some_func</span> <span class=\"n\">tx</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">some_func</span> <span class=\"n\">ty</span>\n</code></pre></div>\n<p>and then I want to use <code>this ty tx</code> to show this is sufficient. (Essentially identical logic if I use <code>suffices</code> manually instead of <code>wlog</code>).</p>\n<p>But this doesn't work! Because the theorem statement has <code>tx</code> in universe <code>u_1</code> and <code>ty</code> in universe <code>u_2</code>, so I can't pass <code>ty</code> into <code>this</code> because it's at the wrong universe level.</p>\n<p>I tried manually doing it with <code>suffices</code>, but I can't see anyway to make the suffices statement universe polymorphic. (At the time I write the hypothesis, I have to instantiate particular universes; I can't use that hypothesis subsequently with different universe levels.) I tried doing <code>suffices {tx : Type (max u_1 u_2)}</code> or something but of course that didn't work either. I would ideally have something like,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">suffices</span> <span class=\"n\">h.</span><span class=\"o\">{</span><span class=\"n\">u3</span><span class=\"o\">,</span><span class=\"n\">u4</span><span class=\"o\">}</span> <span class=\"o\">:</span>  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">tx</span> <span class=\"o\">:</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ty</span> <span class=\"o\">:</span> <span class=\"n\">u_4</span><span class=\"o\">}</span> <span class=\"bp\">...</span> <span class=\"kd\">by</span>\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"o\">:</span>  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">u_3</span> <span class=\"o\">:</span> <span class=\"kd\">universes</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">u_4</span> <span class=\"o\">:</span> <span class=\"kd\">universes</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">tx</span> <span class=\"o\">:</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ty</span> <span class=\"o\">:</span> <span class=\"n\">u_4</span><span class=\"o\">}</span> <span class=\"bp\">...</span> <span class=\"kd\">by</span>\n</code></pre></div>\n<p>or something like that.</p>",
        "id": 435455723,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1714074159
    },
    {
        "content": "<p>I'm aware that one solution is \"just pull out the thing you're proving and prove it in a separate theorem first\".<br>\nBut if that 'separate thing' is an ugly lemma that depends on (say) a <code>Nat</code> in the context of the larger theorem, that can be quite ugly to pull out! And feels like a nasty hack of a solution</p>",
        "id": 435455855,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1714074222
    },
    {
        "content": "<p>On the other hand, the fact that you <em>could</em> always pull out whatever you need to get the universe polymorphism back feels like exactly a case for why this should be possible. Clearly it doesn't compromise Lean's type system in anyway. In the same way that various tactics, or props in <code>defs</code>, get pulled out into separate <code>.proof_N</code> or <code>auxLemma</code> top-level objects, surely there's a way to have a <code>suffices</code> that (if needed) gives me the new thing at the top level with a universe polymorphism?</p>",
        "id": 435456140,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1714074344
    },
    {
        "content": "<p>I'm fairly certain this isn't possible without making <code>foobar</code> depend on the universes <code>u3</code> and <code>u4</code>, which is problematic because they don't appear in the statement. The claim \"clearly it doesn't compromise Lean's type system in any way\" is not so obvious to me (but IANA type theorist), unless it is actually pulled out as a top-level object, at which point you could just do that yourself. <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 435466020,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714078370
    },
    {
        "content": "<p>Even I make <code>foobar</code> dependent on <code>u_3</code> and <code>u_4</code>, it doesn't work, because I can't 'plug in' <code>u_1</code> for <code>u_3</code> in my suffices or something. I don't see any way to do _besides_ pulling it out as a top-level object.</p>",
        "id": 435466337,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1714078496
    },
    {
        "content": "<p>IANA type theorist either, but I feel reasonably confident in the claim \"if I can construct a type T using a type U where U is a top-level object, I can also construct a type T using U in a let-clause\"</p>",
        "id": 435466413,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1714078536
    },
    {
        "content": "<p>If it's inconceivable that you would ever need to apply this with two different universes then you could always just put the types in the same universe. This is usually my first reaction to universe problems. My impression is that we're only maximally universe polymorphic by default because it's there, not because it's actually useful in practice</p>",
        "id": 435466512,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1714078566
    },
    {
        "content": "<p>Kevin, surely that isn't true for anything that tangentially interacts with the category theory portion of of the library, right?</p>",
        "id": 435466891,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714078709
    },
    {
        "content": "<p>(because universe bumps are forced there)</p>",
        "id": 435466935,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714078736
    },
    {
        "content": "<p>It's pretty inconceivable, sure. But it's a fact I want to use in other places that I've <code>sorry</code>ed out, and <em>they</em> all <em>also</em> make the same \"lazy\" choice of having universes not actually be equal. So if I make the universes equal here, everything else using this must also be changed to be universe symmetric. That feels a bit worse.</p>",
        "id": 435466961,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1714078749
    },
    {
        "content": "<p>Does <code>let rec</code> work here? It genuinely extracts a definition unlike have</p>",
        "id": 435480643,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714086430
    },
    {
        "content": "<p>Jireh my impression is that whenever there are universe <em>problems</em> then this is an indication that we're being too polymorphic, which is why my go-to fix is to be less polymorphic. I know that we've tried lots of other fixes instead but I'm just saying my opinion.</p>",
        "id": 435486839,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1714091142
    },
    {
        "content": "<p><code>let rec</code> sadly does not work. Although I can introduce fresh universe variables there, they get added as universe variables in the enclosing theorem, so they are already \"bound\" to some particular (abstract) values when I want to apply it. The same is true for term-mode <code>let rec</code>. Good idea, though.</p>",
        "id": 435642558,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1714157860
    },
    {
        "content": "<p>I don't know enough about Lean at the 'basic level' but maybe this is actually just not supported by Lean syntax (even though it's supported by the underlying type theory, by e.g. defining it externally to the theorem)?</p>",
        "id": 435642686,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1714157918
    },
    {
        "content": "<p>It's quite strange, so if I do <code>let rec myWlog := </code>∀ (d₁ : Type<em>) {d₂ : Type</em>} ...<code>, then it creates new universe variables and adds them as universe parameters to the enclosing theorem </code>foobar<code> so that it's </code>foobar.{u1,u2,u3,u4}`.</p>\n<p>If I do <code>#print foobar.myWlog</code>, I see a type like what I want:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foobar.myWlog.</span><span class=\"o\">{</span><span class=\"n\">u1</span><span class=\"o\">,</span><span class=\"n\">u2</span><span class=\"o\">,</span><span class=\"n\">u3</span><span class=\"o\">,</span><span class=\"n\">u4</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">d₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">d₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_4</span><span class=\"o\">}</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>But! That's not the type I actually have access to, as given by <code>let rec</code>! The only <code>myWlog</code> I'm able to access within the proof of foobar, is the one where <code>myWlog</code> has been instantiated already with the universe variables <code>u1,u2,u3,u4</code> from the enclosing scope.</p>",
        "id": 435643664,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1714158365
    },
    {
        "content": "<p>If I try to pass in universe variables, I get <code>invalid use of explicit universe parameters, 'myWlog' is a local</code>.</p>",
        "id": 435643724,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1714158405
    },
    {
        "content": "<p>The same thing happens if I do <code>theorem foobar ... := by (.....) where myWlog = .... </code>.</p>",
        "id": 435643814,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1714158455
    },
    {
        "content": "<p>I would argue that when you're saying \"it's supported by the underlying type theory\", that it really isn't. When you make a declaration that's external to the theorem, it may be universe <em>polymorphic</em>, but it's not one <code>Lean.Expr</code> that holds for all universes. Rather, each universe can be inserted into the declaration to get a new <code>Lean.Expr</code> (this is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr.const#doc\">docs#Lean.Expr.const</a>). So, if you declare it externally, and then use it in the proof twice, you are actually using two different expressions. Whereas, if you try to make it universe polymorphic in the proof it would require you to make an expression in the proof of the form \"for all universes ...\", which can't exist in the type theory.</p>\n<p>Now, in practice, you are only using the two universes in scope, so you don't actually need the \"for all universes\" statement, you just need the two individual ones (i.e., the <code>u1,u2</code> and the <code>u2,u1</code> instantiations).</p>",
        "id": 435644999,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714159030
    },
    {
        "content": "<p>I guess I understand why <code>let rec</code> works this way -- you want it to be able to bind variables in the surrounding statement. If your internal statement depends on external values, then you also depend on their universes. The new definition exists at the top level, and it takes the form <code>(localValues) -&gt; letRecGivenType</code>. But you don't want to have to manually go plugging all of the local variables in yourself, so <code>let rec</code> does that for you and just gives you the (possibly dependent) type that you asked for.</p>\n<p>This object you get has already been instantiated with some arguments, which also means all of its universe arguments have to be instantiated. Sadly this is true even if your let rec depends on no local variables. If lean supported \"mixed\" arguments and universes, this could be avoided, but I don't think that's possible.</p>",
        "id": 435645488,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1714159228
    },
    {
        "content": "<p>Alright Jireh, that's a fair point, I'll have to think about that a bit</p>",
        "id": 435646156,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1714159531
    },
    {
        "content": "<p>I think an interesting instance to think about is something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">twoUs</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">usingIt</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">oneArg</span> <span class=\"o\">:=</span> <span class=\"n\">twoUs</span> <span class=\"n\">ℕ</span>\n  <span class=\"k\">if</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span> <span class=\"k\">then</span>\n    <span class=\"n\">oneArg</span> <span class=\"n\">ℚ</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">oneArg</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"c1\">--error</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">usingIt'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span> <span class=\"k\">then</span>\n    <span class=\"n\">twoUs</span> <span class=\"n\">ℕ</span> <span class=\"n\">ℚ</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">twoUs</span> <span class=\"n\">ℕ</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>whatever <code>twoUs</code> is, <code>usingIt</code> is trying to trying to plug in two arguments to get an output. The first one doesn't compile and the second one does, even though the second is <em>precisely</em> the result of plugging that <code>let</code> in to both cases where it might be used. The <code>let</code> instantiates <code>twoUs</code> at some particular universe level. It doesn't know what yet -- that gets filled in later -- but it needs to fill it in with something. In the first case, it can't do that consistently across both branches. It's the same with let rec.</p>\n<p>Sorry if I'm rambling a bit, I'm trying to figure this out myself too</p>",
        "id": 435646710,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1714159740
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/stream/270676-lean4/topic/WLOG.2Fsuffices.20and.20universe.20polymorphism/near/435646710\">said</a>:</p>\n<blockquote>\n<p>even though the second is <em>precisely</em> the result of plugging that <code>let</code> in to both cases where it might be used</p>\n</blockquote>\n<p>No, it's not. <code>oneArg</code> doesn't have a universe as a (universe level) <em>implicit argument</em>, it has a universe <em>metavariable</em>. So after the first branch, that metavariable is instantiated, and then it can't work in the second branch. In contrast, the two <code>twoUs</code> in the branches of <code>UsingIt'</code> are actually different, and have instantiated the universe level implicit arguments differently.</p>",
        "id": 435648198,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714160377
    },
    {
        "content": "<p>Sorry, I meant plugging in the string (which is obviously not a very meaningful notion in general). I get why it's happening. It's just weird</p>",
        "id": 435649472,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1714161024
    },
    {
        "content": "<p>If you step through the tactic state here, it may help.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">oneArg</span> <span class=\"o\">:=</span> <span class=\"n\">twoUs</span> <span class=\"n\">ℕ</span>\n  <span class=\"k\">let</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"n\">twoUs</span> <span class=\"n\">ℕ</span> <span class=\"n\">ℚ</span>\n  <span class=\"k\">let</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"n\">twoUs</span> <span class=\"n\">ℕ</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">baz</span> <span class=\"o\">:=</span> <span class=\"n\">oneArg</span> <span class=\"n\">ℚ</span>\n  <span class=\"k\">let</span> <span class=\"n\">broken</span> <span class=\"o\">:=</span> <span class=\"n\">oneArg</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 435649596,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714161090
    },
    {
        "content": "<p>Another thing, if you try to explicitly construct the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr#doc\">docs#Lean.Expr</a> you want to correspond to <code>oneArg</code>, I think you'll see why you have to put a metavariable in for the universe level. There's nothing else you can put there. This is what I mean when I say it's not supported by the underlying type theory.</p>",
        "id": 435649904,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714161237
    },
    {
        "content": "<p>Oh no, it looks like you're running into a bug in <code>Type*</code> that I've know about but never have seen anyone run into it yet. The <code>Type*</code> elaborator adds the universe level to the current declaration, and it really only makes sense in the top level binder list. Maybe try using <code>Type _</code> instead for your <code>let rec</code>?</p>",
        "id": 435667422,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714170204
    },
    {
        "content": "<p>To underscore this, <code>Type*</code> <em>modifies</em> the current list of universe levels. Using in the body of a declaration is not supported, and I should make it throw an error if you try.</p>",
        "id": 435667459,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714170241
    },
    {
        "content": "<p>Mm, switching to <code>Type _</code> makes <code>myWlog</code> have universe metavariables, and avoids adding new universe variables to the top level. So I can then apply it to one case or the other. But, same as the <code>let ... </code> thing talked about above, those metavariables get fixed the first time I use it, so I can't change it the other time. In fact it seems to become part of the definition of <code>myWlog</code>, that <code>#print foobar.myWlog</code> shows its declaration has its universe variables explicitly bound to be one pair or the other. That makes sense with how metavariables work in retrospect, but I admit was not what I expected</p>",
        "id": 435753764,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1714221295
    },
    {
        "content": "<p>I was able to write a simple elaborator that effectively accomplishes this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u_1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n  <span class=\"n\">auxU</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">t</span> <span class=\"bp\">↦</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"n\">exact</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">x.z</span> <span class=\"n\">y</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">x.z</span> <span class=\"mi\">37</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 435765451,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1714231218
    },
    {
        "content": "<p>my <code>auxU</code> declares the term given as <code>x.z</code>, or whatever the variable name is within  the current enclosing name; and then also gives a <code>let z := ...</code> to use it immediately. So I use it once as <code>z Rat</code> at universe level 1, but then I can also use it at the universe levels <code>u_2</code> (for F) and <code>u_1+1</code> if I want to, by referring to in the enclosing name</p>",
        "id": 435765802,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1714231356
    },
    {
        "content": "<p>It binds the surrounding <code>y</code> into the closure so that if I use it directly (as <code>z</code>) I don't need to pass that back in; subsequent calls do of course. So there I pass in <code>y</code> the second time (or I can pass in something else like 37 if I want to)</p>",
        "id": 435766216,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1714231524
    },
    {
        "content": "<p>Ideally I would make another elaborator like <code>getAux</code> so that <code>getAux z</code> gets me the variable again (without needing to explicitly refer to the name of the surrounding function, which feels hacky) and could also provide the closure'd fvars again. But idk if I'll go that far</p>",
        "id": 435766353,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1714231582
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 435766493,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1714231696
    },
    {
        "content": "<p>This feels like a shortcoming in the syntax of <code>where</code> and <code>let rec</code> to me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">u'</span> <span class=\"n\">v'</span>\n\n<span class=\"c1\">-- fails</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">α</span>  <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">aux</span> <span class=\"o\">(</span><span class=\"n\">α'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α'</span> <span class=\"bp\">→</span> <span class=\"n\">β'</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n  <span class=\"o\">⟨</span><span class=\"n\">aux</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">aux</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- fails</span>\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">{</span><span class=\"n\">α</span>  <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">aux</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">aux</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">⟩</span>\n<span class=\"n\">where</span> <span class=\"n\">aux</span> <span class=\"o\">(</span><span class=\"n\">α'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α'</span> <span class=\"bp\">→</span> <span class=\"n\">β'</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n\n<span class=\"c1\">--works</span>\n<span class=\"kd\">def</span> <span class=\"n\">aux</span> <span class=\"o\">(</span><span class=\"n\">α'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α'</span> <span class=\"bp\">→</span> <span class=\"n\">β'</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n<span class=\"kd\">def</span> <span class=\"n\">baz</span> <span class=\"o\">{</span><span class=\"n\">α</span>  <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">aux</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">aux</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>It seems like <code>where aux.{u',v'}</code> could be legal syntax, and then everything would behave reasonably</p>",
        "id": 435767238,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714232358
    },
    {
        "content": "<p>I agree that it feels like a syntactic deficiency, but I don't think you could make </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">baz</span> <span class=\"o\">{</span><span class=\"n\">α</span>  <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">aux</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">aux</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">⟩</span> <span class=\"n\">where...</span>\n</code></pre></div>\n<p>work without actually changing the definition of <code>TermM</code> (or maybe <code>MetaM</code>?) to include extra data -- because you can't have one local variable <code>aux</code> that works for both</p>",
        "id": 435768925,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1714233439
    }
]