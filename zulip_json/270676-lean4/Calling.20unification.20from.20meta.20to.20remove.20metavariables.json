[
    {
        "content": "<p>I'm trying to build an expr in meta code and I know it's type, but the type has some metavariables at elaboration time that could be figured out through unification (and in fact <code>def</code> has no trouble with that unification). How do I call unification explicitly to get rid of those metavariables? Here's an MWE, maybe that makes more sense:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Command</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk0</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mkn</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">n</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Foo0</span> <span class=\"o\">:=</span> <span class=\"n\">Foo</span> <span class=\"mi\">0</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo0</span> <span class=\"o\">:=</span> <span class=\"n\">Foo.mk0</span>\n<span class=\"k\">#check</span> <span class=\"n\">foo0</span> <span class=\"c1\">-- foo0 : Foo 0</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo0'</span> <span class=\"o\">:=</span> <span class=\"n\">Foo.mkn</span> <span class=\"mi\">0</span>\n<span class=\"k\">#check</span> <span class=\"n\">foo0'</span> <span class=\"c1\">-- foo0' : Foo 0</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">ppExprCmd</span><span class=\"o\">)</span> <span class=\"s2\">\"#ppExpr\"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">evalFoo0Cmd</span><span class=\"o\">)</span> <span class=\"s2\">\"#evalFoo0\"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">command_elab</span> <span class=\"n\">ppExprCmd</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">ppExprCmdImpl</span> <span class=\"o\">:</span> <span class=\"n\">CommandElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">expr</span> <span class=\"bp\">←</span> <span class=\"n\">liftTermElabM</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.elabTerm</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"n\">none</span>\n  <span class=\"n\">liftTermElabM</span> <span class=\"n\">Elab.Term.synthesizeSyntheticMVarsNoPostponing</span>\n  <span class=\"n\">logInfo</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{repr expr}\"</span>\n  <span class=\"n\">return</span> <span class=\"o\">()</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">command_elab</span> <span class=\"n\">evalFoo0Cmd</span><span class=\"kd\">]</span>\n<span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">evalExprCmdImpl</span> <span class=\"o\">:</span> <span class=\"n\">CommandElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">expr</span> <span class=\"bp\">←</span> <span class=\"n\">liftTermElabM</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.elabTerm</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"n\">none</span>\n  <span class=\"n\">liftTermElabM</span> <span class=\"n\">Elab.Term.synthesizeSyntheticMVarsNoPostponing</span>\n  <span class=\"k\">let</span> <span class=\"n\">foo0</span> <span class=\"bp\">←</span> <span class=\"n\">liftTermElabM</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Lean.Meta.evalExpr'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">Foo</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">`</span><span class=\"n\">Foo0</span> <span class=\"n\">expr</span>\n  <span class=\"n\">logInfo</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{repr foo0}\"</span>\n  <span class=\"n\">return</span> <span class=\"o\">()</span>\n\n<span class=\"bp\">#</span><span class=\"n\">ppExpr</span> <span class=\"n\">Foo.mkn</span> <span class=\"mi\">0</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Lean.Expr.app</span>\n<span class=\"cm\">  (Lean.Expr.const `Foo.mkn [])</span>\n<span class=\"cm\">  (Lean.Expr.app</span>\n<span class=\"cm\">    (Lean.Expr.app</span>\n<span class=\"cm\">      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.mvar (Lean.Name.mkNum `_uniq 1999)))</span>\n<span class=\"cm\">      (Lean.Expr.lit (Lean.Literal.natVal 0)))</span>\n<span class=\"cm\">    (Lean.Expr.mvar (Lean.Name.mkNum `_uniq 2000)))</span>\n<span class=\"cm\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">evalFoo0</span> <span class=\"n\">Foo.mkn</span> <span class=\"mi\">0</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\"> failed to evaluate expression, it contains metavariables</span>\n<span class=\"cm\">  Foo.mkn 0</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"bp\">#</span><span class=\"n\">ppExpr</span> <span class=\"n\">Foo.mk0</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Lean.Expr.const `Foo.mk0 []</span>\n<span class=\"cm\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">evalFoo0</span> <span class=\"n\">Foo.mk0</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">unexpected type at evalExpr</span>\n<span class=\"cm\">  Foo 0</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 436342877,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1714506545
    },
    {
        "content": "<p>(I realize I'm probably using <code>evalExpr'</code> wrong here but that's orthogonal to this, I guess)</p>",
        "id": 436342978,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1714506585
    },
    {
        "content": "<p>I'm definitely not an expert on meta programming but aren't you forgetting to <code>instantiateMVars</code> in your <code>expr</code> to actually make use of the fact that they might have been resolved by <code>synthesizeSyntheticMVarsNoPostponing</code>?</p>",
        "id": 436343516,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1714506763
    },
    {
        "content": "<p>That said in general the \"entrypoint\" for unification is <code>isDefEq</code> which can end up assigning meta variables under the hood and then you can make use of that gained knowledge using <code>instantiateMVars</code></p>",
        "id": 436343776,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1714506844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/Calling.20unification.20from.20meta.20to.20remove.20metavariables/near/436343516\">said</a>:</p>\n<blockquote>\n<p>I'm definitely not an expert on meta programming but aren't you forgetting to <code>instantiateMVars</code> in your <code>expr</code> to actually make use of the fact that they might have been resolved by <code>synthesizeSyntheticMVarsNoPostponing</code>?</p>\n</blockquote>\n<p>oh, I thought <code>synthesizeSyntheticMVarsNoPostponing</code> would instantiate them. In any case, calling <code>instantiateMVars</code> in that MWE doesn't seem to fix it either</p>",
        "id": 436344028,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1714506956
    },
    {
        "content": "<p>oh but we are a pure programming language, no function is going to touch your expr unless you pass it as arguments^^</p>",
        "id": 436344166,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1714507005
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/Calling.20unification.20from.20meta.20to.20remove.20metavariables/near/436344166\">said</a>:</p>\n<blockquote>\n<p>oh but we are a pure programming language, no function is going to touch your expr unless you pass it as arguments^^</p>\n</blockquote>\n<p>Huh, I'm confused, I thought in a monad it would (why does <code>synthesizeSyntheticMVarsNoPostponing</code> return <code>Unit</code> otherwise)?</p>",
        "id": 436344428,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1714507097
    },
    {
        "content": "<p>well functions like that or <code>isDefEq</code> will register the mvar to be resolved in the context yes. But <code>Expr</code> is still just a piece of data that's flowing around somewhere and it has an <code>.mvar</code> constructor that points to some mvar. When you then call <code>instantiateMVars</code> it will traverse your term, looking for such constructors and if it finds them + a resolved entry in the context it will replace them with whatever the mvar was resolved to</p>",
        "id": 436344801,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1714507218
    },
    {
        "content": "<p>The \"metavariable\" concept consists of a couple things:</p>\n<ol>\n<li>the <code>Expr.mvar</code> node in an expression that contains a metavariable ID</li>\n<li>the table of metavariable declarations in the monad, mapping IDs to <code>Option Expr</code> (the assignments)</li>\n</ol>\n<p>\"Assignment\" is the process of adding entries to the table, and \"instantiation\" is the process of replacing <code>Expr.mvar</code>s with their assigned values in a given expression.</p>",
        "id": 436345766,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714507612
    },
    {
        "content": "<p>Hm, <code>isDefEq</code> also doesn't seem to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Command</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk0</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mkn</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"n\">n</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Foo0</span> <span class=\"o\">:=</span> <span class=\"n\">Foo</span> <span class=\"mi\">0</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo0</span> <span class=\"o\">:=</span> <span class=\"n\">Foo.mk0</span>\n<span class=\"k\">#check</span> <span class=\"n\">foo0</span> <span class=\"c1\">-- foo0 : Foo 0</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo0'</span> <span class=\"o\">:=</span> <span class=\"n\">Foo.mkn</span> <span class=\"mi\">0</span>\n<span class=\"k\">#check</span> <span class=\"n\">foo0'</span> <span class=\"c1\">-- foo0 : Foo 0</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">ppExprCmd</span><span class=\"o\">)</span> <span class=\"s2\">\"#ppExpr\"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">evalFoo0Cmd</span><span class=\"o\">)</span> <span class=\"s2\">\"#evalFoo0\"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">command_elab</span> <span class=\"n\">ppExprCmd</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">ppExprCmdImpl</span> <span class=\"o\">:</span> <span class=\"n\">CommandElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">expr</span> <span class=\"bp\">←</span> <span class=\"n\">liftTermElabM</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Term.elabTerm</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"n\">none</span>\n  <span class=\"n\">liftTermElabM</span> <span class=\"n\">Elab.Term.synthesizeSyntheticMVarsNoPostponing</span>\n  <span class=\"k\">let</span> <span class=\"n\">expr</span> <span class=\"bp\">←</span> <span class=\"n\">liftTermElabM</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">instantiateMVars</span> <span class=\"n\">expr</span>\n  <span class=\"n\">liftTermElabM</span> <span class=\"n\">Elab.Term.synthesizeSyntheticMVarsNoPostponing</span>\n  <span class=\"k\">let</span> <span class=\"n\">tyExpr</span> <span class=\"bp\">←</span> <span class=\"n\">liftTermElabM</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Meta.inferType</span> <span class=\"n\">expr</span>\n  <span class=\"n\">logInfo</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{repr expr}\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"bp\">←</span> <span class=\"n\">liftTermElabM</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Meta.isDefEq</span> <span class=\"n\">tyExpr</span> <span class=\"o\">(</span><span class=\"n\">Expr.const</span> <span class=\"bp\">`</span><span class=\"n\">Foo0</span> <span class=\"o\">[])</span>\n  <span class=\"n\">logInfo</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{repr expr}\"</span>\n  <span class=\"n\">return</span> <span class=\"o\">()</span>\n\n<span class=\"bp\">#</span><span class=\"n\">ppExpr</span> <span class=\"n\">Foo.mkn</span> <span class=\"mi\">0</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Lean.Expr.app</span>\n<span class=\"cm\">  (Lean.Expr.const `Foo.mkn [])</span>\n<span class=\"cm\">  (Lean.Expr.app</span>\n<span class=\"cm\">    (Lean.Expr.app</span>\n<span class=\"cm\">      (Lean.Expr.app (Lean.Expr.const `OfNat.ofNat [Lean.Level.zero]) (Lean.Expr.mvar (Lean.Name.mkNum `_uniq 1781)))</span>\n<span class=\"cm\">      (Lean.Expr.lit (Lean.Literal.natVal 0)))</span>\n<span class=\"cm\">    (Lean.Expr.mvar (Lean.Name.mkNum `_uniq 1782)))</span>\n<span class=\"cm\">MWE.lean:30:0</span>\n<span class=\"cm\">unknown metavariable '?_uniq.1781'</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 436345801,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1714507628
    },
    {
        "content": "<p>Furthermore, a <em>synthetic</em> metavariable also has</p>\n<ol start=\"3\">\n<li>an entry in the synthetic metavariable table, explaining what the elaborator needs to do to synthesize an assignment.</li>\n</ol>\n<p><code>Elab.Term.synthesizeSyntheticMVarsNoPostponing</code> is a checkpoint for evaluating everything in this table, guaranteeing all the synthetic metavariables have assignments (if there is no overt failure), guaranteeing instantiation will eliminate metavariables</p>",
        "id": 436346009,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714507736
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Calling.20unification.20from.20meta.20to.20remove.20metavariables/near/436345766\">said</a>:</p>\n<blockquote>\n<p>The \"metavariable\" concept consists of a couple things:</p>\n<ol>\n<li>the <code>Expr.mvar</code> node in an expression that contains a metavariable ID</li>\n<li>the table of metavariable declarations in the monad, mapping IDs to <code>Option Expr</code> (the assignments)</li>\n</ol>\n<p>\"Assignment\" is the process of adding entries to the table, and \"instantiation\" is the process of replacing <code>Expr.mvar</code>s with their assigned values in a given expression.</p>\n</blockquote>\n<p>I guess then the right order would be</p>\n<ol>\n<li>unification</li>\n<li>assigning metavar</li>\n<li>instantiating metavar?</li>\n</ol>",
        "id": 436346042,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1714507753
    },
    {
        "content": "<p>For <code>CommandElabM</code>, you have to be careful with your transitions to <code>TermElabM</code>. The <code>liftTermElabM</code> creates a fresh elaborator state. Make sure to stay within it during all of your elaboration activities.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">command_elab</span> <span class=\"n\">ppExprCmd</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">ppExprCmdImpl</span> <span class=\"o\">:</span> <span class=\"n\">CommandElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">liftTermElabM</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">expr</span> <span class=\"bp\">←</span>  <span class=\"n\">Term.elabTerm</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"n\">none</span>\n  <span class=\"n\">Elab.Term.synthesizeSyntheticMVarsNoPostponing</span>\n  <span class=\"k\">let</span> <span class=\"n\">expr</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"n\">expr</span>\n  <span class=\"n\">Elab.Term.synthesizeSyntheticMVarsNoPostponing</span>\n  <span class=\"k\">let</span> <span class=\"n\">tyExpr</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.inferType</span> <span class=\"n\">expr</span>\n  <span class=\"n\">logInfo</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{repr expr}\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.isDefEq</span> <span class=\"n\">tyExpr</span> <span class=\"o\">(</span><span class=\"n\">Expr.const</span> <span class=\"bp\">`</span><span class=\"n\">Foo0</span> <span class=\"o\">[])</span>\n  <span class=\"n\">logInfo</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{repr expr}\"</span>\n  <span class=\"n\">return</span> <span class=\"o\">()</span>\n</code></pre></div>",
        "id": 436346278,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714507857
    },
    {
        "content": "<p>ahhh, that makes sense! thanks a lot! (that works!)</p>",
        "id": 436346452,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1714507933
    },
    {
        "content": "<p>Here's how the order probably should go:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">command_elab</span> <span class=\"n\">ppExprCmd</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">ppExprCmdImpl</span> <span class=\"o\">:</span> <span class=\"n\">CommandElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">liftTermElabM</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">expr</span> <span class=\"bp\">←</span> <span class=\"n\">Term.elabTerm</span> <span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"n\">none</span>\n  <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.isDefEq</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">Meta.inferType</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Expr.const</span> <span class=\"bp\">`</span><span class=\"n\">Foo0</span> <span class=\"o\">[])</span>\n  <span class=\"n\">Elab.Term.synthesizeSyntheticMVarsNoPostponing</span>\n  <span class=\"k\">let</span> <span class=\"n\">expr</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"n\">expr</span>\n  <span class=\"k\">let</span> <span class=\"n\">tyExpr</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">Meta.inferType</span> <span class=\"n\">expr</span><span class=\"o\">)</span>\n  <span class=\"n\">logInfo</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{repr expr}\"</span>\n  <span class=\"n\">logInfo</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{repr tyExpr}\"</span>\n  <span class=\"n\">return</span> <span class=\"o\">()</span>\n</code></pre></div>",
        "id": 436346628,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714508033
    },
    {
        "content": "<p>This doesn't guarantee there are no metavariables by the way. It just guarantees there are no <em>synthetic</em> metavariables (like instances or coercions)</p>",
        "id": 436346981,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714508185
    },
    {
        "content": "<p>You can use <code>expr.hasMVar</code> to check. There are also things you can do like abstract out all the remaining metavariables to make a function, depending on what your goal is.</p>",
        "id": 436347074,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714508234
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Calling.20unification.20from.20meta.20to.20remove.20metavariables/near/436347074\">said</a>:</p>\n<blockquote>\n<p>You can use <code>expr.hasMVar</code> to check. There are also things you can do like abstract out all the remaining metavariables to make a function, depending on what your goal is.</p>\n</blockquote>\n<p>Right, but those are in a sense \"semantic\" metavariables, so I need to deal with them differently I guess. I imagine <code>def</code> does something like that to make a function?</p>",
        "id": 436347258,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1714508315
    },
    {
        "content": "<p><code>def</code> just complains, though for universe level metavariables it can turn those into universe level variables.</p>\n<p>By the way, here's a nicer way to write the command, using <code>elab_rules</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">ppExprCmd</span><span class=\"o\">)</span> <span class=\"s2\">\"#ppExpr\"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span> <span class=\"bp\">#</span><span class=\"n\">ppExpr</span> <span class=\"bp\">$</span><span class=\"n\">stx</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">liftTermElabM</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">expr</span> <span class=\"bp\">←</span> <span class=\"n\">Term.elabTerm</span> <span class=\"n\">stx</span> <span class=\"n\">none</span>\n    <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.isDefEq</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">Meta.inferType</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Expr.const</span> <span class=\"bp\">`</span><span class=\"n\">Foo0</span> <span class=\"o\">[])</span>\n    <span class=\"n\">Elab.Term.synthesizeSyntheticMVarsNoPostponing</span>\n    <span class=\"k\">let</span> <span class=\"n\">expr</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"n\">expr</span>\n    <span class=\"k\">let</span> <span class=\"n\">tyExpr</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">Meta.inferType</span> <span class=\"n\">expr</span><span class=\"o\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">expr.hasMVar</span> <span class=\"k\">then</span>\n      <span class=\"n\">throwErrorAt</span> <span class=\"n\">stx</span> <span class=\"s2\">\"still has metavariables\"</span>\n    <span class=\"n\">logInfo</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{repr expr}\"</span>\n    <span class=\"n\">logInfo</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{repr tyExpr}\"</span>\n    <span class=\"n\">return</span> <span class=\"o\">()</span>\n\n<span class=\"bp\">#</span><span class=\"n\">ppExpr</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"c1\">-- still has metavariables</span>\n</code></pre></div>",
        "id": 436347523,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714508417
    },
    {
        "content": "<p>Is there a reason you're using <code>repr</code>? You can write <code>logInfo m!\"{expr}\"</code> to get a pretty printed output</p>",
        "id": 436347845,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714508578
    },
    {
        "content": "<p>Example of abstraction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">ppExprCmd</span><span class=\"o\">)</span> <span class=\"s2\">\"#ppExpr\"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">command</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span> <span class=\"bp\">#</span><span class=\"n\">ppExpr</span> <span class=\"bp\">$</span><span class=\"n\">stx</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">liftTermElabM</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">expr</span> <span class=\"bp\">←</span> <span class=\"n\">Term.elabTerm</span> <span class=\"n\">stx</span> <span class=\"n\">none</span>\n    <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.isDefEq</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">Meta.inferType</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Expr.const</span> <span class=\"bp\">`</span><span class=\"n\">Foo0</span> <span class=\"o\">[])</span>\n    <span class=\"n\">Elab.Term.synthesizeSyntheticMVarsNoPostponing</span>\n    <span class=\"k\">let</span> <span class=\"n\">expr</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"n\">expr</span>\n    <span class=\"k\">let</span> <span class=\"n\">res</span> <span class=\"bp\">←</span> <span class=\"n\">Meta.abstractMVars</span> <span class=\"n\">expr</span>\n    <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{res.expr} : {← Meta.inferType res.expr}\"</span>\n    <span class=\"n\">return</span> <span class=\"o\">()</span>\n\n<span class=\"bp\">#</span><span class=\"n\">ppExpr</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"c1\">-- fun x_0 =&gt; 1 + x_0 : Nat → Nat</span>\n</code></pre></div>",
        "id": 436347901,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714508608
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Calling.20unification.20from.20meta.20to.20remove.20metavariables/near/436347845\">said</a>:</p>\n<blockquote>\n<p>Is there a reason you're using <code>repr</code>? You can write <code>logInfo m!\"{expr}\"</code> to get a pretty printed output</p>\n</blockquote>\n<p>oh, because the pretty printed output doesn't show that synthetic metavariable!</p>",
        "id": 436348078,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1714508672
    },
    {
        "content": "<p>so I couldn't see the error without <code>repr</code></p>",
        "id": 436348122,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1714508694
    },
    {
        "content": "<p>I guess that makes the name for the command in the MWE a not so ideal choice though <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 436348368,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1714508792
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315434\">Andrés Goens</span> <a href=\"#narrow/stream/270676-lean4/topic/Calling.20unification.20from.20meta.20to.20remove.20metavariables/near/436348078\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Calling.20unification.20from.20meta.20to.20remove.20metavariables/near/436347845\">said</a>:<br>\noh, because the pretty printed output doesn't show that synthetic metavariable!</p>\n</blockquote>\n<p>When using the \"proper\" pretty printing, you can set options like <code>pp.raw</code> to see more details. Not sure if you can bake that into your command as a default though.</p>",
        "id": 436348705,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1714508943
    },
    {
        "content": "<p><code>logInfo</code> responds to <code>set_option</code> if you use <code>m!</code> strings</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">pp.all</span> <span class=\"n\">true</span>\n\n<span class=\"bp\">#</span><span class=\"n\">ppExpr</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">fun (x_0 : Nat) =&gt;</span>\n<span class=\"cm\">  @HAdd.hAdd.{0, 0, 0} Nat Nat Nat (@instHAdd.{0} Nat instAddNat) (@OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))</span>\n<span class=\"cm\">    x_0 : Nat → Nat</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 436348848,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714509010
    },
    {
        "content": "<p>But could you, e.g., have it use <code>pp.raw true</code> by default?</p>",
        "id": 436348970,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1714509071
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"n\">withOptions</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">opt</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">opt.set</span> <span class=\"n\">pp.raw.name</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n      <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{res.expr} : {← Meta.inferType res.expr}\"</span>\n</code></pre></div>",
        "id": 436349025,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714509103
    },
    {
        "content": "<p>I guess that's cleaner for a proper command, I just jotted that down when writing an MWE (my actual code is quite different anyway, I don't want to print it, was just trying to figure out what went wrong)</p>",
        "id": 436349033,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1714509106
    },
    {
        "content": "<p>Should the <code>s!</code> elaborator reject an expected type of <code>MessageData</code>?</p>",
        "id": 436676535,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714650990
    }
]