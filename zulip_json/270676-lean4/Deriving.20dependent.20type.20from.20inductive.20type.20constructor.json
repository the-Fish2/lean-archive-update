[
    {
        "content": "<p>Hello! Very new to pure functional programming, and dependent types, so bear with me. I am trying to create a type that depends on the constructor as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">ATest</span>  <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>  <span class=\"o\">:</span> <span class=\"n\">ATest</span>  <span class=\"n\">x</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ATest_1</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">ATest.c</span> <span class=\"n\">x</span>  <span class=\"o\">:</span> <span class=\"n\">ATest</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>Ideally, I should have to just do: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ATest_1</span> <span class=\"o\">:=</span> <span class=\"n\">ATest.c</span> <span class=\"mi\">1</span> <span class=\"c1\">-- Type is ATest 1</span>\n</code></pre></div>\n<p>Can I improve on the definition of ATest, so I can achieve that?</p>",
        "id": 439302814,
        "sender_full_name": "Carbon",
        "timestamp": 1715986765
    },
    {
        "content": "<p>I'm on my phone, but I think you just have a typo. The constructor should be <code>c (a : Nat) : ATest a</code>. You might want to turn off autoimplicits at this stage.</p>",
        "id": 439309692,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1715992356
    },
    {
        "content": "<p>This was intended to make it work, and not a typo. I am trying to match on the value after:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">ATestV1</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ATestV1</span> <span class=\"n\">a</span>  <span class=\"c1\">-- Use 'a' instead of 'x' won't work, see later</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">ATestV2</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ATestV2</span> <span class=\"n\">x</span> <span class=\"c1\">-- This will work</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ATestV1_1</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">ATestV1.c</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ATestV1</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"mi\">1</span>\n<span class=\"kd\">def</span> <span class=\"n\">ATestV2_1</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">ATestV2.c</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ATestV2</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"mi\">1</span>\n\n\n<span class=\"k\">#eval</span> <span class=\"k\">match</span> <span class=\"n\">ATestV1_1</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">c</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"c1\">-- Does not work</span>\n<span class=\"k\">#eval</span> <span class=\"k\">match</span> <span class=\"n\">ATestV2_1</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">c</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"c1\">-- This works</span>\n</code></pre></div>",
        "id": 439311970,
        "sender_full_name": "Carbon",
        "timestamp": 1715994347
    },
    {
        "content": "<p>I'm not sure if this helps, but one thing you can do is this,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">ATestV3</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">ATestV3</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ATestV3_1</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">ATestV3.c</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ATestV3</span><span class=\"o\">))</span> <span class=\"mi\">1</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">match</span> <span class=\"n\">ATestV3_1</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">c</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 439329160,
        "sender_full_name": "Lucas Allen",
        "timestamp": 1716011993
    },
    {
        "content": "<p>To <span class=\"user-mention\" data-user-id=\"228466\">@Chris Bailey</span> 's point, I think you might be shooting yourself in the foot with Lean's <a href=\"https://lean-lang.org/lean4/doc/autobound.html?highlight=autoimpl#auto-bound-implicit-arguments\">\"auto implicits\" feature</a>. You can turn this off with <code>set_option autoImplicit false</code> and see what happens:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">ATestV2</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ATestV2</span> <span class=\"n\">x</span>\n\n<span class=\"c1\">-- With auto implicits enabled (by default),</span>\n<span class=\"c1\">-- the definition of `ATestV2.c` contains an implicit argument 'x'</span>\n<span class=\"k\">#check</span> <span class=\"n\">ATestV2.c</span> <span class=\"c1\">-- ATestV2.c {x : Nat} (a : Nat) : ATestV2 x</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">ATestV2'</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ATestV2'</span> <span class=\"n\">x</span> <span class=\"c1\">-- unknown identifier 'x'</span>\n</code></pre></div>",
        "id": 439330599,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1716013371
    },
    {
        "content": "<p>The only reason Lean could figure out the value of the implicit parameter <code>x</code> in:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ATestV2_1</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ATestV2.c</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ATestV2</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>... is because you explicitly provide the type annotation <code>AVTestV2 1</code>. Without the type annotation, Lean won't know what <code>x</code> should be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ATestV2_1</span> <span class=\"o\">:=</span> <span class=\"n\">ATestV2.c</span> <span class=\"mi\">1</span> <span class=\"c1\">-- error: don't know how to synthesize implicit argument @ATestV2.c ?x 1</span>\n</code></pre></div>",
        "id": 439330910,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1716013697
    },
    {
        "content": "<p>Your type <code>ATestV2</code> probably isn't what you want, since the number in the type and the number in the content are completely unrelated. Your type <code>ATestV1</code> can only contain numbers that are definitionally equal with the number in the type, this is why the <code>match</code> doesn't accept a generic variable <code>x</code>, but needs a concrete 1. <code>ATestV3</code> in the example below might be want you are hoping for. The number in the type and content don't need to be definitionally equal (defeq), but the constructor requires a proof that they are propositionally equal (propeq), by default it uses <code>by rfl</code> to proof this equality. The only downside is that <code>deriving Repr</code> doesn't work.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">ATestV1</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ATestV1</span> <span class=\"n\">a</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">ATestV2</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ATestV2</span> <span class=\"n\">x</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">ATestV3</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">property</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ATestV3</span> <span class=\"n\">b</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span> <span class=\"c1\">-- doesn't work</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ATestV1_1</span> <span class=\"o\">:=</span> <span class=\"n\">ATestV1.c</span> <span class=\"mi\">1</span> <span class=\"c1\">-- works</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ATestV2_1'</span> <span class=\"o\">:=</span> <span class=\"n\">ATestV2.c</span> <span class=\"mi\">1</span> <span class=\"c1\">-- can't work, since the type is unknown</span>\n<span class=\"kd\">def</span> <span class=\"n\">ATestV2_1</span> <span class=\"o\">:</span> <span class=\"n\">ATestV2</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">ATestV2.c</span> <span class=\"mi\">1</span> <span class=\"c1\">-- works, but the number of the type and the content can be different</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ATestV3_1</span> <span class=\"o\">:=</span> <span class=\"n\">ATestV3.c</span> <span class=\"mi\">1</span> <span class=\"c1\">-- works</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">match</span> <span class=\"n\">ATestV1_1</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">c</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"c1\">-- doesn't work</span>\n<span class=\"k\">#eval</span> <span class=\"k\">match</span> <span class=\"n\">ATestV1_1</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">c</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"c1\">-- works</span>\n<span class=\"k\">#eval</span> <span class=\"k\">match</span> <span class=\"n\">ATestV2_1</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">c</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"c1\">-- works</span>\n<span class=\"k\">#eval</span> <span class=\"k\">match</span> <span class=\"n\">ATestV3_1</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">c</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"c1\">-- works, `h` contains the proof that `x` is 1</span>\n</code></pre></div>",
        "id": 439334144,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1716016965
    },
    {
        "content": "<p>Thanks Markus, this indeed captures what I was trying to achieve. I also will keep this <code>autoImplicit</code> option in mind, thanks all for flagging this.</p>",
        "id": 439383740,
        "sender_full_name": "Carbon",
        "timestamp": 1716067525
    }
]