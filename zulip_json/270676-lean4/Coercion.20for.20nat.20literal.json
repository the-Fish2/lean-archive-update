[
    {
        "content": "<p>While reading Coercion in Functional Programming in Lean,  I am confused about one of the examples with cascading Option type.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- 392 is Nat</span>\n<span class=\"k\">#check</span> <span class=\"mi\">392</span>\n\n<span class=\"c1\">-- This gives error</span>\n<span class=\"kd\">def</span> <span class=\"n\">pppN</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">Nat</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"mi\">392</span>\n\n<span class=\"c1\">-- This does not</span>\n<span class=\"kd\">def</span> <span class=\"n\">pppN1</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">Nat</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">392</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>check says that 392's type is nat. If lean already knows that 392's type is Nat, why does it again need explicit : Nat to initiate search for coercion chain to get from 392 to <code>Option (Option (Option Nat))</code>?</p>\n<p>From text surrounding the example:</p>\n<p>\"Coercions are only activated automatically when Lean encounters a mismatch between an inferred type and a type that is imposed from the rest of the program. In cases with other errors, coercions are not activated. For example, if the error is that an instance is missing, coercions will not be used:\"</p>\n<p>But i could not fully comprehend what it means in this context.</p>",
        "id": 424368235,
        "sender_full_name": "Param Reddy",
        "timestamp": 1709358578
    },
    {
        "content": "<p>The nat literal syntax uses a typeclass <code>OfNat</code> to take values in arbitrary types. For example, you can write <code>(392 : Nat)</code> or <code>(392 : Int)</code> and they are both literals using instances of <code>OfNat Nat 392</code> and <code>OfNat Int 392</code> respectively. When you write <code>392</code> without specifying a type, Lean cannot unambiguously determine what type of literal you're looking for, but there is a special fallback for this syntax to default to type <code>Nat</code>. When you write <code>(392 : Option Nat)</code>, it's unambiguous that you want your literal to be of type <code>Option Nat</code>. Lean looks for an instance of <code>OfNat (Option Nat) 392</code> and errors when it fails to find one</p>",
        "id": 424369608,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709359934
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"500038\">Timo Carlin-Burns</span> Thanks Timo. I think I was missing that unlike other languages 392 as literal does not have predefined type and #check was using \"special fallback\" to default to Nat.</p>",
        "id": 424432241,
        "sender_full_name": "Param Reddy",
        "timestamp": 1709402595
    },
    {
        "content": "<p>Here's the implementation of that defaulting to <code>Nat</code>: <a href=\"https://github.com/leanprover/lean4/blob/019922878491315bcdc3bba67ecfd5e337333703/src/Init/Prelude.lean#L1095-L1097\">https://github.com/leanprover/lean4/blob/019922878491315bcdc3bba67ecfd5e337333703/src/Init/Prelude.lean#L1095-L1097</a></p>\n<p>Just pointing it out so you don't think it's hard coded. These <code>default_instance</code>s are considered at certain points when typeclass inference can't make further progress on its own.</p>",
        "id": 424432728,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709403001
    },
    {
        "content": "<p>If you want to obstruct the expected type from propagating to <code>392</code>, rather than specifying <code>Nat</code>, you can get it to follow the defaulting behavior by using <code>( ... :)</code> syntax:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">pppN</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">Nat</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">392</span> <span class=\"o\">:)</span>\n</code></pre></div>\n<p>That means \"elaborate the expression without an expected type\".</p>",
        "id": 424432844,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709403085
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/Coercion.20for.20nat.20literal/near/424432728\">said</a>:</p>\n<blockquote>\n<p>Here's the implementation of that defaulting to <code>Nat</code>: <a href=\"https://github.com/leanprover/lean4/blob/019922878491315bcdc3bba67ecfd5e337333703/src/Init/Prelude.lean#L1095-L1097\">https://github.com/leanprover/lean4/blob/019922878491315bcdc3bba67ecfd5e337333703/src/Init/Prelude.lean#L1095-L1097</a></p>\n<p>Just pointing it out so you don't think it's hard coded. These <code>default_instance</code>s are considered at certain points when typeclass inference can't make further progress on its own.</p>\n</blockquote>\n<p>This now confused me more.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">default_instance</span> <span class=\"mi\">100</span><span class=\"kd\">]</span> <span class=\"c\">/-</span><span class=\"cm\"> low prio -/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">Nat</span> <span class=\"n\">n</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>My read of this is if n is Nat then you can apply this OfNat instance to Nat n. This seems a bit circular to me as it assumes n is nat before being triggered. So would mean 392 is already of type Nat. What am i missing?</p>",
        "id": 424455423,
        "sender_full_name": "Param Reddy",
        "timestamp": 1709422898
    },
    {
        "content": "<p>It's that <code>392</code> is syntax for <code>OfNat.ofNat 392</code>, with <code>392</code> an actual <code>Nat</code>. Then Lean figures out which <code>OfNat</code> instance to used based on the expected type of this expression.</p>",
        "id": 424455627,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709423076
    },
    {
        "content": "<p>There's <code>nat_lit 392</code> syntax if you want to get a raw Nat literal, without going through all this. I guess it's better to say that <code>392</code> is syntax for <code>OfNat.ofNat (nat_lit 392)</code>.</p>",
        "id": 424455674,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709423133
    },
    {
        "content": "<p>Is there a reason not to enable <code>pp.natLit</code> by default?</p>",
        "id": 424527183,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709486701
    },
    {
        "content": "<p>I wasn't sure if there was a reason not to, and I decided not to investigate too deeply to see if there are any unintended consequences, so in the RFC (<a href=\"https://github.com/leanprover/lean4/pull/3021\">lean4#3021</a>) I just specified that it's false by default. Well, I did know that <code>pp.all</code> is more verbose if that's the default:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"mi\">1</span>\n<span class=\"c1\">-- with pp.natLit false:</span>\n<span class=\"c1\">-- @OfNat.ofNat.{0} Nat 1 (instOfNatNat 1) : Nat</span>\n<span class=\"c1\">-- with pp.natLit true:</span>\n<span class=\"c1\">-- @OfNat.ofNat.{0} Nat (nat_lit 1) (instOfNatNat (nat_lit 1)) : Nat</span>\n</code></pre></div>\n<p>So, there would be the question of whether <code>pp.all</code> should turn off <code>pp.natLit</code>, or leave it on.</p>\n<p>One thing that came up is the follow-up question of whether <code>Nat.zero.succ.succ.....succ</code> should pretty print as a <code>nat_lit</code> too, and if it does, then when <code>pp.natLit</code> is false, whether it should pretty print as a numeral for consistency.</p>\n<p>I think changing this would take some real cases where someone got confused because of a raw <code>nat_lit</code>, and going through the process of filing an issue and getting <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span>'s.</p>",
        "id": 424558904,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709513595
    }
]