[
    {
        "content": "<p>Hello. I am using Lean 4 and I am trying to use its metaprogramming capabilities to evaluate a string that happens to be a valid expression (when some <code>def</code>s are in the context) into the corresponding expression that it represents. To make my scenario more concrete, let's say that I have the following recursive type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyType</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">MyType</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">MyType</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyType</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">BEq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n</code></pre></div>\n<p>With this I can write the following expression:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">c</span><span class=\"o\">)))</span>\n</code></pre></div>\n<p>The twist now is that I have this as a <em>string</em> <code>\"MyType.a (.b (.a (.a .c)))\"</code> and I want a function <code>stringToMyType : String -&gt; Option MyType</code> such that the following two are equivalent and both give me the same value:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">c</span><span class=\"o\">)))</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">stringToMyType</span><span class=\"w\"> </span><span class=\"s2\">\"MyType.a (.b (.a (.a .c)))\"</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">get!</span>\n</code></pre></div>\n<p>I have been reading the Lean 4 Metaprogramming book and I am fairly sure that this should be achievable with a function call to <a href=\"https://leanprover-community.github.io/mathlib4_docs////Lean/Elab/Eval.html\"><code>Lean.Elab.Term.evalTerm</code></a>, but the arguments are undocumented and the manual does not contain a single example call to this function.<br>\nSo the most I have managed to do is this, which is not much:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">stringToMyType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">string</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">asSyntax</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- from `string : String` to `Syntax`</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- what is this? required by `evalTerm`</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- what is this? required by `evalTerm`</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TermElabM</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">evalTerm</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">asSyntax</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\">  </span><span class=\"c1\">-- what is even this monad. `run` here has type `TermElabM α → Term.Context → Term.State`, but the last two are optional</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- no idea how to continue to obtain `Option MyType` (or similar)</span>\n</code></pre></div>\n<p>Does anyone here have experience with Lean 4 metaprogramming and would be willing to help me a bit?</p>\n<p>Online playground link:<br>\n<a href=\"https://live.lean-lang.org/#code=import%20Lean%0D%0A%0D%0Ainductive%20MyType%0D%0A%7C%20a%20%3A%20MyType%20-%3E%20MyType%0D%0A%7C%20b%20%3A%20MyType%20-%3E%20MyType%0D%0A%7C%20c%20%3A%20MyType%0D%0Aderiving%20Inhabited%2C%20BEq%2C%20Repr%0D%0A%0D%0Aopen%20Lean%20Elab%0D%0A%0D%0Aunsafe%20def%20stringToMyType%20(string%20%3A%20String)%20%3A%20Option%20MyType%20%3A%3D%20do%0D%0A%20%20let%20asSyntax%20%3A%3D%20sorry%20--%20from%20%60string%60%20to%20%60Syntax%60%0D%0A%20%20let%20%CE%B1%20%3A%20Type%20%3A%3D%20sorry%20--%20what%20is%20this%3F%20required%20by%20%60evalTerm%60%0D%0A%20%20let%20type%20%3A%20Expr%20%3A%3D%20sorry%20--%20what%20is%20this%3F%20required%20by%20%60evalTerm%60%0D%0A%20%20let%20x%20%3A%20TermElabM%20%CE%B1%20%3A%3D%20Term.evalTerm%20%CE%B1%20type%20asSyntax%0D%0A%20%20let%20y%20%3A%20MetaM%20(%CE%B1%20%C3%97%20Term.State)%20%3A%3D%20x.run%20%20--%20what%20is%20even%20this%20monad.%20%60run%60%20here%20has%20type%20%60TermElabM%20%CE%B1%20%E2%86%92%20Term.Context%20%E2%86%92%20Term.State%60%2C%20but%20the%20last%20two%20are%20optional%0D%0A%20%20sorry%0D%0A%0D%0A%23eval%20MyType.a%20(.b%20(.a%20(.a%20.c)))%0D%0A%23eval%20stringToMyType%20%22MyType.a%20(.b%20(.a%20(.a%20.c)))%22%20%7C%3E.get!%0D%0A\">https://live.lean-lang.org/#code=import%20Lean%0D%0A%0D%0Ainductive%20MyType%0D%0A%7C%20a%20%3A%20MyType%20-%3E%20MyType%0D%0A%7C%20b%20%3A%20MyType%20-%3E%20MyType%0D%0A%7C%20c%20%3A%20MyType%0D%0Aderiving%20Inhabited%2C%20BEq%2C%20Repr%0D%0A%0D%0Aopen%20Lean%20Elab%0D%0A%0D%0Aunsafe%20def%20stringToMyType%20(string%20%3A%20String)%20%3A%20Option%20MyType%20%3A%3D%20do%0D%0A%20%20let%20asSyntax%20%3A%3D%20sorry%20--%20from%20%60string%60%20to%20%60Syntax%60%0D%0A%20%20let%20%CE%B1%20%3A%20Type%20%3A%3D%20sorry%20--%20what%20is%20this%3F%20required%20by%20%60evalTerm%60%0D%0A%20%20let%20type%20%3A%20Expr%20%3A%3D%20sorry%20--%20what%20is%20this%3F%20required%20by%20%60evalTerm%60%0D%0A%20%20let%20x%20%3A%20TermElabM%20%CE%B1%20%3A%3D%20Term.evalTerm%20%CE%B1%20type%20asSyntax%0D%0A%20%20let%20y%20%3A%20MetaM%20(%CE%B1%20%C3%97%20Term.State)%20%3A%3D%20x.run%20%20--%20what%20is%20even%20this%20monad.%20%60run%60%20here%20has%20type%20%60TermElabM%20%CE%B1%20%E2%86%92%20Term.Context%20%E2%86%92%20Term.State%60%2C%20but%20the%20last%20two%20are%20optional%0D%0A%20%20sorry%0D%0A%0D%0A%23eval%20MyType.a%20(.b%20(.a%20(.a%20.c)))%0D%0A%23eval%20stringToMyType%20%22MyType.a%20(.b%20(.a%20(.a%20.c)))%22%20%7C%3E.get!%0D%0A</a></p>",
        "id": 444347314,
        "sender_full_name": "Relyth",
        "timestamp": 1718233280
    },
    {
        "content": "<p>Youll generally need to work in some monad that lets you do these things like <code>TermElabM</code>. In your simple case the function you want could probably be defined without all this but its really much easier if you use the right monads!</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyType</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">MyType</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">MyType</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyType</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">BEq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span>\n\n<span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">stringToMyType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">string</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TermElabM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">syn</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Parser</span><span class=\"bp\">.</span><span class=\"n\">runParserCategory</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"ss\">`term</span><span class=\"w\"> </span><span class=\"n\">string</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">syn</span>\n<span class=\"w\">  </span><span class=\"c1\">-- we could elab here, but its not needed</span>\n<span class=\"w\">  </span><span class=\"c1\">-- let expr ← Term.elabTerm syn (some (.const `MyType []))</span>\n<span class=\"w\">  </span><span class=\"c1\">-- logInfo expr</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">evalTerm</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">`MyType</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"n\">syn</span>\n<span class=\"w\">  </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">repr</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">out</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">c</span><span class=\"o\">)))</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">stringToMyType</span><span class=\"w\"> </span><span class=\"s2\">\"MyType.a (.b (.a (.a .c)))\"</span>\n</code></pre></div>",
        "id": 444350545,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1718234996
    },
    {
        "content": "<p>Sorry if this is a stupid question but can I \"pull\" the <code>Option MyType</code> out of <code>TermElabM</code> so that I can use it in other functions that don't have any references to Lean metaprogramming stuff?</p>",
        "id": 444353299,
        "sender_full_name": "Relyth",
        "timestamp": 1718236873
    },
    {
        "content": "<p>You can, but you have to put it back into TermElabM afterwards:</p>\n<p><a href=\"https://leanprover.github.io/functional_programming_in_lean/monads.html\">https://leanprover.github.io/functional_programming_in_lean/monads.html</a><br>\n<a href=\"https://lean-lang.org/lean4/doc/monads/intro.html\">https://lean-lang.org/lean4/doc/monads/intro.html</a></p>",
        "id": 444353620,
        "sender_full_name": "llllvvuu",
        "timestamp": 1718237078
    },
    {
        "content": "<p>That's the issue, I can't really do that. I need to actually unwrap it to make it fit with existing code easily. I can't just use a bind here.</p>",
        "id": 444353687,
        "sender_full_name": "Relyth",
        "timestamp": 1718237129
    },
    {
        "content": "<p>You'll need to pass context via <code>.run</code> methods then</p>",
        "id": 444354036,
        "sender_full_name": "llllvvuu",
        "timestamp": 1718237346
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Term.TermElabM.run#doc\">docs#Lean.Elab.Term.TermElabM.run</a><br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Term.TermElabM.toIO#doc\">docs#Lean.Elab.Term.TermElabM.toIO</a></p>\n<p>Although I'm not sure if you can get out of IO</p>",
        "id": 444354194,
        "sender_full_name": "llllvvuu",
        "timestamp": 1718237440
    },
    {
        "content": "<p>I was going to say, I managed to see in some doc page that this mysterious and undocumented <code>TermElabM</code> monad is actually <code> ReaderT Lean.Elab.Term.Context (StateRefT' IO.RealWorld Lean.Elab.Term.State Lean.MetaM)</code>,  so I was going to ask if I can call <code>run</code> on it or something. But I don't even understand at a first glance what the signature of run would even look like with such a long type full of names I've never seen before. Even if I knew the signature, no idea how to construct values of the requested types.</p>",
        "id": 444354292,
        "sender_full_name": "Relyth",
        "timestamp": 1718237512
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/wiki/Monad-map\">https://github.com/leanprover-community/mathlib4/wiki/Monad-map</a> can be handy for questions like \"How do I get from <code>FooM</code> to <code>BarM</code>\"</p>",
        "id": 444354350,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718237535
    },
    {
        "content": "<p>The main function of my app is <code>List String -&gt; IO UInt32</code>, so no problem with the IO. The main issue is understanding the signatures around this entire thing and how to get a context (whatever that is), and a state.</p>",
        "id": 444354454,
        "sender_full_name": "Relyth",
        "timestamp": 1718237626
    },
    {
        "content": "<p>Ok I think I can solve my issue with <a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Elab/Term.html#Lean.Elab.Term.TermElabM.toIO\">Lean.Elab.Term.TermElabM.toIO</a>. This is very useful. I will try to figure this out during the next hours and I will come back if it doesn't work I guess. Thank you.</p>",
        "id": 444354599,
        "sender_full_name": "Relyth",
        "timestamp": 1718237744
    },
    {
        "content": "<p>I think probably you want <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CoreM.withImportModules#doc\">docs#CoreM.withImportModules</a></p>",
        "id": 444354665,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718237769
    },
    {
        "content": "<blockquote>\n<p>when some <code>def</code>s are in the context</p>\n</blockquote>\n<p>These <code>def</code>s are in the <em>build-time</em> context. If you're running <code>IO</code> from a binary, then you're in the runtime context, and so the environment doesn't exist at all! (and so you create one with the declaration above)</p>",
        "id": 444354806,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718237886
    },
    {
        "content": "<p>Uhhh I am having very extreme difficulties right now to follow all this, even after having read the Metaprogramming in Lean book.  Do you think just writing a parser manually that constructs a <code>MyType</code> out of a string is more feasible? I am kind of stuck with the metaprogramming way of doing it.</p>",
        "id": 444354914,
        "sender_full_name": "Relyth",
        "timestamp": 1718237990
    },
    {
        "content": "<p>Why are you in IO?</p>",
        "id": 444355018,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718238028
    },
    {
        "content": "<p>Because it's a command-line app that gathers inputs, does some process and prints outputs</p>",
        "id": 444355056,
        "sender_full_name": "Relyth",
        "timestamp": 1718238055
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687971\">Relyth</span> <a href=\"#narrow/stream/270676-lean4/topic/Simple.20parsing.2Belaboration.20with.20metaprogramming/near/444354914\">said</a>:</p>\n<blockquote>\n<p>Do you think just writing a parser manually that constructs a <code>MyType</code> out of a string is more feasible?</p>\n</blockquote>\n<p>This is probably a better idea anyway, since then the interface to your CLI doesn't have to match Lean</p>",
        "id": 444355131,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718238119
    },
    {
        "content": "<p>But you can use the Parsec stuff to do most of the work for you</p>",
        "id": 444355191,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718238138
    },
    {
        "content": "<p>The <code>CoreM.withImportModules</code> approach shouldn't be too bad if you do want to pursue that, you can see an example at <a href=\"https://github.com/leanprover-community/batteries/blob/main/scripts/runLinter.lean#L55\">https://github.com/leanprover-community/batteries/blob/main/scripts/runLinter.lean#L55</a></p>",
        "id": 444355287,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718238225
    },
    {
        "content": "<p>Let me try to write something short without actually showing all the code, because it's a lot:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">main</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">UInt32</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">parsedArgs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">doSomeParsing</span><span class=\"w\"> </span><span class=\"n\">args</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">someData1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">parsedArgs</span><span class=\"bp\">.</span><span class=\"n\">someData1</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">someData2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">parsedArgs</span><span class=\"bp\">.</span><span class=\"n\">someData2</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">someInput</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">readFile</span><span class=\"w\"> </span><span class=\"n\">someData2</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">someParsedInput</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"bp\">.</span><span class=\"n\">parseFromString</span><span class=\"w\"> </span><span class=\"n\">someInput</span><span class=\"w\"> </span><span class=\"c1\">-- I wish to implement this step with metaprogramming</span>\n\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">someComplexOperation</span><span class=\"w\"> </span><span class=\"n\">someData1</span><span class=\"w\"> </span><span class=\"n\">someParsedInput</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">result</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">error</span><span class=\"w\"> </span><span class=\"n\">err</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">eprint</span><span class=\"w\"> </span><span class=\"n\">err</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"mi\">255</span>\n</code></pre></div>\n<p>The real thing is unfortunately way more complex than this.</p>",
        "id": 444355525,
        "sender_full_name": "Relyth",
        "timestamp": 1718238382
    },
    {
        "content": "<blockquote>\n<p>This is probably a better idea anyway, since then the interface to your CLI doesn't have to match Lean</p>\n</blockquote>\n<p>I designed the input language of the tool on purpose so that it does, planning ahead to try to avoid having to actually implement the parsing step with a bit of metaprogramming, but I was not expecting it to be so involved.</p>",
        "id": 444355573,
        "sender_full_name": "Relyth",
        "timestamp": 1718238433
    },
    {
        "content": "<p>Do you want to allow your input to be <code>MyType.a (by (run_tac IO.println \"hello world\"); exact .b)</code>?</p>",
        "id": 444356483,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718239109
    },
    {
        "content": "<p>Because the problem with using the Lean parser is that you get all of lean, which can then make arbitrary IO calls</p>",
        "id": 444356514,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718239129
    },
    {
        "content": "<p>No, only the constructors of the type nested recursively appear, like in my example above.</p>",
        "id": 444356568,
        "sender_full_name": "Relyth",
        "timestamp": 1718239194
    },
    {
        "content": "<p>Then you almost certainly want to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parsec#doc\">docs#Lean.Parsec</a>, which unfortunately has no documentation</p>",
        "id": 444356676,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718239245
    },
    {
        "content": "<p>But you could use <a href=\"https://github.com/leanprover/lean4/blob/be6c4894e0a6c542d56a6f4bb1238087267d21a0/src/Lean/Data/Json/Parser.lean\">https://github.com/leanprover/lean4/blob/be6c4894e0a6c542d56a6f4bb1238087267d21a0/src/Lean/Data/Json/Parser.lean</a> for inspiration</p>",
        "id": 444356710,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718239275
    },
    {
        "content": "<blockquote>\n<p>which unfortunately has no documentation</p>\n</blockquote>\n<p>Well, like this entire metaprogramming code then. Back to square one, still stuck trying to go from a string into MyType after 3 days.</p>",
        "id": 444356736,
        "sender_full_name": "Relyth",
        "timestamp": 1718239303
    },
    {
        "content": "<p>The Json parser above should hopefully give you something in square <code>n/2</code></p>",
        "id": 444356806,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718239335
    },
    {
        "content": "<p>I was under the impression that parsing and evaluating an expression is not only possible but one of the core common use cases for metaprogramming. I think it's a bit unfortunate that I have to take the parser route as the actual <code>MyType</code> in my code has many constructors taking  many arguments, so parsing is not difficult but it is fairly tedious.</p>",
        "id": 444356972,
        "sender_full_name": "Relyth",
        "timestamp": 1718239486
    },
    {
        "content": "<p>Anyway, thank you for the help and the links.</p>",
        "id": 444356999,
        "sender_full_name": "Relyth",
        "timestamp": 1718239505
    },
    {
        "content": "<p>You might want to use metaprogramming to generate the parser automatically (by iterating over the constructors)!</p>",
        "id": 444358721,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718240731
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Simple.20parsing.2Belaboration.20with.20metaprogramming/near/444354665\">said</a>:</p>\n<blockquote>\n<p>I think probably you want <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CoreM.withImportModules#doc\">docs#CoreM.withImportModules</a></p>\n</blockquote>\n<p>I was just quickly skimming this but thread but this suggestion sounds very reasonable. I think Damiano's <code>UpdateDeprecations</code> package is a recent example how to set this up to get an environment, and the <code>gameserver</code> exe in <code>lean4game/server</code> might contain another such example.</p>",
        "id": 444384045,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1718255552
    },
    {
        "content": "<p>First, both references I mentioned do something else <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> </p>\n<p>But, I think this is roughly what I had in mind:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Core</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">sample</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"[True, False]\"</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">testRunnerCore</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">source</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Environment</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Parser</span><span class=\"bp\">.</span><span class=\"n\">runParserCategory</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"ss\">`term</span><span class=\"w\"> </span><span class=\"n\">sample</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"c1\">-- is this the correct context?</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Core</span><span class=\"bp\">.</span><span class=\"n\">Context</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">      </span><span class=\"n\">fileName</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"\"</span>\n<span class=\"w\">      </span><span class=\"n\">fileMap</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">source</span><span class=\"bp\">.</span><span class=\"n\">toFileMap</span>\n<span class=\"w\">    </span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"c1\">-- and what's the correct state?</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Core</span><span class=\"bp\">.</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">      </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">env</span>\n<span class=\"w\">    </span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"c1\">-- I'm only interested in the resulting `Expr`, not in the updated context/state/…</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(((</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">CoreM</span><span class=\"bp\">.</span><span class=\"n\">toIO</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MetaM</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">TermElabM</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"n\">state</span>\n<span class=\"w\">    </span><span class=\"c1\">-- m : Expr</span>\n<span class=\"w\">    </span><span class=\"n\">dbg_trace</span><span class=\"w\"> </span><span class=\"n\">f!</span><span class=\"s2\">\"out: {m}\"</span>\n\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">error</span><span class=\"w\"> </span><span class=\"n\">err</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">panic</span><span class=\"w\"> </span><span class=\"n\">err</span>\n\n<span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">testRunner</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">withImportModules</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[{</span><span class=\"n\">module</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"ss\">`Lean</span><span class=\"o\">}]</span><span class=\"w\"> </span><span class=\"n\">Options</span><span class=\"bp\">.</span><span class=\"n\">empty</span><span class=\"w\">  </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">testRunnerCore</span><span class=\"w\"> </span><span class=\"n\">sample</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">testRunner</span>\n</code></pre></div>\n<p>I'm not super confident this is correct, especially I'm a bit confused that the output <code>List.cons.{?_uniq.1} ?_uniq.2 True (List.cons.{?_uniq.3} ?_uniq.4 False (List.nil.{?_uniq.6} ?_uniq.7))</code> contains so many <code>?_uniq</code>. But maybe that's because I didn't use <code>evalTerm</code>?</p>\n<p>Maybe some more experienced metacoders can jump in, or at least it helps a bit.</p>",
        "id": 444398795,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1718262817
    },
    {
        "content": "<p>Note that you are calling a different <code>withImportModules</code> to the one I recommended</p>",
        "id": 444406510,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718265673
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"385895\">Jon Eugster</span> <a href=\"#narrow/stream/270676-lean4/topic/Simple.20parsing.2Belaboration.20with.20metaprogramming/near/444384045\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Simple.20parsing.2Belaboration.20with.20metaprogramming/near/444354665\">said</a>:</p>\n<blockquote>\n<p>I think probably you want <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CoreM.withImportModules#doc\">docs#CoreM.withImportModules</a></p>\n</blockquote>\n<p>I was just quickly skimming this but thread but this suggestion sounds very reasonable. I think Damiano's <code>UpdateDeprecations</code> package is a recent example how to set this up to get an environment, and the <code>gameserver</code> exe in <code>lean4game/server</code> might contain another such example.</p>\n</blockquote>\n<p>Specifically, <a href=\"https://github.com/adomani/UpdateDeprecations/blob/ef29a47d2d6072af407b3a72e5d63c13001f344f/UpdateDeprecations/Basic.lean#L293-L297\">these lines</a> set up an environment with an <code>import</code> statement and then process a string (<code>buildOutput</code>) in that environment and collect the messages that the parsing produces.</p>",
        "id": 444417553,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718269546
    },
    {
        "content": "<p>The functions that I use are in the <code>Lean.Elab.Frontend</code> file, I used <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.process#doc\">docs#Lean.Elab.process</a>, but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.runFrontend#doc\">docs#Lean.Elab.runFrontend</a> is also relevant.</p>",
        "id": 444418002,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718269682
    },
    {
        "content": "<p>(My code uses yet another import command, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.importModules#doc\">docs#Lean.importModules</a>.)</p>",
        "id": 444418479,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718269867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/270676-lean4/topic/Simple.20parsing.2Belaboration.20with.20metaprogramming/near/444406510\">said</a>:</p>\n<blockquote>\n<p>Note that you are calling a different <code>withImportModules</code> to the one I recommended</p>\n</blockquote>\n<p>Oh you are completely right, yours avoids this manual lifting I was struggling with this morning on the train <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>\n<p>So this is equivalent to my code above, I think</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">CoreM</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Core</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">sample</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"[True, False]\"</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">testRunnerCore</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoreM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getEnv</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Parser</span><span class=\"bp\">.</span><span class=\"n\">runParserCategory</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"ss\">`term</span><span class=\"w\"> </span><span class=\"n\">sample</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">MetaM</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">TermElabM</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">dbg_trace</span><span class=\"w\"> </span><span class=\"n\">f!</span><span class=\"s2\">\"out: {m}\"</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">error</span><span class=\"w\"> </span><span class=\"n\">err</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">panic</span><span class=\"w\"> </span><span class=\"n\">err</span>\n\n<span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">testRunner</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">CoreM</span><span class=\"bp\">.</span><span class=\"n\">withImportModules</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"ss\">`Lean</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">testRunnerCore</span><span class=\"w\"> </span><span class=\"n\">none</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">testRunner</span>\n</code></pre></div>\n<p>(the same questions about correctness and evaluation still applies)</p>",
        "id": 444459243,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1718283424
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687971\">Relyth</span> <a href=\"#narrow/stream/270676-lean4/topic/Simple.20parsing.2Belaboration.20with.20metaprogramming/near/444356972\">said</a>:</p>\n<blockquote>\n<p>I was under the impression that parsing and evaluating an expression is not only possible but one of the core common use cases for metaprogramming.</p>\n</blockquote>\n<p>This is mostly correct, but is missing a key qualifier: metaprogramming operates at a program's <em>compile-time</em>, not its <em>run-time</em>. Thus, if you want to parse and evaluate an expression to generate your program's code, then metaprogramming is the way to do it. However, if you want to parse and evaluate an expression <em>within</em> your program, metaprogramming is less useful.</p>",
        "id": 444565888,
        "sender_full_name": "Mac Malone",
        "timestamp": 1718313744
    }
]