[
    {
        "content": "<p><a href=\"https://www.sphinx-doc.org/en/master/usage/advanced/intl.html\">Sphinx</a> uses <a href=\"https://www.gnu.org/software/gettext/\">gettext</a> to generate <a href=\"https://www.gnu.org/software/gettext/manual/html_node/PO-Files.html\">PO files</a> that can be translated into languages other than English. <span class=\"user-mention\" data-user-id=\"354934\">@David Thrane Christiansen</span> I wonder if <a href=\"https://github.com/leanprover/verso\">Verso</a> will also use localization tools like gettext or <a href=\"https://projectfluent.org/\">Fluent</a> to support internationalization.</p>\n<p>Related topic: <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4/topic/Internationalization\">#lean4 &gt; Internationalization</a></p>",
        "id": 416712641,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1705643517
    },
    {
        "content": "<p>That's not on the current development roadmap, but it would be a valuable thing to have. Ideally it's something that can be a library, rather than a built in feature - that way I'm not a single blocker for progress. Are you interested in building this? If so, I'd be happy to consult on how it can be done, and whether core implementation changes are needed to make it a good experience.</p>",
        "id": 416718971,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1705647420
    },
    {
        "content": "<p>Have you used Sphinx this way before? What works well and what are the pain points? I'd like to learn from others rather than just hack hack hack</p>",
        "id": 416719403,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1705647686
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"354934\">David Thrane Christiansen</span> <a href=\"#narrow/stream/270676-lean4/topic/will.20verso.20support.20internationalization.3F/near/416719403\">said</a>:</p>\n<blockquote>\n<p>Have you used Sphinx this way before? What works well and what are the pain points? I'd like to learn from others rather than just hack hack hack</p>\n</blockquote>\n<p>I've only used <a href=\"https://rust-lang.github.io/mdBook/\">mdBook</a> so far. There's a <a href=\"https://github.com/rust-lang/mdBook/pull/1306\">PR</a> implementing the localization option of mdBook. I found it convenient, but it's never been merged for years. So I'm thinking of using Sphinx to write notes about Mathlib this year.</p>",
        "id": 416749691,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1705660427
    },
    {
        "content": "<p>I'm using a <a href=\"https://en.wikipedia.org/wiki/Translation_memory\">translation memory application</a> called <a href=\"https://omegat.org/\">OmegaT</a>. It has various features including fuzzy matching and user glossaries. Since there's a <a href=\"https://okapiframework.org/wiki/index.php/Okapi_Filters_Plugin_for_OmegaT\">Markdown filter plugin for OmegaT</a>, it can open Markdown source files. It can also open PO files.</p>\n<p>I'll use OmegaT every time I want to translate English documents into Korean. It helps me translate technical terms consistently and refer to my previous translations easily.</p>\n<p><a href=\"/user_uploads/3121/C-cf7ms-19PhpHmCDb6mAyw7/omegat.png\">omegat.png</a> (See <a href=\"https://git.sr.ht/~chabulhwi/lean-notes\">https://git.sr.ht/~chabulhwi/lean-notes</a>.)</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/C-cf7ms-19PhpHmCDb6mAyw7/omegat.png\" title=\"omegat.png\"><img src=\"/user_uploads/3121/C-cf7ms-19PhpHmCDb6mAyw7/omegat.png\"></a></div>",
        "id": 416749702,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1705660432
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"354934\">David Thrane Christiansen</span> <a href=\"#narrow/stream/270676-lean4/topic/will.20verso.20support.20internationalization.3F/near/416718971\">said</a>:</p>\n<blockquote>\n<p>That's not on the current development roadmap, but it would be a valuable thing to have. Ideally it's something that can be a library, rather than a built in feature - that way I'm not a single blocker for progress. Are you interested in building this?</p>\n</blockquote>\n<p>I wish I could develop the library, but I don't know how to program yet. I'm currently learning C programming. Lean will be the second programming language I'll have learned.</p>",
        "id": 416750899,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1705660829
    },
    {
        "content": "<p>Thanks for the additional information and context. I took a look at the docs, and I had a bit of a hard time understanding them with the time I had available, so I hope you can check my understanding and let me know if it's wrong! The way I understand it, supporting these tools with Verso could look something like this:</p>\n<ol>\n<li>While building the document, <code>.po</code> files are created with entries for each (sentence? paragraph?). These would be some kind of easily-reparsed markup (perhaps something markdownish or HTMLish).</li>\n<li>The translator would then use OmegaT or Transifex or some other tool to add the translations to the <code>.po</code> file</li>\n<li>When the document is built again, rather than creating a .po file, it should _synchronize_ it, making sure that any new translatable elements are added but not deleting old ones (as they may have translations in them). Additionally, it generates outputs for each localization based on the contents of the <code>.po</code> files post-synchronization.</li>\n<li>As the document is maintained, the collection of strings needing translation in the <code>.po</code> grows, because added or modified units show up as new ones. Presumably there's tooling to check for coverage and to flag obsolete units to translators.</li>\n</ol>\n<p>Is that about right? Once consequence of this workflow is that translations don't know about language extensions, so they're provided with the output of them. For instance, if I defined a Verso macro that inserted the current date, the .po would have the date rather than the call to the macro. This seems needed to me, as a language extension won't be able to e.g. insert gendered second-person pronouns, perform case declension, or adopt capitalization rules. But I'm a total beginner here - my localization experience is limited to some contributions to the Danish translation of DrRacket - so your feedback is very welcome.</p>",
        "id": 417182627,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1705913816
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"354934\">David Thrane Christiansen</span> <a href=\"#narrow/stream/270676-lean4/topic/will.20verso.20support.20internationalization.3F/near/417182627\">said</a>:</p>\n<blockquote>\n<ol>\n<li>While building the document, <code>.po</code> files are created with entries for each (sentence? paragraph?). These would be some kind of easily-reparsed markup (perhaps something markdownish or HTMLish).</li>\n<li>The translator would then use OmegaT or Transifex or some other tool to add the translations to the <code>.po</code> file</li>\n<li>When the document is built again, rather than creating a .po file, it should _synchronize_ it, making sure that any new translatable elements are added but not deleting old ones (as they may have translations in them). Additionally, it generates outputs for each localization based on the contents of the <code>.po</code> files post-synchronization.</li>\n<li>As the document is maintained, the collection of strings needing translation in the <code>.po</code> grows, because added or modified units show up as new ones. Presumably there's tooling to check for coverage and to flag obsolete units to translators.</li>\n</ol>\n<p>Is that about right?</p>\n</blockquote>\n<p>I think so, although I'm also a beginner in localization.</p>\n<blockquote>\n<p>One consequence of this workflow is that translations don't know about language extensions, so they're provided with the output of them. For instance, if I defined a Verso macro that inserted the current date, the .po would have the date rather than the call to the macro. This seems needed to me, as a language extension won't be able to e.g. insert gendered second-person pronouns, perform case declension, or adopt capitalization rules.</p>\n</blockquote>\n<p>I agree that <code>.po</code> files should have the outputs of Verso macros. I'd want to translate \"January 23, 2024\" to \"2024년 1월 23일\" while using OmegaT to translate <code>.po</code> files.</p>",
        "id": 417437604,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1706013729
    },
    {
        "content": "<p>Thanks! This is still not on the roadmap for me to do, but it's good to have insights into what would be required.</p>",
        "id": 418631580,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1706533157
    }
]