[
    {
        "content": "<p>Should I expect <code>exact?</code> to not find <code>Fintype.ofEquiv</code> in:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n  <span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">heq</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≃*</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span><span class=\"bp\">?</span> <span class=\"c1\">-- fails</span>\n  <span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">heq</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≃*</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.ofEquiv</span> <span class=\"n\">A</span> <span class=\"n\">heq</span>\n</code></pre></div>\n<p>And what's with the second error message that talks about <code>'linearIndependentFintypeOfLeSpanFintype'</code>?</p>",
        "id": 409266197,
        "sender_full_name": "Julian Berman",
        "timestamp": 1703109154
    },
    {
        "content": "<p>I guess there's an implicit coercion. Does it work if heq is the bare Equiv?</p>",
        "id": 409267959,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1703109956
    },
    {
        "content": "<p>On a version of mathlib from today, I just see a single error message, in the first <code>example</code>. Where are you seeing anything about <code>linearIndependentFintypeOfLeSpanFintype</code>?</p>",
        "id": 409269832,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703110865
    },
    {
        "content": "<p>I'm probably a few days behind on this gitpod, let me update.</p>",
        "id": 409270720,
        "sender_full_name": "Julian Berman",
        "timestamp": 1703111352
    },
    {
        "content": "<p>This succeeds:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">heq</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≃</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span><span class=\"bp\">?</span>\n</code></pre></div>\n<p>Maybe <code>exact?</code> could put all the projections to parent structures in context before searching? (<span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Would that be feasible?)</p>",
        "id": 409270938,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703111447
    },
    {
        "content": "<p>(Indeed upgrading from <code>4310b5835</code> which is what I was on to HEAD now makes that linear independent error message go away)</p>",
        "id": 409271566,
        "sender_full_name": "Julian Berman",
        "timestamp": 1703111784
    },
    {
        "content": "<p>That's because I <a href=\"https://github.com/leanprover-community/mathlib4/commit/a3e8d01e04f285df56c4b2a60eaf393b3fceb2ac#diff-4ea04b200530631490327d52c08d2c461018f0209e7ee3adb67cb8009faabbf3L712-R706\">changed</a> the Fintype to Finite</p>",
        "id": 409284926,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1703120099
    },
    {
        "content": "<p>But what I didn't understand is what it had anything to do with that example that <code>exact?</code> was finding it (and then complaining about it)</p>",
        "id": 409285905,
        "sender_full_name": "Julian Berman",
        "timestamp": 1703120908
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/exact.3F.20double.20boom/near/409270938\">said</a>:</p>\n<blockquote>\n<p>This succeeds:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">heq</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≃</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span><span class=\"bp\">?</span>\n</code></pre></div>\n<p>Maybe <code>exact?</code> could put all the projections to parent structures in context before searching? (<span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> Would that be feasible?)</p>\n</blockquote>\n<p>Presumably this would be a change to <code>solve_by_elim</code> rather than <code>exact?</code>. If I'm understanding right, <code>exact?</code> would be applying <code>Fintype.ofEquiv</code> here successfully, but then failing to fill in the subgoals.</p>",
        "id": 409290620,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1703124793
    },
    {
        "content": "<p>If someone wants to implement a <code>saturate_parents</code> tactic we could easily try hooking that in.</p>",
        "id": 409290753,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1703124866
    }
]