[
    {
        "content": "<p>Let me introduce a Regex library that I have just completed the correctness proof in Lean <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span> The library uses a NFA-based PikeVM, which guarantees the linear worst-case run time. I'm also planning to further optimize the performance by profiling and reducing the allocations.</p>\n<p>This is my first serious Lean project, and I'd appreciate any help or suggestions you can provide. Thanks!</p>\n<p><a href=\"https://github.com/pandaman64/lean-regex/tree/main\">https://github.com/pandaman64/lean-regex/tree/main</a></p>",
        "id": 411353836,
        "sender_full_name": "pandaman",
        "timestamp": 1704454677
    },
    {
        "content": "<p>Does it intentionally avoid <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NFA#doc\">docs#NFA</a> from Mathlib?</p>",
        "id": 411356159,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1704455722
    },
    {
        "content": "<p>Yes. I wanted to explicitly control how the data is laid out in memory.</p>",
        "id": 411357332,
        "sender_full_name": "pandaman",
        "timestamp": 1704456185
    },
    {
        "content": "<p>Where is it done?</p>",
        "id": 411361339,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1704457418
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"417654\">@Martin Dvořák</span> Are there examples of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NFA#doc\">docs#NFA</a> being evaluated? That type seems good for purely theoretical arguments, which is great, but <code>Set</code> has no runtime representation.</p>\n<p>Here's the NFA type: <a href=\"https://github.com/pandaman64/lean-regex/blob/main/Regex/NFA/Basic.lean#L72\">https://github.com/pandaman64/lean-regex/blob/main/Regex/NFA/Basic.lean#L72</a></p>\n<p>Here's the NFA state: <a href=\"https://github.com/pandaman64/lean-regex/blob/main/Regex/NFA/VM/Basic.lean#L23\">https://github.com/pandaman64/lean-regex/blob/main/Regex/NFA/VM/Basic.lean#L23</a></p>",
        "id": 411362018,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704457779
    },
    {
        "content": "<p>You can find state transitions here: <a href=\"https://github.com/pandaman64/lean-regex/blob/9e6270b46436f7e147d1396bf67616fe8d86fd29/Regex/NFA/VM/Basic.lean#L337\">https://github.com/pandaman64/lean-regex/blob/9e6270b46436f7e147d1396bf67616fe8d86fd29/Regex/NFA/VM/Basic.lean#L337</a></p>",
        "id": 411362242,
        "sender_full_name": "pandaman",
        "timestamp": 1704457910
    },
    {
        "content": "<p>Oic now.<br>\n<a href=\"https://github.com/pandaman64/lean-regex/blob/main/Regex/NFA/Tests.lean\">https://github.com/pandaman64/lean-regex/blob/main/Regex/NFA/Tests.lean</a><br>\nThe regex is specified as a tree (inside there is array), the input is specified as a string.</p>",
        "id": 411362324,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1704457940
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395416\">@pandaman</span> Could you change the <code>.char</code> regex to take a <code>Char -&gt; Bool</code> predicate instead of a <code>Char</code>? I'm not sure all the implications this would be to what you've done, but that would let you handle character ranges easily, which could otherwise be intractable to represent as a regex if it's a big unicode range. I'm assuming you could modify the VM similarly.</p>",
        "id": 411362926,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704458257
    },
    {
        "content": "<p>(For the NFA state, I saw you mentioned bitvec, which would be a really good improvement to its efficiency. It looks like you already were careful to create an API around <code>NodeSet</code>, which hopefully makes the transition fairly painless! One first step you could do is change that from an <code>abbrev</code> to a <code>def</code> to see where you're accidentally using its definition.)</p>",
        "id": 411363457,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704458488
    },
    {
        "content": "<p>Thank you for the suggestions! I'm planning to do some benchmarking via <a href=\"https://github.com/BurntSushi/rebar\">rebar</a> to measure the base libe performance first, but these suggestions totally make sense.<br>\nOne thing I'm unsure about the bitvec is how to reuse allocations. It uses Nat under the hood, and I'm wondering if we need to reallocate the bigint for each iteration (while we can reuse arrays by clearing it): <a href=\"https://github.com/leanprover/std4/blob/0f6bc5b32bf5b0498902d3b5f0806c75530539d5/Std/Data/BitVec/Basic.lean#L29\">https://github.com/leanprover/std4/blob/0f6bc5b32bf5b0498902d3b5f0806c75530539d5/Std/Data/BitVec/Basic.lean#L29</a></p>",
        "id": 411364739,
        "sender_full_name": "pandaman",
        "timestamp": 1704459062
    },
    {
        "content": "<p>Hmm, I'm not sure whether Lean can re-use Nats like it can an Array. (I also don't see any API for setting bits for bitvec)</p>",
        "id": 411367120,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704460186
    },
    {
        "content": "<p>I suppose <code>Array Bool</code> might not be that bad of a representation -- if I remember correctly, while <code>Array Bool</code> might be an array of pointers, at least the <code>Bool</code> values are packed inside the pointers, so there's no indirection. (I could be misremembering this detail about the Lean runtime.)</p>",
        "id": 411367526,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704460410
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/270676-lean4/topic/PSA.3A.20Verified.20Regex.20Matching.20with.20PikeVM/near/411367526\">said</a>:</p>\n<blockquote>\n<p>I suppose <code>Array Bool</code> might not be that bad of a representation -- if I remember correctly, while <code>Array Bool</code> might be an array of pointers, at least the <code>Bool</code> values are packed inside the pointers, so there's no indirection. (I could be misremembering this detail about the Lean runtime.)</p>\n</blockquote>\n<p>This is corrext, Array Bool will be represented as an Array of tagged pointers so if you access the bool it has to be shifted etc. If you wish an even more efficient representation you should use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ByteArray#doc\">docs#ByteArray</a></p>",
        "id": 411367948,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1704460624
    },
    {
        "content": "<p>I'm putting together a bitvec implementation based on ByteArrays over in LeanColls, if it is of use to anyone <span aria-label=\"stuck out tongue closed eyes\" class=\"emoji emoji-1f61d\" role=\"img\" title=\"stuck out tongue closed eyes\">:stuck_out_tongue_closed_eyes:</span></p>",
        "id": 411490259,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1704532179
    },
    {
        "content": "<p>I'd guess ByteArray is most efficient for dense bit arrays and either BitVec or a hash map is more efficient for sparse bit arrays depending on layout.  It'd be great to get benchmarks on this though.</p>",
        "id": 412437004,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1705014537
    },
    {
        "content": "<p>Nice! How does it go on <a href=\"https://stackoverflow.com/q/1732348\">HTML</a>?</p>",
        "id": 412454260,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1705021925
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/PSA.3A.20Verified.20Regex.20Matching.20with.20PikeVM/near/411367948\">said</a>:</p>\n<blockquote>\n<p>This is corrext, Array Bool will be represented as an Array of tagged pointers so if you access the bool it has to be shifted etc. If you wish an even more efficient representation you should use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ByteArray#doc\">docs#ByteArray</a></p>\n</blockquote>\n<p>Are you sure <code>Array Bool</code> is an array of tagged pointers? <code>Bool</code> is represnted as a <code>UInt8</code>, so I believe <code>Array Bool</code> would just be an array of boxed <code>UInt8</code> / scalar objects (where boxing in this case means a shift <code>&lt;&lt; 1</code> is applied to the value to turn it into a pseudo-<code>lean_object*</code>). As such, the overhead over <code>ByteArray</code> would be that each entry is represnted a <code>USize</code> rather than a <code>UInt8</code> and has to been unboxed from the <code>USize</code> to <code>UInt8</code> after loading via a single shift.</p>",
        "id": 412454273,
        "sender_full_name": "Mac Malone",
        "timestamp": 1705021935
    },
    {
        "content": "<p><del>On, and there is 1 more level of indirection because the <code>Array</code> value is stored as a pointer in the <code>lean_object</code> whereas the scalar <code>ByteArray</code> object is stored inline in the <code>lean_object</code>.</del> <strong>EDIT:</strong> They are both inline.</p>",
        "id": 412454380,
        "sender_full_name": "Mac Malone",
        "timestamp": 1705022015
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac Malone</span> <a href=\"#narrow/stream/270676-lean4/topic/PSA.3A.20Verified.20Regex.20Matching.20with.20PikeVM/near/412454273\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/270676-lean4/topic/PSA.3A.20Verified.20Regex.20Matching.20with.20PikeVM/near/411367948\">said</a>:</p>\n<blockquote>\n<p>This is corrext, Array Bool will be represented as an Array of tagged pointers so if you access the bool it has to be shifted etc. If you wish an even more efficient representation you should use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ByteArray#doc\">docs#ByteArray</a></p>\n</blockquote>\n<p>Are you sure <code>Array Bool</code> is an array of tagged pointers? <code>Bool</code> is represnted as a <code>UInt8</code>, so I believe <code>Array Bool</code> would just be an array of boxed <code>UInt8</code> / scalar objects (where boxing in this case means a shift <code>&lt;&lt; 1</code> is applied to the value to turn it into a pseudo-<code>lean_object*</code>). As such, the overhead over <code>ByteArray</code> would be that each entry is represnted a <code>USize</code> rather than a <code>UInt8</code> and has to been unboxed from the <code>USize</code> to <code>UInt8</code> after loading via a single shift.</p>\n</blockquote>\n<p>I was under the impression that that's what we mean by a tagged pointer? But yes what you are saying is the correct representation</p>",
        "id": 412489146,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1705043685
    },
    {
        "content": "<p>I'm going to perform a benchmark with <code>Array Bool</code> and <code>ByteArray</code> (and possibly <code>Nat</code>) next weekend. Stay tuned<span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 412504783,
        "sender_full_name": "pandaman",
        "timestamp": 1705051080
    },
    {
        "content": "<p>I did a quick benchmark, and it turned out that <strong><code>Array Bool</code> was 10% faster than <code>ByteArray</code></strong>. You can find the code and more results here: <a href=\"https://github.com/pandaman64/lean-regex/pull/1\">https://github.com/pandaman64/lean-regex/pull/1</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">$</span> <span class=\"n\">hyperfine</span> <span class=\"c1\">--warmup 10 \"./array-bool 'lean|rust' /usr/share/dict/american-english\"  \"./bytearray 'lean|rust' /usr/share/dict/american-english\"</span>\n<span class=\"n\">Benchmark</span> <span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"bp\">./</span><span class=\"n\">array</span><span class=\"bp\">-</span><span class=\"n\">bool</span> <span class=\"bp\">'</span><span class=\"n\">lean</span><span class=\"bp\">|</span><span class=\"n\">rust'</span> <span class=\"bp\">/</span><span class=\"n\">usr</span><span class=\"bp\">/</span><span class=\"n\">share</span><span class=\"bp\">/</span><span class=\"n\">dict</span><span class=\"bp\">/</span><span class=\"n\">american</span><span class=\"bp\">-</span><span class=\"n\">english</span>\n  <span class=\"n\">Time</span> <span class=\"o\">(</span><span class=\"n\">mean</span> <span class=\"bp\">±</span> <span class=\"n\">σ</span><span class=\"o\">):</span>     <span class=\"mi\">270</span><span class=\"bp\">.</span><span class=\"mi\">7</span> <span class=\"n\">ms</span> <span class=\"bp\">±</span>  <span class=\"mi\">10</span><span class=\"bp\">.</span><span class=\"mi\">4</span> <span class=\"n\">ms</span>    <span class=\"o\">[</span><span class=\"n\">User</span><span class=\"o\">:</span> <span class=\"mi\">262</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">ms</span><span class=\"o\">,</span> <span class=\"n\">System</span><span class=\"o\">:</span> <span class=\"mi\">8</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">ms</span><span class=\"o\">]</span>\n  <span class=\"n\">Range</span> <span class=\"o\">(</span><span class=\"n\">min</span> <span class=\"bp\">…</span> <span class=\"n\">max</span><span class=\"o\">):</span>   <span class=\"mi\">261</span><span class=\"bp\">.</span><span class=\"mi\">3</span> <span class=\"n\">ms</span> <span class=\"bp\">…</span> <span class=\"mi\">296</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">ms</span>    <span class=\"mi\">11</span> <span class=\"n\">runs</span>\n\n<span class=\"n\">Benchmark</span> <span class=\"mi\">2</span><span class=\"o\">:</span> <span class=\"bp\">./</span><span class=\"n\">bytearray</span> <span class=\"bp\">'</span><span class=\"n\">lean</span><span class=\"bp\">|</span><span class=\"n\">rust'</span> <span class=\"bp\">/</span><span class=\"n\">usr</span><span class=\"bp\">/</span><span class=\"n\">share</span><span class=\"bp\">/</span><span class=\"n\">dict</span><span class=\"bp\">/</span><span class=\"n\">american</span><span class=\"bp\">-</span><span class=\"n\">english</span>\n  <span class=\"n\">Time</span> <span class=\"o\">(</span><span class=\"n\">mean</span> <span class=\"bp\">±</span> <span class=\"n\">σ</span><span class=\"o\">):</span>     <span class=\"mi\">298</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">ms</span> <span class=\"bp\">±</span>   <span class=\"mi\">5</span><span class=\"bp\">.</span><span class=\"mi\">3</span> <span class=\"n\">ms</span>    <span class=\"o\">[</span><span class=\"n\">User</span><span class=\"o\">:</span> <span class=\"mi\">290</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">ms</span><span class=\"o\">,</span> <span class=\"n\">System</span><span class=\"o\">:</span> <span class=\"mi\">7</span><span class=\"bp\">.</span><span class=\"mi\">9</span> <span class=\"n\">ms</span><span class=\"o\">]</span>\n  <span class=\"n\">Range</span> <span class=\"o\">(</span><span class=\"n\">min</span> <span class=\"bp\">…</span> <span class=\"n\">max</span><span class=\"o\">):</span>   <span class=\"mi\">291</span><span class=\"bp\">.</span><span class=\"mi\">0</span> <span class=\"n\">ms</span> <span class=\"bp\">…</span> <span class=\"mi\">306</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">ms</span>    <span class=\"mi\">10</span> <span class=\"n\">runs</span>\n\n<span class=\"n\">Summary</span>\n  <span class=\"bp\">./</span><span class=\"n\">array</span><span class=\"bp\">-</span><span class=\"n\">bool</span> <span class=\"bp\">'</span><span class=\"n\">lean</span><span class=\"bp\">|</span><span class=\"n\">rust'</span> <span class=\"bp\">/</span><span class=\"n\">usr</span><span class=\"bp\">/</span><span class=\"n\">share</span><span class=\"bp\">/</span><span class=\"n\">dict</span><span class=\"bp\">/</span><span class=\"n\">american</span><span class=\"bp\">-</span><span class=\"n\">english</span> <span class=\"n\">ran</span>\n    <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">10</span> <span class=\"bp\">±</span> <span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">05</span> <span class=\"n\">times</span> <span class=\"n\">faster</span> <span class=\"n\">than</span> <span class=\"bp\">./</span><span class=\"n\">bytearray</span> <span class=\"bp\">'</span><span class=\"n\">lean</span><span class=\"bp\">|</span><span class=\"n\">rust'</span> <span class=\"bp\">/</span><span class=\"n\">usr</span><span class=\"bp\">/</span><span class=\"n\">share</span><span class=\"bp\">/</span><span class=\"n\">dict</span><span class=\"bp\">/</span><span class=\"n\">american</span><span class=\"bp\">-</span><span class=\"n\">english</span>\n</code></pre></div>",
        "id": 412708029,
        "sender_full_name": "pandaman",
        "timestamp": 1705150398
    },
    {
        "content": "<p>I originally wanted to try <a href=\"https://github.com/BurntSushi/rebar\">rebar</a> for more comprehensive benchmarking, but rebar is search-oriented while I only implemented matching for the whole string...</p>",
        "id": 412708101,
        "sender_full_name": "pandaman",
        "timestamp": 1705150455
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395416\">pandaman</span> <a href=\"#narrow/stream/270676-lean4/topic/PSA.3A.20Verified.20Regex.20Matching.20with.20PikeVM/near/412708029\">said</a>:</p>\n<blockquote>\n<p>I did a quick benchmark, and it turned out that <strong><code>Array Bool</code> was 10% faster than <code>ByteArray</code></strong>. You can find the code and more results here: <a href=\"https://github.com/pandaman64/lean-regex/pull/1\">https://github.com/pandaman64/lean-regex/pull/1</a></p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">$</span> <span class=\"n\">hyperfine</span> <span class=\"c1\">--warmup 10 \"./array-bool 'lean|rust' /usr/share/dict/american-english\"  \"./bytearray 'lean|rust' /usr/share/dict/american-english\"</span>\n<span class=\"n\">Benchmark</span> <span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"bp\">./</span><span class=\"n\">array</span><span class=\"bp\">-</span><span class=\"n\">bool</span> <span class=\"bp\">'</span><span class=\"n\">lean</span><span class=\"bp\">|</span><span class=\"n\">rust'</span> <span class=\"bp\">/</span><span class=\"n\">usr</span><span class=\"bp\">/</span><span class=\"n\">share</span><span class=\"bp\">/</span><span class=\"n\">dict</span><span class=\"bp\">/</span><span class=\"n\">american</span><span class=\"bp\">-</span><span class=\"n\">english</span>\n  <span class=\"n\">Time</span> <span class=\"o\">(</span><span class=\"n\">mean</span> <span class=\"bp\">±</span> <span class=\"n\">σ</span><span class=\"o\">):</span>     <span class=\"mi\">270</span><span class=\"bp\">.</span><span class=\"mi\">7</span> <span class=\"n\">ms</span> <span class=\"bp\">±</span>  <span class=\"mi\">10</span><span class=\"bp\">.</span><span class=\"mi\">4</span> <span class=\"n\">ms</span>    <span class=\"o\">[</span><span class=\"n\">User</span><span class=\"o\">:</span> <span class=\"mi\">262</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">ms</span><span class=\"o\">,</span> <span class=\"n\">System</span><span class=\"o\">:</span> <span class=\"mi\">8</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">ms</span><span class=\"o\">]</span>\n  <span class=\"n\">Range</span> <span class=\"o\">(</span><span class=\"n\">min</span> <span class=\"bp\">…</span> <span class=\"n\">max</span><span class=\"o\">):</span>   <span class=\"mi\">261</span><span class=\"bp\">.</span><span class=\"mi\">3</span> <span class=\"n\">ms</span> <span class=\"bp\">…</span> <span class=\"mi\">296</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">ms</span>    <span class=\"mi\">11</span> <span class=\"n\">runs</span>\n\n<span class=\"n\">Benchmark</span> <span class=\"mi\">2</span><span class=\"o\">:</span> <span class=\"bp\">./</span><span class=\"n\">bytearray</span> <span class=\"bp\">'</span><span class=\"n\">lean</span><span class=\"bp\">|</span><span class=\"n\">rust'</span> <span class=\"bp\">/</span><span class=\"n\">usr</span><span class=\"bp\">/</span><span class=\"n\">share</span><span class=\"bp\">/</span><span class=\"n\">dict</span><span class=\"bp\">/</span><span class=\"n\">american</span><span class=\"bp\">-</span><span class=\"n\">english</span>\n  <span class=\"n\">Time</span> <span class=\"o\">(</span><span class=\"n\">mean</span> <span class=\"bp\">±</span> <span class=\"n\">σ</span><span class=\"o\">):</span>     <span class=\"mi\">298</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">ms</span> <span class=\"bp\">±</span>   <span class=\"mi\">5</span><span class=\"bp\">.</span><span class=\"mi\">3</span> <span class=\"n\">ms</span>    <span class=\"o\">[</span><span class=\"n\">User</span><span class=\"o\">:</span> <span class=\"mi\">290</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">ms</span><span class=\"o\">,</span> <span class=\"n\">System</span><span class=\"o\">:</span> <span class=\"mi\">7</span><span class=\"bp\">.</span><span class=\"mi\">9</span> <span class=\"n\">ms</span><span class=\"o\">]</span>\n  <span class=\"n\">Range</span> <span class=\"o\">(</span><span class=\"n\">min</span> <span class=\"bp\">…</span> <span class=\"n\">max</span><span class=\"o\">):</span>   <span class=\"mi\">291</span><span class=\"bp\">.</span><span class=\"mi\">0</span> <span class=\"n\">ms</span> <span class=\"bp\">…</span> <span class=\"mi\">306</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">ms</span>    <span class=\"mi\">10</span> <span class=\"n\">runs</span>\n\n<span class=\"n\">Summary</span>\n  <span class=\"bp\">./</span><span class=\"n\">array</span><span class=\"bp\">-</span><span class=\"n\">bool</span> <span class=\"bp\">'</span><span class=\"n\">lean</span><span class=\"bp\">|</span><span class=\"n\">rust'</span> <span class=\"bp\">/</span><span class=\"n\">usr</span><span class=\"bp\">/</span><span class=\"n\">share</span><span class=\"bp\">/</span><span class=\"n\">dict</span><span class=\"bp\">/</span><span class=\"n\">american</span><span class=\"bp\">-</span><span class=\"n\">english</span> <span class=\"n\">ran</span>\n    <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">10</span> <span class=\"bp\">±</span> <span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">05</span> <span class=\"n\">times</span> <span class=\"n\">faster</span> <span class=\"n\">than</span> <span class=\"bp\">./</span><span class=\"n\">bytearray</span> <span class=\"bp\">'</span><span class=\"n\">lean</span><span class=\"bp\">|</span><span class=\"n\">rust'</span> <span class=\"bp\">/</span><span class=\"n\">usr</span><span class=\"bp\">/</span><span class=\"n\">share</span><span class=\"bp\">/</span><span class=\"n\">dict</span><span class=\"bp\">/</span><span class=\"n\">american</span><span class=\"bp\">-</span><span class=\"n\">english</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>That PR doesn't really look like a proper ByteArray implementation to me? Once you have a ByteArray you can pack 8 Bools into a single slot of the ByteArray instead of just 1 Bool per slot, I don't see this packing happening in your PR? I would expect that just from this packing alone you should get drastically better cache hits on non trivial regexes which should easily be able to outrun Array Bool in my expectation. If that's not the case I would be very interested in digging as to why that is.</p>",
        "id": 412708280,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1705150655
    },
    {
        "content": "<blockquote>\n<p>That PR doesn't really look like a proper ByteArray implementation to me?</p>\n</blockquote>\n<p>I just wanted to see if I can get a quick win by switching the underlying array. While bit packing could be advantageous, it would also increase the verification burden, and that's not the path I'm currently pursuing.</p>",
        "id": 412708847,
        "sender_full_name": "pandaman",
        "timestamp": 1705151140
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395416\">pandaman</span> <a href=\"#narrow/stream/270676-lean4/topic/PSA.3A.20Verified.20Regex.20Matching.20with.20PikeVM/near/412708847\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>That PR doesn't really look like a proper ByteArray implementation to me?</p>\n</blockquote>\n<p>I just wanted to see if I can get a quick win by switching the underlying array. While bit packing could be advantageous, it would also increase the verification burden, and that's not the path I'm currently pursuing.</p>\n</blockquote>\n<p>Right that's fair. Also just for fun I tried to reproduce your benchmark on a file of myself (has approx 2k lines):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">λ</span> <span class=\"n\">hyperfine</span> <span class=\"c1\">--warmup 10 \".lake/build/bin/RunRegex 'lean|rust|' /var/log/dnf.log\"                                                                                                                            &lt;&lt;&lt;</span>\n<span class=\"n\">Benchmark</span> <span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"bp\">.</span><span class=\"n\">lake</span><span class=\"bp\">/</span><span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">bin</span><span class=\"bp\">/</span><span class=\"n\">RunRegex</span> <span class=\"bp\">'</span><span class=\"n\">lean</span><span class=\"bp\">|</span><span class=\"n\">rust</span><span class=\"bp\">|'</span> <span class=\"bp\">/</span><span class=\"n\">var</span><span class=\"bp\">/</span><span class=\"n\">log</span><span class=\"bp\">/</span><span class=\"n\">dnf.log</span>\n  <span class=\"n\">Time</span> <span class=\"o\">(</span><span class=\"n\">mean</span> <span class=\"bp\">±</span> <span class=\"n\">σ</span><span class=\"o\">):</span>     <span class=\"mi\">121</span><span class=\"bp\">.</span><span class=\"mi\">4</span> <span class=\"n\">ms</span> <span class=\"bp\">±</span>   <span class=\"mi\">3</span><span class=\"bp\">.</span><span class=\"mi\">3</span> <span class=\"n\">ms</span>    <span class=\"o\">[</span><span class=\"n\">User</span><span class=\"o\">:</span> <span class=\"mi\">112</span><span class=\"bp\">.</span><span class=\"mi\">8</span> <span class=\"n\">ms</span><span class=\"o\">,</span> <span class=\"n\">System</span><span class=\"o\">:</span> <span class=\"mi\">8</span><span class=\"bp\">.</span><span class=\"mi\">0</span> <span class=\"n\">ms</span><span class=\"o\">]</span>\n  <span class=\"n\">Range</span> <span class=\"o\">(</span><span class=\"n\">min</span> <span class=\"bp\">…</span> <span class=\"n\">max</span><span class=\"o\">):</span>   <span class=\"mi\">118</span><span class=\"bp\">.</span><span class=\"mi\">3</span> <span class=\"n\">ms</span> <span class=\"bp\">…</span> <span class=\"mi\">130</span><span class=\"bp\">.</span><span class=\"mi\">7</span> <span class=\"n\">ms</span>    <span class=\"mi\">24</span> <span class=\"n\">runs</span>\n\n<span class=\"n\">florence</span><span class=\"o\">:</span><span class=\"bp\">~/</span><span class=\"n\">Desktop</span><span class=\"bp\">/</span><span class=\"n\">formal_verification</span><span class=\"bp\">/</span><span class=\"n\">lean</span><span class=\"bp\">/</span><span class=\"n\">lean</span><span class=\"bp\">-</span><span class=\"n\">regex</span><span class=\"bp\">|</span><span class=\"n\">main</span>\n<span class=\"bp\">λ</span> <span class=\"n\">git</span> <span class=\"n\">checkout</span>  <span class=\"n\">test</span><span class=\"bp\">/</span><span class=\"n\">bytearray</span>\n<span class=\"n\">branch</span> <span class=\"bp\">'</span><span class=\"n\">test</span><span class=\"bp\">/</span><span class=\"n\">bytearray'</span> <span class=\"n\">set</span> <span class=\"n\">up</span> <span class=\"n\">to</span> <span class=\"n\">track</span> <span class=\"bp\">'</span><span class=\"n\">origin</span><span class=\"bp\">/</span><span class=\"n\">test</span><span class=\"bp\">/</span><span class=\"n\">bytearray'.</span>\n<span class=\"n\">Switched</span> <span class=\"n\">to</span> <span class=\"n\">a</span> <span class=\"n\">new</span> <span class=\"n\">branch</span> <span class=\"bp\">'</span><span class=\"n\">test</span><span class=\"bp\">/</span><span class=\"n\">bytearray'</span>\n<span class=\"n\">florence</span><span class=\"o\">:</span><span class=\"bp\">~/</span><span class=\"n\">Desktop</span><span class=\"bp\">/</span><span class=\"n\">formal_verification</span><span class=\"bp\">/</span><span class=\"n\">lean</span><span class=\"bp\">/</span><span class=\"n\">lean</span><span class=\"bp\">-</span><span class=\"n\">regex</span><span class=\"bp\">|</span><span class=\"n\">test</span><span class=\"bp\">/</span><span class=\"n\">bytearray</span>\n<span class=\"bp\">λ</span> <span class=\"n\">lake</span> <span class=\"n\">build</span> <span class=\"n\">RunRegex</span>\n<span class=\"bp\">...</span>\n<span class=\"n\">florence</span><span class=\"o\">:</span><span class=\"bp\">~/</span><span class=\"n\">Desktop</span><span class=\"bp\">/</span><span class=\"n\">formal_verification</span><span class=\"bp\">/</span><span class=\"n\">lean</span><span class=\"bp\">/</span><span class=\"n\">lean</span><span class=\"bp\">-</span><span class=\"n\">regex</span><span class=\"bp\">|</span><span class=\"n\">test</span><span class=\"bp\">/</span><span class=\"n\">bytearray</span>\n<span class=\"bp\">λ</span> <span class=\"n\">hyperfine</span> <span class=\"c1\">--warmup 10 \".lake/build/bin/RunRegex 'lean|rust|' /var/log/dnf.log\"                                                                                                                            &lt;&lt;&lt;</span>\n<span class=\"n\">Benchmark</span> <span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"bp\">.</span><span class=\"n\">lake</span><span class=\"bp\">/</span><span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">bin</span><span class=\"bp\">/</span><span class=\"n\">RunRegex</span> <span class=\"bp\">'</span><span class=\"n\">lean</span><span class=\"bp\">|</span><span class=\"n\">rust</span><span class=\"bp\">|'</span> <span class=\"bp\">/</span><span class=\"n\">var</span><span class=\"bp\">/</span><span class=\"n\">log</span><span class=\"bp\">/</span><span class=\"n\">dnf.log</span>\n  <span class=\"n\">Time</span> <span class=\"o\">(</span><span class=\"n\">mean</span> <span class=\"bp\">±</span> <span class=\"n\">σ</span><span class=\"o\">):</span>     <span class=\"mi\">121</span><span class=\"bp\">.</span><span class=\"mi\">6</span> <span class=\"n\">ms</span> <span class=\"bp\">±</span>   <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">5</span> <span class=\"n\">ms</span>    <span class=\"o\">[</span><span class=\"n\">User</span><span class=\"o\">:</span> <span class=\"mi\">112</span><span class=\"bp\">.</span><span class=\"mi\">5</span> <span class=\"n\">ms</span><span class=\"o\">,</span> <span class=\"n\">System</span><span class=\"o\">:</span> <span class=\"mi\">8</span><span class=\"bp\">.</span><span class=\"mi\">6</span> <span class=\"n\">ms</span><span class=\"o\">]</span>\n  <span class=\"n\">Range</span> <span class=\"o\">(</span><span class=\"n\">min</span> <span class=\"bp\">…</span> <span class=\"n\">max</span><span class=\"o\">):</span>   <span class=\"mi\">119</span><span class=\"bp\">.</span><span class=\"mi\">9</span> <span class=\"n\">ms</span> <span class=\"bp\">…</span> <span class=\"mi\">126</span><span class=\"bp\">.</span><span class=\"mi\">5</span> <span class=\"n\">ms</span>    <span class=\"mi\">24</span> <span class=\"n\">runs</span>\n</code></pre></div>\n<p>That looks like approximately like within noise to me? How big is your dataset? I'd like to figure out where exactly the performance diff is coming from</p>",
        "id": 412709613,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1705151941
    },
    {
        "content": "<p>I used Ubuntu's American English dictionary: <a href=\"https://manpages.ubuntu.com/manpages/trusty/man5/american-english.5.html\">https://manpages.ubuntu.com/manpages/trusty/man5/american-english.5.html</a><br>\nI already left my machine, but I can check the line count tomorrow.</p>\n<p>I ran the benchmark on WSL, which might or might not affect the result.</p>",
        "id": 412710787,
        "sender_full_name": "pandaman",
        "timestamp": 1705153125
    },
    {
        "content": "<p>This line looks bad:</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"w\"> </span>def NodeSet.empty {n : Nat} : NodeSet n :=\n<span class=\"gd\">-  ⟨mkArray n false, by simp⟩</span>\n<span class=\"gi\">+  ⟨⟨mkArray n 0⟩, by simp [ByteArray.size]⟩</span>\n</code></pre></div>\n<p>You are creating an <code>Array UInt8</code> and converting it to a <code>ByteArray</code> there, so you lose most of the performance wins of the 8x less memory allocation needed by ByteArray</p>",
        "id": 412755194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705187854
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395416\">@pandaman</span> The speed benefits usually come from using <code>USize</code> for indexing instead of <code>Nat</code> (i.e, <code>uget</code> vs <code>get</code>/<code>fget</code>). Using <code>ByteArray</code> gives an 8x improvement in memory allocation, and the access time should be equal or better than <code>Array UInt8</code> when using <code>USize</code> instead of <code>Nat</code>.</p>",
        "id": 413026087,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1705351333
    }
]