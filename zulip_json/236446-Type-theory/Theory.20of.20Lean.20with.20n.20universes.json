[
    {
        "content": "<p>My question is based on a <a href=\"https://proofassistants.stackexchange.com/questions/2728/lean-and-inaccessible-cardinals\">question on PA.SE</a>.  The answer by <span class=\"user-mention\" data-user-id=\"119741\">@François G. Dorais</span> I think isn’t quite right and I wanted to continue the discussion here.  The original question by the OP is about whether there is a way to know if a theorem of Lean is true in ZFC.  I would like to ask a related question here about what if we restrict the number of universes used in a proof.</p>",
        "id": 422239958,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708351539
    },
    {
        "content": "<p>I think two simplifying assumptions would help.  First, let’s restrict ourselves to statements of first-order arithmetic since that is unambiguous (but still really expressive).  If we are doing that then obviously we can’t (easily) know if a theorem is compatible with ZFC by the form of a statement alone, since we can encode statements like <code>Con(ZFC)</code> into arithmetic.</p>",
        "id": 422239972,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708351544
    },
    {
        "content": "<p>So my second assumption is that I’m talking about restricting universes not in the theorem statements themselves, but <em>in the proofs</em>. I know from another thread (<a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general/topic/Highest.20universe.20in.20mathlib\">#general &gt; Highest universe in mathlib</a>) that we can count this sort of thing (and no more than something like 4 levels are ever used in Mathlib).  Also, I know that Lean’s set-theoretic interpretation (from <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>) is something like each <code>Type u</code> is a Grothendieck universe.  So does this mean if we have an arithmetic theorem with a proof that only uses one universe level (which we could measure with a linter or with a command analogous to <code>#print_axioms</code>), <em>then it holds in ZFC plus one inaccessible cardinal?</em></p>",
        "id": 422239990,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708351549
    },
    {
        "content": "<p>The tricky bit is formalizing what it means to use one universe level, and I could easily imagine there are a few options.  For example, it is not clear how to handle polymorphic types like <code>List: Type u -&gt; Type u</code> when counting universe levels.  While <code>List.{0}</code> is in <code>Type 1</code> it might be that if it is used in a certain syntactic way (like a proper class in set theory), then I wouldn’t necessarily count as a universe bump.</p>",
        "id": 422240024,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708351560
    },
    {
        "content": "<p>Also, I could imagine an off-by-one error in my estimates where theorems using only one universe level need two inaccessible cardinals or something like that.</p>",
        "id": 422240070,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708351564
    },
    {
        "content": "<p><em>But if this does hold, could you formalize what it means to use no universes in a proof?  Then would such a theorem hold in ZFC?</em></p>",
        "id": 422240108,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708351569
    },
    {
        "content": "<p>Anyway, I’m not sure there are fully worked-out answers here, but is there something to this line of logic, or am I fundamentally confused?</p>",
        "id": 422240113,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708351571
    },
    {
        "content": "<p>I believe you are broadly correct. If a proof is conducted using <code>n</code> universes, then it holds in <code>ZFC</code> with <code>n</code> inaccessible cardinals, up to a bit of fencepost error</p>",
        "id": 422240573,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708351706
    },
    {
        "content": "<p>this is proved in my thesis</p>",
        "id": 422240609,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708351718
    },
    {
        "content": "<p>As you say, there are complications in counting exactly when a universe bump occurs, because when you truncate the theory various type theoretic properties fail to hold like \"every type has a type\". I believe this is not actually the right way to do the truncation, and I make some intimations in this direction in the thesis: rather than throwing away the higher universes entirely, you use strong limit cardinals instead of inaccessible cardinals for them. These can be proved to exist in ZFC, they just aren't closed under inductive types and Pi types. Lacking Pi types is a bit of a problem though so hopefully there is a better choice of truncation that only lacks inductive types, which I think is quite reasonable to count.</p>",
        "id": 422241390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708351954
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> do you remember that code you wrote in Lean 3 which convinced us all that some random statement about the empty set required 5 universes? That discussion convinced me that <em>in practice</em> it might be extremely difficult to convince anyone that a random theorem of mathlib was a theorem of ZFC. I never understood that empty set example.</p>",
        "id": 422250869,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708354809
    },
    {
        "content": "<p>it's linked above</p>",
        "id": 422250943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708354830
    },
    {
        "content": "<p>Note that that calculation was using a rather naive/obvious definition of universe, which has a drawback that very silly things can bump universes. What i mean by my post just above is that there should be a better way to count universes which gives lower numbers in common cases, ideally 0</p>",
        "id": 422251380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708354948
    },
    {
        "content": "<p>But it's fair to say that this is in the \"open research question\" category</p>",
        "id": 422251458,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708354971
    },
    {
        "content": "<p>Can we get this working in lean 4 so we can get to the bottom of why mathlib needs 5 universes whereas it \"clearly all works in ZFC\"?</p>",
        "id": 422252807,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708355342
    },
    {
        "content": "<p>I'll put it on my stack of projects :)</p>",
        "id": 422253047,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708355407
    },
    {
        "content": "<p>I've always wanted to get to the bottom of this!</p>",
        "id": 422259755,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708357351
    },
    {
        "content": "<p>The question here is a bit different from the SE question. Still, my argument there is about the impredicativity of <code>Prop</code> and this is relevant here too.</p>\n<p>Were there no impredicative <code>Prop</code>, then every <code>Type n</code> would have its own <code>Prop n</code> (as subsingletons, hProps or whatever) and it is true that \"provable in ZFC\" would amount to \"true in <code>Prop 0</code>\" (±epsilon). Given a model S of ZFC + there is a 17-correct sequence + there are no 18-correct sequences (n-correctness is defined in Mario's MS thesis, 17 is just to get above Mathlib's experimental limit with room to spare). Using S, I can try to carry out the set-theoretic interpretation from Mario's thesis (ignoring things about <code>Prop</code> but all universes are classical so that doesn't matter). That will get me through to some level, say 8 to leave even more wiggle room, where everything is sound and nice. I can then build a model of Lean with no impredicative <code>Prop</code> using these 8 levels and making all higher universes trivial (i.e. every type is inhabited). This is fine since universes 0-8 are protected from universes 9 and up by a predicativity barrier that prevents things from higher universes to trickle down.</p>\n<p>That doesn't work with an impredicative <code>Prop</code> since that forces all universe levels to have the same propositions: if one universe level is trivial then they are all trivial. That is why I answered <code>No</code> on SE.  The question posed here is more precise. If you have a proof of an arithmetical statement that doesn't use universes above 8, can that be translated in to a proof in ZFC + there is a 17-correct sequence? Yes, most likely, this is exactly what my hand wavy construction above proves modulo all the nontrivial stuff I swept under the rug. (Note that the construction can be fitted with a <code>Prop</code> which is impredicative up to level 8, which helps with the nontrivial stuff.)</p>\n<p>Can Lean actually be used this way? Maybe Mario knows better but I don't think so. I think the kernel has some uses of impredicativity that can't be effectively measured.</p>",
        "id": 422288158,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708367228
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119741\">@François G. Dorais</span>  I have to admit I don’t understand your argument about impredictivity, or even what you are arguing.  Are you suggesting that Lean with say 8 universes can prove <code>Con…Con(ZFC)</code> for any number of <code>Con</code>?  (I don’t understand n-correctness but I assume it is similar.)  If so that seems to violate what <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> said above.  Are you saying that impredictivity can somehow be used to do hidden universe jumping which is not easily measured by the kernel.</p>\n<p>Or am I still totally misunderstanding you? Honestly I can’t even tell if you disagree with the statement that if one measures at most n universe jumps used in a Lean proof (of say an arithmetic theorem) then that theorem holds in ZFC plus n + k inaccessible cardinals for some constant k.  That seems to be what Mario is suggesting.</p>\n<p>(I’m also a bit confused by your statements about universes having the same propositions.  Prop only has two elements.  But that is probably just confusion on my part.)</p>",
        "id": 422293616,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708370312
    },
    {
        "content": "<p>Our are you saying there is something special about small numbers of universe levels (which show that the constant k has to be greater than 0), so we can’t get exactly ZFC + 0 innaccessibles?</p>",
        "id": 422294289,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708370669
    },
    {
        "content": "<p>I think there is some fundamental misunderstanding, I'm not sure how to pinpoint it. In my predicative universes example, universes 9 and up have only one truth value while universes 0-8 have two. This is how inconsistency manifests itself in type theories. Having an impredicative <code>Prop</code> forces all universes to have the same propositions.</p>",
        "id": 422295216,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708371193
    },
    {
        "content": "<p>Why do you need to consider models where there are trivial universes?  They are not models of the fragment of Lean I’m talking about.  I’m talking about the fragment of Lean with only n universes (not n nontrivial universes)?  I agree having higher universes changes which props are true (just like adding inaccessible cardinals to ZFC changes which theorems of arithmetic are true).</p>",
        "id": 422296131,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708371714
    },
    {
        "content": "<p>I get the impression that at least in the original question, you were focusing on if there was a way to tell if a theorem was provable in ZFC from the statement of the theorem, and I interpreted the question that you can look at the proof too.</p>",
        "id": 422296758,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708372025
    },
    {
        "content": "<p>I agree, if you look at a proof then you can see if it is formalizable in ZFC. This is regularly done with paper proofs, for example. But Lean's type theory has two features: proof irrelevance and impredicative propositions. The first prevents you to equate theorems and proofs, which is fine if you're looking at a specific proof rather than the existence of a proof. The second erases type levels when it comes to propositions: this is significant since the kernel might use a thousand universe levels without telling you about it.</p>",
        "id": 422297717,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708372533
    },
    {
        "content": "<p>Ok, so you are saying that type checking may hide universe levels, so possibly Mario’s approach to measuring universe levels misses universe bumps which happen during type checking.  That is interesting and I am curious if Mario agrees.</p>",
        "id": 422298272,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708372836
    },
    {
        "content": "<p>(I think we now understand each other more or less.)</p>",
        "id": 422298360,
        "sender_full_name": "Jason Rute",
        "timestamp": 1708372891
    },
    {
        "content": "<p>I'm also curious about that. I suspect nothing bad happens out of the box but I'm not sure once you throw in user stuff into the mix.</p>",
        "id": 422299378,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708373506
    },
    {
        "content": "<p>The problem with truncating to n universes with an axe is that some terms go untyped. That's why I extended my model with trivial universes. These are fictional type theories anyway so there is no point arguing about fine details. I think my version is basically the same as yours.</p>",
        "id": 422300626,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708373814
    },
    {
        "content": "<p>Another thing: </p>\n<blockquote>\n<p>(I’m also a bit confused by your statements about universes having the same propositions. Prop only has two elements. But that is probably just confusion on my part.)</p>\n</blockquote>\n<p>The fact that Prop has only two elements is itself a proposition. There is in fact no such restriction! So long as Prop is a Boolean algebra this is valid. There are plenty of Boolean algebras with more than two elements. Logically this is a non-issue, so long as you have a flexible mindset to allow Boolean valued models or if you believe in ultrafilters.</p>",
        "id": 422303570,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708374831
    },
    {
        "content": "<p>I think the easiest way to conceptualize what it means to truncate the type theory is to say that the kernel will throw an error when it ever sees or attempts to construct <code>Sort n</code> where <code>n &gt; 18</code>. In fact, lean's kernel actually does this (for a larger limit, I think around 2^21), because it's implemented in a computer and there are a finite number of representable universes. Under this constraint, if the kernel typechecks the theorem and proof, then the proof was performed \"using only 18 universes\", and it will be provable in ZFC with 18 inaccessible cardinals.</p>",
        "id": 422316404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708382708
    },
    {
        "content": "<p>Whether the statement is arithmetic or not makes no difference here. There are no \"multiple Props\" in the model I describe; there is one Prop and it has two elements. This is necessary to model impredicative Prop correctly, and even with only 18 universes lean is still impredicative. You can't prove Con(ZFC+20 inaccessibles) in lean with 18 universes, but you can state it.</p>",
        "id": 422316567,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708382795
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Theory.20of.20Lean.20with.20n.20universes/near/422303570\">said</a>:</p>\n<blockquote>\n<p>Another thing: </p>\n<blockquote>\n<p>(I’m also a bit confused by your statements about universes having the same propositions. Prop only has two elements. But that is probably just confusion on my part.)</p>\n</blockquote>\n<p>The fact that Prop has only two elements is itself a proposition. There is in fact no such restriction! So long as Prop is a Boolean algebra this is valid. There are plenty of Boolean algebras with more than two elements. Logically this is a non-issue, so long as you have a flexible mindset to allow Boolean valued models or if you believe in ultrafilters.</p>\n</blockquote>\n<p>No, you can prove in lean that Prop has exactly two elements, so in order to have a more general boolean algebra for Prop you would need equality to mean something other than ZFC equality, and if you do that then defining substitution becomes harder. It may be possible but it significantly changes the character of the theory, to something more like a HoTT model.</p>",
        "id": 422316794,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708382927
    },
    {
        "content": "<p>I've never really given much thought to \"predicative Lean\" or what properties it has, because the model theory of predicative type theories is quite different and weaker, we probably wouldn't be talking ZFC at all (even with the universes) but rather a subsystem of second order logic.</p>",
        "id": 422317593,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708383339
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Theory.20of.20Lean.20with.20n.20universes/near/422316794\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Theory.20of.20Lean.20with.20n.20universes/near/422303570\">said</a>:</p>\n<blockquote>\n<p>Another thing: </p>\n<blockquote>\n<p>(I’m also a bit confused by your statements about universes having the same propositions. Prop only has two elements. But that is probably just confusion on my part.)</p>\n</blockquote>\n<p>The fact that Prop has only two elements is itself a proposition. There is in fact no such restriction! So long as Prop is a Boolean algebra this is valid. There are plenty of Boolean algebras with more than two elements. Logically this is a non-issue, so long as you have a flexible mindset to allow Boolean valued models or if you believe in ultrafilters.</p>\n</blockquote>\n<p>No, you can prove in lean that Prop has exactly two elements, so in order to have a more general boolean algebra for Prop you would need equality to mean something other than ZFC equality, and if you do that then defining substitution becomes harder. It may be possible but it significantly changes the character of the theory, to something more like a HoTT model.</p>\n</blockquote>\n<p>Exactly! Which equality is actual equality in the model. There are several notions of equality in Lean. Syntactic equality is one but it's not part of the internal language. Propositional equality is in the language. Actual equality is not in the language and not expressible in it. So long as I have a model where <code>∀ (p : Prop), p = True ∨ p = False</code> is <code>True</code> then everything is fine. For example, Lean^2 where two classical Leans are working independently and in parallel from each other is a perfectly fine model of Lean. However, there are actually four truth values in this Boolean valued model.</p>",
        "id": 422318110,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708383594
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Theory.20of.20Lean.20with.20n.20universes/near/422293616\">said</a>:</p>\n<blockquote>\n<p>Are you suggesting that Lean with say 8 universes can prove <code>Con…Con(ZFC)</code> for any number of <code>Con</code>?  (I don’t understand n-correctness but I assume it is similar.)</p>\n</blockquote>\n<p>n-correctness is just saying that if we have 8 inaccessibles we can put them in a line and then fill in the rest of the line with weak universes which still have the same basic structural properties but aren't full universes closed under all the operation they should be. Existence of an n-correct sequence is equivalent to existence of n inaccessible cardinals over ZFC.</p>\n<p>Lean with 8 universes can indeed prove Con...Con(ZFC) but that's because it can construct a model of ZFC. This is true even with only 1 universe, or in ZFC + 1 inaccessible. Iterating Con is a very weak way of growing the consistency strength, adding an inaccessible goes past all of them. But maybe what you wanted to ask, can lean with 8 universes prove Con(ZFC + n inaccessibles) for n &gt; 8? In which case the answer is no, because ZFC with 8 inaccessibles can prove the consistency of lean with 8 universes.</p>",
        "id": 422318582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708383808
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119741\">@François G. Dorais</span> Yes, you can paste independent models together but then there isn't any equality that corresponds to actual equality in the model. You can also make some elements be doubled in a way that no set picks out. I don't think these are particularly interesting changes to the model though. I think this is a bit different from \"there are no restrictions other than Prop being a boolean algebra\", because you had to clone all of the rest of the model in parallel to what you did to Prop.</p>",
        "id": 422319200,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708384168
    },
    {
        "content": "<p>Also, for boolean algebras other than 2^A I don't know what you would do to the rest of the model to ensure only the representable elements appear as elements of Prop</p>",
        "id": 422319389,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708384285
    },
    {
        "content": "<p>As I said earlier: Logically this is a non-issue, so long as you have a flexible mindset to allow Boolean valued models or if you believe in ultrafilters.</p>",
        "id": 422319547,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708384402
    },
    {
        "content": "<p>I don't believe you, Lean is a type theory not a FOL so you can't just reduce everything to propositions with boolean values. Maybe you can do it but it's not at all obvious and there will be many subtleties</p>",
        "id": 422319655,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708384490
    },
    {
        "content": "<p>The model in my thesis takes as a \"simplifying assumption\" that equality in ZFC, equality in lean, and defeq in lean are all made equivalent. This model validates the equality reflection rule as a result</p>",
        "id": 422319704,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708384535
    },
    {
        "content": "<p>But my thesis is not really a model theory paper, I did not consider the full spectrum of possible models, only a few models that have useful properties (in particular existence). If you would like to write one I'll be interested to read it</p>",
        "id": 422319947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708384726
    },
    {
        "content": "<p>There is nothing wrong with your thesis! It's a wonderful work! I'm pointing out that the \"simplifying assumptions\" (your words, I don't think they simplify much!) can be relaxed to reveal more models with interesting properties.</p>\n<p>That said, my original comment explores a theoretical version of Lean with no impredicative Prop. I never had any intent to make that version real. Lean is perfectly fine with an impredicative Prop and that is fully compatible with the usual two-valued Prop model that everyone loves.</p>",
        "id": 422320620,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708385237
    },
    {
        "content": "<blockquote>\n<p>I'm pointing out that the \"simplifying assumptions\" (your words, I don't think they simplify much!) can be relaxed to reveal more models with interesting properties.</p>\n</blockquote>\n<p>I'm aware of this, I'm saying that this would be another paper entirely and without going to the effort I'm not going to make claims in this area because I'm not sure it's as simple as just replacing 2 by B and getting a BVM out</p>",
        "id": 422320725,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708385331
    },
    {
        "content": "<p>I agree. I don't think anyone was pressing you to do this. If anyone appeared to do that, I'm sure it was a misunderstanding or an error of some kind.</p>",
        "id": 422320985,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708385534
    },
    {
        "content": "<p>I'm not saying that either. Until someone (including possibly me) writes that paper and I read it I don't believe blanket claims that you can BVM-ize the model straightforwardly. I do believe it in the case where you just construct Lean^A in the manner you described, this is a weaker statement though</p>",
        "id": 422321130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708385657
    },
    {
        "content": "<p>Sorry, what does BVM-ize mean?</p>",
        "id": 422321189,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708385728
    },
    {
        "content": "<p>make a boolean valued model from a classical model construction</p>",
        "id": 422321201,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708385757
    },
    {
        "content": "<p>Ah! That's not what I tried to say. I pointed out that Lean naturally allows some Boolean valued models, not the other way around.</p>",
        "id": 422321336,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708385875
    },
    {
        "content": "<p>I have no idea what the spectrum of Lean models actually is.</p>",
        "id": 422321410,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708385933
    },
    {
        "content": "<p>me neither, hence the skepticism</p>",
        "id": 422321426,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708385955
    },
    {
        "content": "<p>I think we're in agreement. Sorry for the confusion.</p>",
        "id": 422321523,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708386028
    },
    {
        "content": "<p>but maybe this is getting off topic of Jason's original question. I would be interested to know your answers to Jason's questions to you above, to the extent they apply to (impredicative) Lean</p>",
        "id": 422321559,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708386077
    },
    {
        "content": "<p>Which questions specifically? It's getting a bit late and I'm losing track of this long thread. I'm always happy to clarify and answer questions.</p>",
        "id": 422321737,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708386236
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Theory.20of.20Lean.20with.20n.20universes/near/422288158\">said</a>:</p>\n<blockquote>\n<p>The question posed here is more precise. If you have a proof of an arithmetical statement that doesn't use universes above 8, can that be translated in to a proof in ZFC + there is a 17-correct sequence? Yes, most likely, this is exactly what my hand wavy construction above proves modulo all the nontrivial stuff I swept under the rug. (Note that the construction can be fitted with a <code>Prop</code> which is impredicative up to level 8, which helps with the nontrivial stuff.)</p>\n<p>Can Lean actually be used this way? Maybe Mario knows better but I don't think so. I think the kernel has some uses of impredicativity that can't be effectively measured.</p>\n</blockquote>\n<p>What aspect of this are you unsure about? We are not \"measuring impredicativity\" in any sense, and the stuff about predicative universes (edited out since it is mostly irrelevant to impredicative lean) doesn't clarify this point.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Theory.20of.20Lean.20with.20n.20universes/near/422297717\">said</a>:</p>\n<blockquote>\n<p>I agree, if you look at a proof then you can see if it is formalizable in ZFC. This is regularly done with paper proofs, for example. But Lean's type theory has two features: proof irrelevance and impredicative propositions. The first prevents you to equate theorems and proofs, which is fine if you're looking at a specific proof rather than the existence of a proof. The second erases type levels when it comes to propositions: this is significant since the kernel might use a thousand universe levels without telling you about it.</p>\n</blockquote>\n<p>How might \"the kernel might use a thousand universe levels without telling you about it\"?</p>",
        "id": 422322225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708386625
    },
    {
        "content": "<p>To be clear, when I talk about a \"proof\" in lean (in this context, at least) I don't mean the inhabitant of a proposition, I mean the full typing derivation that the expression has the stated type. This is <em>mostly</em> just a copy of the input expression, but it differs when defeq conversion is triggered. Use of higher universes anywhere in a typing derivation \"counts\" against it being a proof in Lean with n universes.</p>",
        "id": 422322485,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708386889
    },
    {
        "content": "<p>The \"to be clear\" part really clarifies the discrepancy.</p>\n<p>I'm not thinking syntactically. It's pretty clear that (but not at all easy how) one could translate a Lean proof into a ZFC proof, or fail and perhaps explain why.</p>\n<p>I'm thinking semantically. There is no internal way to distinguish whether a statement requires level 1000 or not. For example, Con(ZFC) is provable in Lean. This is an arithmetical statement which doesn't require more than Type 0 to state. Because Type 1 exists and there is a model of ZFC in Type 1, that arithmetical statement is true. Because <code>Prop</code> is impredicative, this statement is true at all levels of the hierarchy. Impredicativity of <code>Prop</code> not only requires that all levels have the same <code>Prop</code> but also that the interpretations match. So Con(ZFC) is necessarily true in <code>Type 0</code> and there must therefore be a model of ZFC in <code>Type 0</code> (not the same one as in <code>Type 1</code>, probably one constructed using the Henkin method). That this model exists in <code>Type 0</code> entails Con(ZFC). There is no connection  with this model to <code>Type 1</code>, it just works in<code>Type 0</code>!</p>",
        "id": 422324270,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708388246
    },
    {
        "content": "<p>Provability is a syntactic notion, not a semantic one. Truth in a model is a semantic notion but you can cook up models which satisfy only the consistency statements you want by tweaking the metatheory</p>",
        "id": 422324424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708388382
    },
    {
        "content": "<blockquote>\n<p>For example, Con(ZFC) is provable in Lean. This is an arithmetical statement which doesn't require more than Type 0 to state. Because Type 1 exists and there is a model of ZFC in Type 1, that arithmetical statement is true.</p>\n</blockquote>\n<p>That is to say, any proof of Con(ZFC) in lean is going to go through a lemma which is \"Type 1 exists\", so syntactically I can see this in the proof, and semantically if I have a truncated model which fails this then it will also fail when trying to access Type 1 because Type 1 doesn't exist in the model (or exists and doesn't have all the properties of a universe)</p>",
        "id": 422324632,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708388524
    },
    {
        "content": "<p>If you don't believe in completeness and soundness, then I'm afraid we have nothing else to talk about in this thread.</p>",
        "id": 422324662,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708388541
    },
    {
        "content": "<p>I'm not sure how you gathered that from what I said</p>",
        "id": 422324688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708388561
    },
    {
        "content": "<p>but note that Lean is not complete for the model in my thesis</p>",
        "id": 422324721,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708388595
    },
    {
        "content": "<p>The first sentence?</p>",
        "id": 422324727,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708388604
    },
    {
        "content": "<p>That's just a fact. Proof is syntactic, truth in a model is semantic. Soundness and completeness are two ways to connect between these two notions</p>",
        "id": 422324796,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708388645
    },
    {
        "content": "<p>What do you think completeness means?</p>",
        "id": 422324824,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708388685
    },
    {
        "content": "<p>that everything which is true in a model or class of models is provable in the theory</p>",
        "id": 422324848,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708388706
    },
    {
        "content": "<p>Exactly.</p>",
        "id": 422324882,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708388746
    },
    {
        "content": "<p>Completeness is a property that may or may not hold when you vary the theory and the class of models</p>",
        "id": 422324953,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708388779
    },
    {
        "content": "<p>Model theoretic reasoning is sound, so long as you consider all models.</p>",
        "id": 422324966,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708388795
    },
    {
        "content": "<p>for the case of lean and the standard model of lean, it doesn't hold</p>",
        "id": 422324967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708388796
    },
    {
        "content": "<p>I am not just considering the standard model. I am reasoning inside any model.</p>",
        "id": 422325018,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708388845
    },
    {
        "content": "<p>there might be some class of lean models for which completeness holds but it would have to include some quite exotic models to falsify all the things which are independent in lean. This is starting to get back to that point of \"we don't have a model theory paper on lean\"</p>",
        "id": 422325039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708388872
    },
    {
        "content": "<p>and in any case it's irrelevant to the point</p>",
        "id": 422325091,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708388889
    },
    {
        "content": "<p>Do you disagree that in any model of Lean (the whole thing) the arithmetic statement \"Con(ZFC)\" is true?</p>",
        "id": 422325149,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708388962
    },
    {
        "content": "<p><del>yes</del> I do not disagree with that</p>",
        "id": 422325159,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708388972
    },
    {
        "content": "<p>Do you believe the Henkin construction can be formalized in Lean using only <code>Type 0</code>?</p>",
        "id": 422325293,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708389038
    },
    {
        "content": "<p>I don't know what you mean by that. It's not directly applicable</p>",
        "id": 422325319,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708389063
    },
    {
        "content": "<p>again, because Lean isn't a FOL</p>",
        "id": 422325355,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708389095
    },
    {
        "content": "<p>ZFC is a FOL.</p>",
        "id": 422325375,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708389112
    },
    {
        "content": "<p>do you mean the Henkin construction of FOL being formalized in lean?</p>",
        "id": 422325459,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708389151
    },
    {
        "content": "<p>Sure I guess, not sure why you want to do metatheory in lean now though</p>",
        "id": 422325490,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708389174
    },
    {
        "content": "<p>So you believe there is a model of ZFC in <code>Type 0</code>?</p>",
        "id": 422325500,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708389181
    },
    {
        "content": "<p>I don't think the question is well formed</p>",
        "id": 422325517,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708389195
    },
    {
        "content": "<p>If you mean in (full) lean, then yes</p>",
        "id": 422325534,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708389211
    },
    {
        "content": "<p>but in the truncated model of lean, or the truncated type theory of lean to 0 universes, no</p>",
        "id": 422325566,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708389242
    },
    {
        "content": "<p>So, using only objects in <code>Type 0</code>, I can establish Con(ZFC)?</p>",
        "id": 422325637,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708389271
    },
    {
        "content": "<p>Depends on what you mean by \"using\", but probably no</p>",
        "id": 422325659,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708389301
    },
    {
        "content": "<p>(In full Lean.)</p>",
        "id": 422325670,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708389308
    },
    {
        "content": "<p>still depends on what you mean by \"using\"</p>",
        "id": 422325689,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708389326
    },
    {
        "content": "<p>How can you tell whether that model came from higher reasoning or not? It's in <code>Type 0</code>.</p>",
        "id": 422325720,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708389358
    },
    {
        "content": "<p>you are going to be hard-pressed to come up with a proof that does not involve constructing <code>Type 0</code> in the course of the proof</p>",
        "id": 422325774,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708389371
    },
    {
        "content": "<p>Yes, I'm not thinking about proofs. I'm working in _any_ model of Lean.</p>",
        "id": 422325828,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708389429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Theory.20of.20Lean.20with.20n.20universes/near/422325720\">said</a>:</p>\n<blockquote>\n<p>How can you tell whether that model came from higher reasoning or not? It's in <code>Type 0</code>.</p>\n</blockquote>\n<p>The proof that it satisfies the axioms of ZFC <em>will</em> make use of properties of inductive types inside Type 0 and quantifications that are not valid in the truncated model</p>",
        "id": 422325838,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708389440
    },
    {
        "content": "<p>So, in _any_ model of Lean, I claim there exists an object in <code>Type 0</code> which is a model of ZFC. I think we've established that.</p>",
        "id": 422325990,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708389566
    },
    {
        "content": "<p>So, by completeness...</p>",
        "id": 422326061,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708389606
    },
    {
        "content": "<p>the exact details of this relate to how the truncation is performed, but for example we might have that <code>Type 0</code> does not have all inductive types, and in particular does not have the <code>pSet</code> inductive type; or maybe it's proper-class like and doesn't admit higher order quantification above a certain level</p>",
        "id": 422326078,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708389615
    },
    {
        "content": "<p>I'm not talking about the proof. We already discussed that point.</p>",
        "id": 422326117,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708389656
    },
    {
        "content": "<p>You keep talking about full lean, but the point here is that the semantic analogue of the syntactic proof theory of \"lean with n universes\" is \"the truncated model with n universes\", that is, an n-correct model instead of an omega-correct model</p>",
        "id": 422326161,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708389693
    },
    {
        "content": "<p>Sure, if you restrict the type theory, then I won't be able to prove some things.</p>",
        "id": 422326186,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708389718
    },
    {
        "content": "<p>and in this model various parts of the proof you are trying to conduct will be false</p>",
        "id": 422326234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708389726
    },
    {
        "content": "<p>in particular the final theorem, but also many of the statements leading up to it</p>",
        "id": 422326253,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708389749
    },
    {
        "content": "<p>Which theorems? The Henkin construction is really basic, so is the soundness theorem.</p>",
        "id": 422326320,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708389824
    },
    {
        "content": "<p>I'm just using the fact that Con(ZFC) is true.</p>",
        "id": 422326381,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708389855
    },
    {
        "content": "<p>That's an arithmetic statement.</p>",
        "id": 422326392,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708389868
    },
    {
        "content": "<p>Is it okay if I add n inaccessibles to that statement? Things are a bit clearer with some wiggle room</p>",
        "id": 422326443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708389911
    },
    {
        "content": "<p>Con(ZFC + 18 inaccessibles) is not true in a metatheory of ZFC with no inaccessibles</p>",
        "id": 422326542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708389975
    },
    {
        "content": "<p>That would be weird. Not sure why you would want to do that. What are you getting at?</p>",
        "id": 422326570,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708390008
    },
    {
        "content": "<p>and if I have a construction of a 0-correct lean model in that metatheory, Con(ZFC + 18 inaccessibles) will still not be true</p>",
        "id": 422326583,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708390020
    },
    {
        "content": "<p>(having an n to play with there makes it really obvious which statements are weak and which are strong)</p>",
        "id": 422326616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708390064
    },
    {
        "content": "<p>Why are you insisting on building Lean models? I don't get it.</p>",
        "id": 422326694,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708390097
    },
    {
        "content": "<p>Didn't you want to go the semantic route?</p>",
        "id": 422326708,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708390113
    },
    {
        "content": "<p>I'm saying that there exists a (truncated) lean model in which Con(ZFC + n inaccessibles) is false</p>",
        "id": 422326745,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708390152
    },
    {
        "content": "<p>That doesn't mean building models. What model do you want to build and why?</p>",
        "id": 422326757,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708390163
    },
    {
        "content": "<p>even though it's an arithmetic statement which can be stated only using objects in Type 0</p>",
        "id": 422326764,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708390168
    },
    {
        "content": "<p>What is a truncated lean model? (There is no lean model where Con(ZFC + n inaccessibles) is false).)</p>",
        "id": 422326857,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708390231
    },
    {
        "content": "<p>An n-correct model</p>",
        "id": 422326864,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708390245
    },
    {
        "content": "<p>That's a notion in ZFC. I don't know what you mean.</p>",
        "id": 422326898,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708390280
    },
    {
        "content": "<p>This is defined in my paper, which in fact never works with omega-correct models, the main theorem is actually about n-correct models</p>",
        "id": 422326900,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708390284
    },
    {
        "content": "<p>What is a n-correct model of Lean?</p>",
        "id": 422326945,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708390321
    },
    {
        "content": "<p>You do the same construction as in the standard model but you use a sequence of cardinals that ceases to be inaccessible above n</p>",
        "id": 422327039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708390362
    },
    {
        "content": "<p>as a result, the higher universes are not closed under some operations</p>",
        "id": 422327087,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708390385
    },
    {
        "content": "<p>this is a model of \"lean with n universes\" because if you never use the higher universes then you never notice that they are kinda broken</p>",
        "id": 422327174,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708390447
    },
    {
        "content": "<p>That's sort of what I described above, no? That requires no impredicative <code>Prop</code> since the whole theory would collapse.</p>",
        "id": 422327251,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708390525
    },
    {
        "content": "<p>everything is impredicative here</p>",
        "id": 422327270,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708390543
    },
    {
        "content": "<p>the theory does not collapse, but maybe you mean something more specific</p>",
        "id": 422327327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708390565
    },
    {
        "content": "<p>Why do you have universes then?</p>",
        "id": 422327333,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708390571
    },
    {
        "content": "<p>?</p>",
        "id": 422327346,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708390581
    },
    {
        "content": "<p><code>Type</code> is predicative, of course, because <code>Type : Type</code> is inconsistent. But <code>Prop</code> is impredicative and I don't want to be sidetracked by discussing predicative <code>Prop</code></p>",
        "id": 422327432,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708390657
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Theory.20of.20Lean.20with.20n.20universes/near/422327251\">said</a>:</p>\n<blockquote>\n<p>That's sort of what I described above, no? That requires no impredicative <code>Prop</code> since the whole theory would collapse.</p>\n</blockquote>\n<p>You described a sequence of <code>Prop n</code> types, some of which have one element and others which have two. I am not describing anything like that, there is one <code>Prop</code> and it has two elements in all truncated models</p>",
        "id": 422327576,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708390794
    },
    {
        "content": "<p>So, in Type n+1 (or whatever) you can prove False is inhabited, so False is inhabited by impredicativity and this a fact at all levels.</p>",
        "id": 422327589,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708390801
    },
    {
        "content": "<p>Is that a claim about the model or the proof theory?</p>",
        "id": 422327653,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708390824
    },
    {
        "content": "<p>The proof theory.</p>",
        "id": 422327677,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708390846
    },
    {
        "content": "<p>In the proof theory, when you write down <code>Type n+1</code> the kernel says ERROR OVERFLOW</p>",
        "id": 422327694,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708390864
    },
    {
        "content": "<p>In the model <code>Type n+1</code> exists but is weird and doesn't act like the other universes. False is still sitting there at the bottom and uninhabited though</p>",
        "id": 422327735,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708390908
    },
    {
        "content": "<p>I have no idea what the kernel would say, but lean would be inconsistent so I wouldn't care much what it says.</p>",
        "id": 422327803,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708390930
    },
    {
        "content": "<p>No, ERROR OVERFLOW means the proof doesn't typecheck, so you didn't prove false</p>",
        "id": 422327822,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708390950
    },
    {
        "content": "<p>less dramatically, the proof is simply not well typed</p>",
        "id": 422327851,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708390970
    },
    {
        "content": "<p>So you're working in that \"type theory\" where typeworthy terms don't have types? I'm not sure what to do with that.</p>",
        "id": 422327898,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708391027
    },
    {
        "content": "<p>that's right</p>",
        "id": 422327908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708391036
    },
    {
        "content": "<p>There exist type theories with only a finite number of universes. Just think that we are working in one of those</p>",
        "id": 422327959,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708391046
    },
    {
        "content": "<p>usually you will have a <code>Gamma |- A type</code> judgment separate from <code>Gamma |- A : U</code> for typing the things at the top that have no type</p>",
        "id": 422327997,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708391090
    },
    {
        "content": "<p>or maybe <code>Gamma |- A : *</code> where <code>*</code> isn't a term</p>",
        "id": 422328038,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708391124
    },
    {
        "content": "<p>That's not what I was thinking about. I would rather have trivial higher universes and restricted impredicativity, but whatever.</p>",
        "id": 422328040,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708391125
    },
    {
        "content": "<p>I can play along so long as you're clear.</p>",
        "id": 422328071,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708391152
    },
    {
        "content": "<p>In this case, we are rather rudely just chopping off the top of the lean type system, so we just have the one judgment and there are types that don't have types near the top</p>",
        "id": 422328133,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708391168
    },
    {
        "content": "<p>That's what I called \"axe chopping\" earlier. It's kind of sketchy.</p>",
        "id": 422328170,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708391207
    },
    {
        "content": "<p>This is part of what I meant <a href=\"#narrow/stream/236446-Type-theory/topic/Theory.20of.20Lean.20with.20n.20universes/near/422241390\">earlier</a> about finessing this truncation process so that we don't lose \"every type has a type\" and instead lose less structurally important properties like \"every universe has inductive types\"</p>",
        "id": 422328221,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708391258
    },
    {
        "content": "<p>Yes, that's essentially equivalent to the predicative model I described before. I just don't think \"axe chopping\" as finesse <span aria-label=\"joking\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"joking\">:joking:</span></p>",
        "id": 422328351,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708391367
    },
    {
        "content": "<p>well no, the axe chopping is without the finesse</p>",
        "id": 422328370,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708391392
    },
    {
        "content": "<p>with the finesse you would be allowed to have <code>Type n</code> for every <code>n</code> in the proof theory, and every type would have a type</p>",
        "id": 422328440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708391433
    },
    {
        "content": "<p>they still wouldn't actually be modeled as inaccessible cardinals though</p>",
        "id": 422328479,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708391460
    },
    {
        "content": "<p>the part of the ZFC construction that would fail is the construction of the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PSet#doc\">docs#PSet</a> type</p>",
        "id": 422328508,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708391501
    },
    {
        "content": "<p>I don't think it's the same as the predicative model, there would still only be one <code>Prop</code> and indeed it would be not very obviously different from the usual lean</p>",
        "id": 422328663,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708391597
    },
    {
        "content": "<p>Yeah, i don't think we disagree here, these are hypothetical type theories. I'm not super interested in working out the details of what \"Lean_n\" ought to mean.</p>\n<p>I'm reaching the end of my useful hours here. Should we continue tomorrow?</p>",
        "id": 422328951,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1708391882
    },
    {
        "content": "<p>I think there may eventually be something useful to come out of a \"typechecker for Lean_n\" to practically address the issue of how to know whether your proof has been conducted in ZFC when it feels like it should have been</p>",
        "id": 422329095,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708391998
    },
    {
        "content": "<p>the finesse is important for this though, especially for n = 0</p>",
        "id": 422329201,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708392048
    }
]