[
    {
        "content": "<p>I have some basic questions about the cardinality of types. I have come across a claim from Kevin many times on zulip that one can only prove inequality of types if they have different cardinality and also that you can't prove <code>\\N \\neq \\Z</code>.  Firstly how is the concept of cardinality defined for types? Are types considered to have the same cardinality if they one can show some bijection between them? If so then wouldn't a proof that there is no surjective map from \\N to \\Z prove that the two types are not equal since they don't have a bijection?</p>",
        "id": 422969911,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1708676955
    },
    {
        "content": "<p>There is a surjection from ℕ to ℤ: the even numbers map to their half, the odd ones to the negative of one half their predecessor.</p>",
        "id": 422970997,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708677491
    },
    {
        "content": "<p>Oh right</p>",
        "id": 422971025,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1708677510
    },
    {
        "content": "<p>How silly of me. Both are countable sets</p>",
        "id": 422971065,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1708677540
    },
    {
        "content": "<p>But yes, a proof of a bijection between two types is probably equivalent to the undecidability of the equality of the two types.</p>",
        "id": 422971086,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708677554
    },
    {
        "content": "<p>I have a hunch that cardinality would be defined w.r.t some set theoretic model. Because in some models Z could very well be considered equal to N and in others, not so.</p>",
        "id": 422971986,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1708677996
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 422972345,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1708678162
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Cardinality.20of.20types/near/422971086\">said</a>:</p>\n<blockquote>\n<p>But yes, a proof of a bijection between two types is probably equivalent to the undecidability of the equality of the two types.</p>\n</blockquote>\n<p>It's not equivalent because sometimes they are equal (eg a type bijects with itself)</p>",
        "id": 422977599,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708680006
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Cardinality.20of.20types/near/422977599\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Cardinality.20of.20types/near/422971086\">said</a>:</p>\n<blockquote>\n<p>But yes, a proof of a bijection between two types is probably equivalent to the undecidability of the equality of the two types.</p>\n</blockquote>\n<p>It's not equivalent because sometimes they are equal (eg a type bijects with itself)</p>\n</blockquote>\n<p><span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span> indeed.</p>",
        "id": 422978610,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708680330
    },
    {
        "content": "<p>Mario explained this (the undecidability part) to me <a href=\"#narrow/stream/113489-new-members/topic/Equality.20with.20Types/near/422594504\">here</a>.</p>",
        "id": 422978814,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708680386
    },
    {
        "content": "<p>Are you aware of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Cardinal#doc\">docs#Cardinal</a> in mathlib?</p>",
        "id": 423028456,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708699193
    },
    {
        "content": "<blockquote>\n<p>Are types considered to have the same cardinality if they one can show some bijection between them?</p>\n</blockquote>\n<p>Because this is true by definition for <code>Cardinal.mk</code></p>",
        "id": 423028588,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708699225
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Cardinality.20of.20types/near/422977599\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/236446-Type-theory/topic/Cardinality.20of.20types/near/422971086\">said</a>:</p>\n<blockquote>\n<p>But yes, a proof of a bijection between two types is probably equivalent to the undecidability of the equality of the two types.</p>\n</blockquote>\n<p>It's not equivalent because sometimes they are equal (eg a type bijects with itself)</p>\n</blockquote>\n<p>I understood Damiano's statement to  mean that extensional equality of two types given as inputs is undecidable, as opposed to definitional equality, which a lot of type theories seem to want to keep decidable.</p>",
        "id": 423105866,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1708727883
    },
    {
        "content": "<p>Incidentally <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> , since you mentioned Rustbelt a few weeks ago, that's at the heart of the rustbelt approach. Instead of dealing with types as syntactic constructs, they model types as ....(sweeping some stuff under the carpet)... basically sets and/or logically defined relations. This means they lose decidability and have to manually prove a bunch of things that a typechecker would otherwise do automatically. But it helps recover the ability to reason about safely accessing \"unsafe\" data constructs. Iris abstracts over this.</p>",
        "id": 423106171,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1708728081
    }
]