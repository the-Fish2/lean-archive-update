[
    {
        "content": "<p>This PR makes it so that <code>f ^ n</code> is defeq to <code>f^[n]</code> for <code>f</code> an endomorphism (of different kinds, eg <code>Function.End</code>). <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> is worried that this will break defeqs with the categorical version of the constructions. Personally I think that Yury's complaint extends to literally any <code>Monoid</code> instance tweaking the <code>pow</code> defeq, meaning that if we followed his thought we might as well drop the <code>pow</code> field.</p>",
        "id": 440738142,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1716755417
    },
    {
        "content": "<p>Someone to tie-break?</p>",
        "id": 440738153,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1716755425
    },
    {
        "content": "<p>The <code>pow</code> field was introduced to resolve defeq issues for <code>nsmul</code>. Here it introduces defeq issue (<code>Monoid</code> instances on <code>Function.End α</code> and <code>α ⟶ α</code> will be no longer defeq).</p>",
        "id": 440739348,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1716756708
    },
    {
        "content": "<p>I think that we should hear from someone who actually uses Mathlib category theory library before making a decision here.</p>",
        "id": 440739414,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1716756749
    },
    {
        "content": "<p>I don't think having non-defeq instances on defeq types is a huge problem? In fact the mul instance on <code>α → α</code> is actually radically different from these:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 440741193,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1716758397
    },
    {
        "content": "<p>I'm a bit worried that these instances are propeq but aren't defeq (so, I'm not ready to merge this PR myself) but I'm OK if another maintainer decides that it's OK.</p>",
        "id": 440745449,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1716762201
    },
    {
        "content": "<p>Just a note for other zulip on-lookers: the  <code>α ⟶ α</code> in Yury's message is the categorical Hom, in the category of types. It is not (syntactically) the function type. The arrow can be hard to distinguish on Zulip.</p>\n<p>I personally would be happy if all the instances on <code>X ⟶ Y</code> are defeq to those on <code>X → Y</code>. (And similar for <code>MonoidHom X Y</code> and <code>X ⟶ Y</code> in the category of monoids/groups/etc.)</p>\n<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> Do you have an opinion on this one?</p>",
        "id": 440781676,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1716790528
    },
    {
        "content": "<p>My impression was that category theory already gives up on defeq in a bunch of places (notably around <code>nsmul</code>)</p>",
        "id": 440824475,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1716805571
    },
    {
        "content": "<p>In some cases, defeq can't be recovered (e.g., for the <code>ModuleCat Int -&gt; AddCommGroupCat -&gt; ModuleCat Int</code> round-trip). In other cases, it can. I don't know what are design decisions made by the category theory team, so I think that we should ask them. BTW, should we create <code>@</code> tags for <code>t-*</code> github labels and ask people which of them they want to join?</p>",
        "id": 440878447,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1716824106
    },
    {
        "content": "<p>Can you remind me why it can't be recovered in that example? That is indeed the one I was thinking of.</p>",
        "id": 440890212,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1716828792
    },
    {
        "content": "<p>Because the first arrow has to work for <code>ModuleCat R -&gt; AddCommGroupCat</code>, thus can't rely on <code>R = Int</code> (or <code>R = Nat</code>) for <code>zsmul</code>/<code>nsmul</code>.</p>",
        "id": 440903954,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1716835638
    },
    {
        "content": "<p>It can rely on <code>Nat.cast : ℕ → R</code> and <code>Int.cast : ℤ → R</code>, right? That does make it roundtrip.</p>",
        "id": 440905466,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1716836438
    },
    {
        "content": "<p>Probably, you're right. Let's wait for people from category theory team.</p>",
        "id": 440905809,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1716836634
    },
    {
        "content": "<p>I think that the composition will not recover the defeq of <code>smul</code>. The first arrow is forgetful, but the second arrow will put <code>smul := zsmul</code>, which doesn't have to be defeq to the <code>smul</code> that we started with on the left.</p>",
        "id": 440907124,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1716837261
    },
    {
        "content": "<p>The first arrow can put <code>zsmul n a := (n : R) • a</code></p>",
        "id": 440907288,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1716837352
    },
    {
        "content": "<p>Same for <code>nsmul</code></p>",
        "id": 440907354,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1716837370
    },
    {
        "content": "<p>Then you've lost the <code>zsmul</code> that came from the left.</p>",
        "id": 440907413,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1716837411
    },
    {
        "content": "<p>I see.</p>",
        "id": 440908409,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1716837911
    },
    {
        "content": "<p>One solution is to throw away the category <code>AddCommGroupCat</code>, and just use <code>ModuleCat Int</code> everywhere.</p>",
        "id": 440908699,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1716838080
    },
    {
        "content": "<p>Possibly via <code>abbrev Ab := ModuleCat Int</code>, with some special constructor.</p>",
        "id": 440908778,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1716838101
    },
    {
        "content": "<p>But I guess <code>to_additive</code> will not like that.</p>",
        "id": 440908807,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1716838129
    },
    {
        "content": "<p>Then you get two non-defeq <code>SMul Nat G</code> instances</p>",
        "id": 440912980,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1716840287
    },
    {
        "content": "<p>But this discussion is offtopic here.</p>",
        "id": 440913300,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1716840472
    },
    {
        "content": "<p>Sorry, don't have time to have an opinion on this now. :-)</p>",
        "id": 441003849,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1716889998
    },
    {
        "content": "<p>So it seems category theory is not that attached to defeq of operations across defeq type synonyms?</p>",
        "id": 441455769,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1717075321
    },
    {
        "content": "<p>defeq is lame, who needs it.</p>",
        "id": 441734990,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1717169148
    },
    {
        "content": "<p>I think that one composition of functors is more important than the other.</p>",
        "id": 441737689,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1717169815
    },
    {
        "content": "<p>When you are doing CT, I agree with Kim that we shouldn't really rely on defeqs of operations. But in the \"unbundled world\" I think it is fair to do so.</p>",
        "id": 441737805,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1717169849
    },
    {
        "content": "<p>Hmm, wait, that comment doesn't even apply here.</p>",
        "id": 441737974,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1717169887
    },
    {
        "content": "<p>Never mind..., I think that whatever we do, some potential defeq does not line up.</p>",
        "id": 441738104,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1717169923
    },
    {
        "content": "<p>So nobody is against <a href=\"https://github.com/leanprover-community/mathlib4/pull/1388\">#1388</a> and it makes things a bit nicer in cases we care about?</p>",
        "id": 442710949,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1717571414
    }
]