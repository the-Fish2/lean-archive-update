[
    {
        "content": "<p>This one is a prerequisite for functional equations for Dirichlet L-functions, which is something I've been trying to get into mathlib for a long time. Any takers?</p>",
        "id": 444639926,
        "sender_full_name": "David Loeffler",
        "timestamp": 1718350804
    },
    {
        "content": "<p>Haven't we decided that my approach in APAP was more general hence preferrable?</p>",
        "id": 444640074,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718350867
    },
    {
        "content": "<p>I am slowly getting everything in. Currently stuck at <a href=\"https://github.com/leanprover-community/mathlib4/pull/11243\">#11243</a></p>",
        "id": 444640235,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718350924
    },
    {
        "content": "<p>I don't think we decided that. I think I argued at the time that the approach in LeanAPAP, which sets up the discrete Fourier transform in isolation (without any reference to the existing mathlib code for the non-discrete Fourier transform), was the wrong approach; and we should instead write a few very trivial lemmas about interpreting finite sums as special cases of integrals, etc, so we could use the existing approach. This is precisely the approach followed in my PR.</p>",
        "id": 444642172,
        "sender_full_name": "David Loeffler",
        "timestamp": 1718351740
    },
    {
        "content": "<p>So I have thought about this again and I have to disagree:</p>\n<ol>\n<li><a href=\"https://tqft.net/mathlib4files/Analysis/Fourier/AddCircle\">file#Analysis/Fourier/AddCircle</a> and other files about the Fourier transform are full of continuity, measurability, integrability requirements which are completely irrelevant to the discrete setting.</li>\n<li>It is really important for the discrete applications that physical space is equipped with the compact normalisation and Fourier space with the discrete one</li>\n<li>The discrete setting wouldn't even benefit from the general theory since everything is so easy to prove</li>\n</ol>",
        "id": 444644031,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718352344
    },
    {
        "content": "<p>I would even add</p>\n<ol start=\"4\">\n<li>The current non-discrete Fourier transform library is spread across many folders and unsearchable (where is Plancherel?! I can only find Parseval for a special case of the Fourier transform)</li>\n</ol>",
        "id": 444644393,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718352457
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313353.20discrete.20Fourier.20transform.20on.20ZMod.20N/near/444642172\">said</a>:</p>\n<blockquote>\n<p>I argued at the time that the approach in LeanAPAP, which sets up the discrete Fourier transform in isolation (without any reference to the existing mathlib code for the non-discrete Fourier transform), was the wrong approach</p>\n</blockquote>\n<p>Then let's add my discrete Fourier transform code and show that under some conditions it agrees with the non-discrete one</p>",
        "id": 444644502,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718352485
    },
    {
        "content": "<p>I should also add that APAP is now used by downstream projects as the de facto discrete Fourier analysis library, which is testimony to its usability</p>",
        "id": 444644759,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718352583
    },
    {
        "content": "<blockquote>\n<ol>\n<li><a href=\"https://tqft.net/mathlib4files/Analysis/Fourier/AddCircle\">file#Analysis/Fourier/AddCircle</a> and other files about the Fourier transform are full of continuity, measurability, integrability requirements which are completely irrelevant to the discrete setting.</li>\n</ol>\n</blockquote>\n<p>They're completely <em>trivial</em> in the discrete setting.</p>\n<blockquote>\n<p>Then let's add my discrete Fourier transform code and show that under some conditions it agrees with the non-discrete one</p>\n</blockquote>\n<p>\"Some conditions\" = <em>no conditions at all</em>. </p>\n<p>That's the point I'm trying to make here: a lot of the DFT definitions and theorems from LeanAPAP that you're proposing to upstream into mathlib are literally special cases of more general non-discrete theorems. Moreover, mathlib is capable of recognising them as such: with some minor additions and tweaks (which this PR is trying to make), the instance resolution machinery is able to automatically recognise  that the measurability / summability / etc requirements of the general theory are vacuously satisfied for finite groups.</p>\n<p>Of course the mathlib Fourier-theory library is not perfect – I think the reason you can't find Parseval's theorem is because it hasn't been written yet! – but the solution to that is to make it better, not to reinvent the wheel because the existing wheels aren't 100% perfect.</p>",
        "id": 444651299,
        "sender_full_name": "David Loeffler",
        "timestamp": 1718354998
    },
    {
        "content": "<p>Okay, how should I spell <a href=\"https://yaeldillies.github.io/LeanAPAP/docs/find/?pattern=cft#doc\">LeanAPAP#cft</a> with the existing library?</p>",
        "id": 444651743,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718355159
    },
    {
        "content": "<p>Perhaps you should take a look at the PR which this thread is supposedly about :-)</p>",
        "id": 444652762,
        "sender_full_name": "David Loeffler",
        "timestamp": 1718355485
    },
    {
        "content": "<p>I have, and the Fourier transform there uses <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Measure.count#doc\">docs#Measure.count</a>, which is the wrong normalisation</p>",
        "id": 444652994,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718355567
    },
    {
        "content": "<p>Also</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The discrete measurable space structure (every set is measurable). -/</span>\n<span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">instMeasurableSpaceZMod</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ZMod</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span>\n</code></pre></div>\n<p>is a symptom that you are trying to shoehorn the discrete setting into the more general setting</p>",
        "id": 444653347,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718355661
    },
    {
        "content": "<p>I can't just write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span>\n</code></pre></div>",
        "id": 444653520,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718355706
    },
    {
        "content": "<p>You are being somewhat tendentious with your language here. \"Wrong\" = \"not the one you happen to like\". \"Trying to shoehorn into\" = \"deriving from in the obvious way\".</p>",
        "id": 444653747,
        "sender_full_name": "David Loeffler",
        "timestamp": 1718355763
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313353.20discrete.20Fourier.20transform.20on.20ZMod.20N/near/444653520\">said</a>:</p>\n<blockquote>\n<p>I can't just write</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Why not?</p>",
        "id": 444653829,
        "sender_full_name": "David Loeffler",
        "timestamp": 1718355792
    },
    {
        "content": "<p>I mean \"wrong normalisation for my applications\", as said in my previous message</p>",
        "id": 444653919,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718355832
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313353.20discrete.20Fourier.20transform.20on.20ZMod.20N/near/444653919\">said</a>:</p>\n<blockquote>\n<p>I mean \"wrong normalisation for my applications\", as said in my previous message</p>\n</blockquote>\n<p>So just replace <code>Measure.count</code> with <code>Measure.average</code>, what's the big deal?</p>",
        "id": 444654028,
        "sender_full_name": "David Loeffler",
        "timestamp": 1718355863
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313353.20discrete.20Fourier.20transform.20on.20ZMod.20N/near/444653829\">said</a>:</p>\n<blockquote>\n<p>Why not?</p>\n</blockquote>\n<p>I will need this instance in every single file where I want to talk about the discrete Fourier transform</p>",
        "id": 444654035,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718355867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313353.20discrete.20Fourier.20transform.20on.20ZMod.20N/near/444654035\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313353.20discrete.20Fourier.20transform.20on.20ZMod.20N/near/444653829\">said</a>:</p>\n<blockquote>\n<p>Why not?</p>\n</blockquote>\n<p>I will need this instance in every single file where I want to talk about the discrete Fourier transform</p>\n</blockquote>\n<p>So make it a scoped instance in a namespace <code>Fourier.Discrete</code> and open it when needed.</p>",
        "id": 444654133,
        "sender_full_name": "David Loeffler",
        "timestamp": 1718355902
    },
    {
        "content": "<p>Naive question: would it be harmful to give every <code>[Finite X]</code> type the <code>\\top</code>-MeasurableSpace instance?</p>",
        "id": 444654417,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1718355998
    },
    {
        "content": "<p>Technically, yes, since you can have non-discrete sigma-algebras on finite types</p>",
        "id": 444654482,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718356027
    },
    {
        "content": "<p>In practice, I don't know whether that matters</p>",
        "id": 444654496,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718356037
    },
    {
        "content": "<p>I can imagine settings where you might end up with a MeasurableSpace structure which is discrete, but not <em>definitionally</em> equal to the discrete measure space structure.</p>",
        "id": 444654588,
        "sender_full_name": "David Loeffler",
        "timestamp": 1718356080
    },
    {
        "content": "<p>Good point. We have <code>[DiscreteTopology X]</code> for a reason.</p>",
        "id": 444654679,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1718356106
    },
    {
        "content": "<p>... and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DiscreteMeasurableSpace#doc\">docs#DiscreteMeasurableSpace</a> !</p>",
        "id": 444654717,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718356123
    },
    {
        "content": "<p>Actually, yes, and it's very easy to find one: My project talks about <code>G × G</code> where <code>[Fintype G]</code>. This has the trivial sigma-algebra but not definitionally</p>",
        "id": 444654775,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718356148
    },
    {
        "content": "<p>So, David, your suggestion just doesn't work <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 444654818,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718356165
    },
    {
        "content": "<p>Wait, why wouldn't it work?</p>",
        "id": 444654853,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1718356181
    },
    {
        "content": "<p>I can't do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span>\n</code></pre></div>\n<p>because it would also apply to <code>G × G</code>, creating a non-defeq diamond. Either I</p>\n<ul>\n<li>add the above instance locally but only for the groups on which I want it</li>\n<li>assume all my groups are discrete measurable spaces</li>\n</ul>",
        "id": 444655198,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718356280
    },
    {
        "content": "<p>But your <code>*2</code> isn't that bad right? I guess we can even have a simple tactic that you can invoke inside a proof which will endow <code>G</code> with a discrete measure: <code>endow_discrete_measure G</code><br>\nSo yes, it is an extra line, but I'm not sure if avoiding those extra lines would justify specializing an entire API.</p>",
        "id": 444655772,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1718356471
    },
    {
        "content": "<p>We have a similar tactic for Polish spaces, I think.</p>",
        "id": 444655877,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1718356509
    },
    {
        "content": "<p>Well there is also the fact that side conditions (like integrability, measurability, etc...) break the flow of rewriting tactics (<code>rw</code>, <code>simp</code>, <code>simp_rw</code>). Indeed either</p>\n<ul>\n<li>they generate extra goals</li>\n<li>they just don't rewrite if the automation doesn't close the side goals</li>\n<li>the code becomes sluggish if the automation does close the side goals</li>\n</ul>",
        "id": 444656624,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718356753
    },
    {
        "content": "<p>After some experimentation, I do see that the existing library isn't general enough to derive Yaël's version of DFT, because we always assume that the domain is a <code>𝕜</code>-module for some commutative ring <code>𝕜</code>, and we consider only additive characters that come by composing a <code>𝕜</code>-linear functional with an additive character of <code>𝕜</code> itself. So this would not work for general finite abelian groups.</p>",
        "id": 444656858,
        "sender_full_name": "David Loeffler",
        "timestamp": 1718356830
    },
    {
        "content": "<p>How could I have figured that out?</p>",
        "id": 444657025,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718356893
    },
    {
        "content": "<p>But there is a very natural common generalisation of Yael's Fourier transform and mathlib's, which is to define a Fourier transform for <em>locally compact</em> abelian groups, sending functions on <code>G</code> to functions on its Pontryagin dual <code>G*</code>.</p>",
        "id": 444657177,
        "sender_full_name": "David Loeffler",
        "timestamp": 1718356936
    },
    {
        "content": "<p>Oh, that's the generalisation I thought we already had</p>",
        "id": 444657296,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718356984
    },
    {
        "content": "<p>It's the generalisation we clearly ought to have, but nobody has written it yet</p>",
        "id": 444657368,
        "sender_full_name": "David Loeffler",
        "timestamp": 1718357017
    },
    {
        "content": "<p>Also, I don't understand your comment about me duplicating all the API. You do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">discreteFourierTransform</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ZMod</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ZMod</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Fourier</span><span class=\"bp\">.</span><span class=\"n\">fourierIntegral</span><span class=\"w\"> </span><span class=\"n\">toCircle</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"bp\">.</span><span class=\"n\">count</span><span class=\"w\"> </span><span class=\"n\">Φ</span><span class=\"w\"> </span><span class=\"n\">k</span>\n</code></pre></div>\n<p>which in practice means you will have to copy over all the lemmas from <code>fourierIntegral</code> to <code>discreteFourierTransform</code></p>",
        "id": 444657963,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718357225
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313353.20discrete.20Fourier.20transform.20on.20ZMod.20N/near/444657963\">said</a>:</p>\n<blockquote>\n<p>Also, I don't understand your comment about me duplicating all the API. You do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">discreteFourierTransform</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ZMod</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ZMod</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Fourier</span><span class=\"bp\">.</span><span class=\"n\">fourierIntegral</span><span class=\"w\"> </span><span class=\"n\">toCircle</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"bp\">.</span><span class=\"n\">count</span><span class=\"w\"> </span><span class=\"n\">Φ</span><span class=\"w\"> </span><span class=\"n\">k</span>\n</code></pre></div>\n<p>which in practice means you will have to copy over all the lemmas from <code>fourierIntegral</code> to <code>discreteFourierTransform</code></p>\n</blockquote>\n<p>That's true: in order to prove any properties of <code>discreteFourierTransform</code>, we have to either unfold the definition (meaning the measure-theoretic side conditions become visible again), or we make copies of a bunch of lemmas. But the copied lemmas will all end up having one-line proofs, just applying the underlying <code>FourierIntegral</code> lemmas; the duplication is a very thin façade -- it's much less duplicatory (if that's a word) than building a new API for DFT's from scratch without reference to the existing one for non-discrete Fourier transforms.</p>",
        "id": 444696302,
        "sender_full_name": "David Loeffler",
        "timestamp": 1718370246
    },
    {
        "content": "<p>I mean, <a href=\"https://github.com/YaelDillies/LeanAPAP/blob/master/LeanAPAP/Prereqs/Discrete/DFT/Basic.lean\">most proofs in APAP</a> are one or two lines long as well <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 444697185,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718370528
    },
    {
        "content": "<p>OK, fair enough. There's a danger here that the debate over the code becomes longer than the code itself! </p>\n<p>Can I suggest the following?</p>\n<ul>\n<li>We evaluate <a href=\"https://github.com/leanprover-community/mathlib4/pull/13353\">#13353</a> on its own merits for now (ignoring the existence of an alternative treatment in LeanAPAP),</li>\n<li>When the relevant results from LeanAPAP get merged (in whatever form), we can revisit this and consider reimplementing / removing the treatment of <code>ZMod N</code> using that.</li>\n</ul>",
        "id": 444699365,
        "sender_full_name": "David Loeffler",
        "timestamp": 1718371253
    },
    {
        "content": "<p>There is a mathematical diamond here, by which I mean both what people expect on this forum, and a jewel.</p>",
        "id": 444713548,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1718375623
    },
    {
        "content": "<p>Fourier transform for Z mod N generalizes in one direction, representation theory of finite (non necessarily commutative) groups, and in another direction, Fourier transform for compact abelian groups, with representation theory of locally compact groups being in top of both generalizations.</p>",
        "id": 444713569,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1718375631
    },
    {
        "content": "<p>On the other hand, the case of finite groups, in particular finite abelian groups, has nice arithmetic features which will be needed sooner or later. So it has to be studied in a more general context than analysis. Semifields are not enough, rings such as the ring of cyclotomic integers are important, finite fields are important too.</p>",
        "id": 444713740,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1718375689
    },
    {
        "content": "<p>And when it comes about normalizations: I am not sure they should be fixed beforehand. While I have some preferences for myself, I am tempted to say that all normalizations have some interest. (If one divides by N early, one cannot anymore reduce modulo something dividing N…)</p>",
        "id": 444715661,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1718376316
    },
    {
        "content": "<p>And a general question: imagine one has to formalize some theorem in analysis that is based on some different normalization than mathlib's. It is obviously possible to rewrite  everything but it might be a nightmare to have to.</p>",
        "id": 444716276,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1718376506
    },
    {
        "content": "<p>Tate's normalisation of the norm on the complexes has <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mn>2</mn><mi mathvariant=\"normal\">∣</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">|2|=4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣2∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span></span></span></span>, right?</p>",
        "id": 444716505,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1718376592
    },
    {
        "content": "<p>This is the “modulus”, how homotheties change a Haar measure. But it's not a norm.</p>",
        "id": 444721405,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1718377923
    },
    {
        "content": "<p>I'll mention that we're slowing working towards the theory for locally compact abelian groups (e.g., <a href=\"https://github.com/leanprover-community/mathlib4/pull/11335\">#11335</a> proves local compactness of the Pontryagin dual), but we still don't have the general Fourier transform yet.</p>",
        "id": 444747599,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1718384483
    }
]