[
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/11521\">#11521</a> introduces a new <code>fast_instance% inst</code> elaborator, which takes an instance expression<code>inst</code> and tried to replace as much of it as possible with existing instances.</p>\n<p>Using this in a number of places is <a href=\"http://speed.lean-fro.org/mathlib4/compare/1fa7b43f-361e-40fa-90a0-aaa1a6372cee/to/0be42ab7-df41-4ea7-93c9-24da90211a38\">looking pretty promising</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"w\"> </span> Benchmark                                              Metric         Change\n<span class=\"w\"> </span> ============================================================================\n<span class=\"gi\">+ ~Mathlib.AlgebraicGeometry.GammaSpecAdjunction         instructions   -11.0%</span>\n<span class=\"gi\">+ ~Mathlib.AlgebraicGeometry.Spec                        instructions   -13.0%</span>\n<span class=\"gi\">+ ~Mathlib.FieldTheory.AbelRuffini                       instructions   -45.4%</span>\n<span class=\"gi\">+ ~Mathlib.FieldTheory.Adjoin                            instructions    -9.9%</span>\n<span class=\"gi\">+ ~Mathlib.FieldTheory.PurelyInseparable                 instructions   -13.1%</span>\n<span class=\"gi\">+ ~Mathlib.FieldTheory.SeparableDegree                   instructions   -20.4%</span>\n<span class=\"gi\">+ ~Mathlib.FieldTheory.Subfield                          instructions   -14.6%</span>\n<span class=\"gi\">+ ~Mathlib.FieldTheory.Subfield.Order                    instructions   -76.7%</span>\n<span class=\"gi\">+ ~Mathlib.NumberTheory.NumberField.CanonicalEmbedding   instructions    -7.7%</span>\n<span class=\"gi\">+ ~Mathlib.NumberTheory.NumberField.ClassNumber          instructions   -17.6%</span>\n<span class=\"gi\">+ ~Mathlib.NumberTheory.NumberField.Discriminant         instructions    -8.5%</span>\n<span class=\"gi\">+ ~Mathlib.NumberTheory.NumberField.FractionalIdeal      instructions   -20.4%</span>\n<span class=\"gi\">+ ~Mathlib.NumberTheory.NumberField.Units                instructions    -6.1%</span>\n<span class=\"gi\">+ ~Mathlib.NumberTheory.RamificationInertia              instructions    -3.9%</span>\n<span class=\"gi\">+ ~Mathlib.RingTheory.Subring.Order                      instructions   -79.3%</span>\n<span class=\"gi\">+ ~Mathlib.RingTheory.Subsemiring.Order                  instructions   -64.4%</span>\n</code></pre></div>\n<p>(note that some of these are quite small files, so the improvement is not actually as big as it looks)</p>",
        "id": 428421032,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711148306
    },
    {
        "content": "<p>Some things to consider:</p>\n<ul>\n<li>Are there better names? <span class=\"user-mention\" data-user-id=\"306577\">@Matthew Ballard</span>  suggests <code>compact_instance%</code> which is a little more accurate; though I'd rather not make two renames in a row if there's an even better option</li>\n<li>This doesn't work with <code>where</code> notation, because there is nowhere to insert the term.</li>\n<li>In theory it's probably safe to put <code>fast_instance%</code>on everything; should we have an <code>instanceüèéÔ∏è </code> keyword instead that make it easier to do so? Should this feature be part of the core <code>instance</code>?</li>\n</ul>",
        "id": 428421307,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711148489
    },
    {
        "content": "<p>Isn't the operation \"flattening\" somehow?</p>",
        "id": 428421424,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1711148554
    },
    {
        "content": "<p>As in you are flattening the arguments to the (nested) constructors</p>",
        "id": 428421460,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1711148576
    },
    {
        "content": "<p>The original motivation here was to speed up uses of things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.Injective.ring#doc\">docs#Function.Injective.ring</a>, but it also works on cases like <code>{ instB, instA }</code></p>",
        "id": 428421464,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711148581
    },
    {
        "content": "<p>What do you mean by flattening here?</p>",
        "id": 428421518,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711148614
    },
    {
        "content": "<p>Okay nevermind it does not do what I thought it did</p>",
        "id": 428421613,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1711148669
    },
    {
        "content": "<p>Opposite of flattening I would think</p>",
        "id": 428421692,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711148748
    },
    {
        "content": "<p>I guess it's more accurately \"recycling\"</p>",
        "id": 428421827,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1711148835
    },
    {
        "content": "<p>It is about ~500B over the whole library which is good. There is probably room to speed things up at least double or triple given experiments I‚Äôve run</p>",
        "id": 428421843,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711148860
    },
    {
        "content": "<p>This isn‚Äôt recursive is it?</p>",
        "id": 428422088,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711149030
    },
    {
        "content": "<p>It is recursive</p>",
        "id": 428422141,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711149078
    },
    {
        "content": "<p>Does it generate the instances it cannot find?</p>",
        "id": 428422154,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711149099
    },
    {
        "content": "<p>I think the outcome is that it usually finds instance for the data fields, and anything that is leftover comes from the original <code>inst</code></p>",
        "id": 428422233,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711149133
    },
    {
        "content": "<p>Beyond just speeding things up, I think that something like this is could be a big part of the UX of constructing instances going forward where the exact inheritance graph for structures is less prominent.</p>",
        "id": 428422504,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711149363
    },
    {
        "content": "<p>At least to the user</p>",
        "id": 428422540,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711149379
    },
    {
        "content": "<p>Yes, this is kind of the point; of course, people can still fiddle with parent orders in the <em>definition</em> of the typeclasses if they so desire, but this should insulate the user from those choices</p>",
        "id": 428422559,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711149402
    },
    {
        "content": "<p>It also aids refactors</p>",
        "id": 428422562,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711149405
    },
    {
        "content": "<p>/poll What should we call this elaborator</p>\n<ul>\n<li>fast_instance%</li>\n<li>compact_instance%</li>\n<li>recycle_instances_in%<br>\n*</li>\n</ul>",
        "id": 428423562,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711150092
    },
    {
        "content": "<p>Maybe <code>shallow_instance%</code>? Is \"shallow\" a good word to describe the kind of instances this elaborator aims to produce?<br>\nOr maybe <code>optimize_instance%</code> to evoke a more flexible specification?</p>",
        "id": 428424399,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711150751
    },
    {
        "content": "<p>Do you see this elaborator as a black box to just produce a more optimized instance that just happens to currently only perform recycling, or do you see it as a specific tool among others that a library author should intelligently choose between for optimizing instances? If the former, <code>fast_instance%</code> or <code>optimize_instance%</code> seem preferable to a more specific name.</p>",
        "id": 428424709,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711150984
    },
    {
        "content": "<p>My hunch is that it is possible to write the instance such that it is always the correct choice, and at worse does nothing</p>",
        "id": 428425388,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711151478
    },
    {
        "content": "<p>Other possibilities: <code>fold_up%</code>, <code>bundle_up%</code></p>",
        "id": 428426857,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711152610
    },
    {
        "content": "<p>Let's see if I got what this right:</p>\n<p><code>fast_instance% e</code> takes the expression <code>e</code> and normalizes <code>e</code> so that it is a structure constructor application such that each of its instance arguments are either canonical instances or (recursively) normalized expressions.</p>",
        "id": 428427735,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711153429
    },
    {
        "content": "<p>I don‚Äôt think it does the following but I want to check. (Edit: checked)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">B</span> <span class=\"kd\">extends</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">fast_instance</span><span class=\"bp\">%</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">}</span>\n<span class=\"c\">/-</span><span class=\"cm\">  returns B.mk (A.mk 0) 0 and not B.mk instA 0 where instA is a generated declaration? -/</span>\n</code></pre></div>",
        "id": 428428464,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711154048
    },
    {
        "content": "<p>Also I would like <code>where‚Äô</code> syntax where we do this for all structure instances and generate declarations for the parents recursively</p>",
        "id": 428428727,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711154342
    },
    {
        "content": "<p>One thing to note is that the \"canonical\" instance chosen is just the one found via <code>inferInstance</code>; this would be even more performant if preferred parents had a higher <code>priority</code> than non-preferred parents</p>",
        "id": 428429473,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711155120
    },
    {
        "content": "<p>Another suggestion: <code>rectify_instance%</code></p>",
        "id": 428431816,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711157555
    },
    {
        "content": "<p>This seems similar to how <a href=\"https://en.wikipedia.org/wiki/Dictionary_coder\">https://en.wikipedia.org/wiki/Dictionary_coder</a> works ... maybe <code>compress</code> is better than <code>compact(ify)</code></p>",
        "id": 428440006,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1711165420
    },
    {
        "content": "<p>I'm not sure a dictionary coder is a good point of comparison. This is taking the instance fields of the instance and re-synthesizing them (using only the type) and replacing the term, meanwhile <em>expanding</em> the term so that there is an explicit structure constructor.</p>\n<p>It's not looking for previous terms that it can re-use, which is what I'd think a dictionary coder would be like.</p>",
        "id": 428440589,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711165785
    },
    {
        "content": "<p>(In compilers, I guess the analogue of a dictionary coder would be an optimization called global value numbering. That sort of optimization is frequently done in Lean, but not here.)</p>",
        "id": 428440644,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711165807
    },
    {
        "content": "<p>Thanks, I now have a better idea how it works, and I'd like to suggest <code>streamline</code> ...</p>",
        "id": 429058223,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1711178507
    },
    {
        "content": "<p><code>normalize</code>?</p>",
        "id": 429066807,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1711187387
    },
    {
        "content": "<p><code>norm_inst</code>?</p>",
        "id": 429082864,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711202021
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2311521.20speeding.20up.20lots.20of.20instances/near/428440589\">said</a>:</p>\n<blockquote>\n<p>I'm not sure a dictionary coder is a good point of comparison. This is taking the instance fields of the instance and re-synthesizing them (using only the type) and replacing the term, meanwhile <em>expanding</em> the term so that there is an explicit structure constructor.</p>\n<p>It's not looking for previous terms that it can re-use, which is what I'd think a dictionary coder would be like.</p>\n</blockquote>\n<p>To me, the fact it is checking for defeq on the synthesized terms, makes me mentally view the input and output of the resynth as the ‚Äúsame‚Äù because I‚Äôm quotienting by defeq. </p>\n<p>Also there isn‚Äôt always a constructor application. If you already have a defeq instance in scope for original class, that will get slotted in correct?</p>",
        "id": 429084820,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711203598
    },
    {
        "content": "<p>The (perhaps far flung) analogy in my head is choosing length minimizing paths in a homotopy class.</p>",
        "id": 429085067,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711203729
    },
    {
        "content": "<p>What is quickest way to pass this to all instances for testing?</p>",
        "id": 429373051,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711368561
    },
    {
        "content": "<p>Brute force (python) it is</p>",
        "id": 429470206,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711387014
    },
    {
        "content": "<p>Something that occurred to me is that we could create a term version of <code>where</code> for the purpose of making it easy to insert material around the <code>where</code>.</p>\n<p>Imagine replacing <code>instance : Foo X where ...</code> with <code>instance : Foo X := where% ...</code> and it Just Works<span aria-label=\"tm\" class=\"emoji emoji-2122\" role=\"img\" title=\"tm\">:tm:</span></p>",
        "id": 429486239,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711392235
    },
    {
        "content": "<p>I like standardizing around <code>where</code> for syntax also. More legible</p>",
        "id": 429487542,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711392734
    },
    {
        "content": "<p>That syntax sounds great, but I'm a bit worried about trying to lump it in with <code>fast_instance%</code> and nothing happening as a result. Perhaps worth making an RFC for?</p>",
        "id": 429490332,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711393770
    },
    {
        "content": "<p>I think it's fine making something called <code>where%</code> and using it to keep the diff down for <code>fast_instance%</code>. Maybe only <code>fast_instance_where%</code> would make it into mathlib?</p>",
        "id": 429490684,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711393895
    },
    {
        "content": "<p>Yes definitely out of scope for this PR but great of another!</p>",
        "id": 429491541,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711394209
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/11668\">#11668</a> is a haphazard attempt at seeing the performance implications of more widespread use. I replaced all <code>:=</code> on the same line as <code>instance</code> with <code>:= fast_instance%</code>. Probably not the smartest move but see below</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"w\"> </span> Benchmark                                                        Metric         Change\n<span class=\"w\"> </span> ======================================================================================\n<span class=\"gi\">+ build                                                            instructions     -2.0 %</span>\n</code></pre></div>\n<p><a href=\"http://speed.lean-fro.org/mathlib4/compare/1fa7b43f-361e-40fa-90a0-aaa1a6372cee/to/5fbd62e2-7598-41b8-bd61-2072734154d2\">Full benchmark</a></p>",
        "id": 429522409,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711406236
    },
    {
        "content": "<p>Nothing in that PR should be considered for anything else in life</p>",
        "id": 429522442,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711406261
    },
    {
        "content": "<p>Maybe the <code>instance</code> keyword really should do this all automagically? I guess the real test will be the <code>where</code>s</p>",
        "id": 429522528,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711406300
    },
    {
        "content": "<p>Yes, I think both should recalibrate the instances in sympathy with the machine</p>",
        "id": 429522586,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711406366
    },
    {
        "content": "<p>About halfway through, I realized that I should have replaced the <code>:=</code> in the next 2 to 4 lines instead <span aria-label=\"lol\" class=\"emoji emoji-1f606\" role=\"img\" title=\"lol\">:lol:</span> Those are the complicated instances</p>",
        "id": 429524333,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711407290
    },
    {
        "content": "<p>If it's recursive then that doesn't matter, right?</p>",
        "id": 429531973,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711411760
    },
    {
        "content": "<p>Sorry I wasn‚Äôt clear perhaps. I inserted into things like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Stuff</span> <span class=\"o\">:=</span> <span class=\"bp\">‚Ä¶</span>\n</code></pre></div>\n<p>and I am saying it would have been to insert into things like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">complicatedFoo</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LongClassName1</span><span class=\"o\">]</span> <span class=\"bp\">‚Ä¶.</span>\n<span class=\"bp\">‚Ä¶</span><span class=\"n\">more</span> <span class=\"n\">lines</span>\n<span class=\"bp\">‚Ä¶</span><span class=\"n\">even</span> <span class=\"n\">more</span> <span class=\"n\">lines</span>\n<span class=\"o\">[</span><span class=\"n\">LongClassName37</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Stuff</span> <span class=\"o\">:=</span> <span class=\"bp\">‚Ä¶</span>\n</code></pre></div>",
        "id": 429532336,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711411975
    },
    {
        "content": "<p>The latter are probably deeper in the hierarchy and would benefit more from the change</p>",
        "id": 429532463,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1711412061
    }
]