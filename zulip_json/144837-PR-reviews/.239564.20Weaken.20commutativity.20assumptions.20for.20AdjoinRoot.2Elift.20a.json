[
    {
        "content": "<p>I weaken a commutativity assumption for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AdjoinRoot.liftHom#doc\">docs#AdjoinRoot.liftHom</a> that the target algebra be commutative. It is only assumed to be a Semiring.</p>\n<p>For that, I need to generalize <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AdjoinRoot.lift#doc\">docs#AdjoinRoot.lift</a> which takes i : R -&gt;+* S, a : S with f.eval₂ i a = 0 and defines AdjoinRoot f -&gt;+* S that extends i and sends AdjoinRoot.root f to a.</p>\n<p>To weaken the present commutativity assumption, I define AdjoinRoot.lift' where S is only a Semiring, with the additional assumption that the element a commutes with the image of i.</p>\n<p>I make <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AdjoinRoot.lift#doc\">docs#AdjoinRoot.lift</a> as an <code>abbrev</code> in terms of this newly defined function.</p>\n<p>I wanted to avoid duplicating the lemmas such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AdjoinRoot.lift_root#doc\">docs#AdjoinRoot.lift_root</a>, etc. for the new variant, so I redefined them so that they can apply in both cases. The commutativity assumption is an implicit parameter and Lean finds it by itself when needed, except in one case, in the proof of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IntermediateField.adjoinRootEquivAdjoin_apply_root#doc\">docs#IntermediateField.adjoinRootEquivAdjoin_apply_root</a> where I had to supply it myself.</p>",
        "id": 411902275,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1704795148
    },
    {
        "content": "<p>I think this might be a good test case to see if the commutativity assumption can be supplied by a default argument/tactic.</p>",
        "id": 411908057,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1704796926
    },
    {
        "content": "<p>The tactic could be something like (pseudocode) <code>{ try assumption } orelse { intro; apply Commute.all }</code></p>",
        "id": 411908247,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1704796981
    },
    {
        "content": "<p>Are there example cases in mathlib so that I can understand how to use such a tactic?<br>\nCan one enter just this line within parentheses, in place of the argument?</p>",
        "id": 411909464,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1704797366
    },
    {
        "content": "<p>Just <code>:= by blah</code>.</p>",
        "id": 411909544,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1704797395
    },
    {
        "content": "<p>There are a bunch of examples in CategoryTheory, <code>NatIso.ofComponents</code> is perhaps the most widely used there.</p>",
        "id": 411909672,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1704797422
    },
    {
        "content": "<p>But probably it needs to come with some error-reporting, otherwise people might get very confused.</p>",
        "id": 411909766,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1704797452
    },
    {
        "content": "<p>If the tactic fails, it should tell people to prove argument <code>hc</code> by hand.</p>",
        "id": 411909807,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1704797469
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> is that easy to do?</p>",
        "id": 411909828,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1704797475
    },
    {
        "content": "<p>If the autoparam runs, you just get whatever error message it produces.</p>",
        "id": 411910031,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1704797539
    },
    {
        "content": "<p>So you can provide a wrapper that catches the underlying error and rethrows it with help text.</p>",
        "id": 411910083,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1704797561
    },
    {
        "content": "<p>I've never done that before</p>",
        "id": 411910149,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1704797587
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">assumption</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"c1\">-- fails with `tactic 'assumption' failed ⊢ ℕ</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"my_assumption\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">first</span> <span class=\"bp\">|</span> <span class=\"n\">assumption</span> <span class=\"bp\">|</span> <span class=\"n\">fail</span> <span class=\"s2\">\"ouch\"</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f'</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">my_assumption</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g'</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">f'</span> <span class=\"c1\">-- fails with `ouch ⊢ ℕ`</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g''</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">f'</span> <span class=\"c1\">-- succeeds</span>\n</code></pre></div>",
        "id": 411910936,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1704797863
    },
    {
        "content": "<p>Thanks for the little demo!</p>",
        "id": 411911144,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1704797935
    },
    {
        "content": "<p>I'm not convinced that doing <code>assumption</code> automatically is helpful here; but certainly doing so for <code>Commute.all</code> is</p>",
        "id": 411911932,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704798182
    },
    {
        "content": "<p>(The argument being that we could use assumption automatically for every argument, but we don't, suggesting it's probably just confusing to do so)</p>",
        "id": 411912022,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704798211
    },
    {
        "content": "<p>In the present case, duplicating 5-6 functions (whose proofs are essentially identical) by having <code>AdjoinRoot.lift'_of</code>, etc. for the noncomm case would not be a great deal neither.</p>",
        "id": 411913244,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1704798600
    },
    {
        "content": "<p>I don't have a strong opinion on which kind of solution we choose. I just want to make sure that \"commutative\" users don't really notice this change <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span> <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 411914251,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1704798948
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.239564.20Weaken.20commutativity.20assumptions.20for.20AdjoinRoot.2Elift.20a/near/411910031\">said</a>:</p>\n<blockquote>\n<p>If the autoparam runs, you just get whatever error message it produces.</p>\n</blockquote>\n<p>I think this should be changed in core; if an <code>autoparam</code> run, it should decorate the error message with information about the argument it is being used to fill</p>",
        "id": 411915298,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704799338
    },
    {
        "content": "<p>Can we teach autoparams to first see if the argument can be filled in by unification, and only try running tactics afterwards?</p>",
        "id": 413166672,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1705415576
    },
    {
        "content": "<p>I pushed something to <code>jmc-AdjoinRoot</code>. It seems that we currently have to choose between to suboptimals:</p>\n<ul>\n<li>have an argument <code>hc</code> without autoparam. In the noncommutative setting this <code>hc</code> is passed a long, and often filled in by inference. In the commutative setting, apply <code>Commute.all</code> by hand.</li>\n<li>have an argument <code>hc</code> with autoparam. In the commutative setting everything is nice and transparent. But in the noncommutative setting, <code>hc</code> is no longer filled in by inference, and the autoparam fails.</li>\n</ul>",
        "id": 413170137,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1705416533
    },
    {
        "content": "<p>Probably naïve remark: in <a href=\"https://github.com/leanprover-community/mathlib4/tree/jmc-AdjoinRoot\">branch#jmc-AdjoinRoot</a>, Lean should be able to find the argument <code>hc</code> by itself in many cases, because the theorem to prove uses it. (For example, in <code>lift_mk</code>.)</p>",
        "id": 413171662,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1705416953
    },
    {
        "content": "<p>Finding commutativity either from hypotheses or existing theorems sounds like a good job for <code>aesop</code>! I pushed a commit which tags a few lemmas and replaces <code>commutativity</code> with a call to <code>aesop</code>. It's almost as good as original for the commutative case, if you ignore the parentheses :)</p>",
        "id": 418106432,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1706197057
    }
]