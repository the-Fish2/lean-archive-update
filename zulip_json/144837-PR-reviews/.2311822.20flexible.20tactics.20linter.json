[
    {
        "content": "<p>I would like to have some impressions on whether the changes that <a href=\"https://github.com/leanprover-community/mathlib4/pull/11822\">#11822</a> does look reasonable.</p>\n<p>The context is an evolution of the \"non-terminal <code>simp</code>\" linter.  In its current form, the linter only flags situations where a proof has <code>simp at somewhere</code> and <code>somewhere</code> is later used by a \"rigid\" tactic, such as <code>rw</code>.</p>\n<p>The design is such that adding more \"<code>simp</code>-like\" tactics is very easy and I am using <code>simp</code> just as a showcase (and even so there are hundreds of affected files).</p>\n<p>So, do you think that the changes that I made to please the linter improve the code?  Please, be very critical!!!</p>",
        "id": 431564398,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712334904
    },
    {
        "content": "<p>I think this really merits a bigger discussion in general than putting in all these linters (which are great work, btw!)</p>",
        "id": 431664580,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1712402201
    },
    {
        "content": "<p>We tend to have proofs in a form that is not very human readable because of performance and 'stability', but I think that this hasn't been re evaluated for a while, and I think it's worthwhile. Also, I'd argue that sometimes <code>simp</code> is more robust than these long simp only chains!</p>",
        "id": 431664664,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1712402285
    },
    {
        "content": "<p>Eric, thanks for your comments!</p>\n<p>Here are the two specific threads where the linter was discussed:</p>\n<ul>\n<li><a href=\"#narrow/stream/287929-mathlib4/topic/.60simp.60.20followers\">simp followers</a>,</li>\n<li><a href=\"#narrow/stream/287929-mathlib4/topic/flexible.20vs.20rigid.20tactics\">flexible vs rigid</a>.</li>\n</ul>",
        "id": 431693159,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712426794
    },
    {
        "content": "<p>With respect to chains of <code>simp only</code>, the linter does not flag consecutive <code>simp</code>s, it only flags the boundary between a <code>simp *not only*</code> and something else (in fact, many tactics can follow <code>simp</code> without triggering a flag).</p>",
        "id": 431693287,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712426902
    },
    {
        "content": "<p>So, if you saw a lot of chains of <code>simp only</code>s, they may be due to the fact that I adapted the linter and forgot to revert some earlier change.</p>",
        "id": 431693337,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712426957
    },
    {
        "content": "<p>From a higher point of view, this is what the linter does.</p>\n<p>The linter introduces essentially three types of tactics:</p>\n<ul>\n<li>flexible tactics (like <code>simp</code>) that can only be followed by other flexible tactics or stoppers;</li>\n<li>stopper tactics (like <code>norm_num</code> or <code>simp only</code>) that can be followed by any tactic;</li>\n<li>rigid tactics (like <code>rw</code>) that cannot follow flexible tactics.</li>\n</ul>\n<p>The linter warns you when a rigid tactic follows a flexible one.</p>",
        "id": 431693624,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712427232
    },
    {
        "content": "<p>My impression is that, when I was still making big changes to the linter, the changes that it was suggesting were often debatable.  Once I stabilised the core of the algorithm, I found myself liking more and more the changes.</p>\n<p>My current impression is that all almost all the changes that it suggests are improvements and, when they are not, then it is simply because a tactic has been mislabeled.</p>",
        "id": 431693812,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712427387
    },
    {
        "content": "<p>Also, if you look at the output of the <code>build mathlib</code> step of CI, you can see that the linter tells you which flexible tactic the linter first encountered and which rigid tactic follows that flexible one.</p>",
        "id": 431693878,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712427463
    },
    {
        "content": "<p>Here is an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Warning</span><span class=\"o\">:</span> <span class=\"bp\">./././</span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Data</span><span class=\"bp\">/</span><span class=\"n\">Nat</span><span class=\"bp\">/</span><span class=\"n\">Bits.lean</span><span class=\"o\">:</span><span class=\"mi\">125</span><span class=\"o\">:</span><span class=\"mi\">21</span><span class=\"o\">:</span> <span class=\"n\">warning</span><span class=\"o\">:</span> <span class=\"bp\">'</span><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">cond</span><span class=\"o\">,</span> <span class=\"n\">not</span><span class=\"o\">]</span><span class=\"bp\">'</span> <span class=\"n\">stains</span> <span class=\"sc\">'⊢'</span><span class=\"bp\">...</span> <span class=\"o\">[</span><span class=\"n\">linter.flexible</span><span class=\"o\">]</span>\n<span class=\"bp\">...</span> <span class=\"n\">and</span> <span class=\"bp\">'</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_comm</span><span class=\"o\">]</span><span class=\"bp\">'</span> <span class=\"n\">uses</span> <span class=\"sc\">'⊢'</span><span class=\"bp\">!</span>\n<span class=\"n\">Warning</span><span class=\"o\">:</span> <span class=\"bp\">./././</span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Data</span><span class=\"bp\">/</span><span class=\"n\">Nat</span><span class=\"bp\">/</span><span class=\"n\">Bits.lean</span><span class=\"o\">:</span><span class=\"mi\">125</span><span class=\"o\">:</span><span class=\"mi\">21</span><span class=\"o\">:</span> <span class=\"n\">warning</span><span class=\"o\">:</span> <span class=\"bp\">'</span><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">cond</span><span class=\"o\">,</span> <span class=\"n\">not</span><span class=\"o\">]</span><span class=\"bp\">'</span> <span class=\"n\">stains</span> <span class=\"sc\">'⊢'</span><span class=\"bp\">...</span> <span class=\"o\">[</span><span class=\"n\">linter.flexible</span><span class=\"o\">]</span>\n<span class=\"bp\">...</span> <span class=\"n\">and</span> <span class=\"bp\">'</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">succ_mul</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_comm</span> <span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">'</span> <span class=\"n\">uses</span> <span class=\"sc\">'⊢'</span><span class=\"bp\">!</span>\n</code></pre></div>\n<p>This is saying that in <code>Mathlib/Data/Nat/Bits.lean</code> there is a <code>simp</code> that is followed by two <code>rw</code>.  Indeed, this is what the code looks like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"n\">refine'</span> <span class=\"n\">Eq.trans</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">bodd_add_div2</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n    <span class=\"n\">cases</span> <span class=\"n\">bodd</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">cond</span><span class=\"o\">,</span> <span class=\"n\">not</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_comm</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">succ_mul</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_comm</span> <span class=\"mi\">1</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 431694118,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712427678
    },
    {
        "content": "<p>So, it seems to me that this is certainly a situation where</p>\n<ol>\n<li><code>simp</code> is <em>not</em> terminal;</li>\n<li>it is followed by a tactic that will almost certainly stop working if <code>simp</code> makes any further sort of progress.</li>\n</ol>\n<p>At this position, the linter triggers and flags this use.</p>",
        "id": 431694364,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712427882
    },
    {
        "content": "<p>Of course, the linter could decide to do more checks to decide what to do.</p>\n<ul>\n<li>Should the <code>simp; rw</code> pair above be flagged?</li>\n<li>Should the linter do some further testing before flagging?  If so, what?</li>\n</ul>\n<p>Or even</p>\n<ul>\n<li>is this linter not a good idea at all?</li>\n</ul>",
        "id": 431694529,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712427979
    },
    {
        "content": "<p>I understand that <code>simp</code> followed by <code>rw</code> makes the code fragile to further additions/deletions of <code>simp</code> lemmas, hence makes the library more difficult to refactor. <br>\nOn the other hand, these chains of <code>simp only</code> with often arcane lemmas are illegible. <br>\nWhat I believe would be nice is that after each <code>simp</code> (without arguments), the  linter <em>inserts</em> inserts a kind of command that says to which goal it is simplified. That would be the equivalent of <code>suffices ... by ... simp</code>.<br>\nIn a further refactor, one could either leave that intermediate goal intact, or make use of the refactor to redo the proof, or the compiler could say: “the <code>simp</code> used to lead to … and now leads to …”.</p>",
        "id": 431895664,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1712565667
    },
    {
        "content": "<p>This was proposed in <a href=\"#narrow/stream/113488-general/topic/Try.20this.3A.20suffices.20simpa\">this thread</a>.  Let me try to see if I can implement it.</p>",
        "id": 431899530,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712566403
    },
    {
        "content": "<p>I suspect though that in many situations, printing the final goal in <code>suffices [here] by</code> would be unwieldy as much as the wall of lemmas that <code>simp?</code> might produce.</p>",
        "id": 431899939,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712566476
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/12006\">#12006</a></p>",
        "id": 431942617,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712575462
    },
    {
        "content": "<p>However, here is an example showing that this may not be a great solution either:<br>\n(source: <code>Archive/Examples/IfNormalization/Result.lean:90+</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>          <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">ht₁</span><span class=\"o\">]</span>\n            <span class=\"n\">congr</span>\n            <span class=\"n\">ext</span> <span class=\"n\">w</span>\n            <span class=\"n\">by_cases</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"bp\">◾</span>\n</code></pre></div>\n<p>becomes (after some massaging, since handling <code>fvar</code>s does not really work with the new tactic)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>          <span class=\"bp\">·</span> <span class=\"k\">suffices</span>\n              <span class=\"n\">eval</span>\n                  <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">w</span> <span class=\"bp\">↦</span>\n                    <span class=\"k\">match</span> <span class=\"n\">AList.lookup</span> <span class=\"n\">w</span> <span class=\"o\">(</span><span class=\"n\">AList.insert</span> <span class=\"n\">v</span> <span class=\"n\">true</span> <span class=\"n\">l</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">↦</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n                    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x_1</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span>\n                    <span class=\"bp\">|</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n                  <span class=\"n\">t</span> <span class=\"bp\">=</span>\n                <span class=\"n\">eval</span>\n                  <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">w</span> <span class=\"bp\">↦</span>\n                    <span class=\"k\">match</span> <span class=\"n\">AList.lookup</span> <span class=\"n\">w</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">↦</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n                    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x_1</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span>\n                    <span class=\"bp\">|</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n                  <span class=\"n\">t</span>\n              <span class=\"kd\">by</span>\n              <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">ht₁</span><span class=\"o\">]</span>\n              <span class=\"n\">convert</span> <span class=\"n\">this</span>\n            <span class=\"n\">congr</span>\n            <span class=\"n\">ext</span> <span class=\"n\">w</span>\n            <span class=\"n\">by_cases</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"bp\">◾</span>\n</code></pre></div>\n<p>Squeezing the <code>simp</code> yields</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ht₁</span><span class=\"o\">,</span> <span class=\"n\">Option.elim</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">cond_true</span><span class=\"o\">,</span> <span class=\"n\">imp_and_neg_imp_iff</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 431943423,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712575662
    }
]