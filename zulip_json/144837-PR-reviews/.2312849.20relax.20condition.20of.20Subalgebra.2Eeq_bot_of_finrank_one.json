[
    {
        "content": "<p>At first this PR is only about relax the condition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subalgebra.eq_bot_of_finrank_one#doc\">docs#Subalgebra.eq_bot_of_finrank_one</a> from requiring <code>F</code> being a field to <code>F</code> satisfying <code>StrongRankCondition</code> and <code>S</code> being a free <code>F</code>-module.</p>\n<p>But later it turns out that quite a lot of results in the file <code>Mathlib.LinearAlgebra.Dimension.DivisionRing</code> and <code>Mathlib.LinearAlgebra.FiniteDimensional</code> can be generalized by the same way.</p>",
        "id": 438428569,
        "sender_full_name": "Jz Pan",
        "timestamp": 1715626976
    },
    {
        "content": "<p>I don't know if such substantial changes could impact the efficiency of mathlib, namely when the condition relaxed, there will be more typeclass inference steps to deduce that a division ring satisfies <code>StrongRankCondition</code> and any modules over it is free.</p>",
        "id": 438429099,
        "sender_full_name": "Jz Pan",
        "timestamp": 1715627175
    },
    {
        "content": "<p>The first one is a mathematical problem: does the following generalization of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=rank_quotient_add_rank_of_divisionRing#doc\">docs#rank_quotient_add_rank_of_divisionRing</a> true?</p>\n<blockquote>\n<p>If <code>R</code> is a ring satisfying strong rank condition, <code>0 -&gt; N -&gt; M -&gt; M/N -&gt; 0</code> is a short exact sequence of free <code>R</code>-modules, then <code>rank M = rank N + rank M/N</code>?</p>\n</blockquote>\n<p>If it's true, then <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=rank_quotient_add_rank_of_divisionRing#doc\">docs#rank_quotient_add_rank_of_divisionRing</a> follows from it.</p>",
        "id": 438429567,
        "sender_full_name": "Jz Pan",
        "timestamp": 1715627376
    },
    {
        "content": "<p>At least it's true for commutative rings: take any maximal ideal <code>m</code> of <code>R</code>, tensor the above sequence with <code>R/m</code>, since <code>M/N</code> is free (hence flat), we still have a short exact sequence, now the rank-nullity theorem for fields yield the desired result.</p>",
        "id": 438430318,
        "sender_full_name": "Jz Pan",
        "timestamp": 1715627687
    },
    {
        "content": "<p>If <code>rank</code>of a free module is what I think it is, namely the cardinality of a basis, then yes, that holds: take a basis of <code>M/N</code>, lift it to a family in <code>M</code>, add a basis of <code>N</code>, and this is a basis of <code>M</code>.</p>",
        "id": 438431077,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1715627987
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasRankNullity#doc\">docs#HasRankNullity</a> is relevant to your question</p>",
        "id": 438432825,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715628623
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2312849.20relax.20condition.20of.20Subalgebra.2Eeq_bot_of_finrank_one/near/438432825\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasRankNullity#doc\">docs#HasRankNullity</a> is relevant to your question</p>\n</blockquote>\n<p>I already discovered it, but I think that's another direction of the question: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasRankNullity#doc\">docs#HasRankNullity</a> asks that it holds for any modules (hence the ring cannot be arbitrary), whereas I ask it holds only for free modules (hence the condition on the ring can be relaxed).</p>",
        "id": 438433352,
        "sender_full_name": "Jz Pan",
        "timestamp": 1715628831
    },
    {
        "content": "<blockquote>\n<p>But later it turns out that quite a lot of results ... can be generalized by the same way.</p>\n</blockquote>\n<p>It seems that there are too much works; maybe for this PR I only generalize a few selected ones. <span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span></p>",
        "id": 438437651,
        "sender_full_name": "Jz Pan",
        "timestamp": 1715630412
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2312849.20relax.20condition.20of.20Subalgebra.2Eeq_bot_of_finrank_one/near/438431077\">said</a>:</p>\n<blockquote>\n<p>If <code>rank</code>of a free module is what I think it is, namely the cardinality of a basis, then yes, that holds: take a basis of <code>M/N</code>, lift it to a family in <code>M</code>, add a basis of <code>N</code>, and this is a basis of <code>M</code>.</p>\n</blockquote>\n<p>Thank you very much. So basically it is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.Basis</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Basis.ofTest1</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">P</span> <span class=\"n\">ιM</span> <span class=\"n\">ιP</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCancelCommMonoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">bM</span> <span class=\"o\">:</span> <span class=\"n\">Basis</span> <span class=\"n\">ιM</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bP</span> <span class=\"o\">:</span> <span class=\"n\">Basis</span> <span class=\"n\">ιP</span> <span class=\"n\">R</span> <span class=\"n\">P</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Function.Injective</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ginv</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">Function.RightInverse</span> <span class=\"n\">ginv</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Basis</span> <span class=\"o\">(</span><span class=\"n\">ιM</span> <span class=\"bp\">⊕</span> <span class=\"n\">ιP</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"n\">N</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">.</span><span class=\"n\">ofRepr</span> <span class=\"o\">(</span><span class=\"n\">LinearEquiv.ofBijective</span> <span class=\"o\">(</span><span class=\"n\">Finsupp.total</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">&lt;|</span>\n    <span class=\"n\">Sum.elim</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">bM</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ginv</span> <span class=\"bp\">∘</span> <span class=\"n\">bP</span><span class=\"o\">))</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hxy</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The two <code>sorry</code> should be not too hard to prove. But let me postpone this a little bit...</p>",
        "id": 438443281,
        "sender_full_name": "Jz Pan",
        "timestamp": 1715632584
    },
    {
        "content": "<p>Ahh, we already have this: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ModuleCat.free_shortExact#doc\">docs#ModuleCat.free_shortExact</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ModuleCat.free_shortExact_rank_add#doc\">docs#ModuleCat.free_shortExact_rank_add</a></p>",
        "id": 438444234,
        "sender_full_name": "Jz Pan",
        "timestamp": 1715632966
    },
    {
        "content": "<p>But following <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span>'s advice in another thread, the initial result should before types, not for bundled categories. That'll be a but more work...</p>",
        "id": 438505377,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1715665808
    },
    {
        "content": "<p>Yes, I think it's best if we can use this result without importing things in category theory.</p>",
        "id": 438525146,
        "sender_full_name": "Jz Pan",
        "timestamp": 1715675025
    },
    {
        "content": "<p>Some more results are relaxed in <a href=\"https://github.com/leanprover-community/mathlib4/pull/12849\">#12849</a>. Since the relaxed results are essentially for dimension of free modules, I think maybe they should be moved to <code>Mathlib.LinearAlgebra.Dimension.Free</code>? If all the preliminary results are imported. That file is imported by <code>Mathlib.LinearAlgebra.Dimension.DivisionRing</code> and <code>Mathlib.LinearAlgebra.FiniteDimensional</code>.</p>",
        "id": 438800852,
        "sender_full_name": "Jz Pan",
        "timestamp": 1715779397
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/12963\">#12963</a> is a related PR and is ready for review now.</p>",
        "id": 439890856,
        "sender_full_name": "Jz Pan",
        "timestamp": 1716320698
    }
]