[
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/8979\">#8979</a> makes <code>Finsupp.filter</code> computable, which means you can evaluate toy examples like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- What are the odd prime factors of 720?</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">Nat.factorization</span> <span class=\"mi\">720</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"n\">Odd</span>\n<span class=\"c1\">-- prints `fun₀ | 3 =&gt; 2 | 5 =&gt; 1`</span>\n</code></pre></div>\n<p>The downstream fallout is pretty minimal, and just amounts to using <code>Classical.dec*</code> in some downstream proofs.</p>",
        "id": 420898226,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707665310
    },
    {
        "content": "<p>I have no comments, except for some questions.</p>",
        "id": 420904125,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1707669890
    },
    {
        "content": "<p>What should we do with other <code>Finsupp</code> definitions?</p>",
        "id": 420939331,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707701333
    },
    {
        "content": "<p>AFAIR, they were computable, then became noncomputable.</p>",
        "id": 420939364,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707701388
    },
    {
        "content": "<p>I like 2 approaches:</p>\n<h3>Noncomputable definitions</h3>\n<ul>\n<li>the definition is noncomputable and uses <code>Classical</code> instance;</li>\n<li>the <code>_def</code> lemma unfolds it to whatever <code>Decidable*</code> instance we have;</li>\n<li>theorems that rely on the definition don't assume any specific <code>Decidable*</code> instance.</li>\n</ul>\n<p>That's what <code>Finsupp</code> uses now.</p>\n<h3>Computable</h3>\n<ul>\n<li>the definition is computable and assumes whatever <code>Decidable*</code> instances it needs;</li>\n<li>lemmas about this definition assume exactly those <code>Decidable*</code> instances that are used in the type signature;</li>\n<li>e.g., if you need <code>DecidableEq α</code>, <code>DecidableEq β</code>, and <code>DecidableEq (α × β)</code>, then you assume all three, so that the lemma works if you call <code>classical!</code> in a proof.</li>\n</ul>",
        "id": 420948889,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707710734
    },
    {
        "content": "<p>Most of the issues with non-defeq <code>Decidable*</code> assumptions come from lemmas where people assume, e.g., <code>[Fintype α] [DecidablePred p]</code> to get <code>Fintype {x // p x}</code> instead of assuming <code>Fintype {x // p x}</code>.</p>",
        "id": 420948995,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707710820
    },
    {
        "content": "<p>in fact, I think that we should have a linter for this.</p>",
        "id": 420949082,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707710890
    },
    {
        "content": "<p>I tried to write such a linter for Lean 3</p>",
        "id": 420969624,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707724673
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.238979.20making.20Finsupp.2Efilter.20computable/near/420939331\">said</a>:</p>\n<blockquote>\n<p>What should we do with other <code>Finsupp</code> definitions?</p>\n</blockquote>\n<p>I don't think we have to decide this all at once; there is no rule that says \"computability is something we care about on a per-type basis\". I think we can decide on a case-by-case basis depending on how unpleasant the fallout is downstream</p>",
        "id": 420974594,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707726737
    },
    {
        "content": "<p>In particular, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.factorization#doc\">docs#Nat.factorization</a> returns a Finsupp and is computable, so we already cannot claim \"everything around finsupp is noncomputable\".</p>",
        "id": 420974718,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707726792
    }
]