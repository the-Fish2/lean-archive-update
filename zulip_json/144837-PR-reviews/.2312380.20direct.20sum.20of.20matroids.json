[
    {
        "content": "<p>I and <span class=\"user-mention\" data-user-id=\"709805\">@Ivan S.</span> have defined direct sum of matroids using the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IndepMatroid#doc\">docs#IndepMatroid</a> definition. We would like to hear what you think.</p>",
        "id": 435008259,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1713885360
    },
    {
        "content": "<p>Where should our lemmas about sets that aren't basic enough to be part of the <code>Set</code> API go?</p>",
        "id": 435042897,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1713896235
    },
    {
        "content": "<p>Can you give some example lemmas?</p>",
        "id": 435044823,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713896919
    },
    {
        "content": "<p>This is the list of all lemmas in question:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">Set.union_inters_of_subset_union</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span> <span class=\"bp\">∪</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">B</span> <span class=\"bp\">∪</span> <span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span> <span class=\"bp\">=</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">aesop</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.subset_inter_of_redundant_right</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hADB</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"n\">D</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hAC</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Set.subset_inter</span> <span class=\"o\">((</span><span class=\"n\">Set.subset_union_left</span> <span class=\"n\">A</span> <span class=\"n\">D</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">hADB</span><span class=\"o\">)</span> <span class=\"n\">hAC</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.subset_inter_of_redundant_left</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hDAB</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">∪</span> <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hAC</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Set.subset_inter</span> <span class=\"o\">((</span><span class=\"n\">Set.subset_union_right</span> <span class=\"n\">D</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">hDAB</span><span class=\"o\">)</span> <span class=\"n\">hAC</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.union_inter_aux</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hAB</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"n\">C</span> <span class=\"bp\">∩</span> <span class=\"n\">D</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span> <span class=\"bp\">∪</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"n\">C</span> <span class=\"bp\">∩</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.inter_union_aux</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hAB</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">C</span> <span class=\"bp\">∩</span> <span class=\"n\">D</span> <span class=\"bp\">∪</span> <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"bp\">∩</span> <span class=\"n\">D</span> <span class=\"bp\">∪</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">D</span> <span class=\"bp\">∪</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.union_inter_supset_left_of_disjoint</span> <span class=\"o\">{</span><span class=\"n\">I₁</span> <span class=\"n\">I₂</span> <span class=\"n\">E₁</span> <span class=\"n\">E₂</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hE</span> <span class=\"o\">:</span> <span class=\"n\">E₁</span> <span class=\"bp\">∩</span> <span class=\"n\">E₂</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hI</span> <span class=\"o\">:</span> <span class=\"n\">I₂</span> <span class=\"bp\">⊆</span> <span class=\"n\">E₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">I₁</span> <span class=\"bp\">∪</span> <span class=\"n\">I₂</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">E₁</span> <span class=\"bp\">=</span> <span class=\"n\">E₁</span> <span class=\"bp\">∩</span> <span class=\"n\">I₁</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.union_inter_supset_right_of_disjoint</span> <span class=\"o\">{</span><span class=\"n\">I₁</span> <span class=\"n\">I₂</span> <span class=\"n\">E₁</span> <span class=\"n\">E₂</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hE</span> <span class=\"o\">:</span> <span class=\"n\">E₁</span> <span class=\"bp\">∩</span> <span class=\"n\">E₂</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hI</span> <span class=\"o\">:</span> <span class=\"n\">I₁</span> <span class=\"bp\">⊆</span> <span class=\"n\">E₁</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">I₁</span> <span class=\"bp\">∪</span> <span class=\"n\">I₂</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">E₂</span> <span class=\"bp\">=</span> <span class=\"n\">E₂</span> <span class=\"bp\">∩</span> <span class=\"n\">I₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.subset_iff_subsets_of_disjoint</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">E₁</span> <span class=\"n\">E₂</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">E₁</span> <span class=\"bp\">∪</span> <span class=\"n\">E₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span> <span class=\"bp\">↔</span> <span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">E₁</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span> <span class=\"bp\">∩</span> <span class=\"n\">E₁</span> <span class=\"bp\">∧</span> <span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">E₂</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span> <span class=\"bp\">∩</span> <span class=\"n\">E₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.between_inter</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"n\">T</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hIT</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">⊆</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hTX</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">⊆</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">I</span> <span class=\"bp\">∩</span> <span class=\"n\">E</span> <span class=\"bp\">⊆</span> <span class=\"n\">T</span> <span class=\"bp\">∩</span> <span class=\"n\">E</span> <span class=\"bp\">∧</span> <span class=\"n\">T</span> <span class=\"bp\">∩</span> <span class=\"n\">E</span> <span class=\"bp\">⊆</span> <span class=\"n\">X</span> <span class=\"bp\">∩</span> <span class=\"n\">E</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">Set.inter_subset_inter_left</span> <span class=\"n\">E</span> <span class=\"n\">hIT</span><span class=\"o\">,</span> <span class=\"n\">Set.inter_subset_inter_left</span> <span class=\"n\">E</span> <span class=\"n\">hTX</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.union_inter_eq_fst</span> <span class=\"o\">{</span><span class=\"n\">S₁</span> <span class=\"n\">S₂</span> <span class=\"n\">E₁</span> <span class=\"n\">E₂</span> <span class=\"n\">X₁</span> <span class=\"n\">X₂</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hE</span> <span class=\"o\">:</span> <span class=\"n\">E₁</span> <span class=\"bp\">∩</span> <span class=\"n\">E₂</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hX₁</span> <span class=\"o\">:</span> <span class=\"n\">S₁</span> <span class=\"bp\">⊆</span> <span class=\"n\">X₁</span> <span class=\"bp\">∩</span> <span class=\"n\">E₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hX₂</span> <span class=\"o\">:</span> <span class=\"n\">S₂</span> <span class=\"bp\">⊆</span> <span class=\"n\">X₂</span> <span class=\"bp\">∩</span> <span class=\"n\">E₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">S₁</span> <span class=\"bp\">∪</span> <span class=\"n\">S₂</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">E₁</span> <span class=\"bp\">=</span> <span class=\"n\">S₁</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.union_inter_eq_snd</span> <span class=\"o\">{</span><span class=\"n\">S₁</span> <span class=\"n\">S₂</span> <span class=\"n\">E₁</span> <span class=\"n\">E₂</span> <span class=\"n\">X₁</span> <span class=\"n\">X₂</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hE</span> <span class=\"o\">:</span> <span class=\"n\">E₁</span> <span class=\"bp\">∩</span> <span class=\"n\">E₂</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hX₁</span> <span class=\"o\">:</span> <span class=\"n\">S₁</span> <span class=\"bp\">⊆</span> <span class=\"n\">X₁</span> <span class=\"bp\">∩</span> <span class=\"n\">E₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hX₂</span> <span class=\"o\">:</span> <span class=\"n\">S₂</span> <span class=\"bp\">⊆</span> <span class=\"n\">X₂</span> <span class=\"bp\">∩</span> <span class=\"n\">E₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">S₁</span> <span class=\"bp\">∪</span> <span class=\"n\">S₂</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">E₂</span> <span class=\"bp\">=</span> <span class=\"n\">S₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 435045181,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1713897079
    },
    {
        "content": "<p>I don't think we want any of them</p>",
        "id": 435050294,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713898975
    },
    {
        "content": "<p>You can just reprove on the fly wherever needed</p>",
        "id": 435050337,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713898989
    },
    {
        "content": "<p>Are you suggesting we use less modularity in our proofs?</p>",
        "id": 435050391,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1713899013
    },
    {
        "content": "<p>Surely avoiding stating idiosyncratic lemmas makes your proofs <em>more</em> modular?</p>",
        "id": 435050519,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713899045
    },
    {
        "content": "<p>It should be possible state an ad-hoc lemma somewhere. Maybe a private lemma inside our file?</p>",
        "id": 435050787,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1713899168
    },
    {
        "content": "<p>An important consideration is whether anyone is ever going to find these lemmas; the more arbitrary the lemma statement, the more likely that no one ever finds it, or worse that they contribute it independently with another unfindable name</p>",
        "id": 435050862,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713899201
    },
    {
        "content": "<p>If you replace <code>E₁ ∩ E₂ = ∅</code> with <code>Disjoint E₁ E₂</code> you might find that more of these lemmas exist</p>",
        "id": 435050938,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713899237
    },
    {
        "content": "<p>Take eg</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">Set.union_inter_eq_fst</span> <span class=\"o\">{</span><span class=\"n\">S₁</span> <span class=\"n\">S₂</span> <span class=\"n\">E₁</span> <span class=\"n\">E₂</span> <span class=\"n\">X₁</span> <span class=\"n\">X₂</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hE</span> <span class=\"o\">:</span> <span class=\"n\">E₁</span> <span class=\"bp\">∩</span> <span class=\"n\">E₂</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hX₁</span> <span class=\"o\">:</span> <span class=\"n\">S₁</span> <span class=\"bp\">⊆</span> <span class=\"n\">X₁</span> <span class=\"bp\">∩</span> <span class=\"n\">E₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hX₂</span> <span class=\"o\">:</span> <span class=\"n\">S₂</span> <span class=\"bp\">⊆</span> <span class=\"n\">X₂</span> <span class=\"bp\">∩</span> <span class=\"n\">E₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">S₁</span> <span class=\"bp\">∪</span> <span class=\"n\">S₂</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">E₁</span> <span class=\"bp\">=</span> <span class=\"n\">S₁</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>This is a very non-modular lemma: <code>X₁</code> and <code>X₂</code> appear in a single place each, so you might as well assume they're <code>univ</code>. If you do that, you get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">Set.union_inter_eq_fst'</span> <span class=\"o\">{</span><span class=\"n\">S₁</span> <span class=\"n\">S₂</span> <span class=\"n\">E₁</span> <span class=\"n\">E₂</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hE</span> <span class=\"o\">:</span> <span class=\"n\">E₁</span> <span class=\"bp\">∩</span> <span class=\"n\">E₂</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hX₁</span> <span class=\"o\">:</span> <span class=\"n\">S₁</span> <span class=\"bp\">⊆</span> <span class=\"n\">E₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hX₂</span> <span class=\"o\">:</span> <span class=\"n\">S₂</span> <span class=\"bp\">⊆</span> <span class=\"n\">E₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">S₁</span> <span class=\"bp\">∪</span> <span class=\"n\">S₂</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">E₁</span> <span class=\"bp\">=</span> <span class=\"n\">S₁</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>which is better, but not quite there yet, since you can rewrite the conclusion using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.union_inter_distrib_right#doc\">docs#Set.union_inter_distrib_right</a> to be <code>S₁ ∩ E₁ ∪ S₂ ∩ E₁ = S₁</code>. Then use <code>hX₁</code> to rewrite that to <code>S₁ ∪ S₂ ∩ E₁ = S₁</code>. And now I really don't see what's the point of having the lemma</p>",
        "id": 435051234,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713899361
    },
    {
        "content": "<p>I think a lot of this is sort of a symptom that the design of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matroid#doc\">docs#Matroid</a> doesn't mesh well with the rest of the library (c.f. the discussion <a href=\"#narrow/stream/287929-mathlib4/topic/Matroids.20in.20mathlib.20-.20feedback.3F/near/377319685\">here</a>), and it forces you to write <code>A : set \\alpha</code> and use <code>A \\inter B</code> everywhere, instead of just using <code>A : Set \\beta</code></p>",
        "id": 435051742,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713899573
    },
    {
        "content": "<p>For example <code>Set.between_inter</code> shouldn't be a public lemma because it is simply a conjunction of two instances of an existing lemma. At the same time, it is useful for our bigger proof because we have expressions in exactly this form. So a private lemma be it?</p>",
        "id": 435051939,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1713899656
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2312380.20direct.20sum.20of.20matroids/near/435051234\">said</a>:</p>\n<blockquote>\n<p>And now I really don't see what's the point of having the lemma</p>\n</blockquote>\n<p>The point is that it becomes a single step for the caller, which is a more complicated proof.</p>",
        "id": 435052749,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1713900004
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2312380.20direct.20sum.20of.20matroids/near/435050862\">said</a>:</p>\n<blockquote>\n<p>An important consideration is whether anyone is ever going to find these lemmas; the more arbitrary the lemma statement, the more likely that no one ever finds it, or worse that they contribute it independently with another unfindable name</p>\n</blockquote>\n<p>Should the lemma be reusable, other users will find it by <code>exact?</code> and not by the lemma name (but that doesn't mean that the name doesn't matter; we welcome your suggestions for renames). Otherwise, I'd make it a private lemma.</p>",
        "id": 435054536,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1713900699
    },
    {
        "content": "<p>Anyways, before we dive into the low-level stuff, is this (as the main definition) all right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Direct sum of matroids as a matroid. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Matroid.directSum</span> <span class=\"o\">{</span><span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"n\">Matroid</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hME</span> <span class=\"o\">:</span> <span class=\"n\">M₁.E</span> <span class=\"bp\">∩</span> <span class=\"n\">M₂.E</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Matroid</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">indepMatroidDirectSum</span> <span class=\"n\">hME'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">matroid</span> <span class=\"n\">where</span>\n  <span class=\"n\">hME'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">M₁.restrictIndepMatroid</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">E</span> <span class=\"bp\">∩</span> <span class=\"o\">(</span><span class=\"n\">M₂.restrictIndepMatroid</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">E</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span> <span class=\"n\">hME</span>\n</code></pre></div>\n<p>This is the part of code I am the least sure about.</p>",
        "id": 435165298,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1713957262
    },
    {
        "content": "<p>Surely it should rather be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Matroid.sum</span> <span class=\"o\">(</span><span class=\"n\">M₁</span> <span class=\"o\">:</span> <span class=\"n\">Matroid</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"n\">Matroid</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Matroid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⊕</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 435174649,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713960551
    },
    {
        "content": "<p>Disjointness can be be achieved either by requiring disjoint ground sets or by having each matroid over a different type. This is a design decision that was hard for us to navigate.</p>\n<p>As a matter of fact, we are also working on matroid mappings.<br>\n<a href=\"https://github.com/madvorak/matroids\">https://github.com/madvorak/matroids</a><br>\nShould the change of the directSum definition be made right away, or can we first define it over the same type (as we did) and then provide a wrapper for matroids of different types (as we were going to do)?</p>",
        "id": 435187114,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1713964591
    },
    {
        "content": "<p>The whole matroid thing seems to be a mess <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 435187623,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713964739
    },
    {
        "content": "<p>This is a thread for general issues about Matroids:<br>\n<a href=\"#narrow/stream/287929-mathlib4/topic/Matroids.20in.20mathlib.20-.20feedback.3F/near/377319685\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Matroids.20in.20mathlib.20-.20feedback.3F/near/377319685</a></p>\n<p>This is a thread for general issues about ad-hoc lemmas:<br>\n<a href=\"#narrow/stream/287929-mathlib4/topic/Philosophy.3A.20single-purpose.20lemma\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Philosophy.3A.20single-purpose.20lemma</a></p>\n<p>Let's keep this thread focused on our PR only.</p>",
        "id": 435189769,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1713965326
    },
    {
        "content": "<p>So, a plan for refactoring would be...</p>\n<p>Instead of defining</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">indepMatroidDirectSum</span> <span class=\"o\">{</span><span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"n\">IndepMatroid</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hME</span> <span class=\"o\">:</span> <span class=\"n\">M₁.E</span> <span class=\"bp\">∩</span> <span class=\"n\">M₂.E</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IndepMatroid</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>we would define</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">IndepMatroid.sum</span> <span class=\"o\">(</span><span class=\"n\">M₁</span> <span class=\"o\">:</span> <span class=\"n\">IndepMatroid</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"n\">IndepMatroid</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IndepMatroid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⊕</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>as the definition that does the \"heavy lifting\".</p>\n<p>At the end, we would provide a wrapper</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Matroid.sum</span> <span class=\"o\">(</span><span class=\"n\">M₁</span> <span class=\"o\">:</span> <span class=\"n\">Matroid</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"n\">Matroid</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Matroid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⊕</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">IndepMatroid.sum</span>\n    <span class=\"o\">(</span><span class=\"n\">M₁.restrictIndepMatroid</span> <span class=\"n\">M₁.E</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">M₂.restrictIndepMatroid</span> <span class=\"n\">M₂.E</span><span class=\"o\">)</span>\n  <span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">matroid</span>\n</code></pre></div>\n<p>for the base matroids.</p>",
        "id": 435242920,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1713980905
    },
    {
        "content": "<p>I don't have a completely fleshed out idea here, but something that might be useful is to explore how to cleanly transition between <code>Set X</code> and <code>Set A</code> when <code>A : Set X</code>.</p>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Subset.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Subset.html</a> has some of this. There's notation <code>A ↓∩ B</code> to take the intersection of <code>A</code> and <code>B</code> (both in <code>Set X</code>) and land inside <code>Set A</code>.</p>\n<p>I didn't see this theorem anywhere, but it would help with going back and forth between <code>Set A</code> and <code>Set X</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">Set.Notation</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">↓∩</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"n\">A</span> <span class=\"bp\">↓∩</span> <span class=\"n\">C</span> <span class=\"bp\">↔</span> <span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">h</span>\n    <span class=\"n\">ext</span> <span class=\"n\">x</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span>\n    <span class=\"bp\">·</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">congr</span><span class=\"o\">(⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">h</span><span class=\"o\">)</span>\n      <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">h</span>\n    <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">congr</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">h</span><span class=\"o\">)</span>\n    <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">this</span>\n</code></pre></div>",
        "id": 435246635,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713982228
    },
    {
        "content": "<p>This came to mind because a number of lemmas seemed to be working \"under a <code>A ∩ ...</code>\", so transitioning to <code>Set A</code> and setting up automation to help with this might be beneficial.</p>",
        "id": 435247105,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713982387
    },
    {
        "content": "<p>Yes, both \"subset of intersection\" and \"supset of intersection\" appeared many times in our construction. However, note that most of it will change with the refactor I proposed above.</p>",
        "id": 435247647,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1713982572
    },
    {
        "content": "<p>That theorem is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subtype.preimage_val_eq_preimage_val_iff#doc\">docs#Subtype.preimage_val_eq_preimage_val_iff</a></p>",
        "id": 435274836,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713993771
    },
    {
        "content": "<p>Should we update the \"preimage_val\" theorems with the new notation?</p>",
        "id": 435279171,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1713995918
    },
    {
        "content": "<p>I created a new thread <a href=\"#narrow/stream/287929-mathlib4/topic/Updating.20preimage_val.20to.20use.20.E2.86.93.E2.88.A9.20notation/near/435280958\">here</a> for the previous question.</p>",
        "id": 435279685,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1713996136
    },
    {
        "content": "<p>there will be a need for both an 'external direct sum' <br>\n<code>Matroid.sum (M₁ : Matroid α) (M₂ : Matroid β) : Matroid (α ⊕ β) </code> and an 'internal direct sum' <br>\n<code>Matroid.sum' (M₁ M₂ : Matroid α) : Matroid α</code>. <br>\nThere should also be indexed versions of both for summing more than two matroids. </p>\n<p>This is analogous to other things in mathlib; the first <code>Matroid.sum</code> is like the direct sum of two groups, and <code>Matroid.sum'</code> is like the supremum of two subgroups. </p>\n<p>Internal direct sum needs a proof term of disjointness to be useful, but it can probably be defined without one. <br>\n(Really, <code>Matroid.sum'</code> should be a specialization of matroid union, but that's not yet sorted out even informally for infinite matroids. )</p>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2312380.20direct.20sum.20of.20matroids/near/435187623\">said</a>:</p>\n<blockquote>\n<p>The whole matroid thing seems to be a mess <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>\n</blockquote>\n<p>Not constructive. Please read the other thread, engage with the actual issues and respond if you think you know a way to improve the design. I would love to hear it.</p>",
        "id": 435284144,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1713998769
    },
    {
        "content": "<p>Just to check I understand correctly; is it definitely <code>α ⊕ β</code> and not <code>α × β</code>? The direct sum of groups is the latter.</p>",
        "id": 435287715,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714001120
    },
    {
        "content": "<p>Oh, my mistake. The general principle is true though - you can define sum-like operations of <code>Subgroup</code>s, <code>Submodule</code>s, <code>Subgraph</code>s etc within a fixed type, but you can also combine <code>Group</code>/<code>Module</code>/<code>SimpleGraph</code> with sums that give you objects on sum types.</p>\n<p>I don't know offhand a notion of the product of two matroids, but I haven't thought hard about this.</p>",
        "id": 435290986,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1714003754
    },
    {
        "content": "<p>So yes, the type signature <code>Matroid.sum (M₁ : Matroid α) (M₂ : Matroid β) : Matroid (α ⊕ β)</code>is definitely right for external direct sum.</p>",
        "id": 435291166,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1714003921
    },
    {
        "content": "<p>For the record, I already gave you an alternative design which seems strictly better to me (from poking around in your repo), namely remove the <code>ground</code> field and instead have a <code>IsSupportedOn</code> predicate checking that everything is defined on a given ground set.</p>",
        "id": 435315835,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1714023758
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2312380.20direct.20sum.20of.20matroids/near/435284144\">said</a>:</p>\n<blockquote>\n<p>Really, <code>Matroid.sum'</code> should be a specialization of matroid union, but that's not yet sorted out even informally for infinite matroids. </p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"709805\">@Ivan S.</span> has an idea how to get from direct sum to union of (potentially infinite) matroids afaik.</p>",
        "id": 435326710,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1714029442
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2312380.20direct.20sum.20of.20matroids/near/435291166\">said</a>:</p>\n<blockquote>\n<p>So yes, the type signature <code>Matroid.sum (M₁ : Matroid α) (M₂ : Matroid β) : Matroid (α ⊕ β)</code>is definitely right for external direct sum.</p>\n</blockquote>\n<p>And is <code>M₁.restrictIndepMatroid M₁.E</code> the canonical way how to get from <code>Matroid</code> to <code>IndepMatroid</code> without losing anything?</p>",
        "id": 435326990,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1714029566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2312380.20direct.20sum.20of.20matroids/near/435315835\">said</a>:</p>\n<blockquote>\n<p>For the record, I already gave you an alternative design which seems strictly better to me (from poking around in your repo), namely remove the <code>ground</code> field and instead have a <code>IsSupportedOn</code> predicate checking that everything is defined on a given ground set.</p>\n</blockquote>\n<p>Ok - this was back in the lean3 days, right? Can you please elaborate on this in the other thread?</p>",
        "id": 435361052,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1714041829
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2312380.20direct.20sum.20of.20matroids/near/435326990\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2312380.20direct.20sum.20of.20matroids/near/435291166\">said</a>:</p>\n<blockquote>\n<p>So yes, the type signature <code>Matroid.sum (M₁ : Matroid α) (M₂ : Matroid β) : Matroid (α ⊕ β)</code>is definitely right for external direct sum.</p>\n</blockquote>\n<p>And is <code>M₁.restrictIndepMatroid M₁.E</code> the canonical way how to get from <code>Matroid</code> to <code>IndepMatroid</code> without losing anything?</p>\n</blockquote>\n<p>The idea is that you should never be wanting to get to <code>IndepMatroid</code> from anywhere else, except when defining a matroid coming from something that isn't yet a matroid.</p>",
        "id": 435568554,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1714131412
    },
    {
        "content": "<p>an <code>IndepMatroid</code> is an intermediate object whose job is to produce a <code>Matroid</code>, and nothing more.</p>",
        "id": 435568673,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1714131472
    },
    {
        "content": "<p>Originally the design had a lot of <code>matroidOf****OfIndep</code> lemmas that encoded the various ways to define a matroid via independent sets - <code>IndepMatroid</code> was suggested in review as a way to tidy those up. </p>\n<p>Based on what I’ve seen in this PR, I think that this might be less than obvious to someone coming in and looking at the docstrings. I’ll try to update them to clarify the design intention.</p>",
        "id": 435576208,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1714134470
    }
]