[
    {
        "content": "<p>I'd appreciate feedback on <a href=\"https://github.com/leanprover-community/mathlib4/pull/10725\">#10725</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/10728\">#10728</a>, which are part of a sequence extending the material on L-series in Mathlib.</p>",
        "id": 422590170,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1708512594
    },
    {
        "content": "<p><span aria-label=\"ping pong\" class=\"emoji emoji-1f3d3\" role=\"img\" title=\"ping pong\">:ping_pong:</span></p>",
        "id": 422784979,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1708596776
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/10728\">#10728</a> has an approving review (thanks, <span class=\"user-mention\" data-user-id=\"481963\">@David Loeffler</span> !). Maybe someone else can have a look?<br>\nAlso, could somebody with knowledge on coercions look at <a href=\"https://github.com/leanprover-community/mathlib4/pull/10725\">#10725</a> ? The way I have set up things does work well in my downstream code, but I may be ignorant of some subtleties.<br>\n(These PRs will eventually be relevant for PNT+.)</p>",
        "id": 423466747,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1708974956
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/10728\">#10728</a> is now merged, thanks! However, I still need <a href=\"https://github.com/leanprover-community/mathlib4/pull/10725\">#10725</a> to proceed with the next installment of PRs on L-series. Can I do something (more) to entice people to look at it?</p>",
        "id": 423623597,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709045434
    },
    {
        "content": "<p>You could fix the merge conflict which just appeared 1 minute ago? ;-)</p>",
        "id": 423623834,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709045504
    },
    {
        "content": "<p>Too bad the two new filenames ended up at the same place in <code>Mathlib.lean</code>...</p>",
        "id": 423626508,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709046124
    },
    {
        "content": "<p>I looked at the second one but I don't feel qualified to comment on</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">instCoeHead</span> <span class=\"o\">:</span> <span class=\"n\">CoeHead</span> <span class=\"o\">(</span><span class=\"n\">ArithmeticFunction</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ArithmeticFunction</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">toComplexArithmeticFunction</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">R</span><span class=\"o\">)⟩</span>\n</code></pre></div>\n<p>If someone who knew something about coercions could give this a nod, then everything else looks uncontroversial...</p>",
        "id": 423626826,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709046197
    },
    {
        "content": "<p>Actually, why don't you coerce from <code>ArithmeticFunction R</code> to <code>ArithmeticFunction A</code> for any <code>[Algebra R A]</code>?</p>",
        "id": 423627115,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709046277
    },
    {
        "content": "<p>I think this gives problems because there are too many possibilities for what <code>R</code> and <code>A</code> can be (and there are already coercions when <code>R</code> is <code>Nat</code> or <code>Int</code>, I believe). IIRC, I tried something like that, and it didn't work as intended.</p>",
        "id": 423627475,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709046384
    },
    {
        "content": "<p>Similarly I was going to say that I could imagine working with <code>IsScalarTower</code> for things like <code>toComplexArithmeticFunction_int_nat</code> but you're going to tell me that that has the same problems?</p>",
        "id": 423627880,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709046493
    },
    {
        "content": "<p>But if there is a way to make it work in this generality (including <code>norm_cast</code> working to allow sums/products/pointwise products of arithmetic functions with different codomains), I would change it. I certainly don't know more about coercions than you do <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 423628071,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709046555
    },
    {
        "content": "<p>In any case, I don't think there is much harm in using the version as is currently in the PR. It should be easy to make it more general later if possible and desired.</p>",
        "id": 423628334,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709046626
    },
    {
        "content": "<p>I had the same reaction as Kevin, that a more general approach for generic source and target rings satisfying suitable typeclass assumptions would be nicer than a hard-coded list of special cases. Can you let us know what goes wrong if one tries this?</p>",
        "id": 423630392,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709047187
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">coe</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">toComplexArithmeticFunction</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ArithmeticFunction</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ArithmeticFunction</span> <span class=\"n\">C</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">algebraMap</span> <span class=\"n\">R</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">map_zero</span><span class=\"o\">,</span> <span class=\"n\">_root_.map_zero</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instCoeHead</span> <span class=\"o\">:</span> <span class=\"n\">CoeHead</span> <span class=\"o\">(</span><span class=\"n\">ArithmeticFunction</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ArithmeticFunction</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">toComplexArithmeticFunction</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">C</span><span class=\"o\">)⟩</span>\n</code></pre></div>\n<p>gives</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">cannot</span> <span class=\"n\">find</span> <span class=\"n\">synthesization</span> <span class=\"n\">order</span> <span class=\"n\">for</span> <span class=\"kd\">instance</span> <span class=\"bp\">@</span><span class=\"n\">instCoeHead</span> <span class=\"k\">with</span> <span class=\"n\">type</span>\n  <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n    <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n      <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"bp\">→</span>\n        <span class=\"o\">[</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">CommSemiring</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">CoeHead</span> <span class=\"o\">(</span><span class=\"n\">ArithmeticFunction</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ArithmeticFunction</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"n\">all</span> <span class=\"n\">remaining</span> <span class=\"n\">arguments</span> <span class=\"k\">have</span> <span class=\"n\">metavariables</span><span class=\"o\">:</span>\n  <span class=\"n\">CommSemiring</span> <span class=\"bp\">?</span><span class=\"n\">C</span>\n  <span class=\"bp\">@</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"bp\">?</span><span class=\"n\">C</span> <span class=\"n\">inst</span><span class=\"bp\">✝²</span> <span class=\"n\">CommSemiring.toSemiring</span>\n</code></pre></div>\n<p>and adding <code>outParam</code> to the first or second argument does not help. (But I don't really know what I'm doing here.)</p>",
        "id": 423631860,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709047631
    },
    {
        "content": "<p>Surely that's a question for <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> ?</p>",
        "id": 423631980,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709047674
    },
    {
        "content": "<p>Fixing the complex numbers as target avoids this problem (and is what I need for L-series).</p>",
        "id": 423632153,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709047721
    },
    {
        "content": "<p><code>CoeTail</code> in place of <code>CoeHead</code> complains (not surprisingly) about <code>R</code> instead of <code>C</code>.</p>",
        "id": 423632525,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709047820
    },
    {
        "content": "<p>(The merge conflict is gone now, BTW.)</p>",
        "id": 423632657,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709047871
    },
    {
        "content": "<p>You can mute the linter by adding</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">synthInstance.checkSynthOrder</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n</code></pre></div>\n<p>but I do not know if it is a good idea or not...</p>",
        "id": 423633004,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1709047959
    },
    {
        "content": "<p>And then you have to check that (a) it actually fires and (b) it doesn't go into an infinite loop...</p>",
        "id": 423633705,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709048149
    },
    {
        "content": "<p>Can you not do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Algebra</span> <span class=\"o\">(</span><span class=\"n\">ArithmeticFunction</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ArithmeticFunction</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>and then use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=algebraMap#doc\">docs#algebraMap</a> ?</p>",
        "id": 423634637,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709048304
    },
    {
        "content": "<p>To me, this seems like a bad job for a coercion</p>",
        "id": 423635168,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709048387
    },
    {
        "content": "<p>I'd like to write <code>LSeries f</code> when <code>f : ArithmeticFunction R</code> (and <code>R = Nat, Int, Real</code>), so I do want a coercion. Whether it's <code>algebraMap</code> under the hood or not I don't care.</p>",
        "id": 423635603,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709048452
    },
    {
        "content": "<p>Would it be the end of the world if you had to write <code>LSeries (algebraMap _ _ f)</code>?</p>",
        "id": 423636942,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709048647
    },
    {
        "content": "<p>It looks like in order to define an <code>Algebra</code> instance in a reasonable way, I need the coercion first: the <code>Smul</code> instance morally is given by <code>f * g</code>,  but to write it like this (and not repeat the (complicated) definition of multiplication of arithmetic functions), I need to turn <code>f</code> into an arithmetic function with values in <code>C</code>.</p>",
        "id": 423637296,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709048705
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310725.20and.20.2310728.3A.20L-series/near/423636942\">said</a>:</p>\n<blockquote>\n<p>Would it be the end of the world if you had to write <code>LSeries (algebraMap _ _ f)</code>?</p>\n</blockquote>\n<p>This is very ugly.</p>",
        "id": 423637405,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709048722
    },
    {
        "content": "<p>In particular since what I have does do what it is intended to do quite nicely.</p>",
        "id": 423638065,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709048830
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310725.20and.20.2310728.3A.20L-series/near/423638065\">said</a>:</p>\n<blockquote>\n<p>This is very ugly. In particular since what I have does do what it is intended to do quite nicely.</p>\n</blockquote>\n<p>Having long lists of hard-coded lemmas for particular input and output rings is pretty ugly too, IMHO.</p>\n<p>It also strikes me that for a lot of \"natural\" L-series (Dirichlet characters, modular form L-series, etc), the coefficients <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>a</mi><mi>n</mi></msub><msub><mo stretchy=\"false\">)</mo><mrow><mi>n</mi><mo>≥</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">(a_n)_{n \\ge 1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mrel mtight\">≥</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2452em;\"><span></span></span></span></span></span></span></span></span></span> actually live in a number field, and it's convenient to be able to regard the L-series coming from different embeddings of that field into <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> as being on the same footing. So I think assigning an L-series to a pair (R-valued arithmetic function, embedding of R into <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>) – which is what Yaël is suggesting – actually has something going for it from the theoretical side too.</p>",
        "id": 423641767,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709049469
    },
    {
        "content": "<p>I'll think about that. I would like to avoid having to deal with an explicit embedding all the time when manipulating L-series explicitly, though. Maybe keep <code>LSeries</code> as is and add a version <code>LSeries' </code> (or so) that takes an embedding into <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> as an additional argument? Can we let it default to the algebra map if it exists?</p>",
        "id": 423654817,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709053011
    },
    {
        "content": "<p>Anyway, currently:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.NumberTheory.VonMangoldt</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ArithmeticFunction</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">ζ</span> <span class=\"o\">:</span> <span class=\"n\">ArithmeticFunction</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"c1\">-- OK</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"bp\">Λ</span> <span class=\"o\">:</span> <span class=\"n\">ArithmeticFunction</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"c1\">-- not OK</span>\n</code></pre></div>\n<p>which is not so nice...</p>",
        "id": 423655166,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709053098
    },
    {
        "content": "<p>The point being that <code>ζ</code> is <code>Nat</code>-valued while <code>Λ</code>is <del><code>Int</code></del> real-valued? If anything, I'd take this as an argument that the whole <code>ArithmeticFunction</code> type is more trouble than it's worth, and we should be attaching L-series to plain functions on Nat.</p>",
        "id": 423657406,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709053753
    },
    {
        "content": "<p>The one defining property of an <code>ArithmeticFunction</code>, namely that it sends 0 to 0, is actually really inconvenient anyway in my approach to Dirichlet L-functions via Hurwitz zeta, where the function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi mathvariant=\"normal\">∞</mi></msubsup><mfrac><msup><mi>e</mi><mrow><mi>i</mi><mi>n</mi><mi>θ</mi></mrow></msup><msup><mi>n</mi><mi>s</mi></msup></mfrac></mrow><annotation encoding=\"application/x-tex\">\\sum_{n = 1}^\\infty \\tfrac{e^{i n \\theta}}{n^s}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.3879em;vertical-align:-0.345em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8043em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">∞</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0429em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5935em;\"><span style=\"top:-2.786em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.927em;\"><span style=\"top:-2.931em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">θ</span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> comes up very naturally.</p>",
        "id": 423658009,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709053948
    },
    {
        "content": "<p>To pick up <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span>'s suggestion from above:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">synthInstance.checkSynthOrder</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n<span class=\"kd\">instance</span> <span class=\"n\">instCoeHead</span> <span class=\"o\">:</span> <span class=\"n\">CoeHead</span> <span class=\"o\">(</span><span class=\"n\">ArithmeticFunction</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ArithmeticFunction</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">toComplexArithmeticFunction</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">C</span><span class=\"o\">)⟩</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">ArithmeticFunction.log</span> <span class=\"o\">:</span> <span class=\"n\">ArithmeticFunction</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"c1\">-- error</span>\n</code></pre></div>\n<p>so the coercion doesn't fire.</p>",
        "id": 423668208,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709057313
    },
    {
        "content": "<p>There was the suggestion to use functions on <code>PNat</code>...</p>",
        "id": 423670316,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709058086
    },
    {
        "content": "<p>Anyway, just using <code>ℕ → R</code> has the problem that we want to put a ring instance on whatever type we use, where multiplication is Dirichlet convolution and not point-wise multiplication. I assume that this more or less forces us to use a type synonym, which there is good reason to call <code>ArithmeticFunction</code>. The following are some options:</p>\n<ol>\n<li>keep the current set-up</li>\n<li>define <code>ArithmeticFunction R</code> as a type synonym of <code>ℕ → R</code> and essentially ignore the value at zero</li>\n<li>define <code>ArithmeticFunction R</code> as a type synonym of <code>PNat → R</code></li>\n</ol>\n<p>Option 3. has the disadvantage that <code>PNat</code> is not a <code>CommSemiring</code>, but this is perhaps not much of a problem.</p>",
        "id": 423671493,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709058494
    },
    {
        "content": "<p>Doing some experiments...<br>\nWorking with <code>PNat</code> seems quite OK so far. except that there are no <code>PNat</code> versions of <code>Summable.of_norm_bounded_eventually_nat</code> and <code>Real.summable_nat_rpow</code> (and probably similar ones).<br>\nOn the other hand, many proofs are shorter because there is no need to deal with <code>n = 0</code> separately.</p>",
        "id": 423674584,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709059759
    },
    {
        "content": "<p>Is option 2 possible without breaking the ring instance? I suspect not. Option 3 seems more natural to me. I guess it should be easy to get the summability results out of their <code>Nat</code>versions using <code>Summable.comp_injective</code>.</p>",
        "id": 423675103,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709059941
    },
    {
        "content": "<p>This is basically <code>Summable.subtype</code>. The other direction is more tricky.</p>",
        "id": 423676199,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709060353
    },
    {
        "content": "<p>Option 2. works via <code>def ArithmeticFunction (R : Type u) [CommSemiring R] : Type u := ℕ → R</code> and copying over the additive part ofthe structure, but defining a new multiplication.<br>\nOption 3. would be similar in this respect.</p>",
        "id": 423676617,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709060493
    },
    {
        "content": "<p>I'll try to look further into this tomorrow. It still doesn't really solve the original problem, though.</p>",
        "id": 423677374,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709060756
    },
    {
        "content": "<p>I'm trying (without type synonym for now)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">lift</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">R'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">R'</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"bp\">→</span> <span class=\"n\">R'</span> <span class=\"o\">:=</span>\n  <span class=\"n\">algebraMap</span> <span class=\"n\">R</span> <span class=\"n\">R'</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">ℂ</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- The L-series of an `ArithmeticFunction`. -/</span>\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">LSeries</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∑'</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">lift</span> <span class=\"n\">ℂ</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"n\">z</span>\n\n<span class=\"sd\">/-- `f.LSeriesSummable z` indicates that the L-series of `f` converges at `z`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">LSeriesSummable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Summable</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lift</span> <span class=\"n\">ℂ</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"n\">z</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">LSeries_eq_zero_of_not_LSeriesSummable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">¬</span><span class=\"n\">LSeriesSummable</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">LSeries</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"n\">tsum_eq_zero_of_not_summable</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">LSeriesSummable_zero</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">LSeriesSummable</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LSeriesSummable</span><span class=\"o\">,</span> <span class=\"n\">summable_zero</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- This states that the L-series of the arithmetic function `f` converges at `s` to `a`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">LSeriesHasSum</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">HasSum</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lift</span> <span class=\"n\">ℂ</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>etc., to see how it goes.</p>",
        "id": 423677801,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709060903
    },
    {
        "content": "<blockquote>\n<p>I'm trying (without type synonym for now)</p>\n</blockquote>\n<p>I think not using the type synonym is preferable, actually: I'd argue that the type synonym should only be used when showing that Dirichlet convolution gives a ring structure, and that statements which don't explicitly involve convolution should be formulated for \"bare\" functions <code>ℕ+ → R</code> (or possibly for functions <code>ℕ → R</code> ignoring the value at 0).</p>",
        "id": 423680631,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709062017
    },
    {
        "content": "<p>What I meant about option (2) and the ring instance was the following. There are various ways of extending Dirichlet convolution into a binary operation on all functions <code>ℕ → R</code> (without the <code>f 0 = 0</code> requirement). But it is not so clear that these extended convolutions, together with pointwise addition, give a ring structure. (If we define <code>(f \\star g)(0) = f 0 * g 0</code> then we are probably OK)</p>",
        "id": 423681167,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709062204
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310725.20and.20.2310728.3A.20L-series/near/423680631\">said</a>:</p>\n<blockquote>\n<p>I'd argue that the type synonym should only be used when showing that Dirichlet convolution gives a ring structure, and that statements which don't explicitly involve convolution should be formulated for \"bare\" functions <code>ℕ+ → R</code> (or possibly for functions <code>ℕ → R</code> ignoring the value at 0).</p>\n</blockquote>\n<p>I feel the need to point out that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ArithmeticFunction.IsMultiplicative#doc\">docs#ArithmeticFunction.IsMultiplicative</a> is a predicate on <code>ArithmeticFunction</code>s, which if you're doing Euler products is another place besides Dirichlet convolution where you'll want to use <code>ArithmeticFunction</code>s with the current setup.</p>",
        "id": 423690936,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1709065927
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310725.20and.20.2310728.3A.20L-series/near/423631860\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">coe</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">toComplexArithmeticFunction</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ArithmeticFunction</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ArithmeticFunction</span> <span class=\"n\">C</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">algebraMap</span> <span class=\"n\">R</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">map_zero</span><span class=\"o\">,</span> <span class=\"n\">_root_.map_zero</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instCoeHead</span> <span class=\"o\">:</span> <span class=\"n\">CoeHead</span> <span class=\"o\">(</span><span class=\"n\">ArithmeticFunction</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ArithmeticFunction</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">toComplexArithmeticFunction</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">C</span><span class=\"o\">)⟩</span>\n</code></pre></div>\n<p>gives</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">cannot</span> <span class=\"n\">find</span> <span class=\"n\">synthesization</span> <span class=\"n\">order</span> <span class=\"n\">for</span> <span class=\"kd\">instance</span> <span class=\"bp\">@</span><span class=\"n\">instCoeHead</span> <span class=\"k\">with</span> <span class=\"n\">type</span>\n  <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n    <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n      <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"bp\">→</span>\n        <span class=\"o\">[</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">CommSemiring</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">CoeHead</span> <span class=\"o\">(</span><span class=\"n\">ArithmeticFunction</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ArithmeticFunction</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"n\">all</span> <span class=\"n\">remaining</span> <span class=\"n\">arguments</span> <span class=\"k\">have</span> <span class=\"n\">metavariables</span><span class=\"o\">:</span>\n  <span class=\"n\">CommSemiring</span> <span class=\"bp\">?</span><span class=\"n\">C</span>\n  <span class=\"bp\">@</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"bp\">?</span><span class=\"n\">C</span> <span class=\"n\">inst</span><span class=\"bp\">✝²</span> <span class=\"n\">CommSemiring.toSemiring</span>\n</code></pre></div>\n<p>and adding <code>outParam</code> to the first or second argument does not help. (But I don't really know what I'm doing here.)</p>\n</blockquote>\n<p>The only way to get a coercion with free variables in the left- and right hand side, as far as I understand it, is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CoeDep#doc\">docs#CoeDep</a>. The code will look something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">coe</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">toComplexArithmeticFunction</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ArithmeticFunction</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ArithmeticFunction</span> <span class=\"n\">C</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">algebraMap</span> <span class=\"n\">R</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">map_zero</span><span class=\"o\">,</span> <span class=\"n\">_root_.map_zero</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instCoeDep</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">CoeDep</span> <span class=\"o\">(</span><span class=\"n\">ArithmeticFunction</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">ArithmeticFunction</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">toComplexArithmeticFunction</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>With appropriate changes to the rest of the file, everything builds. An important limitation is that <code>CoeDep</code> cannot compose with other coercions: we have to go from expected type to inferred type directly. I think that's actually a good thing here since we don't want e.g. <code>((f : ArithmeticFunction ℤ) : ArithmeticFunction ℂ)</code> to be ambiguous between  <code>toComplexArithmeticFunction (C := ℂ) (toComplexArithmeticFunction (C := ℝ) f)</code> and <code>toComplexArithmeticFunction (C := ℂ) f</code>.</p>",
        "id": 423798716,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1709119764
    },
    {
        "content": "<p>However, a drawback to all these approaches is that we now have a separation between a theorem for <code>ArithmeticFunction ℂ</code> and a theorem for <code>ArithmeticFunction R</code> where we subsequently set <code>R := ℂ</code>: the second will have <code>algebraMap ℂ ℂ</code> inserted in many different places. This is not a terrible burden, it disappears with one <code>simp</code>, but it can be very annoying in practice.</p>",
        "id": 423799967,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1709120302
    },
    {
        "content": "<p>One way to avoid this issue is by using more classes. We axiomatize what we need from the structure of arithmetic functions, perhaps up to the semiring level:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Note that we don't use `FunLike` because we want `R` to be independent of `F`,</span>\n<span class=\"c1\">-- not fixed by `FunLike`'s `outParam`.</span>\n<span class=\"kd\">class</span> <span class=\"n\">ArithmeticFunctionClass</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n    <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">toFun</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">toFun_zero_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">toFun</span> <span class=\"mi\">0</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">toFun_zero_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">toFun</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">toFun_one_one</span> <span class=\"o\">:</span> <span class=\"n\">toFun</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">toFun_one_of_ne</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">toFun</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- and so on</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">ArithmeticFunctionClass</span> <span class=\"o\">(</span><span class=\"n\">toFun</span><span class=\"o\">)</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">ArithmeticFunctionClass.toFun_zero_left</span> <span class=\"n\">ArithmeticFunctionClass.toFun_zero_right</span> <span class=\"n\">ArithmeticFunctionClass.toFun_one_one</span>\n</code></pre></div>\n<p>This can be given multiple instances, unlike <code>FunLike</code>/<code>ZeroHomClass</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ArithmeticFunctionClass</span> <span class=\"o\">(</span><span class=\"n\">ArithmeticFunction</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">f</span>\n  <span class=\"n\">toFun_zero_left</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"n\">toFun_zero_right</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"n\">toFun_one_one</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"n\">toFun_one_of_ne</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ArithmeticFunctionClass</span> <span class=\"o\">(</span><span class=\"n\">ArithmeticFunction</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">algebraMap</span> <span class=\"n\">R</span> <span class=\"n\">ℂ</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span>\n  <span class=\"n\">toFun_zero_left</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"n\">toFun_zero_right</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"n\">toFun_one_one</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"n\">toFun_one_of_ne</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Next we redefine L-series to be generic in which arithmetic functions they take:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ArithmeticFunctionClass</span> <span class=\"n\">F</span> <span class=\"n\">ℂ</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- The L-series of an `ArithmeticFunction`. -/</span>\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">LSeries</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∑'</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">toFun</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"n\">z</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">nat.arithmetic_function.l_series</span> <span class=\"n\">ArithmeticFunction.LSeries</span>\n\n<span class=\"sd\">/-- `f.LSeriesSummable z` indicates that the L-series of `f` converges at `z`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">LSeriesSummable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Summable</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">toFun</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"n\">z</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">nat.arithmetic_function.l_series_summable</span> <span class=\"n\">ArithmeticFunction.LSeriesSummable</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">LSeries_eq_zero_of_not_LSeriesSummable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">¬</span><span class=\"n\">LSeriesSummable</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">LSeries</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"n\">tsum_eq_zero_of_not_summable</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">nat.arithmetic_function.l_series_eq_zero_of_not_l_series_summable</span> <span class=\"n\">ArithmeticFunction.LSeries_eq_zero_of_not_LSeriesSummable</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">LSeriesSummable_zero</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">LSeriesSummable</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LSeriesSummable</span><span class=\"o\">,</span> <span class=\"n\">summable_zero</span><span class=\"o\">]</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">nat.arithmetic_function.l_series_summable_zero</span> <span class=\"n\">ArithmeticFunction.LSeriesSummable_zero</span>\n\n<span class=\"sd\">/-- This states that the L-series of the arithmetic function `f` converges at `s` to `a`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">LSeriesHasSum</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ArithmeticFunction</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">HasSum</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">algebraMap</span> <span class=\"n\">R</span> <span class=\"n\">ℂ</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 423801850,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1709121031
    },
    {
        "content": "<p>The drawback of this approach, apart from the added complexity, is that the notation is less convenient: we have to write <code>toFun</code> and can't use dot notation like <code>f.LSeries</code>. But we wouldn't need the simplifier to see through the equalities.</p>",
        "id": 423802163,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1709121148
    },
    {
        "content": "<p>In the end I think it's best if we either use <code>CoeDep</code> or <code>Algebra</code> to implement this coercion, since it's flexible enough to do what we want while not requiring users to understand a whole new system. Hopefully at some point I can sit down and redo <code>Algebra</code> so we don't have so many issues with composition or identity maps...</p>",
        "id": 423803553,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1709121702
    },
    {
        "content": "<p>This is a technically very impressive solution but I think it's overkill for the problem at hand.</p>",
        "id": 423804289,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709121965
    },
    {
        "content": "<p>If I'm not mistaken, the only reason why we have the <code>ArithmeticFunction</code> type synonym is in order to be able to write <code>*</code> for Dirichlet convolution, overriding the \"native\" pointwise multiplication operation on function types.  If we're willing to put up with writing <code>DirichletConvolution f g</code> instead of <code>f * g</code>, then we can work with bare functions on <code>Nat</code> or <code>PNat</code> and the coercion issues largely go away.</p>\n<p>My view is that Dirichlet convolution, although it's undeniably important, doesn't get used <em>so</em> often that it is worth putting up with all these awkward circumlocutions and/or long lists of special-case lemmas for coercions in an L-series.</p>",
        "id": 423805132,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709122312
    },
    {
        "content": "<p>(Of course we can still have <code>ArithmeticFunction</code> as a type synonym with <code>*</code> defined to be convolution, but I'm saying we shouldn't use that type synonym in stating theorems about L-series.)</p>",
        "id": 423805509,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709122460
    },
    {
        "content": "<p>I suggest that we find a symbol for DirichletConvolution, why not ⊛ or any Unicode star ✮✶✸✹❇︎✳︎★   ?</p>",
        "id": 423834081,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1709131735
    },
    {
        "content": "<p>If we don't pick <code>\\O*</code> or <code>\\ast</code>, we need to add a convenient shortcut for typing it...</p>",
        "id": 423837618,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709132585
    },
    {
        "content": "<p>Sure, but it is possible to add characters to editors.</p>",
        "id": 423838237,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1709132734
    },
    {
        "content": "<p>Of course; I'm just saying that it should be part of the change.</p>",
        "id": 423838463,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709132782
    },
    {
        "content": "<p>Isn't the point that, with Dirichlet convolution, the set of arithmetic function has a good structure (a ring, probably?). If you want to apply theorems on rings, then the multiplication has to use the usual symbol, so you can not avoid the type synonym approach.</p>",
        "id": 423839025,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1709132940
    },
    {
        "content": "<p>Whatever symbol is chosen it should be relatively distinguishable from the standard star. (My students cry at distinguishing <code>\\&lt;</code> from <code>(</code> … a nightmare when you teach the syntax for rcases with and and or.</p>",
        "id": 423839062,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1709132951
    },
    {
        "content": "<p>I'd take ⊛.</p>",
        "id": 423839278,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709133015
    },
    {
        "content": "<p>Dirichlet convolution is the MonoidAlgebra for the monoid of non zero integers, but it has been agreed that one should not use this point of view.</p>",
        "id": 423839285,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1709133017
    },
    {
        "content": "<p>Later today, I'll try to see whether</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ArithmeticFunction</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"bp\">→</span> <span class=\"n\">R</span>\n</code></pre></div>\n<p>gives something workable. We can define Dirichlet convolution on <code>ℕ+ → R</code> (under suitable assumptions on <code>R</code>) and denote it <code>⊛</code> and define <code>*</code> on <code>ArithmeticFunction R</code> to be that, to be able to put a (semi)ring structure on it.</p>",
        "id": 423839966,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709133230
    },
    {
        "content": "<p>FWIW in LeanAPAP I am using <code>\\ast</code> for convolution: <a href=\"https://github.com/YaelDillies/LeanAPAP/blob/master/LeanAPAP/Prereqs/Discrete/Convolution/Basic.lean#L61\">https://github.com/YaelDillies/LeanAPAP/blob/master/LeanAPAP/Prereqs/Discrete/Convolution/Basic.lean#L61</a></p>",
        "id": 423840136,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709133271
    },
    {
        "content": "<p>And I have but do not use the type synonym that makes <code>G → ℂ</code> into a ring with multiplication given by convolution</p>",
        "id": 423840230,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709133303
    },
    {
        "content": "<p>I think <code>\\ast</code> is maybe not sufficiently distinct from <code>*</code>, so I'd prefer <code>\\O*</code>.</p>",
        "id": 423840329,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709133340
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sébastien Gouëzel</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310725.20and.20.2310728.3A.20L-series/near/423839025\">said</a>:</p>\n<blockquote>\n<p>Isn't the point that, with Dirichlet convolution, the set of arithmetic function has a good structure (a ring, probably?). If you want to apply theorems on rings, then the multiplication has to use the usual symbol, so you can not avoid the type synonym approach.</p>\n</blockquote>\n<p>My point is that this ring structure, while pretty, is not actually very important in practice in working with L-functions. Yes, Dirichlet convolution is an occasionally important tool, but the fact that it satisfies the ring axioms is not usually very relevant. So the gain of using a type synonym rather than just plain functions (being able to apply general ring-theoretic lemmas to the ring of <code>ArithmeticFunction</code>s) is not worth the loss (that coercion becomes very painful).</p>",
        "id": 423840523,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709133389
    },
    {
        "content": "<p>Makes sense!</p>",
        "id": 423840705,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1709133447
    },
    {
        "content": "<p>Coercion of functions <code>ℕ+ → R</code> to <code>ℕ+ → Complex</code> is even more painful, I think. (Other than composing with an explicit map.)</p>",
        "id": 423840771,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709133475
    },
    {
        "content": "<p>I'll have a stab at this in the evening (CET).</p>",
        "id": 423841229,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709133606
    },
    {
        "content": "<p>\\ast was also used as notation for the convolution of measures that was added a while back, you can find it here: <br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.Measure.conv#doc\">docs#MeasureTheory.Measure.conv</a></p>",
        "id": 423846151,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1709134937
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310725.20and.20.2310728.3A.20L-series/near/423840523\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sébastien Gouëzel</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310725.20and.20.2310728.3A.20L-series/near/423839025\">said</a>:</p>\n<blockquote>\n<p>Isn't the point that, with Dirichlet convolution, the set of arithmetic function has a good structure (a ring, probably?). If you want to apply theorems on rings, then the multiplication has to use the usual symbol, so you can not avoid the type synonym approach.</p>\n</blockquote>\n<p>My point is that this ring structure, while pretty, is not actually very important in practice in working with L-functions. Yes, Dirichlet convolution is an occasionally important tool, but the fact that it satisfies the ring axioms is not usually very relevant. So the gain of using a type synonym rather than just plain functions (being able to apply general ring-theoretic lemmas to the ring of <code>ArithmeticFunction</code>s) is not worth the loss (that coercion becomes very painful).</p>\n</blockquote>\n<p>Hmm it does get quite convenient to say things like: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ζ</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo><mo>∗</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>ζ</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\"> \\zeta(s) *1/\\zeta(s)=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07378em;\">ζ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07378em;\">ζ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>, and therefore <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>⊗</mo><mi>μ</mi><mo>=</mo><mi>δ</mi></mrow><annotation encoding=\"application/x-tex\">1 \\otimes \\mu = \\delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span></span></span></span>... More advanced versions of this like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>ζ</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>∗</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>ζ</mi><mo>=</mo><msup><mi>ζ</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mi mathvariant=\"normal\">/</mi><mi>ζ</mi><mo>⇒</mo><mi>log</mi><mo>⁡</mo><mo>⊗</mo><mi>μ</mi><mo>=</mo><mi mathvariant=\"normal\">Λ</mi></mrow><annotation encoding=\"application/x-tex\">\\zeta&#x27; * 1/\\zeta = \\zeta&#x27;/\\zeta \\Rightarrow \\log \\otimes \\mu = \\Lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9463em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07378em;\">ζ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07378em;\">ζ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07378em;\">ζ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07378em;\">ζ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">⊗</span><span class=\"mord mathnormal\">μ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Λ</span></span></span></span> come up, e.g., in Vaughan-type identities in sieving...</p>",
        "id": 423854906,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1709137273
    },
    {
        "content": "<p>But I agree that you can say these things without reference to the ring structure per se...</p>",
        "id": 423855007,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1709137302
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310725.20and.20.2310728.3A.20L-series/near/423839062\">said</a>:</p>\n<blockquote>\n<p>Whatever symbol is chosen it should be relatively distinguishable from the standard star. (My students cry at distinguishing <code>\\&lt;</code> from <code>(</code> … a nightmare when you teach the syntax for rcases with and and or.</p>\n</blockquote>\n<p>You may need to recommend a different font.</p>",
        "id": 423855440,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709137417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252920\">Alex Kontorovich</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310725.20and.20.2310728.3A.20L-series/near/423855007\">said</a>:</p>\n<blockquote>\n<p>But I agree that you can say these things without reference to the ring structure per se...</p>\n</blockquote>\n<p>Indeed, the issue is not whether the convolution operation is available, but whether we can apply general <code>Ring</code> lemmas to it, and the latter seems to be a bit less likely to be useful.</p>",
        "id": 423855723,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709137500
    },
    {
        "content": "<p>I have looked at refactoring <code>ArithmeticFunction</code> or <code>LSeries</code> yesterday night a bit. My conclusions are</p>\n<ul>\n<li>Changing <code>ArithmeticFunction</code> to be <code>ℕ+ → R</code> is possible, but quite some work. In particular, it requires adding quite a bit of API for <code>PNat</code> (e.g., to get Dirichlet convolution work). Since my time is limited, I won't pursue this further, at least for now.</li>\n<li>Changing <code>LSeries</code> to eat something of type <code>ℕ+ → ℂ</code> seems to work fairly well (so far!). I'll continue with this to see what kinds of problems may arise later.</li>\n</ul>\n<p>I'll post an update later.</p>",
        "id": 424015497,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709212180
    },
    {
        "content": "<p>OK, after putting in more work, I have the strong impression that there is no way around beefing up the <code>PNat</code> API no matter whether we restrict arithmetic functions to <code>ℕ+</code> or only L-series.</p>\n<p>Based on this, I now think that <em>if</em> we want to do this in some form, the better approach is, after all, to refactor <code>ArithmeticFunction R</code> as a synonym of <code>ℕ+ → R</code> and keeping the input of <code>LSeries</code> as an <code>ArithmeticFunction ℂ</code>.</p>\n<p>As said above, this will require some work. Before embarking on this further, I'd like to have some <strong>more feedback</strong> -- I'd like to avoid putting in the work only for the PRs to be rejected later. One point to keep in mind is that such a refactor cannot be done in small steps, as changing the definition of <code>ArithmeticFunction</code> will likely break a lot of downstream code (<code>Mathlib.NumberTheory.VonMangold</code>, <code>Mathlib.RingTheory.Polynomial.Cyclotomic.Basic</code> and dependencies, L-series and Euler products) .</p>",
        "id": 424109980,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709241461
    },
    {
        "content": "<p>The pain point came when I was trying to prove that <code>L χ s * L (χ * ↗μ) s = 1</code> for a Dirichlet character <code>χ</code>, where <code>↗μ</code> is the function <code>ℕ+ → ℂ</code> induced by the Möbius function (and <code>1 &lt; s.re</code>). This went reasonably smoothly with the setting I had before (see <a href=\"https://github.com/MichaelStollBayreuth/EulerProducts/blob/main/EulerProducts/DirichletLSeries.lean\">DirichletLSeries.lean</a> in the <a href=\"https://github.com/MichaelStollBayreuth/EulerProducts/tree/main\">EulerProducts</a> repo), but gets pretty hairy in the set-up with functions on <code>ℕ+</code>.</p>",
        "id": 424110720,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709241754
    },
    {
        "content": "<p>The alternative, which is \"minimally invasive\" in comparison, would be to leave the basic definitions of  <code>ArithmeticFunction</code> and <code>LSeries</code> unchanged, ditch <a href=\"https://github.com/leanprover-community/mathlib4/pull/10725\">#10725</a> (which seems doomed anyway) and replace its core functionality by a suitable local notation (like <code>↗μ</code> above).</p>",
        "id": 424111145,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709241941
    },
    {
        "content": "<p>Of course, there is also the long-term point of view. If we are convinced that a refactor will be necessary anyway to be able to do certain things we want to do eventually in the Right Way <span aria-label=\"trademark\" class=\"emoji emoji-2122\" role=\"img\" title=\"trademark\">:trademark:</span>, the the earlier we do it, the less pain it will be.</p>",
        "id": 424111450,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709242067
    },
    {
        "content": "<p>Some of the missing <code>PNat</code> API (and I'm not talking about <code>divisorsAntidiagonal</code>...):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">PNat.mul_eq_one</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">↔</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">PNat.noMaxOrder</span> <span class=\"o\">:</span> <span class=\"n\">NoMaxOrder</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finite</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">PNat.cofinite_eq_atTop</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">cofinite</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"bp\">=</span> <span class=\"n\">atTop</span>\n</code></pre></div>",
        "id": 424112317,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709242407
    },
    {
        "content": "<p>Isn't the first one <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mul_eq_one_iff%27#doc\">docs#mul_eq_one_iff'</a> ?</p>",
        "id": 424112485,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709242469
    },
    {
        "content": "<p>The third one comes from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instLocallyFiniteOrderPNatToPreorderToPartialOrderToSemilatticeInfToLatticeInstDistribLatticeInstPNatLinearOrder#doc\">docs#instLocallyFiniteOrderPNatToPreorderToPartialOrderToSemilatticeInfToLatticeInstDistribLatticeInstPNatLinearOrder</a> (terrible name...)</p>",
        "id": 424112565,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709242514
    },
    {
        "content": "<p>Not on the nose; you have to provide the <code>1 ≤  ..</code>conditions.</p>",
        "id": 424112583,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709242528
    },
    {
        "content": "<p><code>inferInstance</code> fails.</p>",
        "id": 424112733,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709242575
    },
    {
        "content": "<p>Ah sorry, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mul_eq_one_iff#doc\">docs#mul_eq_one_iff</a></p>",
        "id": 424112739,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709242578
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310725.20and.20.2310728.3A.20L-series/near/424112733\">said</a>:</p>\n<blockquote>\n<p><code>inferInstance</code> fails.</p>\n</blockquote>\n<p>Are you importing <code>Data.PNat.Interval</code>?</p>",
        "id": 424112771,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709242597
    },
    {
        "content": "<p>importing <code>Mathlib</code>...</p>",
        "id": 424112809,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709242614
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310725.20and.20.2310728.3A.20L-series/near/424112739\">said</a>:</p>\n<blockquote>\n<p>Ah sorry, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mul_eq_one_iff#doc\">docs#mul_eq_one_iff</a></p>\n</blockquote>\n<p><code>exact?</code> fails. Anyway, <code>PNat</code> is not a monoid.</p>",
        "id": 424112990,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709242693
    },
    {
        "content": "<p>Sure it is!</p>",
        "id": 424112999,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709242702
    },
    {
        "content": "<p>It's not an <em>additive</em> monoid, but it is a canonically ordered multiplicative one (and basically the only one, actually)</p>",
        "id": 424113094,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709242757
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">PNat.mul_eq_one</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">↔</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n  <span class=\"n\">mul_eq_one_iff</span>\n</code></pre></div>\n<p>gives</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">mul_eq_one_iff</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">HMul.hMul</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">instHMul</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"n\">MulOneClass.toMul</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">↔</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">HMul.hMul</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">instHMul</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"n\">instPNatMul</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">↔</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p><span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 424113161,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709242798
    },
    {
        "content": "<p>Well maybe we're missing the <code>CanonicallyOrderedMonoid ℕ+</code> instance</p>",
        "id": 424113276,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709242839
    },
    {
        "content": "<p><code>#synth CanonicallyOrderedCommMonoid ℕ+</code> --&gt; \"failed to synthesize<br>\n  CanonicallyOrderedCommMonoid ℕ+\"</p>",
        "id": 424113387,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709242902
    },
    {
        "content": "<p>Wait no sorry it's not because we don't have <code>a ≤ b ↔ ∃ c, a * c = b</code></p>",
        "id": 424115014,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709243520
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/11076\">#11076</a> for the instance names</p>",
        "id": 424115101,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709243543
    },
    {
        "content": "<blockquote>\n<p>Based on this, I now think that if we want to do this in some form, the better approach is, after all, to refactor ArithmeticFunction R as a synonym of ℕ+ → R and keeping the input of LSeries as an ArithmeticFunction ℂ.<br>\nAs said above, this will require some work. Before embarking on this further, I'd like to have some more feedback.</p>\n<p>[...]</p>\n<p>The alternative, which is \"minimally invasive\" in comparison, would be to leave the basic definitions of ArithmeticFunction and LSeries unchanged, ditch <a href=\"https://github.com/leanprover-community/mathlib4/pull/10725\">#10725</a> (which seems doomed anyway) and replace its core functionality by a suitable local notation (like ↗μ above).</p>\n</blockquote>\n<p>You make a convincing case that extending the <code>PNat</code> API is more work than I realised (and it would be very unpleasant work both to build and maintain since so much of it would be duplicating existing <code>Nat</code> functionality). </p>\n<p>Would it work to keep <code>ArithmeticFunction</code> unchanged, but allow <code>LSeries</code> to eat an arbitrary function <code>ℕ → ℂ</code> (<em>not</em>  <code>ℕ+ → ℂ</code>), and deal with the <code>0 ^ s</code> term by either masking it out with an <code>ite</code> or  trusting that it will always be 0 in the convergence range anyway?</p>\n<p>Then we can have it as a lemma that if the functions we feed to <code>LSeries</code> <em>happen</em> to be <code>ArithmeticFunction</code>'s, then Dirichlet convolution becomes multiplication of L-series; but we regain the flexibility to consider <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∑</mo><msup><mi>e</mi><mrow><mi>i</mi><mi>n</mi><mi>θ</mi></mrow></msup><msup><mi>n</mi><mrow><mo>−</mo><mi>s</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">\\sum e^{in \\theta} n^{-s}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0991em;vertical-align:-0.25em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">θ</span></span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mathnormal mtight\">s</span></span></span></span></span></span></span></span></span></span></span></span> as an L-series if we wish.</p>",
        "id": 424168587,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709275479
    },
    {
        "content": "<p>(and building an L-series out of something valued in a subring of ℂ would be as simple as <code>LSeries (fun n ↦ f n)</code>, but we can have a notation <code>↗f</code> for this if we want)</p>",
        "id": 424168778,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709275584
    },
    {
        "content": "<p>Note that <code>(f ·)</code> is a shorter version of <code>(fun n ↦ f n)</code>.</p>",
        "id": 424169107,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1709275810
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2310725.20and.20.2310728.3A.20L-series/near/424169107\">said</a>:</p>\n<blockquote>\n<p>Note that <code>(f ·)</code> is a shorter version of <code>(fun n ↦ f n)</code>.</p>\n</blockquote>\n<p>Note the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"c1\">-- \"type mismatch\"</span>\n<span class=\"k\">#check</span> <span class=\"o\">((</span><span class=\"n\">f</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"c1\">-- works</span>\n</code></pre></div>\n<p>Maybe it would be nice if the first one could also work?</p>",
        "id": 424194698,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709286825
    },
    {
        "content": "<p>I'm not so sure. This is the kind of things that lead to terrible performance</p>",
        "id": 424194873,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1709286882
    },
    {
        "content": "<p>I guess it may be slow to fail when no suitable coercions can be found.<br>\nAnyway, writing <code>(f ·)</code> isn't too bad.</p>",
        "id": 424195317,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709286984
    },
    {
        "content": "<p>I'll have a look at what David suggests later.</p>",
        "id": 424195461,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709287022
    },
    {
        "content": "<p>So far, it looks quite OK. At least getting </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">LSeriesHasSum.mul</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">LSeriesHasSum</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">LSeriesHasSum</span> <span class=\"n\">g</span> <span class=\"n\">s</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">LSeriesHasSum</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⍟</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(where <code>f ⍟ g</code> is Dirichlet convolution) was not more painful than what I had before.<br>\nTomorrow, I'll see how it goes with Dirichlet L-series.</p>\n<p>My opening gambit is to define</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The `n`th term of the L-series of `f` evaluated at `s`. We set it to zero when `n = 0`. -/</span>\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">LSeriesTerm</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"n\">s</span>\n</code></pre></div>\n<p>then provide suitable API for that and define</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The L-series of the sequence `f`. -/</span>\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">LSeries</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∑'</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">LSeriesTerm</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"n\">n</span>\n\n<span class=\"sd\">/-- `LSeriesSummable f s` indicates that the L-series of `f` converges at `s`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">LSeriesSummable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Summable</span> <span class=\"o\">(</span><span class=\"n\">LSeriesTerm</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- This states that the L-series of the sequence `f` converges at `s` to `a`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">LSeriesHasSum</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">HasSum</span> <span class=\"o\">(</span><span class=\"n\">LSeriesTerm</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>All the relevant properties can be stated and proved in terms of <code>LSeriesTerm</code> first; then in the proofs of results on L-series, one does not have to break through the API barrier of <code>LSeriesTerm</code>, which makes for somewhat nicer code.</p>",
        "id": 424339996,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709334486
    },
    {
        "content": "<p>I think this approach will work OK also downstream. (I checked with the lemma that gave me problems with the <code>PNat</code> approach).</p>\n<p>So I propose to refactor the current <code>NumberTheory.LSeries.*</code>files replacing <code>ArithmeticFunction ℂ</code> by <code>ℕ → ℂ</code> (and introducing <code>LSeries.term</code>) as a first step, followed by adding further material in further PRs:</p>\n<ul>\n<li>differentiability and derivatives</li>\n<li>Dirichlet convolution and multiplication of L-series</li>\n<li>L-series of specific functions (delta, zeta, mu, ...)</li>\n<li>L-series of Dirichlet characters</li>\n<li>etc.</li>\n</ul>\n<p>with the goal of providing the necessary material on L-series for PNT+ and beyond.</p>\n<p>Does this find approval?</p>\n<p>And, also important: are people willing to review these PRs reasonably quickly?</p>",
        "id": 424406220,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709381175
    },
    {
        "content": "<p>I am in favour of this and willing to help with reviewing.</p>",
        "id": 424406577,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709381546
    },
    {
        "content": "<p>I will also help with reviewing.</p>",
        "id": 424407203,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709382247
    },
    {
        "content": "<p>I can handle differentiability/derivatives.</p>",
        "id": 424407412,
        "sender_full_name": "David Loeffler",
        "timestamp": 1709382405
    },
    {
        "content": "<p>I'm also happy to help reviewing</p>",
        "id": 424407539,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1709382503
    },
    {
        "content": "<p>Since I wrote some comments in that direction, I feel obliged to help reviewing…</p>",
        "id": 424421654,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1709394225
    },
    {
        "content": "<p>I think one of the superpowers of mathlib and this community is that people are very keen on getting things right rather than struggling with suboptimal design decisions, and there are several major refactors which are a witness to this.</p>",
        "id": 424423453,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709395596
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/11111\">#11111</a> <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> (not by intention!)<br>\nI have added you all as reviewers.</p>\n<p>The diff is rather large, unfortunately (some things have moved within the <code>Basic</code> file, and the github diff is not that smart...).</p>",
        "id": 424434569,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709404451
    },
    {
        "content": "<p>(Is that <a href=\"https://github.com/leanprover-community/mathlib4/pull/11111\">#11111</a> or #lllll?)</p>",
        "id": 424446704,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1709414553
    },
    {
        "content": "<p>I've started a new thread <a href=\"#narrow/stream/144837-PR-reviews/topic/L-series/near/424858837\">here</a> for discussing further PRs.</p>",
        "id": 424858976,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709642170
    }
]