[
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/13166\">#13166</a> replaces just under 8000 <code>refine'</code> with <code>refine</code>.  A parallel PR with the same replacement (and a linter to help the process) built all of mathlib, so I am hopeful that this one will also build.</p>",
        "id": 440493236,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716551202
    },
    {
        "content": "<p>The way the replacement happened is as follows.</p>\n<p>A linter detected <code>refine'</code>, replaced them by <code>refine</code> and logged the locations of the \"unsynthesized <code>_</code>\" and then replaced each <code>refine'</code> in succession with <code>refine</code>.  If the substitution built, it would output the position of the <code>refine'</code> and of the <code>_</code>, otherwise it would skip the <code>refine'</code>.</p>",
        "id": 440493493,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716551314
    },
    {
        "content": "<p>A second (python) script removed the flagged <code>'</code>s and added the needed <code>?</code>.</p>",
        "id": 440493573,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716551350
    },
    {
        "content": "<p>This worked \"almost\" well!</p>",
        "id": 440493585,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716551357
    },
    {
        "content": "<p>As a consequence, on that branch, there are 1634 <code>refine'</code> left.</p>",
        "id": 440494038,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716551545
    },
    {
        "content": "<p>The PR is linting now, after a merge conflict.  I tried to use <code>!bench</code>, but it told me that there are no runs to compare to: can I do something to get <code>!bench</code> to compare to something somewhat recent?</p>",
        "id": 440507065,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716556536
    },
    {
        "content": "<p><a href=\"http://speed.lean-fro.org/mathlib4/compare/e7b27246-a3e6-496a-b552-ff4b45c7236e/to/7154f447-eacb-45e1-b172-599fa45c4fa8?hash1=801a7d0eef7f568fbb26de3770097abcd981977d\">http://speed.lean-fro.org/mathlib4/compare/e7b27246-a3e6-496a-b552-ff4b45c7236e/to/7154f447-eacb-45e1-b172-599fa45c4fa8?hash1=801a7d0eef7f568fbb26de3770097abcd981977d</a> -100B</p>",
        "id": 440507480,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716556678
    },
    {
        "content": "<p>If you click on the little scales icon you can select another commit to compare against. I just went back two commits in the history to get one that had been benched</p>",
        "id": 440507663,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716556732
    },
    {
        "content": "<p>Oh, thanks!  So... this has not made mathlib worse, right?  I am always unsure how to read these results...</p>",
        "id": 440507688,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716556740
    },
    {
        "content": "<p>No file significantly regressed. Some significantly improved and overall there are ~100B (or ~.1%) less instructions</p>",
        "id": 440507833,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716556790
    },
    {
        "content": "<p>You made lean do 0.081% less work</p>",
        "id": 440507863,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1716556802
    },
    {
        "content": "<p>Not sure if that's reliable</p>",
        "id": 440507918,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1716556809
    },
    {
        "content": "<p>I would be shocked if it was noise</p>",
        "id": 440507964,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716556828
    },
    {
        "content": "<p>Ok, thanks!  I just get confused by so many parameters and do not really know which ones to take seriously and which ones to disregard.</p>",
        "id": 440508023,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716556854
    },
    {
        "content": "<p>Overall instruction changes in the 10s of billions is almost certainly signal</p>",
        "id": 440508120,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716556888
    },
    {
        "content": "<p>Whereas wall clock improvements of 3% might be that the server is feeling its oats that day</p>",
        "id": 440508314,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716556936
    },
    {
        "content": "<p>Ok, great, thanks for the explanations!</p>",
        "id": 440508316,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716556937
    },
    {
        "content": "<p>Is there any automated tool that will consume the diff and tell me if the only changes are </p>\n<ul>\n<li><code>refine'</code> =&gt; <code>refine</code> are the only deletions </li>\n<li><code>_</code> =&gt; <code>?_</code> are the only additions?</li>\n</ul>",
        "id": 440508741,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716557063
    },
    {
        "content": "<p>I also added some line breaks for the 100 chars linter.</p>",
        "id": 440508856,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716557100
    },
    {
        "content": "<p>That would be a good test :)</p>",
        "id": 440508917,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716557122
    },
    {
        "content": "<p>I am not sure about automating what you asked, other than looking at git diff and maybe a more refined word diff.</p>",
        "id": 440508939,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716557130
    },
    {
        "content": "<p>(The long lines should all be in the same commit, btw, so should be easy to filter out, after the test!)</p>",
        "id": 440509009,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716557154
    },
    {
        "content": "<p>I mean that if told me the line breaks were not of this type it would make me feel more confident about the automated diff checking tool</p>",
        "id": 440509445,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716557300
    },
    {
        "content": "<p>You could replace on master and the PR <code>refine'</code> with <code>refine</code> and remove all <code>?</code> and diff the output.</p>",
        "id": 440509450,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716557301
    },
    {
        "content": "<p>Right, so if we write something that does what I said, it should report just the line breaks.</p>",
        "id": 440509524,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716557328
    },
    {
        "content": "<p>I tried to ask GPT to do it for me on the last batch <code>refine'</code> PR but decided powering through was quicker that fixing the code</p>",
        "id": 440509650,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716557382
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>  1    _, _⟩\n  1      a₂ * a₁, a₂ * b₁ + b₂, mul_nonneg ha₂ ha₁, hab.le, _, _⟩\n  1      ⟨a, b, ⟨⟨⟨_, fun p hp =&gt; _⟩, hab₂⟩, ⟨_, fun p hp =&gt; _⟩⟩, by simp_rw [hab₁, m.add_one_sub_one]⟩\n  1    and_congr_right&#39;\n  1      ⟨by rw [repr, ihb.1, add_succ, repr], fun H =&gt; H.fst.oadd _ (NF.below_of_lt&#39; _ (ihb.2 H.snd))⟩\n  1    (_ : _ ≤ card (succ (typein (· &lt; ·) (g p))) * card (succ (typein (· &lt; ·) (g p)))) _\n  1      ciSup_eq_of_forall_le_of_forall_lt_exists_gt (fun j =&gt; _) fun n hn =&gt; ⟨i, hn.trans_eq _⟩\n  1    closure_cycle_coprime_swap (Nat.Coprime.symm (h0.coprime_iff_not_dvd.mpr fun h =&gt; h4 _)) h1 h2 x\n  1      (Continuous.continuousOn _) (Continuous.continuousOn _) _).continuousOn\n  1    (continuous_if_le _ _\n  1      (continuous_if_le _ _ (Continuous.continuousOn _) (Continuous.continuousOn _) _).continuousOn\n  1            disjoint_left.mp\n  1    (eq_pow_second_of_chain_of_has_chain hs (fun t u h =&gt; _) (@fun r =&gt; ⟨@fun hr =&gt; _, _⟩) _).symm\n  1    exists_congr fun a =&gt; ⟨fun ha b =&gt; ⟨fun hba hb =&gt; _, fun hb =&gt; _⟩, fun ha =&gt; ⟨_, fun b hb =&gt; _⟩⟩\n  1      Filter.EventuallyEq.trans _ (indicator_ae_eq_of_restrict_compl_ae_eq_zero (hm _ hs_m) hf_zero)\n  1      Finset.Subset.trans (vars_add_subset _ _) (Finset.union_subset_union (Finset.Subset.refl _) _)\n  1              ⟨f.num, f.num_mem_deg⟩, mem2⟩, _, _⟩, rfl⟩\n  1    forall_congr&#39; fun _hp =&gt; forall_congr&#39; fun q =&gt; forall_congr&#39; fun hq =&gt; _\n  1    forall_congr&#39; fun p =&gt; forall_congr&#39; fun _hp =&gt; forall_congr&#39; fun q =&gt; forall_congr&#39; fun hq =&gt; _\n  1            fun a ha =&gt; by simpa [ha] using hp ⟨a, ha⟩, _⟩\n  1      ⟨fun a =&gt; if h : a ∈ s then p ⟨a, h⟩ else univ, fun a ha =&gt; by simpa [ha] using hp ⟨a, ha⟩, _⟩\n  1                          fun _ =&gt; h₂.1, fun _ =&gt; h₂.1⟩, _⟩\n  1    ⟨fun ha b =&gt; ⟨fun hba hb =&gt; _, fun hb =&gt; _⟩, fun ha =&gt; ⟨_, fun b hb =&gt; _⟩⟩\n  1    ⟨fun h ↦ _, fun h ↦ _⟩\n  1        ⟨fun h =&gt; ⟨fun i hi j hj hij =&gt; _, fun i hi j hj hij =&gt; _⟩, fun h =&gt; h.1.prod_left h.2⟩ &lt;;&gt;\n  1      ⟨fun h =&gt; ⟨fun i hi j hj hij =&gt; _, fun i hi j hj hij =&gt; _⟩, fun h =&gt; h.1.prod_left h.2⟩ &lt;;&gt;\n  1    fun h ↦ ⟨fun J hJ hIJ hJX ↦ hIJ.antisymm (fun e heJ ↦ by_contra (fun heI ↦ _)), _⟩⟩\n  1    fun h ↦ ⟨fun J hJ hIJ hJX ↦ hIJ.antisymm (fun e heJ ↦ by_contra (fun heI ↦ _)),_⟩⟩\n  1    ⟨fun h : (preadditiveYonedaObj J ⋙ (forget &lt;| ModuleCat (End J))).PreservesEpimorphisms =&gt; _, _⟩\n  1          fun hx =&gt; hx.map S.subtype⟩\n  1      fun hx =&gt; hx.map S.subtype⟩\n  1      ⟨fun h x hx y hy a b ha hb hab =&gt; h hx hy ha.le hb.le hab, fun h x hx y hy a b ha hb hab =&gt; _⟩\n  1    ⟨fun h x hx y hy a b ha hb hab =&gt; h hx hy ha.le hb.le hab, fun h x hx y hy a b ha hb hab =&gt; _⟩\n  1    ⟨fun hx =&gt; ⟨⟨x, ⟨(↑hx.unit⁻¹ : A), StarSubalgebra.isUnit_coe_inv_mem hS hx x.prop⟩, _, _⟩, rfl⟩,\n  1    (@fun r =&gt; ⟨@fun hr =&gt; _, _⟩) _).symm\n  1            fun s =&gt; _\n  1            fun x =&gt; _, u_open.lowerSemicontinuous_indicator (zero_le _), _⟩\n  1              (h2 (mem_disjiUnion.mpr ⟨_, a.prop, hfa⟩) (mem_disjiUnion.mpr ⟨_, b.prop, hfb⟩) _) hga\n  1            (h2 (mem_disjiUnion.mpr ⟨_, a.prop, hfa⟩) (mem_disjiUnion.mpr ⟨_, b.prop, hfb⟩) _) hga\n  1    (h.const_mul ‖L‖).mono&#39; (hmf.convolution_integrand_snd&#39; L hmg) (eventually_of_forall fun x =&gt; _)\n  1    (hd.comp differentiable_neg.diffContOnCl H) _ (fun x hx =&gt; _) (fun x hx =&gt; _) hz_re hz_im\n  1    ((hf.comp_tendsto hg).symm.congr&#39; (hfg.mono _) (eventually_of_forall fun _ =&gt; rfl)).trans_isBigO\n  1    (hfg.mono _) (eventually_of_forall fun _ =&gt; rfl)).trans_isBigO _\n  1              hgb\n  1            hgb\n  1        (h (g * C f.leadingCoeff) (f * C g.leadingCoeff) _ _ _).symm.imp\n  1        (h (g * C f.leadingCoeff) (f * C g.leadingCoeff) _ _ _).symm.imp (isUnit_of_mul_eq_one f _)\n  1    (hmf.convolution_integrand_snd&#39; L hmg) (eventually_of_forall fun x =&gt; _)\n  1    hm (Lp.stronglyMeasurable f) _ _ _ _ hs hμs\n  1    hz_re hz_im\n  1    (IccExtend_eq_self zero_le_one smoothTransition (fun x hx =&gt; _) fun x hx =&gt; _) x\n  1      indicator_ae_eq_of_restrict_compl_ae_eq_zero (hm _ hs_m) hf_zero\n  1      intros &lt;;&gt; simp only [zero_smul, add_smul]\n  1    intro x hx &lt;;&gt; apply_assumption &lt;;&gt;\n  1          (isUnit_of_mul_eq_one f _)\n  1          le_antisymm (le_of_add_le_add_left ((hmn.trans (Nat.succ_le_of_lt h)).trans _)) n&#39;.zero_le\n  1    le_antisymm (sup_le (prod_mono le_sup_left le_sup_left) (prod_mono le_sup_right le_sup_right)) _\n  1    le_antisymm (α := Ideal R) (fun i hi =&gt; _) &lt;|\n  1    le_antisymm (α := Ideal R) (fun i hi =&gt; _) &lt;| (span_singleton_mul_span_singleton a b).ge.trans _\n  1          (le_of_add_le_add_left ((hmn.trans (Nat.succ_le_of_lt h)).trans _)) n&#39;.zero_le\n  1        le_of_forall_nnreal_lt fun r hr =&gt; le_radius_of_bound_nnreal _ (max 1 ‖(1 : A)‖₊) fun n =&gt; _\n  1        le_radius_of_bound_nnreal _ (max 1 ‖(1 : A)‖₊) fun n =&gt; _\n  1    lintegral_nnnorm_le_of_forall_fin_meas_integral_eq hm (Lp.stronglyMeasurable f) _ _ _ _ hs hμs\n  1    lt_of_le_of_lt (_ : _ ≤ card (succ (typein (· &lt; ·) (g p))) * card (succ (typein (· &lt; ·) (g p))))\n  1    lt_of_le_of_ne ((real_inner_le_norm _ _).trans (mul_le_mul_of_nonneg_right _ (norm_nonneg _))) _\n  1        mem_shadow_iff.2\n  1    ⟨M.evalFrom s ((x.take m).take n), (x.take m).take n, (x.take m).drop n,\n  1    ⟨M.evalFrom s ((x.take m).take n), (x.take m).take n, (x.take m).drop n, x.drop m, _, _, _, by\n  1    (Multiset.le_prod_nonempty_of_submultiplicative_on_pred f p h_mul hp_mul _ _ _) _\n  1    (Nat.Coprime.symm (h0.coprime_iff_not_dvd.mpr fun h =&gt; h4 _)) h1 h2 x\n  1    ne_zero_of_dvd_ne_zero hn (d ⟨p, _⟩).prop).mp ⟨_, fun b hb =&gt; _⟩\n  1          (p.changeOriginSeries_summable_aux₂ (mem_emetric_ball_zero_iff.1 x_mem_ball) k)\n  1          (p.changeOriginSeries_summable_aux₂ (mem_emetric_ball_zero_iff.1 x_mem_ball) k) fun s =&gt; _\n  1    ⟨P.recOnHorner (by simp) (fun p r hp₀ _ hp hpr i ↦ _) (fun p _ hnp hpX i ↦ _), fun h ↦ _⟩\n  1        ⟨pullback (Abelian.factorThruImage f) c, 𝟙 _, pullback.snd, inferInstance, inferInstance, _⟩\n  1              pullback.snd, inferInstance, inferInstance, _⟩\n  1    ((real_inner_le_norm _ _).trans (mul_le_mul_of_nonneg_right _ (norm_nonneg _))) _\n  3          refine\n 17        refine\n 71      refine\n 17    · refine\n 43  · refine\n651  refine\n  1    refine ⟨a, b, ⟨⟨⟨_, fun p hp =&gt; _⟩, hab₂⟩, ⟨_, fun p hp =&gt; _⟩⟩, by\n  1  refine and_congr_right&#39;\n  1  refine (Associates.isAtom_iff &lt;|\n  1  refine (Associates.isAtom_iff &lt;| ne_zero_of_dvd_ne_zero hn (d ⟨p, _⟩).prop).mp ⟨_, fun b hb =&gt; _⟩\n  1    refine ⟨ax + ay, fun i =&gt; I.add_mem (hax i) (hay i), Finsupp.sum_add_index&#39; _ _⟩ &lt;;&gt;\n  1    refine ⟨ax + ay, fun i =&gt; I.add_mem (hax i) (hay i), Finsupp.sum_add_index&#39; _ _⟩ &lt;;&gt; intros &lt;;&gt;\n  1  · refine ⟨by\n  1    refine ciSup_eq_of_forall_le_of_forall_lt_exists_gt (fun j =&gt; _) fun n hn =&gt; ⟨i, hn.trans_eq _⟩\n  1  refine closure_cycle_coprime_swap\n  1  refine congr_fun\n  1  refine congr_fun (IccExtend_eq_self zero_le_one smoothTransition (fun x hx =&gt; _) fun x hx =&gt; _) x\n  1          refine disjoint_left.mp\n  1  refine (eq_pow_second_of_chain_of_has_chain hs (fun t u h =&gt; _)\n  1  refine exists_congr fun a =&gt;\n  1    refine Filter.EventuallyEq.trans _ &lt;|\n  1    refine Finset.Subset.trans\n  1  refine forall_congr&#39; fun p =&gt;\n  1    refine ⟨⟨f, Quotient.mk&#39;&#39; ⟨f.deg, ⟨f.den, f.den_mem_deg⟩,\n  1    refine ⟨⟨f, Quotient.mk&#39;&#39; ⟨f.deg, ⟨f.den, f.den_mem_deg⟩, ⟨f.num, f.num_mem_deg⟩, mem2⟩, _, _⟩,\n  1    refine ⟨fun a =&gt; if h : a ∈ s then p ⟨a, h⟩ else univ,\n  1  refine ⟨fun h : (preadditiveYonedaObj J ⋙ (forget &lt;| ModuleCat (End J))).PreservesEpimorphisms =&gt;\n  1  refine ⟨fun hx =&gt;\n  1      · refine fun n =&gt; eventually_of_forall fun y =&gt;\n  1      · refine fun n =&gt; eventually_of_forall fun y =&gt; SimpleFunc.norm_approxOn_zero_le _ _ (x, y) n\n  1  refine (h.const_mul ‖L‖).mono&#39;\n  1  refine ((hf.comp_tendsto hg).symm.congr&#39;\n  1    refine hmn.mul_dvd_of_dvd_of_dvd _ _ &lt;;&gt;\n  1    refine hmn.mul_dvd_of_dvd_of_dvd _ _ &lt;;&gt; rw [← natCast_dvd_natCast, natAbs_dvd, dvd_natAbs] &lt;;&gt;\n  1  refine (Iff.trans _ &lt;| hfg.sum_smul_comp_perm_eq_sum_smul_iff hσinv).trans\n  1  refine (Iff.trans _ &lt;| hfg.sum_smul_comp_perm_eq_sum_smul_iff hσinv).trans ⟨fun h ↦ _, fun h ↦ _⟩\n  1        refine le_antisymm\n  1  refine le_antisymm\n  1      refine le_of_forall_nnreal_lt fun r hr =&gt;\n  1  refine le_trans\n  1  refine le_trans (Multiset.le_prod_nonempty_of_submultiplicative_on_pred f p h_mul hp_mul _ _ _) _\n  1  refine lhopital_zero_right_on_Ioo hau _ _ _ hfa hga hdiv &lt;;&gt;\n  1  refine lhopital_zero_right_on_Ioo hau _ _ _ hfa hga hdiv &lt;;&gt; intro x hx &lt;;&gt; apply_assumption &lt;;&gt;\n  1  refine lintegral_nnnorm_le_of_forall_fin_meas_integral_eq\n</code></pre></div>",
        "id": 440511078,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716557828
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>  1  refine lt_of_le_of_lt\n  1  refine lt_of_le_of_ne\n  1    · refine mem_shadow_iff.2\n  1  refine ⟨P.recOnHorner (by simp) (fun p r hp₀ _ hp hpr i ↦ _) (fun p _ hnp hpX i ↦ _), fun h ↦ _⟩\n  1      refine ⟨pullback (Abelian.factorThruImage f) c, 𝟙 _,\n  1  refine quadrant_II\n  1  refine quadrant_II (hd.comp differentiable_neg.diffContOnCl H) _ (fun x hx =&gt; _) (fun x hx =&gt; _)\n  1      refine RelHomClass.wellFounded\n  1  refine ⟨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel &lt;| htu.trans &lt;| P.le hu₁), _, _, _⟩\n  1    refine ⟨Set.indicator u fun _ =&gt; c,\n  1        RelHomClass.wellFounded\n  1          (RelHom.mk _ _ : (DvdNotUnit : α → α → Prop) →r ((· &lt; ·) : ℕ∞ → ℕ∞ → Prop)) wellFounded_lt\n  1        (RelHom.mk _ _ : (DvdNotUnit : α → α → Prop) →r ((· &lt; ·) : ℕ∞ → ℕ∞ → Prop)) wellFounded_lt\n  1    ⟨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel &lt;| htu.trans &lt;| P.le hu₁), _, _, _⟩\n  1        rfl⟩\n  1      rfl, _⟩\n  1      rw [← natCast_dvd_natCast, natAbs_dvd, dvd_natAbs] &lt;;&gt;\n  1      rw [repr, ihb.1, add_succ, repr], fun H =&gt; H.fst.oadd _ (NF.below_of_lt&#39; _ (ihb.2 H.snd))⟩\n  1      ⟨Set.indicator u fun _ =&gt; c, fun x =&gt; _, u_open.lowerSemicontinuous_indicator (zero_le _), _⟩\n  1          SimpleFunc.norm_approxOn_zero_le _ _ (x, y) n\n  1      simp only [zero_smul, add_smul]\n  1      simp_rw [Function.onFun, iSup_disjoint_iff, disjoint_iSup_iff] &lt;;&gt;\n  1    simp_rw [Function.onFun, iSup_disjoint_iff, disjoint_iSup_iff] &lt;;&gt;\n  1        simp_rw [hab₁, m.add_one_sub_one]⟩\n  1      (span_singleton_mul_span_singleton a b).ge.trans _\n  1    (sup_le (prod_mono le_sup_left le_sup_left) (prod_mono le_sup_right le_sup_right)) _\n  1      supports_insert.2 ⟨⟨fun _ =&gt; h₁, fun _ =&gt; h₂.2 _ (Or.inl W),\n  1      supports_insert.2 ⟨⟨fun _ =&gt; h₁, fun _ =&gt; h₂.2 _ (Or.inl W), fun _ =&gt; h₂.1, fun _ =&gt; h₂.1⟩, _⟩\n  1            sup_sdiff_mem_of_mem_compression Ht hvt &lt;| disjoint_of_erase_right hau huvs.1, a, _, _⟩\n  1          sup_sdiff_mem_of_mem_compression Ht hvt &lt;| disjoint_of_erase_right hau huvs.1, a, _, _⟩\n  1          ⟨(t ⊔ u) \\ v,\n  1        ⟨(t ⊔ u) \\ v,\n  1      (vars_add_subset _ _) (Finset.union_subset_union (Finset.Subset.refl _) _)\n  1                    x.drop m, _, _, _, by rfl, _⟩\n  1           ⟨⟨x, ⟨(↑hx.unit⁻¹ : A), StarSubalgebra.isUnit_coe_inv_mem hS hx x.prop⟩, _, _⟩, rfl⟩,\n  1      ⟨y, hy, z, hz, _, _, _, _, _, rfl⟩,\n  1      ⟨y, hy, z, hz, _, _, _, _, _, rfl⟩, a₂ * a₁, a₂ * b₁ + b₂, mul_nonneg ha₂ ha₁, hab.le, _, _⟩\n</code></pre></div>",
        "id": 440511086,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716557831
    },
    {
        "content": "<p>I am not sure if this is helpful: here is what it is.</p>",
        "id": 440511163,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716557846
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>git<span class=\"w\"> </span>diff<span class=\"w\"> </span>--unified<span class=\"o\">=</span><span class=\"m\">0</span><span class=\"w\"> </span>origin/master...HEAD<span class=\"w\"> </span><span class=\"p\">|</span>\n<span class=\"w\">  </span>sed<span class=\"w\"> </span>-n<span class=\"w\"> </span><span class=\"s1\">'s=^+\\([^+]\\)==p; s=^-\\([^-]\\)==p'</span><span class=\"w\"> </span><span class=\"p\">|</span>\n<span class=\"w\">  </span>sed<span class=\"w\"> </span><span class=\"s1\">'s=refine'</span><span class=\"s2\">\"'\"</span><span class=\"s1\">'=refine=g; s=?==g'</span><span class=\"w\"> </span><span class=\"p\">|</span>\n<span class=\"w\">  </span>sort<span class=\"w\"> </span><span class=\"p\">|</span><span class=\"w\"> </span>uniq<span class=\"w\"> </span>-c<span class=\"w\"> </span><span class=\"p\">|</span><span class=\"w\"> </span>grep<span class=\"w\"> </span>-v<span class=\"w\"> </span><span class=\"s2\">\"^ *[0-9]*[02468] \"</span>\n</code></pre></div>",
        "id": 440511255,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716557874
    },
    {
        "content": "<ul>\n<li>Gets the diff printing only the line changes (plus fluff)</li>\n<li>extracts the lines that begin with either a single <code>+</code> or a single <code>-</code> (these should be the lines of the actual diff)</li>\n<li>changes <code>refine'</code> to <code>refine</code> and strips out <code>?</code></li>\n<li>sorts, prefixes multiplicities on repeated lines, removes lines whose multiplicity is even.</li>\n</ul>",
        "id": 440511611,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716557992
    },
    {
        "content": "<p>(at least, these are many fewer lines than the diff the GitHub shows...).</p>",
        "id": 440511831,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716558062
    },
    {
        "content": "<p>Oh, you can check that no declaration was lost!</p>",
        "id": 440511869,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716558070
    },
    {
        "content": "<p>Let me do that!</p>",
        "id": 440511882,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716558074
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313166.20.60refine'.60.20to.20.60refine.60/near/440509450\">said</a>:</p>\n<blockquote>\n<p>You could replace on master and the PR <code>refine'</code> with <code>refine</code> and remove all <code>?</code> and diff the output.</p>\n</blockquote>\n<p>I created <a href=\"https://github.com/leanprover-community/mathlib4/tree/MR-refine-master-with-replacement\">branch#MR-refine-master-with-replacement</a> and <a href=\"https://github.com/leanprover-community/mathlib4/tree/MR-refine-to-refine-butchered\">branch#MR-refine-to-refine-butchered</a> doing exactly this:</p>\n<ul>\n<li>replacing all <code>refine'</code> be <code>refine</code> and all <code>?_</code> by <code>_</code> (automatically),</li>\n<li>both on the parent commit of <a href=\"https://github.com/leanprover-community/mathlib4/pull/13166\">#13166</a> (the first branch) and on top of the PR.</li>\n</ul>",
        "id": 440517374,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1716559727
    },
    {
        "content": "<p>In theory, <a href=\"https://github.com/leanprover-community/mathlib4/compare/MR-refine-master-with-replacement...MR-refine-to-refine-butchered\">this diff</a> is supposed to give the output and be virtually empty...</p>",
        "id": 440517583,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1716559795
    },
    {
        "content": "<p>Wrong link?</p>",
        "id": 440517730,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1716559830
    },
    {
        "content": "<p>In practice, something's off - I would think with github's diff, or my local methodology.</p>",
        "id": 440517820,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1716559867
    },
    {
        "content": "<p>(I don't have time until the evening to look into what is going wrong, sorry.)</p>",
        "id": 440518093,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1716559952
    },
    {
        "content": "<p>I thought that the issue was that in the replacement you had removed the first <code>?</code> of each line, so I went ahead and tried removing all <code>?</code>s, but I still can't get the diff to show that I think that it should...</p>",
        "id": 440528279,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716563346
    },
    {
        "content": "<p>Also, note that there were quite a few <code>refine</code> that spanned several lines and the <code>?</code> are not necessarily added on the same line where there is a <code>refine</code>.</p>",
        "id": 440528987,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716563612
    },
    {
        "content": "<p>I did enough spot testing to convince myself that things look good. <img alt=\":merge:\" class=\"emoji\" src=\"https://zulip-avatars.s3.amazonaws.com/3121/emoji/images/18527.png\" title=\"merge\"></p>",
        "id": 440537842,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716567018
    },
    {
        "content": "<p>Much thanks!</p>",
        "id": 440537876,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716567028
    }
]