[
    {
        "content": "<p>Semi-automated bisect over dependency versions might be quite helpful, too, at least for narrowing in to a commit that might be specific enough that the leaf output won't have much clutter to wade through.</p>",
        "id": 412192284,
        "sender_full_name": "namibj",
        "timestamp": 1704909091
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> this tool looks great! My understanding was that each trait contributes a fixed \"cost\" - what would it take to consider tree diffs of types rather than hash comparisons?</p>",
        "id": 412195957,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704910629
    },
    {
        "content": "<p>Lovely talk! Looking forward to having this integrated in mathlib CI!</p>",
        "id": 412196196,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1704910718
    },
    {
        "content": "<p>I am definitely concerned about the case of lean version changes, because these happen periodically in mathlib and the probability of a lean version change tends to 1 as the mathlib window width grows</p>",
        "id": 412196967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704911015
    },
    {
        "content": "<p>I think it will require changes to the olean format though, because currently all you have is a lean4 commit sha and these aren't really ordered unless you maintain a list of all lean4 commit shas</p>",
        "id": 412197181,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704911109
    },
    {
        "content": "<p>Tangential comment:<br>\nIn case these automatic comments on PRs become too noisy (need to be scrolled through, trigger notification), one can also use the github API to write a “check” including markdown-formatted status pages:<br>\n<a href=\"https://docs.github.com/en/rest/checks/runs?apiVersion=2022-11-28#create-a-check-run\">https://docs.github.com/en/rest/checks/runs?apiVersion=2022-11-28#create-a-check-run</a><br>\nOr a bit simpler using job summaries:<br>\n<a href=\"https://github.blog/2022-05-09-supercharging-github-actions-with-job-summaries/\">https://github.blog/2022-05-09-supercharging-github-actions-with-job-summaries/</a><br>\nThen it’s one click away, so only really visible to those who know it’s there, but it's less verbose.</p>",
        "id": 412197279,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1704911154
    },
    {
        "content": "<p>I think we could also just remove proof changes from the PR comment output, I don't think that is very useful unless you are debugging core changes</p>",
        "id": 412197445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704911217
    },
    {
        "content": "<p>It does already print a job summary, which is helpful for commits not attached to a PR. I agree that it can be spammy, I was planning to explore using <code>&lt;summary&gt;</code> tags on github markdown to give the user the option of which type of diffs you want to see.</p>",
        "id": 412197535,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1704911252
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Leaff.3A.20a.20Lean.20library.20diff.20tool.20-.20Alex.20Best/near/412197445\">said</a>:</p>\n<blockquote>\n<p>I think we could also just remove proof changes from the PR comment output, I don't think that is very useful unless you are debugging core changes</p>\n</blockquote>\n<p>Yeah this is also probably true!</p>",
        "id": 412197601,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1704911280
    },
    {
        "content": "<p>my thought regarding version changes is to use leangz, which can double as a olean migration tool because it is version aware and is essentially the only tool in the lean ecosystem which is capable of reading oleans generated by multiple versions of lean</p>",
        "id": 412197976,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704911427
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Leaff.3A.20a.20Lean.20library.20diff.20tool.20-.20Alex.20Best/near/412196967\">said</a>:</p>\n<blockquote>\n<p>I am definitely concerned about the case of lean version changes, because these happen periodically in mathlib and the probability of a lean version change tends to 1 as the mathlib window width grows</p>\n</blockquote>\n<p>Yeah this is one reason why I think keeping a list of diffs for each commit to master and then composing them is a better way of getting to a diff for a long period.</p>\n<p>If  <code>CHECK_OLEAN_VERSION</code> was overridable at runtime that would make it much simpler to diff over changed lean version</p>",
        "id": 412197985,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1704911429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"354934\">David Thrane Christiansen</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Leaff.3A.20a.20Lean.20library.20diff.20tool.20-.20Alex.20Best/near/412195957\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> this tool looks great! My understanding was that each trait contributes a fixed \"cost\" - what would it take to consider tree diffs of types rather than hash comparisons?</p>\n</blockquote>\n<p>Thanks, I still think it would be good to use the hashes as a first pass so we can ignore everything that definitely didn't change, but outputting tree diffs when the type did change would definitely be a nice feature for usability.</p>",
        "id": 412198197,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1704911524
    },
    {
        "content": "<p>You can also probably get a performance boost by not building an <code>Environment</code> at all and instead reading the <code>ModuleData</code>s directly. This is what <code>lake exe shake</code> does</p>",
        "id": 412198311,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704911588
    },
    {
        "content": "<p>that also gives you an easy place to early-out when a module / constant is unchanged</p>",
        "id": 412198379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704911624
    },
    {
        "content": "<p>it may also help with the issue of partially failed builds since it makes you less sensitive to errors</p>",
        "id": 412198581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704911721
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Leaff.3A.20a.20Lean.20library.20diff.20tool.20-.20Alex.20Best/near/412198197\">said</a>:</p>\n<blockquote>\n<p>Thanks, I still think it would be good to use the hashes as a first pass so we can ignore everything that definitely didn't change, but outputting tree diffs when the type did change would definitely be a nice feature for usability.</p>\n</blockquote>\n<p>Agreed on hashing first! But it seems that the tree diff might also be useful in figuring out whether something was renamed, moved, <strong>and</strong> had a new type class requirement added to its signature, vs a delete/add</p>",
        "id": 412199861,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704912310
    },
    {
        "content": "<p>RE prior work - I believe Elm has something like this</p>",
        "id": 412200018,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704912383
    },
    {
        "content": "<p>Also, the GHC devs use a similar technique to ensure that there's no unexpected changes to the standard library from one release to another</p>",
        "id": 412200072,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704912410
    },
    {
        "content": "<p>Though they just dump the interface to a text file and then use text diff of that, I suppose</p>",
        "id": 412200199,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704912476
    },
    {
        "content": "<p><a href=\"https://gitlab.haskell.org/ghc/ghc/-/commit/8165404bb7ab37bada9c2ccf99c9711817ff8f13\">GHC</a></p>",
        "id": 412200591,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704912630
    },
    {
        "content": "<p>Can Leaff somehow spit out binder annotation changes? When regrouping assumptions by grouping them up in variable lines, as for example in <a href=\"https://github.com/leanprover-community/mathlib4/pull/9696\">#9696</a>, a double check by leaff would be great. Currently it does not seem to do that though.</p>",
        "id": 412580058,
        "sender_full_name": "Christian Merten",
        "timestamp": 1705077305
    },
    {
        "content": "<p>I would say yes it's a planned feature to output the most useful information in such a situation at the very least. Can you say a bit more about what you'd like to see for this PR specifically (or what you'd hope to see if the PR made an unintended change) so I can make sure it behaves as you want in future.</p>",
        "id": 412584482,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1705078829
    },
    {
        "content": "<p>Minimal example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n  <span class=\"n\">congrArg</span> <span class=\"n\">f</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>vs</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n  <span class=\"n\">congrArg</span> <span class=\"n\">f</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>should be shown as different.</p>",
        "id": 412587213,
        "sender_full_name": "Christian Merten",
        "timestamp": 1705079742
    },
    {
        "content": "<p>I'm getting the following error on recent <code>Mathlib</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">uncaught</span> <span class=\"n\">exception</span><span class=\"o\">:</span> <span class=\"n\">unknown</span> <span class=\"n\">package</span> <span class=\"bp\">'</span><span class=\"n\">ImportGraph'</span>\n</code></pre></div>",
        "id": 413052277,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705365270
    },
    {
        "content": "<p>What are the two mathlib versions?</p>",
        "id": 413052458,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1705365342
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/tree/YK-sort-meas\">branch#YK-sort-meas</a> (3715cfa2fa) and 137ab0bb05 (<code>master</code>)</p>",
        "id": 413053032,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705365555
    },
    {
        "content": "<p>there was some time when cache was broken and would not download <code>ImportGraph</code>. Try running <code>lake build</code> in both projects first</p>",
        "id": 413053217,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705365620
    },
    {
        "content": "<p>UPD: possibly, bad cache</p>",
        "id": 413053225,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705365624
    },
    {
        "content": "<p>For some reason, I have to <code>lake clean</code> before <code>lake exe cache get</code>, or I get bad oleans from time to time.</p>",
        "id": 413053303,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705365666
    },
    {
        "content": "<p>repros are helpful for that (but we may not be able to do anything about issues in an old version)</p>",
        "id": 413053381,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705365701
    },
    {
        "content": "<p>or at least a description of what you did and what the error message is</p>",
        "id": 413053510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705365745
    },
    {
        "content": "<p>Can I ask <code>leaff</code> to pretty-print old and new types for \"type changed\"?</p>",
        "id": 413053685,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705365831
    },
    {
        "content": "<p>Not right now, but its a feature I'd like to add very soon</p>",
        "id": 413055248,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1705366360
    },
    {
        "content": "<p>I'm going to open a bunch of Github issues on <a href=\"https://github.com/alexjbest/leaff\">https://github.com/alexjbest/leaff</a> so that we can refer to particular missing features by numbers.</p>",
        "id": 416843164,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705689245
    },
    {
        "content": "<p>Great idea, thanks! I'll try and copy anything else I can think of there when you are done</p>",
        "id": 416843360,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1705689328
    },
    {
        "content": "<p>I opened 6 issues. I'm done for now.</p>",
        "id": 416846504,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705690424
    },
    {
        "content": "<p>Is it possible to run leaff on a mathlib PR? I remember seeing some instructions but cannot find it now.</p>",
        "id": 435332219,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1714031572
    }
]