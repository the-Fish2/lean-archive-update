[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132858\">@Ramon Fernández Mir</span> is there a fundamental reason why you don't do the change of variables in the equality saturation part as a rewrite?</p>",
        "id": 412587915,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1705079985
    },
    {
        "content": "<p>That is a great question!! I tried to do that initially. </p>\n<p>If you do it naively by adding a rule that merges <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>e</mi><msup><mi>x</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></msup></mrow><annotation encoding=\"application/x-tex\">e^{x&#x27;}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9425em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9425em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8278em;\"><span style=\"top:-2.931em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>, then you have an issue when analyzing curvatures because the same e-class could have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>log</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\log(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">x&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>e</mi><msup><mi>x</mi><mrow><mo mathvariant=\"normal\">′</mo><mo mathvariant=\"normal\">′</mo></mrow></msup></msup></mrow><annotation encoding=\"application/x-tex\">e^{x&#x27;&#x27;}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9425em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9425em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8278em;\"><span style=\"top:-2.931em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>. I assume that terms represented by the same e-class only have one known curvature (e-classes will have nodes that are a mixture of {DCP unknown, DCP convex} or {DCP unknown, DCP concave} or {DCP unknown, DCP affine}). Or, in other words, rewrites preserve the \"mathematical\" curvature of expressions.</p>\n<p>I think it might be possible to make egg explore changes of variables, but it is not straightforward because they are a problem-level transformation, so it cannot be done locally by replacing var nodes.</p>",
        "id": 412589108,
        "sender_full_name": "Ramon Fernández Mir",
        "timestamp": 1705080421
    },
    {
        "content": "<p>It was also a bit of a design decision, where I wanted to split what the user does and what egg can do more clearly. But if we could use egg to discover changes of variables, that would be very cool, especially for more complicated ones.</p>",
        "id": 412589338,
        "sender_full_name": "Ramon Fernández Mir",
        "timestamp": 1705080505
    },
    {
        "content": "<p>oh interesting! Yeah that makes sense, the change of variables does not fall into the type of equivalence of terms you're considering there? even if the resulting domains are equivalent?</p>",
        "id": 412593410,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1705082145
    },
    {
        "content": "<p>or is it more subtle (that the convexity is not an invariant of the equivalence class of the terms)?</p>",
        "id": 412593553,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1705082182
    },
    {
        "content": "<p>When working with <code>Matrix.Computable.dotProduct</code>, can you reuse mathlib theorems about <code>Matrix.dotProduct</code>?</p>",
        "id": 412593656,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705082221
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315434\">Andrés Goens</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/CvxLean.3A.20modeling.20convex.20optimization.20problems.20in.20Lean/near/412593410\">said</a>:</p>\n<blockquote>\n<p>oh interesting! Yeah that makes sense, the change of variables does not fall into the type of equivalence of terms you're considering there? even if the resulting domains are equivalent?</p>\n</blockquote>\n<p>Basically they are not a \"rewrite\" but rather a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mo separator=\"true\">,</mo><mi>c</mi><mi>s</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo>&gt;</mo><mo stretchy=\"false\">(</mo><mi>f</mi><mo>∘</mo><mi>g</mi><mo separator=\"true\">,</mo><mi>c</mi><mi>s</mi><mo>∘</mo><mi>g</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(f, cs) =&gt; (f \\circ g, cs \\circ g)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">cs</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">cs</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> is the change of variables. Note that this is an issue because what we send egg is the \"skolemized\" objective function and constraints. So in order to do that properly, we would need to have functions (so you have to deal with binders, which is annoying in egg) as part of our language in egg and rules for composition. If we had that, then you could add it as a rewrite rule.</p>\n<p>We support some maps, but these are of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mo separator=\"true\">,</mo><mi>c</mi><mi>s</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo>&gt;</mo><mo stretchy=\"false\">(</mo><mi>m</mi><mo>∘</mo><mi>f</mi><mo separator=\"true\">,</mo><mi>c</mi><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(f, cs) =&gt; (m \\circ f, cs)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">cs</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">cs</span><span class=\"mclose\">)</span></span></span></span>, which are easy to simulate as rewrites.</p>",
        "id": 412595363,
        "sender_full_name": "Ramon Fernández Mir",
        "timestamp": 1705082817
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/CvxLean.3A.20modeling.20convex.20optimization.20problems.20in.20Lean/near/412593656\">said</a>:</p>\n<blockquote>\n<p>When working with <code>Matrix.Computable.dotProduct</code>, can you reuse mathlib theorems about <code>Matrix.dotProduct</code>?</p>\n</blockquote>\n<p>No, we indeed lose any lemma about dot products. These are only used once you have your reduced problem and you want to extract the coefficients so that you can solve it (say, a constraint is <code>posOrthCone (dotProduct a x)</code> where <code>a</code> is constant). Then, in general, you need to compute to extract <code>a</code>. So we replace every real function by its floating-point counter parts and get the coefficients of the problem. And we do not prove any correctness result about that step.</p>",
        "id": 412595898,
        "sender_full_name": "Ramon Fernández Mir",
        "timestamp": 1705083006
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132858\">Ramon Fernández Mir</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/CvxLean.3A.20modeling.20convex.20optimization.20problems.20in.20Lean/near/412595363\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"315434\">Andrés Goens</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/CvxLean.3A.20modeling.20convex.20optimization.20problems.20in.20Lean/near/412593410\">said</a>:</p>\n<blockquote>\n<p>oh interesting! Yeah that makes sense, the change of variables does not fall into the type of equivalence of terms you're considering there? even if the resulting domains are equivalent?</p>\n</blockquote>\n<p>Basically they are not a \"rewrite\" but rather a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mo separator=\"true\">,</mo><mi>c</mi><mi>s</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo>&gt;</mo><mo stretchy=\"false\">(</mo><mi>f</mi><mo>∘</mo><mi>g</mi><mo separator=\"true\">,</mo><mi>c</mi><mi>s</mi><mo>∘</mo><mi>g</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(f, cs) =&gt; (f \\circ g, cs \\circ g)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">cs</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">cs</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> is the change of variables. Note that this is an issue because what we send egg is the \"skolemized\" objective function and constraints. So in order to do that properly, we would need to have functions (so you have to deal with binders, which is annoying in egg) as part of our language in egg and rules for composition. If we had that, then you could add it as a rewrite rule.</p>\n<p>We support some maps, but these are of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mo separator=\"true\">,</mo><mi>c</mi><mi>s</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo>&gt;</mo><mo stretchy=\"false\">(</mo><mi>m</mi><mo>∘</mo><mi>f</mi><mo separator=\"true\">,</mo><mi>c</mi><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(f, cs) =&gt; (m \\circ f, cs)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">cs</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">cs</span><span class=\"mclose\">)</span></span></span></span>, which are easy to simulate as rewrites.</p>\n</blockquote>\n<p>Here by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mo separator=\"true\">,</mo><mi>c</mi><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(f,cs)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">cs</span><span class=\"mclose\">)</span></span></span></span> I mean objective function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> and constraints <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">cs</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">cs</span></span></span></span></p>",
        "id": 412595977,
        "sender_full_name": "Ramon Fernández Mir",
        "timestamp": 1705083052
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132858\">Ramon Fernández Mir</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/CvxLean.3A.20modeling.20convex.20optimization.20problems.20in.20Lean/near/412595898\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/CvxLean.3A.20modeling.20convex.20optimization.20problems.20in.20Lean/near/412593656\">said</a>:</p>\n<blockquote>\n<p>When working with <code>Matrix.Computable.dotProduct</code>, can you reuse mathlib theorems about <code>Matrix.dotProduct</code>?</p>\n</blockquote>\n<p>No, we indeed lose any lemma about dot products. These are only used once you have your reduced problem and you want to extract the coefficients so that you can solve it (say, a constraint is <code>posOrthCone (dotProduct a x)</code> where <code>a</code> is constant). Then, in general, you need to compute to extract <code>a</code>. So we replace every real function by its floating-point counter parts and get the coefficients of the problem. And we do not prove any correctness result about that step.</p>\n</blockquote>\n<p>You define <code>Matrix.Computable.dotProduct</code> generically but then you use it only for <code>α</code> being <code>Float</code>? Or are there also integer types?</p>",
        "id": 412597082,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705083486
    },
    {
        "content": "<p>It is only used for <code>Float</code> at the moment</p>",
        "id": 412597263,
        "sender_full_name": "Ramon Fernández Mir",
        "timestamp": 1705083564
    }
]