[
    {
        "content": "<p>Here's the paper: <a href=\"https://arxiv.org/abs/2310.01530\">https://arxiv.org/abs/2310.01530</a></p>",
        "id": 412181215,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704905043
    },
    {
        "content": "<p>The conceptual flexibility here w.r.t. the layout-vs-cost correspondence together with how flexible the layout choices can be, makes me hopeful about getting an easy extension to support for proportional fonts.</p>",
        "id": 412182611,
        "sender_full_name": "namibj",
        "timestamp": 1704905540
    },
    {
        "content": "<p>I implemented support for proportional fonts in a variant of a Wadler-style pretty printer once, in Haskell. The technique was that the renderer (Doc -&gt; String) had to run in a monad that supported the ability to measure the empirical width of a string</p>",
        "id": 412182985,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704905668
    },
    {
        "content": "<p>I had a backend with ghcjs that would reflow documents in response to browser resizing</p>",
        "id": 412183189,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704905743
    },
    {
        "content": "<p>Yeah, \"measure empirical width\" is what I'd have reached for as the naive way, too. Does neglect kerning, though: e.g. width of spaces is somewhat flexible, and mild variation there usually trumps mild <em>vertical</em> unalignment.</p>",
        "id": 412183488,
        "sender_full_name": "namibj",
        "timestamp": 1704905860
    },
    {
        "content": "<p>Here's my not (yet) so well optimized clone: <a href=\"https://github.com/hargoniX/pfmt/\">https://github.com/hargoniX/pfmt/</a></p>",
        "id": 412183611,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1704905900
    },
    {
        "content": "<p>This is why it's necessary to measure strings rather than characters - this is needed for scripts like Arabic or Devanagari even moreso than for Latin</p>",
        "id": 412184038,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704906035
    },
    {
        "content": "<p>So <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span>, to make it clear, this is your ongoing implementation of a lean library from the ideas of the paper, right? despite the performance, is it feature complete?</p>",
        "id": 412184326,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1704906123
    },
    {
        "content": "<p>Yes, it doesnt have any proofs etc. but it can do the stuff from the paper, see the unit tests in Main.lean: <a href=\"https://github.com/hargoniX/pfmt/blob/main/Main.lean#L5-L128\">https://github.com/hargoniX/pfmt/blob/main/Main.lean#L5-L128</a></p>\n<p>The two things that have to be done are the performance and actually integrating the algorithm with Lean.</p>",
        "id": 412184626,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1704906220
    },
    {
        "content": "<p>Though vertical alignment is even more complicated with variable-width fonts - I pretty-printed Haskell and had to have ways of aligning <code>=</code> and <code>|</code> vertically such that the <code>|</code> was centered WRT the <code>=</code></p>",
        "id": 412184660,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704906233
    },
    {
        "content": "<p>The other thing we did was add semantic annotations (like the tags in the Lean pprinter), and we needed a way of having annotations affect font choice and make that interact with the measurement (e.g. bolding keywords makes them wider)</p>",
        "id": 412184964,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704906332
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span>; I am looking for a pretty printer for my <a href=\"https://github.com/arademaker/delphin\">https://github.com/arademaker/delphin</a>.  It can parse structures like <a href=\"https://github.com/delph-in/docs/wiki/MrsRFC#overview\">https://github.com/delph-in/docs/wiki/MrsRFC#overview</a>. But I also need to serialize them.</p>",
        "id": 412185954,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1704906695
    },
    {
        "content": "<p>Lean itself contains a pretty printer that's not as fancy as <span class=\"user-mention\" data-user-id=\"360581\">@Sorawee Porncharoenwase</span>'s - the document datatype is called <code>Std.Format</code></p>",
        "id": 412186087,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704906742
    },
    {
        "content": "<p>Yes <span class=\"user-mention\" data-user-id=\"354934\">@David Thrane Christiansen</span> , I started to read Wadler's <a href=\"https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf\">paper</a> to understand it. I do need more time, I could not make it work yet.</p>",
        "id": 412186490,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1704906887
    },
    {
        "content": "<p>Quick demo to get started:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Expr</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">atom</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">entries</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Expr</span><span class=\"o\">)</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">pp</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Std.Format</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">atom</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">text</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">list</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">text</span> <span class=\"s2\">\"(\"</span> <span class=\"bp\">++</span> <span class=\"bp\">.</span><span class=\"n\">group</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nest</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">joinSep</span> <span class=\"o\">(</span><span class=\"n\">xs.map</span> <span class=\"n\">pp</span><span class=\"o\">)</span> <span class=\"bp\">.</span><span class=\"n\">line</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"s2\">\")\"</span><span class=\"o\">)</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">ex</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">atom</span> <span class=\"s2\">\"x\"</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">ns</span> <span class=\"o\">:=</span> <span class=\"n\">n.fold</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"o\">::</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"o\">[]</span>\n    <span class=\"bp\">.</span><span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">ns.map</span> <span class=\"n\">ex</span><span class=\"o\">)</span>\n\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">((() x) (x) () x)</span>\n\n<span class=\"cm\">-/</span>\n<span class=\"k\">#eval</span> <span class=\"n\">pp</span> <span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"mi\">5</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">(((((x) () x) (() x) (x) () x) ((() x) (x) () x) ((x) () x) (() x) (x) () x)</span>\n<span class=\"cm\">  (((() x) (x) () x) ((x) () x) (() x) (x) () x)</span>\n<span class=\"cm\">  (((x) () x) (() x) (x) () x)</span>\n<span class=\"cm\">  ((() x) (x) () x)</span>\n<span class=\"cm\">  ((x) () x)</span>\n<span class=\"cm\">  (() x)</span>\n<span class=\"cm\">  (x)</span>\n<span class=\"cm\">  ()</span>\n<span class=\"cm\">  x)</span>\n\n<span class=\"cm\">-/</span>\n<span class=\"k\">#eval</span> <span class=\"n\">pp</span> <span class=\"o\">(</span><span class=\"n\">ex</span> <span class=\"mi\">10</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 412187177,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704907143
    },
    {
        "content": "<p>Note that Wadler's implementation won't work in a strict language - the code needs refactoring for that</p>",
        "id": 412187252,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704907178
    },
    {
        "content": "<p>But I think I'd learn this not by reading the paper, but instead by working with a few examples to get a feel for the API</p>",
        "id": 412187358,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704907205
    },
    {
        "content": "<p>You can write a reasonable pretty printer just with <code>.line</code> (newline), <code>.group</code> (undoes newlines inside itself as long as it fits on the line), <code>.text</code> (inserts a literal string), <code>++</code> (append two documents), <code>.nest</code> (controls indentation following newlines in its body)</p>",
        "id": 412187885,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704907397
    },
    {
        "content": "<p>Do these tools also allow to enforce code style, such as forbidding space after an opening parenthesis?</p>",
        "id": 412189177,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1704907811
    },
    {
        "content": "<p>Here's an annotated version of that program that might be helpful:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">pp</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Std.Format</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n  <span class=\"c1\">-- Emit atoms literally</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">atom</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">text</span> <span class=\"n\">x</span>\n  <span class=\"c1\">-- A list is parens surrounding its contents. Put them on one line if</span>\n  <span class=\"c1\">-- possible, or one item per line otherwise with two spaces indentation.</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">list</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"c1\">-- Start with a (</span>\n    <span class=\"bp\">.</span><span class=\"n\">text</span> <span class=\"s2\">\"(\"</span> <span class=\"bp\">++</span>\n    <span class=\"c1\">-- \"group\" means to put the contents on the same line if possible. It does</span>\n    <span class=\"c1\">-- this by replacing all the \"line\" calls immediately under itself (that is,</span>\n    <span class=\"c1\">-- not under a nested \"group\") with spaces</span>\n    <span class=\"bp\">.</span><span class=\"n\">group</span>\n      <span class=\"c1\">-- \"nest 2\" means to indent by two extra spaces after newlines</span>\n      <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nest</span> <span class=\"mi\">2</span>\n        <span class=\"c1\">-- joinSep takes a list of documents and a separator document, and</span>\n        <span class=\"c1\">-- appends the list with the separator between them. Here, the separator</span>\n        <span class=\"c1\">-- is \"line\", putting newlines between the items. The final closing</span>\n        <span class=\"c1\">-- paren is appended here to put it on the same line as the last list</span>\n        <span class=\"c1\">-- element.</span>\n        <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">joinSep</span> <span class=\"o\">(</span><span class=\"n\">xs.map</span> <span class=\"n\">pp</span><span class=\"o\">)</span> <span class=\"bp\">.</span><span class=\"n\">line</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"s2\">\")\"</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 412189179,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704907811
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/A.20Pretty.20Expressive.20Printer.20-.20Sorawee.20Porncharoenwase/near/412189177\">said</a>:</p>\n<blockquote>\n<p>Do these tools also allow to enforce code style, such as forbidding space after an opening parenthesis?</p>\n</blockquote>\n<p>Only indirectly, by comparing the output of the formatter to its input</p>",
        "id": 412189304,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704907868
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/A.20Pretty.20Expressive.20Printer.20-.20Sorawee.20Porncharoenwase/near/412189177\">said</a>:</p>\n<blockquote>\n<p>Do these tools also allow to enforce code style, such as forbidding space after an opening parenthesis?</p>\n</blockquote>\n<p>the idea is that we take your code as a syntax tree together with a series of valid ways to format it and pick the optimal one. If your valid ways to format it dont contain spaces after an opening parenthesis you won't get that in the result.</p>",
        "id": 412189335,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1704907884
    },
    {
        "content": "<blockquote>\n<p>Note that Wadler's implementation won't work in a strict language - the code needs refactoring for that</p>\n</blockquote>\n<p>Yeah, as you said it's not too hard to work out how to do so oneself. There's also a short paper describing how to implement Wadler's algorithm in a strict language: <a href=\"https://lindig.github.io/papers/strictly-pretty-2000.pdf\">https://lindig.github.io/papers/strictly-pretty-2000.pdf</a></p>",
        "id": 412189553,
        "sender_full_name": "Justin Pombrio",
        "timestamp": 1704907950
    },
    {
        "content": "<p>Ken Friis Larsen has an SML port that's very short, with few features, but that also illustrates the technique</p>",
        "id": 412189695,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704908017
    },
    {
        "content": "<p><a href=\"https://github.com/kfl/wpp\">https://github.com/kfl/wpp</a></p>",
        "id": 412190136,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704908165
    },
    {
        "content": "<p>Here's my slides: <br>\n<a href=\"/user_uploads/3121/7vc5TL4P0vSG_Je2fWW_sQEu/lean-together-2024.pdf\">lean-together-2024.pdf</a>.</p>\n<p>It's my working hours right now, so I won't be able to participate in this thread yet. Though <span class=\"user-mention\" data-user-id=\"680245\">@Justin Pombrio</span> (a co-author of this work) should feel free to chime in :)</p>",
        "id": 412190383,
        "sender_full_name": "Sorawee Porncharoenwase",
        "timestamp": 1704908276
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"678785\">namibj</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/A.20Pretty.20Expressive.20Printer.20-.20Sorawee.20Porncharoenwase/near/412182611\">said</a>:</p>\n<blockquote>\n<p>The conceptual flexibility here w.r.t. the layout-vs-cost correspondence together with how flexible the layout choices can be, makes me hopeful about getting an easy extension to support for proportional fonts.</p>\n</blockquote>\n<p>Is there a reason to want proportional fonts for Lean in particular?</p>\n<p>Adding support for proportional fonts in Wadler-style printing is \"easy\" in terms of the algorithm, because the only thing the algorithm needs to check is \"is this line longer than the max width\". (The hard part just being figuring out how big text is before you render it.)</p>\n<p>Adding support for proportional fonts in any printer that supports vertical alignment (e.g. Bernardy's printer, or Sorawee and my printer) is harder in terms of the algorithm, because the running time of the algorithm is worst-case polynomial in the number of _possible_ line widths. With a fixed-width font, there are 80 possible line widths between 0 and 80 characters long. With a proportional-width font, there are very many possible line widths between 0.0 and 80.0 em. I think what you would want to do is clump similar widths together, saying e.g. that a width of 40.12 and 40.17 are \"close enough\" and treat them as equal when determining the pareto frontier.</p>",
        "id": 412191102,
        "sender_full_name": "Justin Pombrio",
        "timestamp": 1704908567
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/A.20Pretty.20Expressive.20Printer.20-.20Sorawee.20Porncharoenwase/near/412183611\">said</a>:</p>\n<blockquote>\n<p>Here's my not (yet) so well optimized clone: <a href=\"https://github.com/hargoniX/pfmt/\">https://github.com/hargoniX/pfmt/</a></p>\n</blockquote>\n<p>Henrik, this is great. We should stay in touch. Sorawee in particular has spent a lot of time optimizing PrettyExpressive and probably has helpful advice. Definitely email us if you have any questions; I'll DM you our email addresses.</p>",
        "id": 412191858,
        "sender_full_name": "Justin Pombrio",
        "timestamp": 1704908886
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"680245\">@Justin Pombrio</span> The Wadler-Leijen pprinter does have vertical alignment, right? How does that fit into your framework?</p>",
        "id": 412192774,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704909268
    },
    {
        "content": "<p>Are they not considered due to breaking optimality?</p>",
        "id": 412193212,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704909474
    },
    {
        "content": "<p>There is a <code>vcat</code> operation in the OCaml implementation that is based on the other operators.</p>",
        "id": 412193396,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1704909531
    },
    {
        "content": "<p>By \"framework\" here I meant \"conceptual framework\" - sorry for being unclear</p>",
        "id": 412193483,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704909567
    },
    {
        "content": "<p>Leijen's pretty printer does technically have vertical alignment, but you really don't want to use it because it can make some very bad choices due to being greedy. For example, it thinks that at max-width=4 this format:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">AAAB</span>\n   <span class=\"n\">C</span>\n   <span class=\"n\">D</span>\n</code></pre></div>\n<p>is better than this format:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">AAA</span>\n<span class=\"n\">BCD</span>\n</code></pre></div>\n<p>This isn't a weird edge case that would rarely come up in practice, I think you'd very commonly hit situations like this.</p>",
        "id": 412195474,
        "sender_full_name": "Justin Pombrio",
        "timestamp": 1704910412
    },
    {
        "content": "<p>Interesting - I've used it a lot in the past without encountering many bad layouts in practice. But it's certainly theoretically poorly behaved</p>",
        "id": 412195702,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704910518
    },
    {
        "content": "<p>Oh I'm interested to hear this. Where did you use vertical alignment, and could it ever be far to the right? That's where it runs into issues, when the alignment is near the right margin. It certainly behaves very badly for Racket, but Racket has a _ton_ of possible alignment points.</p>",
        "id": 412195925,
        "sender_full_name": "Justin Pombrio",
        "timestamp": 1704910615
    },
    {
        "content": "<p>I used it in Idris, for doing the traditional layout of <code>do</code>, like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">main</span> <span class=\"bp\">=</span>\n  <span class=\"n\">repeat</span> <span class=\"bp\">$</span> <span class=\"k\">do</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">getLine</span>\n              <span class=\"n\">print</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>In practice, I think it occurred fairly leftwards, which explains the lack of pain</p>",
        "id": 412196304,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704910760
    },
    {
        "content": "<p>Also for types in REPL output</p>",
        "id": 412196491,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704910818
    },
    {
        "content": "<p><a href=\"https://github.com/search?q=repo%3Aidris-lang%2FIdris-dev+align+language%3AHaskell&amp;type=code&amp;l=Haskell\">https://github.com/search?q=repo%3Aidris-lang%2FIdris-dev+align+language%3AHaskell&amp;type=code&amp;l=Haskell</a></p>",
        "id": 412196542,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704910837
    },
    {
        "content": "<p>Yeah, the place it would get painful would be if the <code>do</code> was far right and you got (near the right margin):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">do</span> <span class=\"n\">x</span>\n     <span class=\"bp\">&lt;-</span>\n     <span class=\"n\">getline</span>\n   <span class=\"n\">print</span>\n     <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 412196549,
        "sender_full_name": "Justin Pombrio",
        "timestamp": 1704910841
    },
    {
        "content": "<p>The <code>do</code> would in practice be preceded by a grouped linebreak that would break first, IIRC</p>",
        "id": 412196661,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704910886
    },
    {
        "content": "<p>It's about a decade since I worked on this though</p>",
        "id": 412196676,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704910897
    },
    {
        "content": "<p>Well the trouble is when <code>do x</code> _does_ fit on the line. Wadler's algorithm is greedy so at that point it commits. Unless there's something more complicated going on I don't understand.</p>",
        "id": 412196910,
        "sender_full_name": "Justin Pombrio",
        "timestamp": 1704910977
    },
    {
        "content": "<p>Right!</p>",
        "id": 412196932,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704910990
    },
    {
        "content": "<p>We only used this for compiler output, not for formatting user code, and I suppose that do blocks in compiler output are typically in the left in e.g. a unification error</p>",
        "id": 412197120,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704911086
    },
    {
        "content": "<p>Another question - reference equality (a la <code>eq?</code>) is important for observing the graph structure in the Racket implementation. Would hash-consing be an alternative technique? That is, is it important that accidentally equal subdocuments <strong>not</strong> be <code>eq?</code> with each other?</p>",
        "id": 412199024,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704911928
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"354934\">David Thrane Christiansen</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/A.20Pretty.20Expressive.20Printer.20-.20Sorawee.20Porncharoenwase/near/412199024\">said</a>:</p>\n<blockquote>\n<p>Another question - reference equality (a la <code>eq?</code>) is important for observing the graph structure in the Racket implementation. Would hash-consing be an alternative technique? That is, is it important that accidentally equal subdocuments <strong>not</strong> be <code>eq?</code> with each other?</p>\n</blockquote>\n<p>Would it be possible to give each document a unique id when it's constructed, without needing to do something horribly tedious like use a DocIdGenerator each time? That would be the simplest/fastest. Though understandable if Lean doesn't allow you to violate the property that identical values are indistinguishable.</p>\n<p>If you can't do that, I'm not sure hash-consing would be sufficient? You might need to compare hash-conses and then fall back to a full equality check if the hashes are the same.</p>\n<p>Another option would be to scan the document once and give each node a unique id, if there's an appropriate time to do so. I forget when exactly these eq? checks are used.</p>\n<p>This might be a question for <span class=\"user-mention\" data-user-id=\"360581\">@Sorawee Porncharoenwase</span> (who's unavailable at the moment but will respond later).</p>",
        "id": 412200472,
        "sender_full_name": "Justin Pombrio",
        "timestamp": 1704912598
    },
    {
        "content": "<p>We can do pointer equlaity in Lean with a bit of unsafe.</p>",
        "id": 412200721,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1704912700
    },
    {
        "content": "<p>The situation is basically like it would be in Haskell - adding unique IDs could be done with unsafe features, or in a monad</p>",
        "id": 412200754,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704912717
    },
    {
        "content": "<p>Lean also has a nice computed fields feature that could be used to make document hashes immediately manifest on the constructors</p>",
        "id": 412200940,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704912768
    },
    {
        "content": "<p>Yeah that's probably what you want to do (pointer equality). It's _technically_ an optimization, the behavior shouldn't change if you duplicated a node with a different pointer value.</p>",
        "id": 412201010,
        "sender_full_name": "Justin Pombrio",
        "timestamp": 1704912795
    },
    {
        "content": "<p>I was more curious as to whether _inequality_ ever mattered - sounds like it doesn't</p>",
        "id": 412201048,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704912810
    },
    {
        "content": "<p>You should wait until Sorawee responds to be too sure about this though.</p>",
        "id": 412201169,
        "sender_full_name": "Justin Pombrio",
        "timestamp": 1704912857
    },
    {
        "content": "<p>For sure :-)</p>",
        "id": 412201186,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704912865
    },
    {
        "content": "<p>The hash-consing would be interesting because a document would be represented _by_ its uniqueID/hash, rather than using the hashes to compare. I think the gain would be usability rather than performance - it wouldn't require so much care to maintain sharing</p>",
        "id": 412201452,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704912990
    },
    {
        "content": "<p>Anyway, thanks for answering so many questions!</p>",
        "id": 412201511,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704913021
    },
    {
        "content": "<p>Yeah. There's a very nice implementation of tree-shaped data, where you store the nodes in a vector and \"pointers\" from one node to another as indices into that vector. I've seen this give something absurd like a 2x speedup over regular data structures in Rust, presumably due to the lack of allocation and maybe also cache locality.</p>",
        "id": 412202922,
        "sender_full_name": "Justin Pombrio",
        "timestamp": 1704913537
    },
    {
        "content": "<p>Happy to answer questions, it's exciting to see our work being used!</p>",
        "id": 412203029,
        "sender_full_name": "Justin Pombrio",
        "timestamp": 1704913570
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"354934\">David Thrane Christiansen</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/A.20Pretty.20Expressive.20Printer.20-.20Sorawee.20Porncharoenwase/near/412199024\">said</a>:</p>\n<blockquote>\n<p>That is, is it important that accidentally equal subdocuments <strong>not</strong> be <code>eq?</code> with each other?</p>\n</blockquote>\n<p>It's totally fine for accidentally equal subdocuments to be <code>eq?</code> with each other. In fact, we ideally want the document to be maximally shared!</p>\n<p>I think hash consing could work, but we should never hash the whole document or compare documents structurally on the whole value, because a document could be large. The right way would be to compute a hash incrementally based on children node's hashes.</p>\n<h2>Lookup cost</h2>\n<p>One thing that I want to point out, is that we switched away from using hash table whose key is document (or document identity) for <code>resolve</code> in the current implementations of PrettyExpressive, due to the lookup cost.</p>\n<p>Just so that we are on the same page, what we would like to do is to (essentially) memoize the function <code>resolve : Doc -&gt; Config -&gt; Set Layout</code>.</p>\n<p>Our earliest approach was to create a memoization table with the type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">table</span> <span class=\"o\">:</span> <span class=\"n\">HashEQTbl</span> <span class=\"n\">Doc</span> <span class=\"o\">(</span><span class=\"n\">HashTbl</span> <span class=\"n\">Config</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">Layout</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>where <code>HashEQTbl</code> is a mutable hash table whose key is (efficiently) compared by reference equality and <code>HashTbl</code> is a regular mutable hash table. Not all languages provide <code>HashEQTbl</code>.  Racket does have it (<code>hasheq</code>), and we used this approach for the Racket PrettyExpressive. For languages without <code>HashEQTbl</code>, we can instead forge an identity integer key for each newly constructed document (say, in the smart constructors of documents). This approach was employed by the OCaml PrettyExpressive. The memoization table in this case would have the following type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">table</span> <span class=\"o\">:</span> <span class=\"n\">HashTbl</span> <span class=\"n\">Integer</span> <span class=\"o\">(</span><span class=\"n\">HashTbl</span> <span class=\"n\">Config</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">Layout</span><span class=\"o\">))</span>\n</code></pre></div>\n<hr>\n<p>What we discovered, though, is that for a large document, there will be many hash table lookups (on the document / identity integer key), which is pretty costly. So the current version of PrettyExpressive (both Racket and OCaml) instead stores memoized results in the document structure itself.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">Doc</span> <span class=\"bp\">=</span> <span class=\"o\">{</span> <span class=\"n\">table</span> <span class=\"o\">:</span> <span class=\"n\">HashTbl</span> <span class=\"n\">Config</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">Layout</span><span class=\"o\">),</span>\n             <span class=\"n\">val</span><span class=\"o\">:</span> <span class=\"n\">DocCase</span> <span class=\"o\">}</span>\n<span class=\"n\">data</span> <span class=\"n\">DocCase</span> <span class=\"bp\">=</span>\n<span class=\"bp\">|</span> <span class=\"n\">Text</span> <span class=\"n\">String</span>\n<span class=\"bp\">|</span> <span class=\"n\">Concat</span> <span class=\"n\">Doc</span> <span class=\"n\">Doc</span>\n<span class=\"bp\">|</span> <span class=\"n\">Choice</span> <span class=\"n\">Doc</span> <span class=\"n\">Doc</span>\n<span class=\"bp\">|</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>This eliminates the hash table lookup cost: when we resolve on a document, the memoized results are already in its field. Note, though, that it introduces several complications: </p>\n<p>(1) The tables must be cleared manually, which matters if we want to pretty print multiple times with different cost factories, since results for one factory is not applicable for another factory.<br>\n(2) Garbage collection can't claim space until the tables are all clear.<br>\n(3) Since documents are now stateful, they can't be pretty-printed concurrently.<br>\n(4) <code>Layout</code> actually contains its cost, so it is parameterized by the cost type. This means <code>Doc</code> must now be parameterized by the cost type as well.</p>\n<p>These complications are no big deal for PrettyExpressive though.</p>\n<p>For (1) and (2), it turns out that this inconvenience can sometimes be a feature: it makes _incremental formatting_ easy! In code formatting \"on editing\", the language server would invoke the pretty printer multiple times on syntax trees that differ only slightly. Provided that we reuse the existing (sub-)documents for identical (sub-)trees, the memoized results are automatically transferred. Therefore, subsequent formatting does not need to compute as much.</p>\n<p>In the OCaml PrettyExpressive in particular, the pretty printer is a module functor, parameterized by the cost factory module. Therefore, there is not even a need to do the manual table clearing. If you change a cost factory, you need to construct a new document anyway.</p>\n<p>For (3), we can workaround easily by copying the document, and I personally never need to pretty print concurrently.</p>\n<p>For (4), PrettyExpressive has an <a href=\"https://ocaml.org/p/pretty_expressive/latest/doc/index.html#custom-cost-factory\">extra feature <code>cost</code></a>, which allows us to arbitrarily add extra cost to a document. This already makes the type of <code>Doc</code> parameterized by the cost type anyway, so it's not an issue for PrettyExpressive.</p>",
        "id": 412487886,
        "sender_full_name": "Sorawee Porncharoenwase",
        "timestamp": 1705042953
    },
    {
        "content": "<blockquote>\n<p>I think hash consing could work, but we should never hash the whole document or compare documents structurally on the whole value, because a document could be large. The right way would be to compute a hash incrementally based on children node's hashes.</p>\n</blockquote>\n<p>This is something that we can do nicely in lean with the computed fields features, see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr#src\">src#Lean.Expr</a></p>\n<blockquote>\n<p>where HashEQTbl is a mutable hash table whose key is (efficiently) compared by reference equality and HashTbl is a regular mutable hash table. Not all languages provide HashEQTbl</p>\n</blockquote>\n<p>This is also something that we can do in Lean with a bit of unsafe I would say, the ocaml approach would also be viable though.</p>\n<blockquote>\n<p>What we discovered, though, is that for a large document, there will be many hash table lookups (on the document / identity integer key), which is pretty costly. So the current version of PrettyExpressive (both Racket and OCaml) instead stores memoized results in the document structure itself.</p>\n</blockquote>\n<p>This is the thing I was wondering about when I was porting the OCaml version. We can't really do this nicely in Lean since it doesn't really have a mutable HashMap, instead if the HashMap is used linearly you have a guarantee that it gets updated in place. But this is of course not the case if we employ document sharing. I guess we could put an STRef (HashMap k v) in here? but I have no idea if that would be nice/how good that would work or if something else is a better approach here, maybe someone can chime in on that regard.</p>",
        "id": 412491613,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1705045201
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"354934\">@David Thrane Christiansen</span> asked in the talk if it's possible to support a \"tabular layout\". The answer is ... kind of. I prototyped this new <code>two_columns</code> feature in the OCaml implementation at <a href=\"https://github.com/sorawee/pretty-expressive-ocaml\">https://github.com/sorawee/pretty-expressive-ocaml</a>. It allows you to format something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Doc.size</span> <span class=\"o\">:</span> <span class=\"n\">Doc</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Doc.text</span> <span class=\"n\">_</span>       <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Doc.this_is_a_super_long_name</span> <span class=\"n\">_</span>\n                     <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Doc.cc</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span>     <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">Doc.size</span> <span class=\"n\">d₁</span> <span class=\"bp\">+</span> <span class=\"n\">Doc.size</span> <span class=\"n\">d₂</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Doc.choice</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">Doc.size</span> <span class=\"n\">d₁</span> <span class=\"bp\">+</span> <span class=\"n\">Doc.size</span> <span class=\"n\">d₂</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>where both <code>|</code> and <code>=&gt;</code> across rows are aligned.</p>\n<p>Note that this is actually not a table. For one, it only supports two columns. Also, in each row, The first line of the right column starts at the last line of the left column (see the <code>Doc.this_is_a_super_long_name</code> row, where the left column has two lines). And the column separator is only \"inserted\" to the lines where both columns meet (so other lines like <code>Doc.size d₁ + Doc.size d₂ + 1</code> don't matter, and can pass through the column separator position).</p>\n<p>This two-columns layout follows most conventional programming syntax (top to bottom, left to right). So it's actually good that it's not an actual table (though this means we can't format something like <a href=\"https://docs.racket-lang.org/2d/\">2D syntax</a>, which is an actual table).</p>\n<p>My initial implementation is horribly inefficient, but I later improved that a bit via the zipper data structure and caching (pushed to the git repo, but not yet published on opam). It should work really well if there are not too many rows.</p>",
        "id": 422126406,
        "sender_full_name": "Sorawee Porncharoenwase",
        "timestamp": 1708288015
    }
]