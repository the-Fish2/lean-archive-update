[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"354934\">@David Thrane Christiansen</span>  Question to Josh: It is possible to translate Fin, Vec, etc into just HOL + a wellformedness predicate. Sounds like duper doesn't do this (yet)? Or does it result in ugly translated problems which are very inefficient to solve?</p>\n<p>(I would have asked myself but I'm in a library <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> )</p>",
        "id": 412344929,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1704980635
    },
    {
        "content": "<p>I'll ask it for you in the question session</p>",
        "id": 412345127,
        "sender_full_name": "David Thrane Christiansen",
        "timestamp": 1704980692
    },
    {
        "content": "<p>Thanks <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 412345154,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1704980701
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"436568\">@Josh Clune</span> If duper (practically) relies on receiving only few relevant lemmas, do you expect premise selection to work well with duper?</p>",
        "id": 412348181,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1704981640
    },
    {
        "content": "<p>Thanks for the answer :)</p>",
        "id": 412348191,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1704981643
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"372804\">Marcus Rossel</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Duper.20-.20Josh.20Clune/near/412348181\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"436568\">Josh Clune</span> If duper (practically) relies on receiving only few relevant lemmas, do you expect premise selection to work well with duper?</p>\n</blockquote>\n<p>It's hard to know whether something will be \"efficient enough\" in practice to be useful before actually doing it, but I'm optimistic that Duper will fit in well with a full sledgehammer pipeline. In a sledgehammer pipeline, the first form of premise selection you have is a relevance filter (sometimes a machine learning thing, sometimes a heuristic thing, sometimes a combination) that generates a ton of related lemmas from the library (think hundreds). Hooking Duper up to that directly wouldn't work well. However, in a sledgehammer pipeline, the second thing you do is send the problem (with all the lemmas from the relevance filter) off to an external prover which doesn't need to worry about proof production, and can therefore operate much more efficiently. Then, if the external prover succeeds, it can send back just the lemmas it actually used to obtain a proof. I'm optimistic that Duper will be able to perform reasonably well given just the lemmas that an external prover like Zipperposition needed to solve the problem.</p>",
        "id": 412350137,
        "sender_full_name": "Josh Clune",
        "timestamp": 1704982218
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"436568\">Josh Clune</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Duper.20-.20Josh.20Clune/near/412350137\">said</a>:</p>\n<blockquote>\n<p>I'm optimistic that Duper will be able to perform reasonably well given just the lemmas that an external prover like Zipperposition needed to solve the problem.</p>\n</blockquote>\n<p>These external provers (including Zipperposition) don't just reason on provided lemmas, they also have theory-specific reasoning (hence the T in SMT). Is Duper also going to do that?<br>\nThanks for the great talk btw!</p>",
        "id": 412352230,
        "sender_full_name": "Ricardo Correia",
        "timestamp": 1704982823
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"436568\">Josh Clune</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Duper.20-.20Josh.20Clune/near/412350137\">said</a>:</p>\n<blockquote>\n<p>if the external prover succeeds, it can send back just the lemmas it actually used to obtain a proof. I'm optimistic that Duper will be able to perform reasonably well given just the lemmas that an external prover like Zipperposition needed to solve the problem.</p>\n</blockquote>\n<p>So in such a pipeline the theorem would basically be proven twice?</p>",
        "id": 412353709,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1704983182
    },
    {
        "content": "<p>Isabelle's sledgehammer invokes SMT solvers and uses them as a glorified relevance filter. Those lemmas are then passed into its own superposition prover <code>metis</code> for \"proof reconstruction\". So it's not that unusual. It works surprisingly well for Isabelle, I imagine it'll be fine for Lean. (I don't know any details though, just speaking from my own relatively limited experience).</p>",
        "id": 412354179,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1704983322
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"679773\">Ricardo Correia</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Duper.20-.20Josh.20Clune/near/412352230\">said</a>:</p>\n<blockquote>\n<p>These external provers (including Zipperposition) don't just reason on provided lemmas, they also have theory-specific reasoning (hence the T in SMT). Is Duper also going to do that?<br>\nThanks for the great talk btw!</p>\n</blockquote>\n<p>I'm not sure that  Zipperposition has domain-specific reasoning like SMT solvers do. I'd have to double check that. But in either case, there aren't any current plans for Duper to support domain-specific reasoning (besides what it can figure out if you just give it a bunch of domain-specific lemmas). The first target is to get a full sledgehammer pipeline for problems that are essentially first-order or higher-order. Once we're past that target, it might be interesting to explore integrating more domain-specific things into Duper, but that's much farther away.</p>",
        "id": 412354351,
        "sender_full_name": "Josh Clune",
        "timestamp": 1704983384
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"372804\">Marcus Rossel</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Duper.20-.20Josh.20Clune/near/412353709\">said</a>:</p>\n<blockquote>\n<p>So in such a pipeline the theorem would basically be proven twice?</p>\n</blockquote>\n<p>Yes, but the theorem would only need to be proven twice the first time it's proven. After the external prover finds the lemmas Duper needs to prove the problem, the sledgehammer call could be converted to a Duper call (with the appropriate lemmas supplied) so that future compilations of the file only need to use Duper, and don't even need call the external prover.</p>",
        "id": 412354683,
        "sender_full_name": "Josh Clune",
        "timestamp": 1704983473
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"677028\">Zory Zhang</span> has marked this topic as resolved.</p>",
        "id": 412356893,
        "sender_full_name": "Notification Bot",
        "timestamp": 1704984066
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"677028\">Zory Zhang</span> has marked this topic as unresolved.</p>",
        "id": 412357025,
        "sender_full_name": "Notification Bot",
        "timestamp": 1704984111
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"436568\">@Josh Clune</span> , that was a really great talk! In your high-level description, you said that the superposition loop uses a passive set (initially all facts) and an active set (initially empty), and tries to derive a contradiction. The passive set is initially populated by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mo>‚à™</mo><mrow><mi mathvariant=\"normal\">¬¨</mi><mi>œÜ</mi></mrow></mrow><annotation encoding=\"application/x-tex\">H ‚à™ {¬¨œÜ}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚à™</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\">¬¨</span><span class=\"mord mathnormal\">œÜ</span></span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span> are the hypotheses and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>œÜ</mi></mrow><annotation encoding=\"application/x-tex\">œÜ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">œÜ</span></span></span></span> the goal. At one point the ATP community discovered that simply reasoning forwards from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span> can be quite unproductive as the set is usually consistent (e.g. the group axioms or whatever), and one needs to use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬¨</mi><mi>œÜ</mi></mrow><annotation encoding=\"application/x-tex\">¬¨œÜ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\">¬¨</span><span class=\"mord mathnormal\">œÜ</span></span></span></span> or facts derived from it in some crucial way. This is called the set of support strategy, described e.g. <a href=\"https://mariapaola.github.io/talks/SSFT2022SOSdemodPara-slides.pdf\">here</a>. I am wondering: do you anything goal-oriented like this, and if not, could you?</p>",
        "id": 418084708,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1706191053
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"416280\">Max Nowak üêâ</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Duper.20-.20Josh.20Clune/near/412354179\">said</a>:</p>\n<blockquote>\n<p>Isabelle's sledgehammer invokes SMT solvers and uses them as a glorified relevance filter. Those lemmas are then passed into its own superposition prover <code>metis</code> for \"proof reconstruction\". So it's not that unusual. It works surprisingly well for Isabelle, I imagine it'll be fine for Lean. (I don't know any details though, just speaking from my own relatively limited experience).</p>\n</blockquote>\n<p>Afaik from chatting to people involved in this effort, the 'glorified relevance filter' used to be true of a very early version of the Isabelle sledgehammer but is no longer true. That is, the early version did only transmit the used lemmas and not much more from the external solver to <code>metis</code>, but nowadays when calling e.g. Z3, Z3 will absolutely export the proof steps it applied, and the sledgehammer uses that information. The information is still not a full proof, but it's more than just a list of lemmas.</p>",
        "id": 418085498,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1706191279
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Duper.20-.20Josh.20Clune/near/418084708\">said</a>:</p>\n<blockquote>\n<p>Hey <span class=\"user-mention silent\" data-user-id=\"436568\">Josh Clune</span> , that was a really great talk! In your high-level description, you said that the superposition loop uses a passive set (initially all facts) and an active set (initially empty), and tries to derive a contradiction. The passive set is initially populated by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mo>‚à™</mo><mrow><mi mathvariant=\"normal\">¬¨</mi><mi>œÜ</mi></mrow></mrow><annotation encoding=\"application/x-tex\">H ‚à™ {¬¨œÜ}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚à™</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\">¬¨</span><span class=\"mord mathnormal\">œÜ</span></span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span> are the hypotheses and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>œÜ</mi></mrow><annotation encoding=\"application/x-tex\">œÜ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">œÜ</span></span></span></span> the goal. At one point the ATP community discovered that simply reasoning forwards from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span> can be quite unproductive as the set is usually consistent (e.g. the group axioms or whatever), and one needs to use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬¨</mi><mi>œÜ</mi></mrow><annotation encoding=\"application/x-tex\">¬¨œÜ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\">¬¨</span><span class=\"mord mathnormal\">œÜ</span></span></span></span> or facts derived from it in some crucial way. This is called the set of support strategy, described e.g. <a href=\"https://mariapaola.github.io/talks/SSFT2022SOSdemodPara-slides.pdf\">here</a>. I am wondering: do you anything goal-oriented like this, and if not, could you?</p>\n</blockquote>\n<p>Duper doesn't currently implement the full set of support strategy that you linked to. However, when preprocessing is disabled, Duper does have some heuristics in place to prefer reasoning about clauses that are closely derived from the goal. Currently, there are some technical issues that prevent us from using those same heuristics when preprocessing is enabled (it's nontrivial to determine which of the facts output by Auto's preprocessing and monomorphization procedures were derived from the goal), but that is a problem that we are actively working on, and our intent is to at least reach a state where those same heuristics can be used regardless of whether Duper is using Auto's preprocessing and monomorphization procedures.</p>",
        "id": 418101375,
        "sender_full_name": "Josh Clune",
        "timestamp": 1706195752
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Duper.20-.20Josh.20Clune/near/418085498\">said</a>:</p>\n<blockquote>\n<p>Afaik from chatting to people involved in this effort, the 'glorified relevance filter' used to be true of a very early version of the Isabelle sledgehammer but is no longer true. That is, the early version did only transmit the used lemmas and not much more from the external solver to <code>metis</code>, but nowadays when calling e.g. Z3, Z3 will absolutely export the proof steps it applied, and the sledgehammer uses that information. The information is still not a full proof, but it's more than just a list of lemmas.</p>\n</blockquote>\n<p>I think the situation is a bit more complicated than that. There are some SMT solvers whose proofs Isabelle can use for more direct proof reconstruction (Z3 and veriT). However, the set of external provers that the sledgehammer will call is larger than the set of provers for which this direct proof reconstruction is possible. So there are some instances in which Isabelle will achieve proof reconstruction by actually following the proof output by an external solver, but there are other instances where this approach isn't feasible and so the lemma-based proof reconstruction approach (i.e. just using the external solver to figure out which lemmas you need) is still used.</p>",
        "id": 418102231,
        "sender_full_name": "Josh Clune",
        "timestamp": 1706195974
    }
]