[
    {
        "content": "<p>The relevant file: <a href=\"https://github.com/lecopivo/SciLean/blob/master/SciLean/Core/FunctionTransformations/FDeriv.lean\">https://github.com/lecopivo/SciLean/blob/master/SciLean/Core/FunctionTransformations/FDeriv.lean</a></p>",
        "id": 411966245,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704816632
    },
    {
        "content": "<p>These tactics (<code>fprop</code> etc) are not in mathlib, right?</p>",
        "id": 411966321,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704816661
    },
    {
        "content": "<p>Not as far as I'm aware - they seem amazing!</p>",
        "id": 411966968,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704816859
    },
    {
        "content": "<p>For anyone else wondering, this <code>fun x =&gt;L[R] x^2</code> notation <a href=\"https://github.com/lecopivo/SciLean/blob/0b20f6d648664296f9838042acbd2ce48070fe4c/SciLean/Core/FunctionPropositions/IsContinuousLinearMap.lean#L22-L57\">is coming from</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"fun \"</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"s2\">\" =&gt;L[\"</span> <span class=\"n\">R</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\"] \"</span> <span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">ContinuousLinearMap.mk'</span> <span class=\"bp\">$</span><span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">fprop</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 411967261,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704816963
    },
    {
        "content": "<p>Completely dumb question: these outputs are formally verified, or just some kind of #eval trick?</p>",
        "id": 411967353,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704816987
    },
    {
        "content": "<p>(the <code>#check</code> stuff)</p>",
        "id": 411967653,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704817084
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>'s <a href=\"https://github.com/leanprover-community/mathlib4/pull/2202\">#2202</a> would make it slightly easier to use <code>fprop</code> with mathlib morphism types</p>",
        "id": 411968748,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704817453
    },
    {
        "content": "<p>Though it would be a paradigm shift from using operations on bundled morphisms everywhere (via <code>comp</code> variants) to using constructors where the linearity is proved afresh every time</p>",
        "id": 411969154,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704817594
    },
    {
        "content": "<p>Wow! That was fabulous! Patrick and Johan had questions, maybe you could take them in the conference stream?</p>",
        "id": 411969980,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704817891
    },
    {
        "content": "<p>oh lol sorry, that was supposed to be a DM</p>",
        "id": 411970152,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704817937
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span></p>",
        "id": 411970189,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704817950
    },
    {
        "content": "<p>My question is that in the final ML example, you were considering functions between floaty types. So in terms of the pictures on one of your first slides, you were already in \"approx\" column. Is the reason that your AD still works because you work directly on the level of the AST?</p>",
        "id": 411970621,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1704818087
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Automatic.20Differentiation.20-.20Tomas.20Skrivan/near/411966321\">said</a>:</p>\n<blockquote>\n<p>These tactics (<code>fprop</code> etc) are not in mathlib, right?</p>\n</blockquote>\n<p>They are not, at some point I would like to merge it to mathlib and I think it is getting to the point where it is mature enough.</p>",
        "id": 411970659,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1704818107
    },
    {
        "content": "<p>My question was about the fprop tactic. I guess everyone had this question: can we have a fast continuity and differentiability tactics in Mathlib?</p>",
        "id": 411971001,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1704818229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Automatic.20Differentiation.20-.20Tomas.20Skrivan/near/411970621\">said</a>:</p>\n<blockquote>\n<p>My question is that in the final ML example, you were considering functions between floaty types. So in terms of the pictures on one of your first slides, you were already in \"approx\" column. Is the reason that your AD still works because you work directly on the level of the AST?</p>\n</blockquote>\n<p>Usually everything is formulated and proven polymorphic in the field, i.e. something like<code>{K} [IsROrC K]</code>. When I want to run the program, I just provide inconsistent instance <code>IsROrC Float</code>. Sometimes, like in the ML example, I do not bother in writing it in field polymorphic way.</p>",
        "id": 411971043,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1704818241
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Automatic.20Differentiation.20-.20Tomas.20Skrivan/near/411971001\">said</a>:</p>\n<blockquote>\n<p>My question was about the fprop tactic. I guess everyone had this question: can we have a fast continuity and differentiability tactics in Mathlib?</p>\n</blockquote>\n<p>Yes I would like to merge it to mathlib  ;)</p>",
        "id": 411971243,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1704818312
    },
    {
        "content": "<p>Is there an approximate timeline for this merge? I've been looking on and off into speeding up the Aesop-based <code>continuity</code> and <code>measurability</code> tactics, but if better special-purpose versions are coming soon anyway, I'll shelve this.</p>",
        "id": 411972037,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1704818583
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Automatic.20Differentiation.20-.20Tomas.20Skrivan/near/411967353\">said</a>:</p>\n<blockquote>\n<p>Completely dumb question: these outputs are formally verified, or just some kind of #eval trick?</p>\n</blockquote>\n<p>All that was done with <code>fderiv</code> and <code>Continuity</code> was fully verified. However, results with <code>∂  ∇</code> were not, as they do not use mathlib definition of derivative and adjoint, mainly because <code>X × Y</code> is not inner product space by default. I tried using something like <code>ProdL2 X Y</code> but it is too easy abuse defeq with <code>X × Y</code> that sometimes fails and leads to horrible error that I just gave up on dealing with :)</p>",
        "id": 411972325,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1704818679
    },
    {
        "content": "<p>In theory using <code>WithLp.equiv</code> liberally would save you from the defeq issues, but it's still annoying to do so</p>",
        "id": 411972509,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704818747
    },
    {
        "content": "<p>Here are the <a href=\"https://slides.com/lecopivo/talk-at-nantes-493743\">slides</a> if anyone is interested</p>",
        "id": 411972510,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1704818748
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Automatic.20Differentiation.20-.20Tomas.20Skrivan/near/411972509\">said</a>:</p>\n<blockquote>\n<p>In theory using <code>WithLp.equiv</code> liberally would save you from the defeq issues, but it's still annoying to do so</p>\n</blockquote>\n<p>Another issues is that I want to do automatic differentiation of programs and I really can't tell people to not to use <code>Prod</code> if they want their program to be differentiated.</p>",
        "id": 411972834,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1704818830
    },
    {
        "content": "<p>The choice of norm doesn't actually change the derivative, right? I think <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> has some ideas in the work to remove the norm requirement from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=fderiv#doc\">docs#fderiv</a></p>",
        "id": 411972945,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704818867
    },
    {
        "content": "<p>Yes, the norm is not relevant. I will look at my branch about <code>f =oTVS[k, l] g</code> tonight.</p>",
        "id": 411973259,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704818946
    },
    {
        "content": "<p>But also for gradient it would be nice to be able to have inner product without requiring norm. Such that you can write <code>gradient fun x : X × Y =&gt; x.1</code></p>",
        "id": 411973553,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1704819027
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Automatic.20Differentiation.20-.20Tomas.20Skrivan/near/411972037\">said</a>:</p>\n<blockquote>\n<p>Is there an approximate timeline for this merge? I've been looking on and off into speeding up the Aesop-based <code>continuity</code> and <code>measurability</code> tactics, but if better special-purpose versions are coming soon anyway, I'll shelve this.</p>\n</blockquote>\n<p>I'm still a bit unsure if my version is good enough for mathlib purposes. I haven't done much work with stuff like <code>ContinuityAt/On</code>. </p>\n<p>Within the next month I will try to make a PR to mathlib adding <code>fprop</code> and see how many <code>continuity</code> can be replaced with <code>fprop</code>. Then we will have a better idea if <code>continuity</code> can be replaced by <code>fprop</code> or not.</p>",
        "id": 412028865,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1704842533
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Automatic.20Differentiation.20-.20Tomas.20Skrivan/near/411973259\">said</a>:</p>\n<blockquote>\n<p>Yes, the norm is not relevant. I will look at my branch about <code>f =oTVS[k, l] g</code> tonight.</p>\n</blockquote>\n<p>In <a href=\"https://github.com/leanprover-community/mathlib4/tree/YK-isO-TVS\">branch#YK-isO-TVS</a>, you can find a definition of <code>IsLittleOTVS</code> that doesn't depend on the norm with 2 theorems:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">isLittleOTVS_iff_tendsto_inv_smul</span> <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"n\">α</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalAddGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ContinuousSMul</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">𝕜</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₀</span> <span class=\"o\">:</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsLittleOTVS</span> <span class=\"bp\">𝕜</span> <span class=\"n\">g</span> <span class=\"n\">f</span> <span class=\"n\">l</span> <span class=\"bp\">↔</span> <span class=\"n\">Tendsto</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">•</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">isLittleOTVS_iff_isLittleO</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsLittleOTVS</span> <span class=\"bp\">𝕜</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">l</span> <span class=\"bp\">↔</span> <span class=\"n\">f</span> <span class=\"bp\">=</span><span class=\"n\">o</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n</code></pre></div>",
        "id": 412091797,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704876590
    },
    {
        "content": "<p>Before it lants to Mathlib, a few things have to be done:</p>\n<ul>\n<li>rename <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=gauge#doc\">docs#gauge</a> to something like <code>rayGauge</code></li>\n<li>introduce <code>egauge</code> (as in my branch, thanks to <span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> for formulating the definition in terms of it)</li>\n<li>introduce <code>gauge K s x := (egaue K s x).toReal</code></li>\n<li>rewrite the definition as</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">IsLittleOTVS</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">U</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝓝</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"n\">V</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝓝</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">gauge</span> <span class=\"bp\">𝕜</span> <span class=\"n\">U</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">f</span> <span class=\"bp\">⋅</span><span class=\"o\">)</span> <span class=\"bp\">=</span><span class=\"n\">o</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">gauge</span> <span class=\"bp\">𝕜</span> <span class=\"n\">V</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">g</span> <span class=\"bp\">⋅</span><span class=\"o\">)</span>\n</code></pre></div>\n<ul>\n<li>adjust the theorems to the new definition</li>\n<li>redefine <code>HasFDerivAtFilter</code> etc in terms of <code>IsLittleOTVS</code> without breaking API besides the anonymous constructor/cases</li>\n<li>gradually generalize theorems to topological vector spaces (as needed).</li>\n</ul>",
        "id": 412093224,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704877093
    },
    {
        "content": "<p>Do you want to help with either of these steps?</p>",
        "id": 412093262,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704877105
    },
    {
        "content": "<p>I can give it a try but I have very little experience with actually formalizing mathematics and even less working with filters. So no promises :)</p>",
        "id": 412096827,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1704878396
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Automatic.20Differentiation.20-.20Tomas.20Skrivan/near/411970621\">said</a>:</p>\n<blockquote>\n<p>My question is that in the final ML example, you were considering functions between floaty types. So in terms of the pictures on one of your first slides, you were already in \"approx\" column. Is the reason that your AD still works because you work directly on the level of the AST?</p>\n</blockquote>\n<p>Might be a place/case to have a \"perfect\"/idealized IEEE-style float, to force respect of Inf/signed zero/NaN without discretizing.</p>",
        "id": 412099045,
        "sender_full_name": "namibj",
        "timestamp": 1704879138
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>, do you have an example in mind where your new <code>gauge</code> disagrees with the renamed <code>rayGauge</code>? Edit: ah, when <code>s = Icc 0 2</code> and <code>x = -1</code>, <code>rayGauge s x = 0</code> but <code>egauge Real s x = 0.5</code></p>",
        "id": 412099589,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704879300
    },
    {
        "content": "<p>Though I don't see why that matters here, since you're assuming an topological additive group, so aren't all the sets you use symmetric wrt <code>-</code> anyway?</p>",
        "id": 412104308,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704880838
    },
    {
        "content": "<p>I need to dive back into this (does someone have a link to the original discussion?) but we should think twice before renaming because AFAIK <code>gauge</code> is a standard name for the current <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=gauge#doc\">docs#gauge</a></p>",
        "id": 412105693,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1704881257
    },
    {
        "content": "<p>Maybe the motivation was just generalizing the scalar</p>",
        "id": 412106799,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704881601
    },
    {
        "content": "<p>In which case; would <code>egauge ℝ≥0</code> be effectively the same as <code>rayGauge</code>?</p>",
        "id": 412107555,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704881852
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Automatic.20Differentiation.20-.20Tomas.20Skrivan/near/412028865\">said</a>:</p>\n<blockquote>\n<p>Within the next month I will try to make a PR to mathlib adding <code>fprop</code> and see how many <code>continuity</code> can be replaced with <code>fprop</code>. Then we will have a better idea if <code>continuity</code> can be replaced by <code>fprop</code> or not.</p>\n</blockquote>\n<p>Great, then I'll hold off on my experiments for now. Let me know how it goes.</p>",
        "id": 412108363,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1704882119
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"678785\">namibj</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Automatic.20Differentiation.20-.20Tomas.20Skrivan/near/412099045\">said</a>:</p>\n<blockquote>\n<p>Might be a place/case to have a \"perfect\"/idealized IEEE-style float, to force respect of Inf/signed zero/NaN without discretizing.</p>\n</blockquote>\n<p>Can you expand on this? What do you mean by \"idealized IEEE float\"? Do you mean actual IEEE float or reals + infinity + NaN + negative zero?</p>",
        "id": 412110379,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1704882732
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Automatic.20Differentiation.20-.20Tomas.20Skrivan/near/412110379\">said</a>:</p>\n<blockquote>\n<p>Can you expand on this? What do you mean by \"idealized IEEE float\"? Do you mean actual IEEE float or reals + infinity + NaN + negative zero?</p>\n</blockquote>\n<p>I guess two kinds at least could be useful: the latter you described, and if you want to express certain bit-hacking/binary-float-particularities-exploiting things, at least swapping the exponent to be unlimited (i.e., non-finite <code>Int</code>) and I'd hope somehow making the mantissa be like a rational or probably better a \"unspecified, but finite\"-length normalized binary as usual.<br>\nI'm difference from IEEE, and in consideration of common fast SIMD restrictions, I'd probably actually <em>skip/exclude</em> sub-normals.</p>\n<p>The difference between the \"bignum\"(-ish) floats and the \"decorated\" reals would be whether one wants to reason about effects like catastrophic cancellation, or just do analysis with functions that <em>(aside from rounding errors!)</em> behave (provably, if desired) correctly when fed actual (true) IEEE floats.</p>",
        "id": 412133281,
        "sender_full_name": "namibj",
        "timestamp": 1704890952
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Automatic.20Differentiation.20-.20Tomas.20Skrivan/near/412107555\">said</a>:</p>\n<blockquote>\n<p>In which case; would <code>egauge ℝ≥0</code> be effectively the same as <code>rayGauge</code>?</p>\n</blockquote>\n<p>AFAIK, we don't have normed semifields and I don't know what's a good definition here.</p>",
        "id": 412141978,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704894202
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Automatic.20Differentiation.20-.20Tomas.20Skrivan/near/412105693\">said</a>:</p>\n<blockquote>\n<p>I need to dive back into this (does someone have a link to the original discussion?) but we should think twice before renaming because AFAIK <code>gauge</code> is a standard name for the current <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=gauge#doc\">docs#gauge</a></p>\n</blockquote>\n<p>Is there a standard name for the \"new\" gauge?</p>",
        "id": 412142045,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704894238
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Automatic.20Differentiation.20-.20Tomas.20Skrivan/near/412104308\">said</a>:</p>\n<blockquote>\n<p>Though I don't see why that matters here, since you're assuming an topological additive group, so aren't all the sets you use symmetric wrt <code>-</code> anyway?</p>\n</blockquote>\n<p>I don't know how to define <code>gauge</code> over a general field so that it agrees with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=gauge#doc\">docs#gauge</a> in case of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Real#doc\">docs#Real</a>.</p>",
        "id": 412142234,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704894306
    },
    {
        "content": "<p>The concept of a gauge exists in nonarchimedean functional analysis: see e.g. top of p5 of <a href=\"https://docenti.math.unipd.it/geometria/sites/default/files/Basic%20notions%20on%20non-archimedian%20functional%20analysis_0.pdf\">https://docenti.math.unipd.it/geometria/sites/default/files/Basic%20notions%20on%20non-archimedian%20functional%20analysis_0.pdf</a> .</p>",
        "id": 412149410,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704896586
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Automatic.20Differentiation.20-.20Tomas.20Skrivan/near/412141978\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Automatic.20Differentiation.20-.20Tomas.20Skrivan/near/412107555\">said</a>:</p>\n<blockquote>\n<p>In which case; would <code>egauge ℝ≥0</code> be effectively the same as <code>rayGauge</code>?</p>\n</blockquote>\n<p>AFAIK, we don't have normed semifields and I don't know what's a good definition here.</p>\n</blockquote>\n<p>I suspect <code>dist a (a + b) = norm b</code> is a suitable axiom (on top of all the other easy ones)</p>",
        "id": 412162617,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704900076
    },
    {
        "content": "<p>I don't want to redesign normed groups/rings/fields right now.</p>",
        "id": 412162804,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704900122
    },
    {
        "content": "<p>Maybe we can just stick a norm on <code>NNReal</code> for now, which would be enough to merge the <em>definitions</em> of gauge and eGauge.toReal</p>",
        "id": 412170448,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704901938
    },
    {
        "content": "<p>We'd still need to duplicate all the theorems</p>",
        "id": 412170518,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704901956
    },
    {
        "content": "<p>And move existing lemmas to the <code>NNReal</code> namespace?</p>",
        "id": 412170859,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704902037
    },
    {
        "content": "<p>BTW, normed semifields can be useful to unify <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=tangentConeAt#doc\">docs#tangentConeAt</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=posTangentConeAt#doc\">docs#posTangentConeAt</a></p>",
        "id": 412171205,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704902125
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/419231-Lean-Together-2024/topic/Automatic.20Differentiation.20-.20Tomas.20Skrivan/near/412162804\">said</a>:</p>\n<blockquote>\n<p>I don't want to redesign normed groups/rings/fields right now.</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/9642\">#9642</a> makes a start on this</p>",
        "id": 412247951,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704934683
    }
]