[
    {
        "content": "<p>I am running into a timeout and not sure why?  I am also passing as many implicit arguments that I can see to <code>equivCoxeterGroup</code> and the calls within <code>equivCoxeterGroup_apply_of</code> to try and help Lean but this doesn't help.</p>\n<p>Below is a mwe  snippet from <a href=\"https://github.com/leanprover-community/mathlib4/pull/8223\">#8223</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.PresentedGroup</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.Matrix.Symmetric</span>\n\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">B</span> <span class=\"n\">B</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CoxeterGroup</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Relations</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ofMatrix</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">×</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">FreeGroup</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n <span class=\"n\">Function.uncurry</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">FreeGroup.of</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">FreeGroup.of</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">M</span> <span class=\"n\">i</span> <span class=\"n\">j</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">toSet</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">FreeGroup</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Set.range</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">ofMatrix</span> <span class=\"n\">M</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Relations</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">CoxeterGroup</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Matrix.CoxeterGroup</span> <span class=\"o\">:=</span> <span class=\"n\">PresentedGroup</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">CoxeterGroup.Relations.toSet</span> <span class=\"n\">M</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">Matrix.CoxeterGroup</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">QuotientGroup.Quotient.group</span> <span class=\"n\">_</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CoxeterGroup</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Matrix.CoxeterGroup</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">Matrix.CoxeterGroup</span>\n  <span class=\"n\">exact</span> <span class=\"n\">PresentedGroup.of</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">CoxeterGroup</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CoxeterSystem</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Matrix</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"n\">B'</span> <span class=\"n\">W</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">B</span> <span class=\"n\">B</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">map_relations_eq_reindex_relations</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">≃</span> <span class=\"n\">B'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">FreeGroup.freeGroupCongr</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">''</span> <span class=\"n\">CoxeterGroup.Relations.toSet</span> <span class=\"n\">M</span> <span class=\"bp\">=</span>\n    <span class=\"n\">CoxeterGroup.Relations.toSet</span> <span class=\"o\">(</span><span class=\"n\">reindex</span> <span class=\"n\">e</span> <span class=\"n\">e</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">CoxeterGroup.Relations.toSet</span><span class=\"o\">,</span> <span class=\"n\">CoxeterGroup.Relations.ofMatrix</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">le_antisymm</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.le_iff_subset</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">_</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_image</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_range</span><span class=\"o\">,</span> <span class=\"n\">Prod.exists</span><span class=\"o\">,</span> <span class=\"n\">Function.uncurry_apply_pair</span><span class=\"o\">,</span>\n      <span class=\"n\">forall_exists_index</span><span class=\"o\">,</span> <span class=\"n\">and_imp</span><span class=\"o\">]</span>\n    <span class=\"n\">intro</span> <span class=\"n\">_</span> <span class=\"n\">hb</span> <span class=\"n\">b</span> <span class=\"n\">_</span> <span class=\"n\">heq</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">heq</span><span class=\"o\">]</span>\n    <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">hb</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">aesop</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.le_iff_subset</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">hb'</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_range</span><span class=\"o\">,</span> <span class=\"n\">Prod.exists</span><span class=\"o\">,</span> <span class=\"n\">Function.uncurry_apply_pair</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_image</span><span class=\"o\">,</span>\n      <span class=\"n\">forall_exists_index</span><span class=\"o\">]</span>\n    <span class=\"n\">intro</span> <span class=\"n\">b1'</span> <span class=\"n\">b2'</span> <span class=\"n\">heq</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">heq</span><span class=\"o\">]</span>\n    <span class=\"n\">use</span> <span class=\"o\">((</span><span class=\"n\">FreeGroup.freeGroupCongr</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">hb'</span><span class=\"o\">)</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"kd\">by</span> <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">e.symm</span> <span class=\"n\">b1'</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">e.symm</span> <span class=\"n\">b2'</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">aesop</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">equivCoxeterGroup</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">≃</span> <span class=\"n\">B'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CoxeterGroup</span> <span class=\"n\">M</span> <span class=\"bp\">≃*</span> <span class=\"n\">CoxeterGroup</span> <span class=\"o\">(</span><span class=\"n\">reindex</span> <span class=\"n\">e</span> <span class=\"n\">e</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">CoxeterGroup</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">PresentedGroup.equivPresentedGroup</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">B'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">CoxeterGroup.Relations.toSet</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">e</span>\n  <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">map_relations_eq_reindex_relations</span> <span class=\"n\">B</span> <span class=\"n\">B'</span> <span class=\"n\">M</span> <span class=\"n\">e</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Kernel</span> <span class=\"n\">true</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">profiler</span> <span class=\"n\">true</span>\n<span class=\"c1\">-- set_option maxHeartbeats 0 in</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">equivCoxeterGroup_apply_of</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">B</span> <span class=\"n\">B</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">≃</span> <span class=\"n\">B'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">equivCoxeterGroup</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B'</span> <span class=\"o\">:=</span> <span class=\"n\">B'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">CoxeterGroup.of</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"n\">CoxeterGroup.of</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">B'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">reindex</span> <span class=\"n\">e</span> <span class=\"n\">e</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"c1\">-- by unfold equivCoxeterGroup -- This just runs away!!</span>\n  <span class=\"n\">rfl</span> <span class=\"c1\">-- (deterministic) timeout at 'isDefEq', maximum number of heartbeats (200000) has</span>\n      <span class=\"c1\">-- been reached (use 'set_option maxHeartbeats &lt;num&gt;' to set the limit)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">CoxeterSystem</span>\n</code></pre></div>\n<p>Maybe <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> has an idea as this is just building upon <a href=\"https://github.com/leanprover-community/mathlib4/pull/9403\">#9403</a> ?  Maybe it is related to <a href=\"https://github.com/leanprover-community/mathlib4/pull/9403#discussion_r1451890220\">https://github.com/leanprover-community/mathlib4/pull/9403#discussion_r1451890220</a> on some level?</p>",
        "id": 416810772,
        "sender_full_name": "Newell Jensen",
        "timestamp": 1705680525
    },
    {
        "content": "<p>Am I asking a stupid question that has an obvious answer or does really no one have any idea about this (based on the fact that it is has been about a day since posting and no responses)?  </p>\n<p>How does one troubleshoot a deterministic timeout like this?  Am I doing something obviously wrong?</p>",
        "id": 417026398,
        "sender_full_name": "Newell Jensen",
        "timestamp": 1705787034
    },
    {
        "content": "<p>Debugging timeouts can be hard, and it's the weekend, when things are typically a little less fast-paced around here.</p>",
        "id": 417029235,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705789431
    },
    {
        "content": "<p>Did you try bumping up the heartbeats?</p>",
        "id": 417029331,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705789511
    },
    {
        "content": "<p>Yes I tried bumping up the maxHeartbeats using 0 (no limit) to no avail.  </p>\n<p>I have hit these timeouts before (as most people here probably have) and I am unsure of how to troubleshoot them other than trying to help with the implicit arguments.  </p>\n<p>Are there any other <em>tricks</em> one can use to try and make this work?</p>",
        "id": 417037018,
        "sender_full_name": "Newell Jensen",
        "timestamp": 1705796332
    },
    {
        "content": "<p>I see you defined <code>equivCoxeterGroup</code> using a tactic proof. Generally, it's better to write a term for definitions, restricting any tactics to proofs in sub-terms. Maybe the tactic proof is generating a term that's no good for unfolding or rfl.</p>",
        "id": 417046736,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705804827
    },
    {
        "content": "<p>Ah okay.  I will try and see if I can find a term proof.</p>",
        "id": 417046885,
        "sender_full_name": "Newell Jensen",
        "timestamp": 1705804957
    },
    {
        "content": "<p>Do you know if there is a way to unfold definitions in a term proof?</p>",
        "id": 417046923,
        "sender_full_name": "Newell Jensen",
        "timestamp": 1705805005
    },
    {
        "content": "<p>I suppose instead of a tactic proof using <code>where</code> would get me there (not using tactics for the individual parts as well).</p>",
        "id": 417047061,
        "sender_full_name": "Newell Jensen",
        "timestamp": 1705805121
    },
    {
        "content": "<p>Do you need to unfold the definition? It would really be best if you could avoid rewriting.</p>",
        "id": 417047219,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705805265
    },
    {
        "content": "<p>Why would it be best to avoid this?</p>",
        "id": 417047325,
        "sender_full_name": "Newell Jensen",
        "timestamp": 1705805377
    },
    {
        "content": "<p>You could try doing <code>#print equivCoxeterGroup</code> to see what kinds of terms rewriting produces.</p>",
        "id": 417056915,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705814556
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">CoxeterSystem.equivCoxeterGroup.</span><span class=\"o\">{</span><span class=\"n\">u_3</span><span class=\"o\">,</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n  <span class=\"o\">{</span><span class=\"n\">B'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">B</span> <span class=\"n\">B</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">≃</span> <span class=\"n\">B'</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">CoxeterGroup</span> <span class=\"n\">M</span> <span class=\"bp\">≃*</span> <span class=\"n\">CoxeterGroup</span> <span class=\"o\">((</span><span class=\"n\">reindex</span> <span class=\"n\">e</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">B'</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"n\">e</span> <span class=\"bp\">↦</span>\n  <span class=\"n\">id</span>\n    <span class=\"o\">(</span><span class=\"n\">let_fun</span> <span class=\"n\">this</span> <span class=\"o\">:=</span> <span class=\"n\">PresentedGroup.equivPresentedGroup</span> <span class=\"o\">(</span><span class=\"n\">CoxeterGroup.Relations.toSet</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">e</span><span class=\"bp\">;</span>\n    <span class=\"n\">Eq.mp</span> <span class=\"n\">_</span> <span class=\"n\">this</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I don't really know how to tell whether something above is generating a term that isn't good for unfolding or rfl except for maybe the underscores?</p>",
        "id": 417057325,
        "sender_full_name": "Newell Jensen",
        "timestamp": 1705814958
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"443984\">Newell Jensen</span> <a href=\"#narrow/stream/113489-new-members/topic/Deterministic.20Timeout/near/417047325\">said</a>:</p>\n<blockquote>\n<p>Why would it be best to avoid this?</p>\n</blockquote>\n<p>Because the <code>rw</code> tactic generates weird terms, on the basis that it will only be used in proofs so it doesn't matter</p>",
        "id": 417063834,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705821698
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"443984\">Newell Jensen</span> <a href=\"#narrow/stream/113489-new-members/topic/Deterministic.20Timeout/near/417046923\">said</a>:</p>\n<blockquote>\n<p>Do you know if there is a way to unfold definitions in a term proof?</p>\n</blockquote>\n<p>Term proofs see through definitions so you don't need to unfold them</p>",
        "id": 417064885,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705822927
    },
    {
        "content": "<p>For example in your definition of <code>of</code> what happens if you just delete <code>by</code>, the <code>unfold</code> line and <code>exact</code>?</p>",
        "id": 417065057,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705823147
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Eq.mp#doc\">docs#Eq.mp</a></p>",
        "id": 417065155,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705823257
    },
    {
        "content": "<p>Something bad in particular about rewriting is that it involves changing the types of terms. That's what <code>Eq.mp</code> is does. (In particular, in tends to obstruct things, like Kevin mentions below.)</p>",
        "id": 417065265,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705823376
    },
    {
        "content": "<p>That function is using Eq.rec under the hood, which is an axiom which doesn't unfold. To define an equiv you should, if at all possible, write down the maps explicitly in term mode, and just use stuff like <code>rw</code> for the proof fields</p>",
        "id": 417065272,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705823390
    },
    {
        "content": "<p>Thanks for the suggestions <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> .  Taking the suggestion for using <code>rw</code> in the proof fields I was able to get the below to compile.  Now, this doesn't build upon <code>equivPresentedGroup</code> but it does build on the underlying <code>QuotientGroup.congr</code>, which seems reasonable.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.PresentedGroup</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.Matrix.Symmetric</span>\n\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">B</span> <span class=\"n\">B</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CoxeterGroup</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Relations</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ofMatrix</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">×</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">FreeGroup</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n <span class=\"n\">Function.uncurry</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">FreeGroup.of</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">FreeGroup.of</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">M</span> <span class=\"n\">i</span> <span class=\"n\">j</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">toSet</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">FreeGroup</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Set.range</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">ofMatrix</span> <span class=\"n\">M</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Relations</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">CoxeterGroup</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Matrix.CoxeterGroup</span> <span class=\"o\">:=</span> <span class=\"n\">PresentedGroup</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">CoxeterGroup.Relations.toSet</span> <span class=\"n\">M</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">Matrix.CoxeterGroup</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">QuotientGroup.Quotient.group</span> <span class=\"n\">_</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CoxeterGroup</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Matrix.CoxeterGroup</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">PresentedGroup.of</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">CoxeterGroup</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CoxeterSystem</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Matrix</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"n\">B'</span> <span class=\"n\">W</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">B</span> <span class=\"n\">B</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">map_relations_eq_reindex_relations</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">≃</span> <span class=\"n\">B'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">MulEquiv.toMonoidHom</span> <span class=\"o\">(</span><span class=\"n\">FreeGroup.freeGroupCongr</span> <span class=\"n\">e</span><span class=\"o\">))</span> <span class=\"bp\">''</span> <span class=\"n\">CoxeterGroup.Relations.toSet</span> <span class=\"n\">M</span> <span class=\"bp\">=</span>\n    <span class=\"n\">CoxeterGroup.Relations.toSet</span> <span class=\"o\">(</span><span class=\"n\">reindex</span> <span class=\"n\">e</span> <span class=\"n\">e</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">CoxeterGroup.Relations.toSet</span><span class=\"o\">,</span> <span class=\"n\">CoxeterGroup.Relations.ofMatrix</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">le_antisymm</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.le_iff_subset</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">_</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_image</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_range</span><span class=\"o\">,</span> <span class=\"n\">Prod.exists</span><span class=\"o\">,</span> <span class=\"n\">Function.uncurry_apply_pair</span><span class=\"o\">,</span>\n      <span class=\"n\">forall_exists_index</span><span class=\"o\">,</span> <span class=\"n\">and_imp</span><span class=\"o\">]</span>\n    <span class=\"n\">intro</span> <span class=\"n\">_</span> <span class=\"n\">hb</span> <span class=\"n\">b</span> <span class=\"n\">_</span> <span class=\"n\">heq</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">heq</span><span class=\"o\">]</span>\n    <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">hb</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">aesop</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.le_iff_subset</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">hb'</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_range</span><span class=\"o\">,</span> <span class=\"n\">Prod.exists</span><span class=\"o\">,</span> <span class=\"n\">Function.uncurry_apply_pair</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_image</span><span class=\"o\">,</span>\n      <span class=\"n\">forall_exists_index</span><span class=\"o\">]</span>\n    <span class=\"n\">intro</span> <span class=\"n\">b1'</span> <span class=\"n\">b2'</span> <span class=\"n\">heq</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">heq</span><span class=\"o\">]</span>\n    <span class=\"n\">use</span> <span class=\"o\">((</span><span class=\"n\">FreeGroup.freeGroupCongr</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">hb'</span><span class=\"o\">)</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"kd\">by</span> <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">e.symm</span> <span class=\"n\">b1'</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">e.symm</span> <span class=\"n\">b2'</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">aesop</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">equivCoxeterGroup</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">≃</span> <span class=\"n\">B'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CoxeterGroup</span> <span class=\"n\">M</span> <span class=\"bp\">≃*</span> <span class=\"n\">CoxeterGroup</span> <span class=\"o\">(</span><span class=\"n\">reindex</span> <span class=\"n\">e</span> <span class=\"n\">e</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">QuotientGroup.congr</span> <span class=\"o\">(</span><span class=\"n\">Subgroup.normalClosure</span> <span class=\"o\">(</span><span class=\"n\">CoxeterGroup.Relations.toSet</span> <span class=\"n\">M</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">Subgroup.normalClosure</span> <span class=\"o\">(</span><span class=\"n\">CoxeterGroup.Relations.toSet</span> <span class=\"o\">(</span><span class=\"n\">reindex</span> <span class=\"n\">e</span> <span class=\"n\">e</span> <span class=\"n\">M</span><span class=\"o\">)))</span>\n    <span class=\"o\">(</span><span class=\"n\">FreeGroup.freeGroupCongr</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span>\n      <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">Subgroup.map_normalClosure</span> <span class=\"o\">(</span><span class=\"n\">CoxeterGroup.Relations.toSet</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">FreeGroup.freeGroupCongr</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toMonoidHom</span> <span class=\"o\">(</span><span class=\"n\">FreeGroup.freeGroupCongr</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">surjective</span>\n      <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">map_relations_eq_reindex_relations</span> <span class=\"n\">B</span> <span class=\"n\">B'</span> <span class=\"n\">M</span> <span class=\"n\">e</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">equivCoxeterGroup_apply_of</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">B</span> <span class=\"n\">B</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">≃</span> <span class=\"n\">B'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">equivCoxeterGroup</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">CoxeterGroup.of</span> <span class=\"n\">M</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">CoxeterGroup.of</span> <span class=\"o\">(</span><span class=\"n\">reindex</span> <span class=\"n\">e</span> <span class=\"n\">e</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">CoxeterSystem</span>\n</code></pre></div>",
        "id": 417097509,
        "sender_full_name": "Newell Jensen",
        "timestamp": 1705851975
    }
]