[
    {
        "content": "<p>I find myself using <code>rw</code> a lot to go between a function and lambdas. What's the idiomatic way to do this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span> <span class=\"n\">Real</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> TODO how to not need this lemma? -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Function.eq_lambda</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- example use</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">sin_sin</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">sin</span> <span class=\"o\">(</span><span class=\"n\">sin</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">sin_sin</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Function.eq_lambda</span> <span class=\"n\">sin_sin</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sin_sin</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Continuous.comp'</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">continuous_sin</span>\n</code></pre></div>",
        "id": 412757108,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1705189521
    },
    {
        "content": "<p>Try <code>unfold sin_sin</code> and then <code>continuity</code>?</p>",
        "id": 412757306,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705189731
    },
    {
        "content": "<p>Yes, <code>continuity</code> works. I want to know in general what to do when one has <code>f</code>inside some expression and one needs <code>fun x =&gt; f x</code>. Or should such situations not happen?</p>",
        "id": 412757437,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1705189833
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Tactic/DefEqTransformations.lean\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Tactic/DefEqTransformations.lean</a> has a number of tactics for transforming expressions in different ways.  The <code>eta_expand</code> tactic does that transformation to all under-applied functions.</p>",
        "id": 412757442,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705189837
    },
    {
        "content": "<p>I'm not sure it's used anywhere in mathlib, so caveat emptor</p>",
        "id": 412757460,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705189855
    },
    {
        "content": "<p>Yes, I was looking for <code>eta_expand</code>. Thanks! Any advice how I could have found it myself?</p>",
        "id": 412757585,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1705189950
    },
    {
        "content": "<p>(1) Guessing it might be called <code>eta_expansion</code> if you happen to know the greek letter associated to this lambda calculus rule, (2) consulting the not-yet-existing list of all the mathlib tactics in the mathlib docs (though someone's generated <a href=\"https://github.com/haruhisa-enomoto/mathlib4-all-tactics/blob/main/all-tactics.md\">this</a> in the meantime), (3) asking here and hoping someone familiar with a tactic is around (I wrote this one, so I knew it existed <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>)</p>",
        "id": 412758422,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705190644
    },
    {
        "content": "<p>Are there cases where transformations between defeq terms are necessary? I would think definitional equality means X will suffice whenever Y will</p>",
        "id": 412768582,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1705196281
    },
    {
        "content": "<p>In my original example, if you remove the <code>eta_expand</code> (or the lemma I made that does the same), the proof no longer works.</p>",
        "id": 412768728,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1705196363
    },
    {
        "content": "<p>Right, I see... I'm surprised that it's necessary there</p>",
        "id": 412769336,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1705196684
    },
    {
        "content": "<p>maybe it's a quirk of the way <code>simp</code> does unfolding... as Kevin pointed out, using <code>unfold</code> directly doesn't require the rewrite</p>",
        "id": 412769553,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1705196825
    },
    {
        "content": "<p>Yes, I was wondering what's the point of <code>unfold</code>... I guess it does unfold better than <code>simp</code></p>",
        "id": 412769604,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1705196868
    },
    {
        "content": "<p><code>simp</code> only applies equation lemmas, and equation lemmas are generally for fully applied functions. <code>unfold</code> will unfold a definition even if it's not fully applied.</p>",
        "id": 412769720,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705196948
    },
    {
        "content": "<p>I think there was a suggestion to have <code>simp [!sin_sin]</code> do <code>unfold</code>-style unfolding, but I'm not sure if that's graduated from being a mere idea.</p>",
        "id": 412769939,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705197069
    },
    {
        "content": "<p>I had this <code>simp</code> problem sort of in mind when I added <code>eta_expand</code>, but it's also there as an inverse to <code>eta_reduce</code>.</p>",
        "id": 412770133,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705197219
    },
    {
        "content": "<p>I think this sort of example might have been the inspiration:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">eta_expand</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">add_apply</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- ⊢ Continuous fun a ↦ f a + g a</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 412770373,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705197408
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> While we're on the topic of defeq transformations, is there a reason this doesn't seem to work?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.DefEqTransformations</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span>\n  <span class=\"n\">beta_reduce</span> <span class=\"n\">at</span> <span class=\"n\">q</span> <span class=\"c1\">-- no change</span>\n  <span class=\"n\">trivial</span>\n</code></pre></div>\n<p>Or am I just misunderstanding how it's meant to be used?</p>",
        "id": 412771536,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1705198278
    },
    {
        "content": "<p>Does it only apply to types rather than terms?</p>",
        "id": 412771646,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1705198369
    },
    {
        "content": "<p>Yeah, only types of local hypotheses, no <code>let</code> values.</p>",
        "id": 412771825,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705198537
    },
    {
        "content": "<p>You could make such a tactic that transforms the values though.</p>",
        "id": 412771895,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705198590
    },
    {
        "content": "<p>(Maybe it could be a configuration option to <code>beta_reduce</code> and all the other defeq tactics in that file, if this is useful to do.)</p>",
        "id": 412771918,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705198630
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20rw.20.60f.60to.20.60fun.20x.20.3D.3E.20f.20x.60.3F/near/412768582\">said</a>:</p>\n<blockquote>\n<p>Are there cases where transformations between defeq terms are necessary? I would think definitional equality means X will suffice whenever Y will</p>\n</blockquote>\n<p>Tactics like <code>rw</code> work up to syntactic equality, so sometimes you need to make a definitional change before rewriting.</p>",
        "id": 412810388,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705234841
    }
]