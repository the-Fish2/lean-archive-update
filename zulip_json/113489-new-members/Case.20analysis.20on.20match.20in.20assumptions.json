[
    {
        "content": "<p>I'm writing a verified Brainfuck compiler as an exercise in learning Lean. As a small lemma, I want to prove that <code>Token.ofChar</code> and <code>Token.toChar</code> are inverses of each other; however, the fallthrough case of <code>Token.ofChar</code> is tripping me up. It should just be a simple proof by contradiction with <code>some t = none</code>, but matching in the proof does not come with a proof that <code>c</code> is not equal to the values of the other cases.</p>\n<p>In a Coq-style tactic-oriented approach, I'd destruct on decideable equality of the <code>Char</code> for each of the cases, which would introduce hypotheses for the equalities. The <code>match</code> would then need to somehow be desugared into disjunctions and implications and I could pull it apart according to the equalities.</p>\n<p>I think it's likely I'm approaching this wrong. Any suggestions?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Token</span>\n  <span class=\"bp\">|</span> <span class=\"n\">right</span>\n  <span class=\"bp\">|</span> <span class=\"n\">left</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inc</span>\n  <span class=\"bp\">|</span> <span class=\"n\">dec</span>\n  <span class=\"bp\">|</span> <span class=\"n\">output</span>\n  <span class=\"bp\">|</span> <span class=\"n\">input</span>\n  <span class=\"bp\">|</span> <span class=\"n\">head</span>\n  <span class=\"bp\">|</span> <span class=\"n\">tail</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Token.ofChar</span> <span class=\"o\">:</span> <span class=\"n\">Char</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">Token</span>\n  <span class=\"bp\">|</span> <span class=\"sc\">'&gt;'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Token.right</span>\n  <span class=\"bp\">|</span> <span class=\"sc\">'&lt;'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Token.left</span>\n  <span class=\"bp\">|</span> <span class=\"sc\">'+'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Token.inc</span>\n  <span class=\"bp\">|</span> <span class=\"sc\">'-'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Token.dec</span>\n  <span class=\"bp\">|</span> <span class=\"sc\">'.'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Token.output</span>\n  <span class=\"bp\">|</span> <span class=\"sc\">','</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Token.input</span>\n  <span class=\"bp\">|</span> <span class=\"sc\">'['</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Token.head</span>\n  <span class=\"bp\">|</span> <span class=\"sc\">']'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Token.tail</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Token.toChar</span> <span class=\"o\">:</span> <span class=\"n\">Token</span> <span class=\"bp\">→</span> <span class=\"n\">Char</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Token.right</span> <span class=\"bp\">=&gt;</span> <span class=\"sc\">'&gt;'</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Token.left</span> <span class=\"bp\">=&gt;</span> <span class=\"sc\">'&lt;'</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Token.inc</span> <span class=\"bp\">=&gt;</span> <span class=\"sc\">'+'</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Token.dec</span> <span class=\"bp\">=&gt;</span> <span class=\"sc\">'-'</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Token.output</span> <span class=\"bp\">=&gt;</span> <span class=\"sc\">'.'</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Token.input</span> <span class=\"bp\">=&gt;</span> <span class=\"sc\">','</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Token.head</span> <span class=\"bp\">=&gt;</span> <span class=\"sc\">'['</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Token.tail</span> <span class=\"bp\">=&gt;</span> <span class=\"sc\">']'</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Token.toChar_ofChar</span> <span class=\"n\">t</span> <span class=\"o\">:</span>\n  <span class=\"n\">Token.ofChar</span> <span class=\"o\">(</span><span class=\"n\">t.toChar</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">t</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Token.ofChar_toChar</span> <span class=\"n\">c</span> <span class=\"n\">t</span> <span class=\"o\">:</span>\n  <span class=\"n\">some</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">Token.ofChar</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">t.toChar</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Token.ofChar</span><span class=\"o\">,</span> <span class=\"n\">Token.toChar</span><span class=\"o\">]</span>\n  <span class=\"k\">match</span> <span class=\"n\">c</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"sc\">'&gt;'</span> <span class=\"bp\">|</span> <span class=\"sc\">'&lt;'</span> <span class=\"bp\">|</span> <span class=\"sc\">'+'</span> <span class=\"bp\">|</span> <span class=\"sc\">'-'</span> <span class=\"bp\">|</span> <span class=\"sc\">'.'</span> <span class=\"bp\">|</span> <span class=\"sc\">','</span> <span class=\"bp\">|</span> <span class=\"sc\">'['</span> <span class=\"bp\">|</span> <span class=\"sc\">']'</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">H</span><span class=\"bp\">;</span> <span class=\"n\">subst</span> <span class=\"n\">H</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">c'</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">admit</span>\n</code></pre></div>\n<p>As an aside, if I replace <code>theorem</code> with <code>lemma</code>, it reports <code>unexpected identifier; expected command</code> for the <code>lemma</code> keyword. I thought they would be interchangeable. Is this a bug? I'm using Lean v4.7.0-rc2.</p>",
        "id": 429524652,
        "sender_full_name": "Thalia Archibald",
        "timestamp": 1711407430
    },
    {
        "content": "<p><code>lemma</code> is a mathlib-only command — you just need to be sure to import pretty much any module of mathlib to get it.</p>",
        "id": 429525446,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711407793
    },
    {
        "content": "<p>To get a hypothesis for <code>c</code>, you can use <code>match h : c with</code> syntax, but that doesn't give you the fact that it's <em>not</em> any of the preceding cases unfortunately.</p>",
        "id": 429525479,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711407825
    },
    {
        "content": "<p>Strange that <code>lemma</code> isn't in the stdlib</p>",
        "id": 429525550,
        "sender_full_name": "Thalia Archibald",
        "timestamp": 1711407845
    },
    {
        "content": "<blockquote>\n<p><code>match h : c with</code></p>\n</blockquote>\n<p>Is it Lean convention to lowercase hypotheses?</p>",
        "id": 429525636,
        "sender_full_name": "Thalia Archibald",
        "timestamp": 1711407888
    },
    {
        "content": "<p>Here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Token.ofChar_toChar</span> <span class=\"n\">c</span> <span class=\"n\">t</span> <span class=\"o\">:</span>\n  <span class=\"n\">some</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">Token.ofChar</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">t.toChar</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Token.ofChar</span><span class=\"o\">,</span> <span class=\"n\">Token.toChar</span><span class=\"o\">]</span>\n  <span class=\"n\">split</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">intro</span> <span class=\"n\">h</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 429525691,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711407908
    },
    {
        "content": "<p><code>split</code> looks like it does a lot of heavy lifting. Very nice!</p>",
        "id": 429526106,
        "sender_full_name": "Thalia Archibald",
        "timestamp": 1711408086
    }
]