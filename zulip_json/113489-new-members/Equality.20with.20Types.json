[
    {
        "content": "<p>how can I show that two types aren't equal?<br>\nfor example: for the natural numbers, integers, etc...</p>",
        "id": 422430720,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708439955
    },
    {
        "content": "<p>Why?</p>",
        "id": 422430795,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1708439980
    },
    {
        "content": "<p>curiosity</p>",
        "id": 422430902,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708440005
    },
    {
        "content": "<p>(This is generally not a thing you need to express, and in particular you can't prove that <code>Nat</code> and <code>Int</code> are not equal)</p>",
        "id": 422430966,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1708440019
    },
    {
        "content": "<p>why not tho</p>",
        "id": 422431122,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708440068
    },
    {
        "content": "<p>Name one way in that they are intrinsically different</p>",
        "id": 422432354,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1708440375
    },
    {
        "content": "<p>As far as I know (and I know I'm going to get subtly corrected but I don't remember the other way) the only way to prove two types are not equal is that they don't have the same cardinality</p>",
        "id": 422432440,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1708440401
    },
    {
        "content": "<p>Right -- for all we know, Lean is running the cardinality model, where there's precisely one type of each cardinality, and Nat and Int and Rat are all secretly internally equal to the aleph_null type but just with different structures attached. In particular, they could all secretly be equal to each other.</p>",
        "id": 422432887,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708440528
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Equality.20with.20Types/near/422432887\">said</a>:</p>\n<blockquote>\n<p>Right -- for all we know, Lean is running the cardinality model, where there's precisely one type of each cardinality, and Nat and Int and Rat are all secretly internally equal to the aleph_null type but just with different structures attached. In particular, they could all secretly be equal to each other.</p>\n</blockquote>\n<p>yeah, but we also know they aren't equal to each other</p>",
        "id": 422433080,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708440585
    },
    {
        "content": "<p>No we don’t.</p>",
        "id": 422433205,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1708440609
    },
    {
        "content": "<p>And if we do, we're using a notion of \"equal\" that <del>Lean doesn't know about</del> isn't Lean's <code>=</code></p>",
        "id": 422433256,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708440622
    },
    {
        "content": "<p>You can prove that they are not isomorphic as monoids: maybe this is closer to what you had in mind?  Or showing that the image of Nat.cast is not everything?</p>",
        "id": 422433275,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708440626
    },
    {
        "content": "<p>The good news is that this question is completely irrelevant. You wouldn’t be able to do anything with the answer.</p>",
        "id": 422433429,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1708440678
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Equality.20with.20Types/near/422433256\">said</a>:</p>\n<blockquote>\n<p>And if we do, we're using a notion of \"equal\" that <del>Lean doesn't know about</del> isn't Lean's <code>=</code></p>\n</blockquote>\n<p>yeah - haha</p>",
        "id": 422433438,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708440680
    },
    {
        "content": "<p>true true. it's a completely unnecessary question, but we were just curious</p>",
        "id": 422433599,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708440730
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Equality.20with.20Types/near/422432887\">said</a>:</p>\n<blockquote>\n<p>Right -- for all we know, Lean is running the cardinality model, where there's precisely one type of each cardinality, and Nat and Int and Rat are all secretly internally equal to the aleph_null type but just with different structures attached. In particular, they could all secretly be equal to each other.</p>\n</blockquote>\n<p>As an exercise, you could define your own <code>IntThatEqualsNat</code> which is isomorphic as a ring to the integers, but satisfies <code>example : IntThatEqualsNat = Nat := rfl</code></p>",
        "id": 422433827,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708440790
    },
    {
        "content": "<p>I don't think it would be a very rewarding exercise though</p>",
        "id": 422433891,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708440809
    },
    {
        "content": "<p>In set theory, the naturals are defined via some weird construction involving sets of sets, and then the integers are defined perhaps as some equivalence classes of ordered pairs, so they're also just some weird sets of sets, and now someone could ask whether the naturals and the integers are equal by coincidence, and now you realise that this is a really weird question because now all of a sudden it really matters what your definition of things like \"ordered pair\" is, and there are three definitions of an ordered pair on Wikipedia, and so in set theory now you realise that whether the naturals and the integers are equal is not really even a well-defined question because it depends on things which mathematicians don't think or care about. My point is -- do you know for sure that the naturals and the integers in set theory are not coincidentally equal, given that their definitions are under the hood totally weird?</p>",
        "id": 422433894,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708440810
    },
    {
        "content": "<p>I totally agree. But shouldn't we care about whether or not they are \"equal\"?</p>",
        "id": 422434671,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708440967
    },
    {
        "content": "<p>Definitely not! It's a totally pathological question as I just attempted to explain. It depends on things which are not mathematics.</p>",
        "id": 422434776,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708440992
    },
    {
        "content": "<p>There is a model of Lean where they are equal, and there is a model of Lean where they are not equal, so we know for sure that the question is independent of Lean's axioms. This is a very good reason not to care about the question.</p>",
        "id": 422435064,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708441074
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Equality.20with.20Types/near/422433827\">said</a>:</p>\n<blockquote>\n<p>As an exercise, you could define your own <code>IntThatEqualsNat</code> which is isomorphic as a ring to the integers, but satisfies <code>example : IntThatEqualsNat = Nat := rfl</code></p>\n</blockquote>\n<p>There's a really easy way to do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Int'</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Int'</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Countable</span> <span class=\"n\">Int'</span> <span class=\"o\">:=</span> <span class=\"n\">instCountableNat</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Infinite</span> <span class=\"n\">Int'</span> <span class=\"o\">:=</span> <span class=\"n\">instInfiniteNat</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">int'EquivInt</span> <span class=\"o\">:</span> <span class=\"n\">Int'</span> <span class=\"bp\">≃</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Cardinal.eq.mp</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">some</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"n\">Int'</span> <span class=\"o\">:=</span> <span class=\"n\">int'EquivInt.commRing</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Int'</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 422439208,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708442160
    },
    {
        "content": "<p>So <span class=\"user-mention\" data-user-id=\"477483\">@Monica Omar</span>, this is what people are saying when they say it's not a meaningful question to ask. In the above the type <code>Int'</code> is equal (definitionally!) to <code>ℕ</code>, but as a ring, it is isomorphic to <code>ℤ</code> (so in essence, it <em>is</em> <code>ℤ</code>, despite the fact that it's equal to <code>ℕ</code>).</p>",
        "id": 422439771,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708442305
    },
    {
        "content": "<p>I claim <code>noncomputable section</code> is cheating, no computer scientist would believe that those \"are\" the integers!</p>",
        "id": 422441134,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708442670
    },
    {
        "content": "<p>yeah, that says they are isomorphic, but doesn't say anything about equality</p>",
        "id": 422442236,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708442955
    },
    {
        "content": "<p>Did you miss the <code>example : Int' = Nat := rfl</code> bit?</p>",
        "id": 422442513,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708443026
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Equality.20with.20Types/near/422432887\">ha scritto</a>:</p>\n<blockquote>\n<p>Right -- for all we know, Lean is running the cardinality model, where there's precisely one type of each cardinality</p>\n</blockquote>\n<p>Do you have a reference for this? Curious about these nonsensical things</p>",
        "id": 422442535,
        "sender_full_name": "Simone Castellan",
        "timestamp": 1708443030
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Equality.20with.20Types/near/422442513\">said</a>:</p>\n<blockquote>\n<p>Did you miss the <code>example : Int' = Nat := rfl</code> bit?</p>\n</blockquote>\n<p>but that's not the integers, that's the naturals? Int' is Nat and Nat = Nat</p>",
        "id": 422442870,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708443120
    },
    {
        "content": "<p>Why is <code>Int'</code> not the integers?</p>",
        "id": 422443147,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708443190
    },
    {
        "content": "<p>because it's defined as Nat</p>",
        "id": 422443191,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708443202
    },
    {
        "content": "<p>Definitions of types don't mean anything though(besides cardinality), only the operations matter</p>",
        "id": 422443309,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708443234
    },
    {
        "content": "<p>And it has the <code>+</code> and <code>*</code> and <code>-</code> operators of the integers</p>",
        "id": 422443327,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708443239
    },
    {
        "content": "<p>No mathematician would ask \"Wait, are these Coq integers, Lean integers, or the integers from that zulip thread\"</p>",
        "id": 422443554,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708443300
    },
    {
        "content": "<p>but like -1 isn't in Nat</p>",
        "id": 422443585,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708443307
    },
    {
        "content": "<p>But <code>-1</code> <em>is</em> in <code>Int'</code> !!</p>",
        "id": 422443658,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708443330
    },
    {
        "content": "<p>Well, you can write <code>-1 : Int'</code> with the above and everything works</p>",
        "id": 422443661,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708443330
    },
    {
        "content": "<p>(I think the <code>computable</code> approach makes it a bit clearer what is going on here; you represent <code>{...,-2, -1, 0, 1, 2,...}</code> with the naturals <code>{..., 3, 1, 0, 2, 4, ...}</code></p>",
        "id": 422444133,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708443447
    },
    {
        "content": "<p>I was just about to implement the computable approach, give me a minute.</p>",
        "id": 422444356,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708443502
    },
    {
        "content": "<p>but (-1 : Int) isn’t in Nat?</p>",
        "id": 422444665,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708443596
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Int'</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"n\">Int'</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Denumerable.equiv₂</span> <span class=\"n\">ℕ</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">commRing</span>\n\n<span class=\"c1\">-- Equal to `Nat`</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Int'</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- Isomorphic to `ℤ`</span>\n<span class=\"kd\">def</span> <span class=\"n\">int'EquivInt</span> <span class=\"o\">:</span> <span class=\"n\">Int'</span> <span class=\"bp\">≃+*</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Denumerable.equiv₂</span> <span class=\"n\">ℕ</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ringEquiv</span>\n\n<span class=\"c1\">-- Peek under the hood at the Nat we're using</span>\n<span class=\"kd\">def</span> <span class=\"n\">toNat</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Int'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">i</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">10</span> <span class=\"o\">:</span> <span class=\"n\">Int'</span><span class=\"o\">)</span>  <span class=\"c1\">-- -10</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">10</span> <span class=\"o\">:</span> <span class=\"n\">Int'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toNat</span> <span class=\"bp\">=</span> <span class=\"mi\">19</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 422444854,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708443638
    },
    {
        "content": "<p>Too slow, sorry <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span></p>",
        "id": 422444873,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708443644
    },
    {
        "content": "<p>to make it really clear Eric, add the line</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">10</span> <span class=\"o\">:</span> <span class=\"n\">Int'</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">19</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 422445070,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708443703
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 422445271,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708443752
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"477483\">Monica Omar</span> <a href=\"#narrow/stream/113489-new-members/topic/Equality.20with.20Types/near/422443585\">said</a>:</p>\n<blockquote>\n<p>but like -1 isn't in Nat</p>\n</blockquote>\n<p>Lean disagrees with you:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">neg_one_in_nat</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Int'</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"bp\">@</span><span class=\"n\">Set.univ</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">True.intro</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">neg_one_in_nat</span> <span class=\"c1\">-- -1 ∈ Set.univ</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.explicit</span> <span class=\"n\">true</span>\n<span class=\"k\">#print</span>  <span class=\"n\">neg_one_in_nat</span>\n<span class=\"c1\">-- @Membership.mem Int' (Set ℕ) (@Set.instMembershipSet ℕ) (-1) (@Set.univ ℕ)</span>\n</code></pre></div>",
        "id": 422446365,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708444058
    },
    {
        "content": "<p>but that’s Int’, not Int</p>",
        "id": 422447395,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708444364
    },
    {
        "content": "<p>and also my point of saying -1 isn’t in Nat is that there are no negative numbers in Nat</p>",
        "id": 422447698,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708444457
    },
    {
        "content": "<p>What is surely true is that there is not <code>n : ℕ</code> such that <code>(1 : ℕ) + n = 0</code>, but that's all you can say.</p>",
        "id": 422447844,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708444500
    },
    {
        "content": "<p>Just swap the names of <code>Int</code> and <code>Int'</code>? Look, I'm not claiming <code>ℕ = ℤ</code>, because that's independent of Lean's type theory. The above is just to show you that it is <em>possible</em> (within Lean's type theory) that they could be equal. There are also models where <code>ℕ ≠ ℤ</code>.</p>",
        "id": 422448027,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708444549
    },
    {
        "content": "<p>okay I was just confused what equality of types actually means</p>",
        "id": 422448283,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708444609
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"477483\">Monica Omar</span> <a href=\"#narrow/stream/113489-new-members/topic/Equality.20with.20Types/near/422447698\">said</a>:</p>\n<blockquote>\n<p>and also my point of saying -1 isn’t in Nat is that there are no negative numbers in Nat</p>\n</blockquote>\n<p>This is also easy to prove, btw:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 422448367,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708444634
    },
    {
        "content": "<p>But it's also easy to disprove if you redefine <code>&lt;</code> like we did the arithmetic operators above</p>",
        "id": 422448487,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708444670
    },
    {
        "content": "<p>yeah, and I thought saying that they technically have different elements and evaluations means that they are nonequal types</p>",
        "id": 422448632,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708444703
    },
    {
        "content": "<p>As has already been commented, I think that it is very easy to find reasons why the <em>structures</em> you put on <code>Nat</code> and <code>Int</code> are different, but wondering about whether these structures are defined on the same type or not is neither meaningful nor decidable.</p>",
        "id": 422448904,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708444776
    },
    {
        "content": "<p>can we prove the undecidability of it</p>",
        "id": 422449288,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708444860
    },
    {
        "content": "<p>No, because the axiom of choice says you can't prove undecidability of anything (in the sense of <code>Decidable (ℕ = ℤ)</code>)</p>",
        "id": 422449562,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708444925
    },
    {
        "content": "<p>lol</p>",
        "id": 422449600,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708444938
    },
    {
        "content": "<p>So if you could, the axiom of choice would be inconsistent</p>",
        "id": 422449616,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708444944
    },
    {
        "content": "<p>If the axiom of choice were inconsistent, though, you would then be able to prove that it is undecidable (among other things).</p>",
        "id": 422449816,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708445007
    },
    {
        "content": "<p>I think Damiano meant <em>provable</em>, not <em>decidable</em> above.</p>",
        "id": 422449823,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708445009
    },
    {
        "content": "<p>Also, by \"not meaningful\" I meant that it is not a meaningful mathematical question.  I find that whenever this issue comes up on Zulip, there is always something to be learned.</p>",
        "id": 422450049,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708445066
    },
    {
        "content": "<p>right, so this is just some non-mathematical meta-philosophical nonsense</p>",
        "id": 422450268,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708445125
    },
    {
        "content": "<p>this being my question</p>",
        "id": 422450300,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708445133
    },
    {
        "content": "<p>lol this went from me trying to find some easy example of non-equal non-empty Types for class next week, to having some meta-philosophical meltdown</p>",
        "id": 422451086,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708445367
    },
    {
        "content": "<p>In particular, I feel like no one picked up Eric's challenge:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/113489-new-members/topic/Equality.20with.20Types/near/422432440\">said</a>:</p>\n<blockquote>\n<p>As far as I know (and I know I'm going to get subtly corrected but I don't remember the other way) the only way to prove two types are not equal is that they don't have the same cardinality</p>\n</blockquote>\n<p>Let's see how many of these <code>example</code>s we can prove!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Unit</span> <span class=\"bp\">×</span> <span class=\"n\">Unit</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Unit</span> <span class=\"bp\">×</span> <span class=\"n\">Unit</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Nonempty</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">Unit</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Nonempty</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">Unit</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 422451093,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708445368
    },
    {
        "content": "<p>Isn't the answer none? Because Lean doesn't know the model behind the inductive <code>Prod</code> type?</p>",
        "id": 422451682,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708445553
    },
    {
        "content": "<p>Honestly, I am not sure: you are probably right, but I was wondering whether you could deduce a contradiction from non-well-foundedness of \"first projections\".  Not sure.</p>",
        "id": 422451913,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708445625
    },
    {
        "content": "<p>Like, I think it's the case that the only way to prove (<em>within</em> Lean) that two types are equal is if they are equal <em>by definition</em>, and the only way to prove that two types are not equal is if they have different cardinalities.</p>",
        "id": 422452006,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708445646
    },
    {
        "content": "<p>I could be wrong though, I'm not a type theorist!</p>",
        "id": 422452048,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708445658
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"477483\">Monica Omar</span> <a href=\"#narrow/stream/113489-new-members/topic/Equality.20with.20Types/near/422448632\">said</a>:</p>\n<blockquote>\n<p>yeah, and I thought saying that they technically have different elements and evaluations means that they are nonequal types</p>\n</blockquote>\n<p>I think you are confusing the elements (terms) with their <em>names</em>. If Nat = Int (which I hope we've now established is actually possible) then this certainly doesn't mean that <code>(0 : Nat)</code> = <code>(0 : Int)</code>, because the typeclass inference search which finds the term whose name is <code>0</code> in a type will behave differently depending on whether it's looking for a Nat or an Int. In fact if Nat = Int then it's necessarily true that there is some concrete natural <code>n</code> such that <code>(n : Nat)</code> and <code>(n : Int)</code> are different terms, because <code>(-1 : Int)</code> must correspond to some natural under the identification Nat = Int.</p>\n<p>An analogue would perhaps be the question which we are fond of setting the undergraduates: prove that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo>−</mo><mo stretchy=\"false\">{</mo><mo>−</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}-\\{-1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7722em;vertical-align:-0.0833em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span> is a group, if the group law is defined by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>⋆</mo><mi>y</mi><mo>=</mo><mi>x</mi><mi>y</mi><mo>+</mo><mi>x</mi><mo>+</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x\\star y=xy+x+y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4653em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋆</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span>. If we made this a <code>Group</code> in Lean then it would have a <code>1</code> (in the sense that one of the terms would now have the new name <code>1</code>), but this <code>1</code> wouldn't be the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>∈</mo><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">1\\in\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6835em;vertical-align:-0.0391em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>.</p>",
        "id": 422452136,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708445684
    },
    {
        "content": "<p>Right, I do not have any proof to any of the examples above, but would be very interested in any proof!</p>",
        "id": 422452179,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708445700
    },
    {
        "content": "<p>The proof that all of those examples are undecidable is \"<code>rfl</code> doesn't work and they have the same cardinality\"</p>",
        "id": 422452661,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708445828
    },
    {
        "content": "<p>Hmm, maybe.  Although sometimes <code>by rfl</code> works, where <code>rfl</code> does not.</p>",
        "id": 422452916,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708445904
    },
    {
        "content": "<p>Anyway, I am happy to believe that the type equalities above are undecidable.</p>",
        "id": 422453104,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708445960
    },
    {
        "content": "<p>Damiano, I think the idea is this. There's a model of Lean where all types with the same cardinality are equal (because under the hood you define them all to be the same type), and there's another model where any two distinct types (not defined with <code>def</code>, so <code>inductive</code>s) are actually different under the hood.</p>",
        "id": 422453193,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708445986
    },
    {
        "content": "<p>Yes, I read this idea, but maybe I have not yet internalised that it is really consistent to have all types of the same cardinality being equal.</p>",
        "id": 422453513,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708446058
    },
    {
        "content": "<p>Just extend the <code>Int' = Nat</code> idea above to all denumerable types (and do the same thing for other cardinalities)</p>",
        "id": 422453675,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708446105
    },
    {
        "content": "<p>I can see how this would work for any finite number of types being made equal.  What I am missing is that you can actually to this for all types of the same cardinality.</p>",
        "id": 422454022,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708446202
    },
    {
        "content": "<p>What is the distinction exactly between finite and all types?</p>",
        "id": 422454209,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708446246
    },
    {
        "content": "<p>I meant that you can prove that finitely many types are equal to one another, but not that all products <code>Unit, Unit x Unit, Unit x Unit x Unit, ...</code> are all the same.</p>",
        "id": 422454336,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708446291
    },
    {
        "content": "<p>(At least, I am not seeing how, that is all I was saying.)</p>",
        "id": 422454400,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708446311
    },
    {
        "content": "<p>In this case, maybe you can prove that <code>Unit x anything</code> is <code>anything</code>?</p>",
        "id": 422454535,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708446357
    },
    {
        "content": "<p>Anyway, idle speculation!  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 422454597,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708446370
    },
    {
        "content": "<p><del>They will all be equal by <code>rfl</code> in that model (I think).</del> I think that's wrong actually.</p>",
        "id": 422454619,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708446377
    },
    {
        "content": "<p>The thing is that, when you talk about \"model\", you have already committed to it being consistent.</p>",
        "id": 422454693,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708446402
    },
    {
        "content": "<p>I think when we say model here we mean within ZFC + ω inaccessible cardinals or something. (If you can't tell, I'm getting out of my depth now)</p>",
        "id": 422454966,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708446478
    },
    {
        "content": "<p>I am also out of my depth, so maybe I should stop continuing to ask questions in this thread!  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 422455075,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708446508
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span>, I think <span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> meant (please correct me if I'm wrong) that you <em>can</em> prove they aren't equal if they have non-equal cardinality or if one is countable and the other isn't</p>\n<p>so, for example, <code>Real ≠ Nat</code> would be easy to prove in Lean</p>",
        "id": 422456050,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708446787
    },
    {
        "content": "<p>Right, this is why my examples all have the same cardinality.</p>",
        "id": 422456124,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708446812
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113489-new-members/topic/Equality.20with.20Types/near/422452006\">said</a>:</p>\n<blockquote>\n<p>Like, I think it's the case that the only way to prove (<em>within</em> Lean) that two types are equal is if they are equal <em>by definition</em>, and the only way to prove that two types are not equal is if they have different cardinalities.</p>\n</blockquote>\n<p>Based on this whole discussion, I think this is true</p>\n<p>I'm not a type theorist either tho, so we could be wrong haha</p>",
        "id": 422456649,
        "sender_full_name": "Monica Omar",
        "timestamp": 1708446962
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"477483\">Monica Omar</span> has marked this topic as resolved.</p>",
        "id": 422457813,
        "sender_full_name": "Notification Bot",
        "timestamp": 1708447326
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417769\">Bulhwi Cha</span> has marked this topic as unresolved.</p>",
        "id": 422538045,
        "sender_full_name": "Notification Bot",
        "timestamp": 1708486453
    },
    {
        "content": "<p>I'm fine with not being able to prove <code>ℕ ≠ ℤ</code> in Lean, but I hate to see newcomers puzzled by this fact.</p>\n<p>I've met a few Koreans online who said that the <a href=\"https://github.com/metamath/set.mm\"><code>set.mm</code></a> database seems <em>fundamentally</em> different from ordinary mathematics. It was my fault for not properly explaining the foundational details of Metamath and its ZFC-based math library. To be honest, I still don't know much about these aspects.</p>\n<p>But I also realized that some math majors in South Korea might suspect most libraries of formalized mathematics are nonstandard because these libraries <em>look</em> eccentric. Most of them have never heard about type theory.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Equality.20with.20Types/near/422433894\">said</a>:</p>\n<blockquote>\n<p>In set theory, the naturals are defined via some weird construction involving sets of sets, and then the integers are defined perhaps as some equivalence classes of ordered pairs, so they're also just some weird sets of sets, and now someone could ask whether the naturals and the integers are equal by coincidence, and now you realise that this is a really weird question because now all of a sudden it really matters what your definition of things like \"ordered pair\" is, and there are three definitions of an ordered pair on Wikipedia, and so in set theory now you realise that whether the naturals and the integers are equal is not really even a well-defined question because it depends on things which mathematicians don't think or care about. My point is -- do you know for sure that the naturals and the integers in set theory are not coincidentally equal, given that their definitions are under the hood totally weird?</p>\n</blockquote>\n<p>Despite what <span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> said above, I fear I might fail to make a good impression of Lean on Korean mathematicians when I have to say \"You can't prove <code>ℕ ≠ ℤ</code> in Lean.\" The only solution I can think of is to study mathematical logic and explain the foundations of proof assistants to them as professionally as <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> does.</p>",
        "id": 422538046,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1708486454
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417769\">Bulhwi Cha</span> <a href=\"#narrow/stream/113489-new-members/topic/Equality.20with.20Types/near/422538046\">said</a>:</p>\n<blockquote>\n<p>Despite what <span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> said above, I fear I might fail to make a good impression of Lean on Korean mathematicians when I have to say \"You can't prove <code>ℕ ≠ ℤ</code> in Lean.\"</p>\n</blockquote>\n<p>I claim that this basically never needs to come up. What you can prove is that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">Function.Surjective</span> <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">x.cast_nonneg.trans_eq</span> <span class=\"n\">hx</span>\n  <span class=\"n\">norm_num</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n</code></pre></div>\n<p>which is all that a mathematician ever really means when they say <code>ℕ ≠ ℤ</code>, they just normally don't phrase it that way.</p>",
        "id": 422538775,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708487083
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/Equality.20with.20Types/near/422454022\">said</a>:</p>\n<blockquote>\n<p>I can see how this would work for any finite number of types being made equal.  What I am missing is that you can actually to this for all types of the same cardinality.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/Equality.20with.20Types/near/422454336\">said</a>:</p>\n<blockquote>\n<p>I meant that you can prove that finitely many types are equal to one another, but not that all products <code>Unit, Unit x Unit, Unit x Unit x Unit, ...</code> are all the same.</p>\n</blockquote>\n<p>Let me expound on the cardinality model a bit. We take as the \"types\" all cardinal numbers (initial ordinals), and the elements of those sets are the elements of the type. For each type former, we need to map everything back to an initial ordinal and we do so using a copious serving of the axiom of choice: for example, we define <code>[[A -&gt; B]]</code> to be <code>|[[A]] -&gt; [[B]]|</code>, and fix an equivalence <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>η</mi><mrow><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi></mrow></msub><mo>:</mo><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">[</mo><mi>A</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">]</mo><mo>→</mo><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">[</mo><mi>B</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo><mo>≃</mo><mi mathvariant=\"normal\">∣</mi><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">[</mo><mi>A</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">]</mo><mo>→</mo><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">[</mo><mi>B</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">\\eta_{A,B}: ([[A]] \\to [[B]])\\simeq |[[A]] \\to [[B]]|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7167em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">A</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">([[</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">]]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">]])</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mopen\">[[</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">]]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">]]</span><span class=\"mord\">∣</span></span></span></span> which we use to define the constructors and destructors for the type, i.e. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">[</mo><mi>λ</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>e</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">]</mo><mo>=</mo><msub><mi>η</mi><mrow><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi></mrow></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo>:</mo><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">[</mo><mi>A</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">]</mo><mo>↦</mo><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">[</mo><mi>e</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[[\\lambda x:A,e]]=\\eta_{A,B}(x:[[A]]\\mapsto [[e]])</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[[</span><span class=\"mord mathnormal\">λ</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mclose\">]]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">A</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[[</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">]]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[[</span><span class=\"mord mathnormal\">e</span><span class=\"mclose\">]])</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">[</mo><mi>f</mi><mtext>  </mtext><mi>a</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">]</mo><mo>=</mo><msubsup><mi>η</mi><mrow><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[[f\\;a]]=\\eta^{-1}_{A,B}(f)(a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[[</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">]]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2839em;vertical-align:-0.4296em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8542em;\"><span style=\"top:-2.4065em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">A</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05017em;\">B</span></span></span></span><span style=\"top:-3.1031em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4296em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span></span></span></span>.</p>\n<p>Most operations can't even tell that the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>η</mi></mrow><annotation encoding=\"application/x-tex\">\\eta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span></span></span></span> functions are being inserted, except for equality on types, which is defined as equality of these cardinals, which means for example that <code>Nat = Int</code> is true in this model, with the result of <code>cast</code> being <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>η</mi><mrow><mi>N</mi><mi>a</mi><mi>t</mi></mrow></msub><mo>∘</mo><msubsup><mi>η</mi><mrow><mi>I</mi><mi>n</mi><mi>t</mi></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding=\"application/x-tex\">\\eta_{Nat}\\circ \\eta^{-1}_{Int}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal mtight\">a</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1478em;vertical-align:-0.2935em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8542em;\"><span style=\"top:-2.4065em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mathnormal mtight\">t</span></span></span></span><span style=\"top:-3.1031em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2935em;\"><span></span></span></span></span></span></span></span></span></span>, which will be something random picked out by the axiom of choice.</p>",
        "id": 422594504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708514102
    },
    {
        "content": "<p>Mario, thank you for your answer: it clears up some doubts.</p>",
        "id": 422635584,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708527372
    },
    {
        "content": "<p>Do homotopy type theory or univalent foundations change this at all?</p>",
        "id": 422698728,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1708546730
    },
    {
        "content": "<p>I think <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> are equal in HoTT.</p>",
        "id": 422699268,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1708546967
    },
    {
        "content": "<p>(both being sets)</p>",
        "id": 422699309,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1708546994
    },
    {
        "content": "<p>But this is a different kind of equal -- they are equal in many ways in HoTT. Things can only be equal in one way in Lean, this is the axiom of Lean which means that HoTT <code>=</code> is incompatible with Lean's <code>=</code>.</p>",
        "id": 422700608,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708547578
    }
]