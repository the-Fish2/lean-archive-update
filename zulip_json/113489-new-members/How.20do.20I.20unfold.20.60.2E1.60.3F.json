[
    {
        "content": "<p>I'm using <code>UInt8</code>for certain functions for efficiency which means there are a lot of casts which I fastidiously unfold until I get to <code>.1</code>. Then I'm stuck. How can I unfold this? The underlying type that has me stuck this time is <code>Fin UInt8.size</code>. I tried <code>unfold Fin.val</code> and <code>simp [Fin.val]</code> but nothing happens.</p>",
        "id": 426436974,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1710368761
    },
    {
        "content": "<p>Can you make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 426437144,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710368825
    },
    {
        "content": "<p>at the core is a complex recursive function with multiple deep <code>match</code> branches, so it'll be challenging. But I'll try to create a smaller version that exhibits the issue</p>",
        "id": 426437373,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1710368934
    },
    {
        "content": "<p>okay, I figured out what's up here. I had a definition <code>def OP_SHA256 : UInt8 := 11</code> (an opcode) and I needed to unfold it. Computer programmer brain forgot constants work differently in lean</p>",
        "id": 426438422,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1710369443
    },
    {
        "content": "<p>In my attempt at a more minimal example, I can get stuck at the same point, but <code>rfl</code> solves it. Is there a way to see what sub-tactics <code>rfl</code> uses so I try some of those?</p>",
        "id": 426440245,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1710370593
    },
    {
        "content": "<p>I get to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">int_to_atom</span> <span class=\"o\">({</span> <span class=\"n\">natCast</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">â†¦</span> <span class=\"n\">Int.ofNat</span> <span class=\"n\">n</span> <span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n   <span class=\"o\">{</span> <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"n\">UInt8.ofNat</span> <span class=\"mi\">11</span> <span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">instOfNatAtom.1</span>\n</code></pre></div>",
        "id": 426440395,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1710370695
    },
    {
        "content": "<p>it seems like it's clear these are all constants, but <code>simp [int_to_atom]</code> just blows up to a big mess</p>",
        "id": 426440623,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1710370819
    },
    {
        "content": "<p>okay, this has something to do with how <code>OfNat</code> works and how it \"hides\" the underlying <code>Nat</code> (11 in this case) in the instance function</p>",
        "id": 426441161,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1710371096
    },
    {
        "content": "<p>Here's an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"n\">Int.ofNat</span> <span class=\"o\">(</span><span class=\"n\">Fin.val</span> <span class=\"o\">(</span><span class=\"n\">UInt8.val</span> <span class=\"o\">(</span><span class=\"mi\">11</span><span class=\"o\">:</span> <span class=\"n\">UInt8</span><span class=\"o\">)))</span> <span class=\"bp\">=</span> <span class=\"mi\">11</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">UInt8.val</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">Fin.val</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>It's easy to prove the example with <code>rfl</code>. But I eventually get stuck when using just <code>unfold</code> and <code>simp</code>.</p>",
        "id": 426449110,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1710377214
    },
    {
        "content": "<p>one <code>reduce</code> does it! But <code>reduce</code> is not well documented and I don't yet know what it does</p>",
        "id": 426449872,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1710377894
    },
    {
        "content": "<blockquote>\n<p>Is there a way to see what sub-tactics rfl uses so I try some of those?</p>\n</blockquote>\n<p><code>show_term rfl</code>. But all it does it tries to unify the goal with <code>Eq.refl [LHS]</code>, it's not applying any sub-tactics AFAIK.</p>",
        "id": 426450221,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710378194
    },
    {
        "content": "<p>If you know what it's supposed to be, you can use the <code>change</code> tactic, which should be able handle anything <code>rfl</code>/<code>reduce</code> should</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"n\">Int.ofNat</span> <span class=\"o\">(</span><span class=\"n\">Fin.val</span> <span class=\"o\">(</span><span class=\"n\">UInt8.val</span> <span class=\"o\">(</span><span class=\"mi\">11</span><span class=\"o\">:</span> <span class=\"n\">UInt8</span><span class=\"o\">)))</span> <span class=\"bp\">=</span> <span class=\"mi\">11</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">change</span> <span class=\"mi\">11</span> <span class=\"bp\">=</span> <span class=\"n\">_</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 426453740,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710379549
    },
    {
        "content": "<p>It looks like <code>simp</code> is actually able to reduce this one, though perhaps using lemmas you don't have imported.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Int.ofNat</span> <span class=\"o\">(</span><span class=\"n\">Fin.val</span> <span class=\"o\">(</span><span class=\"n\">UInt8.val</span> <span class=\"o\">(</span><span class=\"mi\">11</span><span class=\"o\">:</span> <span class=\"n\">UInt8</span><span class=\"o\">)))</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span><span class=\"bp\">?</span>\n  <span class=\"c1\">-- simp only [UInt8.val_val_eq_toNat, UInt8.reduceToNat, Int.ofNat_eq_coe, Nat.cast_ofNat]</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(the <code>a</code> is to prevent <code>simp</code> from proving it with <code>rfl</code>)</p>",
        "id": 426453871,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710379644
    },
    {
        "content": "<p>Here's the solution with just <code>unfold</code> and <code>simp</code> of the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"n\">Int.ofNat</span> <span class=\"o\">(</span><span class=\"mi\">11</span><span class=\"o\">:</span> <span class=\"n\">UInt8</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val.val</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">11</span><span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">Fin.val</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">UInt8.val</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">UInt8.instOfNat</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">UInt8.ofNat</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">Fin.ofNat</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Int.ofNat</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Now I just need to unwind the casting and get my mind around how that works.</p>",
        "id": 426454156,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1710379897
    },
    {
        "content": "<p>a lot of unfolding is a code smell, IMHO... there should be APIs that make it easier to move between types</p>\n<p>for example, if you want a <code>UInt8</code> as an <code>Int</code>, you can just do <code>Int.ofNat (11 : UInt8).toNat</code>, and the example becomes</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Int.ofNat</span> <span class=\"o\">(</span><span class=\"mi\">11</span><span class=\"o\">:</span> <span class=\"n\">UInt8</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toNat</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">11</span><span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 426459874,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710384228
    },
    {
        "content": "<p>Of course it's a toy example and you could solve it with <code>rfl</code>, but I think it's instructive that <code>simp</code> works here while it fails to solve <code>Int.ofNat (11: UInt8).val.val = (11: Int)</code> without imports. Things are easier when you take advantage of functions that are designed to facilitate casting.</p>",
        "id": 426460527,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710384738
    },
    {
        "content": "<p>(And with imports, <code>simp</code> can solve your version thanks to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UInt8.val_val_eq_toNat#doc\">docs#UInt8.val_val_eq_toNat</a>, which re-writes it to use <code>UInt8.toNat</code>.)</p>",
        "id": 426461233,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710385336
    },
    {
        "content": "<p>I was on v4.6.1 and some of this stuff seems to only be in 4.7.0-rc2, so I'm upgrading</p>",
        "id": 426461356,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1710385441
    }
]