[
    {
        "content": "<p>Hi, I'm having trouble proving the following statement:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">map_factor</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"n\">c</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">U</span><span class=\"o\">):</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"o\">(</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">s'</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">s'</span> <span class=\"n\">c</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I can define the <code>s'</code> I'm looking for:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">set</span> <span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">c</span>\n    <span class=\"n\">choose</span> <span class=\"n\">a</span> <span class=\"n\">ha</span> <span class=\"n\">using</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n    <span class=\"n\">exact</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>but then I don't know how to prove that it satisfies the properties, because the proofs <code>ha</code>that  I need are somehow lost when we left the definition of the function.</p>\n<p>By the way I would also be happy to know if this result is already stated somewhere !</p>",
        "id": 430395859,
        "sender_full_name": "Florestan",
        "timestamp": 1711810115
    },
    {
        "content": "<p>It's frowned upon to use tactic mode for anything other than proofs for essentially this reason. If you define <code>s'</code> using tactic mode, it's hard to then look into the definition later.</p>\n<p>You can start the proof with the line <code>choose s' hs' using h</code>, which will get you both the function and the hypothesis that it satisfies.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">map_factor</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"n\">c</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">U</span><span class=\"o\">):</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">s'</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">s'</span> <span class=\"n\">c</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">choose</span> <span class=\"n\">s'</span> <span class=\"n\">hs'</span> <span class=\"n\">using</span> <span class=\"n\">h</span>\n  <span class=\"c1\">-- s' : C → A</span>\n  <span class=\"c1\">-- hs' : ∀ (c : C), s' c ∈ U ∧ f (s' c) = s c</span>\n  <span class=\"n\">use</span> <span class=\"n\">s'</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">ext</span> <span class=\"n\">c</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">hs'</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">forall_and.mp</span> <span class=\"n\">hs'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 430404827,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1711818192
    },
    {
        "content": "<p>Oh, I see thank you !<br>\nDoes it means that for Lean <br>\n<code>\\forall x \\exists y, P(x,y)</code><br>\nis \"the same\" as <br>\n<code>\\exists y \\forall x, P(x, y(x))</code><br>\n?</p>",
        "id": 430412322,
        "sender_full_name": "Florestan",
        "timestamp": 1711825168
    },
    {
        "content": "<p>No. However, the <code>choose</code> tactic will yield a function when used on a hypothesis of the form<code>∀ x, ∃ y, P x y</code>. You can read more about the tactic here: <a href=\"https://raw.githubusercontent.com/haruhisa-enomoto/mathlib4-all-tactics/main/all-tactics.md\">https://raw.githubusercontent.com/haruhisa-enomoto/mathlib4-all-tactics/main/all-tactics.md</a></p>\n<p>This is more powerful than the <code>cases</code> or <code>obtain</code> tactic, which can be used to obtain an term satisfying an existence statement, but cannot be used on <code>∀ x, ∃ y, P x y</code>.</p>",
        "id": 430414769,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1711827369
    }
]