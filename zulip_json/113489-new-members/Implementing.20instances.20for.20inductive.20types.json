[
    {
        "content": "<p>How does one implement <code>Eq</code> instance for an inductive type</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Token</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Id</span> <span class=\"o\">:</span> <span class=\"n\">Token</span> <span class=\"c1\">-- | Terminal Symbol</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Ident</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Token</span> <span class=\"c1\">-- | Token contains a String Identifier</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Number</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Token</span> <span class=\"c1\">-- | Token contains an Int value</span>\n  <span class=\"bp\">|</span> <span class=\"n\">If_Symbol</span> <span class=\"o\">:</span> <span class=\"n\">Token</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Then_Symbol</span> <span class=\"o\">:</span> <span class=\"n\">Token</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Eq</span>\n</code></pre></div>\n<p><code>deriving Eq</code> doesn't work </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">default</span> <span class=\"n\">handlers</span> <span class=\"k\">have</span> <span class=\"n\">not</span> <span class=\"n\">been</span> <span class=\"n\">implemented</span> <span class=\"n\">yet</span><span class=\"o\">,</span> <span class=\"kd\">class</span><span class=\"o\">:</span> <span class=\"bp\">'</span><span class=\"n\">Eq'</span> <span class=\"n\">types</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">Token</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 429186515,
        "sender_full_name": "Shubham Kumar ðŸ¦€ (he/him)",
        "timestamp": 1711278681
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Eq#doc\">docs#Eq</a> is defined for every type already</p>",
        "id": 429186798,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1711278964
    },
    {
        "content": "<p>so <code>deriving Eq</code> should not show that error message, is it an incorrect way to use it?</p>",
        "id": 429187016,
        "sender_full_name": "Shubham Kumar ðŸ¦€ (he/him)",
        "timestamp": 1711279080
    },
    {
        "content": "<p><code>Eq</code> is not a typeclass, so it doesn't make any sense to use <code>deriving Eq</code></p>",
        "id": 429187119,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1711279123
    },
    {
        "content": "<p>oh ok, so I can just use <code>=</code> and it would implicitly search for the instance?</p>",
        "id": 429187240,
        "sender_full_name": "Shubham Kumar ðŸ¦€ (he/him)",
        "timestamp": 1711279206
    },
    {
        "content": "<p>There is no instance because there is no typeclass!</p>",
        "id": 429187245,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1711279219
    },
    {
        "content": "<p>Have you clicked here? <span aria-label=\"point right\" class=\"emoji emoji-1f449\" role=\"img\" title=\"point right\">:point_right:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Eq#doc\">docs#Eq</a> <span aria-label=\"point left\" class=\"emoji emoji-1f448\" role=\"img\" title=\"point left\">:point_left:</span></p>",
        "id": 429187254,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1711279242
    },
    {
        "content": "<p>You will see what <code>Eq</code> is, and how it is not the same as Haskell's <code>Eq</code> (which is more like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BEq#doc\">docs#BEq</a> instead)</p>",
        "id": 429187277,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1711279279
    },
    {
        "content": "<p>The answer here is possibly that you meant <code>deriving BEq</code> or <code>deriving DecidableEq</code></p>",
        "id": 429187498,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711279470
    },
    {
        "content": "<p>ok, so<code>Eq</code> is an inductive type which consumes 2 Types and returns a Prop while <code>BEq</code> is typeclass which defines the <code>beq</code> function that consumes 2 Types (but of the same universe because it is a typeclass in that universe? I don't know why Type u is specified) and returns a <code>Bool</code> Type which is an inductive Type</p>",
        "id": 429187751,
        "sender_full_name": "Shubham Kumar ðŸ¦€ (he/him)",
        "timestamp": 1711279560
    },
    {
        "content": "<p>No, it doesn't consume two types. Instead it consumes one type <code>Î±</code> and two elements of that type</p>",
        "id": 429187940,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1711279611
    },
    {
        "content": "<p>Thanks! I didn't have (still don't) any understanding of Eq then</p>",
        "id": 429188025,
        "sender_full_name": "Shubham Kumar ðŸ¦€ (he/him)",
        "timestamp": 1711279664
    },
    {
        "content": "<p>When I write <code>0 = 1</code>, this is notation for <code>@Eq Nat 0 1</code>. So <code>Î± := Nat</code></p>",
        "id": 429188385,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1711279796
    },
    {
        "content": "<p>oh not that part, I don't know what is the difference between Eq and BEq I was assuming both are typeclasses, which it isn't and I don't have an image of how they are related</p>",
        "id": 429188468,
        "sender_full_name": "Shubham Kumar ðŸ¦€ (he/him)",
        "timestamp": 1711279859
    },
    {
        "content": "<p>The truth is that they are not</p>",
        "id": 429188477,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1711279873
    },
    {
        "content": "<p><code>Eq</code> is mathematical equality. <code>BEq</code> is just a typeclass that gives you access to the <code>==</code> notation</p>",
        "id": 429188497,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1711279907
    },
    {
        "content": "<p>If you want to state that <code>==</code> corresponds to mathematical equality (namely <code>âˆ€ a b, a = b â†” a == b</code>), you use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LawfulBEq#doc\">docs#LawfulBEq</a></p>",
        "id": 429188557,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1711279943
    },
    {
        "content": "<p>Interesting, thanks you have given me a lot to think about.</p>\n<p>For now, I think <code>deriving BEq</code> should work and probably I don't need to derive an instance</p>",
        "id": 429188856,
        "sender_full_name": "Shubham Kumar ðŸ¦€ (he/him)",
        "timestamp": 1711280138
    },
    {
        "content": "<p>another stupid question, even after deriving DecidableEq it seems like Token doesn't have the DecidableEq instance</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">pSym</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Parser</span> <span class=\"n\">s</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Parser.P</span> <span class=\"o\">(</span><span class=\"bp\">Î»</span> <span class=\"n\">inp</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">inp</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">s</span> <span class=\"o\">::</span> <span class=\"n\">ss</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"k\">then</span> <span class=\"o\">[(</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">ss</span><span class=\"o\">)]</span> <span class=\"k\">else</span> <span class=\"o\">[]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[])</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Token</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Id</span> <span class=\"o\">:</span> <span class=\"n\">Token</span> <span class=\"c1\">-- | Terminal Symbol</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Ident</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Token</span> <span class=\"c1\">-- | Token contains a String Identifier</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Number</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Token</span> <span class=\"c1\">-- | Token contains an Int value</span>\n  <span class=\"bp\">|</span> <span class=\"n\">If_Symbol</span> <span class=\"o\">:</span> <span class=\"n\">Token</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Then_Symbol</span> <span class=\"o\">:</span> <span class=\"n\">Token</span>\n<span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span><span class=\"o\">,</span> <span class=\"n\">BEq</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pIdent</span> <span class=\"o\">:=</span> <span class=\"n\">pSym</span> <span class=\"n\">Id</span>\n</code></pre></div>\n<p>error</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>error:<span class=\"w\"> </span>typeclass<span class=\"w\"> </span>instance<span class=\"w\"> </span>problem<span class=\"w\"> </span>is<span class=\"w\"> </span>stuck,<span class=\"w\"> </span>it<span class=\"w\"> </span>is<span class=\"w\"> </span>often<span class=\"w\"> </span>due<span class=\"w\"> </span>to<span class=\"w\"> </span>metavariables\n<span class=\"w\">  </span>DecidableEq<span class=\"w\"> </span>?m.4178\n</code></pre></div>",
        "id": 429798282,
        "sender_full_name": "Shubham Kumar ðŸ¦€ (he/him)",
        "timestamp": 1711524294
    },
    {
        "content": "<p>You want to write pSym Token.Id</p>",
        "id": 429799432,
        "sender_full_name": "Henrik BÃ¶ving",
        "timestamp": 1711524872
    },
    {
        "content": "<p>Thanks! I knew it was something stupid</p>",
        "id": 429799528,
        "sender_full_name": "Shubham Kumar ðŸ¦€ (he/him)",
        "timestamp": 1711524931
    },
    {
        "content": "<p>so in the previously stated messages (not sure if it would be clear) I was trying to get to a place where after defining my token Inductive type I can define a concrete equality where <code>Token.Id = Token.Ident \"\"</code> should be true but the automatic derivation leads to false</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Token</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Id</span> <span class=\"o\">:</span> <span class=\"n\">Token</span> <span class=\"c1\">-- | Terminal Symbol</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Ident</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Token</span> <span class=\"c1\">-- | Token contains a String Identifier</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Number</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Token</span> <span class=\"c1\">-- | Token contains an Int value</span>\n  <span class=\"bp\">|</span> <span class=\"n\">If_Symbol</span> <span class=\"o\">:</span> <span class=\"n\">Token</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Then_Symbol</span> <span class=\"o\">:</span> <span class=\"n\">Token</span>\n<span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span><span class=\"o\">,</span> <span class=\"n\">BEq</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">Token.Id</span> <span class=\"bp\">=</span> <span class=\"n\">Token.Ident</span> <span class=\"s2\">\"\"</span> <span class=\"c1\">-- | should be true</span>\n</code></pre></div>\n<p>image showing false<br>\n<a href=\"/user_uploads/3121/wkshiZAGgimpEbB61OM2sn3a/Screenshot-from-2024-03-27-13-26-46.png\">Screenshot-from-2024-03-27-13-26-46.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/wkshiZAGgimpEbB61OM2sn3a/Screenshot-from-2024-03-27-13-26-46.png\" title=\"Screenshot-from-2024-03-27-13-26-46.png\"><img src=\"/user_uploads/3121/wkshiZAGgimpEbB61OM2sn3a/Screenshot-from-2024-03-27-13-26-46.png\"></a></div><p>How to I go about defining equality if I want it to be true?</p>",
        "id": 429802288,
        "sender_full_name": "Shubham Kumar ðŸ¦€ (he/him)",
        "timestamp": 1711526292
    },
    {
        "content": "<p>The direct answer to your question is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quotient#doc\">docs#Quotient</a>. Given an equivalence relation, this creates a new type for which this equivalence relation defines <code>Eq</code> equality. But If your goal is simply <code>Token.Id = Token.Ideny \"\"</code>, the simpler solution would be to define the former in terms of the latter.</p>",
        "id": 429924311,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1711564840
    },
    {
        "content": "<p>Make sure not to derive both <code>DecidableEq</code> and <code>BEq</code>. You get <code>BEq</code> for free from <code>DecidableEq</code>.</p>\n<p>And also Markus's suggestion is the right one for overriding the equality for a type. Quotients are the way you create a type from another type with a looser Eq. (This is not done with typeclasses.) I suppose you could define BEq on the original type to correspond exactly to the Eq on the quotient type â€” I'm not sure how much people have explored that design pattern.</p>",
        "id": 429925975,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711565425
    },
    {
        "content": "<p>I would like to do the simple thing but first maybe waste time on understanding what quotient is, <del>I found something related to <a href=\"https://www.cs.cornell.edu/nogin/papers/quotients.pdf\">quotient types</a> but if there are easier ways to approach this I'll be happy to look</del> looking at Wikipedia.</p>\n<p>Thanks for the help!</p>",
        "id": 429953748,
        "sender_full_name": "Shubham Kumar ðŸ¦€ (he/him)",
        "timestamp": 1711575460
    }
]