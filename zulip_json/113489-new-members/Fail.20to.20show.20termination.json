[
    {
        "content": "<p>Can you tell me what I'm doing wrong here? I expected <code>fprod (k + 1)</code> to be able to use <code>fprod k</code> without any fuss.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finsupp.Basic</span>\n\n<span class=\"c1\">-- For all vectors `f : Fin k → (κ →₀ R)` of finitely-supported functions on $$κ$$, there</span>\n<span class=\"c1\">-- is a single finitely-supported function on $$κᵏ$$, `fprod k f : (Fin k → κ) →₀ R`,</span>\n<span class=\"c1\">-- such that `fprod k f v = List.prod &lt;| .ofFn fun i =&gt; x i (v i)` for all `v` in $$κᵏ$$.</span>\n<span class=\"kd\">def</span> <span class=\"n\">fprod</span> <span class=\"o\">{</span><span class=\"n\">κ</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">κ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonoidWithZero</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Nontrivial</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NoZeroDivisors</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">k</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">κ</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">k</span> <span class=\"bp\">→</span> <span class=\"n\">κ</span><span class=\"o\">)</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">k</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span>\n      <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n      <span class=\"n\">support</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"k\">fun</span><span class=\"bp\">.</span><span class=\"o\">}</span>\n      <span class=\"n\">mem_support_toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">one_ne_zero</span><span class=\"o\">,</span>\n        <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Finset.mem_singleton.mpr</span> <span class=\"o\">(</span><span class=\"n\">Subsingleton.allEq</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)⟩</span>\n    <span class=\"o\">}</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span>\n      <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">fprod</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">Fin.tail</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin.tail</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n      <span class=\"n\">support</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support.biUnion</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"o\">(</span><span class=\"n\">fprod</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">Fin.tail</span> <span class=\"n\">f</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">support.map</span> <span class=\"o\">⟨</span><span class=\"n\">Fin.cons</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Fin.cons_right_injective</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n      <span class=\"n\">mem_support_toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n          <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">hj</span><span class=\"o\">,</span> <span class=\"n\">htail</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">Finset.mem_biUnion.mp</span> <span class=\"n\">h</span>\n          <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">Finset.mem_map.mp</span> <span class=\"n\">htail</span>\n          <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Function.Embedding.coeFn_mk</span><span class=\"o\">]</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Fin.cons_zero</span><span class=\"o\">,</span> <span class=\"n\">Fin.tail_cons</span><span class=\"o\">,</span> <span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"n\">mul_eq_zero</span><span class=\"o\">,</span> <span class=\"n\">not_or</span><span class=\"o\">]</span>\n          <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">Finsupp.mem_support_iff.mp</span> <span class=\"n\">hj</span><span class=\"o\">,</span> <span class=\"n\">Finsupp.mem_support_iff.mp</span> <span class=\"n\">ha</span><span class=\"o\">⟩,</span>\n        <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">hhead</span><span class=\"o\">,</span> <span class=\"n\">htail</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">mul_ne_zero_iff.mp</span> <span class=\"n\">h</span>\n          <span class=\"n\">Finset.mem_biUnion.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">i</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">Finsupp.mem_support_iff.mpr</span> <span class=\"n\">hhead</span><span class=\"o\">,</span>\n            <span class=\"n\">Finset.mem_map.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">Fin.tail</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Finsupp.mem_support_iff.mpr</span> <span class=\"n\">htail</span><span class=\"o\">,</span>\n              <span class=\"n\">Fin.cons_self_tail</span> <span class=\"n\">i</span><span class=\"o\">⟩⟩⟩</span>\n    <span class=\"o\">}</span>\n</code></pre></div>\n<p>The error is</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>fail to show termination for\n  fprod\nwith errors\nargument #7 was not used for structural recursion\n  unexpected occurrence of recursive application\n    @fprod\n\nstructural recursion cannot be used\n</code></pre></div>\n<p>and the remaining goal is just</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⊢</span> <span class=\"n\">k</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">m</span>\n</code></pre></div>",
        "id": 420911729,
        "sender_full_name": "Richard Copley",
        "timestamp": 1707676387
    },
    {
        "content": "<p>here's one solution:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finsupp.Basic</span>\n\n<span class=\"c1\">-- For all vectors `f : Fin k → (κ →₀ R)` of finitely-supported functions on $$κ$$, there</span>\n<span class=\"c1\">-- is a single finitely-supported function on $$κᵏ$$, `fprod k f : (Fin k → κ) →₀ R`,</span>\n<span class=\"c1\">-- such that `fprod k f v = List.prod &lt;| .ofFn fun i =&gt; x i (v i)` for all `v` in $$κᵏ$$.</span>\n<span class=\"kd\">def</span> <span class=\"n\">fprod</span> <span class=\"o\">{</span><span class=\"n\">κ</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">κ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonoidWithZero</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Nontrivial</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NoZeroDivisors</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">k</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">κ</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">k</span> <span class=\"bp\">→</span> <span class=\"n\">κ</span><span class=\"o\">)</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">k</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span>\n      <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n      <span class=\"n\">support</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"k\">fun</span><span class=\"bp\">.</span><span class=\"o\">}</span>\n      <span class=\"n\">mem_support_toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">one_ne_zero</span><span class=\"o\">,</span>\n        <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Finset.mem_singleton.mpr</span> <span class=\"o\">(</span><span class=\"n\">Subsingleton.allEq</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)⟩</span>\n    <span class=\"o\">}</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">f'</span> <span class=\"o\">:=</span> <span class=\"n\">fprod</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">Fin.tail</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span>\n      <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">f'</span> <span class=\"o\">(</span><span class=\"n\">Fin.tail</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n      <span class=\"n\">support</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support.biUnion</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"o\">(</span><span class=\"n\">fprod</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">Fin.tail</span> <span class=\"n\">f</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">support.map</span> <span class=\"o\">⟨</span><span class=\"n\">Fin.cons</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Fin.cons_right_injective</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n      <span class=\"n\">mem_support_toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n          <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">hj</span><span class=\"o\">,</span> <span class=\"n\">htail</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">Finset.mem_biUnion.mp</span> <span class=\"n\">h</span>\n          <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">Finset.mem_map.mp</span> <span class=\"n\">htail</span>\n          <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Function.Embedding.coeFn_mk</span><span class=\"o\">]</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Fin.cons_zero</span><span class=\"o\">,</span> <span class=\"n\">Fin.tail_cons</span><span class=\"o\">,</span> <span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"n\">mul_eq_zero</span><span class=\"o\">,</span> <span class=\"n\">not_or</span><span class=\"o\">]</span>\n          <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">Finsupp.mem_support_iff.mp</span> <span class=\"n\">hj</span><span class=\"o\">,</span> <span class=\"n\">Finsupp.mem_support_iff.mp</span> <span class=\"n\">ha</span><span class=\"o\">⟩,</span>\n        <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">hhead</span><span class=\"o\">,</span> <span class=\"n\">htail</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">mul_ne_zero_iff.mp</span> <span class=\"n\">h</span>\n          <span class=\"n\">Finset.mem_biUnion.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">i</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">Finsupp.mem_support_iff.mpr</span> <span class=\"n\">hhead</span><span class=\"o\">,</span>\n            <span class=\"n\">Finset.mem_map.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">Fin.tail</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Finsupp.mem_support_iff.mpr</span> <span class=\"n\">htail</span><span class=\"o\">,</span>\n              <span class=\"n\">Fin.cons_self_tail</span> <span class=\"n\">i</span><span class=\"o\">⟩⟩⟩</span>\n    <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 420916167,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1707680273
    },
    {
        "content": "<p>strangely it doesn't require replacing the 2nd instance of <code>fprod m (Fin.tail f)</code>, though you can certainly do that for the sake of consistency</p>",
        "id": 420916258,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1707680346
    },
    {
        "content": "<p>How mysterious! Thank you very much.</p>\n<p>(Here is a diff:)</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gd\">--- mwe.lean    2024-02-11 19:41:39 +0000</span>\n<span class=\"gi\">+++ fixed.lean  2024-02-11 19:41:39 +0000</span>\n<span class=\"gu\">@@ -12,8 +12,10 @@</span>\n<span class=\"w\"> </span>      mem_support_toFun := fun _ =&gt; ⟨fun _ =&gt; one_ne_zero,\n<span class=\"w\"> </span>        fun _ =&gt; Finset.mem_singleton.mpr (Subsingleton.allEq _ _)⟩\n<span class=\"w\"> </span>    }\n<span class=\"gd\">-  | (m + 1) =&gt; {</span>\n<span class=\"gd\">-      toFun := fun p =&gt; f 0 (p 0) * fprod m (Fin.tail f) (Fin.tail p)</span>\n<span class=\"gi\">+  | (m + 1) =&gt;</span>\n<span class=\"gi\">+    let f' := fprod m (Fin.tail f)</span>\n<span class=\"gi\">+    {</span>\n<span class=\"gi\">+      toFun := fun p =&gt; f 0 (p 0) * f' (Fin.tail p)</span>\n<span class=\"w\"> </span>      support := (f 0).support.biUnion fun i =&gt;\n<span class=\"w\"> </span>        (fprod m (Fin.tail f)).support.map ⟨Fin.cons i, Fin.cons_right_injective _⟩\n<span class=\"w\"> </span>      mem_support_toFun := fun i =&gt;\n</code></pre></div>",
        "id": 420916517,
        "sender_full_name": "Richard Copley",
        "timestamp": 1707680583
    }
]