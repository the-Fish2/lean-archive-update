[
    {
        "content": "<p>I am new to lean4 and am starting a project on building a coding theory library. I am having trouble on defining the distance of a code, which is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi>min</mi><mo>⁡</mo></mrow><mrow><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>∈</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>x</mi><mo mathvariant=\"normal\">≠</mo><mi>y</mi></mrow></msub><mi>H</mi><mi>a</mi><mi>m</mi><mi>m</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\min_{x, y\\in C, x\\neq y}HammingDist(x, y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mop\"><span class=\"mop\">min</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">x</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">y</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\">x</span><span class=\"mrel mtight\"><span class=\"mrel mtight\"><span class=\"mord vbox mtight\"><span class=\"thinbox mtight\"><span class=\"rlap mtight\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord mtight\"><span class=\"mrel mtight\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel mtight\">=</span></span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">y</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathnormal\">ammin</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span>. Here is my code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Logic.Equiv.Fin</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.SpecificLimits.Normed</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.InformationTheory.Hamming</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Init.Set</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Set</span> <span class=\"n\">Filter</span> <span class=\"n\">Asymptotics</span> <span class=\"n\">Finset</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CodingTheory</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"bp\">𝔽</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"bp\">𝔽</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"bp\">𝔽</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"bp\">𝔽</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"bp\">𝔽</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n\n\n<span class=\"sd\">/-- A type that represents the set of symbols in the code -/</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">Alphabet</span> <span class=\"o\">:=</span> <span class=\"n\">Set</span> <span class=\"n\">α</span>\n\n\n<span class=\"sd\">/-- An element of 𝔽ⁿ. -/</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">Codeword</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">𝔽</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"bp\">𝔽</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"bp\">𝔽</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"bp\">𝔽</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"bp\">𝔽</span>\n\n\n<span class=\"sd\">/-- Code `Code n 𝔽` is a subset of 𝔽ⁿ. -/</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">Code</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">𝔽</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"bp\">𝔽</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"bp\">𝔽</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"bp\">𝔽</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Codeword</span> <span class=\"n\">n</span> <span class=\"bp\">𝔽</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">hamming_distance</span> <span class=\"o\">(</span><span class=\"n\">c1</span> <span class=\"n\">c2</span> <span class=\"o\">:</span> <span class=\"n\">Codeword</span> <span class=\"n\">n</span> <span class=\"bp\">𝔽</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">hammingDist</span> <span class=\"n\">c1</span> <span class=\"n\">c2</span>\n\n<span class=\"sd\">/-- This gives me an error. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">distance</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Code</span> <span class=\"n\">n</span> <span class=\"bp\">𝔽</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Finset.min'</span> <span class=\"o\">{</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"n\">hamming_distance</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">d</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>I am happy to take any comments/suggestions on the code.</p>",
        "id": 416520487,
        "sender_full_name": "Allan Li",
        "timestamp": 1705566762
    },
    {
        "content": "<p>Disclaimer, I'm a mathlib noob but:<br>\n<code>{d : Fin n | ∃ x ∈ C, ∃ y ∈ C, x ≠ y ∧ hamming_distance x y = d}</code> is a Set, not a FinSet. I think you can use <code>Finset.range</code> and <code>Finset.filter</code> to get a finset of what you want.</p>\n<p>Another problem is that Finset.min' takes two arguments, a finset and a proof that it is non-empty, but I think if n is 0, there is only one codeword, but you need two distinct codewords for an element of your FinSet and it can therefore be empty.</p>",
        "id": 416538070,
        "sender_full_name": "ohhaimark",
        "timestamp": 1705572637
    },
    {
        "content": "<p>^ I can confirm this is correct :)</p>",
        "id": 416539227,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1705572984
    },
    {
        "content": "<p>I don't think <code>d : Fin n</code> is a good idea.</p>",
        "id": 416539427,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705573045
    },
    {
        "content": "<p>Not a direct answer to your question, but I think this definition might be useful:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">separated</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Code</span> <span class=\"n\">n</span> <span class=\"bp\">𝔽</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">hamming_distance</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">≥</span> <span class=\"n\">d</span>\n</code></pre></div>",
        "id": 416540203,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705573298
    },
    {
        "content": "<p>My last comment: I don't see what <code>Alphabet</code> should do in your code.</p>",
        "id": 416540540,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705573400
    },
    {
        "content": "<p><del>To elaborate, perhaps unnecesarily, <code>separated C 0</code> is always true since <code>x ≥ 0</code> is always true  and since ℕ is well founded, you can find the minimum d such that <code>separated C d</code>. I think that'll translate fairly straightforwardly in mathlib.</del></p>",
        "id": 416548750,
        "sender_full_name": "ohhaimark",
        "timestamp": 1705576321
    },
    {
        "content": "<p>The interesting question is the maximum <code>d</code> such that...</p>",
        "id": 416550471,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705576958
    },
    {
        "content": "<p>Oh. I should refrain from commenting with my airheadedness</p>",
        "id": 416550721,
        "sender_full_name": "ohhaimark",
        "timestamp": 1705577052
    },
    {
        "content": "<p>If you are interested in coding theory you might be interested in talking to <span class=\"user-mention\" data-user-id=\"330967\">@Wrenna Robson</span></p>",
        "id": 416551003,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1705577172
    },
    {
        "content": "<p>Hi. <span class=\"user-mention\" data-user-id=\"653650\">@Allan Li</span> we already have the hamming metric defined</p>",
        "id": 416551125,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705577228
    },
    {
        "content": "<p>We also have a construct called infsup (I think) which is designed to be used for exactly this</p>",
        "id": 416551181,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705577254
    },
    {
        "content": "<p>Yeah, I was going to say, if you want spoilers, you can see how mathlib defines the hamming distance at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=hammingDist#doc\">docs#hammingDist</a></p>",
        "id": 416551191,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1705577257
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.infsep#doc\">docs#Set.infsep</a></p>",
        "id": 416551272,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705577284
    },
    {
        "content": "<p>However yeah I had a go at defining linear codes a year or two ago and I never really got anywhere with it. I know Dan Bernstein has done some formalisation in this area too but his work hasn't made it to Mathlib in any form.</p>",
        "id": 416551427,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705577346
    },
    {
        "content": "<p>Ah I see you have already imported the hamming distance file</p>",
        "id": 416551484,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705577378
    },
    {
        "content": "<p>What you want to do is define Codeword as Hamming (Fin n -&gt; alpha)</p>",
        "id": 416551615,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705577420
    },
    {
        "content": "<p>And then the hamming distance of a set of codewords is given by s.infsep</p>",
        "id": 416551721,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705577464
    },
    {
        "content": "<p>(because that's the ambient metric on the space)</p>",
        "id": 416551756,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705577476
    },
    {
        "content": "<p>The design intent was always to use this for codes but I never got round to putting infsep and hamming together!</p>",
        "id": 416551973,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705577550
    },
    {
        "content": "<p>But yeah above people are trying to go down the path I already went down when I made infsep. You don't need to do this again!</p>",
        "id": 416552702,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705577802
    },
    {
        "content": "<p>The only thing we could ARGUABLY do with is a definition of Finset.infsep but I think we decided that wasn't strictly necessary. You'd want it if you wanted a computable version I guess.</p>",
        "id": 416552795,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705577846
    },
    {
        "content": "<p>What's interesting actually is that the hamming distance has a very well-behaved infsep even not on final steps because it takes integer values. I don't think we ever worked out quite how to formalise that property.</p>",
        "id": 416552985,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705577912
    },
    {
        "content": "<p>By well behaved I mean \"a set is non-trivial if and only if its infsep is positive\" - that's true for finite sets, and we have that, but what we don't have is a notion of, I guess, a \"discrete metric\" (in the sense of a metric that gives rise to the discrete topology, rather than the usual sense of discrete metric).</p>",
        "id": 416553570,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705578163
    },
    {
        "content": "<p>Or I guess, specifically, a metric where non-equal things have some minimum distance.</p>",
        "id": 416553675,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705578224
    },
    {
        "content": "<p>So actually it's univ.infsep &gt; 0 isn't it</p>",
        "id": 416557091,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705579549
    },
    {
        "content": "<p>Which is somewhat the relatively discrete stuff in there, but it's very limited and could do with extending.</p>",
        "id": 416557722,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705579769
    },
    {
        "content": "<p>Also I feel like maybe that ought to be \"uniformly discrete\"</p>",
        "id": 416558272,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705580008
    },
    {
        "content": "<p>Based on <a href=\"https://en.m.wikipedia.org/wiki/Delone_set\">https://en.m.wikipedia.org/wiki/Delone_set</a></p>",
        "id": 416558773,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705580189
    },
    {
        "content": "<p>I think I got as far as suggesting that we ought to have a notion of uniformly discrete metric spaces but no further.</p>",
        "id": 416558992,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705580271
    },
    {
        "content": "<p>I still think this!</p>",
        "id": 416559081,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705580291
    },
    {
        "content": "<p>We should define UniformlyDiscrete and RelativelyDense as predicates on sets with a metric, and then we could also define Delone, and then we could define a UniformlyDiscrete(E)Metric as a metric for which univ is a UniformlyDiscrete set.</p>",
        "id": 416559710,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705580523
    },
    {
        "content": "<p>All of which would help with coding theory but isn't directly related to it, but this was kind of what I found: you end up having to do a lot of stuff in specific that really you want to define in general and then be specific about.</p>",
        "id": 416559847,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705580572
    },
    {
        "content": "<p>We might also want to define covering radius and packing radius which are related but not the same.</p>",
        "id": 416560379,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705580760
    },
    {
        "content": "<p>It all needs a plan, basically, and I was only one person working on my own so it was hard to get any engagement with it.</p>",
        "id": 416560482,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705580784
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"653650\">@Allan Li</span> i would be interested to help out if and when you take this further</p>",
        "id": 417180947,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705913107
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330967\">@Wrenna Robson</span>  I am thinking about taking this project further. I have already set up the blueprint and documentation for the project <a href=\"https://shilun-allan-li.github.io/tcslib/\">https://shilun-allan-li.github.io/tcslib/</a> I am thinking about following <a href=\"https://people.eecs.berkeley.edu/~venkatg/teaching/ECC-fall22/\">lectures notes</a> on coding theory and implementing the blueprint of the theorems first.</p>",
        "id": 417181501,
        "sender_full_name": "Allan Li",
        "timestamp": 1705913340
    },
    {
        "content": "<p>Sounds great.</p>",
        "id": 417182771,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705913882
    },
    {
        "content": "<p>Was the above useful?</p>",
        "id": 417185855,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705914915
    },
    {
        "content": "<p>Yeah, thanks for the advice</p>",
        "id": 417185891,
        "sender_full_name": "Allan Li",
        "timestamp": 1705914938
    },
    {
        "content": "<p>I think the definition of code there is as good as any. For what it's worth I think it might be good to have this stuff in mathlib but I guess it could be downstream.</p>",
        "id": 417186512,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1705915146
    },
    {
        "content": "<p>I'm creating a new library since I'm also trying to formalize  other TCS results (for example  complexity theory). I'm note sure if these results would fit into mathlib</p>",
        "id": 417188123,
        "sender_full_name": "Allan Li",
        "timestamp": 1705915739
    },
    {
        "content": "<p>i tried to replicate these definitions, while extending it to define all Codes instead of just linear codes and got a decent way, even defining the minimal distance, dimension, and rate of a code.<br>\ni'd like to also formalise the hamming bound and possibly even prove it, but i'm having a bit of trouble integrating with the Hamming distance and metric. </p>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/113489-new-members/topic/Buiding.20a.20Coding.20Theory.20Library/near/416551615\">said</a>:</p>\n<blockquote>\n<p>What you want to do is define Codeword as Hamming (Fin n -&gt; alpha)</p>\n</blockquote>\n<p>i tried defining CodeWord the way that was suggested, but it doesn't seem to work? i don't quite get the type of <code>Hamming</code> either, it seems to say it needs some kind of dependent type?</p>\n<p>this is what i tried:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.InformationTheory.Hamming</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">CodeWord</span> <span class=\"o\">(</span><span class=\"n\">ι</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">Hamming</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and this is the error i got:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>application type mismatch\n  Hamming (ι → Ω)\nargument\n  ι → Ω\nhas type\n  Type : Type 1\nbut is expected to have type\n  ?m.1224 ι Ω → Type : Type 1\n</code></pre></div>",
        "id": 420746142,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707519651
    },
    {
        "content": "<p>Hmm, I can't quite remember how it's defined</p>",
        "id": 420746628,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707519958
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Hamming#doc\">docs#Hamming</a></p>",
        "id": 420746681,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707519970
    },
    {
        "content": "<p>Right yes I see - you're putting in the type \\iota -&gt; \\omega. But actually you want something like this: <code>const \\iota \\omega</code></p>",
        "id": 420746908,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707520101
    },
    {
        "content": "<p>The other day after chatting about this I was playing around with definitions of the various delone quantities. I think I'm intending to redefine infsep to be the packing diameter at some point, and also define covering radius</p>",
        "id": 420747009,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707520181
    },
    {
        "content": "<p>this seemed to work: <code>@Hamming ι (fun x =&gt; Ω)</code></p>",
        "id": 420747152,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707520265
    },
    {
        "content": "<p>Yes that's essentially the same</p>",
        "id": 420747179,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707520287
    },
    {
        "content": "<p>sadly const doesn't seem to be a built-in</p>",
        "id": 420747194,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707520300
    },
    {
        "content": "<p>Function.const maybe?</p>",
        "id": 420747202,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707520311
    },
    {
        "content": "<p>Sorry I just got back from a week of house hunting, I'm pretty pooped ;_;</p>",
        "id": 420747307,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707520373
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/113489-new-members/topic/Buiding.20a.20Coding.20Theory.20Library/near/420747202\">said</a>:</p>\n<blockquote>\n<p>Function.const maybe?</p>\n</blockquote>\n<p>you're right, that does work! and that way i don't need to specify the implicit context parameter too! thanks!</p>",
        "id": 420747458,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707520452
    },
    {
        "content": "<p>Nw</p>",
        "id": 420747847,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707520672
    },
    {
        "content": "<p>One thing I got stuck on was that not all codes use the hamming metric</p>",
        "id": 420747931,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707520709
    },
    {
        "content": "<p>But I'm interested to see where you get to</p>",
        "id": 420747972,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707520739
    },
    {
        "content": "<p>the plan is to define linear codes afterward, along with isomorphisms of linear codes...<br>\nspeaking of, is there some reason why those are defined to conserve distance on the entire vectorspace, rather than just on the code? i couldn't figure it out, and there didn't seem to be some obvious proof that those are the same...</p>",
        "id": 420748343,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707520968
    },
    {
        "content": "<p>How do you mean?</p>",
        "id": 420749183,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707521437
    },
    {
        "content": "<p>Which distance?</p>",
        "id": 420749226,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707521467
    },
    {
        "content": "<p>Anyway, an isometry of the space preserves distances.</p>",
        "id": 420749253,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707521486
    },
    {
        "content": "<p>It would be strange to define an isometry only on a set...</p>",
        "id": 420749288,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707521504
    },
    {
        "content": "<p>But of course you could define some notion of isometryOn...</p>",
        "id": 420749340,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707521524
    },
    {
        "content": "<p>i see my mistake now... a key aspect of a Code is its embedding in the space of all possible codewords, since that's the space from where you want to be able to correct. i thought that it (for a linear code at least) was just some set with a notion of adding, scalar multiplying, and a notion of hamming distance on that set.</p>",
        "id": 420750141,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707522019
    },
    {
        "content": "<p>Indeed, but it is not - the embedding is important</p>",
        "id": 420750178,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707522051
    },
    {
        "content": "<p>It's a subset, or subspace in the case of a linear code</p>",
        "id": 420750197,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707522065
    },
    {
        "content": "<p>But as I say not all codes use the hamming distance</p>",
        "id": 420750217,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707522082
    },
    {
        "content": "<p><a href=\"https://arxiv.org/abs/2203.12384#:~:text=The%20rank%20metric%20measures%20the,by%20a%20variety%20of%20applications\">https://arxiv.org/abs/2203.12384#:~:text=The%20rank%20metric%20measures%20the,by%20a%20variety%20of%20applications</a>.</p>",
        "id": 420750238,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707522101
    },
    {
        "content": "<p>Indeed it's not even necessary in theory that they be finite</p>",
        "id": 420750261,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707522119
    },
    {
        "content": "<p>At least the underlying space - I think in practice you would always want a code to be finite, and of course in any practical application infinity doesn't exist</p>",
        "id": 420750355,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707522177
    },
    {
        "content": "<p>right... i'm not sure how i would have to extend the definition that i have now though... something i (or someone else) will have to figure out later</p>",
        "id": 420750457,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707522247
    },
    {
        "content": "<p>Broadly speaking, a \"code\" can be thought of as just some set in an arbitrary type, such that the set is sufficiently separated that I can distinguish members of the code, and so that sufficiently large balls around the codewords cover the set</p>",
        "id": 420750487,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707522279
    },
    {
        "content": "<p>That is, really, a delone set. Many theorems about \"codes\" are actually theorems in that much more general setting</p>",
        "id": 420750516,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707522308
    },
    {
        "content": "<p>But yes - what you should do is continue your work and hopefully someone will generalise it later</p>",
        "id": 420750537,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707522328
    },
    {
        "content": "<p><a href=\"https://en.m.wikipedia.org/wiki/Hamming_bound#:~:text=In%20mathematics%20and%20computer%20science,space%20of%20all%20possible%20words\">https://en.m.wikipedia.org/wiki/Hamming_bound#:~:text=In%20mathematics%20and%20computer%20science,space%20of%20all%20possible%20words</a>.</p>",
        "id": 420750548,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707522345
    },
    {
        "content": "<p>Proving the hamming bound would be a good test</p>",
        "id": 420750568,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707522362
    },
    {
        "content": "<p>And then proving facts about perfect codes is the natural next step</p>",
        "id": 420750653,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707522406
    },
    {
        "content": "<p>If you could prove this result it would be a very fine thing indeed: <a href=\"https://epubs.siam.org/doi/abs/10.1137/0124010?journalCode=smjmap\">https://epubs.siam.org/doi/abs/10.1137/0124010?journalCode=smjmap</a></p>",
        "id": 420750706,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707522452
    },
    {
        "content": "<p>i'm afraid i might fall short of those last two... the main reason i'm developing this part of the library is because i'd like a rigorous notion of code automorphisms, as the construction of the sporadic Mathieu-12 group depends in part on it (, or at least in the book i'm reading it does). i might give it a shot though</p>",
        "id": 420751055,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707522685
    },
    {
        "content": "<p>Oh exciting</p>",
        "id": 420751286,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707522817
    },
    {
        "content": "<p>The reason I suggest it is just that testing your definitions actually work for proving things is a great way to see if they're any good</p>",
        "id": 420751401,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707522868
    },
    {
        "content": "<p>i'm having a bit of trouble... the packing distance in a metric space is half the smallest distance between points... however, for codes with the hamming distance, the packing distance is rounded down... is there a good way to unify this? if there isn't, which definition should i use?</p>\n<p>there might be several options:</p>\n<ul>\n<li>the largest radius such that all open balls around points in the subset are disjoint<ul>\n<li>this one would suggest rounding up</li>\n</ul>\n</li>\n<li>the largest radius such that there is a all closed balls around points in the subset are disjoint, and there is some point where the shortest distance to a point in the subset is that radius<ul>\n<li>this one agrees with the definition saying to round down.</li>\n<li>however, it only works in the discrete case, in the continuous case the limsup might give a value for which the property doesn't hold</li>\n</ul>\n</li>\n<li>keep it as-is, half the smallest distance</li>\n</ul>",
        "id": 420809391,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707579552
    },
    {
        "content": "<p>i feel the key to this problem is that in the discrete case, looking at a closed set makes more sense. in particular because it is sensible to only consider packing distances where there actually is some point with that distance to the subset</p>",
        "id": 420809624,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707579729
    },
    {
        "content": "<p>somehow you'd want to look at both open and closed balls, and look at which combination of open/closed and radius fits the maximum amount of points in balls, while keeping the property that the balls around points in the subset are disjoint</p>",
        "id": 420809794,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707579856
    },
    {
        "content": "<p>is there some mathematical concept that describes this?</p>",
        "id": 420809853,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707579913
    },
    {
        "content": "<p>It might help to write down a bunch of such statements in Lean, and prove them with <code>sorry</code>. And then at some point the API might suggest what the optimal definition is.</p>",
        "id": 420809861,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707579917
    },
    {
        "content": "<p>Or you make all 3 definitions, and some implications between them...</p>",
        "id": 420809929,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707579965
    },
    {
        "content": "<p>i was kindof thinking of somehow generalising this notion of \"picking the largest radius that exists, such that all closed or all open balls  are disjoint\"</p>",
        "id": 420810076,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707580093
    },
    {
        "content": "<p>but that will make properties a bit harder, because you don't necessarily know if you are talking about opens or closeds</p>",
        "id": 420810121,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707580132
    },
    {
        "content": "<p>Yeah I know the issue you're talking about</p>",
        "id": 420810173,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707580181
    },
    {
        "content": "<p>The easiest way to think about it I think is:  the hamming metric is integer-valued, so \"half\" rounds down</p>",
        "id": 420810292,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707580257
    },
    {
        "content": "<p>yes... except that when you use <code>s.infsep</code>, it becomes real-valued automatically</p>",
        "id": 420810349,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707580299
    },
    {
        "content": "<p>Yes, it's because we have no notion really of an integer-valued distance</p>",
        "id": 420810395,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707580324
    },
    {
        "content": "<p><em>but</em></p>",
        "id": 420810425,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707580329
    },
    {
        "content": "<p><a href=\"https://en.m.wikipedia.org/wiki/Delone_set\">https://en.m.wikipedia.org/wiki/Delone_set</a></p>",
        "id": 420810615,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707580461
    },
    {
        "content": "<p>I think you want to use the definition here</p>",
        "id": 420810625,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707580470
    },
    {
        "content": "<p>Like it's still true that open balls of radius infsep/2 won't intersect</p>",
        "id": 420810655,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707580495
    },
    {
        "content": "<p>But - ah yeah right sorry, this is why one rounds up I think...</p>",
        "id": 420810713,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707580556
    },
    {
        "content": "<p>If it's t-error correcting, then closed balls of radius t won't intersect. So in other words, the infsep has to be at least 2t + 1, right? If it was 2t, then there would be some pair with 2t coordinates different, but then if you change t of one to the coordinates of the other, that's t away from two codewords, and we can't correct it</p>",
        "id": 420811220,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707580911
    },
    {
        "content": "<p>I think infsep/2 is the only sensible definition of packing radius. But it might mean that some of the literature doesn't quite line up. What I found was that defining it in terms of the balls isn't the way to go - you kinda want to treat that as a property you prove</p>",
        "id": 420811607,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707581196
    },
    {
        "content": "<p>Especially because you can then say \"ah well if e &gt; packing radius, balls of that radius intersect\", and that's true for I think both open and closed balls</p>",
        "id": 420811678,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707581265
    },
    {
        "content": "<p>I recently tried writing some of this down - if you search on Zulip I think I posted some of it?</p>",
        "id": 420811757,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707581309
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/113489-new-members/topic/Buiding.20a.20Coding.20Theory.20Library/near/420811678\">said</a>:</p>\n<blockquote>\n<p>Especially because you can then say \"ah well if e &gt; packing radius, balls of that radius intersect\", and that's true for I think both open and closed balls</p>\n</blockquote>\n<p>this is not the case though?</p>",
        "id": 420811787,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707581331
    },
    {
        "content": "<p>Is it not? I suppose it might not be</p>",
        "id": 420811844,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707581388
    },
    {
        "content": "<p>if you take the entire space as your code, infsep will be 1. so then the packing radius is 1/2, but open balls of size 3/4 don't intersect</p>",
        "id": 420811854,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707581398
    },
    {
        "content": "<p>even open balls of radius 1 don't</p>",
        "id": 420811913,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707581420
    },
    {
        "content": "<p>Around each point in the space?</p>",
        "id": 420811929,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707581433
    },
    {
        "content": "<p>yes</p>",
        "id": 420811939,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707581440
    },
    {
        "content": "<p>in the discrete case</p>",
        "id": 420811947,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707581449
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 420811952,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707581453
    },
    {
        "content": "<p>Oh yes of course because there's no \"points in-between\"</p>",
        "id": 420811976,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707581482
    },
    {
        "content": "<p>Which is why my geometric intuition is messing up</p>",
        "id": 420811985,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707581491
    },
    {
        "content": "<p>Whereas in lattice theory obviously they embed in a larger space... hmm</p>",
        "id": 420812102,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707581591
    },
    {
        "content": "<p>What I suppose <em>is</em> true is that closed balls with radius infsep around a point in the space will always contain another point in the space</p>",
        "id": 420812244,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707581705
    },
    {
        "content": "<p>I think that's true in the continuous and discrete cases?</p>",
        "id": 420812252,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707581715
    },
    {
        "content": "<p>yes, by definition of infsep</p>",
        "id": 420812278,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707581741
    },
    {
        "content": "<p>it gives you the pair of points in the subset of that distance</p>",
        "id": 420812306,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707581763
    },
    {
        "content": "<p>The abstract of this paper looks interesting and promising</p>",
        "id": 420812409,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707581855
    },
    {
        "content": "<p><a href=\"https://link.springer.com/article/10.1007/s10623-012-9623-4\">https://link.springer.com/article/10.1007/s10623-012-9623-4</a></p>",
        "id": 420812412,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707581857
    },
    {
        "content": "<p>Yeah here is a neat but troubling example</p>",
        "id": 420812785,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707582166
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/sCq068He_cQVBeNycboo1D2D/f867cdc2-dbbf-4e4e-a6cb-02cc3cf9f5e1.jpg\">f867cdc2-dbbf-4e4e-a6cb-02cc3cf9f5e1.jpg</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/sCq068He_cQVBeNycboo1D2D/f867cdc2-dbbf-4e4e-a6cb-02cc3cf9f5e1.jpg\" title=\"f867cdc2-dbbf-4e4e-a6cb-02cc3cf9f5e1.jpg\"><img src=\"/user_uploads/3121/sCq068He_cQVBeNycboo1D2D/f867cdc2-dbbf-4e4e-a6cb-02cc3cf9f5e1.jpg\"></a></div>",
        "id": 420812795,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707582179
    },
    {
        "content": "<p>(note this is using the language of permutation codes)</p>",
        "id": 420812885,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707582253
    },
    {
        "content": "<p>But the idea is - you can construct two codes, both with min distance 6, but one of them <em>can</em> decode 3 errors and one can't.</p>",
        "id": 420812923,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707582292
    },
    {
        "content": "<p>yea, i got that much</p>",
        "id": 420812943,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707582309
    },
    {
        "content": "<p>If the min distance is 3, you can guarantee you can decode 2 errors, but you might not be able to decode 3</p>",
        "id": 420812957,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707582324
    },
    {
        "content": "<p>It suggests that in fact you do want to define the packing radius distinctly to infsep - it's that the minimum distance of the code is closely related to the packing radius, but I think it might be the case that you can't actually determine one from the other</p>",
        "id": 420813039,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707582389
    },
    {
        "content": "<p>Annoying!!</p>",
        "id": 420813068,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707582418
    },
    {
        "content": "<p>Also, making this definition in a way that is nicely compatible with the continuous case will be a pain, and it's never fun to be taking minimums.</p>",
        "id": 420813116,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707582459
    },
    {
        "content": "<p>i think in general i'd need to formalise these notions: <br>\n<code>class GMetricSpace A Codomain</code> <br>\n<code>def packing_radius (...) : (OpenOrClosed \\x Codomain)</code>with OpenOrClosed an enum.</p>",
        "id": 420813196,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707582520
    },
    {
        "content": "<p>Maybe - there was certainly some talk of doing generalised metric spaces at some point</p>",
        "id": 420813225,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707582555
    },
    {
        "content": "<p>Basically all this is why I gave up before - it felt like the kind of thing that was too big to do alone, because you end up with a bunch of different ways of doing a bunch of stuff, and you want some coordination</p>",
        "id": 420813251,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707582583
    },
    {
        "content": "<p>in that case, you can determine the radius simply by taking the supremum of radii that work in the closed case, while the enum is determined afterwards by checking wether a counterexample to the edge case exists</p>",
        "id": 420813346,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707582657
    },
    {
        "content": "<p>Yeah no I just mean that you end up wanting a lot of general API</p>",
        "id": 420813379,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707582696
    },
    {
        "content": "<p>That approach sounds hacky but if it lets you move forward it's better than nothing</p>",
        "id": 420813392,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707582710
    },
    {
        "content": "<p>the question is if i should keep calling such a space a <code>DeloneSet</code> or not...</p>",
        "id": 420813573,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707582870
    },
    {
        "content": "<p>Yeah. Possibly not!</p>",
        "id": 420813588,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707582891
    },
    {
        "content": "<p>But it feels like a useful notion to have and tantalisingly close to what you actually want</p>",
        "id": 420813629,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707582931
    },
    {
        "content": "<p>I think possibly, as <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> has observed at some point, part of the issue is that \"packing radius\" is kinda less useful than \"packing diameter\".</p>",
        "id": 420813711,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707582983
    },
    {
        "content": "<p>what's packing diameter?</p>",
        "id": 420813737,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707583019
    },
    {
        "content": "<p>twice the radius of the largest sphere that does not contain an element of the subset?</p>",
        "id": 420813801,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707583081
    },
    {
        "content": "<p>Infsep, probably.</p>",
        "id": 420813984,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707583205
    },
    {
        "content": "<p>It's sort of like, intuitively, we can expand out to that diameter without hitting another codeword</p>",
        "id": 420814005,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707583228
    },
    {
        "content": "<p>Or rather I suppose, that's the first time when we might</p>",
        "id": 420814020,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707583245
    },
    {
        "content": "<p>Or when another codeword is an infinitesimal distance away?</p>",
        "id": 420814029,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707583259
    },
    {
        "content": "<p>It doesn't help we don't even have a notion of discrete metric...</p>",
        "id": 420814042,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707583274
    },
    {
        "content": "<p>right... let me get a start with general metrics, see how that goes</p>",
        "id": 420814075,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707583307
    },
    {
        "content": "<p>i'm guessing the best general case for a notion of distance is a linear ordering with a lowest element?</p>",
        "id": 420814275,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707583447
    },
    {
        "content": "<p>where we'd like the distance between an element and itself to be that lowest element?</p>",
        "id": 420814461,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707583571
    },
    {
        "content": "<p>Uh. Well, you don't need the second part. I guess that would be a generalised pseudometric?</p>",
        "id": 420814693,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707583757
    },
    {
        "content": "<p>so just any linear ordering?</p>",
        "id": 420814728,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707583796
    },
    {
        "content": "<p>Well, for the dist function it can be anything, in a sense that's just notation.</p>",
        "id": 420815358,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707584204
    },
    {
        "content": "<p>ah, there is a slight hiccup as we <em>would</em> like to be able to add distances to define the triangle inequality</p>",
        "id": 420815406,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707584238
    },
    {
        "content": "<p><a href=\"#narrow/stream/113489-new-members/topic/Buiding.20a.20Coding.20Theory.20Library/near/420815406\">A message</a> was moved here from <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members/topic/How.20to.20get.20the.20least.20element.20of.20a.20set.20of.20natural.20numbers.3F\">#new members &gt; How to get the least element of a set of natural numbers?</a> by <span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span>.</p>",
        "id": 420815432,
        "sender_full_name": "Notification Bot",
        "timestamp": 1707584262
    },
    {
        "content": "<p>i'm guessing we should like it to be a monoid which respects ordering? as in, adding only increases its value?</p>",
        "id": 420815620,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707584382
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/113489-new-members/topic/Buiding.20a.20Coding.20Theory.20Library/near/420813711\">said</a>:</p>\n<blockquote>\n<p>I think possibly, as <span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> has observed at some point, part of the issue is that \"packing radius\" is kinda less useful than \"packing diameter\".</p>\n</blockquote>\n<p>I'm not sure I said this exactly, but I do agree that you can't just take the packing radius to be half the packing diameter.</p>",
        "id": 420817119,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707585458
    },
    {
        "content": "<p>I will also point out that, just as we have both <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.floor#doc\">docs#Int.floor</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.ceil#doc\">docs#Int.ceil</a>, you will very likely need both the left and right adjoint to some map (which I think is <code>ε ↦ ball x ε</code>, but I'm not sure)</p>",
        "id": 420817243,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707585540
    },
    {
        "content": "<p>the first hurdle has been cleared: writing a definition for a general equivalent to a PseudoMetricSpace.</p>\n<p>it turns out you can easily extend it. The construction of a Bornology (whatever that is) still works. However, i was unable to extend the mapping to a Uniform space</p>",
        "id": 420819573,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707587449
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/Buiding.20a.20Coding.20Theory.20Library/near/420817243\">said</a>:</p>\n<blockquote>\n<p>I will also point out that, just as we have both <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.floor#doc\">docs#Int.floor</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.ceil#doc\">docs#Int.ceil</a>, you will very likely need both the left and right adjoint to some map (which I think is <code>ε ↦ ball x ε</code>, but I'm not sure)</p>\n</blockquote>\n<p>Oh this is a nice observation.</p>",
        "id": 420829419,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707595780
    },
    {
        "content": "<p>i think that's precisely what will happen when i add the option between open or closed... not <em>exactly</em> sure, but i think so</p>",
        "id": 420829597,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707595940
    },
    {
        "content": "<p>right now, i've defined the generalised metric to have domain <code>β</code> with <code>[LinearOrderedAddCommMonoid β]</code>, however in copying some lemmas of PseudoMetricSpace i often come across instances where i'd like to prove something like <code>(a &lt; b) -&gt; (a + c &lt; b + c)</code>, and the original proofs make use of some lemmas (in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Algebra.Order.Monoid.Lemmas#doc\">docs#Mathlib.Algebra.Order.Monoid.Lemmas</a>) which require an instance <code>[CovariantClass β β (fun x x_1 ↦ x + x_1) fun x x_1 ↦ x &lt; x_1]</code>... i'm not exactly sure how i should fix something like this, other than explicitly adding the instance and continuing... is there some single stronger requirement i could ask of <code>β</code>? the trouble of expanding to something like [Group β] is that you'd probably have to allow negative distances...</p>",
        "id": 420834329,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707600900
    },
    {
        "content": "<p>Look up <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearOrderedAddCommMonoid#doc\">docs#LinearOrderedAddCommMonoid</a></p>",
        "id": 420840580,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707607184
    },
    {
        "content": "<p>See that it is extended by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearOrderedCancelAddCommMonoid#doc\">docs#LinearOrderedCancelAddCommMonoid</a></p>",
        "id": 420840691,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707607288
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 420871755,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707639747
    },
    {
        "content": "<p>i'd like some advice...</p>\n<p>right now i've defined a notion of generalised DeloneSet, and have a definition for a \"general\" Linear Code, i.e. a subspace of some vectorspace that is also a DeloneSet... however, now i'm not sure if there really is a difference between a DeloneSet and a code. furthermore, i'm not certain if i should add more requirements to Linear Codes, as the current notion really seems like the best definition that does not necessarily use the Hamming distance. i could of course add a requirement that the vectorspace must be a finite disjoint union of a finite field (or something like that), but that seems unnecessarily restrictive... what is the best course going forward?</p>",
        "id": 421116797,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707767883
    },
    {
        "content": "<p>I'm not sure if there's a meaningful rather than contextual difference.</p>",
        "id": 421117067,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707767969
    },
    {
        "content": "<p>Honestly what I would do is try to free yourself from definition hell by picking some simple theorems and trying to prove them.</p>",
        "id": 421117201,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707768008
    },
    {
        "content": "<p>In my experience that is the best guide.</p>",
        "id": 421117226,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707768015
    },
    {
        "content": "<p>Trying to remember what we call a module equipped with a compatible norm... There's a word for this. Anyway, <em>all</em> subspaces of the suitable vector space are linear codes - so it must be a property of the <em>space</em>, not the individual code</p>",
        "id": 421117637,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707768128
    },
    {
        "content": "<p>Like there's something about the space that means all subspaces are delone, right?</p>",
        "id": 421117715,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707768155
    },
    {
        "content": "<p>And that's weird. It's certainly not true of all subsets! But I wonder if it is the essential thing you need to capture</p>",
        "id": 421117778,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707768182
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/113489-new-members/topic/Buiding.20a.20Coding.20Theory.20Library/near/421117067\">said</a>:</p>\n<blockquote>\n<p>I'm not sure if there's a meaningful rather than contextual difference.</p>\n</blockquote>\n<p>the differences that i can think of of the top of my head are twofold: the first difference is that right now, the vectorspace can have any number of dimensions (even infinite). secondly, as of yet there is no restriction on the \"size\" of the scalar field, so each of the dimensions can stretch on forever in every direction you'd like, which most certainly isn't the case for products of finite fields.</p>",
        "id": 421119154,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707768651
    },
    {
        "content": "<p>But is this actually important for anything in the actual definition?</p>",
        "id": 421119246,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707768691
    },
    {
        "content": "<p>Rather than an extra hypothesis you will introduce in certain theorems?</p>",
        "id": 421119290,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707768706
    },
    {
        "content": "<p>well... if i want to at least be somewhat consistent with existing literature....</p>",
        "id": 421119395,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707768732
    },
    {
        "content": "<p>I agree that there's a few finiteness constraints that you need for coding theory</p>",
        "id": 421119421,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707768743
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/113489-new-members/topic/Buiding.20a.20Coding.20Theory.20Library/near/421119395\">said</a>:</p>\n<blockquote>\n<p>well... if i want to at least be somewhat consistent with existing literature....</p>\n</blockquote>\n<p>In my experience - I don't think I'm entirely wrong about this - the definitions in existing literature don't always match up with the natural way to formalise things, and it's very easy to unnecessarily introduce constraints into your definitions that aren't actually necessary for them.</p>",
        "id": 421119565,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707768799
    },
    {
        "content": "<p>I personally take a formalisation philosophy that things should minimally use preconditions, only when they are necessary.</p>",
        "id": 421119703,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707768844
    },
    {
        "content": "<p>Like in the literature sometimes a code is defined as a map and sometimes it's defined as the image of that map</p>",
        "id": 421119796,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707768878
    },
    {
        "content": "<p>You literally can't be fully consistent.</p>",
        "id": 421119807,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707768885
    },
    {
        "content": "<p>it can be a map <span aria-label=\"melting face\" class=\"emoji emoji-1fae0\" role=\"img\" title=\"melting face\">:melting_face:</span></p>",
        "id": 421119891,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707768916
    },
    {
        "content": "<p>welp</p>",
        "id": 421119906,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707768922
    },
    {
        "content": "<p>And in my experience if you make your definitions too specialised, it becomes challenging to go on and use your definitions</p>",
        "id": 421119923,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707768930
    },
    {
        "content": "<p>Well yeah of course</p>",
        "id": 421119928,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707768933
    },
    {
        "content": "<p>Like another way of thinking about a linear code is that it's an injective linear map, right?</p>",
        "id": 421120020,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707768964
    },
    {
        "content": "<p>Say from a space with dimension n to a space with dimension k</p>",
        "id": 421120076,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707768980
    },
    {
        "content": "<p>And maybe we have a metric on the spaces which is, essentially, the hamming metric according to a particular basis for both of them</p>",
        "id": 421120156,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707769014
    },
    {
        "content": "<p>Then the image of the map is the set of codewords.</p>",
        "id": 421120191,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707769028
    },
    {
        "content": "<p>i hadn't thought about it that way, i had only come across the \"it's a subset with those distance properties\" part...</p>",
        "id": 421120239,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707769050
    },
    {
        "content": "<p>OR it could be a surjective linear map from a space with dimension n to a space with dimension n - k, and the kernel is the set of codewords</p>",
        "id": 421120295,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707769070
    },
    {
        "content": "<p>Because linear codes (well, any subspace, but in this context) are simultaneously images or kernels, and when they're images we think of them as codewords, and when they're kernels we think of them as sets with null syndromes</p>",
        "id": 421120505,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707769137
    },
    {
        "content": "<p>the thing is, i think the requirements you pose on automorphisms make a lot more sense when you look at a Code (not necessarily a linear one) as a map, rather than a subset, as it makes it obvious that the \"superspace\" is important</p>",
        "id": 421120556,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707769160
    },
    {
        "content": "<p>Yes. But the trouble is the choice of map is not unique</p>",
        "id": 421120623,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707769190
    },
    {
        "content": "<p>Different encodings can give rise to the same codewords</p>",
        "id": 421120652,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707769201
    },
    {
        "content": "<p>Which is why one makes the equation of the linear codes with the subspaces/subsets</p>",
        "id": 421120775,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707769236
    },
    {
        "content": "<p>The trouble being that it does somewhat obscure these other properties/perspectives</p>",
        "id": 421120840,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707769258
    },
    {
        "content": "<p>And the issue is that in formalisation, we really have to care about what things actually are, rather than making these kind of elisions where we equate stuff</p>",
        "id": 421120983,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707769317
    },
    {
        "content": "<p>the main problem that i'm understanding from this is that given some distance function and set of codewords on some space, the mapping is not unique?</p>",
        "id": 421121051,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707769328
    },
    {
        "content": "<p>Yes</p>",
        "id": 421121120,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707769356
    },
    {
        "content": "<p>Another way of thinking about this is - you have many different generating sets for the same code</p>",
        "id": 421121181,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707769377
    },
    {
        "content": "<p>Or sometimes you want to take one code and permute it to obscure its structure (this is relevant in cryptography).</p>",
        "id": 421121277,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707769411
    },
    {
        "content": "<p>i don't think that different generating sets should be a problem the way i've linear codes right now... and i think permuting a code can be done by simply applying the permutation before both parameters of the metric and before the correcting map? that should still work, right?</p>",
        "id": 421121893,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707769600
    },
    {
        "content": "<p>Correcting map?</p>",
        "id": 421123329,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707770059
    },
    {
        "content": "<p>the mapping from the entire space to the codewords?</p>",
        "id": 421123426,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707770089
    },
    {
        "content": "<p>Why is it called that?</p>",
        "id": 421123529,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707770117
    },
    {
        "content": "<p>that's how i describe it. i'm not very familiar with coding theory, but that's what i'd call it. if it's not obvious or if there is a better/more common name for such a map, i do apologise, i didn't know.</p>",
        "id": 421123895,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707770223
    },
    {
        "content": "<p>because the map corrects</p>",
        "id": 421123981,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707770258
    },
    {
        "content": "<p>Oh I see, as in, the map that - right</p>",
        "id": 421124171,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707770327
    },
    {
        "content": "<p>But you don't explicitly have such a map, right?</p>",
        "id": 421124199,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707770336
    },
    {
        "content": "<p>I would call this operation \"decoding\", incidentally</p>",
        "id": 421124239,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707770354
    },
    {
        "content": "<p>ah right, i remember seeing that somewhere...</p>",
        "id": 421124312,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707770383
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/113489-new-members/topic/Buiding.20a.20Coding.20Theory.20Library/near/421124199\">said</a>:</p>\n<blockquote>\n<p>But you don't explicitly have such a map, right?</p>\n</blockquote>\n<p>no, i don't... but i'm thinking about it...</p>",
        "id": 421124709,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707770523
    },
    {
        "content": "<p>i should at the very least consider it, before discarding such an idea</p>",
        "id": 421124793,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707770550
    },
    {
        "content": "<p>You can certainly define such a map</p>",
        "id": 421125267,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707770725
    },
    {
        "content": "<p>But you won't have a general explicit definition I think</p>",
        "id": 421125342,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707770754
    },
    {
        "content": "<p>Not a computable one anyway</p>",
        "id": 421125425,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707770774
    },
    {
        "content": "<p>yes, and extensionality would also be a weaker tool, precisely because there might be multiple decoding maps</p>",
        "id": 421125630,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707770861
    },
    {
        "content": "<p>Well ideally it is unambiguous what they decode to, so from a function extensionality pov they're all the same, but I think one can certainly say of a function \"this function decodes that code\"</p>",
        "id": 421125916,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707770972
    },
    {
        "content": "<p>yes, i can certainly write such a statement... something along the lines of \"the function maps all closed balls of a certain radius around some codepont to that codepoint if they don't intersect with some other ball with that radius around another codepoint\"</p>",
        "id": 421126543,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707771173
    },
    {
        "content": "<p>Yeah the issue I guess is that you do have a limit to how much you can correct</p>",
        "id": 421126794,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707771260
    },
    {
        "content": "<p>And I<em>think</em> that when it's not a perfect code, there will be things that cannot be corrected to anything</p>",
        "id": 421126844,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707771284
    },
    {
        "content": "<p>yes, that does seem right</p>",
        "id": 421126880,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707771302
    },
    {
        "content": "<p>i suppose you could construct a decoding map in general by doing axiom of choice on the family of sets of closest codewords for each point... but it wouldn't exactly be canonical</p>",
        "id": 421128532,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707771865
    },
    {
        "content": "<p>by the way, is there a name for the union of those closed balls i was talking about? or can i give it a name like \"sphere of influence\" or something?</p>",
        "id": 421128816,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707771969
    },
    {
        "content": "<p>Crucially I think decoding is NP hard in general</p>",
        "id": 421131663,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707772971
    },
    {
        "content": "<p>Hmm not sure. Name it and it can be renamed later.</p>",
        "id": 421131712,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1707772993
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Separates</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">GDeloneSet</span> <span class=\"n\">α₁</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">):</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">cw</span> <span class=\"bp\">∈</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">cw'</span> <span class=\"bp\">∈</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">cw</span> <span class=\"bp\">≠</span> <span class=\"n\">cw'</span> <span class=\"bp\">→</span> <span class=\"n\">closedBall</span> <span class=\"n\">cw</span> <span class=\"n\">δ</span> <span class=\"bp\">∩</span> <span class=\"n\">closedBall</span> <span class=\"n\">cw'</span> <span class=\"n\">δ</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">IsDecodingMap</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">GDeloneSet</span> <span class=\"n\">α₁</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">DecFun</span> <span class=\"o\">:</span> <span class=\"n\">α₁</span> <span class=\"bp\">→</span> <span class=\"n\">c</span><span class=\"o\">):</span><span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α₁</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">cw</span> <span class=\"bp\">∈</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">Separates</span> <span class=\"n\">β</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"n\">GDist.gdist</span> <span class=\"n\">x</span> <span class=\"n\">cw</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">DecFun</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">cw</span>\n</code></pre></div>\n<p>sneak peek</p>",
        "id": 421132325,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707773225
    },
    {
        "content": "<p>here beta is the type of the codomain of the metric we're using. it gets passed because lean doesn't always naturally infer the type we're going for</p>",
        "id": 421132619,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707773322
    },
    {
        "content": "<p>i'm having some trouble with defining the covering radius... according to <a href=\"https://en.m.wikipedia.org/wiki/Delone_set\">the source that was mentioned before</a>, it is the smallest distance such that closed balls around elements of some set <code>X</code> cover the entire space, however it seems to me that when you choose <code>X={1/n | n∈ℕ}</code> and the entire space <code>X∪ {-1}</code>, the infimum of distances which cover <code>{-1}</code> is equal to 1, however closed balls around elements of <code>X</code> with radius 1 all don't contain the element <code>{-1}</code>... so there is no such smallest distance...<br>\nis this just a bad description or definition of covering radius? or is there some assumption i'm missing?</p>",
        "id": 421931329,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1708114273
    },
    {
        "content": "<p>Just so you know, <span class=\"user-mention\" data-user-id=\"443984\">@Newell Jensen</span> is also interested in some of these things and is pursuing a patch to add some of these concepts</p>",
        "id": 421931443,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708114324
    },
    {
        "content": "<p>Yeah I think it is the infimum of something, but it may not imply that it does cover the space</p>",
        "id": 421931593,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708114394
    },
    {
        "content": "<p>You might need an extra assumption on the space (completeness?)</p>",
        "id": 421931669,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708114431
    },
    {
        "content": "<p>i think that would fix it yea.... or maybe something like the subset of elements closer than some radius is finite, maybe?</p>",
        "id": 421932067,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1708114594
    },
    {
        "content": "<p>i'm not completely sure</p>",
        "id": 421932109,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1708114622
    },
    {
        "content": "<p>Perhaps.</p>",
        "id": 421932113,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708114623
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> feel free to contribute to <a href=\"https://github.com/leanprover-community/mathlib4/pull/10641\">#10641</a> if you see fit.</p>",
        "id": 421932306,
        "sender_full_name": "Newell Jensen",
        "timestamp": 1708114721
    },
    {
        "content": "<p>thanks... although i did use my own definitions and stuff, so it might not exactly be compatible... in particular i generalised it so discrete metrics and anything inbetween could be used...</p>",
        "id": 421932586,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1708114860
    },
    {
        "content": "<p>most of my definitions parametrise over some codomain <code>β</code> which is a <code>CompleteLinearOrder</code> and a <code>AddCommMonoid</code>, along with a mixin which says that they work together nice...</p>",
        "id": 421932745,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1708114932
    },
    {
        "content": "<p>that way, some distances come out a bit better</p>",
        "id": 421933065,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1708115051
    },
    {
        "content": "<p>It might be good to state some goals: I think broadly what we are looking for here is, aside from the specific context of coding theory, to get concepts such as Delone sets, packing radii, minimum distance and so forth to a) lie flat together, b) be defined in Mathlib to an appropriate degree of generality i.e. for as arbitrary a metric space as possible.</p>",
        "id": 421933117,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708115073
    },
    {
        "content": "<p>The wrinkles come in because in the literature, different definitions are sometimes used, and in general settings they might not be equivalent.</p>",
        "id": 421933210,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708115113
    },
    {
        "content": "<p>Does that reflect both your understandings?</p>",
        "id": 421933223,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708115121
    },
    {
        "content": "<p>Actually I should post this in the other thread...</p>",
        "id": 421933265,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708115136
    }
]