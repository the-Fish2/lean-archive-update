[
    {
        "content": "<p>I've been trying to come up with a better minimum working example, but since I don't understand the problem, it's a bit tough to replicate.</p>\n<p>The following code fails at the indicated rewrite. Somehow I managed to use the \"throw everything at the wall and see what sticks\" approach to come up with a solution. So you can see that if I <code>simp only [IndexList.length] at i</code> before I try to rewrite, then I have a complete proof.</p>\n<p>What I'm missing is why. Based on my limited understanding, <code>simp at i</code> should do the opposite, and make <code>i</code> no longer match the value in <code>get_eq</code>. What's happening?</p>\n<p>(Sorry for the amount of code here)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Foo</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">IndexList</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">β</span>\n  <span class=\"n\">idxs</span><span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">l.length</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">IndexList.length</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">IndexList</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">l.idxs.card</span>\n<span class=\"kd\">def</span> <span class=\"n\">getElem</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">IndexList</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">l.length</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">l.l</span><span class=\"o\">[(</span><span class=\"n\">l.idxs.sort</span> <span class=\"n\">LE.le</span><span class=\"o\">)[</span><span class=\"n\">i</span><span class=\"o\">]]</span>\n<span class=\"kd\">def</span> <span class=\"n\">mem</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">IndexList</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">getElem</span> <span class=\"n\">l</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">mem_finset_union_left</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">l.card</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">l.sort</span> <span class=\"n\">LE.le</span><span class=\"o\">)[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"bp\">∪</span> <span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sort</span> <span class=\"n\">LE.le</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Finset.mem_sort</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_union</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"n\">Finset.mem_sort</span> <span class=\"n\">LE.le</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span>\n  <span class=\"n\">exact</span> <span class=\"n\">List.mem_iff_get.mpr</span> <span class=\"o\">⟨⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Finset.length_sort</span><span class=\"o\">,</span> <span class=\"n\">Fin.is_lt</span><span class=\"o\">]</span>\n  <span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">mem_indexlist_union_left</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">is₁</span> <span class=\"n\">is₂</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">l.length</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">mem</span> <span class=\"n\">a</span> <span class=\"o\">⟨</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">is₁</span><span class=\"o\">⟩</span> <span class=\"bp\">→</span> <span class=\"n\">mem</span> <span class=\"n\">a</span> <span class=\"o\">⟨</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">is₁</span> <span class=\"bp\">∪</span> <span class=\"n\">is₂</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">get_i_eq_a</span><span class=\"o\">⟩</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:=</span> <span class=\"n\">mem_finset_union_left</span> <span class=\"n\">is₁</span> <span class=\"n\">is₂</span> <span class=\"n\">i</span>\n  <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">i'</span><span class=\"o\">,</span> <span class=\"n\">get_eq</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">List.mem_iff_get.mp</span> <span class=\"n\">h₁</span>\n  <span class=\"n\">use</span> <span class=\"o\">⟨</span><span class=\"n\">i'</span><span class=\"o\">,</span> <span class=\"kd\">by</span>\n    <span class=\"n\">convert</span> <span class=\"n\">i'.isLt</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">IndexList.length</span><span class=\"o\">,</span> <span class=\"n\">Finset.length_sort</span><span class=\"o\">]</span>\n  <span class=\"o\">⟩</span>\n  <span class=\"c1\">-- simp only [IndexList.length] at i -- Uncomment this to fix</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">l.get</span> <span class=\"o\">(</span><span class=\"n\">is₁.sort</span> <span class=\"n\">LE.le</span><span class=\"o\">)[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">get_i_eq_a</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">get_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₂</span> <span class=\"c1\">-- This rw fails</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h₂</span>\n</code></pre></div>",
        "id": 421451227,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1707919400
    },
    {
        "content": "<p>It seems to me like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">l.get</span> <span class=\"o\">(</span><span class=\"n\">is₁.sort</span> <span class=\"n\">LE.le</span><span class=\"o\">)[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">get_i_eq_a</span>\n</code></pre></div>\n<p>is doing something mysterious. Somehow <code>i</code> is changed in a way I can't inspect via the infoview.</p>\n<p>It feels like I should be able to finish the proof (or get close) with<br>\n<code>convert get_i_eq_a</code></p>",
        "id": 421702130,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1708016938
    },
    {
        "content": "<p>I can change the last few lines to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">IndexList.length</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">i</span>\n<span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">getElem</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">get_i_eq_a</span>\n<span class=\"n\">change</span> <span class=\"n\">l</span><span class=\"o\">[(</span><span class=\"n\">Finset.sort</span> <span class=\"n\">LE.le</span> <span class=\"n\">is₁</span><span class=\"o\">)[</span><span class=\"n\">i</span><span class=\"o\">]]</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"n\">at</span> <span class=\"n\">get_i_eq_a</span>\n<span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">get_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">get_i_eq_a</span>\n<span class=\"n\">exact</span> <span class=\"n\">get_i_eq_a</span>\n</code></pre></div>\n<p>In the infoview, the change tactic shows no changes to <code>get_i_eq_a</code>'s type (they're character for character identical), but without that line, the proof doesn't compile.</p>",
        "id": 421706394,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1708018355
    },
    {
        "content": "<p>If you set <code>set_option pp.explicit true</code>, you can see that there are differences in h2. It appears that <code>rw</code> is not able to see through these differences when locating the expression.</p>\n<p>Here are three options:</p>\n<ul>\n<li>Live with needing to unfold <code>IndexList.length</code></li>\n<li>Change <code>IndexList.length</code> from a <code>def</code> to an <code>abbrev</code>, which makes it reducible and in this case makes the <code>rw</code> go through.</li>\n<li>Use <code>erw</code> instead of <code>rw</code>, which is more forceful with reduction when trying to find matches.</li>\n</ul>",
        "id": 421711103,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708020043
    },
    {
        "content": "<p>Another option is figuring out why you have this difference, and somehow getting <code>get_eq</code> to be in the correct form.</p>",
        "id": 421711415,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708020145
    },
    {
        "content": "<p>(The mystery in <code>l.get (is₁.sort LE.le)[i]</code> is that if you change the type of <code>i</code> it causes it to elaborate slightly differently; some implicit arguments get syntactically-different-yet-defeq values.)</p>",
        "id": 421711698,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708020232
    },
    {
        "content": "<p>Thanks for the help! :)</p>\n<p><code>set_option pp.explicit true</code> certainly does show me more, but suddenly it's so much.</p>\n<p>Doing a quick diff on <code>get_i_eq_a</code> and <code>h₂</code> shows they're different for sure. So at least it's no longer a mystery what the <code>change</code> tactic is doing. Though I feel like I came to this solution (change the type) almost by accident, so I'm not confident I could do so again. </p>\n<p>It feels a bit undirected/magical/lucky that the <code>change</code> tactic should elaborate slightly differently in a way that happens to help. Probably the thing to do is to come back around to this when I have a bit more experience under my belt. :)</p>",
        "id": 421719939,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1708023265
    }
]