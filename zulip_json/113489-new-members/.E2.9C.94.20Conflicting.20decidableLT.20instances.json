[
    {
        "content": "<p>I am on 4.8.0-rc1. I am trying to reason about the use of <code>List.minimum</code> with <code>Rat</code>. Here's a simplified example (the theorem is false, but that isn't relevant here):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.List.MinMax</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Rat.Order</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">minX</span> <span class=\"o\">(</span><span class=\"n\">points</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">ℚ</span> <span class=\"bp\">×</span> <span class=\"n\">ℚ</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">points.map</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p.fst</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">minimum.getD</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">points</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">ℚ</span> <span class=\"bp\">×</span> <span class=\"n\">ℚ</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">minX</span> <span class=\"n\">points</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">minX</span><span class=\"o\">]</span>\n  <span class=\"n\">induction</span> <span class=\"n\">points</span>\n  <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">p</span> <span class=\"n\">ps</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">List.minimum_cons</span><span class=\"o\">]</span>\n</code></pre></div>\n<p><a href=\"https://live.lean-lang.org/#code=import%20Mathlib.Data.List.MinMax%0Aimport%20Mathlib.Data.Rat.Order%0A%0Adef%20minX%20(points%20%3A%20List%20(%E2%84%9A%20%C3%97%20%E2%84%9A))%20%3A%20%E2%84%9A%20%3A%3D%0A%20%20(points.map%20%CE%BB%20p%20%3D%3E%20p.fst).minimum.getD%200%0A%0Atheorem%20test%20(points%20%3A%20List%20(%E2%84%9A%20%C3%97%20%E2%84%9A))%20%3A%20minX%20points%20%3D%200%0A%3A%3D%20by%0A%20%20simp%20%5BminX%5D%0A%20%20induction%20points%0A%20%20case%20cons%20p%20ps%20ih%20%3D%3E%0A%20%20%20%20simp%0A%20%20%20%20rw%20%5BList.minimum_cons%5D\">Playground link.</a></p>\n<p>The issue is that <code>rw [List.minimum_cons]</code> is failing because the <code>List.minimum</code> uses <code>Rat.instDecidableLt</code> whereas <code>List.minimum_cons</code> uses <code>instDecidableLt_mathlib</code>. What is the best way to work around this? The only solution I can imagine is defining a new <code>LinearOrder</code> instance for <code>Rat</code> that specifically uses the non-mathlib instance of <code>DecidableLt</code>. But that seems kind of gross.</p>",
        "id": 438130189,
        "sender_full_name": "Will Crichton",
        "timestamp": 1715456864
    },
    {
        "content": "<p>Decidable instances can be annoying to work around. Luckily they're equal to each other, so it's usually possible to handle them somehow.</p>\n<p>The right thing to do would be to fix mathlib (something here is using the wrong Decidable instance), but as a workaround you can use <code>convert</code>, which is like <code>exact</code> but can deal with <code>Decidable</code>, and it leaves goals wherever there are unresolved differences.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">points</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">ℚ</span> <span class=\"bp\">×</span> <span class=\"n\">ℚ</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">minX</span> <span class=\"n\">points</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">minX</span><span class=\"o\">]</span>\n  <span class=\"n\">induction</span> <span class=\"n\">points</span>\n  <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">p</span> <span class=\"n\">ps</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span>\n    <span class=\"c1\">-- ⊢ Option.getD (p.1 :: List.map (fun p ↦ p.1) ps).minimum 0 = 0</span>\n    <span class=\"n\">convert</span> <span class=\"bp\">←</span> <span class=\"n\">congr</span><span class=\"o\">(</span><span class=\"n\">Option.getD</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">List.minimum_cons</span> <span class=\"n\">p.1</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n    <span class=\"c1\">-- ⊢ Option.getD (min (↑p.1) (List.map (fun p ↦ p.1) ps).minimum) 0 = 0</span>\n</code></pre></div>\n<p>The <code>congr</code> is a way to say where you want the rewrite to happen. For whatever reason, you need to specify one of the arguments to <code>List.minimum_cons</code> (I think it's only to lock down a particular type).</p>",
        "id": 438132704,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715459738
    },
    {
        "content": "<p>Fixed in <a href=\"https://github.com/leanprover-community/mathlib4/pull/12827\">#12827</a></p>",
        "id": 438133244,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715460296
    },
    {
        "content": "<p>Ok great. Now I have both a back-up strategy and a direct fix :-) thanks <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> and <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>!</p>",
        "id": 438133389,
        "sender_full_name": "Will Crichton",
        "timestamp": 1715460472
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"625391\">Will Crichton</span> has marked this topic as resolved.</p>",
        "id": 438133442,
        "sender_full_name": "Notification Bot",
        "timestamp": 1715460487
    },
    {
        "content": "<p>Note for posterity: <code>$(...)</code> is sensitive to the direction of the equality, so in my particular case, I had to use <code>Eq.symm</code> to reverse the inequality before <code>convert congr(... $(h_eq) ...)</code> worked correctly.</p>",
        "id": 438151734,
        "sender_full_name": "Will Crichton",
        "timestamp": 1715482897
    },
    {
        "content": "<p>(Note I had <code>←</code> in the <code>convert</code> to reverse part of it, but it's possible you needed to reverse the equality too!)</p>",
        "id": 438151827,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715483009
    },
    {
        "content": "<p>It might be instructive to see just how weird this <code>convert</code> line is by doing <code>convert ... using 0</code> to see what goal it passes to <code>congr!</code>. I'm not sure why I thought it would work in the first place, and I had to do this myself to understand it.</p>",
        "id": 438151879,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715483047
    }
]