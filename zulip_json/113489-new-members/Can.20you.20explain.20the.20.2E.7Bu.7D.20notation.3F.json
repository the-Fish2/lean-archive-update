[
    {
        "content": "<p>I understand that rfl.{u} {Sort u} means you don't have to specify the universe. But I can't really find an explanation of the funny notation \"dot brackets u\". Also u is a natural number but actually isn't because we haven't defined natural numbers. </p>\n<p>Can anyone explain this strange notation in terms of why the notation is written like this?</p>\n<p>By understanding (correct me if I'm wrong) but it means there is one RFL for each type level</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">rfl0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">-&gt;</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">-&gt;</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">=</span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"n\">rfl1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">-&gt;</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">-&gt;</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">=</span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"n\">rfl2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">-&gt;</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">-&gt;</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">=</span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But if that is the case how would I reference, say, rfl2. Is there some way to do this in Lean?</p>\n<p>As an aside. Numbering the Type universes with natural numbers seems a bit chicken-and-egg. <span aria-label=\"hatching\" class=\"emoji emoji-1f423\" role=\"img\" title=\"hatching\">:hatching:</span>I hope there's a better way in Lean 5</p>",
        "id": 447031686,
        "sender_full_name": "Mr Proof",
        "timestamp": 1719363141
    },
    {
        "content": "<p>Universe levels aren't natural numbers</p>",
        "id": 447036782,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719364939
    },
    {
        "content": "<p>You can say rfl.{3} for rfl over Type 2. Because  Type 2 is Sort 3.</p>",
        "id": 447036822,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719364961
    },
    {
        "content": "<p>I don't know what you mean when you say 3 is not a number <span aria-label=\"sob\" class=\"emoji emoji-1f62d\" role=\"img\" title=\"sob\">:sob:</span></p>",
        "id": 447037272,
        "sender_full_name": "Mr Proof",
        "timestamp": 1719365164
    },
    {
        "content": "<p>Universe levels have 0, succ, max, and imax. They do not have recursors. They have different unification rules than naturals. 3 is a literal that stands for succ succ succ 0. \"3 is not a number\", correct, it is notation for something else.</p>",
        "id": 447042729,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719367467
    },
    {
        "content": "<p>First, there are the sorts you can name: Sort 0 (aka Prop), Sort (succ 0) (aka Sort 1, Type 0), Sort (succ (succ 0)) (aka Sort 2, Type 1), etc.  This 0 and succ are totally different from the natural numbers in Lean.  They use the same notation, but then again 0 is used for lots of things in Lean like the unit of an additive group.  But unlike 0 (used in any other context in Lean), universe levels are not elements of a type.  There is no type of universe levels.  You can't put a universe level where a type (or element of a type) would go, and you can't put a type (or element of a type) where a universe level would go.  Lean is just nice to you and lets you write <code>Type 2</code> instead of <code>Type (succ (succ zero))</code>, and <code>Type (u + 3)</code> instead of <code>Type (succ (succ (succ u)))</code>, but internally it is stored more like the later.</p>\n<p>Now, to avoid having a separate <code>refl</code> for each universe level, there is universe polymorphism where we can use <code>Type u</code> or <code>Type (max u v)</code>, etc to specify a universe.  You normally don't need to worry about what universe level you are using since Lean figures it out for you, but you can specify it with <code>foo.{3}</code> or <code>foo.{u}</code> or if there are multiple universe levels used in a theorem, <code>foo.{1, 2}</code>.</p>\n<p>You also can't really prove formally in Lean anything about universe levels (except for proving a theorem with a universe level in it).  Now, it is true that the only explicit universe levels you can construct with the four constructors are 0, 1, 2, 3, ...  But there is really nothing saying that the universe levels are isomorphic to the natural numbers or that there isn't a universe level in between say 2 and 3.  We just know that for a universe level <code>u</code> there is some higher universe level <code>succ u</code>.  For <code>u</code> and <code>v</code> there is some upper bound universe level <code>max u v</code> satisfying say <code>max (succ u) u</code> is the same as <code>succ u</code> and <code>max (max u v) w</code> is the same as <code>max u (max v w)</code>.  (<code>imax u v</code> is the maximum of <code>u</code> and <code>v</code> if <code>v</code> is not 0, and 0 otherwise).  These are just rules built into Lean which Lean uses to check if two universes are compatible.</p>",
        "id": 447047595,
        "sender_full_name": "Jason Rute",
        "timestamp": 1719369537
    },
    {
        "content": "<p>An interesting fact is that since we don't know if there are \"in-between\" universes, we can't say much about the relative cardinalities of the universes <code>Type u</code> and <code>Type (u + 1)</code>.  It is consistent that <code>Type (u + 1)</code> is just a bit larger than <code>Type u</code>.  (I think formally that is saying the cardinality of <code>Type (u + 1)</code> is the next largest inaccessible cardinal.)  It is also consistent that <code>Type (u + 1)</code> is much larger (there are many, even uncountably many, inaccessible cardinals in between).  (<a href=\"https://proofassistants.stackexchange.com/questions/1605/cardinality-of-type-in-a-given-universe\">https://proofassistants.stackexchange.com/questions/1605/cardinality-of-type-in-a-given-universe</a>)</p>",
        "id": 447050504,
        "sender_full_name": "Jason Rute",
        "timestamp": 1719371012
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Level#doc\">docs#Lean.Level</a> does exist, though</p>",
        "id": 447113670,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1719375687
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"725689\">Mr Proof</span> <a href=\"#narrow/stream/113489-new-members/topic/Can.20you.20explain.20the.20.2E.7Bu.7D.20notation.3F/near/447037272\">said</a>:</p>\n<blockquote>\n<p>I don't know what you mean when you say 3 is not a number <span aria-label=\"sob\" class=\"emoji emoji-1f62d\" role=\"img\" title=\"sob\">:sob:</span></p>\n</blockquote>\n<p>This is a bit of a tangent...</p>\n<p>I'm not completely sure, but I believe the type-theory perspective is that the only way to have an element of ℕ is for something to be given to you as such. You can't have a thing and wonder \"Is this thing a ℕ\"? You can have a subtype like <code>{x : ℕ // Even x}</code> after which if you have an ℕ, you can ask something akin to if this is also a <code>{x : ℕ // Even x}</code>.</p>\n<p>Thinking of programming languages like C, without the types <strong>everything</strong> looks just like a binary number. For the non-ML based programming languages, types were invented to deal with the \"everything looks the same\" problem - as it's dangerous to mistake a pointer for a struct or some such..</p>\n<p>I think that's at least one sense in which the universes aren't numbers.</p>\n<p>Of course that's not very convincing because if the definition of ℕ where somehow tied up in the Universe Levels, you may well still wonder if there's some logical fallacy at play - maybe.</p>",
        "id": 447233715,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1719412887
    },
    {
        "content": "<p>I usually think as the <code>3</code> in  <code>Sort 3 </code> as a completely separate object as <code>3 : Nat</code>. Indeed, if you have <code>i : Nat</code>, you cannot write <code>Sort i</code>. The hierarchy of universes is present <em>before</em> giving the definition of natural numbers.</p>",
        "id": 447237029,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1719413802
    }
]