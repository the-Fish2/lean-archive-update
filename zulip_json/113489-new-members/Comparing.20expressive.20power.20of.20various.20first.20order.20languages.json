[
    {
        "content": "<p>Hi All,</p>\n<p>I'm evaluating various theorem proving environments for database theory work. Lean is, naturally, on the list. To assist my selection of a tool, I have a concrete use case which I would be interested in the communities response to.</p>\n<p>I'm curious as to the recommended path in Lean for comparing the expressive power of various first order languages.  I'd like to leverage Lean's native syntax and input methods to the greatest degree.  </p>\n<p>For example one language that is interesting to my project is 'conjunctive queries' from database theory which amongst other restrictions doesn't admit disjunction or negation.   </p>\n<p>One approach might be to start with a meta-programmed implementation of FOL hosted in Lean that mirrors the built-in FOL. Are there other approaches? </p>\n<p>Once we had a hosted FOL, I imagine one could instantiate various restricted versions of the hosted language, as required, then prove theorems both within and about them?</p>\n<p>If this is the recommended approach, is there a standard hosted FOL to start from?</p>\n<p>Thoughts?</p>\n<p>David</p>",
        "id": 446487542,
        "sender_full_name": "David Pratten",
        "timestamp": 1719185657
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"723825\">David Pratten</span> <a href=\"#narrow/stream/113489-new-members/topic/Comparing.20expressive.20power.20of.20various.20first.20order.20languages/near/446487542\">said</a>:</p>\n<blockquote>\n<p>comparing the expressive power of various first order languages.  I'd like to leverage Lean's native syntax and input methods to the greatest degree.</p>\n<p>[...]</p>\n<p>one language that is interesting to my project is 'conjunctive queries'</p>\n</blockquote>\n<p><a href=\"https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html\">Chapter 3 of Theorem Proving in Lean 4</a> starts with a description of <strong>Propositions as Types</strong> that might be enlightening.</p>\n<p>You can probably introduce types that model your desired language and then prove things with/about them. I don't think you'd need any meta-programming, but you can effectively build your logic using all the same tools Lean uses to build FOL (Lean's Prop universe enjoys some compiler support, but I think the support is for speed/ergonomics and not for expressiveness).</p>\n<p>I'm not sure what hurdles you may encounter, but assuming familiarity with Dependent Type Systems, you might be able to get a feel for it yourself in an afternoon or two. If you're not familiar with any system like Lean, Agda, Idris, Coq, etc then there's a bit of a learning curve but it's a fun adventure in my opinion.</p>",
        "id": 446618040,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1719236514
    }
]