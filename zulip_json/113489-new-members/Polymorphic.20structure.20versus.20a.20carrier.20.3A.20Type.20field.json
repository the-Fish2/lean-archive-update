[
    {
        "content": "<p>Hi all,</p>\n<p>I'm working through the coersions section of FP In Lean and the implementation of Monoid has a convention that I wasn't expecting: the definition of the datatype embeds a <code>Carrier : Type</code> field, in contrast to making <code>Monoid</code> polymorphic over some type, e.g.:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Monoid</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">neutral</span><span class=\"o\">:</span> <span class=\"n\">α</span>\n  <span class=\"n\">op</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>Two questions:</p>\n<p>1) Are these equivalent?  I was able to finish the section on monoids with my implementation, so at least for simple cases it appears to be so, but if not, what are situations where my implementation is inexpressive enough to not work?  If they _are_ equivalent, when should I favour polymorphism over embedding a carrier <code>Type</code>?</p>\n<p>2) What are the runtime semantics between the two?  I assume that in my polymorphic version <code>\\alpha</code> is erased at runtime, whereas in the version used in the book, presumably, that isn't the case?  </p>\n<p>(The text later on says, \"putting a type in a field of a structure, similarly to the <code>Monoid</code> example, can make sense in contexts where there is more than one way to implement an operation and more manual control is needed than type classes would allow\"; however, I'm not sure I fully understand this point, but perhaps this is the thing I'm missing?)</p>\n<p>Thanks,<br>\nNathan</p>",
        "id": 425558595,
        "sender_full_name": "Nathan Taylor",
        "timestamp": 1709917759
    },
    {
        "content": "<p>In mathlib, monoids are implemented in a similar way as what you suggest <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Group/Defs.html#Monoid\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Group/Defs.html#Monoid</a><br>\nThe difference is that there is a typeclass system: in mathlib <code>Monoid</code> is not just a structure but a <em>class</em>, given <code>α : Type*</code>, when we have defined an instance of <code>Monoid α</code> (this is related to variables with brackets <code>[Monoid α]</code>), then we can use the definitions of <code>0</code> and <code>+</code> transparently (everything works as if we have endowed <code>α</code> with a monoid structure, e.g. we can write statements like <code>∀ (x y : α), x + y = y + x</code>).</p>\n<p>In mathlib, we also have the other type of definition for the category of monoids. Then, an object in this category is a tuple consisting of type <code>α</code> (the carrier) and the monoid structure on it. <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Category/MonCat/Basic.html#MonCat\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Category/MonCat/Basic.html#MonCat</a> We would usually say that this is the \"bundled\" version of the definition of monoids.</p>\n<p>Depending on what we want to do, both ways are useful and complement each other.</p>",
        "id": 425612238,
        "sender_full_name": "Joël Riou",
        "timestamp": 1709934348
    }
]