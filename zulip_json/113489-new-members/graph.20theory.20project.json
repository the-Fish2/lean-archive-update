[
    {
        "content": "<p>Hi! The coming months I will be working on a project where I am looking to formalize some graph theory proofs in Lean. Currently, I am still getting to know the Lean language by looking at the existing <a href=\"https://github.com/leanprover-community/mathlib4/tree/02b189d7395fbce49adae521a92e5dbc33997f84/Mathlib/Combinatorics/SimpleGraph\">SimpleGraph directory</a> in Mathlib. Some of these are quite intimidating, so it would really help me if someone could answer some of my questions. Should I start a conversation for my project in <a class=\"stream\" data-stream-id=\"252551\" href=\"/#narrow/stream/252551-graph-theory\">#graph theory</a> ?</p>",
        "id": 431317069,
        "sender_full_name": "Lode Vermeulen",
        "timestamp": 1712238330
    },
    {
        "content": "<p>I think that a new stream for each question in <a class=\"stream\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members\">#new members</a>  is probably better.</p>",
        "id": 431317405,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712238412
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/graph.20theory.20project/near/431317405\">said</a>:</p>\n<blockquote>\n<p>I think that a new stream for each question in <a class=\"stream\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members\">#new members</a>  is probably better.</p>\n</blockquote>\n<p>In that case, I have a question about the first lemma I am working on, about the union of 2 perfect matchings being a disjoint union of cycles. I have the formalization, but I am getting stuck on trying to show that the resulting graph is 2-regular. Also, I am not sure how I would then translate this into it being a cycle.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> Two disjoint perfect matchings -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">IsDisjointPerfectMatchingPair</span> <span class=\"o\">(</span><span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">M₁.IsPerfectMatching</span> <span class=\"bp\">∧</span> <span class=\"n\">M₂.IsPerfectMatching</span> <span class=\"bp\">∧</span> <span class=\"n\">M₁.edgeSet</span> <span class=\"bp\">∩</span> <span class=\"n\">M₂.edgeSet</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> A graph with exclusively disjoint perfect matchings -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">IsExclusivelyDisjointPMGraph</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">IsDisjointPerfectMatchingPair</span> <span class=\"n\">M₁</span> <span class=\"n\">M₂</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> A graph that consists of a disjoint union of cycles -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">IsCyclic</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.Walk</span> <span class=\"n\">v</span> <span class=\"n\">v</span><span class=\"o\">),</span> <span class=\"n\">c.IsCycle</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Two disjoint PMs form a union of cycles -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">disjoint_PMs_form_union_of_cycles</span> <span class=\"o\">(</span><span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">IsDisjointPerfectMatchingPair</span> <span class=\"n\">M₁</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">IsExclusivelyDisjointPMGraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">IsCyclic</span> <span class=\"o\">(</span><span class=\"n\">fromEdgeSet</span> <span class=\"o\">(</span><span class=\"n\">M₁.edgeSet</span> <span class=\"bp\">∪</span> <span class=\"n\">M₂.edgeSet</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"k\">have</span> <span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">G.IsRegularOfDegree</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 431323297,
        "sender_full_name": "Lode Vermeulen",
        "timestamp": 1712240048
    },
    {
        "content": "<p>Note you could define</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">IsDisjointPerfectMatchingPair</span> <span class=\"o\">(</span><span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">M₁.IsPerfectMatching</span> <span class=\"bp\">∧</span> <span class=\"n\">M₂.IsPerfectMatching</span> <span class=\"bp\">∧</span> <span class=\"n\">Disjoint</span> <span class=\"n\">M₁</span> <span class=\"n\">M₂</span>\n</code></pre></div>",
        "id": 431352453,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1712247387
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">IsExclusivelyDisjointPMGraph</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">IsDisjointPerfectMatchingPair</span> <span class=\"n\">M₁</span> <span class=\"n\">M₂</span>\n</code></pre></div>\n<p>is (almost) always false since</p>\n<ol>\n<li>Most simple graphs have subgraphs which are not perfect matchings (eg the empty subgraph)</li>\n<li>You don't forbid <code>M₁ = M₂</code></li>\n</ol>",
        "id": 431352898,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1712247513
    },
    {
        "content": "<p>What you want is something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">IsExclusivelyDisjointPMGraph</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">M.IsPerfectMatching</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">PairwiseDisjoint</span> <span class=\"n\">id</span>\n</code></pre></div>",
        "id": 431353087,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1712247565
    },
    {
        "content": "<p><del>If you want to write the condition that the graph <code>G</code> is the union of the two disjoint perfect matchings <code>M₁ M₂ : Subgraph G</code>, that would be <code>M₁.IsPerfectMatching ∧ M₂.IsPerfectMatching ∧ IsCompl M₁ M₂</code>. (See <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsCompl#doc\">docs#IsCompl</a>.) It might not be worth introducing a new definition for that.</del></p>",
        "id": 431408460,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712267532
    },
    {
        "content": "<p><del>(Of course, you should use three separate hypotheses of types <code>M₁.IsPerfectMatching</code>, <code>M₂.IsPerfectMatching</code>, and <code>IsCompl M₁ M₂</code> rather than one hypothesis of type <code>M₁.IsPerfectMatching ∧ M₂.IsPerfectMatching ∧ IsCompl M₁ M₂</code>.)</del></p>",
        "id": 431409222,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712267851
    },
    {
        "content": "<p>I think your definition of <code>IsCyclic</code> is wrong.  It states that every walk from a vertex to itself is a cycle. This isn't possible if the graph has any edges, because you can walk back and forth along that edge several times.</p>",
        "id": 431409650,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712268018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/graph.20theory.20project/near/431352453\">said</a>:</p>\n<blockquote>\n<p>Note you could define</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">IsDisjointPerfectMatchingPair</span> <span class=\"o\">(</span><span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">M₁.IsPerfectMatching</span> <span class=\"bp\">∧</span> <span class=\"n\">M₂.IsPerfectMatching</span> <span class=\"bp\">∧</span> <span class=\"n\">Disjoint</span> <span class=\"n\">M₁</span> <span class=\"n\">M₂</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Unfortunately, for <code>M₁ M₂ : Subgraph G</code>,  I think that <code>Disjoint M₁ M₂</code> means that <code>M₁</code> and <code>M₂</code> don't share any vertices, not that they don't share any edges. So this isn't what you want.</p>\n<p>(In a perfect world, you could get around this problem by taking <code>M₁</code> and <code>M₂</code> to be of type <code>SimpleGraph V</code> instead. Then <code>Disjoint M₁ M₂</code> would mean that <code>M₁</code> and <code>M₂</code> don't share any edges. But then you wouldn't have <code>IsMatching</code> or <code>IsPerfectMatching</code>. I think it would be nice to be able to use <code>IsMatching</code> on <code>SimpleGraph V</code> in addition to <code>Subgraph G</code>. See <a href=\"https://github.com/leanprover-community/mathlib4/pull/11911\">#11911</a>.)</p>\n<p>For now, you can use <code>M₁.edgeSet ∩ M₂.edgeSet = ∅</code> or <code>Disjoint M₁.edgeSet M₂.edgeSet</code>.</p>",
        "id": 431412224,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712269278
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/graph.20theory.20project/near/431352898\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">IsExclusivelyDisjointPMGraph</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">IsDisjointPerfectMatchingPair</span> <span class=\"n\">M₁</span> <span class=\"n\">M₂</span>\n</code></pre></div>\n<p>is (almost) always false since</p>\n<ol>\n<li>Most simple graphs have subgraphs which are not perfect matchings (eg the empty subgraph)</li>\n<li>You don't forbid <code>M₁ = M₂</code></li>\n</ol>\n</blockquote>\n<p>I see, thanks for the correction</p>",
        "id": 431509960,
        "sender_full_name": "Lode Vermeulen",
        "timestamp": 1712318801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"695266\">Mitchell Lee</span> <a href=\"#narrow/stream/113489-new-members/topic/graph.20theory.20project/near/431409650\">said</a>:</p>\n<blockquote>\n<p>I think your definition of <code>IsCyclic</code> is wrong.  It states that every walk from a vertex to itself is a cycle. This isn't possible if the graph has any edges, because you can walk back and forth along that edge several times.</p>\n</blockquote>\n<p>Right, that makes sense. I have adjusted it to impose that the walk should be a trail first:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> A graph that consists of a disjoint union of cycles -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">IsCyclic</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">G.Walk</span> <span class=\"n\">v</span> <span class=\"n\">v</span><span class=\"o\">),</span> <span class=\"n\">w.IsTrail</span> <span class=\"bp\">→</span> <span class=\"n\">w.IsCycle</span>\n</code></pre></div>",
        "id": 431510248,
        "sender_full_name": "Lode Vermeulen",
        "timestamp": 1712318917
    },
    {
        "content": "<p>How I see it then, is that I have to show the following statements:</p>\n<ol>\n<li>That a trail exists</li>\n<li>The trail is nonempty</li>\n<li>The trail starts and ends at the same vertex.</li>\n<li>The only repeating vertex is the first one.<br>\nBecause point 2, 3 and 4 are the only differences between a trail and a cycle.</li>\n</ol>\n<p>Does anyone know of any examples I can use in order to show these points?</p>",
        "id": 431511320,
        "sender_full_name": "Lode Vermeulen",
        "timestamp": 1712319295
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690587\">Lode Vermeulen</span> <a href=\"#narrow/stream/113489-new-members/topic/graph.20theory.20project/near/431510248\">said</a>:</p>\n<blockquote>\n<p>I have adjusted it to impose that the walk should be a trail first:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> A graph that consists of a disjoint union of cycles -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">IsCyclic</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">G.Walk</span> <span class=\"n\">v</span> <span class=\"n\">v</span><span class=\"o\">),</span> <span class=\"n\">w.IsTrail</span> <span class=\"bp\">→</span> <span class=\"n\">w.IsCycle</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>You also need to assume <code>w ≠ nil</code>. <code>nil</code> is a trail but not a cycle.</p>",
        "id": 431512455,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1712319711
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/graph.20theory.20project/near/431512455\">said</a>:</p>\n<blockquote>\n<p><code>≠ nil</code></p>\n</blockquote>\n<p>That makes sense. I guess that also removes one thing that needs to be shown from the lemma. Is there any way you could show me how to start proving this? I have tried looking at a bunch of similar Lean code, but I can't find a way to attack this.</p>",
        "id": 431516711,
        "sender_full_name": "Lode Vermeulen",
        "timestamp": 1712321198
    },
    {
        "content": "<p>Can you please provide an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>? I couldn't figure out what <code>import</code>s, <code>open</code>s, <code>variable</code>s, etc. you're using.</p>",
        "id": 431517840,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1712321575
    },
    {
        "content": "<p>Sorry, I don't have much time right now, but I will remark three more things</p>\n<ul>\n<li><code>fromEdgeSet (M₁.edgeSet ∪ M₂.edgeSet)</code> is just <code>M₁ ⊔ M₂</code></li>\n<li><code>IsCyclic</code> is still wrongly stated because it currently allows vertices that don't lie on any cycle. I believe what you want is</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">IsCyclic</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">⦄,</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">G.Walk</span> <span class=\"n\">v</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span> <span class=\"bp\">≠</span> <span class=\"n\">nil</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">G.Walk</span> <span class=\"n\">v</span> <span class=\"n\">v</span><span class=\"o\">),</span> <span class=\"n\">w.IsTrail</span> <span class=\"bp\">→</span> <span class=\"n\">w.IsCycle</span>\n</code></pre></div>\n<ul>\n<li>Your theorem is wrong because you haven't assumed <code>V</code> is finite. Without that assumption, you can at least prove that <code>M₁ ⊔ M₂</code> is a disjoint union of cycles/two-sided infinite paths.</li>\n</ul>",
        "id": 431518321,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1712321730
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"580947\">Rida Hamadani</span> <a href=\"#narrow/stream/113489-new-members/topic/graph.20theory.20project/near/431517840\">said</a>:</p>\n<blockquote>\n<p>Can you please provide an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>? I couldn't figure out what <code>import</code>s, <code>open</code>s, <code>variable</code>s, etc. you're using.</p>\n</blockquote>\n<p>Yes, my apologies, <a href=\"https://live.lean-lang.org/#code=import%20Mathlib.Combinatorics.SimpleGraph.Subgraph%0D%0Aimport%20Mathlib.Combinatorics.SimpleGraph.Matching%0D%0Aimport%20Mathlib.Combinatorics.SimpleGraph.Acyclic%0D%0A%0D%0Auniverse%20u%0D%0A%0D%0Anamespace%20SimpleGraph%0D%0A%0D%0Avariable%20%7BV%20%3A%20Type%20u%7D%20%7BG%20%3A%20SimpleGraph%20V%7D%0D%0Avariable%20%5BLocallyFinite%20G%5D%0D%0A%0D%0Anamespace%20Subgraph%0D%0A%0D%0A%2F-%20Two%20disjoint%20perfect%20matchings%20-%2F%0D%0Adef%20IsDisjointPerfectMatchingPair%20(M%E2%82%81%20M%E2%82%82%20%3A%20Subgraph%20G)%20%3A%20Prop%20%3A%3D%0D%0AM%E2%82%81.IsPerfectMatching%20%E2%88%A7%20M%E2%82%82.IsPerfectMatching%20%E2%88%A7%20Disjoint%20M%E2%82%81.edgeSet%20M%E2%82%82.edgeSet%0D%0A%0D%0A%2F-%20A%20graph%20with%20exclusively%20disjoint%20perfect%20matchings%20-%2F%0D%0Adef%20IsExclusivelyDisjointPMGraph%20(G%20%3A%20SimpleGraph%20V)%20%3A%20Prop%20%3A%3D%0D%0A%7BM%20%3A%20Subgraph%20G%20%7C%20M.IsPerfectMatching%7D.PairwiseDisjoint%20id%0D%0A%0D%0A%2F-%20A%20graph%20that%20consists%20of%20a%20disjoint%20union%20of%20cycles%20-%2F%0D%0Adef%20IsCyclic%20(G%20%3A%20SimpleGraph%20V)%20%3A%20Prop%20%3A%3D%0D%0A%E2%88%80%20%E2%A6%83v%20%3A%20V%E2%A6%84%20(w%20%3A%20G.Walk%20v%20v)%2C%20w%20%E2%89%A0%20Walk.nil%20%E2%88%A7%20w.IsTrail%20%E2%86%92%20w.IsCycle%0D%0A%0D%0A%2F-%20Two%20disjoint%20PMs%20form%20a%20union%20of%20cycles%20-%2F%0D%0Alemma%20disjoint_PMs_form_union_of_cycles%20(M%E2%82%81%20M%E2%82%82%20%3A%20Subgraph%20G)%0D%0A(hm%20%3A%20IsDisjointPerfectMatchingPair%20M%E2%82%81%20M%E2%82%82)%20%3A%0D%0AIsCyclic%20(fromEdgeSet%20(M%E2%82%81.edgeSet%20%E2%88%AA%20M%E2%82%82.edgeSet))%20%3A%3D%20by%0D%0A%20%20sorry\">here</a> is an instance of the lean web editor with all my code so far.</p>",
        "id": 431519106,
        "sender_full_name": "Lode Vermeulen",
        "timestamp": 1712321986
    },
    {
        "content": "<p>The first thing that would come to mind is a plan like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">disjoint_PMs_form_union_of_cycles</span> <span class=\"o\">(</span><span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">IsDisjointPerfectMatchingPair</span> <span class=\"n\">M₁</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsCyclic</span> <span class=\"o\">(</span><span class=\"n\">fromEdgeSet</span> <span class=\"o\">(</span><span class=\"n\">M₁.edgeSet</span> <span class=\"bp\">∪</span> <span class=\"n\">M₂.edgeSet</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">hm</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hm</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">isPerfectMatching_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hm</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">hw</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hm</span> <span class=\"n\">v</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Now you have to find a way to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Adj.toWalk#doc\">docs#SimpleGraph.Adj.toWalk</a> with <code>hw</code> to construct the walk, and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Adj.ne#doc\">docs#SimpleGraph.Adj.ne</a>  to get <code>v ≠ w</code>, and finishing the first goal with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Walk.not_nil_of_ne#doc\">docs#SimpleGraph.Walk.not_nil_of_ne</a>.</p>\n<p>P.S. I'm using <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>'s definition of IsCyclic, but I couldn't replace <code>fromEdgeSet (M₁.edgeSet ∪ M₂.edgeSet)</code> with <code>M₁ ⊔ M₂</code>.</p>",
        "id": 431537001,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1712327598
    },
    {
        "content": "<p>I couldn't really figure out how to apply <code>SimpleGraph</code> theorems to <code>Subgraph</code>, I suppose there should be an easy way to do that?<br>\nAlso by the way, in your link, you can remove <code>import Mathlib.Combinatorics.SimpleGraph.Subgraph</code>, since it is already included in <code>SimpleGraph.Matching</code>.</p>",
        "id": 431537803,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1712327831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"580947\">Rida Hamadani</span> <a href=\"#narrow/stream/113489-new-members/topic/graph.20theory.20project/near/431537001\">said</a>:</p>\n<blockquote>\n<p>I couldn't replace <code>fromEdgeSet (M₁.edgeSet ∪ M₂.edgeSet)</code> with <code>M₁ ⊔ M₂</code>.</p>\n</blockquote>\n<p>Hint: You want to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.fromEdgeSet_sup#doc\">docs#SimpleGraph.fromEdgeSet_sup</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.fromEdgeSet_edgeSet#doc\">docs#SimpleGraph.fromEdgeSet_edgeSet</a> and some glue between <code>SimpleGraph.edgeSet</code> and <code>SimpleGraph.Subgraph.edgeSet</code></p>",
        "id": 431542796,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1712328462
    },
    {
        "content": "<p>Hi, I think that <code>[LocallyFinite G]</code> isn't enough; the vertex set <code>V</code> actually needs to be finite.</p>",
        "id": 431592328,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712345904
    },
    {
        "content": "<p>Another note: the definition of <code>IsCyclic G</code> you have is now equivalent to the statement that <code>G</code> is a disjoint union of cycles. However, you said that your goal is to prove that <code>G</code> is a disjoint union of cycles, not just to prove that <code>G</code> has a property that's equivalent to being a disjoint union of cycles. (After all, if you just wanted to do the latter, you could stop at proving that <code>G</code> is regular of degree 2.)</p>\n<p>Here's one way of expressing it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> The graph `G` is a disjoint union of cycles -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">IsDisjointUnionOfCycles</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"c1\">-- There exists a set `P` of subgraphs of `G`, such that:</span>\n    <span class=\"n\">P.Pairwise</span> <span class=\"n\">Disjoint</span> <span class=\"c1\">-- The subgraphs are pairwise disjoint,</span>\n    <span class=\"bp\">∧</span> <span class=\"n\">sSup</span> <span class=\"n\">P</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"c1\">-- The union of all of the subgraphs is the whole graph, and</span>\n    <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">H</span> <span class=\"bp\">∈</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.Walk</span> <span class=\"n\">v</span> <span class=\"n\">v</span><span class=\"o\">),</span> <span class=\"n\">c.IsCycle</span> <span class=\"bp\">∧</span> <span class=\"n\">H</span> <span class=\"bp\">=</span> <span class=\"n\">c.toSubgraph</span> <span class=\"c\">/-</span><span class=\"cm\"> every subgraph `H ∈ P`</span>\n<span class=\"cm\">      consists of the vertices and edges of some cycle of `G`. -/</span>\n</code></pre></div>\n<p>Another way to express this, which is less direct but probably easier for proofs, is to state that the induced subgraph on each connected component of <code>G</code> consists of the vertices and edges of a cycle of <code>G</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> The graph `G` is a disjoint union of cycles -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">IsDisjointUnionOfCycles'</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">G.ConnectedComponent</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.Walk</span> <span class=\"n\">v</span> <span class=\"n\">v</span><span class=\"o\">),</span> <span class=\"n\">c.IsCycle</span> <span class=\"bp\">∧</span> <span class=\"n\">Subgraph.induce</span> <span class=\"bp\">⊤</span> <span class=\"n\">H</span> <span class=\"bp\">=</span> <span class=\"n\">c.toSubgraph</span>\n</code></pre></div>",
        "id": 431599294,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712348895
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"580947\">Rida Hamadani</span> <a href=\"#narrow/stream/113489-new-members/topic/graph.20theory.20project/near/431537001\">said</a>:</p>\n<blockquote>\n<p>The first thing that would come to mind is a plan like this:...</p>\n</blockquote>\n<p>Thanks a lot for this start! This helps a lot with my understanding of Lean as well <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> . After playing around with the code, I do have a some questions which I hope you could speak to and which would help me with understanding basic proofs in Lean:</p>\n<ol>\n<li>The proof starts with a lambda function. Is this just to address that the following should hold for every <code>v</code>?</li>\n<li>The documentation of <code>refine</code> states that it behaves like <code>exact</code>. In my experience, the <code>exact</code> tactic solves a goal if the types match. From what I can tell in this example, refine splits the goal into two subgoals. Furthermore, the <code>⟨⟩</code> brackets stand for pattern matching right? Which in this case is done without assigning a name, hence the anonymous 'dot notation'?</li>\n<li>The <code>obtain</code> tactic seems to be used as a destructuring function in this example. Especially the second time it is used is confusing to me. Here, we somehow get <code>hw: M₁.Adj v w</code> from <code>hm</code>, which states that that <strong>shouldn't</strong> exist.</li>\n<li>To address the first <code>sorry</code>, I tried, as you suggested, applying <code>Adj.toWalk hw</code>. From looking at the code for <code>Adj.toWalk</code>, this should work, as it is expecting an argument of type <code>G.Adj u v</code>, but it throws the error <code>argument hw has type M₁.Adj v w : Prop but is expected to have type ?m.671.Adj ?m.672 ?m.673 : Prop</code>. The only difference seems like <code>M₁</code> is a SubGraph, but I am not sure whether this is the problem.</li>\n<li>To try to address the second sorry, I tried <code>fun w =&gt;</code>, but Lean says it is expecting a tactic. Do I not have to loop over all walks, like we also do with <code>v</code>?</li>\n</ol>",
        "id": 431995433,
        "sender_full_name": "Lode Vermeulen",
        "timestamp": 1712588946
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/graph.20theory.20project/near/431542796\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"580947\">Rida Hamadani</span> <a href=\"#narrow/stream/113489-new-members/topic/graph.20theory.20project/near/431537001\">said</a>:</p>\n<blockquote>\n<p>I couldn't replace <code>fromEdgeSet (M₁.edgeSet ∪ M₂.edgeSet)</code> with <code>M₁ ⊔ M₂</code>.</p>\n</blockquote>\n<p>Hint: You want to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.fromEdgeSet_sup#doc\">docs#SimpleGraph.fromEdgeSet_sup</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.fromEdgeSet_edgeSet#doc\">docs#SimpleGraph.fromEdgeSet_edgeSet</a> and some glue between <code>SimpleGraph.edgeSet</code> and <code>SimpleGraph.Subgraph.edgeSet</code></p>\n</blockquote>\n<p>Is there a benefit of using <code>⊔</code> over <code>∪</code>? It seems quite a hassle at this point, and, in my opinion, is little less readable.</p>",
        "id": 431995600,
        "sender_full_name": "Lode Vermeulen",
        "timestamp": 1712588982
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"695266\">Mitchell Lee</span> <a href=\"#narrow/stream/113489-new-members/topic/graph.20theory.20project/near/431599294\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> The graph `G` is a disjoint union of cycles -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">IsDisjointUnionOfCycles</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"c1\">-- There exists a set `P` of subgraphs of `G`, such that:</span>\n    <span class=\"n\">P.Pairwise</span> <span class=\"n\">Disjoint</span> <span class=\"c1\">-- The subgraphs are pairwise disjoint,</span>\n    <span class=\"bp\">∧</span> <span class=\"n\">sSup</span> <span class=\"n\">P</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"c1\">-- The union of all of the subgraphs is the whole graph, and</span>\n    <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">H</span> <span class=\"bp\">∈</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.Walk</span> <span class=\"n\">v</span> <span class=\"n\">v</span><span class=\"o\">),</span> <span class=\"n\">c.IsCycle</span> <span class=\"bp\">∧</span> <span class=\"n\">H</span> <span class=\"bp\">=</span> <span class=\"n\">c.toSubgraph</span> <span class=\"c\">/-</span><span class=\"cm\"> every subgraph `H ∈ P`</span>\n<span class=\"cm\">      consists of the vertices and edges of some cycle of `G`. -/</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thank you, this looks like a really robust way to define it! It might be beneficial to use this in the long run as well, as I intent to show the matchings form a Hamiltonian cycle when the graph is <code>IsExclusivelyDisjointPMGraph</code> (which I hope could then be as simple as proving <code>Card P = 1</code>).</p>",
        "id": 431995950,
        "sender_full_name": "Lode Vermeulen",
        "timestamp": 1712589037
    },
    {
        "content": "<p>What do you mean by <code>IsExclusivelyDisjointPMGraph</code>?</p>",
        "id": 432002770,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712590386
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"695266\">Mitchell Lee</span> <a href=\"#narrow/stream/113489-new-members/topic/graph.20theory.20project/near/432002770\">said</a>:</p>\n<blockquote>\n<p>What do you mean by <code>IsExclusivelyDisjointPMGraph</code>?</p>\n</blockquote>\n<p>It is defined at the top of this thread (note Yaël's correction as well).</p>",
        "id": 432003288,
        "sender_full_name": "Lode Vermeulen",
        "timestamp": 1712590518
    },
    {
        "content": "<p>Can you describe it without using code? Currently the definition is expressing a property that's equivalent to the graph having at most one perfect matching. But I am not sure whether this is what you want because I can't figure out what \"A graph with exclusively disjoint perfect matchings\" means.</p>",
        "id": 432004539,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712590848
    },
    {
        "content": "<p>Maybe the code is not right, but it is supposed to represent the property that a graph has <strong>only</strong> disjoint perfect matchings. So a graph with 2 disjoint PMs and no other (non-disjoint) PMs would satisfy this property.</p>",
        "id": 432005656,
        "sender_full_name": "Lode Vermeulen",
        "timestamp": 1712591086
    },
    {
        "content": "<p>I see. That shouldn't be necessary as a hypothesis of your theorem <code>disjoint_PMs_form_union_of_cycles</code>.</p>",
        "id": 432008755,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712591747
    },
    {
        "content": "<p>Also, please see this MathOverflow page: <a href=\"https://mathoverflow.net/questions/267002/graphs-with-only-disjoint-perfect-matchings\">https://mathoverflow.net/questions/267002/graphs-with-only-disjoint-perfect-matchings</a></p>",
        "id": 432008944,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712591776
    },
    {
        "content": "<p>Haha, this is actually the post which my project is based upon. See the following document where I worked out the math more formally.<a href=\"/user_uploads/3121/smmuWVubUHD0JacYciqS7n3k/Bogdanov_s_lemma.pdf\">Bogdanov_s_lemma.pdf</a></p>",
        "id": 432010192,
        "sender_full_name": "Lode Vermeulen",
        "timestamp": 1712592012
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690587\">Lode Vermeulen</span> <a href=\"#narrow/stream/113489-new-members/topic/graph.20theory.20project/near/431995433\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"580947\">Rida Hamadani</span> <a href=\"#narrow/stream/113489-new-members/topic/graph.20theory.20project/near/431537001\">said</a>:</p>\n<blockquote>\n<p>The first thing that would come to mind is a plan like this:...</p>\n</blockquote>\n<p>Thanks a lot for this start! This helps a lot with my understanding of Lean as well <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> . After playing around with the code, I do have a some questions which I hope you could speak to and which would help me with understanding basic proofs in Lean:</p>\n<ol>\n<li>The proof starts with a lambda function. Is this just to address that the following should hold for every <code>v</code>?</li>\n<li>The documentation of <code>refine</code> states that it behaves like <code>exact</code>. In my experience, the <code>exact</code> tactic solves a goal if the types match. From what I can tell in this example, refine splits the goal into two subgoals. Furthermore, the <code>⟨⟩</code> brackets stand for pattern matching right? Which in this case is done without assigning a name, hence the anonymous 'dot notation'?</li>\n<li>The <code>obtain</code> tactic seems to be used as a destructuring function in this example. Especially the second time it is used is confusing to me. Here, we somehow get <code>hw: M₁.Adj v w</code> from <code>hm</code>, which states that that <strong>shouldn't</strong> exist.</li>\n<li>To address the first <code>sorry</code>, I tried, as you suggested, applying <code>Adj.toWalk hw</code>. From looking at the code for <code>Adj.toWalk</code>, this should work, as it is expecting an argument of type <code>G.Adj u v</code>, but it throws the error <code>argument hw has type M₁.Adj v w : Prop but is expected to have type ?m.671.Adj ?m.672 ?m.673 : Prop</code>. The only difference seems like <code>M₁</code> is a SubGraph, but I am not sure whether this is the problem.</li>\n<li>To try to address the second sorry, I tried <code>fun w =&gt;</code>, but Lean says it is expecting a tactic. Do I not have to loop over all walks, like we also do with <code>v</code>?</li>\n</ol>\n</blockquote>\n<p>Bumping this because it might have gotten buried.</p>",
        "id": 432244727,
        "sender_full_name": "Lode Vermeulen",
        "timestamp": 1712670103
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690587\">Lode Vermeulen</span> <a href=\"#narrow/stream/113489-new-members/topic/graph.20theory.20project/near/432244727\">said</a>:</p>\n<blockquote>\n<p>Bumping this because it might have gotten buried.</p>\n</blockquote>\n<p>I've been away from my computer, I'll try to reply tonight, sorry for the late response.</p>",
        "id": 432248156,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1712670842
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"580947\">Rida Hamadani</span> <a href=\"#narrow/stream/113489-new-members/topic/graph.20theory.20project/near/432248156\">said</a>:</p>\n<blockquote>\n<p>I've been away from my computer, I'll try to reply tonight, sorry for the late response.</p>\n</blockquote>\n<p>That is completely fine, no rush, I was just worried that it had gotten buried.</p>",
        "id": 432248996,
        "sender_full_name": "Lode Vermeulen",
        "timestamp": 1712671006
    },
    {
        "content": "<p>I'm just starting out too! I'm sure you'll get more detailed answers still.</p>\n<p>Re: question 1. I think you have it right.<br>\nConsider that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">λ</span><span class=\"n\">v</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>Is very similar to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">v</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>Function abstraction is the term-level way to introduce an assumption or hypothesis, so you can use a tactic like intro, or just use function abstraction directly.</p>\n<hr>\n<p>If the term introduced is part of a dependent type, then you sometimes say that what follows holds <code>∀ v</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span> <span class=\"n\">h</span>\n  <span class=\"n\">linarith</span>\n\n<span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">h</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span>\n\n<span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span> <span class=\"n\">h</span>\n  <span class=\"n\">linarith</span>\n\n<span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">h</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span>\n</code></pre></div>\n<p>though in cases like this, it's probably more common to see <code>n</code> and <code>h</code> as parameters already:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span>\n</code></pre></div>",
        "id": 432321509,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1712690315
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690587\">Lode Vermeulen</span> <a href=\"#narrow/stream/113489-new-members/topic/graph.20theory.20project/near/431995433\">said</a>:</p>\n<blockquote>\n<p>I do have a some questions:</p>\n</blockquote>\n<ol>\n<li>Yes.</li>\n<li>Yes, but I'm not sure about assigning names, never saw it in action.  A quick test shows that you can assign a name and use dots anyways.</li>\n<li>Yes. I think you confused \"shouldn't exist\" with \"there exists a unique\", because in programming languages <code>!</code> stands for negation, but in math <code>∃!</code>stands for existence with uniqueness.</li>\n<li>You can use <code>have hvw : G.Adj v w := hw.adj_sub</code> to get <code>G.Adj v w</code>, however I've noticed now that my plan was wrong, because the walk that you need to show is not <code>nil</code> must be of the type <code>w : Walk (fromEdgeSet (edgeSet M₁ ∪ edgeSet M₂)) v v</code>. I didn't notice this at first.</li>\n<li>Lean has a \"term mode\", and a \"tactic mode\". <code>fun w =&gt;</code> is a term, while <code>intro w</code> is a tactic.</li>\n</ol>\n<p>Note that there was a job posting here years ago for formalizing what you are working on, check <a href=\"#narrow/stream/284757-job-postings/topic/200hours.20to.20work.20on.20Quantum.20Physics.20in.20Lean.20via.20Graph.20Theory/near/258886241\">this</a>, so I wonder if anybody ended up taking the offer and formalizing this.</p>",
        "id": 432355384,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1712703191
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"580947\">Rida Hamadani</span> <a href=\"#narrow/stream/113489-new-members/topic/graph.20theory.20project/near/432355384\">said</a>:</p>\n<blockquote>\n<p>Note that there was a job posting here years ago for formalizing what you are working on, check <a href=\"#narrow/stream/284757-job-postings/topic/200hours.20to.20work.20on.20Quantum.20Physics.20in.20Lean.20via.20Graph.20Theory/near/258886241\">this</a>, so I wonder if anybody ended up taking the offer and formalizing this.</p>\n</blockquote>\n<p>Indeed <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> with help of <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> worked on this when i posted it. Time ran out at the time (mainly due to time-constraints of the fundings from my side), and it was not finished. But i shared all of the codes from that time with Lode.</p>",
        "id": 432460863,
        "sender_full_name": "Mario Krenn",
        "timestamp": 1712741598
    },
    {
        "content": "<p>The biggest issue was that mathlib didn't have a proper notion of multigraphs at the time, so I worked a lot on figuring this out but nothing ended up in mathlib</p>",
        "id": 432653438,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1712824387
    },
    {
        "content": "<p>I think having multigraphs in mathlib would be neat, what are the challenges of porting them?</p>",
        "id": 432653695,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1712824473
    },
    {
        "content": "<p>I think having multigraphs in mathlib would be neat, what are the challenges of porting them?<br>\n(This message got double sent for some weird reason, sorry!)</p>",
        "id": 432653726,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1712824487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"580947\">Rida Hamadani</span> <a href=\"#narrow/stream/113489-new-members/topic/graph.20theory.20project/near/432355384\">said</a>:</p>\n<blockquote>\n<ol>\n<li>Yes....</li>\n</ol>\n</blockquote>\n<p>Thanks a lot for these insights, they are really useful!</p>",
        "id": 432901667,
        "sender_full_name": "Lode Vermeulen",
        "timestamp": 1712927683
    },
    {
        "content": "<p>As the previous approach did not really work out, I have been looking into proving the lemma using the following definition:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"695266\">Mitchell Lee</span> <a href=\"#narrow/stream/113489-new-members/topic/graph.20theory.20project/near/431599294\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> The graph `G` is a disjoint union of cycles -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">IsDisjointUnionOfCycles</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Subgraph</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"c1\">-- There exists a set `P` of subgraphs of `G`, such that:</span>\n    <span class=\"n\">P.Pairwise</span> <span class=\"n\">Disjoint</span> <span class=\"c1\">-- The subgraphs are pairwise disjoint,</span>\n    <span class=\"bp\">∧</span> <span class=\"n\">sSup</span> <span class=\"n\">P</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"c1\">-- The union of all of the subgraphs is the whole graph, and</span>\n    <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">H</span> <span class=\"bp\">∈</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G.Walk</span> <span class=\"n\">v</span> <span class=\"n\">v</span><span class=\"o\">),</span> <span class=\"n\">c.IsCycle</span> <span class=\"bp\">∧</span> <span class=\"n\">H</span> <span class=\"bp\">=</span> <span class=\"n\">c.toSubgraph</span> <span class=\"c\">/-</span><span class=\"cm\"> every subgraph `H ∈ P`</span>\n<span class=\"cm\">      consists of the vertices and edges of some cycle of `G`. -/</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>The first step of proving that a graph complies to this definition seems to me to be the most important. Constructing a set of subgraphs by alternating the edges added to a subgraph between the two PMs would naturally mean the subgraphs are disjoint and cycles.</p>\n<p>See this document as well for more info about constructing these subgraphs (Lemma 3.2):<br>\n<a href=\"/user_uploads/3121/smmuWVubUHD0JacYciqS7n3k/Bogdanov_s_lemma.pdf\">Bogdanov_s_lemma.pdf</a></p>\n<p>Doing this in Python code would look something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code><span class=\"c1\">#Assumption: G is made with 2 disjoint PMs -&gt; G is 2-regular</span>\n<span class=\"n\">sub_graphs</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n<span class=\"k\">for</span> <span class=\"n\">edge</span> <span class=\"ow\">in</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">edgeSet</span><span class=\"p\">:</span>\n   <span class=\"n\">edge_added</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n   <span class=\"k\">for</span> <span class=\"n\">sub_graph</span> <span class=\"ow\">in</span> <span class=\"n\">sub_graphs</span><span class=\"p\">:</span>\n      <span class=\"k\">if</span> <span class=\"n\">hasVertexInCommon</span><span class=\"p\">(</span><span class=\"n\">sub_graph</span><span class=\"p\">,</span> <span class=\"n\">edge</span><span class=\"p\">):</span>\n         <span class=\"n\">sub_graph</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">edge</span><span class=\"p\">)</span>\n         <span class=\"n\">edge_added</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n         <span class=\"k\">break</span>\n      <span class=\"k\">if</span> <span class=\"n\">edge_added</span><span class=\"p\">:</span>\n         <span class=\"k\">continue</span>\n   <span class=\"n\">subGraphs</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">([</span><span class=\"n\">edge</span><span class=\"p\">])</span>\n</code></pre></div>\n<p>My question: is it possible to define something similar in Lean? And could this actually lead to a simpler proof in Lean?</p>",
        "id": 432906368,
        "sender_full_name": "Lode Vermeulen",
        "timestamp": 1712929279
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/graph.20theory.20project/near/431353087\">said</a>:</p>\n<blockquote>\n<p>What you want is something like</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">IsExclusivelyDisjointPMGraph</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">M.IsPerfectMatching</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">PairwiseDisjoint</span> <span class=\"n\">id</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I am finally getting around to using this definition, but I am struggling to see why this definition does not also say that the vertex sets of the Subgraphs are disjoint. How does Lean know that we are talking about the disjointness of the edgesets, rather than the vertex sets?</p>",
        "id": 435992873,
        "sender_full_name": "Lode Vermeulen",
        "timestamp": 1714381968
    },
    {
        "content": "<p>As Mitchell mentioned above, this definition is indeed wrong because it should only require that the edge sets are disjoint. The correct definition is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">IsExclusivelyDisjointPMGraph</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Subgraph</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">M.IsPerfectMatching</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">PairwiseDisjoint</span> <span class=\"n\">Subgraph.edgeSet</span>\n</code></pre></div>",
        "id": 435993141,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1714382054
    }
]