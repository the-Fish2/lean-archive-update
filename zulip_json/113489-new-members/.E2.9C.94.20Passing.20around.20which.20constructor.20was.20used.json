[
    {
        "content": "<p>Consider the following inductive type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Basic</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">ConstructorA</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T</span>\n<span class=\"bp\">|</span> <span class=\"n\">ConstructorB</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span><span class=\"o\">,</span> <span class=\"n\">DecidableEq</span><span class=\"o\">,</span> <span class=\"n\">Inhabited</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">makeT</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span>  <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"n\">T.ConstructorA</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>Suppose I want to pass around the fact that <code>makeT</code> always returns a <code>T</code> which is really a <code>ConstructorA</code>. I.e. maybe later I want to get the argument back out, and I don't want to have to consider the fact that makeT 'could' return a <code>ConstructorB</code>.</p>\n<p>What's the best way to go about something like this? Is there some way to annotate <code>makeT</code> with a more specific return type, which represents only <code>ConstructorA</code>? If not, is there some way to pass around the fact that something returned by <code>makeT</code> is actually a <code>ConstructorA n</code> for some <code>n</code> in a way that would allow me to use <code>n</code> later?</p>\n<p>Specifically assume that downstream code does not have access to the definition of <code>makeT</code>. It only has something that was created by a call to <code>makeT</code>.</p>",
        "id": 427989313,
        "sender_full_name": "Alexander Gillon",
        "timestamp": 1710958158
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">makeT</span> <span class=\"mi\">7</span>\n<span class=\"c1\">-- ⇒ T.ConstructorA 7</span>\n</code></pre></div>\n<p>There seems to be some confusion. All objects of an inductive type carry with them the information about what constructor was used to create them, and it is never possible to have an object of type <code>T </code> without having a definition of <code>T</code>.</p>",
        "id": 427992327,
        "sender_full_name": "Richard Copley",
        "timestamp": 1710959244
    },
    {
        "content": "<p>Ok, consider the following function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">T.ConstructorA</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">T.ConstructorB</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- impossible</span>\n</code></pre></div>\n<p>Suppose I want <code>h</code> to contain some information that allows me to know that <code>t</code> is a <code>ConstructorA</code>, and allows me to extract <code>n</code> from it. In this case, we don't know how <code>t</code> is defined.</p>",
        "id": 427993469,
        "sender_full_name": "Alexander Gillon",
        "timestamp": 1710959669
    },
    {
        "content": "<p>As in, I don't want to have to write the <code>ConstructorB</code> case.</p>",
        "id": 427993797,
        "sender_full_name": "Alexander Gillon",
        "timestamp": 1710959796
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">T.ConstructorA</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">T.ConstructorA</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"n\">T.ConstructorB</span> <span class=\"n\">z</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">f_ok</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">T.ConstructorA</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">T.ConstructorA</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">t</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ConstructorA</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">unfold</span> <span class=\"n\">f</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ConstructorB</span> <span class=\"n\">z</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">hn</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n    <span class=\"n\">conv_lhs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hn</span><span class=\"o\">]</span>\n    <span class=\"n\">injections</span>\n</code></pre></div>\n<p>[Edit: make <code>f</code> a def, not a theorem]</p>\n<blockquote>\n<p>As in, I don't want to have to write the ConstructorB case.</p>\n</blockquote>\n<p>I don't see how that's going to work.</p>",
        "id": 427996901,
        "sender_full_name": "Richard Copley",
        "timestamp": 1710961046
    },
    {
        "content": "<p>Here's a trick:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ConstructorA</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ConstructorB</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span><span class=\"o\">,</span> <span class=\"n\">DecidableEq</span><span class=\"o\">,</span> <span class=\"n\">Inhabited</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">makeT</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"n\">T.ConstructorA</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">T.isConstructorA</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span>\n  <span class=\"bp\">|</span> <span class=\"n\">T.ConstructorA</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span>\n  <span class=\"bp\">|</span> <span class=\"n\">T.ConstructorB</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">t.isConstructorA</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">T.ConstructorA</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">makeT</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n<span class=\"c1\">-- 3</span>\n</code></pre></div>",
        "id": 427997855,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710961385
    },
    {
        "content": "<p>Hmm, it turns out you don't need to pass <code>h</code> explicitly to the <code>match</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">t.isConstructorA</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">T.ConstructorA</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 427998488,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710961645
    },
    {
        "content": "<p>Thanks Kyle, that's exactly the sort of trick I was looking for. I was sure there was some way to do this.</p>",
        "id": 428007081,
        "sender_full_name": "Alexander Gillon",
        "timestamp": 1710965044
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"694154\">Alexander Gillon</span> has marked this topic as resolved.</p>",
        "id": 428007130,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710965062
    }
]