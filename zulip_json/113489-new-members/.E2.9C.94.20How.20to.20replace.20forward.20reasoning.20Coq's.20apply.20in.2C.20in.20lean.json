[
    {
        "content": "<p>When writing proofs in Coq, I would use rewrites, which seem more convenient in Lean, but when I have implications, instead of equalities, I could either move forward from hypotheses with Coq's apply in, or backward from conclusions.</p>\n<p>I tried the replacement for apply in mentioned in Coq to Lean tactics guide but it didn't work.</p>\n<p>As I've been transferring over to Lean, I've noticed this problem, but in most cases I can try to adapt reasoning to go backwards from the conclusion, but I have an ex falso proof where I can't really go backwards from false.</p>\n<p>So I thought I'd see what solutions people use?</p>",
        "id": 442298893,
        "sender_full_name": "Anthony Peterson",
        "timestamp": 1717430873
    },
    {
        "content": "<p>If you give a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> here illustrating what you want to see, you can get a targeted answer</p>",
        "id": 442304055,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1717431797
    },
    {
        "content": "<p>This is just a simple example in number theory, as I'm transferring over a proof of the infinitude of primes I wrote in Coq, as an exercise in getting used to Lean.</p>\n<p><code>\ndef times_SS_neq_S0 (x y : Nat) : ¬ ((x * (y + 2)) = 1) := by\n  cases x with\n  | zero =&gt;\n    intros H0\n    rw [Nat.zero_mul] at H0\n    contradiction\n  | succ x' =&gt;\n    intros H0\n    rw [mult_dist2, Nat.one_mul] at H0\n    rw [Nat.add_one, Nat.add_succ, Nat.add_one, Nat.add_succ] at H0\n</code></p>\n<p>My context here is:<br>\n<strong>y x'</strong> : Nat<br>\n<strong>H0</strong> : (x' * y.succ.succ + y).succ.succ = 1<br>\n<strong>⊢</strong> False</p>\n<p>I know I can use succ_inj to move forward in Coq, but I'm not sure how to advance  from succ.succ = 1 to succ = 0 and then contradiction in Lean?</p>",
        "id": 442308788,
        "sender_full_name": "Anthony Peterson",
        "timestamp": 1717432694
    },
    {
        "content": "<p>(Zulip hint: triple backticks for code blocks)</p>\n<p>One option is the <code>injection</code> tactic.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">injection</span><span class=\"w\"> </span><span class=\"n\">H0</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">H0'</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  H0' : x' * y.succ.succ + y + 1 = 0</span>\n<span class=\"cm\">  -/</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Here, <code>simp at H0</code> closes the goal completely. In fact, <code>cases H0</code> does as well (it recursively does <code>injection</code>, more or less).</p>",
        "id": 442342268,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1717440679
    },
    {
        "content": "<p>I eventually figured out how to do it using Have, but injection seems easier.  Thanks!</p>",
        "id": 442343959,
        "sender_full_name": "Anthony Peterson",
        "timestamp": 1717441140
    },
    {
        "content": "<p>Maybe you're looking for <code>apply succ_inj at H0</code>?</p>",
        "id": 442350871,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717442899
    },
    {
        "content": "<p>I tried that, and I got an error message. What I read online said Lean doesn't have apply at? Does apply at exist in Lean?</p>\n<p>It looks like it's trying to apply not apply at when I use it, as I get the error \"tactic 'apply' failed, failed to unify<br>\n  ?x = ?y\"</p>",
        "id": 442352280,
        "sender_full_name": "Anthony Peterson",
        "timestamp": 1717443328
    },
    {
        "content": "<p>It's in mathlib. You'd do <code>apply Nat.succ_inj.mp at H0</code> here (<code>apply_at</code> doesn't know about iffs, hence the <code>.mp</code> to get the modus ponens direction.)</p>",
        "id": 442352960,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1717443536
    },
    {
        "content": "<p>This tactic was added by Adam Topaz last year</p>",
        "id": 442353123,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1717443584
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"697725\">Anthony Peterson</span> has marked this topic as resolved.</p>",
        "id": 443045310,
        "sender_full_name": "Notification Bot",
        "timestamp": 1717676809
    }
]