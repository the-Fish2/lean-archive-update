[
    {
        "content": "<p>As a sort fun exercise, I thought I'd try to work my way through the Natural Numbers Game, but rather than use Peano's Axioms, I'd try it with a base-two representation. I pretty much got myself stuck immediately when trying to define a <code>ToString</code> instance for my new inductive type.</p>\n<p>I suspect that I'm just not familiar enough with Lean. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">NatB</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">ℕb</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">One</span><span class=\"o\">:</span> <span class=\"n\">ℕb</span>\n  <span class=\"bp\">|</span> <span class=\"n\">T2</span><span class=\"o\">:</span> <span class=\"n\">ℕb</span> <span class=\"bp\">→</span> <span class=\"n\">ℕb</span>\n  <span class=\"bp\">|</span> <span class=\"n\">P1</span><span class=\"o\">:</span> <span class=\"n\">ℕb</span> <span class=\"bp\">→</span> <span class=\"n\">ℕb</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">ℕ</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Zero</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Binary</span><span class=\"o\">:</span> <span class=\"n\">ℕb</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"n\">ℕb</span> <span class=\"n\">where</span>\n  <span class=\"n\">toString</span><span class=\"o\">:</span> <span class=\"n\">ℕb</span> <span class=\"bp\">→</span> <span class=\"n\">String</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ℕb.One</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"1\"</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ℕb.T2</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{n}0\"</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ℕb.P1</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{n}1\"</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"n\">ℕ</span> <span class=\"n\">where</span>\n  <span class=\"n\">toString</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">String</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ℕ.Zero</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"0\"</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ℕ.Binary</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{n}\"</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">NatB</span>\n</code></pre></div>\n<p>The Error I get is that I <code>failed to synthesize instance ToString ℕb</code>. I feel like I'm missing something simple.</p>",
        "id": 411067298,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1704309508
    },
    {
        "content": "<p>You can make a separate <code>def</code> first and then use it to make the <code>instance</code></p>",
        "id": 411067617,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704309668
    },
    {
        "content": "<p>ha ha I have also done this exercise :-)  You'll want</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"n\">ℕb</span> <span class=\"n\">where</span>\n  <span class=\"n\">toString</span><span class=\"o\">:</span> <span class=\"n\">ℕb</span> <span class=\"bp\">→</span> <span class=\"n\">String</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ℕb.One</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"1\"</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ℕb.T2</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"c1\">-- something involving `foo`</span>\n</code></pre></div>",
        "id": 411067657,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704309685
    },
    {
        "content": "<p>PS associativity of addition is fun :-) The game becomes impossible after some point -- e.g. associativity of multiplication. The way I did it was that I proved a bijection between binary nat and unary nat, and transported the proof over.</p>",
        "id": 411067863,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704309776
    },
    {
        "content": "<p>Ah, that for the tip! very helpful :)</p>",
        "id": 411068048,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1704309864
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I might have slipped in before you (hence the <span aria-label=\"racecar\" class=\"emoji emoji-1f3ce\" role=\"img\" title=\"racecar\">:racecar:</span>) but your solution ends up being a bit different. The compiler will inline your definition wherever <code>toString</code> is used, but if you split out a separate <code>def</code> then it won't (or rather it won't unfold the body of that definition).</p>",
        "id": 411068639,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704310125
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Structural.20Recursion.20for.20ToString.20Instance/near/411067863\">said</a>:</p>\n<blockquote>\n<p>PS associativity of addition is fun :-) The game becomes impossible after some point -- e.g. associativity of multiplication. The way I did it was that I proved a bijection between binary nat and unary nat, and transported the proof over.</p>\n</blockquote>\n<p>This feels surprising to me! I suppose I'll get there soon enough but somehow my intuition was that the representation would convolute things but not preclude any of the proofs possible with the unary representation. Though I suppose transporting proofs sort of makes that intuition hold. I'm sure I'll learn something in the attempt!</p>",
        "id": 411071420,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1704311395
    },
    {
        "content": "<p>I have seen textbooks which define the reals to be decimal expansions that don't end in ...999999... and I used to think that this was a feasible definition which makes the least upper bound axiom easy to prove, but now I'm extremely skeptical about whether this is feasible because of issues like associativity of multiplication (which for decimals will be much worse than binary naturals). You don't have to biject with the unary naturals, the thing which you really find you need (or at least I found I needed) is the usual induction principle, which you can attempt to prove for binary nats directly.</p>",
        "id": 411076858,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704313801
    },
    {
        "content": "<p>The bottom line is that if you're trying to prove a statement about (possibly several) binary naturals via the induction principle that comes with them, then you can't always get from knowing it for a to knowing it for 2a+1 because +1 might not cancel and you might end up with needing some auxiliary fact for x+1 and only having it for x: \"+1\" is not a primitive operation for binary naturals.</p>",
        "id": 411077302,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704314044
    },
    {
        "content": "<p>By the way, when I did it I didn't add zero until much later: binary naturals naturally start at 1 and you can develop the NNG theory for these instead -- the \"British natural numbers\".</p>",
        "id": 411077465,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704314149
    },
    {
        "content": "<p><a href=\"https://www.sciencedirect.com/science/article/pii/138572587690055X\">https://www.sciencedirect.com/science/article/pii/138572587690055X</a></p>",
        "id": 411078675,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1704314852
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/tree/de-brujin-reals-no-rationals\">branch#de-brujin-reals-no-rationals</a></p>",
        "id": 411078780,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1704314900
    },
    {
        "content": "<p>I'm in the middle of section 12, everything beforehand is proven</p>",
        "id": 411078839,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1704314935
    },
    {
        "content": "<p>We'll see how the multiplication part goes :)</p>",
        "id": 411078899,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1704314970
    },
    {
        "content": "<p>Whilst de Bruijn spends several pages on addition, he says (in section 9) \"the prospects of introducing multiplication and division by their algorithms do not seem to be very good at this point\" and his sketch (just 10 or so lines) of another approach can perhaps be interpreted as \"I don't know how to do associativity of multiplication on binary naturals directly\".</p>",
        "id": 411085120,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704317438
    },
    {
        "content": "<p>Note that mathlib plays the binary natural number game in <a href=\"https://tqft.net/mathlib4files/Mathlib/Data/Num/Lemmas\">file#Mathlib/Data/Num/Lemmas</a></p>",
        "id": 411087290,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704318604
    },
    {
        "content": "<p>but it also \"cheats\" and uses <code>transfer</code> from Nat to prove <code>mul_assoc</code></p>",
        "id": 411087552,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704318753
    },
    {
        "content": "<p>Coq also plays the binary natural number game, I'll go see what they did</p>",
        "id": 411087615,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704318784
    },
    {
        "content": "<p>Ha! They kind of also \"cheat\", but in a slightly different way: they prove that binary natural numbers satisfy the unary natural induction principle and then prove mul_assoc that way. (In fact they prove hundreds of theorems this way, by using Coq modules to describe the property of \"looking like Nat\" and then proving a bunch of theorems about them, then instantiating both binary and unary naturals using this module)</p>",
        "id": 411088869,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704319343
    },
    {
        "content": "<p>Right, those are the two ways I know. I'll leave it to Yakov to explain the third way (I don't know if the techniques in section 14 of the de Bruijn paper will work for naturals)</p>",
        "id": 411092322,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704321144
    },
    {
        "content": "<p>The de Bruijn paper also uses unary induction:<br>\n<a href=\"/user_uploads/3121/QbglOPFyhzlAvauJRZp0KqOE/image.png\">image.png</a><br>\n<a href=\"/user_uploads/3121/zqnPYJz6f_KGmKOYJ-YAQtTJ/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/QbglOPFyhzlAvauJRZp0KqOE/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/QbglOPFyhzlAvauJRZp0KqOE/image.png\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/3121/zqnPYJz6f_KGmKOYJ-YAQtTJ/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/zqnPYJz6f_KGmKOYJ-YAQtTJ/image.png\"></a></div>",
        "id": 411092872,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1704321519
    },
    {
        "content": "<p>Where the induction is more of a Z (Integer) like, over some base.</p>",
        "id": 411092929,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1704321564
    },
    {
        "content": "<p>it does sound like an interesting challenge though</p>",
        "id": 411093137,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704321683
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Structural.20Recursion.20for.20ToString.20Instance/near/411088869\">said</a>:</p>\n<blockquote>\n<p>prove that binary natural numbers satisfy the unary natural induction principle</p>\n</blockquote>\n<p>Because induction is implemented in terms of recursion, does this look a bit like moving from structural recursion to well-founded recursion by proving something like that <code>predecessor</code> is a well founded recursive relation?</p>",
        "id": 411096717,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1704323834
    },
    {
        "content": "<p>I think the core of it is the fact that you can construct a <code>Nat</code> from a <code>Num</code>, in fact an exponentially larger one, which is done by iterating the <code>2*n</code> and <code>2*n+1</code> functions on <code>Nat</code> (which are themselves defined by recursion on <code>Nat</code>)</p>",
        "id": 411097744,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704324619
    },
    {
        "content": "<p>that gives you a very large element of an inductive type which you can then use to power the induction down to zero using binary successor</p>",
        "id": 411097795,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704324672
    },
    {
        "content": "<p>which shows that every element of <code>Num</code> is accessible by applying enough binary successors to zero</p>",
        "id": 411097880,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704324725
    },
    {
        "content": "<p>There is surely a way to recast that proof such that it doesn't use the type <code>Nat</code> directly</p>",
        "id": 411097912,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704324757
    }
]