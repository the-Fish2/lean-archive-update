[
    {
        "content": "<p>I have a structure Type that represents an existing key of an AssocList. Lean is smart enough to automatically \"convert\" the type to other lists where the key is present aswell. It can figure out, that if replace any key-value pair, the resulting list will still contain the key. However when choosing the replaced key to be arbitrary lean fails to do so which confuses me</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">contained_elem</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">Lean.AssocList</span> <span class=\"n\">Nat</span> <span class=\"n\">Unit</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">l.find</span><span class=\"bp\">?</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isSome</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test_list</span><span class=\"o\">:</span> <span class=\"n\">Lean.AssocList</span> <span class=\"n\">Nat</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"o\">[(</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"o\">())]</span><span class=\"bp\">.</span><span class=\"n\">toAssocList'</span>\n<span class=\"kd\">def</span> <span class=\"n\">ce</span><span class=\"o\">:</span> <span class=\"n\">contained_elem</span> <span class=\"n\">test_list</span> <span class=\"o\">:=</span> <span class=\"n\">contained_elem.mk</span> <span class=\"mi\">3</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ce2</span><span class=\"o\">:</span> <span class=\"n\">contained_elem</span> <span class=\"o\">(</span><span class=\"n\">test_list.replace</span> <span class=\"mi\">3</span> <span class=\"o\">())</span> <span class=\"o\">:=</span> <span class=\"n\">ce</span> <span class=\"c1\">-- conversion works magically</span>\n<span class=\"kd\">def</span> <span class=\"n\">ce3</span><span class=\"o\">:</span> <span class=\"n\">contained_elem</span> <span class=\"o\">(</span><span class=\"n\">test_list.replace</span> <span class=\"n\">x</span> <span class=\"o\">())</span> <span class=\"o\">:=</span> <span class=\"n\">ce</span> <span class=\"c1\">-- conversion does not work</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test_fun</span> <span class=\"o\">{</span><span class=\"n\">ls</span><span class=\"o\">:</span> <span class=\"n\">Lean.AssocList</span> <span class=\"n\">Nat</span> <span class=\"n\">Unit</span><span class=\"o\">}:</span> <span class=\"n\">contained_elem</span> <span class=\"n\">ls</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Unit</span>\n<span class=\"bp\">|</span> <span class=\"n\">ce</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">let</span> <span class=\"n\">other_l</span><span class=\"o\">:</span> <span class=\"n\">contained_elem</span> <span class=\"o\">(</span><span class=\"n\">ls.replace</span> <span class=\"mi\">4</span> <span class=\"o\">())</span> <span class=\"o\">:=</span> <span class=\"n\">ce</span> <span class=\"c1\">-- also does not work</span>\n  <span class=\"o\">()</span>\n</code></pre></div>",
        "id": 422579973,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1708509090
    },
    {
        "content": "<p>This seems like a sensible error to me. In the definition of <code>ce2</code> you replace the element with the same element so the <code>Assoclist</code> is the same, so it is fine that <code>ce</code> is used as a <code>contained_elem</code> of that list, that type checks. But if <code>x</code> is different from 3, the list may not be the same so it is not permissible to use <code>ce</code> as an <code>contained_elem</code> of that list, because the type of <code>ce</code> is only known to be <code>contained_elem test_list</code>, <del>not <code>contained_elem (test_list.replace x ())</code></del></p>",
        "id": 422600301,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1708516342
    },
    {
        "content": "<p>I guess your point is <code>test_list.replace x ()</code> will always be equal to <code>test_list</code> no matter what <code>x</code> is. But that is a fact that needs proof.</p>",
        "id": 422600761,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1708516558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113489-new-members/topic/Help.20with.20proofs/near/422600761\">said</a>:</p>\n<blockquote>\n<p>I guess your point is <code>test_list.replace x ()</code> will always be equal to <code>test_list</code> no matter what <code>x</code> is. But that is a fact that needs proof.</p>\n</blockquote>\n<p>thats it, i tried to prove it with simp? and exact?, but those cannot close the goal (which i thought they should be able to)</p>\n<p>also my example works for any chosen Nat, not only 3</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ce2</span><span class=\"o\">:</span> <span class=\"n\">contained_elem</span> <span class=\"o\">(</span><span class=\"n\">test_list.replace</span> <span class=\"mi\">666</span> <span class=\"o\">())</span> <span class=\"o\">:=</span> <span class=\"n\">ce</span> <span class=\"c1\">-- doesnt touch key 3 and works</span>\n</code></pre></div>",
        "id": 422601291,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1708516779
    },
    {
        "content": "<blockquote>\n<p>also my example works for any chosen Nat not only 3</p>\n</blockquote>\n<p>Yes, I see that now. But my confusion was the same as Lean's in this instance. I was not aware of the exact definition of <code>replace</code> so I didn't know if the types would be equal. It seems like a case of the difference between propositional and definitional equality.</p>\n<p>Seems like filling in the sorry below is what you want to do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ce3</span><span class=\"o\">:</span> <span class=\"n\">contained_elem</span> <span class=\"o\">(</span><span class=\"n\">test_list.replace</span> <span class=\"n\">x</span> <span class=\"o\">())</span> <span class=\"o\">:=</span>\n  <span class=\"n\">cast</span>\n  <span class=\"o\">(</span><span class=\"kd\">by</span>\n    <span class=\"n\">congr</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n      <span class=\"n\">rfl</span>\n    <span class=\"bp\">·</span>\n      <span class=\"gr\">sorry</span>\n  <span class=\"o\">)</span> <span class=\"n\">ce</span> <span class=\"c1\">-- conversion does not work</span>\n</code></pre></div>",
        "id": 422601632,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1708516904
    }
]