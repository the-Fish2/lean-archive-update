[
    {
        "content": "<p>I just picked up Lean yesterday by going through the Number Game, and I am thinking about trying to formally verify properties of search algorithms such Monte-Carlo Tree Search (MCTS) with various modifications such as upper confidence bounds for trees (UCT) or terminal node solving.</p>\n<ul>\n<li>I don't know what has already been verified by the community and I would like to find out more.</li>\n<li>I also don't know how difficult something like this might be. I have an undergraduate CS background.</li>\n<li>What should I read first if my goal is to formally verify search algorithms? Theorem Proving in Lean 4 or Functional Programming in Lean?</li>\n</ul>",
        "id": 422060454,
        "sender_full_name": "Viliam Vadocz",
        "timestamp": 1708224645
    },
    {
        "content": "<p>Hi! </p>\n<p>1) What has already been verified is in mathlib<br>\n<a href=\"https://github.com/leanprover-community/mathlib4\">https://github.com/leanprover-community/mathlib4</a><br>\n2) Examples of formally verified results published recently: <a href=\"https://www.tandfonline.com/toc/uexm20/31/2?nav=tocList\">https://www.tandfonline.com/toc/uexm20/31/2?nav=tocList</a><br>\n3) Are search algorithms theorems with proofs? If yes, then this can help: <a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">https://leanprover.github.io/theorem_proving_in_lean/</a><br>\nOtherwise this <a href=\"https://lean-lang.org/functional_programming_in_lean/\">https://lean-lang.org/functional_programming_in_lean/</a></p>\n<p>Good luck <span aria-label=\"fingers crossed\" class=\"emoji emoji-1f91e\" role=\"img\" title=\"fingers crossed\">:fingers_crossed:</span></p>",
        "id": 422100884,
        "sender_full_name": "Yagub Aliyev",
        "timestamp": 1708265756
    },
    {
        "content": "<p>We should now have most probability tools you need to analyse the UCT algorithm. However, what we have in this direction stops here: as far as I know nobody has done any regret bound proof for a RL or multi-armed bandit algorithm. There has been some work in Coq on RL methods: <a href=\"https://github.com/IBM/FormalML\">https://github.com/IBM/FormalML</a> , but not in Lean.</p>\n<p>I say that we have everything you'll need, but you'll want concentration inequalities like Azuma-Hoeffding if you follow the UCT paper proof and while we have everything we need to state it, it has not been done yet.<br>\nAn interesting first step would be to prove a regret bound for the UCB bandit algorithm, since UCT is an adaptation of UCB to the more complex setting of tree search. I suggest you look at the Bandit Algorithms book by Tor Lattimore and Csaba Szepesvari for clean proofs (see <a href=\"https://tor-lattimore.com/\">https://tor-lattimore.com/</a> for a free pdf).</p>\n<p>Overall, I'd say verifying properties of UCT is a feasible but not straightforward goal, and that might take some time.</p>",
        "id": 422103139,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1708267790
    },
    {
        "content": "<p>Thanks for the helpful links, <span class=\"user-mention\" data-user-id=\"682831\">@Yagub Aliyev</span>.</p>\n<p>Also thanks for the suggestion of looking at UCB first, <span class=\"user-mention\" data-user-id=\"350992\">@Rémy Degenne</span>. I have some additional questions:</p>\n<ul>\n<li>How much time would you estimate it would take me to learn Lean (and mathlib) to such a degree that I can verify regret  bounds for UCB? You may assume a computer science undergraduate background with additional reading into type and category theories, experience with functional languages, and familiarity with the subject material in the context of RL.</li>\n<li>How long would it take to do the actual proof?</li>\n<li>Is translating an existing proof straightforward in your experience or do you tend to require new formalisms?</li>\n</ul>",
        "id": 422112148,
        "sender_full_name": "Viliam Vadocz",
        "timestamp": 1708275706
    }
]