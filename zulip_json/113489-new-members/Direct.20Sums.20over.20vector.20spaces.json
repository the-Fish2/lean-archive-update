[
    {
        "content": "<p>Sorry to do this again, but I can't make heads or tails of the <code>DirectSum</code> notation.</p>\n<p>The goal in Axler is to show that the direct sum of subspaces  in <code>F^3</code> {&lt;x, y, 0&gt;} ⊕ {&lt;0, 0,z&gt;} = F^3`</p>\n<p>Here's where I got to, where the <code>example</code> is completely borked because I can't grok the syntax of direct sums in Mathlib</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Module.Submodule.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.DirectSum.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fin.VecNotation</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">ex1_42_U</span><span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">3</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">]</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ex1_42_V</span><span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">3</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">]</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)}</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">DirectSum</span>\n<span class=\"c1\">-- example: (⨁ (ex1_42_U) (ex1_42_V), f ex1_42_U ex1_42_V) = (Fin 3 → F) := by sorry</span>\n</code></pre></div>",
        "id": 424161337,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709269556
    },
    {
        "content": "<p><code>DirectSum</code> operates on an indexed family of spaces. To use it on just two, use an indexing type of cardinality 2, such as <code>Bool</code> or <code>Fin 2</code>. You can express <code>U ⨁ V</code> as <code>⨁ i: Bool, if i then U else V</code></p>",
        "id": 424163553,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709271681
    },
    {
        "content": "<p>Or <code>⨁ i, ![U, V] i</code>. Or <code>DirectSum _ ![U, V]</code></p>",
        "id": 424163803,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709271887
    },
    {
        "content": "<p>Not sure what's preferred</p>",
        "id": 424163809,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709271895
    },
    {
        "content": "<p>Or <code>U × V</code></p>",
        "id": 424176954,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709280104
    },
    {
        "content": "<p>Or since we're talking about subspaces, this is <code>U ⊔ V</code>, or perhaps <code>IsCompl U V</code></p>",
        "id": 424177123,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709280182
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"542196\">@Arien Malec</span> the definitions of things like sums, direct sums etc in mathlib are different to the ones used in Axler and this is a great example of the kind of problem you run into when you want to \"go through a textbook in Lean\". One approach which avoids all this confusion would be to just write your own definitions. Of course, if you do this, you'll discover why Lean's definitions are different -- Lean's definitions are chosen to be the ones which cause the least pain when using them in Lean. This is the problem you face with formalising a maths book.</p>",
        "id": 424215382,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709293021
    },
    {
        "content": "<p>This has nothing to do with Lean, Axler is using a very standard abuse of notations and here you simply need to be precise.</p>",
        "id": 424231829,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709298526
    },
    {
        "content": "<p>We could use the confusing notation in Lean but there is not much point doing it.</p>",
        "id": 424232071,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709298605
    },
    {
        "content": "<p>It's funny -- I see any number of Github repositories of people trying to do the same thing as I, and generally bomb out at the end of Chapter 1.... I'm following a thread, which I can't find in the Zulip, that the most interesting way to do this would be to cover the same ground <em>in Lean</em> rather than translate too closely. This kind of gear meshing is the inevitable result.</p>",
        "id": 424271048,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709307842
    },
    {
        "content": "<p>My approach is what <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> recommended here: <a href=\"#narrow/stream/113489-new-members/topic/Showing.20a.20subset.20that's.20a.20vector.20space.20contains.20zero/near/365098675\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Showing.20a.20subset.20that's.20a.20vector.20space.20contains.20zero/near/365098675</a></p>",
        "id": 424272230,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709308156
    },
    {
        "content": "<p>(which is the thread I was thinking of).</p>",
        "id": 424273413,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709308411
    },
    {
        "content": "<p>And perhaps direct sums are not the right construct -- the definition Axler is looking for is something like: <code>U ⊔ V ∧ U ∩ V = ∅</code></p>",
        "id": 424282552,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709310719
    },
    {
        "content": "<p>The LHS of your <code>∧</code> is not a proposition; it doesn't mean anything for \"<code>U ⊔ V</code>\" to be true.</p>",
        "id": 424287464,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709312001
    },
    {
        "content": "<p>And the RHS is always false, because even the \"empty\" vector space has a zero, so is not the empty set</p>",
        "id": 424287637,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709312045
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsCompl#doc\">docs#IsCompl</a> is probably what you meant</p>",
        "id": 424287660,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709312053
    },
    {
        "content": "<p>Probably -- the sense is that a vector space is composed of multiple disjoint vector spaces.</p>",
        "id": 424287742,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709312083
    },
    {
        "content": "<p>Building to an intuition of a basis.</p>",
        "id": 424288055,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709312121
    },
    {
        "content": "<p>Right, instead of empty I should have written <code>{0}</code></p>",
        "id": 424288330,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709312213
    },
    {
        "content": "<p><code>U ∩ V = {0}</code> would be written in mathlib as <code>Disjoint U V</code> (see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=disjoint_iff#doc\">docs#disjoint_iff</a> for a proof this is the same)</p>",
        "id": 424288416,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709312237
    },
    {
        "content": "<p>We want something like <code>W = U ⊔ V ∧ U ∩ V = {0}</code> then</p>",
        "id": 424288486,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709312258
    },
    {
        "content": "<p>Yes, and I told you how to spell exactly that in mathlib :)</p>",
        "id": 424288684,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709312313
    },
    {
        "content": "<p>I'm still struggling with the setup to Axler's  example above.... , that <code>F^3</code> is the combination of the two disjoint subsets.</p>",
        "id": 424289194,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709312473
    },
    {
        "content": "<p>So maybe the statement is: <code>example: ((ex1_42_U ⊔ ex1_42_V) = Fin 3 → F) ∧ Disjoint ex1_42_U ex1_42_V := by sorry</code>? But I can't get this to typecheck. Perhaps I'm missing an import...</p>",
        "id": 424289872,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709312654
    },
    {
        "content": "<p>Parentheses and stuff, but Mathlib/Lean doesn't like turning a collection of <code>Submodule</code>s into a <code>Module</code></p>",
        "id": 424290856,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709312930
    },
    {
        "content": "<p>Arien I think you would have a much easier job if you could accept to first learn a bit about mathlib and then come back to your project. Guessing everything is not so fun. A lot of things are not documented but what you are struggling with <em>is</em> documented. I think there is not much point doing what you are doing without first reading the algebra chapter of <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a> or some other resource covering the same material.</p>",
        "id": 424295266,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709314371
    },
    {
        "content": "<p>With those defs, <code>ex1_42_U</code> isn't a submodule, <code>ex1_42_U F</code> is.</p>",
        "id": 424295344,
        "sender_full_name": "Richard Copley",
        "timestamp": 1709314406
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113489-new-members/topic/Direct.20Sums.20over.20vector.20spaces/near/424295266\">said</a>:</p>\n<blockquote>\n<p>Arien I think you would have a much easier job if you could accept to first learn a bit about mathlib and then come back to your project. Guessing everything is not so fun. A lot of things are not documented but what you are struggling with <em>is</em> documented. I think there is not much point doing what you are doing without first reading the algebra chapter of <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a> or some other resource covering the same material.</p>\n</blockquote>\n<p>I've read though <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a> but not done the exercises. I'll commit to doing so. At the same time, I suspect that knowing the abstract algebra hierarchy will not lead to clarity in the gear meshing I'm working through...</p>",
        "id": 424304906,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709318161
    },
    {
        "content": "<p>It should be enough to get you to understand why <code>(ex1_42_U ⊔ ex1_42_V) = Fin 3 → F</code> is wrong.</p>",
        "id": 424305124,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709318240
    },
    {
        "content": "<p>I mean it stays wrong even after inserting the missing arguments.</p>",
        "id": 424305209,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709318274
    },
    {
        "content": "<p>When I look at it, it's obviously wrong -- I should have written <code>Module F (Fin 3 → F)</code></p>",
        "id": 424305323,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709318302
    },
    {
        "content": "<p>Which is probably still wrong, but at least a more right sort of wrong.</p>",
        "id": 424305673,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709318444
    },
    {
        "content": "<p>Perhaps I can approach this problem in a different direction. How would one say that <code>(span(&lt;1, 0, 0&gt;) +span(&lt;0,1,0&gt;) + span(&lt;0,0,1&gt;)) = ℝ^3</code></p>",
        "id": 424305972,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709318573
    },
    {
        "content": "<p>This is not the issue, the issue is the right hand side of your <code>(ex1_42_U ⊔ ex1_42_V) = Fin 3 → F</code></p>",
        "id": 424306751,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709318874
    },
    {
        "content": "<p>You need to put a submodule there.</p>",
        "id": 424306831,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709318894
    },
    {
        "content": "<p>OK, now I'm super confused. The exercise that Axler is leading us through is to show that vector spaces are \"composed of\" subspaces each of which can be generated by a basis vector. In Mathlib, can we show that composition of subspaces that form the required vector space? We'd then want submodules on the LHS and a module on the RHS....</p>",
        "id": 424319303,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709324110
    },
    {
        "content": "<p>I guess I've been super confused all along and now I just have a new dimension of confusion added.</p>",
        "id": 424319364,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709324146
    },
    {
        "content": "<p>I can see you are confused, that’s why I told you to read  the explanations instead of trying to guess.</p>",
        "id": 424320009,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709324455
    },
    {
        "content": "<p>Or watch the lecture I mentioned earlier.</p>",
        "id": 424320107,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709324514
    },
    {
        "content": "<p>There is a submodule whose elements are all the elements of the ambiant module, and it’s name is Top.</p>",
        "id": 424320207,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709324545
    },
    {
        "content": "<p>So the statement you want is <code>example: ex1_42_U F ⊔ ex1_42_V F = ⊤ ∧ Disjoint ex1_42_U ex1_42_V </code></p>",
        "id": 424320284,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709324583
    },
    {
        "content": "<p>where <code>⊤</code> is the notation for top.</p>",
        "id": 424320322,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709324601
    },
    {
        "content": "<p>And <code>⊥</code> would be the submodule <code>{0}</code>?</p>",
        "id": 424320573,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709324723
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113489-new-members/topic/Direct.20Sums.20over.20vector.20spaces/near/424320284\">said</a>:</p>\n<blockquote>\n<p>So the statement you want is <code>example: ex1_42_U F ⊔ ex1_42_V F = ⊤ ∧ Disjoint ex1_42_U ex1_42_V </code></p>\n</blockquote>\n<p>Another spelling In mathlib for <code>ex1_42_U F ⊔ ex1_42_V F = ⊤</code> is <code>Codisjoint (ex1_42_U F) (ex1_42_V F)</code>, and combined with the <code> ∧ Disjoint _ _</code> this is exactly <code>IsCompl (ex1_42_U F) (ex1_42_V  F)</code></p>",
        "id": 424323134,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709325952
    },
    {
        "content": "<p>(Not something you should care about now, but: the original problem in this thread of showing a vector space \"is\" a direct sum of two subspaces ends up being more complicated if you start talking about semimodules instead of vector spaces, and the sup / inf / IsCompl spellings no longer work! I can say more once you've solved your current exercise)</p>",
        "id": 424324390,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709326590
    },
    {
        "content": "<p>I made things slightly easier on myself to see the shape of the proof rather than faffing with the right <code>use</code> and have this down to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">ex1_42_U</span><span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">3</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ex1_42_V</span><span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">3</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">]</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)}</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ex1_42_U</span> <span class=\"n\">F</span> <span class=\"bp\">⊔</span> <span class=\"n\">ex1_42_V</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"bp\">∧</span> <span class=\"n\">Disjoint</span> <span class=\"o\">(</span><span class=\"n\">ex1_42_U</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ex1_42_V</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">.</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Submodule.eq_top_iff'</span><span class=\"o\">]</span>\n    <span class=\"n\">intro</span> <span class=\"n\">x</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Submodule.mem_sup</span><span class=\"o\">]</span>\n    <span class=\"n\">use</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">.</span> <span class=\"gr\">sorry</span>\n    <span class=\"bp\">.</span> <span class=\"n\">use</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"mi\">2</span><span class=\"o\">]</span>\n      <span class=\"n\">constructor</span>\n      <span class=\"bp\">.</span> <span class=\"gr\">sorry</span>\n      <span class=\"bp\">.</span> <span class=\"n\">simp</span>\n        <span class=\"n\">ext</span> <span class=\"n\">f</span>\n        <span class=\"n\">fin_cases</span> <span class=\"n\">f</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"bp\">;</span> <span class=\"n\">aesop</span>\n  <span class=\"bp\">.</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">disjoint_iff</span><span class=\"o\">,</span> <span class=\"n\">Submodule.eq_bot_iff</span> <span class=\"o\">(</span><span class=\"n\">ex1_42_U</span> <span class=\"n\">F</span> <span class=\"bp\">⊓</span> <span class=\"n\">ex1_42_V</span> <span class=\"n\">F</span><span class=\"o\">)]</span>\n    <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">h</span>\n    <span class=\"n\">cases'</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span>\n    <span class=\"n\">ext</span> <span class=\"n\">f</span>\n    <span class=\"n\">fin_cases</span> <span class=\"n\">f</span> <span class=\"bp\">&lt;;&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"bp\">&lt;;&gt;</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">h1</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">x₁</span><span class=\"o\">,</span> <span class=\"n\">x₂</span><span class=\"o\">,</span> <span class=\"n\">h1</span><span class=\"o\">⟩</span> <span class=\"bp\">&lt;;&gt;</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">h2</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">x₃</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">⟩</span>\n    <span class=\"bp\">.</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">h2</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n    <span class=\"bp\">.</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">h2</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n    <span class=\"bp\">.</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">h1</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<p>where the two <code>sorry</code>s have the same shape: proof of membership in the subset....</p>",
        "id": 424330417,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709329435
    },
    {
        "content": "<p>But I don't know how to prove membership in a <code>Submodule</code></p>",
        "id": 424330838,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709329649
    },
    {
        "content": "<p>Your issue is that you made a new <code>def</code>, but didn't tell Lean anything about it</p>",
        "id": 424332765,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709330586
    },
    {
        "content": "<p>You'll want to <code>unfold ex1_42_U</code> and <code>unfold ex1_42_V</code>.</p>",
        "id": 424332769,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1709330588
    },
    {
        "content": "<p>Or better yet,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">mem_ex1_42_U_iff</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">ex1_42_U</span> <span class=\"n\">F</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.rfl</span>\n</code></pre></div>",
        "id": 424332785,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709330596
    },
    {
        "content": "<p>Unfolding gives you a monstrosity thanks to nested structures, and <code>set_option pp.proofs.withType false</code> not being the default</p>",
        "id": 424332802,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709330607
    },
    {
        "content": "<p>Yea, though <code>simp</code> or <code>aesop</code> clean it up nicely.</p>",
        "id": 424332923,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1709330657
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Direct.20Sums.20over.20vector.20spaces/near/424332785\">said</a>:</p>\n<blockquote>\n<p>Or better yet,</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">mem_ex1_42_U_iff</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">ex1_42_U</span> <span class=\"n\">F</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.rfl</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Is there any way to make this generic over <code>Submodule F (Fin 3 → F)</code></p>",
        "id": 424335419,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709331987
    },
    {
        "content": "<p>No, in the same way that it's not possible to generalize:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">mem_foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">foo</span> <span class=\"bp\">↔</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 424335633,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709332085
    },
    {
        "content": "<p>It would be reasonable to ask something to auto<em>generate</em> <code>mem_foo</code> and <code>mem_ex1_42_U_iff</code>, but that's not the same as generalization</p>",
        "id": 424335691,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709332121
    },
    {
        "content": "<p>I see -- at some point we need to expand the definition of the carrier....</p>",
        "id": 424336443,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709332556
    },
    {
        "content": "<p>Yes, exactly; either by <code>unfold</code>, which makes a mess, or by writing a lemma that does exactly the expansion you want</p>",
        "id": 424337667,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709333206
    },
    {
        "content": "<p>In many cases <code>@[simps]</code> could do this, but it doesn't know about \\mem</p>",
        "id": 424337728,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709333250
    },
    {
        "content": "<p>OK, can I repeat back what I've learned here, to check for understanding:</p>\n<p>Mathlib uses the fact that the submodules of a module form a complete lattice to generalize the proofs around modules to proofs of lattice structures; in particular, Mathlib uses the <code>⊔</code> (least upper bound) operator, or lattice join, to represent sums of submodules. What Axler terms the Direct Sum is, in Mathlib, the statement that the least upper bound of submodules is <code>⊤</code> (AKA the submodule identical to the module) along with the assertion that the submodules are disjoint.</p>",
        "id": 424337933,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709333354
    },
    {
        "content": "<p>(these last are packaged into the statement <code>IsCompl</code>)</p>",
        "id": 424338070,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709333423
    },
    {
        "content": "<p>Note that you're not using the fact that the lattice is complete in this case, as you only used finite lattice meets / joins</p>",
        "id": 424338965,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709333958
    },
    {
        "content": "<p>That sounds like a fair summary to me</p>",
        "id": 424338987,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709333977
    },
    {
        "content": "<p>We'd use the complete versions if we were dealing with infinite dimensional vector spaces?</p>",
        "id": 424339155,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709334038
    },
    {
        "content": "<p>No, only if you were talking about an infinite family of submodules rather than just two</p>",
        "id": 424339289,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709334115
    },
    {
        "content": "<p>I'd like to recover Axler's original definition: \"The sum <code>𝑉_1 + ⋯ + 𝑉_𝑚</code> is called a direct sum if each element of <code>𝑉_1 + ⋯ + 𝑉_𝑚</code> can be written in only one way as a sum <code>𝑣_1 + ⋯ + 𝑣_𝑚</code>, where each <code>𝑣_𝑘  ∈ 𝑉_𝑘</code>\"</p>\n<p>The existence of such a sum is given in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.mem_sup#doc\">docs#Submodule.mem_sup</a> -- is there any ready made proof for the uniqueness of that sum? (My intuition is that if the existence runs through <code>Codisjoint</code> the uniqueness runs through <code>Disjoint</code> but where I see a proof that the left and right of <code>IsCompl</code> are unique (e.g., <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsCompl.right_unique#doc\">docs#IsCompl.right_unique</a>) I don't see anything obvious that leads to the proof that the sum is unique).</p>",
        "id": 424429739,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709400634
    },
    {
        "content": "<p>I think the literal interpretation of this is to show that <code>Function.bijective (LinearMap.coprod P.subtype Q.subtype : P × Q →ₗ[R] M)</code></p>",
        "id": 424443741,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709411574
    },
    {
        "content": "<p>(<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.coprod#doc\">docs#LinearMap.coprod</a>)</p>",
        "id": 424443758,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709411596
    },
    {
        "content": "<p>Which says \"there is a two-sided inverse to the map that adds together the two pieces\"</p>",
        "id": 424443827,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709411662
    },
    {
        "content": "<p>(this is also the solution to the semimodule version I alluded to above)</p>",
        "id": 424443836,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709411680
    }
]