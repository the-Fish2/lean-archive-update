[
    {
        "content": "<p>Hi all,</p>\n<p>I have a bit of a weird induction problem - in the theorem <code>eval₂_one_eq_gauss</code> I am trying to prove that <code>(gauss n k).eval₂ (RingHom.id ℕ) 1 = choose n k</code>, i.e. the Gaussian binomial coefficients are equal to the regular binomial coefficients when evaluated at 1. However, when I do <code>induction' k</code> and <code>induction' n</code>, I get a hypothesis of the form <code>eval₂ (RingHom.id ℕ) 1 (gauss n k) = choose n k → eval₂ (RingHom.id ℕ) 1 (gauss n (succ k)) = choose n (succ k)</code>, when I would usually expect the two <code>induction'</code>s to produce hypothesis <code>eval₂ (RingHom.id ℕ) 1 (gauss n k) = choose n k</code> and <code>eval₂ (RingHom.id ℕ) 1 (gauss n (succ k)) = choose n (succ k)</code>. I assume I'm using <code>induction'</code> incorrectly?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">Copyright (c) 2024 Alena Gusakov. All rights reserved.</span>\n<span class=\"cm\">Released under Apache 2.0 license as described in the file LICENSE.</span>\n<span class=\"cm\">Authors: Alena Gusakov</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Factorial.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Polynomial.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Polynomial.Eval</span>\n\n<span class=\"bp\">#</span><span class=\"n\">align_import</span> <span class=\"n\">data.nat.choose.basic</span> <span class=\"k\">from</span> <span class=\"s2\">\"leanprover-community/mathlib\"</span><span class=\"bp\">@</span><span class=\"s2\">\"2f3994e1b117b1e1da49bcfb67334f33460c3ce4\"</span>\n<span class=\"bp\">#</span><span class=\"n\">align_import</span> <span class=\"n\">data.polynomial.basic</span> <span class=\"k\">from</span> <span class=\"s2\">\"leanprover-community/mathlib\"</span><span class=\"bp\">@</span><span class=\"s2\">\"949dc57e616a621462062668c9f39e4e17b64b69\"</span>\n\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\"># Gaussian Binomial Coefficients</span>\n\n<span class=\"cm\">This file defines Gaussian binomial coefficients and proves simple lemmas (i.e. those not</span>\n<span class=\"cm\">requiring more imports).</span>\n\n<span class=\"cm\">## Main definition and results</span>\n\n<span class=\"cm\">## Tags</span>\n\n<span class=\"cm\">gaussian binomial coefficient</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Nat</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Polynomial</span>\n\n<span class=\"c1\">-- polynomials? this should output a polynomial, not a nat</span>\n\n<span class=\"sd\">/-- `gauss n k` is the number of `k`-dimensional subspaces in an `n`-dimensional vector space.</span>\n<span class=\"sd\">Also known as Gaussian binomial coefficients. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">gauss</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">gauss</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"n\">k</span> <span class=\"bp\">*</span> <span class=\"n\">gauss</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">gauss_zero_right</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">gauss</span> <span class=\"n\">n</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">gauss_zero_succ</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">gauss</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">gauss_succ_succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">gauss</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">gauss</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"n\">k</span> <span class=\"bp\">*</span> <span class=\"n\">gauss</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">gauss_eq_zero_of_lt</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">},</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k</span> <span class=\"bp\">→</span> <span class=\"n\">gauss</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">hk</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">absurd</span> <span class=\"n\">hk</span> <span class=\"o\">(</span><span class=\"n\">Nat.not_lt_zero</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">gauss_zero_succ</span> <span class=\"n\">_</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">hk</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"k\">have</span> <span class=\"n\">hnk</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"n\">lt_of_succ_lt_succ</span> <span class=\"n\">hk</span>\n    <span class=\"k\">have</span> <span class=\"n\">hnk1</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">lt_of_succ_lt</span> <span class=\"n\">hk</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">gauss_succ_succ</span><span class=\"o\">,</span> <span class=\"n\">gauss_eq_zero_of_lt</span> <span class=\"n\">hnk</span><span class=\"o\">,</span> <span class=\"n\">gauss_eq_zero_of_lt</span> <span class=\"n\">hnk1</span><span class=\"o\">,</span> <span class=\"n\">mul_zero</span><span class=\"o\">,</span> <span class=\"n\">zero_add</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">gauss_self</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">gauss</span> <span class=\"n\">n</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">gauss</span><span class=\"o\">,</span> <span class=\"n\">gauss_eq_zero_of_lt</span> <span class=\"o\">(</span><span class=\"n\">lt_succ_self</span> <span class=\"n\">_</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">gauss_one_right</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">gauss</span> <span class=\"n\">n</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">gauss</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">eval₂_one_eq_gauss</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">gauss</span> <span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">eval₂</span> <span class=\"o\">(</span><span class=\"n\">RingHom.id</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">choose</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction'</span> <span class=\"n\">k</span> <span class=\"k\">with</span> <span class=\"n\">k</span> <span class=\"n\">hk</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">gauss_zero_right</span><span class=\"o\">,</span> <span class=\"n\">choose_zero_right</span><span class=\"o\">,</span> <span class=\"n\">eval₂_one</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">induction'</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">hn</span>\n    <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">gauss_succ_succ</span><span class=\"o\">,</span> <span class=\"n\">choose_succ_succ</span><span class=\"o\">,</span> <span class=\"n\">eval₂_add</span><span class=\"o\">,</span> <span class=\"n\">eval₂_mul</span><span class=\"o\">,</span> <span class=\"n\">eval₂_X_pow</span><span class=\"o\">,</span> <span class=\"n\">one_pow</span><span class=\"o\">,</span> <span class=\"n\">one_mul</span><span class=\"o\">,</span> <span class=\"n\">hk</span><span class=\"o\">]</span>\n      <span class=\"gr\">sorry</span>\n  <span class=\"c\">/-</span><span class=\"cm\">induction n with</span>\n<span class=\"cm\">  | zero =&gt;</span>\n<span class=\"cm\">    induction k with</span>\n<span class=\"cm\">    | zero =&gt;</span>\n<span class=\"cm\">      rw [gauss_self, choose_self, eval₂_one]</span>\n<span class=\"cm\">    | succ n ih =&gt;</span>\n<span class=\"cm\">      rw [gauss_zero_succ, choose_zero_succ, eval₂_zero]</span>\n<span class=\"cm\">  | succ n ihn =&gt;</span>\n<span class=\"cm\">    induction k with</span>\n<span class=\"cm\">    | zero =&gt;</span>\n<span class=\"cm\">      rw [gauss_zero_right, choose_zero_right, eval₂_one]</span>\n<span class=\"cm\">    | succ n ihk =&gt;</span>\n<span class=\"cm\">      rw [gauss_succ_succ, choose_succ_succ, eval₂_add, eval₂_mul, eval₂_X_pow, one_pow, one_mul,</span>\n<span class=\"cm\">        ihn, ihk]-/</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Nat</span>\n</code></pre></div>",
        "id": 419494773,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1706892204
    },
    {
        "content": "<p>I'm not sure I understand the question yet. If you're doing induction on k then sure you'll get a hypothesis of the form P(k)-&gt;P(succ k) which is exactly what you got. Let's define <code>P n k</code> to be <code>(gauss n k).eval₂ (RingHom.id ℕ) 1 = choose n k</code>. What exactly is your mathematical strat for proving <code>P n k</code> for all n and k? Maybe we can tease that strat into Lean.</p>",
        "id": 419535157,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706908019
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Help.20with.20double.20induction/near/419535157\">said</a>:</p>\n<blockquote>\n<p>What exactly is your mathematical strat for proving <code>P n k</code> for all n and k? Maybe we can tease that strat into Lean.</p>\n</blockquote>\n<p>So I wanted to do induction on both <code>n</code> and <code>k</code>. With the first induction I start with <code>k</code> because it's easier, and I want hypothesis <code>P n k</code> in order to prove <code>P n (succ k)</code>, which works fine. Then, within the proof of <code>P n (succ k)</code>, I want to do induction on <code>n</code> to get a new hypothesis <code>P n (succ k)</code> in order to prove <code>P (succ n) (succ k)</code>. I'll be able to prove <code>P (succ n) (succ k)</code> if I have those two hypotheses because I can transform <code>P (succ n) (succ k)</code> into the two goals <code>P n k</code> and <code>P n (succ k)</code>. </p>\n<p>Currently, when I do induction on <code>n</code> after doing induction on <code>k</code>, I get one hypothesis of the form <code>P (succ n) k</code>, and another in the form <code>P n k -&gt; P n (succ k)</code>, which is unhelpful</p>",
        "id": 419572588,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1706932517
    },
    {
        "content": "<p>I understand the question, though unfortunately I don't have an answer... there's something about <code>hk</code> that causes issues. If you add <code>clear hk</code> before the <code>induction' n</code> step, then you get <code>P n (succ k)</code> as expected, but now you've lost <code>hk</code>...</p>\n<p>or would <code>P n (succ k)</code> be sufficient?</p>",
        "id": 419576251,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706936007
    },
    {
        "content": "<p>No unfortunately I need both</p>",
        "id": 419576408,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1706936164
    },
    {
        "content": "<p>I can rewrite <code>P (succ n) (succ k)</code> only in terms of both <code>P n k</code> and <code>P n (succ k)</code></p>",
        "id": 419576461,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1706936198
    },
    {
        "content": "<p>Out of curiosity, is this just a quirk of Lean 4 induction? I feel like I remember being able to do induction over multiple variables in lean 3 without issue</p>",
        "id": 419576499,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1706936269
    },
    {
        "content": "<p>I don't think it's a new issue but I can't say for sure</p>",
        "id": 419577063,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706936788
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"303889\">@Alena Gusakov</span> this might be the wrong way to do this but I think you can get around the issue by doing <code>induction' k with k hk generalizing n</code> when you do induction on k</p>",
        "id": 419577409,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706937146
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/stream/113489-new-members/topic/Help.20with.20double.20induction/near/419577409\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"303889\">Alena Gusakov</span> this might be the wrong way to do this but I think you can get around the issue by doing <code>induction' k with k hk generalizing n</code> when you do induction on k</p>\n</blockquote>\n<p>That works, thanks!!! I swapped it around to do <code>induction' n with n hn generalizing k</code> and then did induction on <code>k</code></p>",
        "id": 419578621,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1706938482
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303889\">Alena Gusakov</span> <a href=\"#narrow/stream/113489-new-members/topic/Help.20with.20double.20induction/near/419572588\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Help.20with.20double.20induction/near/419535157\">said</a>:</p>\n<blockquote>\n<p>What exactly is your mathematical strat for proving <code>P n k</code> for all n and k? Maybe we can tease that strat into Lean.</p>\n</blockquote>\n<p>So I wanted to do induction on both <code>n</code> and <code>k</code>. With the first induction I start with <code>k</code> because it's easier, and I want hypothesis <code>P n k</code> in order to prove <code>P n (succ k)</code>, which works fine. Then, within the proof of <code>P n (succ k)</code>, I want to do induction on <code>n</code> to get a new hypothesis <code>P n (succ k)</code> in order to prove <code>P (succ n) (succ k)</code>. I'll be able to prove <code>P (succ n) (succ k)</code> if I have those two hypotheses because I can transform <code>P (succ n) (succ k)</code> into the two goals <code>P n k</code> and <code>P n (succ k)</code>. </p>\n<p>Currently, when I do induction on <code>n</code> after doing induction on <code>k</code>, I get one hypothesis of the form <code>P (succ n) k</code>, and another in the form <code>P n k -&gt; P n (succ k)</code>, which is unhelpful</p>\n</blockquote>\n<p>I think it might be enlightening to consider how we would explain this proof to undergraduates.  We teach undergraduates that induction is for proving statements of the form <code>∀n, P n</code>, not <code>P n</code>.  So I would tell an undergraduate that the theorem you are proving is <code>∀k, ∀n, P n k</code>.  You start with induction on <code>k</code>, and in the induction step, you introduce an arbitrary <code>k</code>, assume <code>hk : ∀n, P n k</code>, and try to prove <code>∀n, P n (succ k)</code>.  Notice that <code>hk</code> is <code>∀n, P n k</code>, not <code>P n k</code>; that will be important.  Now to prove <code>∀n, P n (succ k)</code>, you use induction again, and in the induction step, you introduce an arbitrary <code>n</code>, assume <code>P n (succ k)</code>, and try to prove <code>P (succ n) (succ k)</code>.  Now you can take the arbitrary <code>n</code> you just introduced and plug it into <code>hk</code> to conclude <code>P n k</code>.  Now you have what you need to prove <code>P (succ n) (succ k)</code>.  Notice that the <code>n</code> to which <code>hk</code> had to be applied wasn't available yet when <code>hk</code> was introduced; the arbitrary <code>n</code> wasn't introduced until the induction step of the induction on <code>n</code>.  So <code>hk</code> <em>had to</em> say <code>∀n, P n k</code>.</p>\n<p>To me, what this suggests is that the Lean approach to induction can be confusing.  For educational purposes, I think it would be good to have an induction tactic that proves <code>∀n, P n</code>, rather than <code>P n</code>.  (Is there such a tactic that I don't know about?)  I want to complete the analogy <code>induction</code> : <code>Nat.recOn</code> :: __ : <code>Nat.rec</code>.</p>",
        "id": 419724082,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1707074504
    },
    {
        "content": "<p>As I understand it, the suggestion to add <code>generalizing n</code> to the induction on <code>k</code> restores the <code>∀n</code> that was missing, solving the problem.</p>",
        "id": 419724214,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1707074604
    }
]