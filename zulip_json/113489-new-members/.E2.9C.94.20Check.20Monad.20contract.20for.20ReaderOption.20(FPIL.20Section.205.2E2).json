[
    {
        "content": "<p>Hi, I'm working through Functional Programming in Lean and I'm trying to verify the Monad contract for ReaderOption, which is an exercise in section 5.2 of FPIL. However, the second and third property don't seem to be verifiable by 'rfl', but also a more direct proof by unfolding didn't seem to work... any pointers? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ReaderOption</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">ρ</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ReaderOption.pure</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ReaderOption</span> <span class=\"n\">ρ</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ReaderOption.bind</span> <span class=\"o\">(</span><span class=\"n\">result</span> <span class=\"o\">:</span> <span class=\"n\">ReaderOption</span> <span class=\"n\">ρ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">next</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ReaderOption</span> <span class=\"n\">ρ</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ReaderOption</span> <span class=\"n\">ρ</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">env</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">result</span> <span class=\"n\">env</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">next</span> <span class=\"n\">x</span> <span class=\"n\">env</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Monad</span> <span class=\"o\">(</span><span class=\"n\">ReaderOption</span> <span class=\"n\">ρ</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">pure</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">ReaderOption.pure</span> <span class=\"n\">x</span>\n  <span class=\"n\">bind</span> <span class=\"n\">first</span> <span class=\"n\">next</span> <span class=\"o\">:=</span> <span class=\"n\">ReaderOption.bind</span> <span class=\"n\">first</span> <span class=\"n\">next</span>\n\n<span class=\"c1\">-- We prove bind (pure v) f = f v</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">readerOptionMonadLaw1</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ReaderOption</span> <span class=\"n\">ρ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"n\">v</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- We prove bind v pure = v</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">readerOptionMonadLaw2</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ReaderOption</span> <span class=\"n\">ρ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">pure</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- this fails</span>\n\n<span class=\"c1\">-- We prove bind (bind v f) g = bind v (fun x =&gt; bind (f x) g)</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">readerOptionMonadLaw3</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ReaderOption</span> <span class=\"n\">ρ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ReaderOption</span> <span class=\"n\">ρ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ReaderOption</span> <span class=\"n\">ρ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">f</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- this fails</span>\n</code></pre></div>",
        "id": 425187118,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1709762949
    },
    {
        "content": "<p>My guess is that the definition with the <code>match</code> in will not be giving you <code>rfl</code> lemmas. Try <code>simp [ReaderOption.bind]</code> instead? The equation lemmas will be true, but just not <code>rfl</code>, but they will be tagged <code>@[simp]</code>.</p>",
        "id": 425243404,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709797040
    },
    {
        "content": "<p>Unfortunately, that gives me no progress for me. <code>simp [pure]</code> and <code>simp [bind]</code> does a little bit, but I'm still not sure how to close the goal from there...</p>",
        "id": 425255422,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1709801895
    },
    {
        "content": "<p>use simp over <code>ReaderOption.bind</code> seems to work.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- We prove bind v pure = v</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">readerOptionMonadLaw2</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ReaderOption</span> <span class=\"n\">ρ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">pure</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">funext</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span>\n  <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">bind</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">ReaderOption.bind</span><span class=\"o\">]</span>\n  <span class=\"n\">cases</span> <span class=\"n\">v</span> <span class=\"n\">x</span>\n  <span class=\"n\">rfl</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 425261927,
        "sender_full_name": "Xiyu Zhai",
        "timestamp": 1709804192
    },
    {
        "content": "<p>thank you! I wasn't excepting that it would involve so many steps, thank you!</p>",
        "id": 425263183,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1709804603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"673728\">Josha Dekker</span> has marked this topic as resolved.</p>",
        "id": 425263232,
        "sender_full_name": "Notification Bot",
        "timestamp": 1709804614
    },
    {
        "content": "<p>I'm a newbie so it might not be that complicated</p>",
        "id": 425263391,
        "sender_full_name": "Xiyu Zhai",
        "timestamp": 1709804647
    },
    {
        "content": "<p>The same also proves the third law, so that is nice!</p>",
        "id": 425263941,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1709804789
    },
    {
        "content": "<p>I have a feeling the way lean proves things is best suited for computer science. These simps just work! Basically many formal verification problems in cs are just unfolding definitions. For mathematics though, I would believe better methods that complements lean exist. I would say inequality rewrites in lean isn't that convenient.</p>",
        "id": 425264524,
        "sender_full_name": "Xiyu Zhai",
        "timestamp": 1709804949
    }
]