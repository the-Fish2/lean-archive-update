[
    {
        "content": "<p>Hello,</p>\n<p>I am trying to understand Lean's type theory and have 2 small questions.</p>\n<p>1) Statements which begin with a universal quantifier are an example of dependent function types. Are there other examples of dependent function types which are not statements of this kind?</p>\n<p>2) From what I have understood, the mathematical equality corresponds to the definitional equality in Lean and \"Eq\" just gives us the symbol \"=\" needed to write statements (because its unique constructor only allows use to prove the statement \"a = a\"). Am I misunderstanding?</p>",
        "id": 411015837,
        "sender_full_name": "Emilie Uthaiwat",
        "timestamp": 1704289048
    },
    {
        "content": "<p>Mathematical equality is <code>=</code> but <code>=</code> is not definitional equality -- definitional equality is when the proof is <code>rfl</code> and this is essentially never true for equalities in advanced mathematics.</p>",
        "id": 411018170,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704290057
    },
    {
        "content": "<blockquote>\n<p>1) Statements which begin with a universal quantifier are an example of dependent function types. Are there other examples of dependent function types which are not statements of this kind?</p>\n</blockquote>\n<p>Generally speaking all functions that take some value which appears later on in the the type are dependent functions. To take a more programmingy example: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.get#doc\">docs#Array.get</a> takes an <code> (a : Array α)</code> and then later a value that depends on <code>a</code>: <code> (i : Fin (Array.size a))</code></p>\n<blockquote>\n<p>2) From what I have understood, the mathematical equality corresponds to the definitional equality in Lean and \"Eq\" just gives us the symbol \"=\" needed to write statements (because its unique constructor only allows use to prove the statement \"a = a\"). Am I misunderstanding?</p>\n</blockquote>\n<p>If you can prove something by just using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Eq.refl#doc\">docs#Eq.refl</a> it is definitionally equal yes, but usually there are a lot more things involved to get you to the point where you can use Eq.refl. If you want a precise definition of definitional equality and the whole type theory stuff check out Mario's thesis: <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a></p>",
        "id": 411021318,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1704291266
    },
    {
        "content": "<p>For a simple example of something that is true but not \"true by definition\": <code>1 + n = n + 1</code> is not true by <code>rfl</code> even though you can prove it by induction on <code>n</code></p>",
        "id": 411021611,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704291388
    },
    {
        "content": "<p>I was wondering the other day - is there a way to make it so, somehow? Obviously nothing resembling our current definition...</p>",
        "id": 411024812,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704292535
    },
    {
        "content": "<p>there is only one case I know of where you get an identity as a \"surprising defeq\", namely <code>(f ∘ g) ∘ h = f ∘ (g ∘ h)</code>. However I don't know how to turn this example into one that is definitionally commutative instead of associative</p>",
        "id": 411025967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704293024
    },
    {
        "content": "<p>Thank you for your answers! So, rfl uses the reduction rules of the lambda calculus. Is this right?</p>",
        "id": 411034840,
        "sender_full_name": "Emilie Uthaiwat",
        "timestamp": 1704296416
    },
    {
        "content": "<p>Alright, thank you!</p>",
        "id": 411035247,
        "sender_full_name": "Emilie Uthaiwat",
        "timestamp": 1704296588
    }
]