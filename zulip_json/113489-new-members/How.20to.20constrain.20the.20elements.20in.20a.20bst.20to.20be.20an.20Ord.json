[
    {
        "content": "<p>I am trying to implement a BST and I want to implement a member function, it looks like the following</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span> <span class=\"n\">BinarySearchTree</span>\n  <span class=\"kd\">inductive</span> <span class=\"n\">Tree</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>  <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Empty</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">Œ±</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Node</span>  <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">Œ±</span> <span class=\"bp\">√ó</span> <span class=\"n\">Œ±</span> <span class=\"bp\">√ó</span> <span class=\"n\">Tree</span> <span class=\"n\">Œ±</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Tree</span> <span class=\"n\">Œ±</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">member</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ord</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">Tree.Empty</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n    <span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">Tree.Node</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"n\">member</span> <span class=\"n\">x</span> <span class=\"n\">a</span>\n      <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"n\">member</span> <span class=\"n\">x</span> <span class=\"n\">b</span>\n      <span class=\"k\">else</span> <span class=\"n\">true</span>\n<span class=\"kd\">end</span> <span class=\"n\">BinarySearchTree</span>\n</code></pre></div>\n<p>There is still an issue where x and y don't have an implementation of LT </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"kd\">instance</span>\n  <span class=\"n\">LT</span> <span class=\"n\">Œ±</span>\n</code></pre></div>\n<p>how do I add an Ord constrain in Tree, deriving doesn't work</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>failed<span class=\"w\"> </span>to<span class=\"w\"> </span>synthesize<span class=\"w\"> </span>instance\n<span class=\"w\">  </span>Ord<span class=\"w\"> </span><span class=\"o\">(</span>Tree<span class=\"w\"> </span>Œ±‚úù<span class=\"w\"> </span>√ó<span class=\"w\"> </span>Œ±‚úù<span class=\"w\"> </span>√ó<span class=\"w\"> </span>Tree<span class=\"w\"> </span>Œ±‚úù<span class=\"o\">)</span>Lean<span class=\"w\"> </span><span class=\"m\">4</span>\nOrd.<span class=\"o\">{</span>u<span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span>Œ±<span class=\"w\"> </span>:<span class=\"w\"> </span>Type<span class=\"w\"> </span>u<span class=\"o\">)</span><span class=\"w\"> </span>:<span class=\"w\"> </span>Type<span class=\"w\"> </span>u\n</code></pre></div>",
        "id": 439424955,
        "sender_full_name": "Shubham Kumar ü¶Ä (he/him)",
        "timestamp": 1716111589
    },
    {
        "content": "<p>Some general advice for the second part of the question, you're almost always going to get better results by un-tupling arguments to inductives/constructors, in this case changing <code>Tree.Node</code> to 'uncurry' it makes <code>deriving Ord</code> work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kd\">inductive</span> <span class=\"n\">Tree</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Empty</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">Œ±</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Node</span>  <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Tree</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Tree</span> <span class=\"n\">Œ±</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Ord</span>\n</code></pre></div>\n<p>To the first part, I think <code>Ord</code> doesn't get you an _instance_ of <code>LT</code> unless you ask for it to be an instance (ltOfOrd is a definition). So I think without that, the play is to use what functionality is built in to <code>Ord</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kd\">def</span> <span class=\"n\">member</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ord</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">Tree.Empty</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n    <span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">Tree.Node</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">match</span> <span class=\"n\">Ord.compare</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">lt</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">member</span> <span class=\"n\">x</span> <span class=\"n\">a</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">gt</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">member</span> <span class=\"n\">x</span> <span class=\"n\">b</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span>\n</code></pre></div>",
        "id": 439438173,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1716125041
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris Bailey</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20constrain.20the.20elements.20in.20a.20bst.20to.20be.20an.20Ord/near/439438173\">said</a>:</p>\n<blockquote>\n<p>Some general advice for the second part of the question, you're almost always going to get better results by un-tupling arguments to inductives/constructors, in this case changing <code>Tree.Node</code> to 'uncurry' it makes <code>deriving Ord</code> work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kd\">inductive</span> <span class=\"n\">Tree</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Empty</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">Œ±</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Node</span>  <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Tree</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Tree</span> <span class=\"n\">Œ±</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Ord</span>\n</code></pre></div>\n<p>To the first part, I think <code>Ord</code> doesn't get you an _instance_ of <code>LT</code> unless you ask for it to be an instance (ltOfOrd is a definition). So I think without that, the play is to use what functionality is built in to <code>Ord</code>:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kd\">def</span> <span class=\"n\">member</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ord</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">Tree.Empty</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n    <span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">Tree.Node</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">match</span> <span class=\"n\">Ord.compare</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">lt</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">member</span> <span class=\"n\">x</span> <span class=\"n\">a</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">gt</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">member</span> <span class=\"n\">x</span> <span class=\"n\">b</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thanks! this makes more sense I'll make the changes!</p>",
        "id": 439549541,
        "sender_full_name": "Shubham Kumar ü¶Ä (he/him)",
        "timestamp": 1716202712
    }
]