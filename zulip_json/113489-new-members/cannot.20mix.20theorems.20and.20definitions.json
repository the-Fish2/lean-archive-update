[
    {
        "content": "<p>Hello! I noticed I cannot use mutual on a function with a theorem.<br>\nI want to write a recursive function, that uses a theorem about itself.<br>\nIs there any way to do that?</p>",
        "id": 422274877,
        "sender_full_name": "Yiftach S",
        "timestamp": 1708361031
    },
    {
        "content": "<p>Can you provide a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>? Without knowing your exact problem, I guess it might help to define a function to a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subtype#doc\">docs#Subtype</a>.</p>",
        "id": 422290775,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1708368795
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/113489-new-members/topic/cannot.20mix.20theorems.20and.20definitions/near/422290775\">said</a>:</p>\n<blockquote>\n<p>Can you provide a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>? Without knowing your exact problem, I guess it might help to define a function to a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subtype#doc\">docs#Subtype</a>.</p>\n</blockquote>\n<p>Sure thing. My full code is much longer, but this a simplification of the issue:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">MyBinTree</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">:</span> <span class=\"n\">MyBinTree</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">:</span> <span class=\"n\">MyBinTree</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">MyBinTree.sizeOf</span> <span class=\"o\">:</span> <span class=\"n\">MyBinTree</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">l</span> <span class=\"n\">_</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">l.sizeOf</span> <span class=\"bp\">+</span> <span class=\"n\">r.sizeOf</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">func</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">MyBinTree</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyBinTree</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">left</span> <span class=\"n\">key</span> <span class=\"n\">right</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">t1</span> <span class=\"o\">:=</span> <span class=\"n\">func</span> <span class=\"n\">left</span>\n    <span class=\"c1\">-- Here I'd like to use func_size, but func and func_size cannot be mutual</span>\n    <span class=\"k\">have</span> <span class=\"n\">help</span> <span class=\"o\">:</span> <span class=\"n\">left.sizeOf</span> <span class=\"bp\">=</span> <span class=\"n\">t1.sizeOf</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"n\">t</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">func_size</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">MyBinTree</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t.sizeOf</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">func</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sizeOf</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 422293643,
        "sender_full_name": "Yiftach S",
        "timestamp": 1708370335
    },
    {
        "content": "<p>In your example the constructors of MyBinTree doesn't require any proofs, so it's not clear why you'd like to use a theorem to define <code>func</code>. Can you not define <code>func</code> first and prove <code>func_size</code> later? If not then I'm afraid I can't provide suggestions without a more detailed example that include the essential difficulty.</p>",
        "id": 422295564,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1708371374
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/113489-new-members/topic/cannot.20mix.20theorems.20and.20definitions/near/422295564\">said</a>:</p>\n<blockquote>\n<p>In your example the constructors of MyBinTree doesn't require any proofs, so it's not clear why you'd like to use a theorem to define <code>func</code>. Can you not define <code>func</code> first and prove <code>func_size</code> later? If not then I'm afraid I can't provide suggestions without a more detailed example that include the essential difficulty.</p>\n</blockquote>\n<p>Thanks. The issue is that func is recursive, and it needs a proof about what it does in order to work.<br>\nI'll also add my actual problem, but it's rather long so I thought that the shorter version might be easier to respond to.<br>\nThe problems are marked with \"TODO\".</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Linarith</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Order.Monoid.Lemmas</span>\n\n\n<span class=\"kd\">inductive</span> <span class=\"n\">TreeBin</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">TreeBin.repr</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span> <span class=\"bp\">→</span> <span class=\"n\">String</span>\n<span class=\"bp\">|</span> <span class=\"n\">TreeBin.leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"\"</span> <span class=\"c1\">--\".\"</span>\n<span class=\"bp\">|</span> <span class=\"n\">TreeBin.node</span> <span class=\"n\">l</span> <span class=\"n\">k</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"(\"</span> <span class=\"bp\">++</span> <span class=\"n\">TreeBin.repr</span> <span class=\"n\">l</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">Nat.repr</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"n\">TreeBin.repr</span> <span class=\"n\">r</span> <span class=\"bp\">++</span> <span class=\"s2\">\")\"</span>\n\n\n\n<span class=\"kd\">def</span> <span class=\"n\">TreeBin.sizeOf</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">l</span> <span class=\"n\">_</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">l.sizeOf</span> <span class=\"bp\">+</span> <span class=\"n\">r.sizeOf</span>\n\n\n<span class=\"c1\">-- t1 ≤ t2 definition by key</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">LE</span> <span class=\"n\">TreeBin</span> <span class=\"n\">where</span>\n  <span class=\"n\">le</span> <span class=\"n\">t1</span> <span class=\"n\">t2</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">t1</span><span class=\"o\">,</span> <span class=\"n\">t2</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">_</span> <span class=\"n\">k1</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">_</span> <span class=\"n\">k2</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">k1</span> <span class=\"bp\">≤</span> <span class=\"n\">k2</span>\n\n\n<span class=\"c1\">-- Unfolding TreeBin comparison</span>\n<span class=\"n\">macro</span> <span class=\"s2\">\"unfold_ge\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">unfold</span> <span class=\"n\">GE.ge</span> <span class=\"n\">LE.le</span> <span class=\"n\">instLETreeBin</span><span class=\"o\">))</span>\n<span class=\"n\">macro</span> <span class=\"s2\">\"unfold_le\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">unfold</span> <span class=\"n\">LE.le</span> <span class=\"n\">instLETreeBin</span><span class=\"o\">))</span>\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">not_ge</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">≥</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">≥</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"k\">match</span> <span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">unfold_ge</span><span class=\"bp\">;</span> <span class=\"n\">trivial</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">let</span> <span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">≥</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n                          <span class=\"k\">let</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≥</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">unfold_ge</span><span class=\"bp\">;</span> <span class=\"n\">trivial</span>\n                          <span class=\"n\">exact</span> <span class=\"n\">absurd</span> <span class=\"n\">h2</span> <span class=\"n\">h3</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">_</span> <span class=\"n\">k1</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">_</span> <span class=\"n\">k2</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">unfold_ge</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n                                  <span class=\"gr\">sorry</span>\n\n\n\n<span class=\"c1\">-- LE is decidable</span>\n<span class=\"kd\">instance</span> <span class=\"n\">TreeBin.decLE</span> <span class=\"o\">(</span><span class=\"n\">t₁</span> <span class=\"n\">t₂</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">t₁</span> <span class=\"bp\">≤</span> <span class=\"n\">t₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">t₁</span><span class=\"o\">,</span> <span class=\"n\">t₂</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LE.le</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">isTrue</span> <span class=\"n\">True.intro</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span>  <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LE.le</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">isFalse</span> <span class=\"n\">False.elim</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">_</span> <span class=\"n\">k1</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">_</span> <span class=\"n\">k2</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.decLe</span> <span class=\"n\">k1</span> <span class=\"n\">k2</span>\n\n\n<span class=\"c1\">-- Local max heap definition - the node doesn't have direct children that are bigger</span>\n<span class=\"kd\">def</span> <span class=\"n\">local_max</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">l</span> <span class=\"n\">_</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">≥</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">≥</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n\n\n<span class=\"c1\">-- local_max is decidable</span>\n<span class=\"kd\">instance</span> <span class=\"n\">decidable_local_max</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">local_max</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">local_max</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">isTrue</span> <span class=\"n\">True.intro</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">l</span> <span class=\"n\">_</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">instDecidableAnd</span>\n\n\n<span class=\"c1\">-- max heap condition - local_max and children are also max heaps</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">is_max_heap</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">:</span> <span class=\"n\">is_max_heap</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span>\n <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">:</span> <span class=\"n\">local_max</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">left</span> <span class=\"n\">key</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n          <span class=\"n\">is_max_heap</span> <span class=\"n\">left</span> <span class=\"bp\">→</span> <span class=\"n\">is_max_heap</span> <span class=\"n\">right</span> <span class=\"bp\">→</span>\n          <span class=\"n\">is_max_heap</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">left</span> <span class=\"n\">key</span> <span class=\"n\">right</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">MaxHeap</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span> <span class=\"bp\">//</span> <span class=\"n\">is_max_heap</span> <span class=\"n\">t</span> <span class=\"o\">}</span>\n\n\n<span class=\"c1\">-- Proof that LE is transitive for TreeBin</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">trans_le</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span>\n  <span class=\"n\">cases</span> <span class=\"n\">a</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">trivial</span> <span class=\"c1\">-- A leaf is always little</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"n\">al</span> <span class=\"n\">ak</span> <span class=\"n\">ar</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">cases</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">trivial</span> <span class=\"c1\">-- b being a leaf contradicts a ≤ b</span>\n    <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"n\">bl</span> <span class=\"n\">bk</span> <span class=\"n\">br</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">cases</span> <span class=\"n\">c</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">trivial</span> <span class=\"c1\">-- c being a leaf contradicts b ≤ c</span>\n      <span class=\"c1\">-- All 3 are nodes, so this is the final case which is simply comparing numbers</span>\n      <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"n\">cl</span> <span class=\"n\">ck</span> <span class=\"n\">cr</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">Nat.le_trans</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span>\n\n<span class=\"c1\">-- Make lean use trans_le</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Trans</span> <span class=\"o\">(</span><span class=\"n\">LE.le</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span> <span class=\"bp\">→</span> <span class=\"n\">TreeBin</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">LE.le</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span> <span class=\"bp\">→</span> <span class=\"n\">TreeBin</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">LE.le</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span> <span class=\"bp\">→</span> <span class=\"n\">TreeBin</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">trans</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">trans_le</span> <span class=\"n\">p</span> <span class=\"n\">q</span>\n\n<span class=\"c1\">-- Same but for GE</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Trans</span> <span class=\"o\">(</span><span class=\"n\">GE.ge</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span> <span class=\"bp\">→</span> <span class=\"n\">TreeBin</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">GE.ge</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span> <span class=\"bp\">→</span> <span class=\"n\">TreeBin</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">GE.ge</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span> <span class=\"bp\">→</span> <span class=\"n\">TreeBin</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">trans</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">trans_le</span> <span class=\"n\">q</span> <span class=\"n\">p</span>\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">plus_le1</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">linarith</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">plus_le2</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">linarith</span>\n\n\n<span class=\"c1\">-- Convert a TreeBin to a heap recursively</span>\n<span class=\"kd\">def</span> <span class=\"n\">heapify</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MaxHeap</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">is_max_heap.leaf</span><span class=\"o\">]⟩</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">left</span> <span class=\"n\">key</span> <span class=\"n\">right</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"c1\">-- used to prove termination</span>\n    <span class=\"k\">have</span> <span class=\"n\">left_l_t</span> <span class=\"o\">:</span> <span class=\"n\">left.sizeOf</span> <span class=\"bp\">&lt;</span> <span class=\"n\">t.sizeOf</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">conv</span> <span class=\"k\">in</span> <span class=\"n\">TreeBin.sizeOf</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">unfold</span> <span class=\"n\">TreeBin.sizeOf</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">plus_le1</span><span class=\"o\">]</span>\n    <span class=\"k\">have</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">right.sizeOf</span> <span class=\"bp\">&lt;</span> <span class=\"n\">t.sizeOf</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">conv</span> <span class=\"k\">in</span> <span class=\"n\">TreeBin.sizeOf</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">unfold</span> <span class=\"n\">TreeBin.sizeOf</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">plus_le2</span><span class=\"o\">]</span>\n    <span class=\"c1\">-- recursively heapify children</span>\n    <span class=\"k\">let</span> <span class=\"n\">l1</span> <span class=\"o\">:=</span> <span class=\"n\">heapify</span> <span class=\"n\">left</span>\n    <span class=\"k\">let</span> <span class=\"n\">r1</span> <span class=\"o\">:=</span> <span class=\"n\">heapify</span> <span class=\"n\">right</span>\n    <span class=\"c1\">-- a default return value in case local_max is OK</span>\n    <span class=\"k\">let</span> <span class=\"n\">ret_t_default</span> <span class=\"o\">:=</span> <span class=\"n\">TreeBin.node</span> <span class=\"n\">l1.val</span> <span class=\"n\">key</span> <span class=\"n\">r1.val</span>\n    <span class=\"k\">if</span> <span class=\"n\">default_local_max</span> <span class=\"o\">:</span> <span class=\"n\">local_max</span> <span class=\"n\">ret_t_default</span> <span class=\"k\">then</span>\n      <span class=\"o\">⟨</span><span class=\"n\">ret_t_default</span><span class=\"o\">,</span> <span class=\"kd\">by</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">is_max_heap.node</span><span class=\"o\">,</span> <span class=\"n\">default_local_max</span><span class=\"o\">,</span> <span class=\"n\">l1.property</span><span class=\"o\">,</span> <span class=\"n\">r1.property</span><span class=\"o\">]⟩</span>\n    <span class=\"c1\">-- Second case l2 on top</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">l1_ge_r1</span> <span class=\"o\">:</span> <span class=\"n\">l1.val</span> <span class=\"bp\">≥</span> <span class=\"n\">r1.val</span> <span class=\"k\">then</span>\n      <span class=\"k\">match</span> <span class=\"n\">hl1</span> <span class=\"o\">:</span> <span class=\"n\">l1.val</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>  <span class=\"c1\">-- l1 being a leaf is absurd</span>\n        <span class=\"k\">have</span> <span class=\"n\">ret_ge_l1</span> <span class=\"o\">:</span> <span class=\"n\">ret_t_default</span> <span class=\"bp\">≥</span> <span class=\"n\">l1.val</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">unfold_ge</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hl1</span><span class=\"o\">]</span>\n        <span class=\"k\">have</span> <span class=\"n\">ret_ge_r1</span> <span class=\"o\">:</span> <span class=\"n\">ret_t_default</span> <span class=\"bp\">≥</span> <span class=\"n\">r1.val</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"k\">calc</span> <span class=\"n\">_</span> <span class=\"bp\">≥</span> <span class=\"n\">l1.val</span> <span class=\"o\">:=</span> <span class=\"n\">ret_ge_l1</span>\n                                                           <span class=\"n\">_</span> <span class=\"bp\">≥</span> <span class=\"n\">r1.val</span> <span class=\"o\">:=</span> <span class=\"n\">l1_ge_r1</span>\n        <span class=\"k\">have</span> <span class=\"n\">ret_local_max</span> <span class=\"o\">:</span> <span class=\"n\">local_max</span> <span class=\"n\">ret_t_default</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">local_max</span><span class=\"o\">,</span> <span class=\"n\">ret_ge_l1</span><span class=\"o\">,</span> <span class=\"n\">ret_ge_r1</span><span class=\"o\">]</span>\n        <span class=\"n\">exact</span> <span class=\"n\">absurd</span> <span class=\"n\">ret_local_max</span> <span class=\"n\">default_local_max</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">ll</span> <span class=\"n\">lk</span> <span class=\"n\">lr</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">let</span> <span class=\"n\">l2_t</span> <span class=\"o\">:=</span> <span class=\"n\">TreeBin.node</span> <span class=\"n\">ll</span> <span class=\"n\">key</span> <span class=\"n\">lr</span>\n        <span class=\"k\">have</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">l2_t.sizeOf</span> <span class=\"bp\">&lt;</span> <span class=\"n\">t.sizeOf</span> <span class=\"o\">:=</span> <span class=\"k\">calc</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">l1.val.sizeOf</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">TreeBin.sizeOf</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hl1</span><span class=\"o\">]</span>\n                                                <span class=\"c1\">-- TODO: how to prove that heapify doesn't change the size?</span>\n                                                <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">left.sizeOf</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n                                                <span class=\"n\">_</span> <span class=\"bp\">&lt;</span> <span class=\"n\">t.sizeOf</span> <span class=\"o\">:=</span> <span class=\"n\">left_l_t</span>\n        <span class=\"k\">let</span> <span class=\"n\">l2</span> <span class=\"o\">:=</span> <span class=\"n\">heapify</span> <span class=\"n\">l2_t</span>\n        <span class=\"k\">let</span> <span class=\"n\">ret_t</span> <span class=\"o\">:=</span> <span class=\"n\">TreeBin.node</span> <span class=\"n\">l2.val</span> <span class=\"n\">lk</span> <span class=\"n\">r1.val</span>\n\n        <span class=\"c1\">-- TODO: I didn't manage to complete this proof.</span>\n        <span class=\"c1\">--       l2_t consists of ll + lr + key.</span>\n        <span class=\"c1\">--       key is smaller than lk because of default_local_max + l1_ge_r1.</span>\n        <span class=\"c1\">--       ll and lr are recursively smaller than lk because l1 is a max heap.</span>\n        <span class=\"c1\">--       This proves that l1 is greater than ANY value in l2_t, and heapify doesn't add any values.</span>\n        <span class=\"k\">have</span> <span class=\"n\">l1_ge_l2</span> <span class=\"o\">:</span> <span class=\"n\">l1.val</span> <span class=\"bp\">≥</span> <span class=\"n\">l2.val</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n        <span class=\"k\">let</span> <span class=\"n\">local_max_ret_t</span> <span class=\"o\">:</span> <span class=\"n\">local_max</span> <span class=\"n\">ret_t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n          <span class=\"n\">unfold</span> <span class=\"n\">local_max</span><span class=\"bp\">;</span>\n          <span class=\"n\">apply</span> <span class=\"n\">And.intro</span>\n          <span class=\"bp\">·</span> <span class=\"k\">calc</span> <span class=\"n\">ret_t</span> <span class=\"bp\">≥</span> <span class=\"n\">l1.val</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">unfold_ge</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hl1</span><span class=\"o\">]</span>\n                 <span class=\"n\">_</span> <span class=\"bp\">≥</span> <span class=\"n\">l2.val</span> <span class=\"o\">:=</span> <span class=\"n\">l1_ge_l2</span>\n          <span class=\"bp\">·</span> <span class=\"k\">calc</span> <span class=\"n\">ret_t</span> <span class=\"bp\">≥</span> <span class=\"n\">l1.val</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">unfold_ge</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hl1</span><span class=\"o\">]</span>  <span class=\"c1\">-- Same key</span>\n                 <span class=\"n\">_</span> <span class=\"bp\">≥</span> <span class=\"n\">r1.val</span> <span class=\"o\">:=</span> <span class=\"n\">l1_ge_r1</span>\n        <span class=\"o\">}</span>\n        <span class=\"o\">⟨</span><span class=\"n\">ret_t</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">is_max_heap.node</span><span class=\"o\">,</span> <span class=\"n\">l2.property</span><span class=\"o\">,</span> <span class=\"n\">r1.property</span><span class=\"o\">,</span> <span class=\"n\">local_max_ret_t</span><span class=\"o\">]⟩</span>\n    <span class=\"c1\">-- Final case r1 on top</span>\n    <span class=\"c1\">-- I didn't bother with this as much, because the privious case is similar</span>\n    <span class=\"k\">else</span>\n      <span class=\"k\">match</span> <span class=\"n\">hr1</span> <span class=\"o\">:</span> <span class=\"n\">r1.val</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>  <span class=\"c1\">-- l1 being a leaf is absurd</span>\n        <span class=\"k\">have</span> <span class=\"n\">ret_ge_r1</span> <span class=\"o\">:</span> <span class=\"n\">ret_t_default</span> <span class=\"bp\">≥</span> <span class=\"n\">r1.val</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">unfold_ge</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hr1</span><span class=\"o\">]</span>\n        <span class=\"k\">have</span> <span class=\"n\">ret_ge_l1</span> <span class=\"o\">:</span> <span class=\"n\">ret_t_default</span> <span class=\"bp\">≥</span> <span class=\"n\">l1.val</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"k\">calc</span> <span class=\"n\">_</span> <span class=\"bp\">≥</span> <span class=\"n\">r1.val</span> <span class=\"o\">:=</span> <span class=\"n\">ret_ge_r1</span>\n                                                           <span class=\"n\">_</span> <span class=\"bp\">≥</span> <span class=\"n\">l1.val</span> <span class=\"o\">:=</span> <span class=\"n\">not_ge</span> <span class=\"n\">l1_ge_r1</span>\n        <span class=\"k\">have</span> <span class=\"n\">ret_local_max</span> <span class=\"o\">:</span> <span class=\"n\">local_max</span> <span class=\"n\">ret_t_default</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">local_max</span><span class=\"o\">,</span> <span class=\"n\">ret_ge_l1</span><span class=\"o\">,</span> <span class=\"n\">ret_ge_r1</span><span class=\"o\">]</span>\n        <span class=\"n\">exact</span> <span class=\"n\">absurd</span> <span class=\"n\">ret_local_max</span> <span class=\"n\">default_local_max</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">rl</span> <span class=\"n\">rk</span> <span class=\"n\">rr</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">let</span> <span class=\"n\">r2_t</span> <span class=\"o\">:=</span> <span class=\"n\">TreeBin.node</span> <span class=\"n\">rl</span> <span class=\"n\">key</span> <span class=\"n\">rr</span>\n        <span class=\"k\">have</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">r2_t.sizeOf</span> <span class=\"bp\">&lt;</span> <span class=\"n\">t.sizeOf</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n        <span class=\"k\">let</span> <span class=\"n\">r2</span> <span class=\"o\">:=</span> <span class=\"n\">heapify</span> <span class=\"n\">r2_t</span>\n        <span class=\"k\">let</span> <span class=\"n\">ret_t</span> <span class=\"o\">:=</span> <span class=\"n\">TreeBin.node</span> <span class=\"n\">l1.val</span> <span class=\"n\">rk</span> <span class=\"n\">r2.val</span>\n        <span class=\"k\">let</span> <span class=\"n\">local_max_ret_t</span> <span class=\"o\">:</span> <span class=\"n\">local_max</span> <span class=\"n\">ret_t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n        <span class=\"o\">⟨</span><span class=\"n\">ret_t</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">is_max_heap.node</span><span class=\"o\">,</span> <span class=\"n\">r2.property</span><span class=\"o\">,</span> <span class=\"n\">l1.property</span><span class=\"o\">,</span> <span class=\"n\">local_max_ret_t</span><span class=\"o\">]⟩</span>\n  <span class=\"n\">termination_by</span> <span class=\"n\">t.sizeOf</span>\n</code></pre></div>",
        "id": 422298225,
        "sender_full_name": "Yiftach S",
        "timestamp": 1708372805
    },
    {
        "content": "<p>I think Junyan's subtype suggestion would be to define <code>def heapifyAux (t : TreeBin) : {mh : MaxHeap // mh.val.sizeOf = t.sizeOf}</code> to interleave the proof with the definition.</p>",
        "id": 422299776,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708373613
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/cannot.20mix.20theorems.20and.20definitions/near/422299776\">said</a>:</p>\n<blockquote>\n<p>I think Junyan's subtype suggestion would be to define <code>def heapifyAux (t : TreeBin) : {mh : MaxHeap // mh.val.sizeOf = t.sizeOf}</code> to interleave the proof with the definition.</p>\n</blockquote>\n<p>Oh, I didn't realize you could define a subtype while returning it. This indeed solves the problem, Thanks!</p>\n<p>I still doubt I'll manage the second TODO (the long one).<br>\nI need to show that heapify doesn't change the values and adds something bigger than there used to be in the tree. Is there any elegant way to go about that?</p>",
        "id": 422302170,
        "sender_full_name": "Yiftach S",
        "timestamp": 1708374319
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 422315131,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1708381894
    },
    {
        "content": "<p>Hopefully this helps:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Define the set of values inductively. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">TreeBin.values</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∅</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">left</span> <span class=\"n\">key</span> <span class=\"n\">right</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">left.values</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">key</span><span class=\"o\">}</span> <span class=\"bp\">∪</span> <span class=\"n\">right.values</span>\n\n<span class=\"sd\">/-- Define `heapify` without incorporating the is_max_heap condition; it's easier to prove it separately. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">heapify</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span> <span class=\"bp\">//</span> <span class=\"n\">t'.sizeOf</span> <span class=\"bp\">=</span> <span class=\"n\">t.sizeOf</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">left</span> <span class=\"n\">key</span> <span class=\"n\">right</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">left.sizeOf</span> <span class=\"bp\">&lt;</span> <span class=\"n\">t.sizeOf</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">conv</span> <span class=\"k\">in</span> <span class=\"n\">TreeBin.sizeOf</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">unfold</span> <span class=\"n\">TreeBin.sizeOf</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">plus_le1</span><span class=\"o\">]</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">right.sizeOf</span> <span class=\"bp\">&lt;</span> <span class=\"n\">t.sizeOf</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">conv</span> <span class=\"k\">in</span> <span class=\"n\">TreeBin.sizeOf</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">unfold</span> <span class=\"n\">TreeBin.sizeOf</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">plus_le2</span><span class=\"o\">]</span>\n    <span class=\"k\">let</span> <span class=\"n\">l1</span> <span class=\"o\">:=</span> <span class=\"n\">heapify</span> <span class=\"n\">left</span>\n    <span class=\"k\">let</span> <span class=\"n\">r1</span> <span class=\"o\">:=</span> <span class=\"n\">heapify</span> <span class=\"n\">right</span>\n    <span class=\"k\">let</span> <span class=\"n\">ret_t_default</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span> <span class=\"bp\">//</span> <span class=\"n\">t'.sizeOf</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">TreeBin.node</span> <span class=\"n\">left</span> <span class=\"n\">key</span> <span class=\"n\">right</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sizeOf</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n      <span class=\"o\">⟨</span><span class=\"n\">TreeBin.node</span> <span class=\"n\">l1</span> <span class=\"n\">key</span> <span class=\"n\">r1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">TreeBin.sizeOf</span><span class=\"o\">,</span> <span class=\"n\">l1.2</span><span class=\"o\">,</span> <span class=\"n\">r1.2</span><span class=\"o\">]⟩</span>\n    <span class=\"k\">if</span> <span class=\"n\">local_max</span> <span class=\"n\">ret_t_default</span> <span class=\"k\">then</span> <span class=\"n\">ret_t_default</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">l1.val</span> <span class=\"bp\">≥</span> <span class=\"n\">r1.val</span> <span class=\"k\">then</span>\n      <span class=\"k\">match</span> <span class=\"n\">hl1</span> <span class=\"o\">:</span> <span class=\"n\">l1.val</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ret_t_default</span> <span class=\"c1\">-- this can't happen, you're free to put any value</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">ll</span> <span class=\"n\">lk</span> <span class=\"n\">lr</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">let</span> <span class=\"n\">l2_t</span> <span class=\"o\">:=</span> <span class=\"n\">TreeBin.node</span> <span class=\"n\">ll</span> <span class=\"n\">key</span> <span class=\"n\">lr</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">l2_t.sizeOf</span> <span class=\"bp\">&lt;</span> <span class=\"n\">t.sizeOf</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n          <span class=\"k\">have</span> <span class=\"n\">hl1</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"n\">TreeBin.sizeOf</span> <span class=\"n\">hl1</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">TreeBin.sizeOf</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hl1</span>\n          <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">TreeBin.sizeOf</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hl1</span><span class=\"o\">,</span> <span class=\"n\">l1.2</span><span class=\"o\">,</span> <span class=\"n\">plus_le1</span><span class=\"o\">]</span>\n        <span class=\"o\">⟨</span><span class=\"n\">TreeBin.node</span> <span class=\"o\">(</span><span class=\"n\">heapify</span> <span class=\"n\">l2_t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">lk</span> <span class=\"n\">r1</span><span class=\"o\">,</span> <span class=\"kd\">by</span>\n          <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">TreeBin.sizeOf</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">heapify</span> <span class=\"n\">l2_t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">r1.2</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">l1.2</span><span class=\"o\">,</span> <span class=\"n\">hl1</span><span class=\"o\">]⟩</span>\n    <span class=\"k\">else</span> <span class=\"k\">match</span> <span class=\"n\">hr1</span> <span class=\"o\">:</span> <span class=\"n\">r1.val</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ret_t_default</span> <span class=\"c1\">-- can't happen</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">rl</span> <span class=\"n\">rk</span> <span class=\"n\">rr</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">let</span> <span class=\"n\">r2_t</span> <span class=\"o\">:=</span> <span class=\"n\">TreeBin.node</span> <span class=\"n\">rl</span> <span class=\"n\">key</span> <span class=\"n\">rr</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">r2_t.sizeOf</span> <span class=\"bp\">&lt;</span> <span class=\"n\">t.sizeOf</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n          <span class=\"k\">have</span> <span class=\"n\">hr1</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"n\">TreeBin.sizeOf</span> <span class=\"n\">hr1</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">TreeBin.sizeOf</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hr1</span>\n          <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">TreeBin.sizeOf</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hr1</span><span class=\"o\">,</span> <span class=\"n\">r1.2</span><span class=\"o\">,</span> <span class=\"n\">plus_le2</span><span class=\"o\">]</span>\n        <span class=\"o\">⟨</span><span class=\"n\">TreeBin.node</span> <span class=\"n\">l1</span> <span class=\"n\">rk</span> <span class=\"o\">(</span><span class=\"n\">heapify</span> <span class=\"n\">r2_t</span><span class=\"o\">),</span> <span class=\"kd\">by</span>\n          <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">TreeBin.sizeOf</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">heapify</span> <span class=\"n\">r2_t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">l1.2</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">r1.2</span><span class=\"o\">,</span> <span class=\"n\">hr1</span><span class=\"o\">]⟩</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">t.sizeOf</span>\n\n<span class=\"sd\">/-- We can now state the fact that `heapify` preserves the set of values. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">values_heapify</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">heapify</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">values</span> <span class=\"bp\">=</span> <span class=\"n\">t.values</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 422315280,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1708381988
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/113489-new-members/topic/cannot.20mix.20theorems.20and.20definitions/near/422315280\">said</a>:</p>\n<blockquote>\n<p>Hopefully this helps:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Define the set of values inductively. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">TreeBin.values</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∅</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">left</span> <span class=\"n\">key</span> <span class=\"n\">right</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">left.values</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">key</span><span class=\"o\">}</span> <span class=\"bp\">∪</span> <span class=\"n\">right.values</span>\n\n<span class=\"sd\">/-- Define `heapify` without incorporating the is_max_heap condition; it's easier to prove it separately. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">heapify</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span> <span class=\"bp\">//</span> <span class=\"n\">t'.sizeOf</span> <span class=\"bp\">=</span> <span class=\"n\">t.sizeOf</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">left</span> <span class=\"n\">key</span> <span class=\"n\">right</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">left.sizeOf</span> <span class=\"bp\">&lt;</span> <span class=\"n\">t.sizeOf</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">conv</span> <span class=\"k\">in</span> <span class=\"n\">TreeBin.sizeOf</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">unfold</span> <span class=\"n\">TreeBin.sizeOf</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">plus_le1</span><span class=\"o\">]</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">right.sizeOf</span> <span class=\"bp\">&lt;</span> <span class=\"n\">t.sizeOf</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">conv</span> <span class=\"k\">in</span> <span class=\"n\">TreeBin.sizeOf</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">unfold</span> <span class=\"n\">TreeBin.sizeOf</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">plus_le2</span><span class=\"o\">]</span>\n    <span class=\"k\">let</span> <span class=\"n\">l1</span> <span class=\"o\">:=</span> <span class=\"n\">heapify</span> <span class=\"n\">left</span>\n    <span class=\"k\">let</span> <span class=\"n\">r1</span> <span class=\"o\">:=</span> <span class=\"n\">heapify</span> <span class=\"n\">right</span>\n    <span class=\"k\">let</span> <span class=\"n\">ret_t_default</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span> <span class=\"bp\">//</span> <span class=\"n\">t'.sizeOf</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">TreeBin.node</span> <span class=\"n\">left</span> <span class=\"n\">key</span> <span class=\"n\">right</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sizeOf</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n      <span class=\"o\">⟨</span><span class=\"n\">TreeBin.node</span> <span class=\"n\">l1</span> <span class=\"n\">key</span> <span class=\"n\">r1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">TreeBin.sizeOf</span><span class=\"o\">,</span> <span class=\"n\">l1.2</span><span class=\"o\">,</span> <span class=\"n\">r1.2</span><span class=\"o\">]⟩</span>\n    <span class=\"k\">if</span> <span class=\"n\">local_max</span> <span class=\"n\">ret_t_default</span> <span class=\"k\">then</span> <span class=\"n\">ret_t_default</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">l1.val</span> <span class=\"bp\">≥</span> <span class=\"n\">r1.val</span> <span class=\"k\">then</span>\n      <span class=\"k\">match</span> <span class=\"n\">hl1</span> <span class=\"o\">:</span> <span class=\"n\">l1.val</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ret_t_default</span> <span class=\"c1\">-- this can't happen, you're free to put any value</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">ll</span> <span class=\"n\">lk</span> <span class=\"n\">lr</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">let</span> <span class=\"n\">l2_t</span> <span class=\"o\">:=</span> <span class=\"n\">TreeBin.node</span> <span class=\"n\">ll</span> <span class=\"n\">key</span> <span class=\"n\">lr</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">l2_t.sizeOf</span> <span class=\"bp\">&lt;</span> <span class=\"n\">t.sizeOf</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n          <span class=\"k\">have</span> <span class=\"n\">hl1</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"n\">TreeBin.sizeOf</span> <span class=\"n\">hl1</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">TreeBin.sizeOf</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hl1</span>\n          <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">TreeBin.sizeOf</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hl1</span><span class=\"o\">,</span> <span class=\"n\">l1.2</span><span class=\"o\">,</span> <span class=\"n\">plus_le1</span><span class=\"o\">]</span>\n        <span class=\"o\">⟨</span><span class=\"n\">TreeBin.node</span> <span class=\"o\">(</span><span class=\"n\">heapify</span> <span class=\"n\">l2_t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">lk</span> <span class=\"n\">r1</span><span class=\"o\">,</span> <span class=\"kd\">by</span>\n          <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">TreeBin.sizeOf</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">heapify</span> <span class=\"n\">l2_t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">r1.2</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">l1.2</span><span class=\"o\">,</span> <span class=\"n\">hl1</span><span class=\"o\">]⟩</span>\n    <span class=\"k\">else</span> <span class=\"k\">match</span> <span class=\"n\">hr1</span> <span class=\"o\">:</span> <span class=\"n\">r1.val</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ret_t_default</span> <span class=\"c1\">-- can't happen</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">rl</span> <span class=\"n\">rk</span> <span class=\"n\">rr</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">let</span> <span class=\"n\">r2_t</span> <span class=\"o\">:=</span> <span class=\"n\">TreeBin.node</span> <span class=\"n\">rl</span> <span class=\"n\">key</span> <span class=\"n\">rr</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">r2_t.sizeOf</span> <span class=\"bp\">&lt;</span> <span class=\"n\">t.sizeOf</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n          <span class=\"k\">have</span> <span class=\"n\">hr1</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"n\">TreeBin.sizeOf</span> <span class=\"n\">hr1</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">TreeBin.sizeOf</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hr1</span>\n          <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">TreeBin.sizeOf</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hr1</span><span class=\"o\">,</span> <span class=\"n\">r1.2</span><span class=\"o\">,</span> <span class=\"n\">plus_le2</span><span class=\"o\">]</span>\n        <span class=\"o\">⟨</span><span class=\"n\">TreeBin.node</span> <span class=\"n\">l1</span> <span class=\"n\">rk</span> <span class=\"o\">(</span><span class=\"n\">heapify</span> <span class=\"n\">r2_t</span><span class=\"o\">),</span> <span class=\"kd\">by</span>\n          <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">TreeBin.sizeOf</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">heapify</span> <span class=\"n\">r2_t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">l1.2</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">r1.2</span><span class=\"o\">,</span> <span class=\"n\">hr1</span><span class=\"o\">]⟩</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">t.sizeOf</span>\n\n<span class=\"sd\">/-- We can now state the fact that `heapify` preserves the set of values. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">values_heapify</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TreeBin</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">heapify</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">values</span> <span class=\"bp\">=</span> <span class=\"n\">t.values</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thanks! That's seems to be the way to do it</p>",
        "id": 423063460,
        "sender_full_name": "Yiftach S",
        "timestamp": 1708709736
    }
]