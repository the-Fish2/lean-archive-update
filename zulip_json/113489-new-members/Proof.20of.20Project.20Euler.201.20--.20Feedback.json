[
    {
        "content": "<p>I recently started learning LEAN, by reading theorem proving in lean4 and playing the natural number games.</p>\n<p>As an extra challenge, I took <a href=\"https://projecteuler.net/problem=1\">problem 1</a> from Project Euler, defined as close as possible to the problem statement, wrote a faster solution, and proved both of them are equivalent.</p>\n<p>Here is the whole proof: <a href=\"https://github.com/mfornet/project-euler-lean/blob/main/ProjectEuler/P1.lean\">https://github.com/mfornet/project-euler-lean/blob/main/ProjectEuler/P1.lean</a></p>\n<p>This is the first code I write outside of a tutorial and I'd love to get some feedback about how could it be improved.</p>\n<p>Some questions:</p>\n<ol>\n<li>How do you decide between using <code>theorem</code> vs <code>lemma</code> vs inline lemma (i.e have h : ...)</li>\n<li>Using <code>exact?</code> was helpful from time to time, but <code>rw?</code> or <code>apply?</code> was never helpful. Most of the time <code>apply?</code> would suggest theorems related to the bitwise representation of the integers. Is there anyway to make those more helpful.</li>\n<li>If I want to share this with colleagues, and let them verify this proof is ok, what command should they run? Right now I just see locally there are no <code>sorry</code></li>\n</ol>",
        "id": 418620129,
        "sender_full_name": "Marcelo Fornet",
        "timestamp": 1706529161
    },
    {
        "content": "<p>Congratulations!</p>\n<p>Question 1 is just a matter of style. Some people don't use the keyword <code>lemma</code> at all (I use <code>lemma</code> a lot and <code>private lemma</code> all over the place). As for those inline lemmas (<code>have</code>), please break line after <code>:=</code> or after <code>by</code> so that your code isn't pushed so much to the right side. Inline lemmas are great because they don't force you to repeat the local context in a new declaration. Just avoid them when (1) you want to use the same or similar inline lemma in two different proofs, or (2) when the elaboration takes a long time. And BTW, if you have an inline lemma whose proof happens to be just one step, ask yourself, maybe you want to do just the one step in the original proof without creating the inline lemma.</p>\n<p>Question 2 is not something I can help you with. I also find <code>exact?</code> extremely helpful and <code>apply?</code> only seldom helpful. I just recommend that, after you find the right lemma to close the subgoal, you delete the <code>by exact</code> part, as these two words basically cancel each other out.</p>\n<p>Question 3 is for <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> because he wrote the lean4checker.<br>\n<a href=\"https://github.com/leanprover/lean4checker\">https://github.com/leanprover/lean4checker</a></p>\n<p>Overall, good job! I don't have much to criticize about it (apart from small unimportant things such as redundant imports or proofs that could be shortened).</p>\n<p>PS: I just noticed that for blocks you use <code>.</code> and sometimes <code>{}</code>. Neither of them is the recommended style. Use <code>·</code> written by <code>\\.</code> in VS Code.</p>",
        "id": 418649321,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1706538842
    },
    {
        "content": "<p>If you want to see an example of what can be easily shortened in your proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">eq_sum_mul_k_to_n</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">):</span> <span class=\"n\">SumMulKToN</span> <span class=\"n\">k</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">SetSum</span> <span class=\"o\">(</span><span class=\"n\">MulKToN</span> <span class=\"n\">k</span> <span class=\"n\">n</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">MulKToN</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">cancel_mul_k_finset</span><span class=\"o\">]</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">SumMulKToN</span>\n  <span class=\"k\">have</span> <span class=\"n\">nat_mul_left_cancel</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"n\">HMul.hMul</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n  <span class=\"n\">apply</span> <span class=\"n\">nat_mul_left_cancel</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sum_first_n</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>The same thing can be written as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">eq_sum_mul_k_to_n</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">):</span> <span class=\"n\">SumMulKToN</span> <span class=\"n\">k</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">SetSum</span> <span class=\"o\">(</span><span class=\"n\">MulKToN</span> <span class=\"n\">k</span> <span class=\"n\">n</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">MulKToN</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">cancel_mul_k_finset</span><span class=\"o\">,</span> <span class=\"n\">sum_first_n</span><span class=\"o\">]</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I personally use <code>rewrite</code> in place of <code>rw</code> that directly precedes <code>rfl</code> but this distinction is not important.</p>",
        "id": 418653131,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1706539939
    },
    {
        "content": "<p>I tried with rewrite and it didn't close the goal, probably because it is not exactly the same without unfolding SumMulKToN</p>",
        "id": 418655586,
        "sender_full_name": "Marcelo Fornet",
        "timestamp": 1706540521
    },
    {
        "content": "<p>I mean, you can do the intermediate:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">eq_sum_mul_k_to_n</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">):</span> <span class=\"n\">SumMulKToN</span> <span class=\"n\">k</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">SetSum</span> <span class=\"o\">(</span><span class=\"n\">MulKToN</span> <span class=\"n\">k</span> <span class=\"n\">n</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">MulKToN</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">cancel_mul_k_finset</span><span class=\"o\">]</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">SumMulKToN</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sum_first_n</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 418656459,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1706540733
    },
    {
        "content": "<p>Typically <code>lean4checker</code> isn't really relevant in this scenario: it's for when you have a really skeptical audience who worry you might be cheating. :-)</p>\n<p>Making sure your project is set up so that everything builds with <code>lake build</code> is probably the answer to question 3?</p>",
        "id": 418658152,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1706541208
    },
    {
        "content": "<p>The \"build everything\" setup has just been discussed here:<br>\n<a href=\"#narrow/stream/270676-lean4/topic/build.20all.20my.20code\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/build.20all.20my.20code</a></p>",
        "id": 418658457,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1706541281
    }
]