[
    {
        "content": "<p>Hi all,</p>\n<p>I am a student in the Netherlands and for a project I am dipping my toes in Lean. I am trying to model a calculus that for a few proof terms makes use from scalars from a mathematical field, i.e. the real number or the complex numbers.<br>\nA friend of mine helped me getting started, but he is on holiday for a month and suggested me to ask for help here.</p>\n<p>At the moment I have the following for scalars:</p>\n<p>variable {S : Type v} [Field S]</p>\n<p>And my inductive type looks something like this:</p>\n<p>inductive ProofTerm: Finset String -&gt; Prop -&gt; Type v where<br>\n | Const1 : {Γ : Finset String} -&gt; (x : String) -&gt; (h : x ∉ Γ) -&gt; ProofTerm (Γ.cons x h) β -&gt; ProofTerm Γ true<br>\n | Const2 : {Γ : Finset String} -&gt; {Δ : Finset String} -&gt; {α : Prop} -&gt; {β : Prop} -&gt; ProofTerm Γ (α -&gt; β) -&gt; ProofTerm Δ α -&gt; (Disjoint Γ Δ) -&gt; ProofTerm (Γ ∪ Δ) β<br>\n...<br>\n | Const16 : (sc : S) -&gt; ProofTerm ∅ true<br>\n | Const17 : {Γ : Finset String} -&gt; {α : Prop} -&gt; (sc : S) -&gt; ProofTerm Γ α -&gt; ProofTerm Γ α</p>\n<p>This example is heavily modified so that it can be copied without much hassle. The important things are: it is an inductive definition from A -&gt; B -&gt; type v and it consists of 17 different constructors. Only 2 out of the 17 involve scalars from a field in some way. </p>\n<p>This inductive type does to work (i.e. it gives valid a ProofTerm for things I want, and complains when I try stuff that indeed should not work), however I am getting two issues with this:</p>\n<ul>\n<li>Lean seems to not be able to handle the field when used in theorems, i.e. </li>\n</ul>\n<p>theorem hasProperty (t: ProofTerms Γ P) : Prop :=<br>\n  sorry</p>\n<p>gives a \"don't know how to synthesize implicit argument\" error. This error is caused by the field S, as I don't get any error when if I leave out the last two constructors with fields.</p>\n<ul>\n<li>Secondly, Lean seems to automatically cast elements from different fields to one another, i.e. if I do </li>\n</ul>\n<p>#check Const17 (<a href=\"http://Complex.mk\">Complex.mk</a> 0 1) (Const16 (4 : ℝ))</p>\n<p>then Lean made a complex number out of the 4. This is technically also something I don't want to happen.</p>\n<p>I am looking for some advice on how to resolve these issues.  One thing I thought of would be to let the field be part of the inductive type (i.e. ProofTerm: S -&gt; A -&gt; B -&gt; type v), however does this make sense to do this, if so little constructors actually depend on it? (Also I couldn't make this work :)<br>\nSecondly, is there perhaps a better way to implement the scalars?</p>\n<p>Much thanks in advance,<br>\nErik Link</p>",
        "id": 425886247,
        "sender_full_name": "Erik Link",
        "timestamp": 1710155691
    },
    {
        "content": "<p>1) The fact that \"just\" two constructors depend on <code>S</code> is not really meaningful for Lean. After all, if you were to do <code>induction t</code> in your example, how should Lean figure out what <code>S</code> is for the <code>Const16/17</code> cases of the induction? Besides, one could argue that it is good and proper to do so: will your theorems be exactly the same if the field is F2 rather than R? It seems sensible to assume this is not the case(?) As to how to make it work, changing the curly brackets to parentheses should do the job (the curly brackets mean precisely \"this is implicit\").</p>\n<p>2) You parametrize your calculus as having  scalars from just one field <code>S</code> (uniformly on all constructors), so of course when you give it  things belonging to two different fields, it tries to find some way to embed one into the other (since by your definition they have to belong the same field). If you want them to belong to arbitrary fields you will need the individual constructors quantify over the type of the field, rather than just the whole inductive type. </p>\n<p>Unrelated, but you can use angle brackets instead of explicitly calling the constructor for complex numbers: (⟨0, 1⟩ : ℂ)</p>",
        "id": 425938327,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1710171778
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"699859\">Erik Link</span> <a href=\"#narrow/stream/113489-new-members/topic/scalars.20from.20a.20field/near/425886247\">said</a>:</p>\n<blockquote>\n<p>Hi all,</p>\n<p>I am a student in the Netherlands and for a project I am dipping my toes in Lean. </p>\n</blockquote>\n<p>Cool! Where in NL? I'm in Utrecht</p>",
        "id": 425972262,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1710177231
    },
    {
        "content": "<p>I am studying at the VU in Amsterdam</p>",
        "id": 425981731,
        "sender_full_name": "Erik Link",
        "timestamp": 1710180604
    },
    {
        "content": "<p>Great! <span class=\"user-mention silent\" data-user-id=\"133635\">Sander Dahmen</span> is in the math dept at the VU</p>",
        "id": 425982809,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1710181014
    },
    {
        "content": "<p>On this map you can find other people in A'dam: <a href=\"https://leanprover-community.github.io/meet.html\">https://leanprover-community.github.io/meet.html</a></p>",
        "id": 425982885,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1710181044
    },
    {
        "content": "<p>Thanks Luigi for the reply. Changing the brackets for S indeed seems to help me</p>\n<p>I do have a follow-up issue though. Let's say I now have this in Lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">NewType</span><span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span> <span class=\"n\">where</span>\n <span class=\"bp\">|</span> <span class=\"n\">Prod</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">sc</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">NewType</span> <span class=\"n\">S</span>\n <span class=\"bp\">|</span> <span class=\"n\">Axiom</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">NewType</span> <span class=\"n\">S</span>\n</code></pre></div>\n<p>This now results into an error with the universe level. Changing Type v to Type* does not fix it and that is where my knowledge ends unfortunately :)</p>",
        "id": 425982932,
        "sender_full_name": "Erik Link",
        "timestamp": 1710181067
    },
    {
        "content": "<p>Erik, see <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a> for rendering Lean code here in Zulip</p>",
        "id": 425985475,
        "sender_full_name": "Newell Jensen",
        "timestamp": 1710182015
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"699859\">@Erik Link</span> the universe level isn't the issue... the problem is that you're passing in the type <code>S</code> to <code>NewType</code> instead of a term of type <code>S</code> (like <code>sc</code>)</p>",
        "id": 426039418,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710208338
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"380294\">@Matt Diamond</span> explained you what the problem is in your definition, but also are you sure that is what you want? </p>\n<p>Here is some code and the respective type signatures. You might actually want 1) or 2) depending what you plan to do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">NewType</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"n\">where</span>\n <span class=\"bp\">|</span> <span class=\"n\">Prod</span>  <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">sc</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">NewType</span> <span class=\"n\">sc</span>\n <span class=\"bp\">|</span> <span class=\"n\">Axiom</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">sc</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">NewType</span> <span class=\"n\">sc</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">NewType</span> <span class=\"n\">ℝ</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">NewType.Axiom</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">NewType.Axiom</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">NewType₁</span> <span class=\"n\">where</span>\n <span class=\"bp\">|</span> <span class=\"n\">Prod</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">NewType₁</span>\n <span class=\"bp\">|</span> <span class=\"n\">Axiom</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">NewType₁</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">NewType₁</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">NewType₁.Axiom</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">NewType₁.Axiom</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n<span class=\"c1\">-- here you can make it implicit! The constructors carry all the necessary information</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">NewType₂</span> <span class=\"n\">where</span>\n <span class=\"bp\">|</span> <span class=\"n\">Prod</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">NewType₂</span>\n <span class=\"bp\">|</span> <span class=\"n\">Axiom</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">NewType₂</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">NewType₂</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">NewType₂</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">NewType₂.Axiom</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 426076189,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1710232619
    },
    {
        "content": "<p>First, I want to thank you all for your comments. I really appreciate it.</p>\n<p>What I am trying to do is to model a family of lambda-calculi based around a mathematical field S, let's call the family lambda-S. Members of this family are then for example lambda-R or lambda-C.</p>\n<p>(In my project I am trying to model the family instead of a particular member)</p>\n<p>Only a few of the proof-terms involve scalars from S in their construction, like for example the <code>Prod</code>-term in my example. For this term the actual value of <code>sc</code> is important.</p>\n<p>The other terms like <code>Axiom</code> don't involve scalars directly, but they still need to know if they are part of lambda-C instead of lambda-R for example. </p>\n<p>At first I was hoping that Lean could infer the value of S once it encountered a term with a scalar, but that gave me the initial errors. Now I am trying to give the value of S as input. I thought <code>S -&gt; Type*</code> would make sense, but I am now realizing that this indeed asks for an element of S and not S itself.</p>\n<p>So I guess my question now is how I can ask for the actual field in my inductive type. Sorry that I was not clear before.</p>",
        "id": 426109817,
        "sender_full_name": "Erik Link",
        "timestamp": 1710245025
    },
    {
        "content": "<p>I’d say <code>NewType₁</code> is what you want then</p>",
        "id": 426111481,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1710245617
    },
    {
        "content": "<p>That is, probably something that looks like this (with random names)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">ScalarLambdaCalculus</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">bot</span> <span class=\"o\">:</span> <span class=\"n\">ScalarLambdaCalculus</span>\n<span class=\"bp\">|</span> <span class=\"n\">tpair</span> <span class=\"o\">:</span> <span class=\"n\">ScalarLambdaCalculus</span> <span class=\"bp\">→</span>  <span class=\"n\">ScalarLambdaCalculus</span> <span class=\"bp\">→</span> <span class=\"n\">ScalarLambdaCalculus</span>\n<span class=\"bp\">|</span> <span class=\"n\">scalar</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">ScalarLambdaCalculus</span>\n<span class=\"bp\">|</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">ScalarLambdaCalculus</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">ScalarLambdaCalculus</span>\n<span class=\"k\">#check</span> <span class=\"n\">ScalarLambdaCalculus</span> <span class=\"n\">ℝ</span>\n<span class=\"k\">#check</span> <span class=\"n\">ScalarLambdaCalculus.bot</span>\n<span class=\"k\">#check</span> <span class=\"n\">ScalarLambdaCalculus.scalar</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">ScalarLambdaCalculus.add</span> <span class=\"o\">(⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">⟩:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">realCalcTerm</span> <span class=\"o\">:</span> <span class=\"n\">ScalarLambdaCalculus</span> <span class=\"n\">ℝ</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">complexCalcTerm</span> <span class=\"o\">:</span> <span class=\"n\">ScalarLambdaCalculus</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">ScalarLambdaCalculus.tpair</span> <span class=\"o\">(</span><span class=\"n\">ScalarLambdaCalculus.add</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">ScalarLambdaCalculus.bot</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 426113799,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1710246472
    },
    {
        "content": "<p>Thank you very much! That works perfectly and now I can continue with my project :)</p>",
        "id": 426122224,
        "sender_full_name": "Erik Link",
        "timestamp": 1710249258
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"699859\">Erik Link</span> has marked this topic as resolved.</p>",
        "id": 426122246,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710249263
    }
]