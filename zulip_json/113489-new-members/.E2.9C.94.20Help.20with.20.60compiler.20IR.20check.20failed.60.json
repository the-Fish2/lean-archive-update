[
    {
        "content": "<p>Hi! I'm new to Lean4 and I'm working on an untyped lambda calculus implementation to learn the language.</p>\n<p>Right now, I'm trying to implement generation and retrieval of fresh names to avoid name collision. When implementing a recursive function that uses <code>Finset.toList</code> from Mathlib, which is marked as noncomputable, I get the following error: <code>compiler IR check failed at 'freshest', error: unknown declaration 'Finset.toList</code></p>\n<p>After some research, I've found mentions that the <code>noncomputable</code> markup has something to do with the possibility of actually compiling Lean programs into bytecode, but I can't see why in this specific case it won't work.</p>\n<p>Here is a minimal working example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.List.MinMax</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Expr</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span>\n  <span class=\"bp\">|</span> <span class=\"n\">abs</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span>\n  <span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Expr</span>\n\n<span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">1</span> <span class=\"s2\">\" :→ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Expr.abs</span>\n<span class=\"kd\">infixl</span><span class=\"o\">:</span><span class=\"mi\">9</span> <span class=\"s2\">\" :. \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Expr.app</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fromFresh</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">String.mk</span> <span class=\"o\">(</span><span class=\"sc\">'`'</span> <span class=\"o\">::</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">nums</span> <span class=\"o\">:=</span> <span class=\"n\">name.map</span> <span class=\"o\">((</span><span class=\"bp\">·</span> <span class=\"bp\">-</span> <span class=\"sc\">'`'</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">Char.toNat</span><span class=\"o\">)</span>\n    <span class=\"n\">nums.foldl</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">acc</span> <span class=\"n\">num</span> <span class=\"bp\">↦</span> <span class=\"n\">num</span> <span class=\"bp\">+</span> <span class=\"mi\">26</span> <span class=\"bp\">*</span> <span class=\"n\">acc</span><span class=\"o\">)</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">freshest</span> <span class=\"o\">(</span><span class=\"n\">expr</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">go</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Finset</span> <span class=\"n\">String</span>\n    <span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span>\n    <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">:</span><span class=\"bp\">→</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">go</span> <span class=\"n\">e</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span>\n    <span class=\"bp\">|</span> <span class=\"n\">e₁</span> <span class=\"o\">:</span><span class=\"bp\">.</span> <span class=\"n\">e₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">go</span> <span class=\"n\">e₁</span> <span class=\"bp\">∪</span> <span class=\"n\">go</span> <span class=\"n\">e₂</span>\n\n  <span class=\"n\">go</span> <span class=\"n\">expr</span>\n    <span class=\"bp\">|&gt;</span> <span class=\"n\">Finset.toList</span>\n    <span class=\"bp\">|&gt;</span> <span class=\"n\">List.map</span> <span class=\"n\">fromFresh</span>\n    <span class=\"bp\">|&gt;</span> <span class=\"n\">List.maximum</span>\n    <span class=\"bp\">|&gt;</span> <span class=\"n\">WithBot.unbot'</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>Is the <code>Finset</code> type not appropriate for what I'm trying to do? How could I fix this problem?</p>\n<p>I appreciate any help :)</p>",
        "id": 423195197,
        "sender_full_name": "Eduardo Sandalo Porto",
        "timestamp": 1708800602
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.toList#doc\">docs#Finset.toList</a> is not computable, because it uses the axiom of choice</p>",
        "id": 423195355,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708800736
    },
    {
        "content": "<p>You can use <code>s.val.unquot</code> if you want to compute, but you can't prove anything about unquot</p>",
        "id": 423195372,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708800767
    },
    {
        "content": "<p>Why not work with a list instead of a finite set?</p>",
        "id": 423195401,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708800811
    },
    {
        "content": "<p>I was using a set to avoid any unnecessary repetitions into the structure, but a list would also work fine in this situation</p>\n<p>Do you know if there's another Set type more adequate for this situation? Before using Finset, I was using Set but it's membership test is not decidable, so it wouldn't work for my use case</p>",
        "id": 423195687,
        "sender_full_name": "Eduardo Sandalo Porto",
        "timestamp": 1708801103
    },
    {
        "content": "<p>What is the motivation for avoiding repetitions? It takes work to deduplicate a list, and the list just goes into a <code>maximum</code> function at the end which ignores duplicates anyway. I think the most performant solution will be to use a list (or actually an array) as Eric suggests. If you really want to use <code>Finset</code> because you find it cleaner, then since you're not allowed to inspect the order of elements in a <code>Finset</code>, you'll need to use <code>Finset.max</code> like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Image</span> <span class=\"c1\">-- Changed from `Basic`</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Lattice</span> <span class=\"c1\">-- Added</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Expr</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span>\n  <span class=\"bp\">|</span> <span class=\"n\">abs</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span>\n  <span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Expr</span>\n\n<span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">1</span> <span class=\"s2\">\" :→ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Expr.abs</span>\n<span class=\"kd\">infixl</span><span class=\"o\">:</span><span class=\"mi\">9</span> <span class=\"s2\">\" :. \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Expr.app</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fromFresh</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">String.mk</span> <span class=\"o\">(</span><span class=\"sc\">'`'</span> <span class=\"o\">::</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">nums</span> <span class=\"o\">:=</span> <span class=\"n\">name.map</span> <span class=\"o\">((</span><span class=\"bp\">·</span> <span class=\"bp\">-</span> <span class=\"sc\">'`'</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">Char.toNat</span><span class=\"o\">)</span>\n    <span class=\"n\">nums.foldl</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">acc</span> <span class=\"n\">num</span> <span class=\"bp\">↦</span> <span class=\"n\">num</span> <span class=\"bp\">+</span> <span class=\"mi\">26</span> <span class=\"bp\">*</span> <span class=\"n\">acc</span><span class=\"o\">)</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">freshest</span> <span class=\"o\">(</span><span class=\"n\">expr</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">go</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Finset</span> <span class=\"n\">String</span>\n    <span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span>\n    <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">:</span><span class=\"bp\">→</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">go</span> <span class=\"n\">e</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"c1\">-- Finset unions are O(n^2)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">e₁</span> <span class=\"o\">:</span><span class=\"bp\">.</span> <span class=\"n\">e₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">go</span> <span class=\"n\">e₁</span> <span class=\"bp\">∪</span> <span class=\"n\">go</span> <span class=\"n\">e₂</span>\n\n  <span class=\"n\">go</span> <span class=\"n\">expr</span>\n    <span class=\"bp\">|&gt;</span> <span class=\"n\">Finset.image</span> <span class=\"n\">fromFresh</span> <span class=\"c1\">-- Finset.image is O(n^2) as well</span>\n    <span class=\"bp\">|&gt;</span> <span class=\"n\">Finset.max</span>\n    <span class=\"bp\">|&gt;</span> <span class=\"n\">WithBot.unbot'</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>I would argue this is a worse approach than just using a list (or array) though, because computing the unions takes O(n^2) time to deduplicate, whereas appending two lists takes O(n) time.</p>",
        "id": 423197472,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708802778
    },
    {
        "content": "<p>Another option is to use <code>Std.HashSet</code>, which doesn't have any of the performance pitfalls of <code>Finset</code> but also isn't a particularly nice type to prove things about.</p>",
        "id": 423197528,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708802839
    },
    {
        "content": "<p>there's also the option of using <code>Finset.sort</code> to computably generate a list</p>\n<p>though if you can just use <code>Finset.max</code> then that seems unnecessary</p>",
        "id": 423197616,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1708802916
    },
    {
        "content": "<p>These are nice solutions, thanks for all the help :)</p>",
        "id": 423201341,
        "sender_full_name": "Eduardo Sandalo Porto",
        "timestamp": 1708806303
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"694319\">Eduardo Sandalo Porto</span> has marked this topic as resolved.</p>",
        "id": 423201347,
        "sender_full_name": "Notification Bot",
        "timestamp": 1708806310
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"694319\">Eduardo Sandalo Porto</span> has marked this topic as unresolved.</p>",
        "id": 423206783,
        "sender_full_name": "Notification Bot",
        "timestamp": 1708811801
    },
    {
        "content": "<p>Hi, I'm reopening this thread because I have another problem related to the same project</p>\n<p>Right now, I'm getting the error \"failed to synthesize instance Reduction m\" within the following MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Fresh</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">MonadStateOf</span> <span class=\"n\">Nat</span> <span class=\"n\">m</span>\n<span class=\"kd\">class</span> <span class=\"n\">Reduction</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Alternative</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">Fresh</span> <span class=\"n\">m</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">runReduction</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">Reduction</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">expr</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Prod.fst</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">StateT.run</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">freshest</span> <span class=\"n\">expr</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>In Haskell, the synthetisation for <code>m </code> could be decided automatically, like in the following code:</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"nf\">runReduction</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">forall</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">.</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Reduction</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=&gt;</span><span class=\"w\"> </span><span class=\"kt\">Expr</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"kt\">Expr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Expr</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Maybe</span><span class=\"w\"> </span><span class=\"kt\">Expr</span>\n<span class=\"nf\">runReduction</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"o\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">runStateT</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">freshest</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>Is there a way to explicitly define the synthetization for the type class in Lean that would solve this issue?</p>",
        "id": 423207034,
        "sender_full_name": "Eduardo Sandalo Porto",
        "timestamp": 1708812031
    },
    {
        "content": "<p><code>m</code> is currently an autoimplicit so chosen by the caller. I think you want</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">runReduction</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">},</span> <span class=\"o\">[</span><span class=\"n\">Reduction</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">expr</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 423208972,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708813688
    },
    {
        "content": "<p>Then the next problem is that it fails to synthesize an instance of <code>Reduction (StateT ℕ Option)</code>. I think you would need to add instances saying that <code>Monad</code> and <code>MonadStateOf</code> imply <code>Fresh</code> and <code>Alternative</code> and <code>Fresh</code> imply <code>Reduction</code>. <code>extends</code> autogenerates instances saying that the new class implies the old one, but in general there could be new fields, so it doesn't generate instances for the converse.</p>",
        "id": 423209262,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708814015
    },
    {
        "content": "<p>Typeclasses like this which just extend other typeclasses and add new fields aren't usually used. When you add the instance saying that the subclasses together imply the superclass, you create a cycle in the instance graph, which is generally discouraged for performance reasons. There has been discussion about a feature for \"typeclass aliases\" to support abbreviating a common combination of typeclass assumptions, but I think the state of the art is to avoid defining these abbreviations and to use the verbose typeclass assumptions instead:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">freshest</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">runReduction</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">},</span> <span class=\"o\">[</span><span class=\"n\">Alternative</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">MonadStateOf</span> <span class=\"n\">Nat</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">expr</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Prod.fst</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">StateT.run</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">freshest</span> <span class=\"n\">expr</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 423209815,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708814529
    },
    {
        "content": "<p>These explanations are great, thank you very much!</p>",
        "id": 423210545,
        "sender_full_name": "Eduardo Sandalo Porto",
        "timestamp": 1708815266
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"694319\">Eduardo Sandalo Porto</span> has marked this topic as resolved.</p>",
        "id": 423210549,
        "sender_full_name": "Notification Bot",
        "timestamp": 1708815271
    }
]