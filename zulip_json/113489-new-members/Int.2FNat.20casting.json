[
    {
        "content": "<p>Apologies for the newbie question. Any good resources on Nat/Int casting in lean4? I have:</p>\n<div class=\"codehilite\" data-code-language=\"code\"><pre><span></span><code>theorem nat_is_even_or_odd (k : Nat) :  Even k ∨ Odd k\n</code></pre></div>\n<p>And I want to apply it to:</p>\n<div class=\"codehilite\" data-code-language=\"code\"><pre><span></span><code>theorem int_is_even_or_odd (k : Int) :  Even k ∨ Odd k\n</code></pre></div>\n<p>But I'm not having much success in being able to write the Int definition in terms of the Nat definition.</p>",
        "id": 429086643,
        "sender_full_name": "Archibald Neil MacDonald",
        "timestamp": 1711204965
    },
    {
        "content": "<p>Do you know how to mathematically prove that <code>nat_is_even_or_odd</code> implies <code>int_is_even_or_odd</code>?</p>",
        "id": 429086702,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711205034
    },
    {
        "content": "<p>In my head it should be trivial for the positive case, then use <code>Odd.add_odd</code> and <code>Even.odd_add</code> to massage out the additional +1's in the negative case?</p>",
        "id": 429086975,
        "sender_full_name": "Archibald Neil MacDonald",
        "timestamp": 1711205221
    },
    {
        "content": "<p>Okay, so you said something important here! You need to consider the positive and negative cases separately. Do you know how to do that in Lean?</p>",
        "id": 429087096,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711205302
    },
    {
        "content": "<p>In particular this is not just a question about casting, there is some mathematics which needs doing here.</p>",
        "id": 429087125,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711205333
    },
    {
        "content": "<p>So far I'm trying:</p>\n<div class=\"codehilite\" data-code-language=\"code\"><pre><span></span><code>theorem int_is_even_or_odd (k : Int) :  Even k ∨ Odd k := by\n  match k with\n  | .ofNat k =&gt; ...\n  | .negSucc k =&gt; ...\n</code></pre></div>\n<p>And I'm not able to deal with the first arm as I'm getting stuck in trying to make <code>ofNat</code> behave.</p>",
        "id": 429087227,
        "sender_full_name": "Archibald Neil MacDonald",
        "timestamp": 1711205416
    },
    {
        "content": "<p>So now you need to prove things of the form <code>Even n → Even (Int.ofNat n)</code>. Do you know how to do that?</p>",
        "id": 429087319,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711205517
    },
    {
        "content": "<p>No that's something I'm hitting my head against the wall here!</p>",
        "id": 429087384,
        "sender_full_name": "Archibald Neil MacDonald",
        "timestamp": 1711205549
    },
    {
        "content": "<p>My instinct would be not to go down this route: <code>.negSucc</code> is a pathological function mathematically with very little API (for example mathematicians have no name for this function, and hence have no desire to develop it). I would be more inclined to prove <code>Even k &lt;-&gt; Even k.natAbs</code> and then this would reduce you directly to the Nat case and you'll not have to deal with the +1 issues.</p>",
        "id": 429087398,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711205562
    },
    {
        "content": "<p>Kevin, I agree, but I think it's instructive to keep on going here</p>",
        "id": 429087431,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711205593
    },
    {
        "content": "<p>Once Archibald is done with the first arm, we can use the mathematically correct case principle for <code>Int</code> rather than the default one</p>",
        "id": 429087464,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711205641
    },
    {
        "content": "<p>Answering your question: I'd do it like this.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Even</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Even</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span><span class=\"bp\">?</span>\n</code></pre></div>",
        "id": 429087516,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711205652
    },
    {
        "content": "<p>But my point is that if the goal is to deduce <code>int_is_even_or_odd</code> from <code>nat_is_even_or_odd</code> then I think that this entire route is a red herring and the sensible route is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Even</span> <span class=\"n\">z</span> <span class=\"bp\">↔</span> <span class=\"n\">Even</span> <span class=\"o\">(</span><span class=\"n\">z.natAbs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span><span class=\"bp\">?</span>\n</code></pre></div>\n<p>i.e. \"Don't split into cases at all, just take the absolute value\"</p>",
        "id": 429087679,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711205783
    },
    {
        "content": "<p>Maybe <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.induction_on#doc\">docs#Int.induction_on</a> ?</p>",
        "id": 429088130,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711206138
    },
    {
        "content": "<p>I don't see how this induction principle will help with reducing the int case to the nat case (but I totally agree that it's a far better induction principle than the default one!)</p>",
        "id": 429088157,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711206174
    },
    {
        "content": "<p>We need <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.sign_cases#doc\">docs#Int.sign_cases</a> but it doesn't seem to exist</p>",
        "id": 429088196,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711206207
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.eq_nat_or_neg#doc\">docs#Int.eq_nat_or_neg</a> is close, but it ought to be an induction principle</p>",
        "id": 429088272,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711206266
    },
    {
        "content": "<p>Sorry I had to step away. Thanks for the replies all, I was not aware of <code>exact?</code> so thanks for that. I'm taking a look at the source code and understand how the implementers are approaching the same proofs.</p>",
        "id": 429096994,
        "sender_full_name": "Archibald Neil MacDonald",
        "timestamp": 1711213317
    },
    {
        "content": "<p>Thanks for the input all.</p>\n<p>On the same topic of int/nast casting, I have this lemma, where I'm trying to derive <code>int_k2_mod8_eq_1</code> from <code>nat_k2_mod8_eq_1</code>. The explicit 8 cast makes me think I'm not doing this right at all, is there a better way to cast here?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">nat_k2_mod8_eq_1</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Odd</span> <span class=\"n\">k</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"mi\">8</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">int_k2_mod8_eq_1</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Odd</span> <span class=\"n\">k</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"mi\">8</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hOdd</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span> <span class=\"bp\">←</span> <span class=\"n\">Int.natAbs_pow_two</span>\n     <span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Int.natCast_pow</span>\n     <span class=\"o\">,</span> <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"mi\">8</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span>  <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">8</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n     <span class=\"o\">,</span> <span class=\"n\">Int.ofNat_mod_ofNat</span> <span class=\"n\">_</span> <span class=\"mi\">8</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nat_k2_mod8_eq_1</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"bp\">;</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Int.natAbs_odd</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">hOdd</span><span class=\"bp\">;</span>\n</code></pre></div>",
        "id": 429243079,
        "sender_full_name": "Archibald Neil MacDonald",
        "timestamp": 1711311128
    },
    {
        "content": "<p>I guess one could step back and ask why you're trying to deduce a theorem about integers from a related but different theorem about naturals when you could just prove the integer case directly and perhaps with less work than deducing it from the natural case. You keep asking about casting, but casting would be deducing the natural case from the integer case.</p>",
        "id": 429249486,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711315438
    },
    {
        "content": "<p>It's a fair question; as a beginner solving this for Nats is achievable for me; I don't know how to do inductive proofs on integers in lean without going into the constructors I've been told to avoid, or bounds check against the negative case in match blocks.</p>",
        "id": 429250477,
        "sender_full_name": "Archibald Neil MacDonald",
        "timestamp": 1711316019
    },
    {
        "content": "<p>Also I'm perhaps incorrectly thinking \"this is a natural-numbers proof and the int proof should follow.\"</p>",
        "id": 429250558,
        "sender_full_name": "Archibald Neil MacDonald",
        "timestamp": 1711316061
    },
    {
        "content": "<p>You can just prove it directly with no induction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int_k2_mod8_eq_1</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Odd</span> <span class=\"n\">k</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"mi\">8</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"c1\">-- k=2w+1</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">Int.even_or_odd</span> <span class=\"n\">w</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"c1\">-- w=2x or 2x+1</span>\n  <span class=\"bp\">·</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">8</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"bp\">%</span> <span class=\"mi\">8</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n    <span class=\"n\">convert</span> <span class=\"n\">this</span><span class=\"bp\">;</span> <span class=\"n\">ring</span>\n  <span class=\"bp\">·</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">8</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"bp\">%</span> <span class=\"mi\">8</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n    <span class=\"n\">convert</span> <span class=\"n\">this</span><span class=\"bp\">;</span> <span class=\"n\">ring</span>\n</code></pre></div>\n<p>For me that's the easiest proof because it just writes itself; every odd k is either 4x+1 or 4x+3 and in both cases it's just a direct calculation to show that the square is 1 mod 8.</p>",
        "id": 429251792,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711316883
    },
    {
        "content": "<p>Cheers Kevin, seems a lot more elegant than my own attempts. There's some keywords I'm not too familiar with, so that's a big help in pointing out the gaps in my knowledge.</p>",
        "id": 429252249,
        "sender_full_name": "Archibald Neil MacDonald",
        "timestamp": 1711317230
    },
    {
        "content": "<p>Here's a proof using your idea of going through Nat. We're fortunate that <code>Odd k iff Odd k.natAbs</code> and <code>k^2 = (k.natAbs)^2</code> are both in the library. The <code>norm_cast</code> tactic is something you could be interested in.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nat_k2_mod8_eq_1</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Odd</span> <span class=\"n\">k</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"mi\">8</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int_k2_mod8_eq_1</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Odd</span> <span class=\"n\">k</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"mi\">8</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hOdd</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span> <span class=\"bp\">←</span> <span class=\"n\">Int.natAbs_pow_two</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Odd</span> <span class=\"o\">(</span><span class=\"n\">k.natAbs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">Odd.natAbs</span> <span class=\"n\">hOdd</span>\n  <span class=\"k\">have</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"n\">nat_k2_mod8_eq_1</span> <span class=\"n\">_</span> <span class=\"n\">foo</span>\n  <span class=\"n\">norm_cast</span> <span class=\"c1\">-- goal is bar modulo casts</span>\n</code></pre></div>",
        "id": 429253008,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711317682
    },
    {
        "content": "<p>golfing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nat_k2_mod8_eq_1</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Odd</span> <span class=\"n\">k</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"mi\">8</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int_k2_mod8_eq_1</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Odd</span> <span class=\"n\">k</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"mi\">8</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hOdd</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span> <span class=\"bp\">←</span> <span class=\"n\">Int.natAbs_pow_two</span><span class=\"o\">]</span>\n  <span class=\"n\">exact_mod_cast</span> <span class=\"n\">nat_k2_mod8_eq_1</span> <span class=\"n\">_</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Odd.natAbs</span> <span class=\"n\">hOdd</span>\n</code></pre></div>",
        "id": 429253090,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711317742
    },
    {
        "content": "<p>more golfing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nat_k2_mod8_eq_1</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Odd</span> <span class=\"n\">k</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"mi\">8</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int_k2_mod8_eq_1</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hOdd</span> <span class=\"o\">:</span> <span class=\"n\">Odd</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"mi\">8</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span> <span class=\"bp\">←</span> <span class=\"n\">Int.natAbs_pow_two</span><span class=\"o\">]</span>\n  <span class=\"n\">exact_mod_cast</span> <span class=\"n\">nat_k2_mod8_eq_1</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Odd.natAbs</span> <span class=\"n\">hOdd</span>\n</code></pre></div>",
        "id": 429253137,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711317799
    },
    {
        "content": "<p>Here is a variant using <code>ZMod 8</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">aux</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ZMod</span> <span class=\"mi\">8</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Odd</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"mi\">8</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">aux</span> <span class=\"n\">y</span>\n  <span class=\"n\">norm_cast</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">nth_rw</span> <span class=\"mi\">2</span> <span class=\"o\">[</span><span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">%</span> <span class=\"mi\">8</span> <span class=\"k\">from</span> <span class=\"n\">rfl</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"n\">Int.ModEq.eq</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"mi\">8</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">8</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"k\">from</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">ZMod.int_cast_eq_int_cast_iff</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>(It would be nice to be able to go more directly between <code>a % 8 = 1</code> and an equality in <code>ZMod 8</code> ...)</p>",
        "id": 429253624,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711318131
    },
    {
        "content": "<p>The price we pay of having three ways <code>%</code> and <code>_ ≡ _ [ZMOD n]</code> and <code>ZMod n</code> to say basically the same thing is that we need good API to move between all three of these things.  I agree that it's frustrating that half your proof is moving from <code>(z : ZMod 8) = 1</code> to <code>z % 8 = 1</code>.</p>",
        "id": 429254336,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711318679
    },
    {
        "content": "<p>Yeah, I would argue that stating these in terms of equalities in <code>ZMod n</code> is actually the best way, and so it should be easy to convert to and from this...</p>",
        "id": 429254603,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711318808
    },
    {
        "content": "<p>Slightly golfed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">aux</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ZMod</span> <span class=\"mi\">8</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Odd</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"mi\">8</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">aux</span> <span class=\"n\">y</span>\n  <span class=\"n\">norm_cast</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">nth_rw</span> <span class=\"mi\">2</span> <span class=\"o\">[</span><span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">%</span> <span class=\"mi\">8</span> <span class=\"k\">from</span> <span class=\"n\">rfl</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Int.ModEq.eq</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">ZMod.int_cast_eq_int_cast_iff</span> <span class=\"n\">_</span> <span class=\"mi\">1</span> <span class=\"mi\">8</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">this</span>\n</code></pre></div>",
        "id": 429255090,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711319188
    },
    {
        "content": "<p>A bit more principled, but still somewhat painful:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">aux</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ZMod</span> <span class=\"mi\">8</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Odd</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"mi\">8</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">aux</span> <span class=\"n\">y</span>\n  <span class=\"n\">norm_cast</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">apply_fun</span> <span class=\"n\">ZMod.val</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">apply_fun</span> <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"k\">have</span> <span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">8</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">⟩</span> <span class=\"c1\">-- needed for `ZMod.val_one`</span>\n  <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">ZMod.val_int_cast</span><span class=\"o\">,</span> <span class=\"n\">ZMod.val_one</span><span class=\"o\">,</span> <span class=\"n\">Int.Nat.cast_ofNat_Int</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n</code></pre></div>",
        "id": 429320035,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711356809
    }
]