[
    {
        "content": "<p>In Lean, I can write either</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span> <span class=\"s2\">\"ℕ\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat</span>\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span>\n</code></pre></div>\n<p>They seem to have approximately the same effect.  After either declaration, I can write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">a</span>\n<span class=\"k\">#check</span> <span class=\"n\">ℕ</span>\n</code></pre></div>\n<p>and the results are the same in either case.</p>\n<p>Is there some practical reason to favor <code>notation</code> over <code>def</code> when introducing a synonym such as this?</p>",
        "id": 419822497,
        "sender_full_name": "Adam Dingle",
        "timestamp": 1707134334
    },
    {
        "content": "<p>Try <code>#synth Add \\N</code> in both cases to see a difference. Parts of lean's inner workings work up to <em>syntactic equality</em> and other parts up to <em>definitional equality</em>. With notation <code>\\N</code> and <code>Nat</code> are syntactically equal,. With <code>def</code> they're only definitionally equal. The typeclass inference system (used by <code>#synth</code>) works up to syntactic equality, as does the <code>rw</code> tactic.</p>",
        "id": 419825514,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707135337
    },
    {
        "content": "<p>See the <a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/formalising-mathematics-2024/Part_B/equality.html\">relevant part of my course notes</a> for more information about the three kinds of equality in play in lean</p>",
        "id": 419825819,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707135458
    },
    {
        "content": "<p>This is very helpful - thanks!</p>",
        "id": 419826085,
        "sender_full_name": "Adam Dingle",
        "timestamp": 1707135532
    },
    {
        "content": "<p><code>notation</code> can also \"carry variables around\" (so it works as a replacement of Lean 3's <code>parameter</code>): if you have an expression that depends on some <code>variable</code>s, if you make a def for that expression, you have to make those <code>variable</code>s arguments, either explicit (so you need to supply them every time you use the def), or implicit (which Lean may fail to infer). But if you <a href=\"https://github.com/leanprover-community/mathlib4/blob/27ade4859c0b702b140ca4e56fc22c2640d0544c/Mathlib/SetTheory/Cardinal/FieldEmb.lean#L379-L380\">make the whole expression</a> a notation, then it just works (like hard-coded (rather than inferred) implicit arguments).</p>",
        "id": 419889808,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1707153324
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687151\">@Adam Dingle</span> see also <a href=\"#narrow/stream/270676-lean4/topic/is.20there.20a.20way.20to.20rename.20a.20type.20such.20as.20N.20.3A.3D.20Nat/near/412885883\">this</a></p>",
        "id": 419907146,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1707159308
    }
]