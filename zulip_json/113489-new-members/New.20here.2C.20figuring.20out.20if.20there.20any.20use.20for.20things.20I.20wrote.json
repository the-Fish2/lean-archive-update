[
    {
        "content": "<p>Hi,</p>\n<p>Just signed up here for the first time. I got curious about formal verification like 1-1.5 months ago, tried the natural numbers game, and went through some of Mathematics in Lean. After that, I decided to stress-test my ability to use the language by verifying this (a topological lemma I've needed not too long ago, though in lesser generality):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">PseudoMetricSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">PreimageBall</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n  <span class=\"n\">connectedComponentIn</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">‚Åª¬π'</span> <span class=\"o\">(</span><span class=\"n\">ball</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">r</span><span class=\"o\">))</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">nhds_basis_closure_PreimageBall</span> <span class=\"o\">[</span><span class=\"n\">T2Space</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">LocallyCompactSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LocallyConnectedSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MetricSpace</span> <span class=\"n\">Z</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Z</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">f_cont</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x_isol</span> <span class=\"o\">:</span> <span class=\"n\">connectedComponentIn</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">‚Åª¬π'</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">})</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">})</span>\n    <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">ùìù</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">HasBasis</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">r</span> <span class=\"bp\">‚Ü¶</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">PreimageBall</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">r</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"bp\">...</span>\n</code></pre></div>\n<p>It certainly took longer than expected to verify, and on the way I had to type up various other topological lemmas (I think the trickiest one was that the intersection of a directed family of compact connected sets in a Hausdorff space is connected).</p>\n<p>Is there any potential use for these things that I've typed? I've never contributed to any open-source libraries, and I don't know what are your quality standards for mathlib and if what I wrote has any chance of passing those (nor if some of these results are already in there under a guise that I can't recognize). I'm wondering that the above one that I set as an \"end-goal\" to myself might be too niche (it's probably not in full generality), but some of the ones I assembled on the way could be useful if they aren't in there already.</p>\n<p>A couple of the main questions that have arisen from this experiment:</p>\n<ul>\n<li>How do you generally handle imports and figuring out what to import? I tried importing just the things I need at the start, but I kept running into trouble when I tried that. Eventually I just imported all of mathlib, but that's probably not the right call.</li>\n<li>It seems to me that VSCode starts slowing down heavily once a file gets larger, to the point that it might be eating up some of my spacebar presses. Is this natural/is there ways to mitigate this?</li>\n</ul>\n<p>-Ilmari</p>",
        "id": 432102207,
        "sender_full_name": "Ilmari Kangasniemi",
        "timestamp": 1712629051
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"708605\">@Ilmari Kangasniemi</span> Welcome! Is your code available in a public place, so that we can look at some of your helper lemmas and/or proofs?</p>\n<p>Regarding imports: You can <code>import Mathlib</code>, and then trim down the needed imports when you are done. There is even a tool for that: <code>lake exe shake</code>.</p>\n<p>Regarding slow downs: Large files shouldn't be too much of a problem. (Depends on \"large\", I guess. But ~3000 loc should be fine for example.) How large is your file? What does cause slowdowns is large proofs. People are working hard on solving that. But in the mean time, we often try to keep proofs &lt; 100 loc (and generally &lt; 30 loc). So splitting up a lemma into more helper lemmas might be a workaround for the slowdowns you are seeing.</p>",
        "id": 432143107,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1712645728
    },
    {
        "content": "<p>One criterion for \"do we want this lemma in mathlib\" is \"are there mathematicians who need this lemma in real life\", so if you're that mathematician then this is an argument for PRing your lemma to mathlib. The PR process is long and complex, for precisely the reason you isolate (quality standards are high) however the community is very open to helping newcomers getting their code to reach this standard (experts frequently suggest rewrites and don't demand any credit; this is the culture here). As Johan suggests, perhaps the first step is that the community looks at your code as it is now and makes suggestions about what if anything needs to be changed in order to make it appropriate for mathlib.</p>",
        "id": 432186222,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712656495
    },
    {
        "content": "<p>Regarding slowdowns -- ten small lemmas is much better than one lemma of ten times the size. There is a certain art to pulling out sublemmas and finding the right abstractions.</p>",
        "id": 432186381,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712656551
    },
    {
        "content": "<p>Hi,</p>\n<p>I'll attach the file here. I'm open to hearing about all the blunders I made in it.</p>\n<p><a href=\"/user_uploads/3121/4K3_gbvCSxemSbgqhrzYRKF6/EarlyTests.lean\">EarlyTests.lean</a></p>\n<p>Based on those standards of large, the file is overall not yet particularly large then, since it's around 550 lines with comments. I've already tried to chop up everything into as discrete and reusable parts as possible, but the main chunk is still around 100 lines. I also wonder if the slowdowns are due to me using a lot of 'have' -statements in the longer proofs (most of the shorter parts I've tried to compress into proof terms).</p>\n<p>Thanks for mentioning the shake -command, I'll look into it.</p>\n<p>-Ilmari</p>",
        "id": 432211270,
        "sender_full_name": "Ilmari Kangasniemi",
        "timestamp": 1712662713
    },
    {
        "content": "<p>This whole file compiles for me in about two seconds! An initial glance indicates that it looks very nice. </p>\n<p>The reason you couldn't deduce the set version from the lattice version in your first few lemmas is that you have a typo in <code>le_of_le_sup_Disjoint_right</code>(and <code>le_of_le_sup_Disjoint_left</code>) : it should be <code>{s a b : Œ±}</code>, not <code>Set Œ±</code>. Then</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">le_of_le_sup_Disjoint_right</span> <span class=\"o\">[</span><span class=\"n\">DistribLattice</span> <span class=\"n\">Œ±</span><span class=\"o\">][</span><span class=\"n\">OrderBot</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">}(</span><span class=\"n\">ssup</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">‚â§</span> <span class=\"n\">a</span> <span class=\"bp\">‚äî</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dsb</span> <span class=\"o\">:</span> <span class=\"n\">Disjoint</span> <span class=\"n\">s</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">‚â§</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n  <span class=\"k\">calc</span>\n    <span class=\"n\">s</span> <span class=\"bp\">‚â§</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">‚äî</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">‚äì</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">‚äî</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">le_inf</span> <span class=\"n\">le_sup_right</span> <span class=\"n\">ssup</span>\n    <span class=\"n\">_</span> <span class=\"bp\">‚â§</span> <span class=\"n\">a</span> <span class=\"bp\">‚äî</span> <span class=\"n\">s</span> <span class=\"bp\">‚äì</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">le_sup_inf</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">‚äî</span> <span class=\"bp\">‚ä•</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">disjoint_iff.mp</span> <span class=\"n\">dsb</span><span class=\"o\">]</span>\n    <span class=\"n\">_</span> <span class=\"bp\">‚â§</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">sup_le</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">bot_le</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">subset_of_subset_union_disjoint_right</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">Su</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">A</span> <span class=\"bp\">‚à™</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dSB</span> <span class=\"o\">:</span> <span class=\"n\">Disjoint</span> <span class=\"n\">S</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n  <span class=\"n\">le_of_le_sup_Disjoint_right</span> <span class=\"n\">Su</span> <span class=\"n\">dSB</span>\n</code></pre></div>",
        "id": 432215445,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712663774
    },
    {
        "content": "<p>That's a good blunder to catch - missed that when copying over the definitions when I realized that it probably already works at the lattice level instead of set level. Tested and it works with that issue fixed. The subset versions are then probably pointless as they're essentially aliases. (Even then I don't know if these should already exist somewhere; they feel like they're a basic set theory tool that should be implemented pretty early, but some ctrl+space -searching with \"disjoint\" didn't lead me anywhere.)</p>",
        "id": 432357432,
        "sender_full_name": "Ilmari Kangasniemi",
        "timestamp": 1712704353
    }
]