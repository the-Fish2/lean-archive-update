[
    {
        "content": "<p>Could somebody please shed light on why pattern matching fails in the following example? The <code>sorry</code>'d identity says that the many-indexed inf over a sum of independently indexed functions is the sum of the single-indexed infs of the individual functions. Once defined, the failure comes when trying to match it to a simple concrete example.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span> <span class=\"n\">ENNReal</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">iInf_pi_sum</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">κ</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompleteLattice</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OrderedAddCommMonoid</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">⨅</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"bp\">⨅</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⨅</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span>\n    <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">⨅</span> <span class=\"n\">ki</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">ki</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- fails to unify with goal</span>\n  <span class=\"c1\">--apply iInf_pi_sum _</span>\n  <span class=\"c1\">-- fails to unify with goal</span>\n  <span class=\"c1\">--apply @iInf_pi_sum (Fin n) ℝ≥0∞ (fun _ =&gt; ℕ) _ _ _ _</span>\n  <span class=\"c1\">-- this works</span>\n  <span class=\"c1\">--apply @iInf_pi_sum (Fin n) ℝ≥0∞ (fun _ =&gt; ℕ) _ _ _ (fun i ki =&gt; 1 / ki)</span>\n  <span class=\"c1\">-- this also works</span>\n  <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">iInf_pi_sum</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">ki</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">ki</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>In practice, I expect that the most tedious part of the matching would be typing in the functions that are being summed over, but that's the only way it works now. Is there any approach that would make the matching succeed automatically?</p>",
        "id": 411005155,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1704284503
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">apply</span> <span class=\"n\">iInf_pi_sum</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">ki</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">ki</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>also works btw, lean just needs help to infer the function f here</p>",
        "id": 411005959,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1704284849
    },
    {
        "content": "<p>There is a further rabbit hole when one tries to prove the general identity. I suspect that it could be done using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.induction_on#doc\">docs#Finset.induction_on</a>, based on the following pattern.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">iInf₂_add</span> <span class=\"c\">/-</span><span class=\"cm\">{α : Type*}-/</span> <span class=\"o\">{</span><span class=\"n\">κ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n    <span class=\"c\">/-</span><span class=\"cm\">[CompleteLattice α] [OrderedAddCommMonoid α]-/</span>\n    <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">κ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span> <span class=\"c\">/-</span><span class=\"cm\">α-/</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"n\">κ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span> <span class=\"c\">/-</span><span class=\"cm\">α-/</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">⨅</span> <span class=\"n\">k₁</span> <span class=\"o\">:</span> <span class=\"n\">κ</span><span class=\"o\">,</span> <span class=\"bp\">⨅</span> <span class=\"n\">k₂</span> <span class=\"o\">:</span> <span class=\"n\">κ</span><span class=\"o\">,</span> <span class=\"n\">f₁</span> <span class=\"n\">k₁</span> <span class=\"bp\">+</span> <span class=\"n\">f₂</span> <span class=\"n\">k₂</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">⨅</span> <span class=\"n\">k₁</span> <span class=\"o\">:</span> <span class=\"n\">κ</span><span class=\"o\">,</span> <span class=\"n\">f₁</span> <span class=\"n\">k₁</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"bp\">⨅</span> <span class=\"n\">k₂</span> <span class=\"o\">:</span> <span class=\"n\">κ</span><span class=\"o\">,</span> <span class=\"n\">f₂</span> <span class=\"n\">k₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">ENNReal.add_iInf</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">ENNReal.iInf_add</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>However, right now I can't even prove that when generalizing from <code>ENNReal</code> in the way that I commented out. It seems that the appropriate general <code>add_iInf</code> and <code>iInf_add</code> are not defined. Generalizing a copy paste of the proof from <code>ENNReal</code> fails with a mysterious typeclass resolution error.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- typeclass resolution failure on α!</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">iInf_add'</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"n\">OrderedAddCommMonoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompleteLattice</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">iInf</span> <span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">⨅</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n  <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">le_iInf</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">add_le_add</span> <span class=\"o\">(</span><span class=\"n\">iInf_le</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">le_rfl</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">tsub_le_iff_right.1</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">le_iInf</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">tsub_le_iff_right.2</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">iInf_le</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Any idea of what's missing here?</p>",
        "id": 411006139,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1704284934
    },
    {
        "content": "<p><code>[CompleteLattice α] [OrderedAddCommMonoid α]</code> declares two (a priori unrelated) orders on <code>α</code></p>",
        "id": 411006447,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704285063
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/113489-new-members/topic/Failure.20of.20pattern.20matching/near/411005959\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">apply</span> <span class=\"n\">iInf_pi_sum</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">ki</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">ki</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>also works btw, lean just needs help to infer the function f here</p>\n</blockquote>\n<p>Of course, thanks. But matching the function is obviously the hard part also for the human. It could be quite an involved expression to type out (or copy from the Infoview). Any way here to make the computer do the hard work?</p>",
        "id": 411006470,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1704285074
    },
    {
        "content": "<p>Theorems of this form are usually pretty hard to prove.</p>",
        "id": 411006537,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704285110
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/Failure.20of.20pattern.20matching/near/411006447\">said</a>:</p>\n<blockquote>\n<p><code>[CompleteLattice α] [OrderedAddCommMonoid α]</code> declares two (a priori unrelated) orders on <code>α</code></p>\n</blockquote>\n<p>Aha, I see. But without the <code>CompleteLattice</code> property, the <code>iInf</code>s don't make sense. Is there a way to ask for the order from <code>OrderedAddCommMonoid</code> to be complete?</p>",
        "id": 411006882,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1704285259
    },
    {
        "content": "<p>That's where things start getting hard. There are many different ways algebraic operations can interact with the order, so I can't give you a one size fits all answer.</p>",
        "id": 411007231,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704285458
    },
    {
        "content": "<p>I guess the main use case is <code>α = ENNReal</code> where it can be made to work. But it would be nice if the proof worked also more generally, say in the presence of extra parameters like <code>α = X -&gt; ENNReal</code>.</p>",
        "id": 411008563,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1704286053
    },
    {
        "content": "<p>I understand that, but it's pretty hard to axiomatise</p>",
        "id": 411008946,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704286235
    },
    {
        "content": "<p>Basically, the proof needs that one-sided addition is a map preserving the infimum. I don't think we have a way to state that in mathlib right now.</p>",
        "id": 411009219,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704286350
    },
    {
        "content": "<p>OK, I understand. Thanks.</p>",
        "id": 411009268,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1704286378
    },
    {
        "content": "<p>Anyway, my main question was about the pattern matching failure in the <code>iInf_pi_sum</code> example. Any way to figure out the point of failure and supply extra hints to make it succeed that doesn't involve manually supplying the function <code>f</code>?</p>",
        "id": 411009347,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1704286425
    },
    {
        "content": "<p>Aha! Here's something that works. Specializing to <code>ENNReal</code> and exchanging the lhs and rhs of the identity gives a successful match.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">iInf_pi_sum</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"c\">/-</span><span class=\"cm\">α-/</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">κ</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"c\">/-</span><span class=\"cm\">[CompleteLattice α] [OrderedAddCommMonoid α]-/</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span> <span class=\"c\">/-</span><span class=\"cm\">α-/</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"bp\">⨅</span> <span class=\"n\">ki</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">ki</span> <span class=\"bp\">=</span> <span class=\"bp\">⨅</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n    <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">⨅</span> <span class=\"n\">ki</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">ki</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⨅</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span>\n    <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">iInf_pi_sum</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 411011519,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1704287235
    },
    {
        "content": "<p>I guess the matching is done from right to left and Lean is confused by the double dependence of <code>f i (k i)</code> on <code>i</code>. It feels like there should be a way to hint Lean to make the match succeed in the other direction as well, which is obviously the important direction in practice (for <code>rw</code> or <code>simp</code>). A case for some metacode maybe? Something I know next to nothing about at the moment, unfortunately.</p>",
        "id": 411011850,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1704287377
    },
    {
        "content": "<p><code>rw [← iInf_pi_sum]</code> works too</p>",
        "id": 411012667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704287701
    },
    {
        "content": "<p>This is called a higher order unification problem, and higher order unification is in general undecidable. The restrictions that lean has here were added deliberately, because they used to not exist (in lean 2) and this lead to unpredictable timeouts and difficult to understand behavior</p>",
        "id": 411012910,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704287794
    },
    {
        "content": "<p>OK, thanks for the explanation. I understand why it doesn't work out of the box. Still the higher unification problem here is very specific (to match <code>f i (k i)</code>, first isolate any occurrence of <code>k</code>, make sure each one occurs in the form <code>k i</code>, replace the combination by a dummy <code>ki</code>, then match against <code>f i ki</code>). And this is a pretty common pattern in mathematics.</p>\n<p>I hope someone takes up the challenge to make something like <code>rw [iInf_pi_sum (special_way_to_extract_f)]</code> to work on expressions that involve the complicated side of the identity. <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span></p>",
        "id": 411019651,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1704290644
    },
    {
        "content": "<p>For anyone who's curious, I've managed to prove the version of <code>iInf_pi_sum</code> that I wanted.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.CompleteLattice</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Order.Sub.Prod</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.BigOperators</span>\n\n<span class=\"sd\">/-- Pass a multi-indexed ⨅ through a ∑, to get a ∑ of single-indexed ⨅s. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">iInf_pi_sum</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hι</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">κ</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"n\">CompleteLattice</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">CovariantClass</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">≤</span> <span class=\"bp\">·</span><span class=\"o\">)]</span>\n    <span class=\"o\">[</span><span class=\"n\">CovariantClass</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">Function.swap</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"bp\">·</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">≤</span> <span class=\"bp\">·</span><span class=\"o\">)]</span>\n    <span class=\"o\">[</span><span class=\"n\">Sub</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OrderedSub</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">⨅</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"bp\">⨅</span> <span class=\"n\">ki</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">ki</span>\n    <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The only interaction between <code>+</code> and <code>≤</code> that was needed is handled by <code>CovariantClass</code>. I modeled this solution on how <code>add_le_add</code> does it.</p>",
        "id": 411544887,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1704581703
    },
    {
        "content": "<p>Would this belong somewhere in Mathlib?</p>",
        "id": 411544898,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1704581722
    },
    {
        "content": "<p>Here's the full code with some intermediate lemmas of their own interest.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.CompleteLattice</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Order.Sub.Prod</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.BigOperators</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.ENNReal</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Classical</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"c1\">-- generalized replacement for ENNReal.iInf_add</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">iInf_add</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"n\">CompleteLattice</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">Add</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">CovariantClass</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x_1</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">x_1</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">CovariantClass</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">Function.swap</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x_1</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">x_1</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">Sub</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OrderedSub</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">iInf</span> <span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">⨅</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">and_self_iff.mp</span> <span class=\"n\">_</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span> <span class=\"c1\">-- two proofs: one compact, one human readable</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">le_iInf</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">add_le_add</span> <span class=\"o\">(</span><span class=\"n\">iInf_le</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">le_rfl</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">tsub_le_iff_right.1</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">le_iInf</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">tsub_le_iff_right.2</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">iInf_le</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">le_antisymm</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n    <span class=\"bp\">·</span> <span class=\"o\">{</span> <span class=\"k\">calc</span>\n        <span class=\"n\">iInf</span> <span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"bp\">⨅</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">le_iInf</span> <span class=\"n\">_</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">j</span><span class=\"bp\">;</span> <span class=\"o\">{</span> <span class=\"k\">calc</span>\n        <span class=\"n\">iInf</span> <span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span>      <span class=\"n\">f</span> <span class=\"n\">j</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">add_le_add</span> <span class=\"n\">_</span> <span class=\"n\">le_rfl</span><span class=\"bp\">;</span> <span class=\"o\">{</span> <span class=\"k\">calc</span>\n        <span class=\"n\">iInf</span> <span class=\"n\">f</span>     <span class=\"bp\">≤</span>      <span class=\"n\">f</span> <span class=\"n\">j</span>     <span class=\"o\">:=</span> <span class=\"n\">iInf_le</span> <span class=\"n\">_</span> <span class=\"n\">j</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n    <span class=\"bp\">·</span> <span class=\"o\">{</span> <span class=\"k\">calc</span>\n        <span class=\"o\">(</span><span class=\"bp\">⨅</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"n\">a</span><span class=\"o\">)</span>     <span class=\"bp\">≤</span> <span class=\"n\">iInf</span> <span class=\"n\">f</span>   <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">tsub_le_iff_right</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"k\">calc</span>\n        <span class=\"o\">(</span><span class=\"bp\">⨅</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">iInf</span> <span class=\"n\">f</span>       <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">le_iInf</span> <span class=\"n\">_</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">j</span><span class=\"bp\">;</span> <span class=\"o\">{</span> <span class=\"k\">calc</span>\n        <span class=\"o\">(</span><span class=\"bp\">⨅</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span>      <span class=\"n\">f</span> <span class=\"n\">j</span>     <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">tsub_le_iff_right</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"o\">{</span> <span class=\"k\">calc</span>\n        <span class=\"bp\">⨅</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"n\">a</span><span class=\"o\">)</span>     <span class=\"bp\">≤</span>      <span class=\"n\">f</span> <span class=\"n\">j</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">iInf_le</span> <span class=\"n\">_</span> <span class=\"n\">j</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- generalized replacement for ENNReal.add_iInf</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">add_iInf</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"n\">CompleteLattice</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">AddCommMagma</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">CovariantClass</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x_1</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">x_1</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">CovariantClass</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">Function.swap</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x_1</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">x_1</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">Sub</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OrderedSub</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">iInf</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"bp\">⨅</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">iInf_add</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- check that the ENNReal versions are special cases</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ENNReal</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ENNReal</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">ENNReal.iInf_add</span> <span class=\"n\">a</span> <span class=\"n\">ι</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">iInf_add</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ENNReal</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ENNReal</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">ENNReal.add_iInf</span> <span class=\"n\">ι</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">add_iInf</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- try a proper generalization</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">ENNReal</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">ENNReal</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n  <span class=\"n\">iInf_add</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">ENNReal</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Pass a double ⨅ through a sum, to get a sum of independent ⨅s. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">iInf₂_add</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">κ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"n\">CompleteLattice</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">AddCommMagma</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">CovariantClass</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x_1</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">x_1</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">CovariantClass</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">Function.swap</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x_1</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">x_1</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">Sub</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OrderedSub</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">κ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"n\">κ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">⨅</span> <span class=\"n\">k₁</span> <span class=\"o\">:</span> <span class=\"n\">κ</span><span class=\"o\">,</span> <span class=\"bp\">⨅</span> <span class=\"n\">k₂</span> <span class=\"o\">:</span> <span class=\"n\">κ</span><span class=\"o\">,</span> <span class=\"n\">f₁</span> <span class=\"n\">k₁</span> <span class=\"bp\">+</span> <span class=\"n\">f₂</span> <span class=\"n\">k₂</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">⨅</span> <span class=\"n\">k₁</span> <span class=\"o\">:</span> <span class=\"n\">κ</span><span class=\"o\">,</span> <span class=\"n\">f₁</span> <span class=\"n\">k₁</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"bp\">⨅</span> <span class=\"n\">k₂</span> <span class=\"o\">:</span> <span class=\"n\">κ</span><span class=\"o\">,</span> <span class=\"n\">f₂</span> <span class=\"n\">k₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">add_iInf</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">iInf_add</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- Factorize dependent function type over an Option. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Equiv.piOptionEquivProdPi</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">((</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">none</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">calc</span>\n    <span class=\"o\">((</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n      <span class=\"bp\">≃</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">Equiv.piCongrLeft'</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Equiv.optionEquivSumPUnit</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">((</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">⊕</span> <span class=\"n\">Unit</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n      <span class=\"bp\">≃</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">Equiv.sumPiEquivProdPi</span> <span class=\"n\">_</span>\n    <span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>        <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">none</span><span class=\"o\">)</span>\n      <span class=\"bp\">≃</span> <span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>    <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">×</span> <span class=\"o\">(</span>       <span class=\"n\">β</span> <span class=\"n\">none</span><span class=\"o\">)</span>\n          <span class=\"o\">:=</span> <span class=\"n\">Equiv.prodCongrRight</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n              <span class=\"o\">(</span><span class=\"n\">Equiv.piUnique</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"n\">β</span> <span class=\"n\">none</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Pass a multi-indexed ⨅ through a ∑, to get a ∑ of single-indexed ⨅s. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">iInf_pi_sum</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hι</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">κ</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"n\">CompleteLattice</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">CovariantClass</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">≤</span> <span class=\"bp\">·</span><span class=\"o\">)]</span>\n    <span class=\"o\">[</span><span class=\"n\">CovariantClass</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">Function.swap</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"bp\">·</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">≤</span> <span class=\"bp\">·</span><span class=\"o\">)]</span>\n    <span class=\"o\">[</span><span class=\"n\">Sub</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OrderedSub</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">⨅</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"bp\">⨅</span> <span class=\"n\">ki</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">κ</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">ki</span>\n    <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- proof by an induction principle on Fintype</span>\n  <span class=\"n\">revert</span> <span class=\"n\">ι</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Fintype.induction_empty_option</span>\n  <span class=\"n\">case</span> <span class=\"n\">h_empty</span> <span class=\"bp\">=&gt;</span> <span class=\"c1\">-- base case: empty type</span>\n    <span class=\"n\">intro</span> <span class=\"n\">κ</span> <span class=\"n\">f</span>\n    <span class=\"k\">calc</span> <span class=\"c1\">-- simplify both empty sums to 0</span>\n      <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">congr_arg</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">funext</span> <span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Finset.sum_of_empty</span> <span class=\"n\">Finset.univ</span><span class=\"o\">)</span>\n      <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">iInf_const</span>\n      <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">Finset.sum_of_empty</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"n\">case</span> <span class=\"n\">h_option</span> <span class=\"bp\">=&gt;</span> <span class=\"c1\">-- inductive step: from α to Option α</span>\n    <span class=\"n\">intro</span> <span class=\"n\">ι</span> <span class=\"n\">hι</span> <span class=\"n\">h_ind</span> <span class=\"n\">κ</span> <span class=\"n\">f</span>\n    <span class=\"c1\">-- factorize parameter space of the multi-indexed ⨅</span>\n    <span class=\"k\">let</span> <span class=\"n\">hprod</span> <span class=\"o\">:=</span> <span class=\"n\">Equiv.piOptionEquivProdPi</span> <span class=\"n\">ι</span> <span class=\"n\">κ</span>\n    <span class=\"c1\">-- expand ∑ over Option α</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">Fintype.sum_option</span><span class=\"o\">]</span>\n    <span class=\"c1\">-- rewrite ⨅ as an iterated ⨅</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Equiv.iInf_comp</span> <span class=\"n\">hprod.symm</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">iInf_prod</span><span class=\"o\">]</span>\n    <span class=\"c1\">-- get the result ready for final simplification</span>\n    <span class=\"n\">unfold_let</span> <span class=\"n\">hprod</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">Equiv.piOptionEquivProdPi</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Equiv.instTransSortSortSortEquivEquivEquiv_trans</span><span class=\"o\">,</span> <span class=\"n\">Equiv.optionEquivSumPUnit_symm_inl</span><span class=\"o\">,</span>\n      <span class=\"n\">Equiv.optionEquivSumPUnit_symm_inr</span><span class=\"o\">,</span> <span class=\"n\">id_eq</span><span class=\"o\">,</span> <span class=\"n\">Equiv.trans_refl</span><span class=\"o\">,</span> <span class=\"n\">Equiv.symm_trans_apply</span><span class=\"o\">,</span>\n      <span class=\"n\">Equiv.piCongrLeft'_symm_apply</span><span class=\"o\">,</span> <span class=\"n\">Equiv.optionEquivSumPUnit_none</span><span class=\"o\">,</span> <span class=\"n\">Equiv.optionEquivSumPUnit_some</span><span class=\"o\">]</span>\n    <span class=\"c1\">-- XXX: did not find better simplification that deeply nested `whnf`</span>\n    <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">enter</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">]</span>\n      <span class=\"n\">whnf</span>\n      <span class=\"n\">rfl</span>\n    <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">enter</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">]</span>\n      <span class=\"n\">whnf</span>\n      <span class=\"n\">rfl</span>\n    <span class=\"c1\">-- pass ⨅ through ∑ and finish</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">iInf_add</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">add_iInf</span><span class=\"o\">]</span>\n    <span class=\"n\">congr</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h_ind</span> <span class=\"n\">_</span>\n  <span class=\"n\">case</span> <span class=\"n\">of_equiv</span> <span class=\"bp\">=&gt;</span> <span class=\"c1\">-- covariance with respect to type equivalence</span>\n    <span class=\"n\">intro</span> <span class=\"n\">ι'</span> <span class=\"n\">ι</span> <span class=\"n\">hι</span> <span class=\"n\">hι'ι</span> <span class=\"n\">h_orig</span> <span class=\"n\">κ</span> <span class=\"n\">f</span>\n    <span class=\"k\">have</span> <span class=\"n\">hι'</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">ι'</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.ofEquiv</span> <span class=\"n\">_</span> <span class=\"n\">hι'ι.symm</span>\n    <span class=\"k\">let</span> <span class=\"n\">hpiι'ι</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">κ</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"o\">((</span><span class=\"n\">i'</span> <span class=\"o\">:</span> <span class=\"n\">ι'</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">κ</span> <span class=\"o\">(</span><span class=\"n\">hι'ι</span> <span class=\"n\">i'</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Equiv.piCongrLeft</span> <span class=\"n\">_</span> <span class=\"n\">hι'ι</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n    <span class=\"c1\">-- reindex ∑ and ⨅</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Equiv.sum_comp</span> <span class=\"n\">hι'ι</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Equiv.iInf_comp</span> <span class=\"n\">hpiι'ι.symm</span><span class=\"o\">]</span>\n    <span class=\"c1\">-- simplify and finish</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Equiv.symm_symm</span><span class=\"o\">,</span> <span class=\"n\">Equiv.piCongrLeft_apply_apply</span><span class=\"o\">]</span>\n    <span class=\"n\">first</span>\n    <span class=\"bp\">|</span> <span class=\"n\">exact</span> <span class=\"n\">h_orig</span> <span class=\"n\">_</span>  <span class=\"c1\">-- fails to unify with goal (XXX: expected behavior?)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">exact</span> <span class=\"n\">Iff.mp</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">congr</span><span class=\"bp\">!</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_orig</span> <span class=\"n\">_</span><span class=\"o\">)</span>  <span class=\"c1\">-- congr! succeeds to prove Iff with goal</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">⨅</span> <span class=\"n\">ki</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">ki</span> <span class=\"o\">:</span> <span class=\"n\">ENNReal</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⨅</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ENNReal</span><span class=\"o\">)</span>\n    <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">first</span>\n  <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">iInf_pi_sum</span> <span class=\"n\">_</span>  <span class=\"c1\">-- fails to unify with goal</span>\n  <span class=\"bp\">|</span> <span class=\"n\">rw</span> <span class=\"o\">[</span>  <span class=\"n\">iInf_pi_sum</span> <span class=\"n\">_</span><span class=\"o\">]</span> <span class=\"c1\">-- fails to match lhs to goal lhs</span>\n  <span class=\"bp\">|</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">iInf_pi_sum</span> <span class=\"n\">_</span><span class=\"o\">]</span> <span class=\"c1\">-- matches rhs to goal rhs</span>\n  <span class=\"bp\">|</span> <span class=\"n\">exact</span> <span class=\"n\">iInf_pi_sum</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">ki</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">ki</span> <span class=\"o\">:</span> <span class=\"n\">ENNReal</span><span class=\"o\">))</span> <span class=\"c1\">-- succeeds with explicit `f`</span>\n  <span class=\"bp\">|</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 411544980,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1704581776
    },
    {
        "content": "<p>Comments welcome, as I'm still in the learning stages with Lean.</p>",
        "id": 411545005,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1704581809
    }
]