[
    {
        "content": "<p>Obvious newbie question. I've search lean4 manual, TP in Lean, MIL and more but can't make it work. I have a disjunction in my hypothesis. I did:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"c1\">-- to do inv cancel let's break h_zero_abs_x into both cases 0 &lt; x and 0 &lt; -x and prove both cases</span>\n    <span class=\"k\">#check</span> <span class=\"n\">Or</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h_zero_abs_x</span> <span class=\"k\">with</span> <span class=\"c1\">-- TODO: how to name hypothesis with cases in lean4</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Or.inl</span> <span class=\"n\">h_x_pos</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Or.inr</span> <span class=\"n\">h_x_neg</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but lean4 doesn't like it. What am I doing wrong? I'd like to name my new hypothesis corresponding to each input to the constructor myself.</p>\n<p>Error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">alternative</span> <span class=\"n\">name</span> <span class=\"bp\">'</span><span class=\"n\">Or.inl'</span>\n</code></pre></div>\n<p>but I hovered over <code>Or</code> and it says it exists </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Or</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">Or</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">or</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">is</span> <span class=\"n\">the</span> <span class=\"n\">disjunction</span> <span class=\"n\">of</span> <span class=\"n\">propositions.</span> <span class=\"n\">There</span> <span class=\"n\">are</span> <span class=\"n\">two</span> <span class=\"n\">constructors</span> <span class=\"n\">for</span> <span class=\"n\">Or</span><span class=\"o\">,</span> <span class=\"n\">called</span> <span class=\"n\">Or.inl</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"n\">and</span> <span class=\"n\">Or.inr</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">and</span> <span class=\"n\">you</span> <span class=\"n\">can</span> <span class=\"n\">use</span> <span class=\"k\">match</span> <span class=\"n\">or</span> <span class=\"n\">cases</span> <span class=\"n\">to</span> <span class=\"n\">destruct</span> <span class=\"n\">an</span> <span class=\"n\">Or</span> <span class=\"n\">assumption</span> <span class=\"n\">into</span> <span class=\"n\">the</span> <span class=\"n\">two</span> <span class=\"n\">cases.</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">Init.Prelude</span>\n</code></pre></div>\n<p>so I'm puzzled.</p>\n<p>Thanks in advance!</p>",
        "id": 425170964,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1709756326
    },
    {
        "content": "<p>With <code>cases</code> syntax, you need to use <code>inl</code> and <code>inr</code> rather than <code>Or.inl</code> and <code>Or.inr</code></p>",
        "id": 425171569,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709756596
    },
    {
        "content": "<p>These names come from the names of the constructors themselves, and in particular, the names of the arguments to <code>Or.casesOn</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Or.casesOn</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">inl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"bp\">⋯</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">inr</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"bp\">⋯</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">motive</span> <span class=\"n\">t</span>\n</code></pre></div>",
        "id": 425171705,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709756650
    },
    {
        "content": "<p>Sorry if this is a dumb question. What confuses me is that cases seems to have very similar syntax to match statements in function defs. When I tried defining addition for MyNats it insisted (unless I did <code>open MyNats</code>) that I used <code>MyNats</code>. So I am still confused why Lean 4 knows what constructors to use without <code>open</code> while in this case seems to magically know it. e.g., Why isn't it <code>Or.casesOn.inl</code> then?</p>",
        "id": 425173562,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1709757443
    },
    {
        "content": "<p>It's similar to <code>match</code>, but it's not <code>match</code>. It's confusing that it looks the same but it has different behavior, but the simple answer is that it's just a different tactic.</p>\n<p>A longer answer might be that <code>cases</code> doesn't work using pattern matching. You're not allowed use <code>match</code> on a proof anyway.</p>",
        "id": 425173819,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709757575
    },
    {
        "content": "<p>It's seeing it's <code>Or</code> because you're passing it <code>h_zero_abs_x</code> and it can see the type, and since <code>cases</code> only gives you cases for each \"minor premise\" of <code>Or.casesOn</code>, there's no need to qualify the names.</p>",
        "id": 425174003,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709757637
    },
    {
        "content": "<p>Potentially, <code>cases</code> could be modified to allow writing <code>Or.inl</code> and <code>Or.inr</code>, or at least detect that you've done it and tell you what to write instead.</p>",
        "id": 425174051,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709757667
    },
    {
        "content": "<p>By the way, for MyNats, if you write <code>.succ</code>, if Lean can figure out that the expected type is a <code>MyNat</code>, it will read that as <code>MyNat.succ</code>. That saves needing to <code>open MyNat</code> if you're just trying to avoid writing <code>MyNat.succ</code>, at the small cost of prefixing the constructor with a dot.</p>",
        "id": 425174291,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709757780
    },
    {
        "content": "<p>Super helpful Kyle. Thank you. However, sadly I'm still struggling to tell lean to manipulate my goal. </p>\n<p>Now that I did</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"n\">cases</span> <span class=\"n\">h_zero_abs_x</span> <span class=\"k\">with</span> <span class=\"c1\">-- TODO: how to name hypothesis with cases in lean4</span>\n      <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"n\">h_x_pos</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n        <span class=\"k\">have</span> <span class=\"n\">h_x_ne_zero</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">ne_of_gt</span> <span class=\"n\">h_x_pos</span>\n      <span class=\"bp\">|</span> <span class=\"n\">nr</span> <span class=\"n\">h_x_neg</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- have h_neg_x_ne_zero : -x ≠ 0 := ne_of_gt h_x_neg</span>\n</code></pre></div>\n<p>I am trying to construct the proof inside each case. But it keeps giving me syntax error e.g.,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unexpected</span> <span class=\"n\">token</span> <span class=\"bp\">'</span><span class=\"kd\">by</span><span class=\"bp\">';</span> <span class=\"n\">expected</span> <span class=\"sc\">'?'</span><span class=\"o\">,</span> <span class=\"sc\">'_'</span><span class=\"o\">,</span> <span class=\"sc\">'{'</span> <span class=\"n\">or</span> <span class=\"n\">tactic</span>\n</code></pre></div>\n<p>I feel it's complaint make sense, since I am not stating a goal (so perhaps it's angry at the having another by) but deconstructing the hypothesis. But then I don't understand how  I'm suppose to construct the proof for each case if Lean 4 doesn't let me generate the tactic proofs as I'd normally would.</p>",
        "id": 425176775,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1709758740
    },
    {
        "content": "<p>Remove the <code>by</code> after <code>=&gt;</code></p>",
        "id": 425176882,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1709758792
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/113489-new-members/topic/how.20to.20name.20new.20hypothesis.20using.20cases.20h.20with.20in.20Lean.204/near/425176882\">said</a>:</p>\n<blockquote>\n<p>Remove the <code>by</code> after <code>=&gt;</code></p>\n</blockquote>\n<p>I had tried that. But, what was wrong is that my later case had a type constructor. It says <code>nr</code> instead of <code>inr</code>. However, it was hard to me to predict that would cause a bug in the current line I was actually trying to construct a proof on. Now I know cases needs both constructors to be done properly or it fails.</p>",
        "id": 425195701,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1709766966
    },
    {
        "content": "<p>fyi, if I have a analogous bug with match (typo in second constructor) it doesn't make Lean4 completely unusable on my other cases. e.g.,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">MyUnderyNat</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">O</span> <span class=\"o\">:</span> <span class=\"n\">MyUnderyNat</span>\n<span class=\"bp\">|</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">MyUnderyNat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">MyUnderyNat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">MyUnderyNat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">MyUnderyNat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">MyUnderyNat</span>\n<span class=\"bp\">|</span> <span class=\"n\">MyUnderyNat.O</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">MyUnderyNat.Su</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MyUnderyNat.S</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>ie putting my cursor on n doesn't confuse lean4.</p>",
        "id": 425196203,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1709767228
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/how.20to.20name.20new.20hypothesis.20using.20cases.20h.20with.20in.20Lean.204/near/425174291\">said</a>:</p>\n<blockquote>\n<p>By the way, for MyNats, if you write <code>.succ</code>, if Lean can figure out that the expected type is a <code>MyNat</code>, it will read that as <code>MyNat.succ</code>. That saves needing to <code>open MyNat</code> if you're just trying to avoid writing <code>MyNat.succ</code>, at the small cost of prefixing the constructor with a dot.</p>\n</blockquote>\n<p>What did you have in mind for this? I tried a specific example by defining the add function without prefixing but Lean4 didn't like it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">MyUnderyNat</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">O</span> <span class=\"o\">:</span> <span class=\"n\">MyUnderyNat</span>\n<span class=\"bp\">|</span> <span class=\"n\">Succ</span> <span class=\"o\">:</span> <span class=\"n\">MyUnderyNat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">MyUnderyNat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">MyUnderyNat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">MyUnderyNat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">MyUnderyNat</span>\n<span class=\"bp\">|</span> <span class=\"n\">MyUnderyNat.O</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">MyUnderyNat.Succ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MyUnderyNat.Succ</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">add'</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MyUnderyNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyUnderyNat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">m</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">O</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Succ</span> <span class=\"n\">m'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Succ</span> <span class=\"o\">(</span><span class=\"n\">add'</span> <span class=\"n\">m'</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">basic_nats.lean</span><span class=\"o\">:</span><span class=\"mi\">12</span><span class=\"o\">:</span><span class=\"mi\">24</span>\n<span class=\"n\">Messages</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">basic_nats.lean</span><span class=\"o\">:</span><span class=\"mi\">12</span><span class=\"o\">:</span><span class=\"mi\">4</span>\n<span class=\"n\">invalid</span> <span class=\"n\">pattern</span><span class=\"o\">,</span> <span class=\"n\">constructor</span> <span class=\"n\">or</span> <span class=\"kd\">constant</span> <span class=\"n\">marked</span> <span class=\"k\">with</span> <span class=\"bp\">'</span><span class=\"o\">[</span><span class=\"n\">match_pattern</span><span class=\"o\">]</span><span class=\"bp\">'</span> <span class=\"n\">expected</span>\n</code></pre></div>",
        "id": 425196435,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1709767390
    },
    {
        "content": "<p>Kyle was talking about this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"bp\">|</span> <span class=\"n\">bar</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span> <span class=\"n\">bar</span>  <span class=\"c1\">-- unknown identifier</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">bar</span> <span class=\"c1\">-- ok; expected type is Foo, so this is resolved to mean Foo.bar</span>\n</code></pre></div>",
        "id": 425198593,
        "sender_full_name": "Scott Kovach",
        "timestamp": 1709768688
    },
    {
        "content": "<p>This is an aside, but in most cases the following two should be the same.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">...</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">ne_of_gt</span> <span class=\"n\">h_x_pos</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">...</span> <span class=\"o\">:=</span> <span class=\"n\">ne_of_gt</span> <span class=\"n\">h_x_pos</span>\n</code></pre></div>\n<p><code>by</code> is a keyword that brings you into tactic mode while exact is a tactic that accepts terms (so you can think of it as bringing you back into term-mode.) Most of the time instances of <code>by exact</code> are redundant.</p>",
        "id": 425201548,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1709770151
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"374083\">Scott Kovach</span> <a href=\"#narrow/stream/113489-new-members/topic/how.20to.20name.20new.20hypothesis.20using.20cases.20h.20with.20in.20Lean.204/near/425198593\">said</a>:</p>\n<blockquote>\n<p>Kyle was talking about this:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"bp\">|</span> <span class=\"n\">bar</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span> <span class=\"n\">bar</span>  <span class=\"c1\">-- unknown identifier</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">bar</span> <span class=\"c1\">-- ok; expected type is Foo, so this is resolved to mean Foo.bar</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>got it, thanks. The example that worked for me what</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">add'</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MyUnderyNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyUnderyNat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">m</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">O</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">Succ</span> <span class=\"n\">m'</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">Succ</span> <span class=\"o\">(</span><span class=\"n\">add'</span> <span class=\"n\">m'</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I didn't know before this that <code>inductive Foo | bar</code> would define a inductive type with cons <code>bar</code> and that <code>.bar</code> made sense. Never seen that notation in any other programming language. Cool!</p>",
        "id": 425209409,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1709774908
    },
    {
        "content": "<p>very related. When I do <code>cases h_zer_lt_abs_x</code> it introduces new hypothesis into my local context with a name with a unicode. I assume this is the reason whenever I try to refer to it I can't use it or rename it. How do I refer to a hypothesis that was automatically named? Or that might have a special unicode? e.g., <br>\nMy current tactic</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"n\">cases</span> <span class=\"n\">h_zero_lt_abs_x</span>\n</code></pre></div>\n<p>leads to this hypothesis being introduced (as expected):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">h</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>but even if I copy paste the symbol ✝ or pair of symbols or manually write \"\\dagger\", I can't refer to that hypothesis. How do I refer to that hypothesis so I can actually make progress in my proof? (ideally rename it to <code>h_x_pos</code>).</p>",
        "id": 425209956,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1709775350
    },
    {
        "content": "<p>With Nat, <code>refl</code> &amp; <code>step</code> works for me. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">@</span><span class=\"n\">step</span> <span class=\"n\">n</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 425217354,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1709780248
    },
    {
        "content": "<p>I don't think that is what I was looking for (?). I'm not using the <code>with</code> statement in this second version of using the <code>cases</code> tactic.</p>",
        "id": 425232341,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1709790791
    },
    {
        "content": "<p>Lean produces goals with funny names I can refer to no matter what I do. I can't rename them or use them. But I want them of course, hence, why I called <code>cases</code> :)</p>",
        "id": 425232387,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1709790830
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246156\">@Brando Miranda</span> Does <code>rename_i h_x_pos</code> do what you want?</p>",
        "id": 425236661,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1709793519
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246156\">Brando Miranda</span> <a href=\"#narrow/stream/113489-new-members/topic/how.20to.20name.20new.20hypothesis.20using.20cases.20h.20with.20in.20Lean.204/near/425209409\">said</a>:</p>\n<blockquote>\n<p>I didn't know before this that <code>inductive Foo | bar</code> would define a inductive type with cons <code>bar</code> and that <code>.bar</code> made sense. Never seen that notation in any other programming language. Cool!</p>\n</blockquote>\n<p>Note that the syntax there is a bit compressed and possibly misleading. The more usual way to write it would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span>\n  <span class=\"bp\">|</span> <span class=\"n\">bar</span>\n</code></pre></div>\n<p>which is shorthand for</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span>\n</code></pre></div>",
        "id": 425237045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709793760
    },
    {
        "content": "<p>Likewise <code>.bar</code> is shorthand for <code>Foo.bar</code>, getting the type <code>Foo</code> from the expected type. It has precedent in <a href=\"https://docs.swift.org/swift-book/documentation/the-swift-programming-language/expressions/#Implicit-Member-Expression\">Swift</a></p>",
        "id": 425237382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709793957
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246156\">Brando Miranda</span> <a href=\"#narrow/stream/113489-new-members/topic/how.20to.20name.20new.20hypothesis.20using.20cases.20h.20with.20in.20Lean.204/near/425232387\">said</a>:</p>\n<blockquote>\n<p>Lean produces goals with funny names I can refer to no matter what I do. I can't rename them or use them. But I want them of course, hence, why I called <code>cases</code> :)</p>\n</blockquote>\n<p>If you just use <code>cases h_zero_abs_x</code> without the <code>with</code> then all the cases will appear in the infoview labeled e.g. <code>case inl</code> and <code>case inr</code>. You can then use the <code>case</code> tactic to focus on whichever goal you want: <code>case inl</code>. If you add an arguments after the case identifier, it will start naming the inaccessible hypotheses: <code>case inl h_x_pos</code> will give you what you're looking for.</p>",
        "id": 425401308,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1709848255
    },
    {
        "content": "<p>By the way, older versions of Lean 3 used to automatically name such hypotheses according to some pre-defined convention. While that was convenient for not having to name everything, it makes proofs quite brittle to changes in Lean, Mathlib, etc.</p>",
        "id": 425401886,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1709848462
    },
    {
        "content": "<p>could a moderator move <span class=\"user-mention\" data-user-id=\"698978\">@Samyak Tuladhar</span> 's post to a new thread? thanks</p>\n<p><strong>Edit:</strong> never mind, moved it myself</p>",
        "id": 425434421,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709865077
    },
    {
        "content": "<p>A message was moved from this topic to <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members/topic/Code.20is.20not.20live.20compiling\">#new members &gt; Code is not live compiling</a> by <span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span>.</p>",
        "id": 425434908,
        "sender_full_name": "Notification Bot",
        "timestamp": 1709865288
    }
]