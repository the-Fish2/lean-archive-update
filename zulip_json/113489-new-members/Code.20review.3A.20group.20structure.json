[
    {
        "content": "<p>For educational purposes I'm building a group structure from scratch with the goal of a.) writing it in fully idiomatic Lean 4 code while b.) still understanding all the code I've written (not just copy and pasting).</p>\n<p>Currently I have this code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- A magma is a set equipped with a binary operation.</span>\n<span class=\"kd\">class</span> <span class=\"n\">Magma</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Mul</span> <span class=\"n\">α</span>\n\n<span class=\"c1\">-- A semigroup is a magma whose binary operation is associative.</span>\n<span class=\"kd\">class</span> <span class=\"n\">Semigroup</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Magma</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul_assoc</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">*</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- A monoid is a semigroup with an identity element for the binary operation.</span>\n<span class=\"kd\">class</span> <span class=\"n\">One</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"kd\">instance</span> <span class=\"n\">One.toOfNat1</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"o\">‹</span><span class=\"n\">One</span> <span class=\"n\">α</span><span class=\"o\">›</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"kd\">class</span> <span class=\"n\">Monoid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Semigroup</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">One</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">one_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">g</span>\n  <span class=\"n\">mul_one</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">g</span>\n\n<span class=\"c1\">-- A group is a monoid with an inverse for every element.</span>\n<span class=\"kd\">class</span> <span class=\"n\">Inv</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"kd\">postfix</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"⁻¹\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Inv.inv</span>\n<span class=\"kd\">class</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Monoid</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">Inv</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul_left_inv</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n  <span class=\"n\">mul_right_inv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n\n<span class=\"c1\">-- An abelian group is a group whose binary operation is commutative.</span>\n<span class=\"kd\">class</span> <span class=\"n\">AbelianGroup</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Group</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul_comm</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"bp\">*</span> <span class=\"n\">g</span>\n</code></pre></div>\n<p>Questions:</p>\n<p>1.</p>\n<p>Is there anything I can improve in the above to make it more idiomatic?</p>\n<p>(I understand that extending <code>Mul</code> to introduce the name <code>Magma</code> is a bit odd, but for pedagogical reasons I'd like to spell out every part of the structure from magma and up.)</p>\n<p>2.</p>\n<p>I'm not fully comfortable with the following code snippet:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">One.toOfNat1</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"o\">‹</span><span class=\"n\">One</span> <span class=\"n\">α</span><span class=\"o\">›</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>It feels somewhat magic. How should I understand it?</p>\n<p>Previously I used …</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">HasIdentityElement</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"kd\">notation</span> <span class=\"s2\">\"e\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">HasIdentityElement.e</span>\n</code></pre></div>\n<p>… which feels much more self-explaining, but I guess I must use <code>One.toOfNat1</code> to get <code>1</code> instead of <code>e</code> for the identity?</p>",
        "id": 423103457,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1708726615
    },
    {
        "content": "<p>Why not introducing <code>Magma</code> from scratch? Copying the definition of <code>Mul</code>.</p>",
        "id": 423104448,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708727106
    },
    {
        "content": "<p>Like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- A magma is a set equipped with a binary operation.</span>\n<span class=\"kd\">class</span> <span class=\"n\">Magma</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"kd\">infixl</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"s2\">\"*\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Magma.mul</span>\n</code></pre></div>",
        "id": 423104782,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1708727274
    },
    {
        "content": "<p>Ah, <code>Mul</code> is in <code>Prelude</code>, so you cannot not import it, and now your notation might conflict with the built in <code>*</code>.</p>",
        "id": 423104915,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708727339
    },
    {
        "content": "<p>Indeed using an high priority might work, but your first solution was probably better.</p>",
        "id": 423104951,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708727357
    },
    {
        "content": "<p>But I would use a notation for <code>Magma</code>, instead of a new class.</p>",
        "id": 423105125,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708727446
    },
    {
        "content": "<p>With</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Magma</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Mul</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>if <code>h : Magma α</code>, then <code>h.1 : Mul α</code>, and to get to the operation you have to write <code>h.1.1</code> (this is rarely needed of course, but still).</p>",
        "id": 423105223,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708727507
    },
    {
        "content": "<p>Something like <code>local notation \"Magma\" α =&gt; Mul α</code> if you don't want to use <code>Mul</code> everywhere.</p>",
        "id": 423105416,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708727610
    },
    {
        "content": "<p>(you can also play the game of <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a> chapter 7 and use a different symbol for the operation)</p>",
        "id": 423105451,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708727631
    },
    {
        "content": "<p>Concerning</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">One.toOfNat1</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"o\">‹</span><span class=\"n\">One</span> <span class=\"n\">α</span><span class=\"o\">›</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>you can just ignore it. The point is that Lean treats numerals in a special way (so that if you type <code>452353245324653456435</code> it understands it as a natural number, even if of course this one has never been defined explicitly). That code just set up a notation <code>1 : α</code> for the element <code>One.one : α</code>.</p>",
        "id": 423105758,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708727789
    },
    {
        "content": "<p>Another question: in Lean code I often see notation defined as this: <code>infixl:70 … \" * \" =&gt; …</code>.</p>\n<p>Is that equivalent to <code>infixl:70 … \"*\" =&gt; …</code> (note the lack of spaces)? Are the spaces ignored?</p>",
        "id": 423106871,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1708728514
    },
    {
        "content": "<p>The spaces are used when printing</p>",
        "id": 423106967,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708728584
    },
    {
        "content": "<p>Which of these formulations is the idiomatic one?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Monoid</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">Inv</span> <span class=\"n\">α</span> <span class=\"n\">where</span> <span class=\"bp\">…</span>\n<span class=\"kd\">class</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Monoid</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">Inv</span> <span class=\"n\">α</span> <span class=\"n\">where</span> <span class=\"bp\">…</span>\n<span class=\"kd\">class</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Monoid</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">Inv</span> <span class=\"n\">G</span> <span class=\"n\">where</span> <span class=\"bp\">…</span>\n<span class=\"kd\">class</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Monoid</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">Inv</span> <span class=\"n\">G</span> <span class=\"n\">where</span> <span class=\"bp\">…</span>\n</code></pre></div>",
        "id": 423107699,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1708729069
    },
    {
        "content": "<p>Surely <code>Type u</code> is more general.</p>",
        "id": 423108067,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708729276
    },
    {
        "content": "<p>For the other choice it really depends, mathlib goes via crazy classes like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MulOneClass#doc\">docs#MulOneClass</a></p>",
        "id": 423108275,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708729414
    },
    {
        "content": "<p>anything should be fine at the beginning.</p>",
        "id": 423108289,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708729427
    },
    {
        "content": "<p>When I'm teaching I don't introduce universes at all. It's just one less thing to worry about. People are total universe fanatics here (\"they're in the language so why not use them\") but for teaching purposes I've never seen the point of them.</p>",
        "id": 423139665,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708755120
    },
    {
        "content": "<p>And I always use sensible notation not alpha. The whole alpha thing was just how mathlib was initially developed in 2017 and there's still plenty of it around but I found it obfuscated things in algebra files because you can't tell what assumptions there are on a type when it's called alpha, whereas in a group theory file you can start guessing that M is a monoid, G and H are groups, A is an abelian group etc</p>",
        "id": 423139839,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708755295
    },
    {
        "content": "<p>Thanks a lot for the helpful hints <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> and <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>! I'm now using <code>Type</code> instead of <code>Type …</code> throughout. I've also switched from the alpha thing to M, G, H, A, etc.</p>\n<p>I've now reached the stage where I'm ready to define <code>Ring</code>.</p>\n<p>I'm doing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- A ring is a set equipped with two binary operations, addition and</span>\n<span class=\"c1\">-- multiplication, where addition forms an abelian group, multiplication</span>\n<span class=\"c1\">-- forms a monoid, and multiplication is distributive over addition.</span>\n<span class=\"kd\">class</span> <span class=\"n\">Ring₁</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">AdditiveAbelianGroup</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">Monoid</span> <span class=\"n\">R</span> <span class=\"n\">where</span>\n  <span class=\"n\">left_distrib</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n  <span class=\"n\">right_distrib</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Ring₂</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">AdditiveAbelianGroup</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">Monoid</span> <span class=\"n\">R</span> <span class=\"n\">where</span>\n  <span class=\"n\">left_distrib</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span>\n  <span class=\"n\">right_distrib</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p><code>Ring₁</code> compiles whereas <code>Ring₂</code> fails with <code>failed to synthesize instance HAdd R R ?m.[…]</code>.</p>\n<p>My questions:</p>\n<ol>\n<li>Does <code>Ring₁</code> look correct?</li>\n<li>How can I make <code>Ring₂</code> compile?</li>\n</ol>\n<p>Full <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- A magma is a set equipped with a binary operation.</span>\n<span class=\"kd\">class</span> <span class=\"n\">Magma</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul</span><span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">M</span>\n<span class=\"kd\">infixl</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"s2\">\" * \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Magma.mul</span>\n<span class=\"kd\">class</span> <span class=\"n\">AdditiveMagma</span> <span class=\"o\">(</span><span class=\"n\">AM</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">add</span><span class=\"o\">:</span> <span class=\"n\">AM</span> <span class=\"bp\">→</span> <span class=\"n\">AM</span> <span class=\"bp\">→</span> <span class=\"n\">AM</span>\n<span class=\"kd\">infixl</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"s2\">\" + \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">AdditiveMagma.add</span>\n\n<span class=\"c1\">-- A semigroup is a magma whose binary operation is associative.</span>\n<span class=\"kd\">class</span> <span class=\"n\">Semigroup</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Magma</span> <span class=\"n\">S</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul_assoc</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">*</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">AdditiveSemigroup</span> <span class=\"o\">(</span><span class=\"n\">AS</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">AdditiveMagma</span> <span class=\"n\">AS</span> <span class=\"n\">where</span>\n  <span class=\"n\">add_assoc</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">AS</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">+</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">+</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- A monoid is a semigroup with an identity element for the binary operation.</span>\n<span class=\"kd\">class</span> <span class=\"n\">One</span> <span class=\"o\">(</span><span class=\"n\">O</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">O</span>\n<span class=\"kd\">instance</span> <span class=\"n\">One.toOfNat1</span> <span class=\"o\">{</span><span class=\"n\">O</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">One</span> <span class=\"n\">O</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">O</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"o\">‹</span><span class=\"n\">One</span> <span class=\"n\">O</span><span class=\"o\">›</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"kd\">class</span> <span class=\"n\">Monoid</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Semigroup</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">One</span> <span class=\"n\">M</span> <span class=\"n\">where</span>\n  <span class=\"n\">one_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">g</span>\n  <span class=\"n\">mul_one</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">g</span>\n<span class=\"kd\">class</span> <span class=\"n\">Zero</span> <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">Z</span>\n<span class=\"kd\">instance</span> <span class=\"n\">Zero.toOfNat0</span> <span class=\"o\">{</span><span class=\"n\">Z</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">Z</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">Z</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"o\">‹</span><span class=\"n\">Zero</span> <span class=\"n\">Z</span><span class=\"o\">›</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"kd\">class</span> <span class=\"n\">AdditiveMonoid</span> <span class=\"o\">(</span><span class=\"n\">AM</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">AdditiveSemigroup</span> <span class=\"n\">AM</span><span class=\"o\">,</span> <span class=\"n\">Zero</span> <span class=\"n\">AM</span> <span class=\"n\">where</span>\n  <span class=\"n\">one_add</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">AM</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">g</span>\n  <span class=\"n\">add_one</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">AM</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">g</span>\n\n<span class=\"c1\">-- A group is a monoid with an inverse for every element.</span>\n<span class=\"kd\">class</span> <span class=\"n\">Inverse</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">I</span>\n<span class=\"kd\">postfix</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"⁻¹\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Inverse.inv</span>\n<span class=\"kd\">class</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Monoid</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">Inverse</span> <span class=\"n\">G</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul_left_inv</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n  <span class=\"n\">mul_right_inv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n<span class=\"kd\">class</span> <span class=\"n\">AdditiveInverse</span> <span class=\"o\">(</span><span class=\"n\">AI</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">AI</span> <span class=\"bp\">→</span> <span class=\"n\">AI</span>\n<span class=\"kd\">prefix</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"-\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">AdditiveInverse.inv</span>\n<span class=\"kd\">class</span> <span class=\"n\">AdditiveGroup</span> <span class=\"o\">(</span><span class=\"n\">AG</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">AdditiveMonoid</span> <span class=\"n\">AG</span><span class=\"o\">,</span> <span class=\"n\">AdditiveInverse</span> <span class=\"n\">AG</span> <span class=\"n\">where</span>\n  <span class=\"n\">add_left_inv</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">AG</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">add_right_inv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">AG</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n\n<span class=\"c1\">-- An abelian group is a group whose binary operation is commutative.</span>\n<span class=\"kd\">class</span> <span class=\"n\">AbelianGroup</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Group</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul_comm</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"bp\">*</span> <span class=\"n\">g</span>\n<span class=\"kd\">class</span> <span class=\"n\">AdditiveAbelianGroup</span> <span class=\"o\">(</span><span class=\"n\">AA</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">AdditiveGroup</span> <span class=\"n\">AA</span> <span class=\"n\">where</span>\n  <span class=\"n\">add_comm</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">AA</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">+</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"bp\">+</span> <span class=\"n\">g</span>\n\n<span class=\"c1\">-- A ring is a set equipped with two binary operations, addition and</span>\n<span class=\"c1\">-- multiplication, where addition forms an abelian group, multiplication</span>\n<span class=\"c1\">-- forms a monoid, and multiplication is distributive over addition.</span>\n<span class=\"kd\">class</span> <span class=\"n\">Ring₁</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">AdditiveAbelianGroup</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">Monoid</span> <span class=\"n\">R</span> <span class=\"n\">where</span>\n  <span class=\"n\">left_distrib</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n  <span class=\"n\">right_distrib</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Ring₂</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">AdditiveAbelianGroup</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">Monoid</span> <span class=\"n\">R</span> <span class=\"n\">where</span>\n  <span class=\"n\">left_distrib</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span>\n  <span class=\"n\">right_distrib</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span>\n</code></pre></div>",
        "id": 423166804,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1708778459
    },
    {
        "content": "<p>Change <code>infixl:70 (priority := high) \" + \" =&gt; AdditiveMagma.add</code> to something like <code>infixl:65 (priority := high) \" + \" =&gt; AdditiveMagma.add</code>. Multiplication should have an higher priority than addition.</p>",
        "id": 423167312,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708779029
    },
    {
        "content": "<p>Otherwise the parenthesis are wrong in <code>Ring₂</code> (the fact that Lean gives you an error rather than simply using the wrong parenthesis is a little subtler, I suggest you to ignore it for the moment).</p>",
        "id": 423167386,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708779101
    },
    {
        "content": "<p>Ah of course! Thanks!</p>\n<p>After …</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">-</span><span class=\"kd\">infixl</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"s2\">\" + \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">AdditiveMagma.add</span>\n<span class=\"bp\">+</span><span class=\"kd\">infixl</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"s2\">\" + \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">AdditiveMagma.add</span>\n</code></pre></div>\n<p>… I'm now doing …</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Ring</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">AdditiveAbelianGroup</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">Monoid</span> <span class=\"n\">R</span> <span class=\"n\">where</span>\n  <span class=\"n\">left_distrib</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span>\n  <span class=\"n\">right_distrib</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p>… which works!</p>",
        "id": 423167777,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1708779477
    },
    {
        "content": "<p>If you want to see something slightly different try modules!</p>",
        "id": 423168128,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708779781
    },
    {
        "content": "<p>The basic class is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SMul#doc\">docs#SMul</a></p>",
        "id": 423168220,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708779871
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> That's a good idea. Thanks! My current plan is to work myself up to <code>Field</code> and then tackle \"two sets with operations\": I'm thinking module, vector space and then inner product space.</p>\n<p>I've proceeded with <code>Field</code> doing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- A commutative ring is a ring in which the multiplication operation is</span>\n<span class=\"c1\">-- commutative.</span>\n<span class=\"kd\">class</span> <span class=\"n\">CommutativeRing</span> <span class=\"o\">(</span><span class=\"n\">CR</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Ring</span> <span class=\"n\">CR</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul_comm</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">CR</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"bp\">*</span> <span class=\"n\">g</span>\n\n<span class=\"c1\">-- A field is a commutative ring which contains a multiplicative inverse</span>\n<span class=\"c1\">-- for every nonzero element.</span>\n<span class=\"kd\">class</span> <span class=\"n\">Field</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">CommutativeRing</span> <span class=\"n\">F</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul_inv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>Looks correct?</p>\n<p>I'm not sure if my definition of <code>Field</code>, <code>Zero</code> and <code>One</code> currently implies <code>0 ≠ 1</code> (or if/when it should). I guess I could make <code>(0 : F) ≠ 1</code> explicit in <code>Field</code>. Should I and would that be the appropriate way to handle that?</p>",
        "id": 423172471,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1708783322
    },
    {
        "content": "<p>Following standard mathematical terminology, in a field <code>0 ≠ 1</code>, and the trivial ring surely satisfies</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>(since there are no <code>a ≠ 0</code>), so you should change the definition. I mean, yours has a (small) mathematical problem.</p>",
        "id": 423172691,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708783493
    },
    {
        "content": "<p>What is your goal, to learn how to set things up?</p>",
        "id": 423172733,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708783523
    },
    {
        "content": "<p>Anyway, for groups you followed the approva via <code>Inv</code>, you can do the same with fields: it gives you the same advantages (i.e. the notation <code>⁻¹</code>).</p>",
        "id": 423172867,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708783618
    },
    {
        "content": "<p>Note that for <code>Inv</code> it's convenient in type theory to allow <code>Inv 0</code> to make sense, and in mathlib we define it to be 0. The problem with <code>∀ a : F, a ≠ 0 → ∃ b : F, a * b = 1</code> is the same as the problem you avoided by not writing <code>∀ g : G, ∃ h : G, g * h = 1</code> for group inverses. If you use this as definition of inverse then you realise that it's not a definition, you have to use the axiom of choice to get the h(g) you want for all g, and things are much more inconvenient. It's easier to define an <code>Inv</code> function on groups sending an element <code>g</code> to <code>Inv g</code> and then demanding <code>g * Inv g = 1</code> (and also setting up notation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>g</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">g^{-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0085em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> for <code>Inv g</code> of course). The same is true for fields; don't just demand an inverse exists, ask for a function, and demand it has good properties, because in practice you want the function, not just some abstract existence statement. This involves defining <code>Inv 0</code> and the easiest solution is to just let it be 0, because you can't make Lean \"crash\" by dividing by 0.</p>",
        "id": 423175588,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708785516
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113489-new-members/topic/Code.20review.3A.20group.20structure/near/423172733\">said</a>:</p>\n<blockquote>\n<p>What is your goal, to learn how to set things up?</p>\n</blockquote>\n<p>Good question! My goal is to learn how to formalize first-year undergraduate abstract algebra from scratch in Lean 4 with an initial focus on group theory.</p>",
        "id": 423190431,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1708796037
    },
    {
        "content": "<p>Did you read Chapter 7 of <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a>?</p>",
        "id": 423192316,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1708797757
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> I've skimmed it and looked at the code before, but now I have read it. Thanks for writing it! It is a great learning resource. I like it a lot.</p>\n<p>This is my attempt at extracting the group theory part of chapter 7.1 and then removing all dependencies on Mathlib and <code>Prelude.lean</code> to make it fully self-contained:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">GroupTheoryFromMILChapter7</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Mul₁</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"kd\">infixl</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"s2\">\" * \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Mul₁.mul</span>\n<span class=\"kd\">class</span> <span class=\"n\">Semigroup₁</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Mul₁</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">One₁</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"kd\">instance</span> <span class=\"n\">One₁.toOfNat1</span> <span class=\"o\">{</span><span class=\"n\">O</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">One₁</span> <span class=\"n\">O</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">O</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"o\">‹</span><span class=\"n\">One₁</span> <span class=\"n\">O</span><span class=\"o\">›</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"kd\">class</span> <span class=\"n\">MulOneClass₁</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">One₁</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">Mul₁</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">one_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n  <span class=\"n\">mul_one</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n<span class=\"kd\">class</span> <span class=\"n\">Monoid₁</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Semigroup₁</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">MulOneClass₁</span> <span class=\"n\">M</span>\n<span class=\"kd\">class</span> <span class=\"n\">Inv₁</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"kd\">postfix</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"⁻¹\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Inv₁.inv</span>\n<span class=\"kd\">class</span> <span class=\"n\">Group₁</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Monoid₁</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">Inv₁</span> <span class=\"n\">G</span> <span class=\"n\">where</span>\n  <span class=\"n\">inv_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n  <span class=\"n\">mul_inv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n<span class=\"kd\">class</span> <span class=\"n\">AbelianGroup₁</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Group₁</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>Let me know if anything looks odd.</p>",
        "id": 423211636,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1708816291
    },
    {
        "content": "<p>I noticed that my code still seems to work as expected after doing the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">-</span><span class=\"kd\">instance</span> <span class=\"n\">One₁.toOfNat1</span> <span class=\"o\">{</span><span class=\"n\">O</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">One₁</span> <span class=\"n\">O</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">O</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"o\">‹</span><span class=\"n\">One₁</span> <span class=\"n\">O</span><span class=\"o\">›</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"bp\">+</span><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">O</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">One₁</span> <span class=\"n\">O</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">O</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"o\">‹</span><span class=\"n\">One₁</span> <span class=\"n\">O</span><span class=\"o\">›</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>When should I include the function name argument (\"One₁.toOfNat1\" in this case) and when is it okay to omit it?</p>",
        "id": 423214079,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1708818710
    },
    {
        "content": "<p>If you omit it then it will be named automatically, and possibly poorly. You can see what it was named by typing <code>whatsnew in</code> before the instance.</p>",
        "id": 423214886,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708819551
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Thanks for the hints regarding the field definition.</p>\n<p>Here is my new try:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- A commutative ring is a ring in which the multiplication operation is</span>\n<span class=\"c1\">-- commutative.</span>\n<span class=\"kd\">class</span> <span class=\"n\">CommutativeRing</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Ring</span> <span class=\"n\">R</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span>\n\n<span class=\"c1\">-- A field is a commutative ring which contains a multiplicative inverse</span>\n<span class=\"c1\">-- for every nonzero element.</span>\n<span class=\"kd\">class</span> <span class=\"n\">Field</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">CommutativeRing</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">Inverse</span> <span class=\"n\">F</span> <span class=\"n\">where</span>\n  <span class=\"n\">zero_ne_one</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span>\n  <span class=\"n\">mul_inv_cancel</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n  <span class=\"n\">inv_zero</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>Let me know if anything looks odd.</p>",
        "id": 423288280,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1708891669
    },
    {
        "content": "<p>Looks good to me at first glance!</p>",
        "id": 423294010,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708897434
    }
]