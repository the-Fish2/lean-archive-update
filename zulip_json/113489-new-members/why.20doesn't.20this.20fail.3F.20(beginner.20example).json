[
    {
        "content": "<p>The below lean code is an attempt to prove that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi><mo>=</mo><mn>4</mn><mi mathvariant=\"normal\">/</mi><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">b=4/3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">4/3</span></span></span></span>, given the following</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo>∈</mo><mi mathvariant=\"normal\">N</mi><mspace linebreak=\"newline\"></mspace><mi>b</mi><mo>=</mo><mi>a</mi><mi mathvariant=\"normal\">/</mi><mn>3</mn><mspace linebreak=\"newline\"></mspace><mi>a</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">a,b \\in  ℕ \\\\ b = a/3 \\\\  a=4\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord amsrm\">N</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord\">/3</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span></span></span></span></span></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"bp\">/</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">calc</span>\n<span class=\"w\">    </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h2</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"bp\">/</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n</code></pre></div>\n<p>This reports no errors or warnings.</p>\n<p>My question: shouldn't this fail because <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mi mathvariant=\"normal\">/</mi><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">4/3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">4/3</span></span></span></span> is not a natural number?</p>",
        "id": 444492079,
        "sender_full_name": "rzeta0",
        "timestamp": 1718292125
    },
    {
        "content": "<p><code>4/3 = 1</code> when <code>4</code> and <code>3 </code> are natural numbers. (Division on natural numbers rounds down.)</p>",
        "id": 444492575,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1718292248
    },
    {
        "content": "<p>yikes! </p>\n<ol>\n<li>\n<p>Allow me to be a little brave and suggest this is counter-intuitive behaviour, and that lean should actually produce an error / warning.   .. But given that I am a beginner, it is possible that this behaviour is beneficial. Can I ask therefore why lean should do this?</p>\n</li>\n<li>\n<p>How should one catch such an error? Do I need a different kind of type declaration? Something like <code>{strict a b : ℕ</code> ?</p>\n</li>\n</ol>",
        "id": 444493324,
        "sender_full_name": "rzeta0",
        "timestamp": 1718292454
    },
    {
        "content": "<p>This is a common trap for beginners: division on natural numbers (and integers) is always defined, and the result is a natural number (integer); in particular, it does not necessarily agree with the result of dividing the same numbers considered as rational numbers.</p>",
        "id": 444493355,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1718292462
    },
    {
        "content": "<p>Another way might be to use a different division operator? Is there one that doesn't allow this to pass?</p>",
        "id": 444493738,
        "sender_full_name": "rzeta0",
        "timestamp": 1718292560
    },
    {
        "content": "<p>I think the general idea is that it is more convenient to have operations be always defined, but add the necessary assumptions when proving statements about them. E.g., <code>a / 0</code> is defined to be <code>0</code>, but when you want to prove statements about division (say, in a field), then you usually need to assume that denominators are nonzero.</p>",
        "id": 444494655,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1718292766
    },
    {
        "content": "<p>This has been discussed several times. The short answer is that beginners should just avoid division (or subtraction) on natural numbers, and use something like <code>(3 : ℚ)/4</code>, that is the usual thing.</p>",
        "id": 444494676,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718292771
    },
    {
        "content": "<p>What is confusing in this specific case is that the same notation <code>/</code> is used to denote operations on <code>ℕ</code> and <code>ℚ</code> (say) that are not compatible w.r.t. the canonical map <code>ℕ → ℚ</code>.</p>",
        "id": 444495245,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1718292866
    },
    {
        "content": "<p>Yes, it is confusing. The problem with introducing another notation is that we really want <code>4/2=2</code></p>",
        "id": 444495420,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718292906
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> <a href=\"#narrow/stream/113489-new-members/topic/why.20doesn't.20this.20fail.3F.20.28beginner.20example.29/near/444493324\">said</a>:</p>\n<blockquote>\n<p>yikes! </p>\n<ol>\n<li>\n<p>Allow me to be a little brave and suggest this is counter-intuitive behaviour, and that lean should actually produce an error / warning.   .. But given that I am a beginner, it is possible that this behaviour is beneficial. Can I ask therefore why lean should do this?</p>\n</li>\n<li>\n<p>How should one catch such an error? Do I need a different kind of type declaration? Something like <code>{strict a b : ℕ</code> ?</p>\n</li>\n</ol>\n</blockquote>\n<p>Regarding 2, you just discovered one of the possible source of errors in a proof checked by Lean (or by any other proof assistant), and probably the most important one: the computer cannot check <em>definitions</em>.</p>",
        "id": 444495963,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718293028
    },
    {
        "content": "<p>Thank you Riccardo and Michael for offering helpful comments.</p>\n<p>To me this feels unsatisfactory. I'm no expert in the implementation or history of lean but purely from a user's perspective it feels like any proof assistant should</p>\n<ul>\n<li>throw an error when a  value is being assigned to an incompatible type eg <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>∈</mo><mi mathvariant=\"normal\">N</mi><mo>∧</mo><mi>a</mi><mo>=</mo><mn>4</mn><mi mathvariant=\"normal\">/</mi><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">a \\in ℕ \\land a=4/3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord amsrm\">N</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">4/3</span></span></span></span></li>\n<li><code>a/0</code> shouldn't be defined to be <code>0</code> </li>\n</ul>\n<p>Will I get angry replies if I suggest this on the github for lean?</p>\n<p>Perhaps I will discover the wisdom of Lean's designers as I progress... </p>\n<p>So as a final question in this thread, how would I modify the following to actually throw an error?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"bp\">/</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">calc</span>\n<span class=\"w\">    </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h2</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"bp\">/</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n</code></pre></div>",
        "id": 444499752,
        "sender_full_name": "rzeta0",
        "timestamp": 1718293932
    },
    {
        "content": "<p>I do think it would be reasonable to scope truncated division as it is usually only needed in specific scenarios.</p>",
        "id": 444501645,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1718294416
    },
    {
        "content": "<p>You would only get links to Zulip where we explain the reasons behind such a design choice (I will look for one of those in a few minutes). We are very well aware that this is a problem for beginners, but taking into account all the pro and cons we still think it is the best solution.</p>",
        "id": 444501912,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718294470
    },
    {
        "content": "<p>For example you can have a look <a href=\"#narrow/stream/113488-general/topic/Opaque.20junk.20values.20for.20partial.20functions\">here</a> but Zulip is full of similar discussions.</p>",
        "id": 444502361,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718294584
    },
    {
        "content": "<p>I think it is worth emphasizing that Riccardo’s <em>we</em> in “we still think it is the best solution” is a very broad one. It is not limited to Lean.</p>",
        "id": 444503052,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1718294752
    },
    {
        "content": "<p>To be clear, I am all for junk values. What I am suggesting is that for integers <code>n</code> and <code>m</code>, <code>n/m</code> should by default typecheck as a rational number. If you want integer division, you should open a scope (This would be possible, right?).</p>",
        "id": 444511247,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1718296855
    },
    {
        "content": "<p>The problem with this is that <code>6/3</code> would be a rational.</p>",
        "id": 444519531,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718299446
    },
    {
        "content": "<p>...which would need some effort to be turned back into a natural number.</p>",
        "id": 444521085,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1718299841
    },
    {
        "content": "<p>Note that this division behavior isn't just a Lean thing but also a statically typed programming languages (and Python 2) thing</p>\n<p>Haskell does the \"no /\" thing though</p>",
        "id": 444522101,
        "sender_full_name": "llllvvuu",
        "timestamp": 1718300170
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113489-new-members/topic/why.20doesn't.20this.20fail.3F.20.28beginner.20example.29/near/444519531\">said</a>:</p>\n<blockquote>\n<p>The problem with this is that <code>6/3</code> would be a rational.</p>\n</blockquote>\n<p>wouldn't we expect that a proof assistant could prove that 6/3 was equivalent to an element of ℕ ? </p>\n<p>perhaps this should be part of <code>num_norm</code> ?</p>",
        "id": 444522791,
        "sender_full_name": "rzeta0",
        "timestamp": 1718300404
    },
    {
        "content": "<p>Of course you can prove that there is an integer such that its coercion is <code>6/3</code>. Even if automation could help with explicit numbers, what about <code>(2*n)/n</code>? The point is exactly that it <em>seems</em> a reasonable idea,  but experience tells us that the current design is better.</p>",
        "id": 444523586,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718300668
    },
    {
        "content": "<p>Unless you have a particular reason to need <code>Nat</code>, maybe it's best to avoid <code>Nat</code> and stick with <code>Rat</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"bp\">/</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">calc</span>\n<span class=\"w\">    </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h2</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"bp\">/</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n</code></pre></div>\n<p>There's no <code>Rat.isNat</code> predicate yet, but at least there's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Rat.isInt#doc\">docs#Rat.isInt</a></p>",
        "id": 444525088,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718301209
    },
    {
        "content": "<blockquote>\n<p>shouldn't this fail because 4/3 is not a natural number?</p>\n</blockquote>\n<p>VS Code hint: if you hover over the <code>/</code> in <code>4/3</code> in the source, you can see that it's a nat. Also, if you hover over it in the Infoview, you can see it's a <code>ℕ</code>.</p>\n<p><a href=\"/user_uploads/3121/x_VjF9wpT39adNi0u8E6R19Q/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/x_VjF9wpT39adNi0u8E6R19Q/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/x_VjF9wpT39adNi0u8E6R19Q/image.png\"></a></div>",
        "id": 444525402,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718301317
    },
    {
        "content": "<p>I wonder whether there should be a \"beginner's linter\" that flags uses of <code>Nat.sub</code>, <code>Nat.div</code> and a few other similar \"peculiarities\", giving some information to get used about what the conventions are.</p>",
        "id": 444553580,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718309868
    },
    {
        "content": "<p>Damiano, linter arc <span aria-label=\"muscle\" class=\"emoji emoji-1f4aa\" role=\"img\" title=\"muscle\">:muscle:</span></p>",
        "id": 444553977,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718309992
    },
    {
        "content": "<p>I remember when I was surprised to find out that</p>\n<ul>\n<li>Lean did not complain about <code>1 - 2 : ℕ</code>,</li>\n<li>the value of <code>1 - 2</code> is <code>0</code>.</li>\n</ul>\n<p>If they had been underlined with a message saying a couple of words about each, I would have felt better...</p>",
        "id": 444554049,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718310006
    },
    {
        "content": "<p>E.g., the equality <code>0-1=1/2</code> that holds by <code>rfl</code> can be seen like a joke.</p>",
        "id": 444554257,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718310088
    },
    {
        "content": "<p>I know of examples like <code>Nat.choose_eq_factorial_div_factorial</code> where integer division is arguably better, but I'm still not entirely sure that this behavior shouldn't be scoped. In general, programming languages are moving <em>away</em> from \"invisible\" integer division. Kyle's example of requiring the programmer to inspect a term just to understand what it is doing seems suboptimal when it comes to arithmetic (especially if you are reading someone else's code).  If it was made more explicit, it would cause less confusion and potentially avoid errors when stating theorems.<br>\nWe all don't have perfect type checkers in our heads to always distinguish between the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">5</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"bp\">/</span><span class=\"mi\">2</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"c1\">-- This coercion can happen \"invisibly\" also.</span>\n</code></pre></div>\n<p>I get that it's \"obvious\" what is happening here, but I feel that this can lead to silent errors. Formal mathematics is not just writing a proof the core can verify, but also checking that the statement is actually correct (which is still left to humans). Making this less error prone is a worthy goal in my opinion.</p>",
        "id": 444557335,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1718311145
    },
    {
        "content": "<p>So I continued to read the replies and suggested links.</p>\n<p>K Buzzard's argument here (<a href=\"https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/\">blog</a>) is that the division operator is just defined differently in Lean, and that it is not inherently wrong, just different. He states, to quote:</p>\n<blockquote>\n<p>It will simply not occur at the point when you do the division, it will occur at the point where you invoke the theorem which is not true for <code>real.div</code>.</p>\n</blockquote>\n<p>However I can't seem to apply this to my toy problem above. The theorem is that </p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo>∈</mo><mi mathvariant=\"normal\">N</mi><mo stretchy=\"false\">)</mo><mo>∧</mo><mo stretchy=\"false\">(</mo><mi>b</mi><mo>=</mo><mi>a</mi><mi mathvariant=\"normal\">/</mi><mn>3</mn><mo stretchy=\"false\">)</mo><mo>∧</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo>=</mo><mn>4</mn><mo stretchy=\"false\">)</mo><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mo stretchy=\"false\">(</mo><mi>b</mi><mo>=</mo><mn>4</mn><mi mathvariant=\"normal\">/</mi><mn>3</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">( a, b \\in ℕ ) \\land (b = a/3) \\land (a=4) \\implies (b=4/3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord amsrm\">N</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord\">/3</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">4</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">4/3</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The Lean appears to prove this theorem. Buzzard says, \"the problem simply shows up at a different point in the argument\" - but I can't see where that happens with this toy example.</p>",
        "id": 444565881,
        "sender_full_name": "rzeta0",
        "timestamp": 1718313737
    },
    {
        "content": "<p>The problem will happen when you try to prove <code>3 * b = 4</code> from your conclusion</p>",
        "id": 444566074,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718313848
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113489-new-members/topic/why.20doesn't.20this.20fail.3F.20.28beginner.20example.29/near/444503052\">said</a>:</p>\n<blockquote>\n<p>I think it is worth emphasizing that Riccardo’s <em>we</em> in “we still think it is the best solution” is a very broad one. It is not limited to Lean.</p>\n</blockquote>\n<p>I don't really agree with this. There's general agreement that the <code>x/0=0</code> behavior is the best solution within the confines of the type system, but the fact that <code>1/2 = 0</code> is arguably just something that every language has inherited from C (and in turn, ALUs in hardware) by default. Python decided that this was  silly and decided that they would change things so that <code>1/2 = 0.5</code>, and to get the C behavior you need <code>1//2 = 0</code>.</p>\n<p>Mathematically, I don't think we gain much by tricking users into thinking <code>/</code> is division when it's actually floor division; we could easily use a different symbol like Python does, or force the user to write the <code>Nat.floor</code> explicitly.</p>",
        "id": 444566860,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718314251
    },
    {
        "content": "<p>(Mathematicians saying \"what the heck is this <code>//</code> thing\" sounds better to me than them saying \"this system is stupid, it thinks 1/2 = 0\")</p>",
        "id": 444567013,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718314327
    },
    {
        "content": "<p>Yaël  - but what if i never do that, and leave the computer content that I have proven a theorem that should be false? That to me seems wrong.</p>\n<p>I also like one of the comments replying to Buzzard's blog: </p>\n<blockquote>\n<p>Like Martin says, you should be wary when you find yourself making choices to please the machine rather than the mathematician. The compromise I am content with is to listen to the machine when it asks me to do math better, but to be resistant when it asks me to make unmotivated choices.</p>\n</blockquote>",
        "id": 444567028,
        "sender_full_name": "rzeta0",
        "timestamp": 1718314338
    },
    {
        "content": "<p>PS - I want to say thank you to everyone who has offered their thoughts and ideas. It is all in the spirit of learning (and maybe even improving) :)</p>",
        "id": 444567265,
        "sender_full_name": "rzeta0",
        "timestamp": 1718314481
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> <a href=\"#narrow/stream/113489-new-members/topic/why.20doesn't.20this.20fail.3F.20.28beginner.20example.29/near/444567028\">said</a>:</p>\n<blockquote>\n<p>but what if i never do that, and leave the computer content that I have proven a theorem that should be false?</p>\n</blockquote>\n<p>That's why you don't just leave the computer content, but prove extra theorems that show you did state what you meant to state</p>",
        "id": 444567326,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718314517
    },
    {
        "content": "<p>See eg all of the <a href=\"https://github.com/leanprover-community/lean-liquid/tree/master/src/examples\">examples folder in the Liquid Tensor Experiment</a></p>",
        "id": 444567451,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718314579
    },
    {
        "content": "<p>You are taking issue with <code>/</code> on <code>ℕ</code>, but there are many more footguns, and it's overwhelmingly easy to make more, so the only way to clear up whether you have proved the theorem you meant is to <em>prove extra properties about it</em>.</p>",
        "id": 444567863,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718314773
    },
    {
        "content": "<p>I can't get behind the argument that because lean has many footguns, we can't have sensible defaults. <code>#eval 5 + 1/2</code> or <code>#eval 10 - 12</code> should have a sensible default. If you want truncated subtraction or integer division, you should have to opt in. That's all I'm suggesting. Maybe truncated subtraction and integer division are so ubiquitous in mathlib that it would always be opted in to, but I'm not really sure that's true.</p>",
        "id": 444584061,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1718323149
    },
    {
        "content": "<p>I'm also thinking hard about \"proving a theorem isn't sufficient, you have to find some other theorems to prove about that theorem and hope they find an error\". That doesn't sound right to me because there isn't a guaranteed way to ensure your other theorems will have complete coverage of the possible failure modes.</p>",
        "id": 444584630,
        "sender_full_name": "rzeta0",
        "timestamp": 1718323532
    },
    {
        "content": "<blockquote>\n<p>That doesn't sound right to me because there isn't a guaranteed way to ensure your other theorems will have complete coverage of the possible failure modes.</p>\n</blockquote>\n<p>Well no, this is essentially testing methodology. You can reduce the probability of errors by using it in a variety of ways. Theorem proofs don't need tests, that's what formal verification gives you, but theorem statements do because lean can't check your work here. Of course if you can express more things in the type system then lean can check more of your work, e.g. requiring that natural subtraction comes with a proof, but this can make the proof significantly more difficult.</p>",
        "id": 444587270,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718325584
    },
    {
        "content": "<p>I think part of the confusion is also that most programming languages don't default to numeral terms being of an unsigned int type. But that's what Nat is.</p>",
        "id": 444596869,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1718332398
    },
    {
        "content": "<p>I would definitely love to see the mathematically incorrect operators like natural subtraction and integer division having different notation to indicate that they're not what a mathematician would think. I think that one issue here is that computer scientists are very used to 5/2=2 but for mathematicians this convention is unheard of.</p>",
        "id": 444633867,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1718348966
    },
    {
        "content": "<p>Monus (truncated natural subtraction) has its own Unicode symbol (the dotted minus) which has been used by logicians for a long time, so that might be a low hanging fruit in terms of notation, in fact I think <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> even introduced that at some point? But I also seem to recall something along the lines that the FRO didn't like that because it would be weird for programmers, but I guess Mathlib could adopt a different convention since it has a different target audience</p>",
        "id": 444644033,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1718352344
    },
    {
        "content": "<p>I think truncating at 0 is also weird for programmers since typically unsigned subtraction wraps around.</p>\n<p>A non-Unicode way to express Nat subtraction could be <code>#eval (3).sub 5</code></p>",
        "id": 444646903,
        "sender_full_name": "llllvvuu",
        "timestamp": 1718353358
    },
    {
        "content": "<p>But what about things like <code>5 - 3</code>? Do we really want this to be <code>2 : ℤ</code>?</p>",
        "id": 444647497,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718353607
    },
    {
        "content": "<p>A conservative behavior (similar to division in Haskell) would be:</p>\n<p><code>(5 - 3 : ℤ)</code>: <code>2 : ℤ</code><br>\n<code>(5 - 3 : Nat)</code>: error<br>\n<code>5 - 3</code>: error<br>\n<code>Nat.sub 5 3</code>: <code>2 : Nat</code></p>",
        "id": 444649733,
        "sender_full_name": "llllvvuu",
        "timestamp": 1718354392
    },
    {
        "content": "<p>What would be the type of <code>-</code>?</p>",
        "id": 444649841,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718354418
    },
    {
        "content": "<p>I mean, the function that takes to natural numbers</p>",
        "id": 444649904,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718354442
    },
    {
        "content": "<p>It's already of type <code>A -&gt; B -&gt; C</code> in general</p>",
        "id": 444649923,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718354450
    },
    {
        "content": "<p>I mean if we want the error</p>",
        "id": 444649984,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718354477
    },
    {
        "content": "<p>It would still be <code>HSub</code> but without an <code>HSub Nat Nat Nat</code> instance</p>",
        "id": 444649993,
        "sender_full_name": "llllvvuu",
        "timestamp": 1718354482
    },
    {
        "content": "<p>The instance could be in an <code>open scoped</code>, and the elaborator could have special support for telling the user about the scope when it is not open</p>",
        "id": 444650080,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718354521
    },
    {
        "content": "<p>Yes, I understand you can disable the notation <code>-</code>, but the function <code>ℕ → ℕ → ℕ</code> would still be there, is this what you are proposing?</p>",
        "id": 444650254,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718354589
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kn\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">instSubNat</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">5</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sub</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">5</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 444650478,
        "sender_full_name": "llllvvuu",
        "timestamp": 1718354673
    },
    {
        "content": "<p>I think so? The operation should certainly still exist and it should be <em>possible</em> to write it with some notation or other, but it shouldn't be possible by default with <code>-</code></p>",
        "id": 444650487,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718354678
    },
    {
        "content": "<p>(I don't think writing <code>Nat.sub</code> directly is a good idea though, since that's different up to reducible defeq)</p>",
        "id": 444650582,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718354710
    },
    {
        "content": "<p>OK, </p>\n<p><span class=\"user-mention silent\" data-user-id=\"607118\">llllvvuu</span> <a href=\"#narrow/stream/113489-new-members/topic/why.20doesn't.20this.20fail.3F.20.28beginner.20example.29/near/444650478\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kn\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">instSubNat</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">5</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sub</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">5</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Note that here you also get an error writing <code>5-3</code>.</p>",
        "id": 444650799,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718354785
    },
    {
        "content": "<p>The expression elaborator could be taught to use int by default if it sees subtraction</p>",
        "id": 444650872,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718354829
    },
    {
        "content": "<p>Yes, but again, then <code>5-3</code> would be an integer.</p>",
        "id": 444650911,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718354848
    },
    {
        "content": "<p>I am not saying this is wrong or whatever, just that both solutions have problems</p>",
        "id": 444650952,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718354866
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113489-new-members/topic/why.20doesn't.20this.20fail.3F.20.28beginner.20example.29/near/444650799\">said</a>:</p>\n<blockquote>\n<p>Note that here you also get an error writing <code>5-3</code>.</p>\n</blockquote>\n<p>Yeah I think anything that makes 3 - 5 illegal at the type level has to also make 5 - 3 illegal for consistency sake</p>",
        "id": 444652259,
        "sender_full_name": "llllvvuu",
        "timestamp": 1718355337
    },
    {
        "content": "<p>Yes, unfortunately it seems a perfect solution does not exist (also, what about <code>n - (n + 1)</code>? This should be illegal, but if the expression is more complicated is impossible to say when the RHS is bigger than the LHS).</p>",
        "id": 444652916,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718355538
    },
    {
        "content": "<p>This may be a terrible idea, but would it be possible (again scoped) to have coercions from <code>ℚ → ℤ</code> and <code>ℤ → ℕ</code> which truncate appropriately? This way, <code>1 - 2</code> normally would be <code>-1 : ℤ</code>, but <code>(1 - 2) : ℕ = 0</code>.</p>",
        "id": 444683356,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1718365848
    },
    {
        "content": "<p>I don't understand what you mean. What would be the type of <code>- : ℕ → ℕ → ?</code></p>",
        "id": 444685480,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718366635
    },
    {
        "content": "<p>I suppose it would be possible (though I'm still very much a Lean beginner), but would it be a good idea? Coercions along this path would work reasonably well, but it is easy to make up situation where diagrams of reasonable coercions would not commute.</p>\n<p>It seems much more reasonable to have the reverse coercions (corresponding to subsets in set-based mathematics), where naturals are coerced to integers and so on. Also, I am not sure if you can have cycles in declared coercions.</p>",
        "id": 444685982,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1718366803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"560559\">Richard Osborn</span> <a href=\"#narrow/stream/113489-new-members/topic/why.20doesn't.20this.20fail.3F.20.28beginner.20example.29/near/444683356\">said</a>:</p>\n<blockquote>\n<p>but would it be possible (again scoped) to have coercions from <code>ℚ → ℤ</code> and <code>ℤ → ℕ</code> which truncate appropriately?</p>\n</blockquote>\n<p>Coercions should be reserved for operations that aren't surprising. Both <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.floor#doc\">docs#Int.floor</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.toNat#doc\">docs#Int.toNat</a> would be very surprising if inserted implicitly, so</p>\n<blockquote>\n<p>This [is] a terrible idea,</p>\n</blockquote>",
        "id": 444686022,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718366818
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113489-new-members/topic/why.20doesn't.20this.20fail.3F.20.28beginner.20example.29/near/444685480\">said</a>:</p>\n<blockquote>\n<p>I don't understand what you mean. What would be the type of <code>- : ℕ → ℕ → ?</code></p>\n</blockquote>\n<p>I would think the simplest would be for <code>n m : ℕ </code> to use integer subtraction (as <code>(n - m : ℤ)</code> does currently via coercions).</p>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/why.20doesn't.20this.20fail.3F.20.28beginner.20example.29/near/444686022\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"560559\">Richard Osborn</span> <a href=\"#narrow/stream/113489-new-members/topic/why.20doesn't.20this.20fail.3F.20.28beginner.20example.29/near/444683356\">said</a>:</p>\n<blockquote>\n<p>but would it be possible (again scoped) to have coercions from <code>ℚ → ℤ</code> and <code>ℤ → ℕ</code> which truncate appropriately?</p>\n</blockquote>\n<p>Coercions should be reserved for operations that aren't surprising. Both <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.floor#doc\">docs#Int.floor</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.toNat#doc\">docs#Int.toNat</a> would be very surprising if inserted implicitly, so</p>\n<blockquote>\n<p>This [is] a terrible idea,<br>\n</p>\n</blockquote>\n</blockquote>\n<p>I'm surprised that <code>floor</code> and <code>toNat</code> would be confusing but <code>1/2=0</code> and <code>2-5+10=10</code> isn't confusing?</p>",
        "id": 444688518,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1718367723
    },
    {
        "content": "<p>Both are confusing, but at least the first one you can say \"watch out when you see a <code>-</code> or <code>/</code> symbol\". \"watch out for something invisible\" is not so teachable an approach</p>",
        "id": 444688681,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718367796
    },
    {
        "content": "<p>Well, I wouldn't want the coercions to be enabled by default (as most wouldn't need the behavior). Though since coercions show up explicitly in the infoview, I would argue coercions are more visible than <code>-</code> and <code>/</code> changing behavior without any visual queues.<br>\nAlso, I realize the last parameter of <code>HSub</code> is an outparam, so my previous suggestion wouldn't work. Though this seems to work?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kn\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">instSubNat</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HSub</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hSub</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"c1\">-- -2</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Sub</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">instSubNat</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"c1\">-- 0</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">10</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- 13</span>\n</code></pre></div>",
        "id": 444691560,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1718368792
    },
    {
        "content": "<p>Anyways, maybe we don't even need coercions, just have <code>HSub Nat Nat Int</code> and <code>HDiv Int Int Rat</code> instances and scope <code>Sub Nat</code> and <code>Div Int</code> instances.</p>",
        "id": 444692047,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1718368946
    },
    {
        "content": "<p>So you propose that <code>(5 : ℕ) - (3 : ℕ) = (2 : ℤ)</code>?</p>",
        "id": 444693196,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718369347
    },
    {
        "content": "<p>This is surely doable, but in my opinion it would make mathematicians <em>very upset</em>, much more than <code>3 - 5 = 0</code>.</p>",
        "id": 444693454,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718369419
    },
    {
        "content": "<p>And so they open a scope which allows for truncated subtraction. Problem solved? If the argument is that truncated subtraction is so ubiquitous in mathlib, that you would want the scope to be open always, then I will concede that there's no point changing the status quo. I'm really not sure that this is the case.</p>",
        "id": 444694413,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1718369729
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 444694864,
        "sender_full_name": "rzeta0",
        "timestamp": 1718369849
    },
    {
        "content": "<p>As a total beginner and outsider I'm stepping back into this discussion again as I believe it is useful to get an outsider's perspective:</p>\n<p>If <code>5 - 3 = 2</code> is problematic or made more complicated than it needs to be, then I politely and respectfully suggest we're failing on user experience design.</p>\n<p>Over 25 years in tech has taught me to \"make the easy things easy\" and not allow complicated technical \"reasons\" to pollute those things that should remain easy and intuitive.</p>\n<p>Of course, it may be the collective view that Lean is not intended for such an audience, and will always require getting past a high barrier. That's the project's choice I guess.</p>",
        "id": 444695054,
        "sender_full_name": "rzeta0",
        "timestamp": 1718369892
    },
    {
        "content": "<p>Also, in certain cases, you could just use <code>Int.toNat</code> explicitly (which may increase readability).</p>",
        "id": 444695068,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1718369896
    },
    {
        "content": "<p>What is ubiquitous (or at least quite common) in mathlib is <code>a - b</code> where <code>b ≤ a</code>. As far as a mathematician is concerned, <code>3 - 5 = 37</code> would be perfectly fine, we just don't care.</p>",
        "id": 444695319,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718369974
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> <a href=\"#narrow/stream/113489-new-members/topic/why.20doesn't.20this.20fail.3F.20.28beginner.20example.29/near/444695054\">said</a>:</p>\n<blockquote>\n<p>As a total beginner and outsider I'm stepping back into this discussion again as I believe it is useful to get an outsider's perspective:</p>\n<p>If <code>5 - 3 = 2</code> is problematic or made more complicated than it needs to be, then I politely and respectfully suggest we're failing on user experience design.</p>\n<p>Over 25 years in tech has taught me to \"make the easy things easy\" and not allow complicated technical \"reasons\" to pollute those things that should remain easy and intuitive.</p>\n<p>Of course, it may be the collective view that Lean is not intended for such an audience, and will always require getting past a high barrier. That's the project's choice I guess.</p>\n</blockquote>\n<p>Probably the point is what \"intuitive\" is. For me is much more intuitive that <code>5 - 3</code> is a natural number rather than anything about <code>3 - 5</code>. Every mathematician thinks that <code>a - b</code>, where <code>a</code> and <code>b</code> are natural numbers with <code>b ≤ a</code>, is a natural number. And we all know that if <code>b &gt; a</code> then \"something\" happens writing <code>a - b</code>: this is very clear. What exactly is this something is not very important (it can be that first of all we have to move to <code>ℤ</code>, or using a strange function <code>ℕ → ℕ → ℤ</code>: this is strange because it is not the one used in <code>5 -3</code>).</p>",
        "id": 444696142,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718370203
    },
    {
        "content": "<p>Let me stress that I am not saying that the point of view of mathematicians is better in an absolute way, it's better to do mathematics with Lean (meaning proving theorems) and I think the current design is the best one for <em>mathlib</em>. Of course people with other interests may find this very impractical.</p>",
        "id": 444696950,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718370467
    },
    {
        "content": "<p>For example, if you discuss this with a mathematician that has never used a proof assistant, their answer will almost certainly be that there is no function <code>- : ℕ × ℕ → ℕ</code>, but there is a function <code>- : {(a,b) ∈ ℕ × ℕ | b ≤ a} → ℕ</code>, and this is the function they want. (This is doable in Lean, but it has different drawbacks)</p>",
        "id": 444698230,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1718370859
    }
]