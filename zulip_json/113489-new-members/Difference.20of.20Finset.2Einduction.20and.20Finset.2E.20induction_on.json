[
    {
        "content": "<p>Reading the API docs, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.induction#doc\">docs#Finset.induction</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.induction_on#doc\">docs#Finset.induction_on</a> look exactly the same, except for a different order of arguments. Is there a point in having both versions? The latter has a <code>Finset</code> as argument first, so enables dot notation; this makes sense. What is the purpose of the former version?</p>\n<p>(This same question also exists for <code>Finset.cons_induction{_on}</code>, and probably in more places.)</p>",
        "id": 433164006,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1713127866
    },
    {
        "content": "<p>Looking at the source, I see that the latter is indeed defined in terms of the former.</p>\n<p>Okay: why do we have both? Can somebody explain Chesterton's fence to me?</p>",
        "id": 433164112,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1713127965
    },
    {
        "content": "<p><del>docs#Nat.rec <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.rec_on#doc\">docs#Nat.rec_on</a> they're everywhere :-)</del>(I didn't expect Nat.rec not to exist!) Yeah, this is a standard idiom for induction hypotheses; one is useful if you already have the <code>s</code> you want to prove <code>P s</code> for at hand, and the other is useful if you don't. e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PNat.recOn#doc\">docs#PNat.recOn</a> eats the positive natural first</p>",
        "id": 433168203,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713131711
    },
    {
        "content": "<p>Nat.rec does exist, just not in the docs</p>",
        "id": 433243093,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713173679
    },
    {
        "content": "<p>I'm not sure if both are needed in the current day and age. If you only use induction principles using the <code>induction ... using ...</code> tactic, then it doesn't matter which you use.<br>\nThe <code>*.induction</code> version is the usual way recursors are written in type theory papers. They also sometimes have nice properties. E.g. <code>Sigma.rec</code> is an equivalence (the backwards direction on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.piCurry#doc\">docs#Equiv.piCurry</a>).<br>\n<code>*.induction_on</code> is sometimes useful when applying induction principles. In term mode, you might first want to specify the induction variable, and only then the induction steps. In Lean 2 you could write <code>apply Nat.rec_on n</code> and Lean would figure out the motive (I don't think that generally works anymore).</p>",
        "id": 433313370,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1713192984
    },
    {
        "content": "<p>I think it does work, that's what <code>elab_as_elim</code> is for</p>",
        "id": 433313698,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713193067
    },
    {
        "content": "<p>oh no it doesn't work, at least not with <code>apply</code>. You can use <code>refine</code> though if you pass enough <code>?_</code></p>",
        "id": 433314042,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713193152
    },
    {
        "content": "<p>Of course if you pass enough <code>?_</code>, the order doesn't matter anyway</p>",
        "id": 433326728,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713196198
    }
]