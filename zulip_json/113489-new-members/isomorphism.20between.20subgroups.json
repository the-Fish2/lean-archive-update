[
    {
        "content": "<p>i'd like to prove that there exists an isomorphism between the stabiliser of n in the alternating group on n characters, and the alternating group of n-1 characters... <br>\nTo do that, i believe i need to write a function of approximate type <code>Subgroup a → Subgroup b</code>, which means i get some <code>x : Subgroup a</code> and need to return some <code>y:Subgroup b</code>. i think i know how to do something similar, but for that i need something of the form <code>x ∈ Subgroup a</code>.<br>\nHow do i convert between these? is that at all possible?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.SpecificGroups.Alternating</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Subgroup.Simple</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">alternatingGroup</span>\n<span class=\"kn\">open</span> <span class=\"n\">Subgroup</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">stabiliser_of_elem_is_alternator</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">MulAction.stabilizer</span> <span class=\"o\">(</span><span class=\"n\">alternatingGroup</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">≃*</span> <span class=\"n\">alternatingGroup</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n    <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"n\">_</span> <span class=\"c1\">-- has type alternatingGroup (Fin (n+1)) →  alternatingGroup (Fin n)</span>\n    <span class=\"n\">invFun</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n    <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n    <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n    <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 419351067,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1706829561
    },
    {
        "content": "<blockquote>\n<p>i think i know how to do something similar, but for that i need something of the form <code>x ∈ Subgroup a</code></p>\n</blockquote>\n<p>what similar thing are you referring to? like mapping individual elements?</p>",
        "id": 419356141,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706831916
    },
    {
        "content": "<p>Well, I think that having statements like that would probably be useful, as most of the theorems for Subgroups and stabilisers seem to use the set notation... Although it might be the case that I haven't looked enough, or that my lack of experience with lean is giving me tunnel vision</p>",
        "id": 419358306,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1706832916
    },
    {
        "content": "<p>oh wait, I think I know what you're asking about... converting terms of a type to members of a Subgroup? you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subtype.prop#doc\">docs#Subtype.prop</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subtype.property#doc\">docs#Subtype.property</a> to get the proof of membership (<strong>Edit:</strong> See below, there's a better way to do this by destructuring the function argument)</p>",
        "id": 419360408,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706833974
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 419360866,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706834224
    },
    {
        "content": "<p>I was confused at first because you wrote <code>Subgroup a → Subgroup b</code> and I misread that as \"a function that takes a Subgroup and returns a Subgroup\" but that's not what you're trying to do... rather, you're trying to provide <code>[a specific Subgroup] → [a specific Subgroup]</code>, where the Subgroups are coerced to types via Subtypes</p>",
        "id": 419361401,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706834498
    },
    {
        "content": "<p>So you can do something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.SpecificGroups.Alternating</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Subgroup.Simple</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">alternatingGroup</span>\n<span class=\"kn\">open</span> <span class=\"n\">Subgroup</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">stabiliser_of_elem_is_alternator</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">MulAction.stabilizer</span> <span class=\"o\">(</span><span class=\"n\">alternatingGroup</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">≃*</span> <span class=\"n\">alternatingGroup</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n    <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n      <span class=\"k\">have</span> <span class=\"n\">hx</span> <span class=\"o\">:=</span> <span class=\"n\">x.property</span> <span class=\"c1\">-- proof that x.val is a member of the subgroup</span>\n      <span class=\"k\">let</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Equiv.Perm</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n      <span class=\"k\">have</span> <span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">alternatingGroup</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n      <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩</span>\n    <span class=\"n\">invFun</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 419364006,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706836039
    },
    {
        "content": "<p>actually, an even better solution is to destructure the Subtype up front by writing <code>fun ⟨x, hx⟩ =&gt; ...</code></p>",
        "id": 419367488,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706838248
    },
    {
        "content": "<p>then <code>x</code> is the member of the Subgroup and <code>hx</code> is the proof of membership... clean and simple</p>",
        "id": 419367606,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706838308
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/113489-new-members/topic/isomorphism.20between.20subgroups/near/419351067\">said</a>:</p>\n<blockquote>\n<p>To do that, i believe i need to write a function of approximate type <code>Subgroup a → Subgroup b</code>, which means i get some <code>x : Subgroup a</code> and need to return some <code>y:Subgroup b</code>.</p>\n</blockquote>\n<p>Your code block looks fine. But I want to briefly point out that <code>Subgroup a → Subgroup b</code> means \"<code>a</code> is a group, <code>b</code> is a group, and this is the type of functions that turn all subgroups of <code>a</code> into subgroups of <code>b</code>\".</p>\n<p>Similarly <code>x : Subgroup a</code> means \"<code>x</code> is a subgroup of the group <code>a</code>\". It does not mean \"<code>x</code> is an element of some subgroup\". For that reason <code>x ∈ Subgroup a</code> doesn't really make sense. What you <em>can</em> write is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"k\">#check</span> <span class=\"n\">y.1</span> <span class=\"o\">:</span> <span class=\"n\">G</span>\n<span class=\"k\">#check</span> <span class=\"n\">y.2</span> <span class=\"o\">:</span> <span class=\"n\">y.1</span> <span class=\"bp\">∈</span> <span class=\"n\">H</span>\n</code></pre></div>",
        "id": 419388499,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1706853030
    },
    {
        "content": "<p>At <code>y : H</code> a bit of magic happens, because <code>H</code> is not a type at face value. But a bit of Lean code explains the <em>elaborator</em> how to treat <code>H</code> as a type anyways: namely as the type of pairs <code>x : G, x ∈ H</code>.</p>",
        "id": 419390852,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1706854779
    },
    {
        "content": "<p>Concerning your isomorphism: do we already have it for permutation groups? It might be easier to do that first, and then restrict it to alternating groups in a second step.</p>",
        "id": 419390929,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1706854817
    }
]