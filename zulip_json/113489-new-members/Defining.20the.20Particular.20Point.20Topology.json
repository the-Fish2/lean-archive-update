[
    {
        "content": "<p>So a per the title, I defined the Particular point topology on a type (I recall someone was looking for it and also there was a discussion about adding the Sierpinksi space to Counterexamples), so here it is. I have a couple questions though: </p>\n<p>a) I'm very confused by the whole typeclass (eg: <code>DiscreTeopology</code>,  <code>OrderTopology</code>) vs type alias (<code>CofiniteTopology</code>) approach to \"generic\" topologies. When is one favoured over the other? I went with the latter since this seems closer in spirit to <code>CofiniteTopology</code>, but I don't really get why there's this distinction.<br>\nb) Is there any way to improve the definition? That <code>p : X</code> hanging there is a bit ugly but I couldn't find a better way. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Filter</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Order</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Topology</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">Set</span> <span class=\"n\">Function</span> <span class=\"n\">Classical</span> <span class=\"n\">Filter</span>\n\n<span class=\"sd\">/-- A type synonym equipped with the topology whose open sets are the empty set</span>\n<span class=\"sd\">and the sets containing a specified point -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">ParticularPointTopology</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">X</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ParticularPointTopology</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"n\">ParticularPointTopology</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">default</span> <span class=\"o\">:=</span> <span class=\"n\">p</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">of</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">‚âÉ</span> <span class=\"n\">ParticularPointTopology</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">:=</span>\n  <span class=\"n\">Equiv.refl</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"o\">(</span><span class=\"n\">ParticularPointTopology</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">IsOpen</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">s.Nonempty</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">p</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span>\n  <span class=\"n\">isOpen_univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">univ_nonempty</span><span class=\"o\">,</span> <span class=\"n\">mem_univ</span><span class=\"o\">,</span> <span class=\"n\">forall_true_left</span><span class=\"o\">]</span>\n  <span class=\"n\">isOpen_inter</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span> <span class=\"o\">‚ü®</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hxs</span><span class=\"o\">,</span> <span class=\"n\">hxt</span><span class=\"o\">‚ü©</span>\n    <span class=\"n\">exact</span> <span class=\"o\">‚ü®</span><span class=\"n\">hs</span> <span class=\"o\">‚ü®</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hxs</span><span class=\"o\">‚ü©,</span> <span class=\"n\">ht</span> <span class=\"o\">‚ü®</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hxt</span><span class=\"o\">‚ü©‚ü©</span>\n  <span class=\"n\">isOpen_sUnion</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">s</span> <span class=\"n\">h</span> <span class=\"o\">‚ü®</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">hts</span><span class=\"o\">,</span> <span class=\"n\">hxt</span><span class=\"o\">‚ü©</span>\n    <span class=\"n\">exact</span> <span class=\"n\">mem_sUnion_of_mem</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">t</span> <span class=\"n\">hts</span> <span class=\"o\">‚ü®</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hxt</span><span class=\"o\">‚ü©)</span> <span class=\"n\">hts</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">isOpen_iff</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">ParticularPointTopology</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)}</span> <span class=\"o\">:</span> <span class=\"n\">IsOpen</span> <span class=\"n\">s</span> <span class=\"bp\">‚Üî</span> <span class=\"n\">s.Nonempty</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">p</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Iff.rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">isOpen_iff'</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">ParticularPointTopology</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)}</span> <span class=\"o\">:</span> <span class=\"n\">IsOpen</span> <span class=\"n\">s</span> <span class=\"bp\">‚Üî</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"bp\">‚àÖ</span> <span class=\"bp\">‚à®</span> <span class=\"n\">p</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">isOpen_iff</span><span class=\"o\">,</span> <span class=\"n\">nonempty_iff_ne_empty</span><span class=\"o\">,</span> <span class=\"n\">or_iff_not_imp_left</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">isClosed_iff</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">ParticularPointTopology</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)}</span> <span class=\"o\">:</span> <span class=\"n\">IsClosed</span> <span class=\"n\">s</span> <span class=\"bp\">‚Üî</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span> <span class=\"bp\">‚à®</span> <span class=\"n\">p</span> <span class=\"bp\">‚àâ</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">isOpen_compl_iff</span><span class=\"o\">,</span> <span class=\"n\">isOpen_iff'</span><span class=\"o\">,</span> <span class=\"n\">compl_empty_iff</span><span class=\"o\">,</span> <span class=\"n\">mem_compl_iff</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">nhds_eq</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ParticularPointTopology</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">ùìù</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">ùìü</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">_root_.mem_nhds_iff</span><span class=\"o\">,</span> <span class=\"n\">isOpen_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">intro</span> <span class=\"o\">‚ü®</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">htx</span><span class=\"o\">,</span> <span class=\"n\">htp</span><span class=\"o\">,</span> <span class=\"n\">hta</span><span class=\"o\">‚ü©</span>\n  <span class=\"n\">refine</span> <span class=\"n\">insert_subset</span> <span class=\"o\">(</span><span class=\"n\">htx</span> <span class=\"n\">hta</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">singleton_subset_iff.mpr</span> <span class=\"o\">(</span><span class=\"n\">htx</span> <span class=\"o\">(</span><span class=\"n\">htp</span> <span class=\"o\">(</span><span class=\"n\">nonempty_of_mem</span> <span class=\"n\">hta</span><span class=\"o\">))))</span>\n  <span class=\"n\">refine</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">‚Ü¶</span> <span class=\"o\">‚ü®{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">},</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">mem_insert_of_mem</span> <span class=\"n\">a</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">mem_insert</span> <span class=\"n\">a</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">}‚ü©</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">mem_nhds_iff</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ParticularPointTopology</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">ParticularPointTopology</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)}</span> <span class=\"o\">:</span>\n    <span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùìù</span> <span class=\"n\">a</span> <span class=\"bp\">‚Üî</span> <span class=\"n\">a</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span> <span class=\"bp\">‚àß</span> <span class=\"n\">p</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nhds_eq</span><span class=\"o\">]</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"n\">refine</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">‚Ü¶</span> <span class=\"o\">‚ü®</span><span class=\"n\">h</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">mem_insert</span> <span class=\"n\">a</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">},</span> <span class=\"n\">h</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">mem_insert_of_mem</span> <span class=\"n\">a</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">‚ü®</span><span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"n\">ps</span><span class=\"o\">‚ü©</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"bp\">|</span> <span class=\"n\">hx</span><span class=\"o\">)</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"o\">(</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">empty_interior_of_closed</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">ParticularPointTopology</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">IsClosed</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">huniv</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">‚â†</span> <span class=\"n\">univ</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">interior</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"bp\">‚àÖ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">isClosed_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hs</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">hs</span> <span class=\"k\">with</span> <span class=\"n\">h</span> <span class=\"bp\">|</span> <span class=\"n\">h</span>\n  <span class=\"bp\">¬∑</span> <span class=\"n\">contradiction</span>\n  <span class=\"bp\">¬∑</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">‚àâ</span> <span class=\"n\">interior</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">not_mem_subset</span> <span class=\"n\">interior_subset</span> <span class=\"n\">h</span>\n    <span class=\"n\">rcases</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">isOpen_iff'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">interior</span> <span class=\"n\">s</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">isOpen_interior</span>\n    <span class=\"bp\">¬∑</span> <span class=\"n\">assumption</span>\n    <span class=\"bp\">¬∑</span> <span class=\"n\">contradiction</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">T0Space</span> <span class=\"o\">(</span><span class=\"n\">ParticularPointTopology</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">t0</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">‚àà</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"bp\">‚àß</span> <span class=\"n\">p</span> <span class=\"bp\">‚àà</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mem_nhds_iff</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}),</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nhds_eq</span><span class=\"o\">,</span> <span class=\"n\">subset_refl</span><span class=\"o\">]</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"o\">{</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"bp\">‚àß</span> <span class=\"n\">p</span> <span class=\"bp\">‚àà</span> <span class=\"o\">{</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mem_nhds_iff</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">{</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}),</span> <span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nhds_eq</span><span class=\"o\">,</span> <span class=\"n\">subset_refl</span><span class=\"o\">]</span>\n    <span class=\"n\">aesop</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">SeparableSpace</span> <span class=\"o\">(</span><span class=\"n\">ParticularPointTopology</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">exists_countable_dense</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">refine</span> <span class=\"o\">‚ü®{</span><span class=\"n\">p</span><span class=\"o\">},</span> <span class=\"n\">countable_singleton</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">dense_iff_inter_open.mpr</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">‚ü©</span>\n    <span class=\"n\">refine</span> <span class=\"k\">fun</span> <span class=\"n\">U</span> <span class=\"n\">h‚ÇÅ</span> <span class=\"n\">h‚ÇÇ</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">inter_singleton_nonempty.mpr</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">((</span><span class=\"n\">isOpen_iff</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">h‚ÇÅ</span> <span class=\"n\">h‚ÇÇ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">FirstCountableTopology</span> <span class=\"o\">(</span><span class=\"n\">ParticularPointTopology</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">nhds_generated_countable</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">refine</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">‚Ü¶</span> <span class=\"o\">‚ü®{{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}},</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">‚ü©</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">countable_singleton</span><span class=\"o\">,</span> <span class=\"n\">nhds_eq</span><span class=\"o\">,</span> <span class=\"n\">generate_singleton</span><span class=\"o\">,</span> <span class=\"n\">and_self</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">ParticularPointTopology</span>\n</code></pre></div>",
        "id": 418898595,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1706639984
    },
    {
        "content": "<p>Certainly that Inhabited instance will never be used, because the p argument cannot be found. Maybe you want to provide it under the assumption that X itself is inhabited?</p>",
        "id": 418900061,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706640545
    },
    {
        "content": "<p>a. The best is to have both. Eg check <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Topology.IsScott#doc\">docs#Topology.IsScott</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Topology.WithScott#doc\">docs#Topology.WithScott</a></p>",
        "id": 418900368,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1706640660
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span> thank you. <span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span>,  that seems very reasonable but are you suggesting adding <code>[Inhabited X]</code>  to the <code>variable {X : Type*} ‚Ä¶ </code> declaration,  adding it as an hypothesis to <code>def ParticularPointTopology</code> or providing just the instance <code>Inhabited (ParticularPointTopology X p)</code> under the assumption <code>[Inhabited X]</code>?  I guess eliminating it altogether might also be a viable option</p>",
        "id": 418902917,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1706641702
    },
    {
        "content": "<blockquote>\n<p>Certainly that Inhabited instance will never be used, because the p argument cannot be found. Maybe you want to provide it under the assumption that X itself is inhabited?</p>\n</blockquote>\n<p><code>ParticularPointTopology X p</code> depends on <code>p</code> so Lean should be able to unify and find <code>p</code>. If it can't it will warn you once you write the instance ...</p>",
        "id": 418921813,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1706649535
    },
    {
        "content": "<p>I'm resurrecting this thread since I got around to finishing things. At the the I had the type synonym working, and as an mwe this was the state of things. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Filter</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Order</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Topology</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">Set</span> <span class=\"n\">Function</span> <span class=\"n\">Classical</span> <span class=\"n\">Filter</span>\n\n<span class=\"sd\">/-- A type synonym equipped with the topology whose open sets are the empty set</span>\n<span class=\"sd\">and the sets containing a specified point -/</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ParticularPoint</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">X</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ParticularPoint</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">of</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">‚âÉ</span> <span class=\"n\">ParticularPoint</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">:=</span>\n  <span class=\"n\">Equiv.refl</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">ParticularPoint</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ParticularPoint</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">))</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"o\">(</span><span class=\"n\">ParticularPoint</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">IsOpen</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">s.Nonempty</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">p</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span>\n  <span class=\"n\">isOpen_univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_univ</span><span class=\"o\">,</span> <span class=\"n\">implies_true</span><span class=\"o\">]</span>\n  <span class=\"n\">isOpen_inter</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span> <span class=\"o\">‚ü®</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hxs</span><span class=\"o\">,</span> <span class=\"n\">hxt</span><span class=\"o\">‚ü©</span>\n    <span class=\"n\">exact</span> <span class=\"o\">‚ü®</span><span class=\"n\">hs</span> <span class=\"o\">‚ü®</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hxs</span><span class=\"o\">‚ü©,</span> <span class=\"n\">ht</span> <span class=\"o\">‚ü®</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hxt</span><span class=\"o\">‚ü©‚ü©</span>\n  <span class=\"n\">isOpen_sUnion</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">s</span> <span class=\"n\">h</span> <span class=\"o\">‚ü®</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">hts</span><span class=\"o\">,</span> <span class=\"n\">hxt</span><span class=\"o\">‚ü©</span>\n    <span class=\"n\">exact</span> <span class=\"n\">mem_sUnion_of_mem</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">t</span> <span class=\"n\">hts</span> <span class=\"o\">‚ü®</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hxt</span><span class=\"o\">‚ü©)</span> <span class=\"n\">hts</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">isOpen_iff</span>  <span class=\"o\">:</span> <span class=\"n\">IsOpen</span> <span class=\"n\">s</span> <span class=\"bp\">‚Üî</span> <span class=\"n\">s.Nonempty</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">p</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Iff.rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">nhds_eq</span> <span class=\"o\">:</span> <span class=\"bp\">ùìù</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">ùìü</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">u</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">_root_.mem_nhds_iff</span><span class=\"o\">,</span> <span class=\"n\">isOpen_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">intro</span> <span class=\"o\">‚ü®</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">htu</span><span class=\"o\">,</span> <span class=\"n\">htp</span><span class=\"o\">,</span> <span class=\"n\">hta</span><span class=\"o\">‚ü©</span>\n  <span class=\"n\">refine</span> <span class=\"n\">insert_subset</span> <span class=\"o\">(</span><span class=\"n\">htu</span> <span class=\"n\">hta</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">singleton_subset_iff.mpr</span> <span class=\"o\">(</span><span class=\"n\">htu</span> <span class=\"o\">(</span><span class=\"n\">htp</span> <span class=\"o\">(</span><span class=\"n\">nonempty_of_mem</span> <span class=\"n\">hta</span><span class=\"o\">))))</span>\n  <span class=\"n\">refine</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">‚Ü¶</span> <span class=\"o\">‚ü®{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">},</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">mem_insert_of_mem</span> <span class=\"n\">a</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">mem_insert</span> <span class=\"n\">a</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">}‚ü©</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">mem_nhds_iff</span> <span class=\"o\">:</span>\n    <span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùìù</span> <span class=\"n\">a</span> <span class=\"bp\">‚Üî</span> <span class=\"n\">a</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span> <span class=\"bp\">‚àß</span> <span class=\"n\">p</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nhds_eq</span><span class=\"o\">]</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"n\">refine</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">‚Ü¶</span> <span class=\"o\">‚ü®</span><span class=\"n\">h</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">mem_insert</span> <span class=\"n\">a</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">},</span> <span class=\"n\">h</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">mem_insert_of_mem</span> <span class=\"n\">a</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">‚ü®</span><span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"n\">ps</span><span class=\"o\">‚ü©</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"bp\">|</span> <span class=\"n\">hx</span><span class=\"o\">)</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"o\">(</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">T0Space</span> <span class=\"o\">(</span><span class=\"n\">ParticularPoint</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">t0</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">‚àà</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"bp\">‚àß</span> <span class=\"n\">p</span> <span class=\"bp\">‚àà</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mem_nhds_iff</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}),</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nhds_eq</span><span class=\"o\">,</span> <span class=\"n\">subset_refl</span><span class=\"o\">]</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"o\">{</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"bp\">‚àß</span> <span class=\"n\">p</span> <span class=\"bp\">‚àà</span> <span class=\"o\">{</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mem_nhds_iff</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">{</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}),</span> <span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nhds_eq</span><span class=\"o\">,</span> <span class=\"n\">subset_refl</span><span class=\"o\">]</span>\n    <span class=\"n\">aesop</span>\n</code></pre></div>\n<p>I tried to make it into a typeclass instead, but now I run into problems. First, I need to specify <code>p</code> when using the theorems, but I guess that might be unavoidable. (I tried making it implicit and ran into other troubles). But more importantly I run into this error: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">cannot</span> <span class=\"n\">find</span> <span class=\"n\">synthesization</span> <span class=\"n\">order</span> <span class=\"n\">for</span> <span class=\"kd\">instance</span> <span class=\"bp\">@</span><span class=\"n\">instT0Space</span> <span class=\"k\">with</span> <span class=\"n\">type</span>\n  <span class=\"bp\">‚àÄ</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">IsParticularPoint</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">],</span> <span class=\"n\">T0Space</span> <span class=\"n\">X</span>\n<span class=\"n\">all</span> <span class=\"n\">remaining</span> <span class=\"n\">arguments</span> <span class=\"k\">have</span> <span class=\"n\">metavariables</span><span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">IsParticularPoint</span> <span class=\"n\">X</span> <span class=\"bp\">?</span><span class=\"n\">p</span> <span class=\"n\">inst</span><span class=\"bp\">‚úù¬π</span><span class=\"n\">Lean</span> <span class=\"mi\">4</span>\n</code></pre></div>\n<p>The code mwe is the following: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Filter</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Order</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Topology</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">Set</span> <span class=\"n\">Function</span> <span class=\"n\">Classical</span> <span class=\"n\">Filter</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">ParticularPoint</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> A nonempty set `s` is open in the Particular Point topology iff</span>\n<span class=\"cm\">it contains some particular point p -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">ParticularPoint</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span> <span class=\"n\">where</span>\n  <span class=\"n\">IsOpen</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">s.Nonempty</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">p</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span>\n  <span class=\"n\">isOpen_univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_univ</span><span class=\"o\">,</span> <span class=\"n\">implies_true</span><span class=\"o\">]</span>\n  <span class=\"n\">isOpen_inter</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span> <span class=\"o\">‚ü®</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hxs</span><span class=\"o\">,</span> <span class=\"n\">hxt</span><span class=\"o\">‚ü©</span>\n    <span class=\"n\">exact</span> <span class=\"o\">‚ü®</span><span class=\"n\">hs</span> <span class=\"o\">‚ü®</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hxs</span><span class=\"o\">‚ü©,</span> <span class=\"n\">ht</span> <span class=\"o\">‚ü®</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hxt</span><span class=\"o\">‚ü©‚ü©</span>\n  <span class=\"n\">isOpen_sUnion</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">s</span> <span class=\"n\">h</span> <span class=\"o\">‚ü®</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">hts</span><span class=\"o\">,</span> <span class=\"n\">hxt</span><span class=\"o\">‚ü©</span>\n    <span class=\"n\">exact</span> <span class=\"n\">mem_sUnion_of_mem</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">t</span> <span class=\"n\">hts</span> <span class=\"o\">‚ü®</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hxt</span><span class=\"o\">‚ü©)</span> <span class=\"n\">hts</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- Predicate for a topological space to be equipped with the Particular Point Topology for some point. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">IsParticularPoint</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">topology_eq_particularPoint</span> <span class=\"o\">:</span> <span class=\"o\">‚Äπ</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">‚Ä∫</span> <span class=\"bp\">=</span> <span class=\"n\">ParticularPoint</span> <span class=\"n\">X</span> <span class=\"n\">p</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">IsParticularPoint</span> <span class=\"n\">X</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">ParticularPoint</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">IsParticularPoint.mk</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">ParticularPoint</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">IsParticularPoint</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsParticularPoint</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">topology_eq</span> <span class=\"o\">:</span> <span class=\"o\">‚Äπ</span><span class=\"n\">_</span><span class=\"o\">‚Ä∫</span> <span class=\"bp\">=</span> <span class=\"n\">ParticularPoint</span> <span class=\"n\">X</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">topology_eq_particularPoint</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">isOpen_iff</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsOpen</span> <span class=\"n\">s</span> <span class=\"bp\">‚Üî</span> <span class=\"n\">s.Nonempty</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">p</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">topology_eq</span> <span class=\"n\">X</span> <span class=\"n\">p</span> <span class=\"n\">_</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">nhds_eq</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ùìù</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">ùìü</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">u</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">_root_.mem_nhds_iff</span><span class=\"o\">,</span> <span class=\"n\">isOpen_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">intro</span> <span class=\"o\">‚ü®</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">htu</span><span class=\"o\">,</span> <span class=\"n\">htp</span><span class=\"o\">,</span> <span class=\"n\">hta</span><span class=\"o\">‚ü©</span>\n  <span class=\"n\">refine</span> <span class=\"n\">insert_subset</span> <span class=\"o\">(</span><span class=\"n\">htu</span> <span class=\"n\">hta</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">singleton_subset_iff.mpr</span> <span class=\"o\">(</span><span class=\"n\">htu</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">))</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">isOpen_iff</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">htp</span> <span class=\"o\">(</span><span class=\"n\">Set.nonempty_of_mem</span> <span class=\"n\">hta</span><span class=\"o\">)</span>\n  <span class=\"n\">refine</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">‚Ü¶</span> <span class=\"o\">‚ü®{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">},</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">mem_insert</span> <span class=\"n\">a</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">}‚ü©</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">isOpen_iff</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">mem_insert_of_mem</span> <span class=\"n\">a</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">mem_nhds_iff</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùìù</span> <span class=\"n\">a</span> <span class=\"bp\">‚Üî</span> <span class=\"n\">a</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span> <span class=\"bp\">‚àß</span> <span class=\"n\">p</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nhds_eq</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"n\">refine</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">‚Ü¶</span> <span class=\"o\">‚ü®</span><span class=\"n\">h</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">mem_insert</span> <span class=\"n\">a</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">},</span> <span class=\"n\">h</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">mem_insert_of_mem</span> <span class=\"n\">a</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">‚ü®</span><span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"n\">ps</span><span class=\"o\">‚ü©</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"bp\">|</span> <span class=\"n\">hx</span><span class=\"o\">)</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"o\">(</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">T0Space</span> <span class=\"n\">X</span> <span class=\"n\">where</span>\n  <span class=\"n\">t0</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">‚àà</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"bp\">‚àß</span> <span class=\"n\">p</span> <span class=\"bp\">‚àà</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mem_nhds_iff</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}),</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nhds_eq</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">subset_refl</span><span class=\"o\">]</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"o\">{</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"bp\">‚àß</span> <span class=\"n\">p</span> <span class=\"bp\">‚àà</span> <span class=\"o\">{</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mem_nhds_iff</span> <span class=\"n\">X</span> <span class=\"n\">p</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">{</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}),</span> <span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nhds_eq</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">subset_refl</span><span class=\"o\">]</span>\n    <span class=\"n\">aesop</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">IsParticularPoint</span>\n<span class=\"kd\">end</span> <span class=\"n\">ParticularPoint</span>\n</code></pre></div>\n<p>I tried to do it like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Topology.IsScott#doc\">docs#Topology.IsScott</a> as you suggested <span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span>  but I'm at a bit of a loss as to what exactly the problem is</p>",
        "id": 423448548,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1708968448
    },
    {
        "content": "<p>Surely it should be <code>T0Space (ParticularPoint X p)</code> instead of <code>T0Space X</code>?</p>",
        "id": 423450461,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1708969011
    },
    {
        "content": "<p>How could that work? In the second example <code>ParticularPoint X p</code> is a of type <code>TopologicalSpace X</code>. I should probably have renamed it in the first one to <code>WithParticularPoint</code>. Anyway I decided to solve the problem by adding the type synonym and then proving the instance on that. However in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Topology.IsScott#doc\">docs#Topology.IsScott</a> they managed to do that with just the typeclass. Dunno. </p>\n<p>I just added the following: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">WithParticularPoint</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">X</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">WithParticularPoint</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"o\">(</span><span class=\"n\">WithParticularPoint</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ParticularPoint</span> <span class=\"n\">X</span> <span class=\"n\">p</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">IsParticularPoint</span> <span class=\"o\">(</span><span class=\"n\">WithParticularPoint</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"o\">‚ü®</span><span class=\"n\">rfl</span><span class=\"o\">‚ü©</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">WithParticularPoint</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">IsParticularPoint</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">T0Space</span> <span class=\"o\">(</span><span class=\"n\">WithParticularPoint</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">t0</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">‚àà</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"bp\">‚àß</span> <span class=\"n\">p</span> <span class=\"bp\">‚àà</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mem_nhds_iff</span> <span class=\"o\">(</span><span class=\"n\">WithParticularPoint</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}),</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">nhds_eq</span> <span class=\"o\">(</span><span class=\"n\">WithParticularPoint</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">subset_refl</span><span class=\"o\">]</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"o\">{</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"bp\">‚àß</span> <span class=\"n\">p</span> <span class=\"bp\">‚àà</span> <span class=\"o\">{</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mem_nhds_iff</span> <span class=\"o\">(</span><span class=\"n\">WithParticularPoint</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">{</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}),</span> <span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">nhds_eq</span> <span class=\"o\">(</span><span class=\"n\">WithParticularPoint</span> <span class=\"n\">X</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">subset_refl</span><span class=\"o\">]</span>\n    <span class=\"n\">aesop</span>\n\n\n<span class=\"kd\">end</span> <span class=\"n\">ParticularPoint</span>\n</code></pre></div>",
        "id": 423454861,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1708970663
    },
    {
        "content": "<p>Which is guess is kosher enough?</p>",
        "id": 423454882,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1708970673
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466290\">Luigi Massacci</span> <a href=\"#narrow/stream/113489-new-members/topic/Defining.20the.20Particular.20Point.20Topology/near/423454861\">said</a>:</p>\n<blockquote>\n<p>I decided to solve the problem by adding the type synonym and then proving the instance on that. However in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Topology.IsScott#doc\">docs#Topology.IsScott</a> they managed to do that with just the typeclass. Dunno. </p>\n</blockquote>\n<p>That's because the Scott topology doesn't require more data than typeclasses can provide. Your \"particular topology\" does, since <code>p</code> can't be found by typeclass search.</p>",
        "id": 423462090,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1708973305
    },
    {
        "content": "<p>That makes sense</p>",
        "id": 423463036,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1708973664
    }
]