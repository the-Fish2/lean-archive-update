[
    {
        "content": "<p>I implemented a strong induction principle for lists that works over all suffixes. The signature is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">IsStrictSuffix</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l2</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">suffix_induction</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">l'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l'</span><span class=\"bp\">.</span><span class=\"n\">IsStrictSuffix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">l'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">l</span>\n</code></pre></div>\n<p><a href=\"https://gist.github.com/willcrichton/b4f2b59009554406727abe62c174c5b4\">Full source link.</a></p>\n<p>Would it be useful to submit this as a contribution to Mathlib? I was hoping something like this was in Mathlib, but there wasn't, so I implemented it myself.</p>",
        "id": 442751471,
        "sender_full_name": "Will Crichton",
        "timestamp": 1717584299
    },
    {
        "content": "<p>Is this principle more useful than using strong induction on list lengths? It seems that if you can prove <code>IsStrictSuffix</code> you can prove that one list is smaller than the other one easily.</p>",
        "id": 442783669,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1717593219
    },
    {
        "content": "<p>Also, it may not be needed to have a separate nil and cons case, and a single case might be nicer.</p>",
        "id": 442783878,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1717593264
    },
    {
        "content": "<p>I'm actually not sure how to prove the induction principle for list lengths. That was my first intuition, but you end up needing to show that <code>l1.length &lt; l2.length -&gt; sizeOf l1 &lt; sizeOf l2</code> and that is not true. Maybe I did something wrong in the proof.</p>",
        "id": 442784073,
        "sender_full_name": "Will Crichton",
        "timestamp": 1717593315
    },
    {
        "content": "<p>But yes more generally, I think Mathlib should have <em>some</em> strong induction principle for lists. This is just the one I could figure out :-)</p>",
        "id": 442784217,
        "sender_full_name": "Will Crichton",
        "timestamp": 1717593354
    },
    {
        "content": "<p>Try <code>termination_by l.length</code> before your <code>decreasing_by</code></p>",
        "id": 442794116,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1717595468
    },
    {
        "content": "<p>Also, there isn’t really anything special about <code>List.length</code> here, so a single induction principle for any <code>α → Nat</code> should suffice:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">strongIndutionMeasureOn</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">   </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">strongIndutionMeasureOn</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">step</span><span class=\"o\">)</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">strongIndutionMeasureOn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"c1\">-- 1 goal</span>\n<span class=\"w\">    </span><span class=\"c1\">-- x: List Nat</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ih: ∀ (y : List Nat), y.length &lt; x.length → y = y</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ⊢ x = x</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 442796959,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1717596081
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/113489-new-members/topic/Contributing.20a.20strong.20induction.20for.20lists/near/442783669\">said</a>:</p>\n<blockquote>\n<p>Is this principle more useful than using strong induction on list lengths?</p>\n</blockquote>\n<p>Maybe if there is a use case where the statement is indeed true only for suffixes and not arbitrary lists, then one would need to create this hypothesis, e.g.:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Batteries</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Lemmas</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Cases</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">generalize</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">  </span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"o\">:</span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">suffix_refl</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- induction y using Nat.strongInductionMeasureOn List.length with | _ y ih =&gt; ?_</span>\n<span class=\"w\">  </span><span class=\"n\">induction'</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">strongInductionOn</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"n\">generalizing</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">measure</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">wf</span><span class=\"bp\">.</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But I guess this can't be solved by an induction principle.</p>",
        "id": 442913912,
        "sender_full_name": "llllvvuu",
        "timestamp": 1717626932
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/113489-new-members/topic/Contributing.20a.20strong.20induction.20for.20lists/near/442783878\">said</a>:</p>\n<blockquote>\n<p>Also, it may not be needed to have a separate nil and cons case, and a single case might be nicer.</p>\n</blockquote>\n<p>I guess if one wanted to mimic the multiset API one could rename <code>List.strongRec</code> and <code>List.suffix_induction</code> to <code>List.strongInduction</code> and <code>List.caseStrongInductionOn</code> respectively, and also add <code>List.strongInductionOn</code> (funny thing: this is spelled differently in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.caseStrongInductionOn#doc\">docs#Nat.caseStrongInductionOn</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.case_strongInductionOn#doc\">docs#Multiset.case_strongInductionOn</a>, and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.case_strong_induction_on#doc\">docs#Finset.case_strong_induction_on</a>). Though I agree the non-case variant is often better / there are very few usages of the case variants in mathlib.</p>",
        "id": 442917386,
        "sender_full_name": "llllvvuu",
        "timestamp": 1717628033
    },
    {
        "content": "<p>Side note: I've asked the same question before here: <a href=\"#narrow/stream/287929-mathlib4/topic/List.20strong.20induction\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/List.20strong.20induction</a></p>",
        "id": 443034470,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1717673581
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 443244736,
        "sender_full_name": "llllvvuu",
        "timestamp": 1717750448
    },
    {
        "content": "<p>I was just <a href=\"https://github.com/leanprover-community/batteries/pull/828\">about to propose it in Batteries anyway</a> thinking it did something that the Nat version didn't, but then I realized I got confused, so I closed it. Maybe it could still be of interest in Mathlib for the sake of completeness / showing up in search results (interestingly, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.strongInductionOn#doc\">docs#Finset.strongInductionOn</a> does actually get used a few times), if not useful in Batteries.</p>\n<p>But I did put in a <a href=\"https://github.com/leanprover-community/batteries/pull/829\">proposal</a> to add Joachim Breitner's <code>α → Nat</code> idea from above.</p>",
        "id": 443253282,
        "sender_full_name": "llllvvuu",
        "timestamp": 1717752632
    }
]