[
    {
        "content": "<p>In languages like Haskell and Rust, there are some laws attached to classes, and sometimes even the compiler relies on these laws being respected in the instances for optimization soundness (like, for instance, the comparison being compatible with the equality). However, the compiler has no way to enforce these laws.</p>\n<p>In Lean, similarly, classes can also have associated laws; but, in Lean, it's very straightforward to make the compiler enforce these laws. For instance, one could imagine that the <code>Monad</code> class would have the following definition (ignoring inheritance)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Monad</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">pure</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">α</span>\n  <span class=\"n\">bind</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">β</span>\n  <span class=\"n\">idR</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">bind</span> <span class=\"n\">x</span> <span class=\"n\">pure</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n  <span class=\"n\">idL</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">β</span><span class=\"o\">)),</span> <span class=\"n\">bind</span> <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span>\n  <span class=\"n\">bindAssoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"n\">γ</span><span class=\"o\">),</span> <span class=\"n\">bind</span> <span class=\"o\">(</span><span class=\"n\">bind</span> <span class=\"n\">x</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">bind</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">bind</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Lean has a quite unique feature-set (among programming languages) that allows it to enforce class laws. Why doesn't it do it? Are there specialized classed like <code>class VerifiedMonad extends Monad where idR : ...</code>?</p>",
        "id": 411702699,
        "sender_full_name": "jthulhu",
        "timestamp": 1704707318
    },
    {
        "content": "<p>There's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LawfulMonad#doc\">docs#LawfulMonad</a> .</p>",
        "id": 411704449,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704707892
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"674423\">jthulhu</span> has marked this topic as resolved.</p>",
        "id": 411712457,
        "sender_full_name": "Notification Bot",
        "timestamp": 1704710342
    },
    {
        "content": "<p>(and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LawfulMonad.mk%27#doc\">docs#LawfulMonad.mk'</a>, which matches your fields without extra ones)</p>",
        "id": 411715610,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704711421
    },
    {
        "content": "<p>It's actually quite convenient that the the monad laws are in a separate type class. I've been constructing some monads recently and this split allowed me to:</p>\n<ol>\n<li>Define a <code>Monad</code> instance</li>\n<li>Proof some lemmas about that monad</li>\n<li>Use those lemmas in the proofs for <code>LawfulMonad</code></li>\n</ol>",
        "id": 416070192,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1705508845
    },
    {
        "content": "<p>Yes, this pattern of putting data fields in a separate typeclass is very useful for precisely that reason, and used all over mathlib</p>",
        "id": 416077105,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705510504
    }
]