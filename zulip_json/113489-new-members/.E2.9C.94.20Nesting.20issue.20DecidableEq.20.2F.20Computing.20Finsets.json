[
    {
        "content": "<p>Hi all, </p>\n<p>I am struggling building an inductive type with Finsets that are expressing the same set.</p>\n<p>Here is a small example of an inductive type like the one I am working with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">FinsetType</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span> <span class=\"n\">where</span>\n <span class=\"bp\">|</span> <span class=\"n\">Constant</span> <span class=\"o\">:</span> <span class=\"n\">FinsetType</span> <span class=\"bp\">∅</span>\n <span class=\"bp\">|</span> <span class=\"n\">Merge</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"bp\">Γ</span> <span class=\"bp\">Δ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">FinsetType</span> <span class=\"bp\">Γ</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">FinsetType</span> <span class=\"bp\">Δ</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">Disjoint</span> <span class=\"bp\">Γ</span> <span class=\"bp\">Δ</span> <span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">FinsetType</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">∪</span> <span class=\"bp\">Δ</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span> <span class=\"n\">Product</span> <span class=\"o\">:</span> <span class=\"n\">FinsetType</span> <span class=\"bp\">Γ</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">FinsetType</span> <span class=\"bp\">Γ</span>\n</code></pre></div>\n<p>(sidenote: any union in my inductive type will always be a disjoint union)</p>\n<p>Some terms can reduce to other terms. Not all reduction rules will be confluent, and therefore I am trying to define this as a relation on terms. None of the reduction rules will change the Finsets in any way.</p>\n<p>Here is an example of how I am trying to write this relation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">FinsetType</span>\n<span class=\"kd\">def</span> <span class=\"n\">reductionRelation</span> <span class=\"o\">{</span><span class=\"bp\">Γ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">FinsetType</span> <span class=\"bp\">Γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">FinsetType</span> <span class=\"bp\">Γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n   <span class=\"bp\">|</span> <span class=\"n\">Merge</span> <span class=\"o\">(</span><span class=\"n\">Constant</span><span class=\"o\">)</span> <span class=\"n\">u</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">t'</span> <span class=\"bp\">=</span> <span class=\"n\">Product</span> <span class=\"n\">u</span>\n   <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n</code></pre></div>\n<p>This now gives an error because <code>t</code> has <code>(∅ ∪ Δ✝)</code> as its Finset and <code>t'</code> has <code>Δ✝</code> as its Finset. These are indeed not built the same way, however they do express the same Finset. </p>\n<p>I have tried adding <code>deriving DecidableEq</code> for the FinsetType, but that gives me a <code>tactic 'cases' failed, nested error</code>.</p>\n<p>What is causing this nesting issue and how can resolve it? Or is there perhaps another way that makes Lean accept these two Finsets as equal?</p>\n<p>Thank you in advance for your time,<br>\nErik Link</p>",
        "id": 426891820,
        "sender_full_name": "Erik Link",
        "timestamp": 1710596283
    },
    {
        "content": "<p>One solution is to shift into tactic mode:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">FinsetType</span>\n<span class=\"kd\">def</span> <span class=\"n\">reductionRelation</span> <span class=\"o\">{</span><span class=\"bp\">Γ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">FinsetType</span> <span class=\"bp\">Γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">FinsetType</span> <span class=\"bp\">Γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n   <span class=\"bp\">|</span> <span class=\"n\">Merge</span> <span class=\"o\">(</span><span class=\"n\">Constant</span><span class=\"o\">)</span> <span class=\"n\">u</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Finset.empty_union</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">t'</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">t'</span> <span class=\"bp\">=</span> <span class=\"n\">Product</span> <span class=\"n\">u</span>\n   <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n</code></pre></div>\n<p>Kind of ugly but it gets the job done. Maybe there's a better way, though.</p>",
        "id": 426907396,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710609379
    },
    {
        "content": "<p>I would recommend making a <code>cast</code> function, since using <code>rw</code> in a definition like this makes it a lot harder to prove things about it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">FinsetType.cast</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">FinsetType</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">s'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">FinsetType</span> <span class=\"n\">s'</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">rfl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">t</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">FinsetType</span>\n<span class=\"kd\">def</span> <span class=\"n\">reductionRelation</span> <span class=\"o\">{</span><span class=\"bp\">Γ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">FinsetType</span> <span class=\"bp\">Γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">FinsetType</span> <span class=\"bp\">Γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n   <span class=\"bp\">|</span> <span class=\"n\">Merge</span> <span class=\"o\">(</span><span class=\"n\">Constant</span><span class=\"o\">)</span> <span class=\"n\">u</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">t'.cast</span> <span class=\"o\">(</span><span class=\"n\">Finset.empty_union</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Product</span> <span class=\"n\">u</span>\n   <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n</code></pre></div>\n<p>You can write some lemmas for <code>cast</code> to support reasoning about it, like <code>cast_rfl</code> and <code>cast_cast</code>.</p>",
        "id": 426908328,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710610321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"699859\">Erik Link</span> <a href=\"#narrow/stream/113489-new-members/topic/Nesting.20issue.20DecidableEq.20.2F.20Computing.20Finsets/near/426891820\">said</a>:</p>\n<blockquote>\n<p>I have tried adding deriving <code>DecidableEq</code></p>\n</blockquote>\n<p>You don't need <code>DecidableEq</code> to be able to use <code>=</code>. This is only needed if you want to make definitions that can depend on whether an equality is true or false (i.e., whether you need to decide the equality).</p>",
        "id": 426908518,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710610480
    },
    {
        "content": "<p>nice... I figured there was a better way</p>",
        "id": 426909393,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710611334
    },
    {
        "content": "<p>Thank you both for helping me out. I really appreciate it <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 427124031,
        "sender_full_name": "Erik Link",
        "timestamp": 1710683404
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"699859\">Erik Link</span> has marked this topic as resolved.</p>",
        "id": 427124066,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710683411
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"699859\">Erik Link</span> has marked this topic as unresolved.</p>",
        "id": 427132410,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710685593
    },
    {
        "content": "<p>I might have closed this topic too early, my bad.</p>\n<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  Your solution does indeed work for that small example, however I am having trouble applying it to my actual system. The additions seem to break it: <code>invalid field 'cast', the environment does not contain 'TypedProofTerm.cast'</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">TypedProofTerm</span><span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span>  <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span> <span class=\"n\">where</span>\n <span class=\"bp\">|</span> <span class=\"n\">Prod</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"bp\">Γ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">S</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">TypedProofTerm</span> <span class=\"bp\">Γ</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">TypedProofTerm</span> <span class=\"bp\">Γ</span>\n <span class=\"bp\">|</span> <span class=\"n\">TruthIntro</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">TypedProofTerm</span> <span class=\"bp\">∅</span>\n <span class=\"bp\">|</span> <span class=\"n\">TruthElim</span>  <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"bp\">Γ</span> <span class=\"bp\">Δ</span><span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">TypedProofTerm</span> <span class=\"bp\">Γ</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">TypedProofTerm</span> <span class=\"bp\">Δ</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Disjoint</span> <span class=\"bp\">Γ</span> <span class=\"bp\">Δ</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">TypedProofTerm</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span> <span class=\"bp\">∪</span> <span class=\"bp\">Δ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">TypedProofTerm</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">TypedProofTerm.cast</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"n\">c'</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TypedProofTerm</span> <span class=\"n\">S</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">c'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TypedProofTerm</span> <span class=\"n\">S</span> <span class=\"n\">c'</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">rfl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">t</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">reductionReltion</span> <span class=\"o\">{</span><span class=\"bp\">Γ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TypedProofTerm</span> <span class=\"n\">S</span> <span class=\"bp\">Γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">TypedProofTerm</span> <span class=\"n\">S</span> <span class=\"bp\">Γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n   <span class=\"bp\">|</span> <span class=\"n\">TruthElim</span> <span class=\"o\">(</span><span class=\"n\">TruthIntro</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">u</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">t'.cast</span> <span class=\"o\">(</span><span class=\"n\">Finset.empty_union</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Prod</span> <span class=\"n\">α</span> <span class=\"n\">u</span>\n   <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n</code></pre></div>",
        "id": 427136426,
        "sender_full_name": "Erik Link",
        "timestamp": 1710686756
    },
    {
        "content": "<p>You defined <code>TypedProofTerm.TypedProofTerm.cast</code></p>",
        "id": 427142062,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1710688234
    },
    {
        "content": "<p>Do you see why?</p>",
        "id": 427142089,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1710688241
    },
    {
        "content": "<p>Thank you, I indeed see the issue with the namespace now <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 427143440,
        "sender_full_name": "Erik Link",
        "timestamp": 1710688601
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"699859\">Erik Link</span> has marked this topic as resolved.</p>",
        "id": 427143593,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710688647
    }
]