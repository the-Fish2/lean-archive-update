[
    {
        "content": "<p>I have a few weeks of messing around with Lean 4, working through the Foundations of Mathematics 2024; so far up to section 9 : Bijections and Isomorphisms. Reached an impasse this morning on what seems to be a very basic question when testing my own knowledge of the fundamentals.  </p>\n<p>In my understanding types are first class objects so can be compared for equality. Indeed, the code fragment below shows that the Nat type is equal to itself, by simple reflection. However, I am stuck trying to demonstrate <em>inequality</em> of types - to take a simple practical example, demonstrating Nat and Int are unequal.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>   <span class=\"kd\">def</span> <span class=\"n\">equalTypes</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n   <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">equalTypes</span> <span class=\"n\">ℕ</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n   <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">equalTypes</span> <span class=\"n\">ℕ</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">equalTypes</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Is this just a newbie gap in my knowledge of the appropriate tactic to apply, or am I missing something conceptual? (Of course, one could present a specific term to demonstrate the distinction between the naturals and the integers, but my  concern is how to demonstrate the abstract case of two quite general types A and B.)</p>",
        "id": 426750690,
        "sender_full_name": "Madir Mabbott",
        "timestamp": 1710511565
    },
    {
        "content": "<p>You are missing something fundamental. This is unprovable</p>",
        "id": 426755708,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710513202
    },
    {
        "content": "<p>This question comes up with some frequency. The short answer is that you are not missing a simple tactic or anything. Surprisingly, it is not possible to prove that <code>ℕ</code> and <code>ℤ</code> are distinct types. </p>\n<p>Consider that, since they have the same cardinality, the terms of the two types could be represented internally by the same underlying objects. Of course the interpretation of those objects will be different when they are viewed as terms of type <code>ℕ</code> versus terms of type <code>ℤ</code>. For example, the object representing <code>0 : ℕ</code> could be wildly different from the object representing <code>0 : ℤ</code>. </p>\n<p>Notice that one typical tactic for proving equality of collections of things is <code>ext</code>. If you try that instead of <code>rfl</code> in showing that ℕ is the same type as itself, you get an error <code>no applicable extensionality theorem found for Type</code>. </p>\n<p>Fortunately, type (in)equality doesn't really come up naturally in doing the mathematics found in a typical curriculum.</p>",
        "id": 426755805,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1710513233
    },
    {
        "content": "<p>Is it possible to prove types are different by some structural property about the types? For example, to prove that \\N has a minimum element but \\Z doesn't?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LT</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">t_nat</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span>\n  <span class=\"n\">push_neg</span>\n  <span class=\"n\">use</span> <span class=\"mi\">0</span>\n  <span class=\"n\">simp</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">t_int</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨</span><span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">omega</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">thing</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hα</span> <span class=\"o\">:</span> <span class=\"n\">LT</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">hβ</span> <span class=\"o\">:</span> <span class=\"n\">LT</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">β</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">LT</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">α</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">≠</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">thing.not.mpr</span>\n  <span class=\"n\">push_neg</span>\n  <span class=\"n\">use</span> <span class=\"n\">p</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">t_nat</span><span class=\"o\">,</span> <span class=\"n\">t_int</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 426763618,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710515410
    },
    {
        "content": "<p>The axiom is definitely wrong because the instance <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>L</mi><mi>T</mi><mi>γ</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[LT \\gamma]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.05556em;\">γ</span><span class=\"mclose\">]</span></span></span></span> can be any instance of that type (? if that makes sense), but I wonder if a variant can be done</p>",
        "id": 426763740,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710515454
    },
    {
        "content": "<p>Or why not</p>",
        "id": 426763753,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710515456
    },
    {
        "content": "<p>I think (might be wrong) the point is that you should distinguish the types from the structures on the type. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> doesn't have an ordering \"by default\". If you put the usual one, then yes you can prove that it is not order isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>. But this doesn't mean that the underlying carriers aren't the same</p>",
        "id": 426764124,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1710515562
    },
    {
        "content": "<p>Just that the two structures you put on top of them interpret the elements differently</p>",
        "id": 426764242,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1710515600
    },
    {
        "content": "<p>That makes sense, but I wonder if you can prove that <em>every</em> possible ordering you put on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> will have this property. Then that'll prove the types are not equal. But now that I think about it, since <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> is isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>, the statement is false</p>",
        "id": 426764520,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710515680
    },
    {
        "content": "<p>What do you mean every possible ordering? There is an isomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo>→</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z} \\to \\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>, so you could stick the usual ordering of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> that way, and then in your new order structure on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span>, there would be a least element (since it would be order-isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>)</p>",
        "id": 426764963,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1710515816
    },
    {
        "content": "<p>Ok you saw it by yoursef</p>",
        "id": 426765105,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1710515855
    },
    {
        "content": "<p>I mean the mathematician's answer is that in any case you really shouldn't care. After all in ZFC you could ask the following question: \"Is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi><mo>=</mo><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"double-struck\">Z</mi><mn>37</mn></msub><mo separator=\"true\">,</mo><mo>+</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\pi = (\\mathbb{Z}_{37}, +)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">37</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">+</span><span class=\"mclose\">)</span></span></span></span> ?\" After all they are both some kind of monstrous sets of sets, so this is well posed. Suppose the answer were \"Yes\". Would you care? Of course not, that is just an artifact of the implementation. Probably if you took a different encoding of ordered pairs, it would no longer be true. So it's not really a \"mathematical\" question, since as a mathematician you care only about the sets modulo their interpretation. It's kind of the same idea here. The question of whether <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>=</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N} = \\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> as <em>types</em>, is about the encoding, and so not really meaningful mathematically</p>",
        "id": 426766180,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1710516151
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"579936\">Gareth Ma</span> <a href=\"#narrow/stream/113489-new-members/topic/Newbie.20question.20.3A.20Equality.20of.20Types/near/426763618\">said</a>:</p>\n<blockquote>\n<p>Is it possible to prove types are different by some structural property about the types? For example, to prove that \\N has a minimum element but \\Z doesn't?</p>\n</blockquote>\n<p>Orderings are auxiliary data to a type and not part of the type itself. That's to say, the ordering is not a structural property of a type.</p>\n<p>A good model (at least according to me, who is neither a type theorist nor logician) is that in Lean, every type expression refers to some set (the type itself, so to speak). This mapping from type expressions to sets need not be injective. In fact there's a Cantor-style argument to prove that it definitely is not injective, though it's a nonconstructive proof and it only shows the mere existence of two type expressions that yield the same type.</p>\n<p>In principle the expression <code>ℕ</code> could refer to the same set as <code>ℤ</code> does. But it also doesn't need to. So by some model theory, whether or not they are equal is unprovable.</p>",
        "id": 426775224,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710518736
    },
    {
        "content": "<p>Appreciate the explanations and discussions. Thanks.</p>",
        "id": 426776717,
        "sender_full_name": "Madir Mabbott",
        "timestamp": 1710519217
    },
    {
        "content": "<p>Yeah this is interesting, my mental picture is clearer too</p>",
        "id": 426781564,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710520705
    },
    {
        "content": "<p>Thanks</p>",
        "id": 426781573,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710520708
    },
    {
        "content": "<p>There's a thread with much more detail about this question which you may find interesting <span class=\"user-mention\" data-user-id=\"701373\">@Madir Mabbott</span> and <span class=\"user-mention\" data-user-id=\"579936\">@Gareth Ma</span> : <a href=\"#narrow/stream/113489-new-members/topic/Equality.20with.20Types\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Equality.20with.20Types</a></p>",
        "id": 426784033,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710521514
    },
    {
        "content": "<p>This question comes up frequently enough that it would be nice to have a polished explanation we could point people to. Is this question addressed in any of the learning resources?</p>",
        "id": 426785007,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1710521817
    },
    {
        "content": "<p>(The start of that thread is not really useful for # new members lol, it's just a bunch of experienced Lean users shoving the idea that type equality is not useful)</p>",
        "id": 426785368,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710521928
    },
    {
        "content": "<p>The type-theoretic explanations for this are initially quite a lot to swallow. I suppose as an everyday mathematician I've become attached to particular models for <code>Nat</code> and <code>Int</code> and have grown to expect these to be canon. However, I found two mathematically-oriented justifications  from that earlier thread quite illuminating: <br>\n<span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Equality.20with.20Types/near/422435064\">said</a>:</p>\n<blockquote>\n<p>There is a model of Lean where they are equal, and there is a model of Lean where they are not equal, so we know for sure that the question is independent of Lean's axioms. This is a very good reason not to care about the question.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/Equality.20with.20Types/near/422448904\">said</a>:</p>\n<blockquote>\n<p>.. it is very easy to find reasons why the <em>structures</em> you put on <code>Nat</code> and <code>Int</code> are different, but wondering about whether these structures are defined on the same type or not is neither meaningful nor decidable.</p>\n</blockquote>\n<p>So this really sharpens up one's feel for the formal distinction between a structure and a particular model, even when that model is unique up to isomorphism.</p>",
        "id": 426800212,
        "sender_full_name": "Madir Mabbott",
        "timestamp": 1710527250
    }
]