[
    {
        "content": "<p>I was looking at <code>Submonoid</code> and <code>Subsemigroup</code> in Mathlib and I am not sure how structure inheritance works in Lean.</p>\n<p><a href=\"https://lean-lang.org/functional_programming_in_lean/functor-applicative-monad/inheritance.html\">Functional programming in Lean (sec 6.1)</a> talked about inheritance without input parameters, and explains that the underlying mechanism is composition. However I am confused about the case with input parameters. Here both <code>Submonoid</code> and <code>Subsemigroup</code> take <code>M</code> but these two <code>M</code> are of different typeclasses. I am wondering:</p>\n<ol>\n<li>What are the constraints of the input parameters/typeclasses of an inherited structure?</li>\n<li>How to understand inheritance with input parameters from a composition point of view?</li>\n</ol>\n<p>Here are the definitions of <code>Submonoid</code> and <code>Subsemigroup</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A submonoid of a monoid `M` is a subset containing 1 and closed under multiplication. -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Submonoid</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">MulOneClass</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">Subsemigroup</span> <span class=\"n\">M</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- A submonoid contains `1`. -/</span>\n  <span class=\"n\">one_mem'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span>\n\n<span class=\"sd\">/-- A subsemigroup of a magma `M` is a subset closed under multiplication. -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Subsemigroup</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- The carrier of a subsemigroup. -/</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">M</span>\n  <span class=\"sd\">/-- The product of two elements of a subsemigroup belongs to the subsemigroup. -/</span>\n  <span class=\"n\">mul_mem'</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span>\n</code></pre></div>",
        "id": 417253966,
        "sender_full_name": "Yunong Shi",
        "timestamp": 1705937266
    },
    {
        "content": "<ol>\n<li>You need all the parameters referenced in the parent to be available in the child. However, just like with other Lean declarations, with respect to instance arguments (the ones in <code>[</code> and <code>]</code> brackets), it is sufficient that the type class instances of the child imply those of the parent. In this case, <code>MulOneClass M</code> provides an instance of <code>Mul M</code>.</li>\n<li>Since <code>Submonoid M</code> extends <code>Subsemigroup M</code>, we have a <code>Submonoid.carrier {M : Type*} [MulOneClass M] : Set M</code> which is <code>Submonoid.toSubsemigroup.carrier</code> where the implicit argument <code>M</code> is the same, but the <code>Mul M</code> instance is filled by <code>MulOneClass.toMul</code>.</li>\n</ol>",
        "id": 417259702,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1705938770
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113489-new-members/topic/Understanding.20structure.20inheritance.20in.20Lean/near/417259702\">said</a>:</p>\n<blockquote>\n<ol>\n<li>You need all the parameters referenced in the parent to be available in the child. However, just like with other Lean declarations, with respect to instance arguments (the ones in <code>[</code> and <code>]</code> brackets), it is sufficient that the type class instances of the child imply those of the parent. In this case, <code>MulOneClass M</code> provides an instance of <code>Mul M</code>.</li>\n<li>Since <code>Submonoid M</code> extends <code>Subsemigroup M</code>, we have a <code>Submonoid.carrier {M : Type*} [MulOneClass M] : Set M</code> which is <code>Submonoid.toSubsemigroup.carrier</code> where the implicit argument <code>M</code> is the same, but the <code>Mul M</code> instance is filled by <code>MulOneClass.toMul</code>.</li>\n</ol>\n</blockquote>\n<p>Those make perfect sense. Thanks a lot!</p>",
        "id": 417270539,
        "sender_full_name": "Yunong Shi",
        "timestamp": 1705941521
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"671093\">Yunong Shi</span> has marked this topic as resolved.</p>",
        "id": 417277249,
        "sender_full_name": "Notification Bot",
        "timestamp": 1705943528
    }
]