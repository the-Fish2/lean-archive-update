[
    {
        "content": "<p>The <code>rw</code> in the Finset argument of <code>sup'</code> fails with the message that \"motive is not type correct\". Nothing I could think of makes it work and I don't understand what this message means in this context.</p>\n<p>Any advice much appreciated!</p>\n<p>Here's a mwe with the error copied into the code. (I suspect it's not minimal but it is the most minimal I could figure out extracted from the place I'm trying to use it.) The problem is in the second theorem, the first is just there because required for the statement of the second.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">map_range_ne</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">addLeftEmbedding</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">use</span> <span class=\"mi\">1</span>\n  <span class=\"n\">refine</span> <span class=\"n\">mem_map.mpr</span> <span class=\"bp\">?</span><span class=\"n\">h.a</span>\n  <span class=\"n\">use</span> <span class=\"mi\">0</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_range</span><span class=\"o\">,</span> <span class=\"n\">add_pos_iff</span><span class=\"o\">,</span> <span class=\"n\">zero_lt_one</span><span class=\"o\">,</span> <span class=\"n\">or_true</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">sup'_union_range</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">sup'</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">nonempty_range_succ</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"bp\">=</span>\n    <span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sup'</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">addLeftEmbedding</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">map_range_ne</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"bp\">∪</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">addLeftEmbedding</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">range_one</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Nat.add_comm</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">range_add_eq_union</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  tactic 'rewrite' failed, motive is not type correct</span>\n\n<span class=\"cm\">  n: ℕ</span>\n<span class=\"cm\">  f: ℕ → ℝ</span>\n<span class=\"cm\">  h0: range (n + 2) = {0} ∪ map (addLeftEmbedding 1) (range (n + 1))</span>\n<span class=\"cm\">  ⊢ sup' (range (n + 2)) ⋯ f = max (f 0) (sup' (map (addLeftEmbedding 1) (range (n + 1))) ⋯ f)</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h0</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- now use `sup'_union`</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 427071553,
        "sender_full_name": "Oliver Butterley",
        "timestamp": 1710669287
    },
    {
        "content": "<p>Have you tried <code>simp_rw</code>?</p>",
        "id": 427073070,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1710669705
    },
    {
        "content": "<p>See <a href=\"https://proofassistants.stackexchange.com/questions/1062/what-does-the-motive-is-not-type-correct-error-mean-in-lean\">here</a> for an explanation of what this error often means.</p>",
        "id": 427073212,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1710669731
    },
    {
        "content": "<p>I hadn't tried <code>simp_rw</code>. Indeed it does the job.</p>",
        "id": 427073359,
        "sender_full_name": "Oliver Butterley",
        "timestamp": 1710669770
    },
    {
        "content": "<p>There is some magic happening in the background that I'm not seeing! Is this related to the fact that it has to also rearrange the proof that the set is nonempty?</p>\n<p>Thanks for the link. I'll read a bit more.</p>",
        "id": 427073677,
        "sender_full_name": "Oliver Butterley",
        "timestamp": 1710669853
    },
    {
        "content": "<p>To be honest I didn't even had a look at your code, by usual workflow for this error is:</p>\n<ul>\n<li>try <code>simp_rw</code>. If it fails</li>\n<li>try <code>conv</code> . If it fails</li>\n<li>think about it</li>\n</ul>",
        "id": 427074027,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1710669952
    },
    {
        "content": "<p>I like having practical algorithms for problem solving that so I'll do it. Indeed simp_rw does the correct thing here but rw does not.</p>\n<p>However.... the help tells that <code>simp_rw</code> functions as a mix of <code>simp</code> and <code>rw</code>. Since I had used simp as much as possible I didn't see the benefit.</p>",
        "id": 427074447,
        "sender_full_name": "Oliver Butterley",
        "timestamp": 1710670064
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"613177\">Oliver Butterley</span> has marked this topic as resolved.</p>",
        "id": 427074454,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710670070
    },
    {
        "content": "<p>Yes, the point is that <code>sup' s</code> wants a proof that <code>s</code> is not empty. You know that <code>h : s = t</code>,  but when you change the <code>s</code> to a <code>t</code> you are telling <code>sup' t</code> that <code>s</code> is non empty, and Lean is confused.</p>",
        "id": 427074556,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1710670087
    },
    {
        "content": "<p>You can rewrite <code>Finset.sup'_congr h</code> that does exactly that.</p>",
        "id": 427074861,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1710670175
    },
    {
        "content": "<p>Good to know! Thanks for clarifying this, it had been driving me crazy.</p>",
        "id": 427075132,
        "sender_full_name": "Oliver Butterley",
        "timestamp": 1710670237
    }
]