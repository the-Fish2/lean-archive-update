[
    {
        "content": "<p>While reading TPIL chapter 8 (Induction and recursion), I came across this example of well-founded recursion:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">div_lemma</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sub_lt</span> <span class=\"o\">(</span><span class=\"n\">Nat.lt_of_lt_of_le</span> <span class=\"n\">h.left</span> <span class=\"n\">h.right</span><span class=\"o\">)</span> <span class=\"n\">h.left</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">div.F</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x₁</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">x₁</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"k\">then</span>\n    <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">div_lemma</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">zero</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">div</span> <span class=\"o\">:=</span> <span class=\"n\">WellFounded.fix</span> <span class=\"o\">(</span><span class=\"n\">measure</span> <span class=\"n\">id</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">wf</span> <span class=\"n\">div.F</span>\n</code></pre></div>\n<p>Although it's a bit hard for me to figure out what is going on here, I can see that <code>div</code> is a well-founded recursive function, since it is defined in terms of the arguments for <code>WellFounded.fix</code> . However, in the next definition, I don't understand the role that well-foundedness of <code>&lt;</code> plays:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">div</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"k\">then</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.sub_lt</span> <span class=\"o\">(</span><span class=\"n\">Nat.lt_of_lt_of_le</span> <span class=\"n\">h.1</span> <span class=\"n\">h.2</span><span class=\"o\">)</span> <span class=\"n\">h.1</span>\n    <span class=\"n\">div</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n  <span class=\"k\">else</span>\n    <span class=\"mi\">0</span>\n</code></pre></div>\n<p>This definition seems to be the same as a structurally recursive definition. What is the difference between the two? Why does Lean not use structural recursion to compile this definition?</p>",
        "id": 409098265,
        "sender_full_name": "Vivek Rajesh Joshi",
        "timestamp": 1703052991
    },
    {
        "content": "<p>In structural recursion the proof of termination works out as follows: We can see that for some argument, each time that we make a recursive call, there is at least one constructor of that argument removed. This allows Lean to do a translation to a more basic concept called recursors. Recursors is how the kernel actually thinks about recursive pattern matching function, it doesn't have a built in notion of matches and stuff like that.</p>\n<p>Then with well founded recursion you can basically do whatever you want with an argument as long as some function on your arguments decreases by  some well founded relation (sometimes you even have to tell lean yourself which one that is). This makes a translation to recursors much harder because they very closely represent the idea of structural recursion and only that. So now you need some way to tell the underlying type theory about what you are doing and that way is WellFounded.fix</p>\n<p>Now if you look at the definition of div. From the POV of the thing that handles pattern matching it cannot really tell that x - y makes the 1st argument structurally smaller. Sure we know that since y &gt; 0 it <em>must</em> do that (and that x cannot be 0 due to the additiobal condition in the if) because we know about how - works but that is not something that this part of the system can figure out on its own.</p>",
        "id": 409112585,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1703057846
    },
    {
        "content": "<p>I got what you said for well-founded recursion. But could you explain what you said for structural recursion with an example? I'm unable to see that with the examples given in TPIL. Also, I can't figure out how that is equivalent to the definition given in TPIL:<br>\nGenerally speaking, the equation compiler processes input of the following form:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[</span><span class=\"n\">patterns₁</span><span class=\"o\">]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">t₁</span>\n  <span class=\"bp\">...</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[</span><span class=\"n\">patternsₙ</span><span class=\"o\">]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">tₙ</span>\n</code></pre></div>\n<p>In this section, we will deal with structural recursion, in which the arguments to foo occurring on the right-hand side of the := are subterms of the patterns on the left-hand side. The idea is that they are structurally smaller, and hence appear in the inductive type at an earlier stage.</p>",
        "id": 409320603,
        "sender_full_name": "Vivek Rajesh Joshi",
        "timestamp": 1703140453
    },
    {
        "content": "<p>So if you look at e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.add#src\">src#Nat.add</a> you will see that it pattern matches on one of its arguments. In the zero case it performs no recursion at all. In the <code>succ n</code> case it performs one recursive call using the <code>n</code> from that pattern match. So the recursive call happens with one constructor less than the current one which guarantees us that we eventually must hit the zero case which is non recursive.</p>",
        "id": 409375555,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1703160912
    },
    {
        "content": "<p>Alright, I think I got it. Thanks <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 409396465,
        "sender_full_name": "Vivek Rajesh Joshi",
        "timestamp": 1703167731
    }
]