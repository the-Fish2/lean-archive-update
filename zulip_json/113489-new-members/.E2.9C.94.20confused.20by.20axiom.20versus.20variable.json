[
    {
        "content": "<p>I am confused by <code>axiom</code>, can someone explain please?<br>\nThe following behaves as expected and gets <code>application type mismatch</code>    because we don't have <code>p : Q</code> for the second <code>p</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">}</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"n\">And.intro</span> <span class=\"n\">p</span> <span class=\"n\">p</span>\n</code></pre></div>\n<p>But I thought using <code>axiom</code> like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">ap</span> <span class=\"o\">:</span> <span class=\"n\">P</span>\n</code></pre></div>\n<p>was saying that you have a proof of <code>P</code>.<br>\nBut why is there no type mismatch in the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">ap</span> <span class=\"o\">:</span> <span class=\"n\">P</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"n\">And.intro</span> <span class=\"n\">ap</span> <span class=\"n\">ap</span>\n</code></pre></div>",
        "id": 429860815,
        "sender_full_name": "John Stell",
        "timestamp": 1711546649
    },
    {
        "content": "<p>Do <code>#print ap</code> to see what is happening</p>",
        "id": 429861535,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711546864
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/confused.20by.20axiom.20versus.20variable/near/429861535\">said</a>:</p>\n<blockquote>\n<p>Do <code>#print ap</code> to see what is happening</p>\n</blockquote>\n<p>Ok, thank you. <code>axiom ap : ∀ {P : Prop}, P</code>.</p>\n<p>So asserting <code>axiom ap  :  P</code> means that <code>ap</code> can provide a proof of any proposition whatsoever, and it's not a possible to say it's a proof of a specific proposition?  I couldn't see this discussed in detail in the documentation, but maybe I was looking in the wrong place? Or maybe I'm missing a key concept about what's going on</p>",
        "id": 429878657,
        "sender_full_name": "John Stell",
        "timestamp": 1711551160
    },
    {
        "content": "<p>If you want it to be a proof of a fixed proposition you need to <em>define</em> that fixed proposition first!</p>",
        "id": 429880795,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711551637
    },
    {
        "content": "<p><code>variable {P : Prop}</code> doesn't define anything, it just prepends <code>{P : Prop}</code> to any declaration that follows it</p>",
        "id": 429881052,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711551681
    },
    {
        "content": "<p>To define your fixed proposition, you could do <code>def P := True</code>, <code>opaque P := True</code> (probably the best), <code>axiom P : Prop</code></p>",
        "id": 429881208,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711551720
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/confused.20by.20axiom.20versus.20variable/near/429881208\">said</a>:</p>\n<blockquote>\n<p>To define your fixed proposition, you could do <code>def P := True</code>, <code>opaque P := True</code> (probably the best), <code>axiom P : Prop</code></p>\n</blockquote>\n<p>Ah, thank you, so I could have started with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">ap</span> <span class=\"o\">:</span> <span class=\"n\">P</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">aq</span> <span class=\"o\">:</span> <span class=\"n\">Q</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"n\">And.intro</span> <span class=\"n\">ap</span> <span class=\"n\">aq</span>\n</code></pre></div>\n<p>in which there would be  an <code>application type mismatch</code> if you were to switch <code>ap</code> and <code>aq</code>.</p>",
        "id": 429892274,
        "sender_full_name": "John Stell",
        "timestamp": 1711554657
    },
    {
        "content": "<p>Is <code>axiom P : Prop</code> really a thing? I would have guessed that <code>axiom</code> should be used only for proofs, and something like <code>constant P : Prop</code> or whatever it is now should be used for things that aren't proofs.</p>",
        "id": 429934073,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711568370
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"672176\">John Stell</span> has marked this topic as resolved.</p>",
        "id": 429938824,
        "sender_full_name": "Notification Bot",
        "timestamp": 1711570236
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20confused.20by.20axiom.20versus.20variable/near/429934073\">said</a>:</p>\n<blockquote>\n<p>I would have guessed that <code>axiom</code> should be used only for proofs, and something like <code>constant P : Prop</code> or whatever it is now should be used for things that aren't proofs.</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.choice#doc\">docs#Classical.choice</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=sorryAx#doc\">docs#sorryAx</a> aren't propositions/proofs.</p>",
        "id": 429951973,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1711574642
    },
    {
        "content": "<p>huh! Funny use of the word \"axiom\" (in my mind, at least)</p>",
        "id": 429952102,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711574689
    },
    {
        "content": "<p>I agree... <code>opaque</code> feels like a better choice for non-proofs</p>",
        "id": 429962903,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1711580341
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"372804\">Marcus Rossel</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20confused.20by.20axiom.20versus.20variable/near/429951973\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20confused.20by.20axiom.20versus.20variable/near/429934073\">said</a>:</p>\n<blockquote>\n<p>I would have guessed that <code>axiom</code> should be used only for proofs, and something like <code>constant P : Prop</code> or whatever it is now should be used for things that aren't proofs.</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.choice#doc\">docs#Classical.choice</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=sorryAx#doc\">docs#sorryAx</a> aren't propositions/proofs.</p>\n</blockquote>\n<p>Well until earlier this week core had Quotient.sound as a def not a theorem, so I'm not sure I'd trust their opinion on these matters :-)</p>",
        "id": 429965471,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711581870
    },
    {
        "content": "<p>In lean 3 <code>constant</code> was available as a def-sounding <code>axiom</code>, but it no longer exists in lean 4. There is no def/theorem dichotomy for <code>axiom</code></p>",
        "id": 429987224,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711596198
    },
    {
        "content": "<p><code>opaque</code> is different, you can only use it for types you already know are inhabited</p>",
        "id": 429987251,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711596217
    },
    {
        "content": "<p>But re: the original example <code>axiom P : Prop</code>, <code>opaque</code> is indeed a better choice since <code>Prop</code> is inhabited</p>",
        "id": 429987393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711596287
    },
    {
        "content": "<p>Interestingly, <code>opaque</code> will let you define constants given only a proof that the type is nonempty, rather than inhabited, which means you can define <code>choice</code> as an opaque:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">LEM</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">X</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"n\">Nonempty</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">LEM</span> <span class=\"o\">(</span><span class=\"n\">Nonempty</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">h'</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">h'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">⟩</span>\n\n<span class=\"sd\">/-- info: 'X' depends on axioms: [LEM] -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span> <span class=\"k\">in</span> <span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"n\">opaque</span> <span class=\"n\">choice</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Nonempty</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"sd\">/-- info: 'choice' depends on axioms: [Classical.choice, LEM] -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span> <span class=\"k\">in</span> <span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">choice</span>\n</code></pre></div>\n<p>It's apparently using <code>Classical.choice</code> under the hood though, as the <code>#print axioms</code> output indicates</p>",
        "id": 429988549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711596986
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"672176\">John Stell</span> has marked this topic as unresolved.</p>",
        "id": 430247291,
        "sender_full_name": "Notification Bot",
        "timestamp": 1711714449
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/confused.20by.20axiom.20versus.20variable/near/429881208\">said</a>:</p>\n<blockquote>\n<p>To define your fixed proposition, you could do <code>def P := True</code>, <code>opaque P := True</code> (probably the best), <code>axiom P : Prop</code></p>\n</blockquote>\n<p>thank you,<br>\nbut does this make sense, where I don't want <code>P</code> to just be <code>True</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">opaque</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">observedFact</span> <span class=\"o\">:</span> <span class=\"bp\">\\</span><span class=\"n\">neg</span> <span class=\"n\">P</span> <span class=\"bp\">\\</span><span class=\"n\">to</span> <span class=\"n\">Q</span>\n</code></pre></div>\n<p>I'm in a context where I want to have some atomic propositions and to assert as axioms that some propositions constructed from these have witnesses. And then to go on to prove other propositions built out of the atomic ones using the axioms. I can see this isn't what Lean is generally used for, but I'm imagining something analogous to using the logic programming language Prolog where you might state certain facts and relationships between them and it then uses resolution to deduce new facts. Here you have to write the proofs instead of that being fully automated, but it looks a plausible analogy unless I'm misunderstanding something basic about the nature of <code>Prop</code>.</p>",
        "id": 430250621,
        "sender_full_name": "John Stell",
        "timestamp": 1711716221
    },
    {
        "content": "<p>I'm missing context, but it does sound reasonable, yes</p>",
        "id": 430250942,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711716371
    },
    {
        "content": "<p>There is basically no difference between <code>opaque P : Prop</code>, <code>opaque P : Prop := True</code> and <code>opaque P : Prop := False</code>. The term on the right is only used to provide a witness that the type in question is inhabited, and when typeclass inference can figure it out you can leave it off.</p>",
        "id": 430333651,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711756225
    },
    {
        "content": "<p>(This is not true for computable definitions, because the term on the right in that case is used for the compiled implementation of the constant. But <code>Prop</code> is not a computable type so in this case it doesn't matter.)</p>",
        "id": 430333757,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711756298
    },
    {
        "content": "<p>In particular, <code>opaque P : Prop := True</code> does not imply <code>P = True</code>. This statement is in fact independent of the proof theory - <code>P</code> is a constant of type <code>Prop</code> that cannot be proved to be anything in particular.</p>",
        "id": 430333923,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711756393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/confused.20by.20axiom.20versus.20variable/near/430333651\">said</a>:</p>\n<blockquote>\n<p>There is basically no difference between <code>opaque P : Prop</code>, <code>opaque P : Prop := True</code> and <code>opaque P : Prop := False</code>. The term on the right is only used to provide a witness that the type in question is inhabited, and when typeclass inference can figure it out you can leave it off.</p>\n</blockquote>\n<p>Ok, thanks, this is all really helpful. <br>\nSo the point is that to have a constant of any type we need to ensure the type is inhabited. In this case we need that Prop is inhabited.  Of course we have the same issue with constants at any level:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">np</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span>\n<span class=\"n\">opaque</span> <span class=\"n\">notP</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">np</span>\n</code></pre></div>\n<p>In that case we cannot just say <code>opaque notP : ¬ P</code> because we have to justify that <code>¬ P</code> is inhabited, which is what the <code>:=  np</code> does. After that, as far as I can see, the constants <code>np</code> and <code>notP</code> can do the same things; it doesn't matter that one was introduced as an axiom and the other as opaque. </p>\n<p>And <code>Prop</code> is special because for any proposition <code>axiom</code> allows us to introduce a constant inhabiting that proposition, but this isn't allowed other types. So I can see why the earlier discussion about <code>axiom P : Prop</code> being odd arose.</p>",
        "id": 430381544,
        "sender_full_name": "John Stell",
        "timestamp": 1711797627
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"672176\">John Stell</span> <a href=\"#narrow/stream/113489-new-members/topic/confused.20by.20axiom.20versus.20variable/near/430381544\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">np</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span>\n<span class=\"n\">opaque</span> <span class=\"n\">notP</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">np</span>\n</code></pre></div>\n<p>In that case we cannot just say <code>opaque notP : ¬ P</code> because we have to justify that <code>¬ P</code> is inhabited</p>\n</blockquote>\n<p>I believe you are confusing the syntax with the underlying justification. Part of what Mario is saying above is that you can do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">np</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"bp\">¬</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">np</span><span class=\"o\">⟩</span>\n<span class=\"n\">opaque</span> <span class=\"n\">notP</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span>\n</code></pre></div>",
        "id": 430381701,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711797761
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"672176\">John Stell</span> <a href=\"#narrow/stream/113489-new-members/topic/confused.20by.20axiom.20versus.20variable/near/430381544\">said</a>:</p>\n<blockquote>\n<p>And <code>Prop</code> is special because for any proposition <code>axiom</code> allows us to introduce a constant inhabiting that proposition, but this isn't allowed other types. So I can see why the earlier discussion about <code>axiom P : Prop</code> being odd arose.</p>\n</blockquote>\n<p>I'm not sure I understand what you mean. I can replace \"proposition\"/<code>Prop</code> by \"type\"/<code>Type</code> everywhere in your sentence without changing its validity.</p>",
        "id": 430381838,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711797891
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/confused.20by.20axiom.20versus.20variable/near/430381701\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"672176\">John Stell</span> <a href=\"#narrow/stream/113489-new-members/topic/confused.20by.20axiom.20versus.20variable/near/430381544\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">np</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span>\n<span class=\"n\">opaque</span> <span class=\"n\">notP</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">np</span>\n</code></pre></div>\n<p>In that case we cannot just say <code>opaque notP : ¬ P</code> because we have to justify that <code>¬ P</code> is inhabited</p>\n</blockquote>\n<p>I believe you are confusing the syntax with the underlying justification. Part of what Mario is saying above is that you can do</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">np</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"bp\">¬</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">np</span><span class=\"o\">⟩</span>\n<span class=\"n\">opaque</span> <span class=\"n\">notP</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thanks, I didn't know there were other ways to say the same thing. That makes sense</p>",
        "id": 430382810,
        "sender_full_name": "John Stell",
        "timestamp": 1711798736
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"672176\">John Stell</span> <a href=\"#narrow/stream/113489-new-members/topic/confused.20by.20axiom.20versus.20variable/near/430381544\">said</a>:</p>\n<blockquote>\n<p>In that case we cannot just say <code>opaque notP : ¬ P</code> because we have to justify that <code>¬ P</code> is inhabited, which is what the <code>:= np</code> does. After that, as far as I can see, the constants <code>np</code> and <code>notP</code> can do the same things; it doesn't matter that one was introduced as an axiom and the other as opaque.</p>\n</blockquote>\n<p>Note that proofs are a bit special, because of proof irrelevance. I said that opaques don't have any nontrivial definitional equalities, but <code>notP</code> is provably equal to <code>np</code> because they are both inhabitants of the same proposition. (For this reason, it's almost never useful to use <code>opaque</code> to construct an element of a proposition, because you can just use whatever proof you used to prove the <code>opaque</code> is legal directly; in this case that means using <code>np</code> instead of <code>notP</code>.)</p>\n<p><code>axiom foo : T</code> is almost the same as <code>opaque foo : T</code>; the only difference is that <code>axiom</code> does not require that the type <code>T</code> is inhabited, which means that if <code>T</code> is an empty type you can introduce falsehoods using <code>axiom</code>. So <code>axiom</code> is used very sparingly, and there are basically only 3 axioms used in mathlib (all of which are defined in core). But it's fine to use it in your own code when playing around with things as long as you keep in mind what it means.</p>",
        "id": 430383337,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711799192
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/confused.20by.20axiom.20versus.20variable/near/430381838\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"672176\">John Stell</span> <a href=\"#narrow/stream/113489-new-members/topic/confused.20by.20axiom.20versus.20variable/near/430381544\">said</a>:</p>\n<blockquote>\n<p>And <code>Prop</code> is special because for any proposition <code>axiom</code> allows us to introduce a constant inhabiting that proposition, but this isn't allowed other types. So I can see why the earlier discussion about <code>axiom P : Prop</code> being odd arose.</p>\n</blockquote>\n<p>I'm not sure I understand what you mean. I can replace \"proposition\"/<code>Prop</code> by \"type\"/<code>Type</code> everywhere in your sentence without changing its validity.</p>\n</blockquote>\n<p>So, is this right?  <code>axiom</code> introduces a constant just like <code>opaque</code> does but <code>axiom</code> doesn't require evidence that the <br>\ntype is  inhabited whereas <code>opaque</code> does  need this evidence. This is what happens at any level and <code>Prop</code> isn't special in this regard.</p>",
        "id": 430384239,
        "sender_full_name": "John Stell",
        "timestamp": 1711800076
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"672176\">John Stell</span> has marked this topic as resolved.</p>",
        "id": 430393217,
        "sender_full_name": "Notification Bot",
        "timestamp": 1711807965
    }
]