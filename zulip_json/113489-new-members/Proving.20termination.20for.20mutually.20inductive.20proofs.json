[
    {
        "content": "<p>Hey folks. Not sure if this is the right place to ask, but I'm having a hard time proving termination for this mutually inductive proof I'm working on.</p>\n<p>I'm trying to show that a bidirectional type checking algorithm agrees with a relational notion of well-typedness for a simply-typed lambda calculus. The details aren't super important, the main thing is that the proof is supposed to have the same inductive structure (and therefore termination argument) as the mutually-defined type-checking algorithm, but for some reason Lean can figure out termination for one and not the other.</p>\n<p>If anyone could help me I'd really appreciate it.</p>\n<p><a href=\"/user_uploads/3121/CY78Uvyd9w2ZqFhbPxMwdXds/STLC.lean\">STLC.lean</a></p>",
        "id": 418132195,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1706204467
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 418134353,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1706205171
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 418136751,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1706206032
    },
    {
        "content": "<p>we both tried to post the same link.. It seems like there's something broken with linking to <a href=\"https://live.lean-lang.org\">https://live.lean-lang.org</a> when the code has parentheses</p>",
        "id": 418136938,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1706206097
    },
    {
        "content": "<p>This could be a bug I recently fixed, <a href=\"https://github.com/leanprover/lean4/pull/3204\">https://github.com/leanprover/lean4/pull/3204</a>.</p>\n<p>Hmm, or not.</p>",
        "id": 418136978,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1706206116
    },
    {
        "content": "<p>So, with <code>set_option showInferredTerminationBy true</code> I found out that your functions are proved terminating using</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">termination_by</span>\n  <span class=\"n\">checkType</span> <span class=\"n\">x1</span> <span class=\"n\">x2</span> <span class=\"n\">x3</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">sizeOf</span> <span class=\"n\">x2</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"n\">inferType</span> <span class=\"n\">x1</span> <span class=\"n\">x2</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">sizeOf</span> <span class=\"n\">x2</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and it’s good practice to copy that after the <code>mutual … end</code> to be explicitly (an check that it matches your expectations).</p>\n<p>I can now write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">termination_by</span>\n  <span class=\"n\">checkType_sound</span> <span class=\"n\">x1</span> <span class=\"n\">x2</span> <span class=\"n\">x3</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">sizeOf</span> <span class=\"n\">x2</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"n\">inferType_sound</span> <span class=\"n\">x1</span> <span class=\"n\">x2</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">sizeOf</span> <span class=\"n\">x2</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>below the proofs and tell Lean how I’d expect the termination argument to go.  This gives better error messages, namely</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">prove</span> <span class=\"n\">termination</span><span class=\"o\">,</span> <span class=\"n\">possible</span> <span class=\"n\">solutions</span><span class=\"o\">:</span>\n  <span class=\"bp\">-</span> <span class=\"n\">Use</span> <span class=\"bp\">`</span><span class=\"k\">have</span><span class=\"bp\">`-</span><span class=\"n\">expressions</span> <span class=\"n\">to</span> <span class=\"n\">prove</span> <span class=\"n\">the</span> <span class=\"n\">remaining</span> <span class=\"n\">goals</span>\n  <span class=\"bp\">-</span> <span class=\"n\">Use</span> <span class=\"bp\">`</span><span class=\"n\">termination_by</span><span class=\"bp\">`</span> <span class=\"n\">to</span> <span class=\"n\">specify</span> <span class=\"n\">a</span> <span class=\"n\">different</span> <span class=\"n\">well</span><span class=\"bp\">-</span><span class=\"n\">founded</span> <span class=\"n\">relation</span>\n  <span class=\"bp\">-</span> <span class=\"n\">Use</span> <span class=\"bp\">`</span><span class=\"n\">decreasing_by</span><span class=\"bp\">`</span> <span class=\"n\">to</span> <span class=\"n\">specify</span> <span class=\"n\">your</span> <span class=\"n\">own</span> <span class=\"n\">tactic</span> <span class=\"n\">for</span> <span class=\"n\">discharging</span> <span class=\"n\">this</span> <span class=\"n\">kind</span> <span class=\"n\">of</span> <span class=\"n\">goal</span>\n<span class=\"bp\">Γ✝</span><span class=\"o\">:</span> <span class=\"n\">Context</span>\n<span class=\"n\">e₁e₂</span><span class=\"o\">:</span> <span class=\"n\">Expr</span>\n<span class=\"n\">τ</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"n\">Ty</span>\n<span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Context</span><span class=\"o\">)</span> <span class=\"bp\">×'</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"bp\">×'</span> <span class=\"n\">Ty</span> <span class=\"bp\">⊕'</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Context</span><span class=\"o\">)</span> <span class=\"bp\">×'</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"bp\">×'</span> <span class=\"n\">Ty</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"n\">invImage</span>\n          <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span>\n            <span class=\"n\">PSum.casesOn</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">val</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">PSigma.casesOn</span> <span class=\"n\">val</span> <span class=\"k\">fun</span> <span class=\"n\">x1</span> <span class=\"n\">snd</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">PSigma.casesOn</span> <span class=\"n\">snd</span> <span class=\"k\">fun</span> <span class=\"n\">x2</span> <span class=\"n\">snd</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">sizeOf</span> <span class=\"n\">x2</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n              <span class=\"k\">fun</span> <span class=\"n\">val</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">PSigma.casesOn</span> <span class=\"n\">val</span> <span class=\"k\">fun</span> <span class=\"n\">x1</span> <span class=\"n\">snd</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">PSigma.casesOn</span> <span class=\"n\">snd</span> <span class=\"k\">fun</span> <span class=\"n\">x2</span> <span class=\"n\">snd</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">sizeOf</span> <span class=\"n\">x2</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n          <span class=\"n\">Prod.instWellFoundedRelationProd</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n      <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">PSum.inr</span> <span class=\"o\">{</span> <span class=\"n\">fst</span> <span class=\"o\">:=</span> <span class=\"bp\">Γ✝</span><span class=\"o\">,</span> <span class=\"n\">snd</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">fst</span> <span class=\"o\">:=</span> <span class=\"n\">e₁</span> <span class=\"bp\">⋅</span> <span class=\"n\">e₂</span><span class=\"o\">,</span> <span class=\"n\">snd</span> <span class=\"o\">:=</span> <span class=\"n\">τ</span><span class=\"bp\">✝</span> <span class=\"o\">}</span> <span class=\"o\">})</span> <span class=\"bp\">→</span>\n    <span class=\"n\">PSum.casesOn</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">checkType</span> <span class=\"n\">_x.1</span> <span class=\"n\">_x.2.1</span> <span class=\"n\">_x.2.2</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"bp\">→</span> <span class=\"n\">_x.1</span> <span class=\"bp\">⊢</span> <span class=\"n\">_x.2.1</span> <span class=\"o\">:</span> <span class=\"n\">_x.2.2</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">_x</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">inferType</span> <span class=\"n\">_x.1</span> <span class=\"n\">_x.2.1</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">_x.2.2</span> <span class=\"bp\">→</span> <span class=\"n\">_x.1</span> <span class=\"bp\">⊢</span> <span class=\"n\">_x.2.1</span> <span class=\"o\">:</span> <span class=\"n\">_x.2.2</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">inferType</span> <span class=\"bp\">Γ✝</span> <span class=\"o\">(</span><span class=\"n\">e₁</span> <span class=\"bp\">⋅</span> <span class=\"n\">e₂</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">τ</span><span class=\"bp\">✝</span>\n<span class=\"n\">τ₁</span><span class=\"o\">:</span> <span class=\"n\">Ty</span>\n<span class=\"n\">τ₂</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"n\">inferType</span> <span class=\"bp\">Γ✝</span> <span class=\"n\">e₁</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">τ₁</span>\n<span class=\"n\">hτ</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">τ₁</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">τa</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">τb</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">checkType</span> <span class=\"bp\">Γ✝</span> <span class=\"n\">e₂</span> <span class=\"n\">τa</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"n\">τb</span> <span class=\"k\">else</span> <span class=\"n\">none</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"n\">some</span> <span class=\"n\">τ</span><span class=\"bp\">✝</span>\n<span class=\"n\">τaτb</span><span class=\"o\">:</span> <span class=\"n\">Ty</span>\n<span class=\"n\">τ₂</span><span class=\"o\">:</span> <span class=\"n\">inferType</span> <span class=\"bp\">Γ✝</span> <span class=\"n\">e₁</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">τa</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">τb</span><span class=\"o\">)</span>\n<span class=\"n\">hτ</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">τa</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">τb</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">τa</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">τb</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">checkType</span> <span class=\"bp\">Γ✝</span> <span class=\"n\">e₂</span> <span class=\"n\">τa</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"n\">τb</span> <span class=\"k\">else</span> <span class=\"n\">none</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"n\">some</span> <span class=\"n\">τ</span><span class=\"bp\">✝</span>\n<span class=\"n\">hτ₁</span><span class=\"o\">:</span> <span class=\"n\">checkType</span> <span class=\"bp\">Γ✝</span> <span class=\"n\">e₂</span> <span class=\"n\">τa</span> <span class=\"bp\">=</span> <span class=\"n\">true</span>\n<span class=\"n\">hτ₂</span><span class=\"o\">:</span> <span class=\"n\">τb</span> <span class=\"bp\">=</span> <span class=\"n\">τ</span><span class=\"bp\">✝</span>\n<span class=\"bp\">Γ</span><span class=\"o\">:</span> <span class=\"n\">Context</span>\n<span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"n\">Expr</span>\n<span class=\"n\">τ</span><span class=\"o\">:</span> <span class=\"n\">Ty</span>\n<span class=\"n\">a</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"n\">inferType</span> <span class=\"bp\">Γ</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">τ</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">sizeOf</span> <span class=\"n\">e</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">e₁</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">e₂</span>\n</code></pre></div>\n<p>Now the <code>e</code> is unconnected to <code>e1</code> and <code>e2</code>, so probably not provable, probably because somewhere the connection got lost.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>\n</code></pre></div>",
        "id": 418138729,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1706206690
    },
    {
        "content": "<p>(It’s a bug (probably due to me) that this error message isn’t anchored at the relevant recursive call.)</p>",
        "id": 418138958,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1706206783
    },
    {
        "content": "<p>Ah, and if I replace</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">inferType_sound</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">apply</span> <span class=\"n\">inferType_sound</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n</code></pre></div>\n<p>it works! So it might be that lean bug after all.</p>",
        "id": 418139455,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1706206969
    },
    {
        "content": "<p>(Background: Simp produces proof terms where the recursive call not fully saturated, and then the termination checker, without the mentioned fix, doesn’t see who the argument relates to your parameters.)</p>",
        "id": 418139584,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1706207034
    },
    {
        "content": "<p>BTW, I am currently working on improving things around well-founded recursion, e.g. generating induction principles from function definitions. Prototype at <a href=\"https://github.com/nomeata/lean-wf-induct\">https://github.com/nomeata/lean-wf-induct</a>. I am looking for alpha-testers and early adoptors, so if you expect to do more proofs about stuff defined by well-founded recursion and are interested to play guinea pig, that’d be great.</p>\n<p>(Your definition <em>should</em> actually just be structurally recursive, but Lean doesn’t support that. It’s on the roadmap.)</p>",
        "id": 418139950,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1706207167
    },
    {
        "content": "<p>Oh, and welcome to the lean Zulip, <span class=\"user-mention\" data-user-id=\"686704\">@Harry Goldstein</span>  :-)</p>",
        "id": 418150358,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1706211027
    },
    {
        "content": "<p>Thank you! :-)</p>\n<p>Oh wow, what a simple fix! Thank you so much. I had a feeling it might be doing something weird under the hood when I called <code>simp</code>, but I naïvely thought it couldn't be doing something weird enough to break the termination checker. But OK, this is good to know. I'm not sure I'll be doing a lot of this kind of thing moving forward, but if I decide to do more I'll definitely check out the prototype. For now I'm just noodling around to get my bearings.</p>",
        "id": 418273382,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1706274993
    },
    {
        "content": "<p>It’s a rather silly reason why this breaks.</p>\n<p>When resolving identifiers, lean inserts a little meta-data note around the recursive call which remembers the original source position, so that later when we do the termination proof (and all surface syntax is gone) we can report the error location. But if the recursive call is not syntactically saturated (as in <code>simp [foo]</code>), this marker  keeps the arguments “separate” from the recursive call, and to the termination checker it looks like a higher-order use. Kinda silly that a little hack to produce nicer termination errors causes more termination errors.</p>\n<p>A while ago I fixed that by floating these markers out of applications. But due to my limited understanding of some of lean’s utility functions, that fix only worked for <em>unary</em> applications. I noticed that only recently, and the fix for that isn't released yet.</p>\n<p>Not sure if anyone wanted to know these hairy details :-D</p>",
        "id": 418300248,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1706283630
    }
]