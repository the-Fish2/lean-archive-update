[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"577178\">@Graham Leach-Krouse</span> and I are working on a binary file parser and there are lots of magic numbers. To stay organized, we parse these numbers into named enum values, and later serialize the enum values back to Nats. Modern software languages usually provide a concise way to define enums with values since it's a common pattern, but we're not sure how to write this concisely in Lean.</p>\n<p>Right now we implement this with an inductive enum type, plus two separate functions toNat and fromNat, plus a pair of theorems that <code>toNat $ fromNat</code> and <code>fromNat $ toNat</code> are identities. It's a ton of boilerplate, and we have hundreds (or maybe thousands!) of magic numbers to deal with.</p>\n<p>Instead, we'd like to write something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">inductive_with_values</span> <span class=\"n\">Weekday</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">7</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">sunday</span> <span class=\"o\">:</span> <span class=\"n\">Weekday</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">monday</span> <span class=\"o\">:</span> <span class=\"n\">Weekday</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">...</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">Weekday.sunday.value</span>  <span class=\"c1\">-- 0</span>\n<span class=\"k\">#eval</span> <span class=\"n\">Weekday.mk</span> <span class=\"mi\">0</span>  <span class=\"c1\">-- Weekday.sunday</span>\n<span class=\"k\">#check</span> <span class=\"n\">Weekday.value_of_mk</span>  <span class=\"c1\">-- Weekday.value_of_mk (n: Nat) : (Weekday.mk n).value = n</span>\n<span class=\"k\">#check</span> <span class=\"n\">Weekday.mk_of_value</span>  <span class=\"c1\">-- Weekday.mk_of_value (w: Weekday) : Weekday.mk w.value = w</span>\n</code></pre></div>\n<p>Also, in some cases, we need to map large number ranges to a common enum label and preserve the original value, e.g.:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">inductive_with_values</span> <span class=\"n\">Vehicle</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Volvo</span> <span class=\"o\">:</span> <span class=\"n\">Vehicle</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Hyundai</span> <span class=\"o\">:</span> <span class=\"n\">Vehicle</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">...</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Tesla</span> <span class=\"o\">:</span> <span class=\"n\">Vehicle</span> <span class=\"o\">:=</span> <span class=\"mi\">34</span>\n  <span class=\"bp\">|</span> <span class=\"n\">UnusedCar</span> <span class=\"o\">:</span> <span class=\"n\">Vehicle</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"k\">if</span> <span class=\"mi\">34</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">512</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Boeing</span> <span class=\"o\">:</span> <span class=\"n\">Vehicle</span> <span class=\"o\">:=</span> <span class=\"mi\">512</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">...</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Airbus</span> <span class=\"o\">:</span> <span class=\"n\">Vehicle</span> <span class=\"o\">:=</span> <span class=\"mi\">528</span>\n  <span class=\"bp\">|</span> <span class=\"n\">UnusedPlane</span> <span class=\"o\">:</span> <span class=\"n\">Vehicle</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"k\">if</span> <span class=\"mi\">528</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1024</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Invalid</span> <span class=\"o\">:</span> <span class=\"n\">Vehicle</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>  <span class=\"c1\">-- all remaining numbers</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">Vehicle.mk</span> <span class=\"mi\">36</span>  <span class=\"c1\">-- Vehicle.UnusedCar 36</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">Vehicle.mk</span> <span class=\"mi\">36</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">value</span>  <span class=\"c1\">-- 36</span>\n</code></pre></div>\n<p>Does something like this exist already? If not, any suggestions on how we can add it? Neither of us has written any metaprogramming yet. Thanks!</p>",
        "id": 432834977,
        "sender_full_name": "Daniel Windham",
        "timestamp": 1712901847
    },
    {
        "content": "<p>If your enum values are specifically <code>Fin n</code>, then <code>FinEnum</code> might work for you</p>",
        "id": 432850726,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712908264
    },
    {
        "content": "<p>Though it's a rather unloved bit of API that needs some work</p>",
        "id": 432850775,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712908286
    },
    {
        "content": "<p>Here's a makeshift <code>enum</code> macro that covers the basic case:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Parser</span> <span class=\"n\">Command</span>\n\n<span class=\"n\">declare_syntax_cat</span> <span class=\"n\">enum_case</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"| \"</span> <span class=\"n\">ident</span> <span class=\"s2\">\" := \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">enum_case</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">split</span> <span class=\"o\">(</span><span class=\"n\">cases</span> <span class=\"o\">:</span> <span class=\"n\">TSyntaxArray</span> <span class=\"bp\">`</span><span class=\"n\">enum_case</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">Ident</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">cases.foldl</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">#</span><span class=\"o\">[],</span> <span class=\"bp\">#</span><span class=\"o\">[]))</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">names</span><span class=\"o\">,</span> <span class=\"n\">values</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">enum_case</span><span class=\"bp\">|</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">names.push</span> <span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">values.push</span> <span class=\"n\">value</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">unreachable</span><span class=\"bp\">!</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"enum\"</span> <span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"s2\">\" : \"</span> <span class=\"n\">ty</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"s2\">\" where\"</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"n\">cases</span><span class=\"o\">:</span><span class=\"n\">enum_case</span><span class=\"bp\">*</span> <span class=\"n\">d</span><span class=\"o\">:</span><span class=\"n\">optDeriving</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">names</span><span class=\"o\">,</span> <span class=\"n\">values</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">split</span> <span class=\"n\">cases</span>\n  <span class=\"k\">let</span> <span class=\"n\">eIdent</span> <span class=\"o\">(</span><span class=\"n\">suffix</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdentFrom</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">e.getId</span> <span class=\"bp\">++</span> <span class=\"n\">suffix</span><span class=\"o\">)</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span>\n    <span class=\"kd\">inductive</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">names</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">]</span><span class=\"bp\">*</span> <span class=\"bp\">$</span><span class=\"n\">d</span><span class=\"o\">:</span><span class=\"n\">optDeriving</span>\n    <span class=\"kd\">def</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">e</span> <span class=\"bp\">→</span> <span class=\"bp\">$</span><span class=\"n\">ty</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">names</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">values</span><span class=\"o\">]</span><span class=\"bp\">*</span>\n    <span class=\"kd\">def</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">ofVal</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"bp\">$</span><span class=\"n\">e</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">values</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"bp\">$</span><span class=\"n\">names</span><span class=\"o\">]</span><span class=\"bp\">*</span> <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n    <span class=\"kd\">theorem</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">ofVal_val</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">ofVal</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">e</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"kd\">theorem</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">val_ofVal</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">ofVal</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">unfold</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">ofVal</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n      <span class=\"n\">split</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">injection</span> <span class=\"n\">h</span>\n      <span class=\"n\">all_goals</span> <span class=\"n\">rename_i</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n  <span class=\"o\">)</span>\n\n<span class=\"n\">enum</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">two</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span><span class=\"o\">,</span> <span class=\"n\">BEq</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">E</span>\n<span class=\"k\">#print</span> <span class=\"n\">E.val</span>\n<span class=\"k\">#print</span> <span class=\"n\">E.ofVal</span>\n<span class=\"k\">#check</span> <span class=\"n\">E.ofVal_val</span>\n<span class=\"k\">#check</span> <span class=\"n\">E.val_ofVal</span>\n</code></pre></div>\n<p>Or do you always know that your enum cases cover all possible values of the given type?</p>",
        "id": 432852169,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1712908822
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"372804\">@Marcus Rossel</span> , this is very helpful! (Sorry for my very delayed reply here.)</p>\n<p>I'm trying to generalize this example to retain the original Nat value in the default case. I need to know that this retained value is a Nat that does not match any of the enumerated cases.</p>\n<p>I'm getting stuck trying to dynamically construct an array syntax term from the user-provided data. How can I construct a TSyntax term like <code>[1, 2]</code> given an array of terms or an array of Nats?</p>\n<p>Here's a simplified example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"test\"</span> <span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"n\">cases</span><span class=\"o\">:</span><span class=\"n\">enum_case</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">names</span><span class=\"o\">,</span> <span class=\"n\">values</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">splitArray</span> <span class=\"n\">cases</span> <span class=\"c1\">-- values has type Array Term (same as previous post)</span>\n  <span class=\"k\">let</span> <span class=\"n\">valuesHardcoded</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">]</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span>\n    <span class=\"c1\">-- def $e:ident := $values           -- fails, because rhs is expected to have type TSyntax `term</span>\n    <span class=\"c1\">-- def $e:ident := $valuesHardcoded  -- fails, because rhs is expected to have type TSyntax `term</span>\n    <span class=\"kd\">def</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">]</span>\n  <span class=\"o\">)</span>\n\n<span class=\"n\">test</span> <span class=\"n\">D</span>\n  <span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">two</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">D</span> <span class=\"c1\">-- def D : List Nat := [1, 2]</span>\n</code></pre></div>\n<hr>\n<p>If it's useful, here is what I'm trying to achieve overall:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- supporting definition</span>\n<span class=\"kd\">structure</span> <span class=\"n\">NatOtherThan</span> <span class=\"o\">(</span><span class=\"n\">excluded</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">val</span>  <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">isOther</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">excluded.contains</span> <span class=\"n\">val</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">BEq</span><span class=\"o\">,</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">NatOtherThan</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- the user writes this:</span>\n<span class=\"n\">enum</span> <span class=\"n\">EE</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">three</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n  <span class=\"bp\">|</span> <span class=\"n\">other</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n\n<span class=\"c1\">-- `enum` is desugared into this inductive type (plus supporting functions)</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">EE</span>\n  <span class=\"bp\">|</span> <span class=\"n\">one</span>\n  <span class=\"bp\">|</span> <span class=\"n\">three</span>\n  <span class=\"bp\">|</span> <span class=\"n\">rest</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">NatOtherThan</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">])</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span><span class=\"o\">,</span> <span class=\"n\">BEq</span><span class=\"o\">,</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">EE.rest</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">⟩)</span>\n</code></pre></div>",
        "id": 433793837,
        "sender_full_name": "Daniel Windham",
        "timestamp": 1713365283
    },
    {
        "content": "<p>I played around with this a bit, and came up with the following, which should add a default \"unknown\" case and also allow docComments on the constructors. It's my first nontrivial macro though, so I'm guessing that it can be improved quite a bit...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Parser</span> <span class=\"n\">Command</span>\n\n<span class=\"n\">declare_syntax_cat</span> <span class=\"n\">enum_case</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">docComment</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"s2\">\" | \"</span> <span class=\"n\">ident</span> <span class=\"s2\">\" := \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">enum_case</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">split</span> <span class=\"o\">(</span><span class=\"n\">cases</span> <span class=\"o\">:</span> <span class=\"n\">TSyntaxArray</span> <span class=\"bp\">`</span><span class=\"n\">enum_case</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">Ident</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">Lean.TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Command.docComment</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"n\">cases.foldl</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">#</span><span class=\"o\">[],</span> <span class=\"bp\">#</span><span class=\"o\">[],</span> <span class=\"bp\">#</span><span class=\"o\">[]))</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">names</span><span class=\"o\">,</span> <span class=\"n\">values</span><span class=\"o\">,</span> <span class=\"n\">comments</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">enum_case</span><span class=\"bp\">|</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">names.push</span> <span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">values.push</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"n\">comments.push</span> <span class=\"n\">emptyComment</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">enum_case</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">comment</span><span class=\"o\">:</span><span class=\"n\">docComment</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">names.push</span> <span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">values.push</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"n\">comments.push</span> <span class=\"n\">comment</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">unreachable</span><span class=\"bp\">!</span>\n  <span class=\"n\">where</span> <span class=\"n\">commentLeader</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Syntax</span> <span class=\"o\">:=</span> <span class=\"n\">Lean.Syntax.atom</span> <span class=\"n\">SourceInfo.none</span> <span class=\"s2\">\"/--\"</span>\n        <span class=\"n\">commentBody</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Syntax</span> <span class=\"o\">:=</span> <span class=\"n\">Lean.Syntax.atom</span> <span class=\"n\">SourceInfo.none</span> <span class=\"s2\">\"undocumented -/\"</span>\n        <span class=\"n\">emptyComment</span> <span class=\"o\">:</span> <span class=\"n\">Lean.TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Command.docComment</span> <span class=\"o\">:=</span> <span class=\"n\">Lean.TSyntax.mk</span> <span class=\"bp\">$</span>\n          <span class=\"n\">Lean.Syntax.node</span> <span class=\"n\">SourceInfo.none</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Command.docComment</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">commentLeader</span><span class=\"o\">,</span> <span class=\"n\">commentBody</span><span class=\"o\">]</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"enum\"</span> <span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"s2\">\" : \"</span> <span class=\"n\">ty</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"s2\">\" where\"</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"n\">cases</span><span class=\"o\">:</span><span class=\"n\">enum_case</span><span class=\"bp\">*</span> <span class=\"n\">d</span><span class=\"o\">:</span><span class=\"n\">optDeriving</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">names</span><span class=\"o\">,</span> <span class=\"n\">values</span><span class=\"o\">,</span> <span class=\"n\">comments</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">split</span> <span class=\"n\">cases</span>\n  <span class=\"k\">let</span> <span class=\"n\">eIdent</span> <span class=\"o\">(</span><span class=\"n\">suffix</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdentFrom</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">e.getId</span> <span class=\"bp\">++</span> <span class=\"n\">suffix</span><span class=\"o\">)</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span>\n    <span class=\"kd\">inductive</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">comments</span><span class=\"o\">:</span><span class=\"n\">docComment</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">names</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">]</span><span class=\"bp\">*</span> <span class=\"bp\">|</span> <span class=\"n\">unknown</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">d</span><span class=\"o\">:</span><span class=\"n\">optDeriving</span>\n    <span class=\"kd\">def</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">e</span> <span class=\"bp\">→</span> <span class=\"bp\">$</span><span class=\"n\">ty</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">names</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">values</span><span class=\"o\">]</span><span class=\"bp\">*</span> <span class=\"bp\">|</span> <span class=\"n\">unknown</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n    <span class=\"kd\">def</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">ofVal</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span> <span class=\"bp\">→</span> <span class=\"bp\">$</span><span class=\"n\">e</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">values</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">names</span><span class=\"o\">]</span><span class=\"bp\">*</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">unknown</span> <span class=\"n\">x</span>\n\n    <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"bp\">$</span><span class=\"n\">e</span> <span class=\"bp\">$</span><span class=\"n\">ty</span> <span class=\"n\">where</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">val</span><span class=\"o\">)</span>\n\n    <span class=\"c\">/-</span><span class=\"cm\"> theorem $(eIdent `ofVal_val) (e : $e) : $(eIdent `ofVal) ($(eIdent `val) e) = e := by cases e &lt;;&gt; try rfl &lt;;&gt; unfold $(eIdent `val) -/</span>\n    <span class=\"kd\">theorem</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">val_ofVal</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">ofVal</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">unfold</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">ofVal</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n      <span class=\"n\">split</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">injection</span> <span class=\"n\">h</span>\n      <span class=\"n\">all_goals</span> <span class=\"n\">rename_i</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n  <span class=\"o\">)</span>\n</code></pre></div>",
        "id": 433796638,
        "sender_full_name": "Graham Leach-Krouse",
        "timestamp": 1713365593
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"662442\">Daniel Windham</span> <a href=\"#narrow/stream/113489-new-members/topic/concise.20enum-with-values.20type/near/433793837\">said</a>:</p>\n<blockquote>\n<p>I'm getting stuck trying to dynamically construct an array syntax term from the user-provided data. How can I construct a TSyntax term like <code>[1, 2]</code> given an array of terms or an array of Nats?</p>\n</blockquote>\n<p>What you're looking for is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Quote#doc\">docs#Lean.Quote</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"one_two\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">vals</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">stx</span> <span class=\"o\">:=</span> <span class=\"n\">Lean.quote</span> <span class=\"n\">vals</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">stx</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">one_two</span> <span class=\"c1\">-- [1, 2]</span>\n</code></pre></div>",
        "id": 433801725,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1713366130
    },
    {
        "content": "<p>Perfect, thanks <span class=\"user-mention\" data-user-id=\"372804\">@Marcus Rossel</span>.</p>",
        "id": 433803380,
        "sender_full_name": "Daniel Windham",
        "timestamp": 1713366307
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"662442\">@Daniel Windham</span> Here's an outline of a macro that follows the example you gave:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Macro</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Parser</span> <span class=\"n\">Command</span>\n\n<span class=\"n\">declare_syntax_cat</span> <span class=\"n\">enum_case</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"| \"</span> <span class=\"n\">ident</span> <span class=\"s2\">\" := \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">enum_case</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">split</span> <span class=\"o\">(</span><span class=\"n\">cases</span> <span class=\"o\">:</span> <span class=\"n\">TSyntaxArray</span> <span class=\"bp\">`</span><span class=\"n\">enum_case</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MacroM</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">Ident</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">cases.foldlM</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">#</span><span class=\"o\">[],</span> <span class=\"bp\">#</span><span class=\"o\">[]))</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">names</span><span class=\"o\">,</span> <span class=\"n\">values</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">enum_case</span><span class=\"bp\">|</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"k\">if</span> <span class=\"n\">name.getId</span> <span class=\"bp\">==</span> <span class=\"bp\">`</span><span class=\"n\">other</span> <span class=\"k\">then</span> <span class=\"n\">Macro.throwErrorAt</span> <span class=\"n\">name</span> <span class=\"s2\">\"enum cases cannot be called 'other'\"</span>\n      <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">names.push</span> <span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">values.push</span> <span class=\"n\">value</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">unreachable</span><span class=\"bp\">!</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"enum\"</span> <span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"s2\">\" : \"</span> <span class=\"n\">ty</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"s2\">\" where\"</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"n\">cases</span><span class=\"o\">:</span><span class=\"n\">enum_case</span><span class=\"bp\">*</span> <span class=\"n\">d</span><span class=\"o\">:</span><span class=\"n\">optDeriving</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">names</span><span class=\"o\">,</span> <span class=\"n\">values</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">split</span> <span class=\"n\">cases</span>\n  <span class=\"k\">let</span> <span class=\"n\">eIdent</span> <span class=\"o\">(</span><span class=\"n\">suffix</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdentFrom</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">e.getId</span> <span class=\"bp\">++</span> <span class=\"n\">suffix</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">otherIdent</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdent</span> <span class=\"bp\">`</span><span class=\"n\">other</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span>\n    <span class=\"kd\">inductive</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">ident</span>\n      <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">names</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">]</span><span class=\"bp\">*</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">otherIdent</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">∉</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">quote</span> <span class=\"n\">values.toList</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">$</span><span class=\"n\">e</span>\n      <span class=\"bp\">$</span><span class=\"n\">d</span><span class=\"o\">:</span><span class=\"n\">optDeriving</span>\n    <span class=\"kd\">def</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">e</span> <span class=\"bp\">→</span> <span class=\"bp\">$</span><span class=\"n\">ty</span>\n      <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">names</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">values</span><span class=\"o\">]</span><span class=\"bp\">*</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">otherIdent</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n    <span class=\"kd\">def</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">ofVal</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">e</span> <span class=\"o\">:=</span>\n      <span class=\"k\">match</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"k\">with</span>\n      <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">values</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">names</span><span class=\"o\">]</span><span class=\"bp\">*</span>\n      <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">otherIdent</span> <span class=\"n\">n</span> <span class=\"gr\">sorry</span>\n  <span class=\"o\">)</span>\n\n<span class=\"n\">enum</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">two</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span><span class=\"o\">,</span> <span class=\"n\">BEq</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">E</span>\n<span class=\"k\">#print</span> <span class=\"n\">E.val</span>\n<span class=\"k\">#print</span> <span class=\"n\">E.ofVal</span>\n</code></pre></div>\n</div></div>\n<p>Notably, I've removed the proofs, because I'm too lazy to figure them out. But I bet that's something you'll figure out.<br>\nAlso, there's a <code>sorry</code> which should be a proof that the value appearing in <code>other</code> is not one of the other constructors' values. I'm not sure how to get that info in a match statement. I was kind of expecting the hypothesis <code>h</code> to contain that info.</p>",
        "id": 433817949,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1713367992
    },
    {
        "content": "<p>Often <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.toExpr#doc\">docs#Lean.toExpr</a> is a better choice than <code>Lean.quote</code></p>",
        "id": 433818054,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713368031
    },
    {
        "content": "<p>(with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Expr.toSyntax#doc\">docs#Expr.toSyntax</a>)</p>",
        "id": 433818115,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713368043
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/concise.20enum-with-values.20type/near/433818054\">said</a>:</p>\n<blockquote>\n<p>Often <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.toExpr#doc\">docs#Lean.toExpr</a> is a better choice than <code>Lean.quote</code></p>\n</blockquote>\n<p>Why is that?</p>",
        "id": 433818398,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1713368133
    },
    {
        "content": "<p>There are more <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.ToExpr#doc\">docs#Lean.ToExpr</a> instances than <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Quote#doc\">docs#Lean.Quote</a></p>",
        "id": 433818571,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713368179
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"372804\">@Marcus Rossel</span> and <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>.</p>\n<p><span class=\"user-mention\" data-user-id=\"372804\">@Marcus Rossel</span>, I also find it odd that the match statement doesn't have a hypothesis about <code>n</code> not being a previous value. Perhaps there's a more verbose form of match that captures this. Either way, here's what I've been doing instead. It's a bit more annoying for downstream proofs but it seems fine.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">E.ofValX</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">E2</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"n\">n</span> <span class=\"k\">then</span>\n    <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">E.one</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">E.two</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">E.other</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 433820239,
        "sender_full_name": "Daniel Windham",
        "timestamp": 1713368704
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"662442\">@Daniel Windham</span> Nice! Here's an updated version of the macro then:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Macro</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Parser</span> <span class=\"n\">Command</span>\n\n<span class=\"n\">declare_syntax_cat</span> <span class=\"n\">enum_case</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"| \"</span> <span class=\"n\">ident</span> <span class=\"s2\">\" := \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">enum_case</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">split</span> <span class=\"o\">(</span><span class=\"n\">cases</span> <span class=\"o\">:</span> <span class=\"n\">TSyntaxArray</span> <span class=\"bp\">`</span><span class=\"n\">enum_case</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MacroM</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">Ident</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">cases.foldlM</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">#</span><span class=\"o\">[],</span> <span class=\"bp\">#</span><span class=\"o\">[]))</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">names</span><span class=\"o\">,</span> <span class=\"n\">values</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">enum_case</span><span class=\"bp\">|</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n      <span class=\"k\">if</span> <span class=\"n\">name.getId</span> <span class=\"bp\">==</span> <span class=\"bp\">`</span><span class=\"n\">other</span> <span class=\"k\">then</span> <span class=\"n\">Macro.throwErrorAt</span> <span class=\"n\">name</span> <span class=\"s2\">\"enum cases cannot be called 'other'\"</span>\n      <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">names.push</span> <span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">values.push</span> <span class=\"n\">value</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">unreachable</span><span class=\"bp\">!</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"enum\"</span> <span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"s2\">\" : \"</span> <span class=\"n\">ty</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"s2\">\" where\"</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"n\">cases</span><span class=\"o\">:</span><span class=\"n\">enum_case</span><span class=\"bp\">*</span> <span class=\"n\">d</span><span class=\"o\">:</span><span class=\"n\">optDeriving</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">names</span><span class=\"o\">,</span> <span class=\"n\">values</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">split</span> <span class=\"n\">cases</span>\n  <span class=\"k\">let</span> <span class=\"n\">eIdent</span> <span class=\"o\">(</span><span class=\"n\">suffix</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdentFrom</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">e.getId</span> <span class=\"bp\">++</span> <span class=\"n\">suffix</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">otherIdent</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdent</span> <span class=\"bp\">`</span><span class=\"n\">other</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span>\n    <span class=\"kd\">inductive</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">ident</span>\n      <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">names</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">]</span><span class=\"bp\">*</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">otherIdent</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">∉</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">quote</span> <span class=\"n\">values.toList</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">$</span><span class=\"n\">e</span>\n      <span class=\"bp\">$</span><span class=\"n\">d</span><span class=\"o\">:</span><span class=\"n\">optDeriving</span>\n    <span class=\"kd\">def</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">e</span> <span class=\"bp\">→</span> <span class=\"bp\">$</span><span class=\"n\">ty</span>\n      <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">names</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">values</span><span class=\"o\">]</span><span class=\"bp\">*</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">otherIdent</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n    <span class=\"kd\">def</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">ofVal</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">e</span> <span class=\"o\">:=</span>\n      <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">quote</span> <span class=\"n\">values.toList</span><span class=\"o\">)</span>\n      <span class=\"k\">then</span> <span class=\"k\">match</span> <span class=\"n\">v</span> <span class=\"k\">with</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">values</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">names</span><span class=\"o\">]</span><span class=\"bp\">*</span>\n      <span class=\"k\">else</span> <span class=\"bp\">$</span><span class=\"n\">otherIdent</span> <span class=\"n\">v</span> <span class=\"n\">h</span>\n  <span class=\"o\">)</span>\n\n<span class=\"n\">enum</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">two</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span><span class=\"o\">,</span> <span class=\"n\">BEq</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">E</span>\n<span class=\"k\">#print</span> <span class=\"n\">E.val</span>\n<span class=\"k\">#print</span> <span class=\"n\">E.ofVal</span>\n</code></pre></div>\n</div></div>",
        "id": 433821764,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1713369148
    },
    {
        "content": "<p><span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 433822934,
        "sender_full_name": "Daniel Windham",
        "timestamp": 1713369493
    },
    {
        "content": "<p>For the basic case of enums, my macro works great.</p>\n<p>But I'm struggling to write a more general macro where each constructor in the generated inductive type declaration is specified in one of two different patterns depending on its input data.</p>\n<p>Here's an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">enum</span> <span class=\"n\">MyEnum</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">small</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">5</span>\n  <span class=\"bp\">|</span> <span class=\"n\">five</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">5</span>\n  <span class=\"bp\">|</span> <span class=\"n\">big</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"mi\">5</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>should produce:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">MyEnum</span>\n  <span class=\"bp\">|</span> <span class=\"n\">one</span>\n  <span class=\"bp\">|</span> <span class=\"n\">small</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">5</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">five</span>\n  <span class=\"bp\">|</span> <span class=\"n\">big</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"mi\">5</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>If none of the constructors had arguments, this would just be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">inductive</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">names</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">]</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>If all of the constructors had arguments, this would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">inductive</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">names</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">conditions</span><span class=\"o\">)]</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>How can I generalize this to allow a mix of constructors with and without arguments, in any order?</p>",
        "id": 434602654,
        "sender_full_name": "Daniel Windham",
        "timestamp": 1713717824
    },
    {
        "content": "<p>I think what I would do is to write the constructors in the form <code>| name : α → β → ... → MyEnum</code>. Then whenever there are no parameters you just omit the <code>α → β → ... →</code> part.</p>",
        "id": 434817181,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1713809817
    },
    {
        "content": "<p>Hmm - I think I'm missing something obvious here. <span class=\"user-mention\" data-user-id=\"372804\">@Marcus Rossel</span> that approach seems reasonable, but I don't know how to implement it.</p>\n<p>Specifically, I can't figure out how to do either of the following:<br>\n(a) construct a <code>TSyntax `term</code> from a type. For instance, <code>let t : TSyntax `term := Lean.quote Nat</code> fails<br>\n(b) inline conditional logic within a <code> `(...)</code> expression, e.g. something like <code>`(... | $names : $(if $params then `($params → ) ) MyEnum</code></p>\n<p>For (a), is there a way to construct a syntax term with <code>`(...)</code>? Perhaps something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"n\">MacroM</span> <span class=\"o\">(</span><span class=\"n\">TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">...</span><span class=\"o\">)</span>\n<span class=\"k\">let</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">term</span> <span class=\"o\">:=</span> <span class=\"n\">someFn</span> <span class=\"n\">t</span>\n</code></pre></div>",
        "id": 434832198,
        "sender_full_name": "Daniel Windham",
        "timestamp": 1713814880
    },
    {
        "content": "<p>Ah - <code>let u : TSyntax `term &lt;- `(...)</code> does the trick.</p>\n<p>If there's a way to do inline conditional logic within a <code>`(...)</code> expression, that would still be good to know.</p>\n<p>Thanks!</p>",
        "id": 434850038,
        "sender_full_name": "Daniel Windham",
        "timestamp": 1713821380
    },
    {
        "content": "<p>You can, <code> ← if x then `(foo) else `(bar)</code></p>",
        "id": 434924904,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713858718
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> , that's an example of inlining <code> `(...)</code> expressions within a condition. Is there a way to inline conditions within a <code> `(...)</code> expression? Otherwise for a large <code> `(...)</code> expression, all conditional logic needs to be constructed out of context in a bunch of prior variables, which makes for messy code.</p>",
        "id": 434969141,
        "sender_full_name": "Daniel Windham",
        "timestamp": 1713873915
    },
    {
        "content": "<p>If you have an optional syntax object <code>o</code>, then its antiquotation syntax is <code>$[$o]?</code>. This is similar to how <code>$[...]*</code> is used for arrays/lists of syntax. I don't think there's anything specific for conditional expressions.</p>",
        "id": 434970736,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1713874486
    },
    {
        "content": "<p>What I was suggesting earlier was therefore to basically do all of the syntax computation beforehand. Given the enum entries, construct the lists <code>names</code> and <code>ctorTypes</code> where <code>ctorTypes[i]</code> is <code>MyEnum</code> when the case has no range and <code>(n : Nat) -&gt; (_ &lt; _ &lt; _) -&gt; MyEnum</code> when it <em>does</em> have a range. Then you can just use the regular syntax:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">inductive</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">names</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">ctorTypes</span><span class=\"o\">]</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 434971707,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1713874808
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"372804\">@Marcus Rossel</span> thank you, I have that working now! Too bad about having to do all the syntax computation beforehand, but at least I can do what I need =]</p>",
        "id": 434972291,
        "sender_full_name": "Daniel Windham",
        "timestamp": 1713875011
    },
    {
        "content": "<p>Would you mind posting your complete macro here? I'd be interested to see how it works :)</p>",
        "id": 434972559,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1713875102
    },
    {
        "content": "<p>Sure - I haven't put the full pieces together yet but I will post here and tag you when I do!</p>",
        "id": 434972655,
        "sender_full_name": "Daniel Windham",
        "timestamp": 1713875141
    },
    {
        "content": "<p>Out of curiosity, what is the syntax type for a constructor case within an inductive declaration? Is this something Lean supports?</p>\n<p>I could keep the code more organized if I was able to do something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mkConstructor</span> <span class=\"o\">(</span><span class=\"bp\">...</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">constructor</span> <span class=\"o\">:=</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"bp\">...</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n        <span class=\"bp\">&lt;-</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">constructor</span><span class=\"bp\">|</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">name</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">)</span><span class=\"bp\">`</span>\n    <span class=\"k\">else</span>\n        <span class=\"bp\">&lt;-</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">constructor</span><span class=\"bp\">|</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">name</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">_</span><span class=\"o\">))</span><span class=\"bp\">`</span>\n\n<span class=\"k\">let</span> <span class=\"n\">constructors</span> <span class=\"o\">:=</span> <span class=\"n\">data.map</span> <span class=\"n\">mkConstructor</span>\n<span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">inductive</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">constructors</span><span class=\"o\">]</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 434973658,
        "sender_full_name": "Daniel Windham",
        "timestamp": 1713875440
    },
    {
        "content": "<p>Here's the complete syntax for inductive types: <a href=\"https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Command.lean#L161\">https://github.com/leanprover/lean4/blob/6fce8f7d5cd18a4419bca7fd51780c71c9b1cc5a/src/Lean/Parser/Command.lean#L161</a></p>\n<p>So you either want <code>ctor</code> or <code>optDeclSig</code>.</p>",
        "id": 434985283,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1713878894
    },
    {
        "content": "<p>Ah perfect, thanks! I saw that before and couldn't get it working. This works though:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">ctor</span><span class=\"bp\">|</span> <span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">inductive</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"n\">where</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 434987742,
        "sender_full_name": "Daniel Windham",
        "timestamp": 1713879585
    },
    {
        "content": "<p>For conditional splices/antiquotations, something like this seems to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">let</span> <span class=\"n\">cond</span>  <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"bp\">|</span> <span class=\"kd\">def</span> <span class=\"n\">x</span><span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"k\">if</span> <span class=\"n\">true</span> <span class=\"k\">then</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">)))</span>\n</code></pre></div>",
        "id": 434988881,
        "sender_full_name": "Graham Leach-Krouse",
        "timestamp": 1713879911
    },
    {
        "content": "<p>Nice!</p>",
        "id": 434998422,
        "sender_full_name": "Daniel Windham",
        "timestamp": 1713882635
    },
    {
        "content": "<p>I think that's exactly what <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> was suggesting <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 435016831,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1713887956
    },
    {
        "content": "<p>Ah oops! The <code>$(...)</code> syntax was new to me</p>",
        "id": 435017269,
        "sender_full_name": "Daniel Windham",
        "timestamp": 1713888089
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"372804\">@Marcus Rossel</span> / others, I finally got more time to work on this. Thanks again for all your help! Here's the result, starting with examples:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- can mix literal, guarded, and match-all values. comments are optional</span>\n<span class=\"n\">enum</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"sd\">/-- one -/</span>\n  <span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">small</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">4</span>\n  <span class=\"sd\">/-- four -/</span>\n  <span class=\"bp\">|</span> <span class=\"n\">four</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">4</span>\n  <span class=\"sd\">/-- other -/</span>\n  <span class=\"bp\">|</span> <span class=\"n\">other</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">E.four</span>\n<span class=\"k\">#eval</span> <span class=\"n\">E.ofVal</span> <span class=\"mi\">4</span>\n<span class=\"k\">#eval</span> <span class=\"n\">E.small</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">)</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">E.other</span> <span class=\"mi\">5</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">E.ofVal</span> <span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n\n<span class=\"c1\">-- proves round-trip identities for both ofVal ⬝ val and val ⬝ ofVal</span>\n<span class=\"k\">#check</span> <span class=\"n\">E.ofVal_val</span>\n<span class=\"k\">#check</span> <span class=\"n\">E.val_ofVal</span>\n\n<span class=\"c1\">-- works with types other than Nat</span>\n<span class=\"n\">enum</span> <span class=\"n\">FinEnum</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">two</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">FinEnum.zero.val</span>\n<span class=\"k\">#eval</span> <span class=\"n\">FinEnum.ofVal</span> <span class=\"mi\">0</span>\n\n<span class=\"c1\">-- adds a default case if it isn't given explicitly</span>\n<span class=\"n\">enum</span> <span class=\"n\">ImplicitDefault</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">two</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">ImplicitDefault.default</span> <span class=\"mi\">5</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">)</span>\n<span class=\"k\">#eval</span> <span class=\"n\">ImplicitDefault.ofVal</span> <span class=\"mi\">5</span>\n</code></pre></div>\n<p>Here's (approximately) what the macro generates for the first example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">E</span>\n  <span class=\"bp\">|</span> <span class=\"n\">one</span>\n  <span class=\"bp\">|</span> <span class=\"n\">small</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n  <span class=\"bp\">|</span> <span class=\"n\">four</span>\n  <span class=\"bp\">|</span> <span class=\"n\">other</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">))</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">BEq</span><span class=\"o\">,</span> <span class=\"n\">Inhabited</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Repr</span> <span class=\"n\">E</span> <span class=\"n\">where</span>\n  <span class=\"n\">reprPrec</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">e</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">one</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"one\"</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">small</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"small {n}\"</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">four</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"four\"</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">other</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"other {n}\"</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">E.val</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">E.one</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">E.small</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"n\">E.four</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">4</span>\n  <span class=\"bp\">|</span> <span class=\"n\">E.other</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">E.ofVal</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">if</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"k\">then</span> <span class=\"bp\">.</span><span class=\"n\">one</span> <span class=\"k\">else</span>\n  <span class=\"k\">if</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">4</span> <span class=\"k\">then</span> <span class=\"bp\">.</span><span class=\"n\">small</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">omega</span><span class=\"o\">)</span> <span class=\"k\">else</span>\n  <span class=\"k\">if</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"k\">then</span> <span class=\"bp\">.</span><span class=\"n\">four</span> <span class=\"k\">else</span>\n  <span class=\"k\">if</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"k\">then</span> <span class=\"bp\">.</span><span class=\"n\">other</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">omega</span><span class=\"o\">)</span> <span class=\"k\">else</span>\n  <span class=\"n\">unreachable</span><span class=\"bp\">!</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">E.ofVal_val</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">E.ofVal</span> <span class=\"o\">(</span><span class=\"n\">E.val</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">e</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">try</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">all_goals</span> <span class=\"n\">rename</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">E.val</span><span class=\"o\">,</span> <span class=\"n\">E.ofVal</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">E.val_ofVal</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">E.val</span> <span class=\"o\">(</span><span class=\"n\">E.ofVal</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">E.ofVal</span>\n  <span class=\"n\">repeat</span> <span class=\"n\">split</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">E.val</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">E.val</span><span class=\"o\">]</span>\n  <span class=\"n\">contradiction</span>\n</code></pre></div>\n<p>And finally, here's the macro:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Parser</span> <span class=\"n\">Command</span> <span class=\"n\">Syntax</span>\n\n<span class=\"n\">declare_syntax_cat</span> <span class=\"n\">enum_case</span>\n<span class=\"n\">syntax</span> <span class=\"n\">atomic</span><span class=\"o\">((</span><span class=\"n\">docComment</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"s2\">\" | \"</span> <span class=\"n\">ident</span> <span class=\"s2\">\" =&gt; \"</span> <span class=\"n\">ident</span> <span class=\"s2\">\", \"</span> <span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">enum_case</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">docComment</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"s2\">\" | \"</span> <span class=\"n\">ident</span> <span class=\"s2\">\" =&gt; \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">enum_case</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">inductive</span> <span class=\"n\">EnumCaseValue</span>\n  <span class=\"bp\">|</span> <span class=\"n\">literalValue</span> <span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">Term</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">parametricValue</span> <span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">Ident</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cond</span> <span class=\"o\">:</span> <span class=\"n\">Term</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">structure</span> <span class=\"n\">EnumCaseParsed</span> <span class=\"n\">where</span>\n  <span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">Ident</span>\n  <span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">EnumCaseValue</span>\n  <span class=\"n\">comment</span> <span class=\"o\">:</span> <span class=\"n\">Lean.TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Command.docComment</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">makeComment</span> <span class=\"o\">(</span><span class=\"n\">comment</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Lean.TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Command.docComment</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">commentLeader</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Syntax</span> <span class=\"o\">:=</span> <span class=\"n\">Lean.Syntax.atom</span> <span class=\"n\">SourceInfo.none</span> <span class=\"s2\">\"/--\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">commentBody</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Syntax</span> <span class=\"o\">:=</span> <span class=\"n\">Lean.Syntax.atom</span> <span class=\"n\">SourceInfo.none</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{comment} -/\"</span>\n  <span class=\"n\">Lean.TSyntax.mk</span> <span class=\"bp\">$</span> <span class=\"n\">Lean.Syntax.node</span> <span class=\"n\">SourceInfo.none</span> <span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Command.docComment</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">commentLeader</span><span class=\"o\">,</span> <span class=\"n\">commentBody</span><span class=\"o\">]</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">parseCase</span> <span class=\"o\">(</span><span class=\"n\">case</span> <span class=\"o\">:</span> <span class=\"n\">TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">enum_case</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">EnumCaseParsed</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">case</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">enum_case</span><span class=\"bp\">|</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">name</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">literalValue</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"n\">emptyComment</span><span class=\"o\">⟩</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">enum_case</span><span class=\"bp\">|</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">name</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">cond</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">parametricValue</span> <span class=\"n\">value</span> <span class=\"n\">cond</span><span class=\"o\">,</span> <span class=\"n\">emptyComment</span><span class=\"o\">⟩</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">enum_case</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">comment</span><span class=\"o\">:</span><span class=\"n\">docComment</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">name</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">literalValue</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"n\">comment</span><span class=\"o\">⟩</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">enum_case</span><span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">comment</span><span class=\"o\">:</span><span class=\"n\">docComment</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">name</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">cond</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">parametricValue</span> <span class=\"n\">value</span> <span class=\"n\">cond</span><span class=\"o\">,</span> <span class=\"n\">comment</span><span class=\"o\">⟩</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">unreachable</span><span class=\"bp\">!</span>\n  <span class=\"n\">where</span> <span class=\"n\">emptyComment</span> <span class=\"o\">:=</span> <span class=\"n\">makeComment</span> <span class=\"s2\">\"undocumented\"</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">parseCases</span> <span class=\"o\">(</span><span class=\"n\">cases</span> <span class=\"o\">:</span> <span class=\"n\">TSyntaxArray</span> <span class=\"bp\">`</span><span class=\"n\">enum_case</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">EnumCaseParsed</span> <span class=\"o\">:=</span>\n  <span class=\"n\">cases.foldl</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">#</span><span class=\"o\">[]))</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">parsedCases</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">case</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">parsedCases.push</span> <span class=\"o\">(</span><span class=\"n\">parseCase</span> <span class=\"n\">case</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- TODO: prove termination.</span>\n<span class=\"c1\">-- Warning: this is not performant if there are many name collisions.</span>\n<span class=\"kn\">private</span> <span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">getUniqueName</span> <span class=\"o\">(</span><span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">names</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">loop</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">base</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"bp\">==</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"s2\">\"\"</span> <span class=\"k\">else</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"_{i}\"</span><span class=\"o\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">name</span> <span class=\"bp\">∈</span> <span class=\"n\">names</span> <span class=\"k\">then</span> <span class=\"n\">loop</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">name</span>\n  <span class=\"n\">loop</span> <span class=\"mi\">0</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">addCaseDefaults</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Ident</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cases</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">EnumCaseParsed</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MacroM</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">EnumCaseParsed</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"c1\">-- Allow the final case to omit the true condition.</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"n\">comment</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">cases.back</span>\n  <span class=\"k\">let</span> <span class=\"n\">trueValue</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">true</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">defaultValue</span> <span class=\"o\">:=</span> <span class=\"n\">EnumCaseValue.parametricValue</span> <span class=\"n\">n</span> <span class=\"n\">trueValue</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">cases</span><span class=\"o\">,</span> <span class=\"n\">lastValue</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">value</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">literalValue</span> <span class=\"n\">v</span>      <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">if</span> <span class=\"n\">v</span> <span class=\"bp\">==</span> <span class=\"n\">n</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"n\">cases.pop.push</span> <span class=\"o\">⟨</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">defaultValue</span><span class=\"o\">,</span> <span class=\"n\">comment</span><span class=\"o\">⟩,</span> <span class=\"n\">defaultValue</span><span class=\"o\">)</span>\n      <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">cases</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">parametricValue</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">cases</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">)</span>\n\n  <span class=\"c1\">-- Append a default case if the final case is not a catch-all.</span>\n  <span class=\"k\">let</span> <span class=\"n\">names</span> <span class=\"o\">:=</span> <span class=\"n\">cases.map</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">name.getId.toString</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">addDefaultCase</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Ident</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cases</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">EnumCaseParsed</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">EnumCaseParsed</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"n\">defaultName</span><span class=\"o\">:</span> <span class=\"n\">Ident</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdentFrom</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">getUniqueName</span> <span class=\"s2\">\"default\"</span> <span class=\"n\">names.toList</span><span class=\"o\">)</span>\n    <span class=\"n\">cases.push</span> <span class=\"o\">⟨</span><span class=\"n\">defaultName</span><span class=\"o\">,</span> <span class=\"n\">defaultValue</span><span class=\"o\">,</span> <span class=\"n\">makeComment</span> <span class=\"s2\">\"default case\"</span><span class=\"o\">⟩</span>\n  <span class=\"k\">let</span> <span class=\"n\">cases</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">lastValue</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">literalValue</span> <span class=\"n\">_</span>      <span class=\"bp\">=&gt;</span> <span class=\"n\">addDefaultCase</span> <span class=\"n\">n</span> <span class=\"n\">cases</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">parametricValue</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"bp\">==</span> <span class=\"n\">trueValue</span> <span class=\"k\">then</span> <span class=\"n\">cases</span> <span class=\"k\">else</span> <span class=\"n\">addDefaultCase</span> <span class=\"n\">n</span> <span class=\"n\">cases</span>\n\n  <span class=\"n\">pure</span> <span class=\"n\">cases</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">validateCases</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Ident</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cases</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">EnumCaseParsed</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MacroM</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"c1\">-- validate that parametric values use the same name as the enum value</span>\n  <span class=\"n\">for</span> <span class=\"n\">case</span> <span class=\"k\">in</span> <span class=\"n\">cases</span> <span class=\"k\">do</span>\n    <span class=\"k\">match</span> <span class=\"n\">case.value</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">literalValue</span> <span class=\"n\">_</span>      <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">parametricValue</span> <span class=\"n\">v</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">v</span> <span class=\"bp\">!=</span> <span class=\"n\">n</span> <span class=\"k\">then</span>\n        <span class=\"n\">Macro.throwErrorAt</span> <span class=\"n\">v</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"parametric value {v.getId.toString} must match the enum parameter {n.getId.toString}\"</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">Make the constructor types for the inductive type that an enum desugars to.</span>\n<span class=\"cm\">Constructors for non-literal cases bind to a value and a proof that the value is</span>\n<span class=\"cm\">in the case's range. A case's range is limited by both its local condition and</span>\n<span class=\"cm\">the conditions of all previous cases (since cases are matched greedily). The net</span>\n<span class=\"cm\">restriction on a case is the conjunction of its local restriction and the</span>\n<span class=\"cm\">negations of all prior restrictions. A literal constructor's implied restriction</span>\n<span class=\"cm\">is that of equality with its literal value.</span>\n\n<span class=\"cm\">To make these constructor types, we fold over the cases, building the</span>\n<span class=\"cm\">constructor type for each case and the net restriction after that case.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">mkCtorTypes</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Ident</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ty</span> <span class=\"o\">:</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">parsedCases</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">EnumCaseParsed</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MacroM</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mkCtorTypeAndCarriedRestrictions</span> <span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">EnumCaseValue</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">priorRestrictions</span> <span class=\"o\">:</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MacroM</span> <span class=\"o\">(</span><span class=\"n\">Term</span> <span class=\"bp\">×</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">thisType</span> <span class=\"bp\">←</span> <span class=\"k\">match</span> <span class=\"n\">value</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">literalValue</span> <span class=\"n\">_</span>      <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">)</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">parametricValue</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">((</span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">h</span> <span class=\"bp\">∧</span> <span class=\"bp\">$</span><span class=\"n\">priorRestrictions</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">netRestrictions</span> <span class=\"bp\">←</span> <span class=\"k\">match</span> <span class=\"n\">value</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">literalValue</span> <span class=\"n\">v</span>      <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">=</span> <span class=\"bp\">$</span><span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"bp\">$</span><span class=\"n\">priorRestrictions</span><span class=\"o\">)</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">parametricValue</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"bp\">$</span><span class=\"n\">priorRestrictions</span><span class=\"o\">)</span>\n    <span class=\"n\">pure</span> <span class=\"o\">⟨</span><span class=\"n\">thisType</span><span class=\"o\">,</span> <span class=\"n\">netRestrictions</span><span class=\"o\">⟩</span>\n\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">ctorTypes</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">←</span> <span class=\"n\">parsedCases.foldlM</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">#</span><span class=\"o\">[],</span> <span class=\"bp\">←`</span><span class=\"o\">(</span><span class=\"n\">true</span><span class=\"o\">)))</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">valuesAcc</span><span class=\"o\">,</span> <span class=\"n\">restrictions</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">case</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">thisType</span><span class=\"o\">,</span> <span class=\"n\">netRestrictions</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mkCtorTypeAndCarriedRestrictions</span> <span class=\"n\">case.value</span> <span class=\"n\">restrictions</span>\n    <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">valuesAcc.push</span> <span class=\"n\">thisType</span><span class=\"o\">,</span> <span class=\"n\">netRestrictions</span><span class=\"o\">)</span>\n\n  <span class=\"n\">pure</span> <span class=\"n\">ctorTypes</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">The `enum` macro defines an enumeration type over a base type. The enumeration</span>\n<span class=\"sd\">type defines cases that partition the base type. Each case is associated with a</span>\n<span class=\"sd\">literal value or a guard condition on values. Cases are matched greedily.</span>\n\n<span class=\"sd\">An enum type defines constructors for each of its cases. Constructors for</span>\n<span class=\"sd\">guarded types take a value and a proof that the value is in the case's range. An</span>\n<span class=\"sd\">enum type also defines functions to convert between the enum type and values of</span>\n<span class=\"sd\">the base type, and defines proofs that a round-trip in either direction between</span>\n<span class=\"sd\">a value of the base type and its corresponding enum value is the identity.</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">macro</span> <span class=\"s2\">\"enum\"</span> <span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"s2\">\"(\"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"s2\">\" : \"</span> <span class=\"n\">ty</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\")\"</span> <span class=\"o\">(</span><span class=\"s2\">\" where\"</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"n\">cases</span><span class=\"o\">:</span><span class=\"n\">enum_case</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"c1\">-- Must have at least one case. Don't enforce this in the syntax parser since</span>\n  <span class=\"c1\">-- it's easier to give a good error message here.</span>\n  <span class=\"k\">if</span> <span class=\"n\">cases.size</span> <span class=\"bp\">==</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">Macro.throwErrorAt</span> <span class=\"n\">e</span> <span class=\"s2\">\"enum must have at least one case\"</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">eIdent</span> <span class=\"o\">(</span><span class=\"n\">suffix</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdentFrom</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">e.getId</span> <span class=\"bp\">++</span> <span class=\"n\">suffix</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">toStrLit</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Lean.Syntax.mkStrLit</span> <span class=\"n\">n.toString</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">rawParsedCases</span> <span class=\"o\">:=</span> <span class=\"n\">parseCases</span> <span class=\"n\">cases</span>\n  <span class=\"k\">let</span> <span class=\"n\">parsedCases</span> <span class=\"bp\">←</span> <span class=\"n\">addCaseDefaults</span> <span class=\"n\">n</span> <span class=\"n\">rawParsedCases</span>\n  <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"bp\">←</span> <span class=\"n\">validateCases</span> <span class=\"n\">n</span> <span class=\"n\">parsedCases</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">comments</span> <span class=\"o\">:=</span> <span class=\"n\">parsedCases.map</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">comment</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">names</span> <span class=\"o\">:=</span> <span class=\"n\">parsedCases.map</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">name</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">ctorTypes</span> <span class=\"bp\">←</span> <span class=\"n\">mkCtorTypes</span> <span class=\"n\">e</span> <span class=\"n\">n</span> <span class=\"n\">ty</span> <span class=\"n\">parsedCases</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">reprCases</span> <span class=\"bp\">←</span> <span class=\"n\">parsedCases.mapM</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"k\">match</span> <span class=\"n\">value</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">literalValue</span> <span class=\"n\">_</span>      <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Term.matchAltExpr</span><span class=\"bp\">|</span> <span class=\"bp\">|</span> <span class=\"bp\">.$</span><span class=\"n\">name</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">toStrLit</span> <span class=\"n\">name.getId</span><span class=\"o\">))</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">parametricValue</span> <span class=\"n\">v</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Term.matchAltExpr</span><span class=\"bp\">|</span> <span class=\"bp\">|</span> <span class=\"bp\">.$</span><span class=\"n\">name</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"n\">v</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"{$(toStrLit name.getId)} {$v}\"</span><span class=\"o\">)</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">valCases</span> <span class=\"bp\">←</span> <span class=\"n\">parsedCases.mapM</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"k\">match</span> <span class=\"n\">value</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">literalValue</span> <span class=\"n\">v</span>      <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Term.matchAltExpr</span><span class=\"bp\">|</span> <span class=\"bp\">|</span> <span class=\"bp\">.$</span><span class=\"n\">name</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">v</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">parametricValue</span> <span class=\"n\">v</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Term.matchAltExpr</span><span class=\"bp\">|</span> <span class=\"bp\">|</span> <span class=\"bp\">.$</span><span class=\"n\">name</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"n\">v</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">v</span><span class=\"o\">)</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">ofValCases</span><span class=\"o\">:</span> <span class=\"n\">Term</span> <span class=\"bp\">←</span> <span class=\"n\">parsedCases.reverse.foldlM</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"bp\">←`</span><span class=\"o\">(</span><span class=\"n\">unreachable</span><span class=\"bp\">!</span><span class=\"o\">))</span> <span class=\"k\">fun</span> <span class=\"n\">res</span> <span class=\"n\">case</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">case</span>\n    <span class=\"k\">match</span> <span class=\"n\">value</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">literalValue</span> <span class=\"n\">v</span>      <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"bp\">$</span><span class=\"n\">v</span> <span class=\"k\">then</span> <span class=\"bp\">.$</span><span class=\"n\">name</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"k\">else</span> <span class=\"bp\">$</span><span class=\"n\">res</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">parametricValue</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">h</span> <span class=\"k\">then</span> <span class=\"bp\">.$</span><span class=\"n\">name</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">omega</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"bp\">$</span><span class=\"n\">res</span><span class=\"o\">)</span>\n\n  <span class=\"bp\">`</span><span class=\"o\">(</span>\n    <span class=\"kd\">inductive</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">ident</span>\n      <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">comments</span><span class=\"o\">:</span><span class=\"n\">docComment</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">names</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">ctorTypes</span><span class=\"o\">]</span><span class=\"bp\">*</span>\n      <span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span><span class=\"o\">,</span> <span class=\"n\">BEq</span>\n    <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Repr</span> <span class=\"bp\">$</span><span class=\"n\">e</span> <span class=\"n\">where</span> <span class=\"n\">reprPrec</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">e</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span> <span class=\"bp\">$</span><span class=\"n\">reprCases</span><span class=\"o\">:</span><span class=\"n\">matchAlt</span><span class=\"bp\">*</span>\n\n    <span class=\"kd\">def</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">e</span> <span class=\"bp\">→</span> <span class=\"bp\">$</span><span class=\"n\">ty</span> <span class=\"bp\">$</span><span class=\"n\">valCases</span><span class=\"o\">:</span><span class=\"n\">matchAlt</span><span class=\"bp\">*</span>\n\n    <span class=\"kd\">def</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">ofVal</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span> <span class=\"bp\">→</span> <span class=\"bp\">$</span><span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">ofValCases</span>\n\n    <span class=\"kd\">theorem</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">ofVal_val</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">ofVal</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">cases</span> <span class=\"n\">e</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">try</span> <span class=\"n\">rfl</span>\n      <span class=\"n\">all_goals</span> <span class=\"n\">rename</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">val</span><span class=\"o\">):</span> <span class=\"n\">ident</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">ofVal</span><span class=\"o\">):</span> <span class=\"n\">ident</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n\n    <span class=\"kd\">theorem</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">val_ofVal</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">ofVal</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">unfold</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">ofVal</span><span class=\"o\">)</span>\n      <span class=\"n\">repeat</span> <span class=\"n\">split</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">val</span><span class=\"o\">):</span> <span class=\"n\">ident</span><span class=\"o\">]</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">eIdent</span> <span class=\"bp\">`</span><span class=\"n\">val</span><span class=\"o\">):</span> <span class=\"n\">ident</span><span class=\"o\">]</span>\n      <span class=\"n\">contradiction</span>\n  <span class=\"o\">)</span>\n</code></pre></div>",
        "id": 437651050,
        "sender_full_name": "Daniel Windham",
        "timestamp": 1715174931
    }
]