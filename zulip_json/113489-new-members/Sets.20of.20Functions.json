[
    {
        "content": "<p>For some proof I need to define sets of functions, but in this little example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test_set</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test_fun</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">test_fun</span> <span class=\"bp\">∈</span> <span class=\"n\">test_set</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">test_set</span><span class=\"o\">,</span> <span class=\"n\">mem_setOf</span><span class=\"o\">]</span>\n  <span class=\"n\">use</span> <span class=\"n\">test_fun</span>\n</code></pre></div>\n<p>I get the following error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">don't</span> <span class=\"n\">know</span> <span class=\"n\">how</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">implicit</span> <span class=\"n\">argument</span>\n  <span class=\"bp\">@</span><span class=\"n\">test_fun</span> <span class=\"bp\">?</span><span class=\"n\">m.187</span> <span class=\"bp\">?</span><span class=\"n\">m.188</span>\n<span class=\"n\">context</span><span class=\"o\">:</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">Set</span> <span class=\"bp\">?</span><span class=\"n\">m.187</span>\n<span class=\"n\">when</span> <span class=\"n\">the</span> <span class=\"n\">resulting</span> <span class=\"n\">type</span> <span class=\"n\">of</span> <span class=\"n\">a</span> <span class=\"n\">declaration</span> <span class=\"n\">is</span> <span class=\"n\">explicitly</span> <span class=\"n\">provided</span><span class=\"o\">,</span> <span class=\"n\">all</span> <span class=\"n\">holes</span> <span class=\"o\">(</span><span class=\"n\">e.g.</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">_</span><span class=\"bp\">`</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">the</span> <span class=\"n\">header</span> <span class=\"n\">are</span> <span class=\"n\">resolved</span> <span class=\"n\">before</span> <span class=\"n\">the</span> <span class=\"n\">declaration</span> <span class=\"n\">body</span> <span class=\"n\">is</span> <span class=\"n\">processedLean</span> <span class=\"mi\">4</span>\n<span class=\"n\">don't</span> <span class=\"n\">know</span> <span class=\"n\">how</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">implicit</span> <span class=\"n\">argument</span>\n  <span class=\"bp\">@</span><span class=\"n\">test_fun</span> <span class=\"bp\">?</span><span class=\"n\">m.187</span> <span class=\"bp\">?</span><span class=\"n\">m.188</span>\n<span class=\"n\">context</span><span class=\"o\">:</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n</code></pre></div>\n<p>How can I fix this?</p>",
        "id": 427086429,
        "sender_full_name": "Philipp SL Schäfer",
        "timestamp": 1710673280
    },
    {
        "content": "<p>The problem here is that <code>test_set</code> has an implicit argument <code>X</code>which the elaborator of the <code>example</code> does not manage to fill in (that's what the <code>?m.113</code> indicates).</p>\n<p>Another problem is a question of understanding the principles of type theory. Your <code>test_set</code> is basically the “set” of all functions <code>X → ℕ</code>, in other words, it is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.univ#doc\">docs#Set.univ</a>. And you're willing to prove that for <code>f: X → ℕ</code>, one has <code>f ∈ Set.univ</code>. That is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.mem_univ#doc\">docs#Set.mem_univ</a>.</p>",
        "id": 427087590,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1710673585
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"690867\">@Philipp SL Schäfer</span>, if you fix the implicit argument problem <span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> told you about, your proof will work just fine. The point is that you can’t possibly expect Lean to guess the set <code>X</code> over which <code>test_set</code> and <code>test_fun</code> are defined. Keep in mind, they are both really functions. Look at the signature of <code>test_set.{u_1}: {α : Type u_1} (X : Set α) : Set (↑X → ℕ)</code> (as you can see by running <code>#check test_set</code> and <code>#check test_fun</code>). </p>\n<p>With the curly brackets you are telling Lean “I won’t pass this information to you explicitly, infer it from the context” but this is clearly impossible in your case.  You can solve it by making <code>X</code> explicit (then α can be inferred from <code>X</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">open</span> <span class=\"n\">Set</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test_set</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">test_fun</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"mi\">0</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">test_set</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">test_fun</span> <span class=\"n\">X</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">test_set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">test_set</span><span class=\"o\">,</span> <span class=\"n\">mem_setOf</span><span class=\"o\">]</span>\n  <span class=\"n\">use</span> <span class=\"n\">test_fun</span> <span class=\"n\">X</span>\n</code></pre></div>",
        "id": 427095288,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1710675634
    },
    {
        "content": "<p>Thanks a lot to both of you!</p>",
        "id": 427132972,
        "sender_full_name": "Philipp SL Schäfer",
        "timestamp": 1710685736
    },
    {
        "content": "<p>But I am still not sure how I can use this to proof that the power set exists for any set X, given the power set axiom:</p>\n<p>(Power set axiom). Let X and Y be sets. Then there exists a set denoted as Yˣ,<br>\nwhich consists of all the functions from X to Y, thus f ∈ Yˣ ↔ (f is a function with domain X and codomain Y)</p>\n<p>The idea for the proof is to start with the set {0, 1}ˣ and apply the replacement axiom, replacing each function f with the object f⁻¹({1}). With pen and paper, I get it, but I run into problems when defining the sets I need:</p>\n<p>1) How to resolve \"Problem 1: failed to synthesize instance OfNat (↑zero_one) 0\" better than to define the arbitrary function <code>to_zo</code>.</p>\n<p>2) How to best define the set <code>{f ⁻¹' ({1}) | f ∈ { f | f : X → {0, 1} } }</code></p>\n<p>This is what I have so far.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">SX</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">zero_one</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">n</span> <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pset</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">zero_one</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">zero_one</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- Problem 1: failed to synthesize instance OfNat (↑zero_one) 0</span>\n<span class=\"kd\">def</span> <span class=\"n\">zo_fun_bad</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">zero_one</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">zero_one</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Workaround? - define a function to explicitly convert natural numbers to zero_one</span>\n<span class=\"c1\">-- But this is not quite acurrate because #eval to_zo 3 returns 1</span>\n<span class=\"kd\">def</span> <span class=\"n\">to_zo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">zero_one</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"k\">else</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">Or.inr</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">zo_fun</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">zero_one</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">to_zo</span> <span class=\"mi\">0</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">pset</span>    <span class=\"c1\">-- pset.{u_1} {α : Type u_1} (X : Set α) : Set (↑X → ↑zero_one)</span>\n<span class=\"k\">#check</span> <span class=\"n\">pset</span> <span class=\"n\">X</span>  <span class=\"c1\">-- pset X : Set (↑X → ↑zero_one)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">zo_fun</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">pset</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">pset</span><span class=\"o\">,</span> <span class=\"n\">mem_setOf</span><span class=\"o\">]</span>\n  <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">zo_fun</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Define this set based on the replacement axiom as suggested</span>\n<span class=\"kd\">def</span> <span class=\"n\">set_1</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">({</span><span class=\"n\">to_zo</span> <span class=\"mi\">1</span><span class=\"o\">})</span> <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">pset</span> <span class=\"n\">X</span><span class=\"o\">)}</span>\n\n<span class=\"c1\">-- Define the power set</span>\n<span class=\"kd\">def</span> <span class=\"n\">set_2</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span> <span class=\"bp\">|</span> <span class=\"n\">y</span> <span class=\"bp\">⊆</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">set_1</span> <span class=\"n\">X</span>\n<span class=\"k\">#check</span> <span class=\"n\">set_2</span> <span class=\"n\">X</span> <span class=\"n\">SX</span>\n</code></pre></div>",
        "id": 427136128,
        "sender_full_name": "Philipp SL Schäfer",
        "timestamp": 1710686606
    },
    {
        "content": "<p>I would highly recommend you don't try to do set theory puzzles based on ZFC axioms</p>",
        "id": 427142204,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1710688280
    },
    {
        "content": "<p>Why?</p>",
        "id": 427148257,
        "sender_full_name": "Philipp SL Schäfer",
        "timestamp": 1710689823
    },
    {
        "content": "<p>because Lean isn't based on ZFC, so the first thing you would need to do is embed ZFC inside Lean's logic. See eg <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ZFSet#doc\">docs#ZFSet</a></p>",
        "id": 427148755,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710689958
    },
    {
        "content": "<p>Lean is based on type theory, not ZFC.  They are different.</p>\n<p>One thing you may be confused about is the difference between types and sets.  In the notation <code>Set X</code>, <code>X</code> should be a type, not a set.  In the notation <code>X → Y</code>, <code>X</code> and <code>Y</code> should be types, not sets.  So when you have <code>X : Set α</code>, you probably don't want to write <code>Set X</code> or <code>X → zero_one</code>; that doesn't mean what you seem to think it means.</p>\n<p>For example, you wrote:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">set_2</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span> <span class=\"bp\">|</span> <span class=\"n\">y</span> <span class=\"bp\">⊆</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>What would make more sense is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">set_2</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">y</span> <span class=\"bp\">⊆</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 427153075,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1710691115
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690867\">Philipp SL Schäfer</span> <a href=\"#narrow/stream/113489-new-members/topic/Sets.20of.20Functions/near/427148257\">said</a>:</p>\n<blockquote>\n<p>Why?</p>\n</blockquote>\n<p>The ZFC axioms are a minimal set of axioms from which one can elaborate the whole language of mathematics. But, as the exercises you are trying to do indicate, a lot of preliminary work is necessary, for example, to construct the set of functions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mspace></mspace><mspace width=\"0.1111em\"/><mo lspace=\"0em\" rspace=\"0.17em\"></mo><mtext> ⁣</mtext><mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333em\"/><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\"> f\\colon X\\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace nobreak\"></span><span class=\"mspace\" style=\"margin-right:0.1111em;\"></span><span class=\"mpunct\"></span><span class=\"mspace\" style=\"margin-right:-0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mrel\">:</span></span><span class=\"mspace\" style=\"margin-right:0.3333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> from various other sets which are already defined.</p>\n<p>Lean is built on another foundational system, type theory, which already contains all of these. If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\"> X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> are types, for example, the system already knows about the type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X\\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> which embodies functions from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>, and how it behaves, so there is no need of doing the kind of constructions required to start math from ZFC. Worse, these exercices would be very unnatural.</p>\n<p>However, two things can be done, and are already done in mathlib if I'm not mistaken.</p>\n<ul>\n<li>Construct a way to talk about another axiom system, its language and terms, using Lean as a metamathematical tool</li>\n<li>Embed the ZF theory of sets into Lean by constructing a type which satisfies the axioms. This is what <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ZFSet#doc\">docs#ZFSet</a> does.</li>\n</ul>",
        "id": 427155366,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1710691680
    },
    {
        "content": "<p>Thanks everyone! </p>\n<p>So how much sense does it generally make to use Lean to verify proofs for an introductory level course on real analysis (that is based on ZFC)? I am mainly doing it because I study alone (since I don't even study math); and Lean works perfectly to see if an idea for a proof works or not (if I manage to write it in Lean, which can fail in cases like this one).</p>",
        "id": 427224055,
        "sender_full_name": "Philipp SL Schäfer",
        "timestamp": 1710710221
    },
    {
        "content": "<p>Introductory level courses on real analysis are <em>not</em> based on ZFC or any other foundation.</p>",
        "id": 427225278,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1710710526
    },
    {
        "content": "<p>Usually the only part of real analysis that will touch on aspects of ZFC will be the appendix entitled \"construction of the real numbers\"</p>",
        "id": 427226871,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710710942
    },
    {
        "content": "<p>and even that can be pretty faithfully reconstructed in type theory if you just stop at <code>Nat</code> instead of building it out of ordinals</p>",
        "id": 427227002,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710710980
    },
    {
        "content": "<p>Okay so I am going through Analysis I by Terence Tao, and I thought it is based on ZFC (since all these axioms are introduced in chapter 3).</p>",
        "id": 427227256,
        "sender_full_name": "Philipp SL Schäfer",
        "timestamp": 1710711036
    },
    {
        "content": "<p>I think the point is more that you can just cross out the part that says \"we assume a foundation of ZFC\" or the like and the remainder of the book will be mostly unaffected</p>",
        "id": 427227549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710711119
    },
    {
        "content": "<p>most mathematics only pays lip-service to ZFC but doesn't use it in any nontrivial way</p>",
        "id": 427227672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710711151
    },
    {
        "content": "<p>Okay that would be perfect for my purposes! So roughly speaking naive set theory is probably sufficient for what I want to learn, and I can just assume that some set exists?</p>",
        "id": 427227677,
        "sender_full_name": "Philipp SL Schäfer",
        "timestamp": 1710711152
    },
    {
        "content": "<p>I would stop at the first part of the sentence</p>",
        "id": 427228239,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710711300
    },
    {
        "content": "<p>type theory gives you the means to construct many types, not just \"start at the empty set and build up to everything else\"</p>",
        "id": 427228356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710711339
    }
]