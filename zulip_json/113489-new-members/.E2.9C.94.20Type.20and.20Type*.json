[
    {
        "content": "<p>Hi, I ran into an idiosyncrasy of Type and Type* that puzzles me a bit. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IntervalModuleObject</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DivisionRing</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ModuleCat</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">SelfSubmod</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">ZeroSubmod</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This code works if I write <code>F : Type</code> but fails to compile as is, with <code>F : Type*</code>, with error: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">SelfSubmod</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">ZeroSubmod</span><span class=\"w\"> </span><span class=\"n\">F</span>\n<span class=\"n\">argument</span>\n<span class=\"w\">  </span><span class=\"n\">ZeroSubmod</span><span class=\"w\"> </span><span class=\"n\">F</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">ModuleCat</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u_3</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">ModuleCat</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u_3</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Here are the definitions of the helper functions for context: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ZeroSubmod</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DivisionRing</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SelfSubmod</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DivisionRing</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">F</span>\n</code></pre></div>\n<p>My questions are: </p>\n<p>1) How can the same type, ModuleCat F, have two different types? I am referring to the error message expecting it to be of a certain type and not being given what it wants here. <br>\n2) When should I be using type vs type* to define variables? I was under the impression type* was always preferable, but in this case it seems to cause issues.<br>\n3) When is it appropriate to use ULift and PLift to force things to live in the desired types?</p>",
        "id": 443822289,
        "sender_full_name": "VayusElytra",
        "timestamp": 1718040152
    },
    {
        "content": "<p>I recommend</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ZeroSubmod</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DivisionRing</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 443824201,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718040786
    },
    {
        "content": "<p>I recommend not bothering to fight with universes and just put everything in Type. If someone asked you \"is it necessary in your theory to allow \"vector spaces\" which are so large that they are not actually sets, eg the \"vector space\" with basis the \"set\" of all sets\" you would probably have replied \"no of course we don't need such large objects\". So why allow Type u as opposed to just Type?</p>",
        "id": 443931615,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1718090230
    },
    {
        "content": "<p>What you are saying makes sense, of course, the theory only really cares about finite-dimensional vector spaces anyway, but the fact that this difference in the allowed size of objects is truly the difference between Type 0 and Type u for arbitrary u is a little unclear to me.</p>",
        "id": 443976537,
        "sender_full_name": "VayusElytra",
        "timestamp": 1718104793
    },
    {
        "content": "<p>I believe that, loosely speaking, each universe contains the \"power set\" of the universe below it, so it makes sense to refer to the difference as a size difference.</p>",
        "id": 444022286,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1718117596
    },
    {
        "content": "<p>I think this requires PUnit.{u+1} to avoid a type mismatch. PUnit.{u} has type Sort u, but the code you wrote above expects something of type Type u, which is Sort (u+1) if I understand the hierarchy properly (and indeed, testing it threw a type error for PUnit.{u} but not for PUnit.{u+1}). </p>\n<p>This suggestion does fix the problem in IntervalModuleObject when using Type*, though! That is so cool, can I ask how you knew this would fix it?</p>",
        "id": 444024962,
        "sender_full_name": "VayusElytra",
        "timestamp": 1718118314
    },
    {
        "content": "<blockquote>\n<p>the theory only really cares about finite-dimensional vector spaces anyway</p>\n</blockquote>\n<p>Every finite-dimensional vector space in <code>Type u</code> is isomorphic to one in <code>Type</code> at least. (Assuming the field it's over is in <code>Type</code>!) I'm not suggesting to restrict to <code>Type</code> here, but I just thought I'd mention it in case it helps with thinking about universes.</p>\n<p>This universe issue is sort of like how every <code>Type u</code> has its own copy of the natural numbers. You can construct these easily with <code>ULift.{u} Nat</code> for example.</p>",
        "id": 444049501,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718123736
    },
    {
        "content": "<p>Hmm, I see. Are there good ressources to learn about what exactly types are meant to be? I think I would benefit from having a more rigorous understanding of them.</p>",
        "id": 444056201,
        "sender_full_name": "VayusElytra",
        "timestamp": 1718125645
    },
    {
        "content": "<p>Here's the sort of mental model I have for Lean's type system:</p>\n<ul>\n<li>A <em>type</em> is a set of objects that's been called a type.</li>\n<li>A <em>term</em> is an expression for an object, where from the expression you can compute what <em>type</em> the object is an element of (for example, from <code>Nat.succ Nat.zero</code> you can see that it must be in the <code>Nat</code> type).</li>\n<li>An <em>inductive type</em> is a type that comes with a complete description of all its elements via constructors and a recursion/induction principle.</li>\n<li>Every type is itself in a type called a <em>universe</em>. The universes are <code>Sort 0</code>, <code>Sort 1</code>, <code>Sort 2</code> and so on (though apparently the set of universe levels need not be just the natural numbers — I've never needed to think about this) with <code>Prop := Sort 0</code> and <code>Type u := Sort (u + 1)</code> for convenience. By convention, the type of the universe <code>Sort u</code> is <code>Sort (u + 1)</code>. My understanding is that this is not a deep fact, but a convenience so that you don't need both <code>x is-term-in Nat</code> and <code>Nat is-type-in Type</code>, and instead we can just write <code>x : Nat</code> and <code>Nat : Type</code> for both concepts).</li>\n<li>The \"underlying sets\" for types need not be disjoint. That's not something you can logically talk about from within Lean, but you can use this to convince yourself that certain things are unprovable in Lean (for example, <code>Nat = Int</code> can neither be proved nor disproved since it's possible for them to be the same, but it's also possible for them not to be). This may seem to conflict with \"every term has a unique type\", but it's <em>terms</em> that have types, not the objects that the terms refer to.</li>\n<li>There are rules for how \"big\" certain constructions are. For example, if <code>X : Type u</code> and <code>Y : Type v</code>, then <code>X -&gt; Y : Type (max u v)</code>. It makes some sense since (1) <code>Unit -&gt; Type u</code> is in bijective correspondence to <code>Type u</code> and indeed they are both in <code>Type (u + 1)</code> and (2) <code>Type u -&gt; Prop</code> is <code>Set (Type u)</code> and it makes sense that both would be in <code>Type (u + 1)</code> (these are \"large\" sets). There's an exception, where if <code>X : Sort u</code> and <code>p : Prop</code> then <code>X -&gt; p</code> is in <code>Prop</code>. This is called <em>impredicativity</em> and it's important to make it so that universal quantification is a proposition while still being, conveniently, a function type.</li>\n</ul>",
        "id": 444063991,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718128020
    },
    {
        "content": "<p>By the way, <code>Type*</code> is a \"strict\" version of <code>Type _</code>. What <code>Type _</code> means is \"type universe with some unknown level parameter, figure it out or (eventually) create a level parameter for it\", and what <code>Type*</code> means is \"<code>Type u</code> with a fresh level parameter <code>u</code>\".</p>\n<p>The point of <code>Type*</code> is to ensure a definition or theorem is truly universe polymorphic. For example, it saves you from mistakes like the following one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Subsingleton</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Subsingleton</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"c1\">-- error: failed to synthesize</span>\n</code></pre></div>\n<p>(Hover over <code>example</code> in the first one to see what type it ends up having.)</p>",
        "id": 444064810,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718128274
    },
    {
        "content": "<p>Wow thank you so much! This is exactly the kind of thing I was looking for!</p>",
        "id": 444071000,
        "sender_full_name": "VayusElytra",
        "timestamp": 1718130357
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"715864\">VayusElytra</span> has marked this topic as resolved.</p>",
        "id": 444266809,
        "sender_full_name": "Notification Bot",
        "timestamp": 1718206482
    }
]