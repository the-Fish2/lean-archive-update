[
    {
        "content": "<p>Why can't I <code>#eval</code> a <code>Set Nat</code>? Specifically:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>results in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">typeclass</span> <span class=\"kd\">instance</span> <span class=\"n\">problem</span> <span class=\"n\">is</span> <span class=\"n\">stuck</span><span class=\"o\">,</span> <span class=\"n\">it</span> <span class=\"n\">is</span> <span class=\"n\">often</span> <span class=\"n\">due</span> <span class=\"n\">to</span> <span class=\"n\">metavariables</span>\n  <span class=\"n\">Insert</span> <span class=\"n\">ℕ</span> <span class=\"bp\">?</span><span class=\"n\">m.55319</span>\n</code></pre></div>\n<p>And if I try</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">expression</span>\n  <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">Set</span> <span class=\"n\">ℕ</span>\n<span class=\"n\">but</span> <span class=\"kd\">instance</span>\n  <span class=\"n\">Lean.MetaEval</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">be</span> <span class=\"n\">synthesized</span><span class=\"o\">,</span> <span class=\"n\">this</span> <span class=\"kd\">instance</span> <span class=\"n\">instructs</span> <span class=\"n\">Lean</span> <span class=\"n\">on</span> <span class=\"n\">how</span> <span class=\"n\">to</span> <span class=\"n\">display</span> <span class=\"n\">the</span> <span class=\"n\">resulting</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"n\">recall</span> <span class=\"n\">that</span> <span class=\"n\">any</span> <span class=\"n\">type</span> <span class=\"n\">implementing</span> <span class=\"n\">the</span> <span class=\"bp\">`</span><span class=\"n\">Repr</span><span class=\"bp\">`</span> <span class=\"kd\">class</span> <span class=\"n\">also</span> <span class=\"n\">implements</span> <span class=\"n\">the</span> <span class=\"bp\">`</span><span class=\"n\">Lean.MetaEval</span><span class=\"bp\">`</span> <span class=\"kd\">class</span>\n</code></pre></div>\n<p>Is there any way to \"print\" the items in this (or any finite set)? <code>Finset.toList</code> is <code>noncomputable</code>, and I can't seem to find a way around this.</p>",
        "id": 410311598,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1703778492
    },
    {
        "content": "<p>Certainly not with <code>Set</code>, since it could be infinite</p>",
        "id": 410312211,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1703778859
    },
    {
        "content": "<p>Really the question is \"what are you trying to do\"</p>",
        "id": 410312284,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1703778912
    },
    {
        "content": "<p>I'm trying to constructively enumerate the preimage of a boolean function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">×</span> <span class=\"n\">Bool</span> <span class=\"bp\">|</span> <span class=\"n\">Bool.xor</span> <span class=\"n\">b.1</span> <span class=\"n\">b.2</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 410312326,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1703778945
    },
    {
        "content": "<p>Specifically, I'm trying to formalize some basic theorems about boolean functions and propositional logic. I'm trying to prove that the symbols <code>{¬, ∧, ∨}</code> are enough to represent a boolean function. I've defined my own structures for a signature (set of symbols) and formulas, and now I'm trying to construct a disjunctive normal form of a boolean function, which requires me to constructively enumerate the inputs for which the boolean function evaluates to <code>true</code>.</p>",
        "id": 410313453,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1703779421
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">Finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Bool</span> <span class=\"bp\">×</span> <span class=\"n\">Bool</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Bool.xor</span> <span class=\"n\">b.1</span> <span class=\"n\">b.2</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">Finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Bool</span> <span class=\"bp\">×</span> <span class=\"n\">Bool</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Bool.xor</span> <span class=\"n\">b.1</span> <span class=\"n\">b.2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">{(</span><span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">false</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 410313882,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1703779591
    },
    {
        "content": "<p>Am I missing some <code>Finset</code> import or something?<br>\nThis still fails for me</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">Finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Bool</span> <span class=\"bp\">×</span> <span class=\"n\">Bool</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Bool.xor</span> <span class=\"n\">b.1</span> <span class=\"n\">b.2</span>\n</code></pre></div>\n<p>with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">expression</span>\n  <span class=\"n\">Finset.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Bool.xor</span> <span class=\"n\">b.1</span> <span class=\"n\">b.2</span> <span class=\"bp\">=</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"n\">Finset.univ</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Bool</span> <span class=\"bp\">×</span> <span class=\"n\">Bool</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"kd\">instance</span>\n  <span class=\"n\">Lean.MetaEval</span> <span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Bool</span> <span class=\"bp\">×</span> <span class=\"n\">Bool</span><span class=\"o\">))</span>\n<span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">be</span> <span class=\"n\">synthesized</span><span class=\"o\">,</span> <span class=\"n\">this</span> <span class=\"kd\">instance</span> <span class=\"n\">instructs</span> <span class=\"n\">Lean</span> <span class=\"n\">on</span> <span class=\"n\">how</span> <span class=\"n\">to</span> <span class=\"n\">display</span> <span class=\"n\">the</span> <span class=\"n\">resulting</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"n\">recall</span> <span class=\"n\">that</span> <span class=\"n\">any</span> <span class=\"n\">type</span> <span class=\"n\">implementing</span> <span class=\"n\">the</span> <span class=\"bp\">`</span><span class=\"n\">Repr</span><span class=\"bp\">`</span> <span class=\"kd\">class</span> <span class=\"n\">also</span> <span class=\"n\">implements</span> <span class=\"n\">the</span> <span class=\"bp\">`</span><span class=\"n\">Lean.MetaEval</span><span class=\"bp\">`</span> <span class=\"kd\">class</span>\n</code></pre></div>",
        "id": 410314062,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1703779677
    },
    {
        "content": "<p>Also thank you for the example proof of the contents of the set, that will be useful.</p>",
        "id": 410314294,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1703779766
    },
    {
        "content": "<p>It seems I was. <a href=\"https://github.com/leanprover-community/mathlib4/blob/fb3fd7cd7a0004f3d9bc0daf99c3d767cf6e7600/Mathlib/Data/Finset/Sort.lean#L260\"><code>Mathlib/Data/Finset/Sort.lean</code></a> contains </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unsafe</span> <span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Repr</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Repr</span> <span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">reprPrec</span> <span class=\"n\">s</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n    <span class=\"c1\">-- multiset uses `0` not `∅` for empty sets</span>\n    <span class=\"k\">if</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"s2\">\"∅\"</span> <span class=\"k\">else</span> <span class=\"n\">repr</span> <span class=\"n\">s.1</span>\n</code></pre></div>",
        "id": 410315222,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1703780230
    },
    {
        "content": "<p>Not sure what the consequences of using an <code>unsafe instance</code> is... But I'll take it for now. Thank you for the help :)</p>",
        "id": 410315270,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1703780259
    },
    {
        "content": "<p>I also guess <code>unsafe</code> doesn't matter much for a <code>Repr</code> instance, since it won't be used in the theorems.</p>",
        "id": 410315481,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1703780360
    },
    {
        "content": "<p><code>unsafe</code> means that if you try to prove things about the <code>repr</code> you'll derive a contradiction, since <code>{1, 2} = {2, 1}</code> but they have different reprs</p>",
        "id": 410316196,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703780751
    },
    {
        "content": "<p>Ah got it, thanks!</p>",
        "id": 410316310,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1703780802
    },
    {
        "content": "<p>also interesting that <code>Finset.toList</code> is <code>noncomputable</code> but <code>Finset.sort</code> is not. Surprised a relation is necessary for this.</p>",
        "id": 410316377,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1703780839
    },
    {
        "content": "<p>By sorting, the output is well-defined</p>",
        "id": 410316613,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1703780971
    },
    {
        "content": "<p>Ah that makes sense.</p>",
        "id": 410317245,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1703781315
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/FinEnum.html#FinEnum\"><code>FinEnum</code></a> is what actually solved the root of my problem.</p>",
        "id": 410489666,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1703893255
    }
]