[
    {
        "content": "<p>Another newbie question.</p>\n<p>I'm trying to understand how terms are constructed to prove something. My understanding is that it is actually working in reverse. e.g. to prove x=x+y-y. You might start with (pseudocode):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">rfl</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">=</span><span class=\"n\">x</span>\n<span class=\"n\">nthrewrite</span><span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lemma1</span><span class=\"o\">:(</span><span class=\"n\">x</span><span class=\"bp\">=</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">0</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">=</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">0</span>\n<span class=\"n\">nthrewrite</span><span class=\"o\">(</span><span class=\"n\">nthrewrite</span><span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lemma1</span><span class=\"o\">:(</span><span class=\"n\">x</span><span class=\"bp\">=</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">0</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">lemma2</span><span class=\"o\">:(</span><span class=\"mi\">0</span><span class=\"bp\">=</span><span class=\"n\">y</span><span class=\"bp\">-</span><span class=\"n\">y</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">=</span><span class=\"n\">y</span><span class=\"bp\">-</span><span class=\"n\">y</span>\n</code></pre></div>\n<p>Therefor my \"term\" which I constructed with the type <code>x=y-y</code> is made of a nested set of rewrite rules. </p>\n<p>Presumably the <strong>nthrewrite</strong> is one of the fundamental Type theory rules. But something bothering me is that it involves counting the nth match. I guess that's fine but we are using this theory to define numbers in the first place so the notation is a bit odd.</p>\n<p>Am I correct in that the \"terms\" we construct for our proof consist of a lot of these rewrite rules plus function operations?<br>\n<a href=\"https://image.slidesharecdn.com/bekkimineshimaesslli2016-dependenttypes-200410041311/75/ESSLLI2016-DTS-Lecture-Day-1-From-natural-deduction-to-dependent-type-theory-5-2048.jpg\">https://image.slidesharecdn.com/bekkimineshimaesslli2016-dependenttypes-200410041311/75/ESSLLI2016-DTS-Lecture-Day-1-From-natural-deduction-to-dependent-type-theory-5-2048.jpg</a></p>\n<div class=\"message_inline_image\"><a href=\"https://image.slidesharecdn.com/bekkimineshimaesslli2016-dependenttypes-200410041311/75/ESSLLI2016-DTS-Lecture-Day-1-From-natural-deduction-to-dependent-type-theory-5-2048.jpg\"><img src=\"https://uploads.zulipusercontent.net/f679e81ee450f40d00c3d1fe8aaeedcbdda5d300/68747470733a2f2f696d6167652e736c696465736861726563646e2e636f6d2f62656b6b696d696e657368696d616573736c6c69323031362d646570656e64656e7474797065732d3230303431303034313331312f37352f4553534c4c49323031362d4454532d4c6563747572652d4461792d312d46726f6d2d6e61747572616c2d646564756374696f6e2d746f2d646570656e64656e742d747970652d7468656f72792d352d323034382e6a7067\"></a></div><p>well i suppose nth-rewrite is just a shorthand for:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">P</span><span class=\"o\">:</span><span class=\"n\">A</span><span class=\"bp\">-&gt;</span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\">   </span><span class=\"n\">C</span><span class=\"o\">:</span><span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">:</span><span class=\"n\">a</span><span class=\"bp\">=</span><span class=\"n\">b</span>\n<span class=\"c1\">------------------------------------</span>\n<span class=\"w\">          </span><span class=\"n\">rw</span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but in a more compact form</p>",
        "id": 447047823,
        "sender_full_name": "Mr Proof",
        "timestamp": 1719369662
    },
    {
        "content": "<p>You can do both forward and backward proof with Lean. Nthrewrite does not exist as a primitive. What kind of proof terms you construct depends entirely on the proof and tactics involved, there are vastly different techniques. And the last rule that you wrote down is very similar to the J rule which is indeed part of Leans type theory through the eliminator for the Eq type.</p>",
        "id": 447166718,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719394050
    },
    {
        "content": "<blockquote>\n<p>\"it is a remarkable fact that it is possible to construct a substantial edifice of mathematics based on nothing more than the type universes, dependent arrow types, and inductive types; everything else follows from those.\" - <a href=\"https://lean-lang.org/theorem_proving_in_lean4/structures_and_records.html?highlight=edif#structures-and-records\">TPiL4</a></p>\n</blockquote>\n<p>Here's how I understand it at the moment:<br>\nFrom the constructive, computational point of view - terms must encode how these three things are constructed and deconstructed. All the more complicated terms are just built on these.</p>",
        "id": 447184751,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1719399238
    },
    {
        "content": "<p>This is not really something that's inherently connected to constructivism, if you assume the existence of a constant that gives you the axiom of choice the above claim still holds but you are not constructive</p>",
        "id": 447192821,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719401515
    },
    {
        "content": "<p>It feels like considerations that take the form <em>'my \"term\" [...] is made of'</em> might break down a bit once you use the axiom of choice, but I suppose no more than it does when making a term within a function abstraction where you've assumed the existence of a term of some Type.</p>\n<p>My mental model of \"what a term is made of,\" is a bunch of things representing — actual and assumed — nested inductives and dependent arrows. That's probably not quite right either because it seems like from a type-checking point of view, terms aren't made of anything they just participate in well-formed expressions or something like that.</p>",
        "id": 447231076,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1719412094
    },
    {
        "content": "<p>I'm looking at one of the proofs from \"The Natural Number Game\" (yes you could just use rfl on this)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ONE</span><span class=\"o\">:=</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">TWO</span><span class=\"o\">:=</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">ONE</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">proofA</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">TWO</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TWO</span><span class=\"o\">]</span>\n<span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ONE</span><span class=\"o\">]</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">proofA</span>\n</code></pre></div>\n<p>And the output of the proof is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">proofA</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TWO</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">TWO</span><span class=\"bp\">.</span><span class=\"n\">eq_1</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ONE</span><span class=\"bp\">.</span><span class=\"n\">eq_1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>So it looks like the rewrite rules are written like for replacing P(b) with P(c) given b=c:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>which unfortunately would be a bit of a long way to write it if you needed to just substitute one variable in a really big expression because first you'd have to write your expression in the form P(a) </p>\n<p>I would like to find somewhere a list of the <strong>keywords</strong> in Lean, which are not made by induction.</p>",
        "id": 447285188,
        "sender_full_name": "Mr Proof",
        "timestamp": 1719423717
    },
    {
        "content": "<blockquote>\n<p>I would like to find somewhere a list of the <strong>keywords</strong> in Lean, which are not made by induction.</p>\n</blockquote>\n<p>What do you mean with made by induction?</p>",
        "id": 447288063,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719424268
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113489-new-members/topic/proofs.20as.20rewrites.20but.20how.20do.20numbers.20appear.3F/near/447288063\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I would like to find somewhere a list of the <strong>keywords</strong> in Lean, which are not made by induction.</p>\n</blockquote>\n<p>What do you mean with made by induction?</p>\n</blockquote>\n<p>I mean made in Lean from other keywords. e.g. Exists is made by induction but the Pi type is a keyword AFAIK. Just looking for the minimal set of Lean keywords. Every programming language has a basic set of keywords. I can't seem to find the list for Lean 4.</p>",
        "id": 447290365,
        "sender_full_name": "Mr Proof",
        "timestamp": 1719424869
    },
    {
        "content": "<p>Lean 4 is an arbitrarily extensible programming language, there is no defined set of keywords. The built-in set of keywords is also very rich as quite literally every tactic is a keyword</p>",
        "id": 447291232,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719425081
    },
    {
        "content": "<p>If there is no set of keywords then Lean 4 is not a programming language.</p>",
        "id": 447291820,
        "sender_full_name": "Mr Proof",
        "timestamp": 1719425240
    },
    {
        "content": "<p>The set of keywords is arbitrarily extensible at elaboration time, there is no fix set of keywords. Yes Lean 4 is still a programming language.</p>",
        "id": 447292071,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719425316
    },
    {
        "content": "<p>I don't know what you mean by \"elaboration time\". I'm just looking for the glossary of keywords that define the Lean 4 language. Otherwise Lean is not a programming language it is an arbitrary set of tools for creating proofs that can be checked by the Lean kernel. Which is fine but doesn't make it a language.</p>",
        "id": 447293019,
        "sender_full_name": "Mr Proof",
        "timestamp": 1719425607
    },
    {
        "content": "<p>The process of translating the Lean language to its core lambda calculus is referred to as elaboration. Thanks to commands like <code>macro</code>, <code>syntax</code>, etc. a Lean file can define new kinds of keywords, syntax, etc. that can then be used in subsequent Lean files. This is also very much a thing in other programming languages like Racket and in mored limited forms also seen in languages like Agda, Coq, Isabelle or Haskell. </p>\n<p>There is a set of built-in syntax that is provided by the compiler which can be extended arbitrarily by a Lean programmer (and the libraries they are using) through this mechanism. The list of syntax and keywords provided by the compiler is already very vast and I would estimate that, given the fact that all tactics are themselves effectively a keyword, there is quite literally hundreds of keywords in the base Lean language already.</p>",
        "id": 447294151,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719425834
    },
    {
        "content": "<p>True, but all tactics create proofs made of keywords that can be checked by the Lean kernel. I am looking for those set of keywords not the tactics keywords.</p>",
        "id": 447294388,
        "sender_full_name": "Mr Proof",
        "timestamp": 1719425884
    },
    {
        "content": "<p>And yes Lean 4 is still a language, it merely has an extensible parser that allows for this type of stuff, again this is a thing that is also seen both in other proof assistants and also other programming languages to varying degrees of freedom.</p>",
        "id": 447294411,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719425887
    },
    {
        "content": "<p>If you are looking for Lean's core lambda calculus that is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Expr#doc\">docs#Expr</a>. This is the stuff that tactics create under the hood</p>",
        "id": 447294541,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719425919
    },
    {
        "content": "<p>This is still far from a description of the basic mechanisms that Lean provdes though <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr#doc\">docs#Lean.Expr</a> doesn't contain inductive type specifications and a ton of other stuff. It is also not something that anyone in Lean that is not doing meta programming really cares about.</p>",
        "id": 447294840,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719425983
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"725689\">Mr Proof</span> <a href=\"#narrow/stream/113489-new-members/topic/proofs.20as.20rewrites.20but.20how.20do.20numbers.20appear.3F/near/447291820\">said</a>:</p>\n<blockquote>\n<p>If there is no set of keywords then Lean 4 is not a programming language.</p>\n</blockquote>\n<p>Depends on how you want to define things I suppose!</p>\n<p>As I understand it, lean has a set mechanisms and APIs whereby syntax is parsed and processed and these API are open to users. So that the notion of a \"built-in\" syntax is perhaps hard to pin down. I don't really see this as precluding it from being a programming language though!</p>",
        "id": 447295154,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1719426040
    },
    {
        "content": "<p>From my point of view there's three languages. The first is what is output by #print, which is the language of the proofs themselves which I guess is fairly fixed by now(??). (And would that be called a language or a data-structure?)  The second is the tactics. Which I guess is a language in it's own right, but one which is constantly changing and updating. <br>\nThe third is the language to actually build the tactics (but I guess some of that is done in another language like C++?) </p>\n<p>Sorry for being vague about what I was looking for. I'm more interested in Lean from a theoretical aspect, so I really am interested in the language that is output by #print. Which I guess must have keywords otherwise the kernel wouldn't be able to check it.</p>",
        "id": 447297302,
        "sender_full_name": "Mr Proof",
        "timestamp": 1719426476
    },
    {
        "content": "<blockquote>\n<h1>Init.Prelude</h1>\n<p>This is the first file in the Lean import hierarchy. It is responsible for setting<br>\nup basic definitions, most of which Lean already has \"built in knowledge\" about,<br>\nso it is important that they be set up in exactly this way<br>\n- <a href=\"https://github.com/leanprover/lean4/blob/master/src/Init/Prelude.lean\">link</a></p>\n</blockquote>\n<p>This isn't syntax, per-say, but there's probably some way to dig into the things Lean has \"built in knowledge\" about.</p>",
        "id": 447298259,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1719426701
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"725689\">Mr Proof</span> <a href=\"#narrow/stream/113489-new-members/topic/proofs.20as.20rewrites.20but.20how.20do.20numbers.20appear.3F/near/447297302\">said</a>:</p>\n<blockquote>\n<p>From my point of view there's three languages. The first is what is output by #print, which is the language of the proofs themselves which I guess is fairly fixed by now(??). (And would that be called a language or a data-structure?)  The second is the tactics. Which I guess is a language in it's own right, but one which is constantly changing and updating. <br>\nThe third is the language to actually build the tactics (but I guess some of that is done in another language like C++?) </p>\n<p>Sorry for being vague about what I was looking for. I'm more interested in Lean from a theoretical aspect, so I really am interested in the language that is output by #print. Which I guess must have keywords otherwise the kernel wouldn't be able to check it.</p>\n</blockquote>\n<p>#print shows a prettified version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Expr#doc\">docs#Expr</a>, the other syntax that you are talking about is always arbitrarily extensible</p>",
        "id": 447298931,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719426898
    },
    {
        "content": "<p>It's quite important to note that #print prints a term. These are not keywords. rw the tactic helped construct a term that began with Eq.mpr. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Eq.mpr#doc\">docs#Eq.mpr</a> is further another term that is defined by something else.</p>",
        "id": 447310196,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719429658
    },
    {
        "content": "<p>So, no, the language of proof terms isn't fixed, because a proof terms could contain any term, and we declare new terms all the time.</p>",
        "id": 447310668,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719429764
    },
    {
        "content": "<p>Are you asking if the structure of terms, or the terms that appear inside terms generated by the rw tactic, whether that is more fixed?</p>",
        "id": 447310797,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719429798
    },
    {
        "content": "<p>Yeah, basically I'm trying to drill down, so that Eq.Mpr is defined by terms A which are defined by terms B etc. and trying to find what lies at the bottom <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>... if anything</p>",
        "id": 447311111,
        "sender_full_name": "Mr Proof",
        "timestamp": 1719429862
    },
    {
        "content": "<p>Yes, Eq.mpr is defined at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Eq.mpr#src\">src#Eq.mpr</a>.</p>",
        "id": 447311293,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719429929
    },
    {
        "content": "<p>What does Lean's Kernal see? Eventually all the keywords and such are expanded, elaborated, etc what is the result of all that? I've generally imagined that it's not something that's super fun to look at, but could that be thought of as lean's \"at the bottom\" representation?</p>",
        "id": 447312055,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1719430163
    },
    {
        "content": "<p>The declaration of which takes two arguments, and constructs a new term of some equality statement, using the two arguments and the rewrite triangle. Declarations as defined by parsing and an elaboration rule. The rewrite triangle also has its own elaboration. Elaboration basically means that after syntax is parsed into expressions, the underlying expressions are combined by some rules, and then passed to the kernel as a term and the expected type. Separately, in kernel proof terms, the proof here works because of the recursor on the Eq type. And the expected type expression has been passed along by the elaborator.</p>",
        "id": 447312135,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719430197
    },
    {
        "content": "<p>How much of this is the language that is being asked about, or implementation details of how the language is parsed? For a question that seems similar to me, is Python the language -- the AST or the parser that constructs an AST from some text file, or the CPython implementation that does evaluation?</p>",
        "id": 447313942,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719430666
    },
    {
        "content": "<p>I think I'm getting the idea. That the keywords are just \"def\", \"=\", \"fun\", \"-&gt;\" etc. and everything else can be defined from these? And you could prove the whole of FLT with just these? Or maybe you don't even need \"=\"</p>",
        "id": 447314783,
        "sender_full_name": "Mr Proof",
        "timestamp": 1719430830
    },
    {
        "content": "<p>There are again quite literally hundreds of keywords, many of them are defined on the fly, for example <code>=</code>is explicitly defined by extending the grammar of Lean at this point: <a href=\"https://github.com/leanprover/lean4/blob/141856d6e6d808a85b9147a530294fee8e48e15f/src/Init/Notation.lean#L325\">https://github.com/leanprover/lean4/blob/141856d6e6d808a85b9147a530294fee8e48e15f/src/Init/Notation.lean#L325</a> the underlying type <code>Eq</code> is defined at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Eq#src\">src#Eq</a> which is done using the <code>inductive</code> keyword that can indeed be considered one of the core primitives. But again, you will not be able to find a notion of \"keywords\" in Lean. You can find a notion of what the kernel thinks terms and definitions are but those are abstracted over <em>a lot</em> in the surface level syntax and users can add new extensions to those abstractions as they wish arbitrarily.</p>",
        "id": 447315549,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719431022
    },
    {
        "content": "<p>I think we just have a different definition of keyword.</p>",
        "id": 447315745,
        "sender_full_name": "Mr Proof",
        "timestamp": 1719431069
    },
    {
        "content": "<p>Then what is a keyword for you</p>",
        "id": 447315788,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719431079
    },
    {
        "content": "<p>Something which isn't defined on the fly</p>",
        "id": 447315818,
        "sender_full_name": "Mr Proof",
        "timestamp": 1719431090
    },
    {
        "content": "<p>I mean the Lean compiler uses quite literally the same mechanisms to register the <code>inductive</code> keyword as a primitive. There is no difference between how <code>inductive</code> is added to the grammar and how <code>=</code> is added to it. You can build your own <code>inductive</code> command if you wish. Lean as a language is a sandbox with infinite possibilities, some of which have been used by the compiler itself already and some of which are waiting to be used by its users.</p>",
        "id": 447316408,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719431226
    },
    {
        "content": "<p>Again if you are looking for the language that the kernel speaks, you can take a look at the kernel APIs and you will find that it only accepts certain data structures but you will have a hard time convincing the majority here that those are the keywords of Lean, the majority of math users has never and will never see or care about this API.</p>",
        "id": 447316703,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719431287
    },
    {
        "content": "<p>For Python, there's a <a href=\"https://docs.python.org/3/reference/grammar.html\">Full Grammar specification</a>. The notation is a mixture of EBNF and PEG and you can look through it and find the terminal symbols like 'pass', 'break', 'continue', 'return', 'raise', 'from', 'global'. If I read you correctly, for Python you'd be satisfied with this list.</p>\n<p>I don't think it's helpful to think of Lean 4 this way.</p>",
        "id": 447316772,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1719431304
    },
    {
        "content": "<p>I think the <a href=\"https://leanprover-community.github.io/lean4-metaprogramming-book/\">intro (link)</a> for the Metaprogramming in Lean 4 book actually contains some insight into why this might feel confusing on first blush.</p>\n<blockquote>\n<p>\"One cool thing about Lean, though, is that it allows us to define custom syntax nodes and implement meta-level routines to elaborate them in the very same development environment that we use to perform object-level activities. [...] We can say that, in Lean, the meta-level is <em>reflected</em> to the object-level.\"</p>\n</blockquote>\n<p>Because there's no separate meta-language, this means you can perform meta-activities like parse code, build an AST and elaborate its syntax nodes into terms that can be processed by the language kernel using syntax you've only moments ago defined in the same file.</p>\n<p>I don't know what the most boot-strapped version of this looks like, but it's easy to imagine this doesn't much resemble what Lean 4 looks like.</p>",
        "id": 447331133,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1719434367
    },
    {
        "content": "<p>The most bootstrapped version of Lean 4 is quite literally Lean 3 ^^</p>",
        "id": 447331340,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719434421
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"725689\">@Mr Proof</span>, have you tried to read <a href=\"https://github.com/leanprover/lean4/blob/master/src/Init/Notation.lean\">Init/Notation.lean</a>?</p>",
        "id": 447373075,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1719455700
    },
    {
        "content": "<p>I think that a good way to get a grasp of what is the core of Lean is to read how the basic commands are defined - and they depend on lots of other things. Grep the sources for \"leading_parser\"...</p>",
        "id": 447373480,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1719455999
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"725689\">Mr Proof</span> <a href=\"#narrow/stream/113489-new-members/topic/proofs.20as.20rewrites.20but.20how.20do.20numbers.20appear.3F/near/447314783\">said</a>:</p>\n<blockquote>\n<p>I think I'm getting the idea. That the keywords are just \"def\", \"=\", \"fun\", \"-&gt;\" etc. and everything else can be defined from these? And you could prove the whole of FLT with just these? Or maybe you don't even need \"=\"</p>\n</blockquote>\n<p><code>=</code> is notation for <code>Eq</code> which is defined in code in core Lean</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- `Eq.refl a : a = a` is reflexivity, the unique constructor of the</span>\n<span class=\"sd\">  equality type. See also `rfl`, which is usually used instead. -/</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>, so it's no more and no  less a keyword than vector spaces, which are also defined in code (this time in mathlib). Note that I can assert this with confidence even though you've supplied no definition of \"keyword\", because equality and vector spaces are defined using the same technique (as are natural numbers etc etc).</p>\n<p><code>def</code> is a <em>command</em>. Is this the concept you're looking for?</p>",
        "id": 447406510,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1719473564
    }
]