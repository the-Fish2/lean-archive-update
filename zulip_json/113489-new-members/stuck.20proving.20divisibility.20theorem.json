[
    {
        "content": "<p>Consider this simple theorem, where all variables are integers:</p>\n<p>If c divides a_1, .., a_k, then c divides (a_1 · u_1 + ... + a_k · u_k) for all integers u_1, ..., u_k.</p>\n<p><strong>Question 1</strong>: Does this theorem exist somewhere in MathLib (perhaps over some more general algebraic structure)?</p>\n<p>As an exercise, I'd like to state this theorem in Lean and prove it.  Here's my attempt at stating it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">range</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">div</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n              <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"bp\">∑</span><span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p><strong>Question 2</strong>: Does this formulation look reasonable?  I've used functions from ℕ → ℤ to represent the sequences, and I've used Finset.range to iterate over integers up to k.  Also, I'm using indices from 0 .. k - 1 even though the original statement uses indices 1 .. k.  Are these typical idiomatic choices?</p>\n<p>Now I'd like to prove it.  Here, in English, is a simple proof:</p>\n<p>By the definition of divisibility, there exist integers q_1 .. q_k such that a_i = q_i · c for i = 1, ..., k.  Then</p>\n<p>(a_1 · u_1 + ... + a_k · u_k) = (q_1 · c · u_1 + ... + q_k · c · u_k) = (q_1 · u_1 + ... + q_k · u_k) · c.</p>\n<p>And so c divides (a_1 · u_1 + ... + a_k · u_k).</p>\n<p>Here's my attempt to translate just the first part of the proof into Lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">div</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n              <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"bp\">∑</span><span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">q</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">):</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"n\">i</span> <span class=\"n\">r</span>\n    <span class=\"n\">d</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>For now, I'm only trying to establish the sequence q.  Unfortunately the code above fails to compile, and I'm a bit stuck.  I believe that h i r has type (c | a i), which is defined to mean ∃ d, a i = c * d.  So I thought I could use 'let' to get the value d.  However Lean won't accept the statement 'let ⟨d, _⟩ := h i r':</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">tactic</span> <span class=\"bp\">'</span><span class=\"n\">cases'</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">nested</span> <span class=\"n\">error</span><span class=\"o\">:</span>\n<span class=\"n\">tactic</span> <span class=\"bp\">'</span><span class=\"n\">induction'</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">recursor</span> <span class=\"bp\">'</span><span class=\"n\">Exists.casesOn'</span> <span class=\"n\">can</span> <span class=\"n\">only</span> <span class=\"n\">eliminate</span> <span class=\"n\">into</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">ℤ</span>\n<span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span>\n<span class=\"n\">i</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"n\">motive</span><span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"bp\">?</span><span class=\"n\">u.16204</span>\n<span class=\"n\">h_1</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">c_1</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">c_1</span><span class=\"o\">)</span>\n<span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"n\">a</span> <span class=\"n\">i</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">motive</span> <span class=\"n\">x</span><span class=\"bp\">✝</span>\n</code></pre></div>\n<p><strong>Question 3</strong>: What's wrong in my code above?  How to fix it?</p>\n<p>I'd appreciate any feedback on the questions above - thanks.</p>",
        "id": 421684534,
        "sender_full_name": "Adam Dingle",
        "timestamp": 1708012258
    },
    {
        "content": "<p>Yes, it's (the direct composition of things) in mathlib: See <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.dvd_sum#doc\">docs#Finset.dvd_sum</a></p>",
        "id": 421685014,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708012383
    },
    {
        "content": "<p>You will need one more lemma, which I am leaving for you to find</p>",
        "id": 421685165,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708012420
    },
    {
        "content": "<p>To get the integers q_1 ... q_k as a function q, you need to use the <code>choose</code> tactic which invokes the axiom of choice: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">div</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n              <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"bp\">∑</span><span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">choose</span> <span class=\"n\">q</span> <span class=\"n\">hq</span> <span class=\"n\">using</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>Even though you can construct a function q satisfying hq by induction on <code>k</code> (since <code>range k</code> is (computably) finite you can avoid choice), invoking choice is more convenient.</p>",
        "id": 421714623,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1708021351
    },
    {
        "content": "<p>There's no reason to have the source equal to <code>Nat</code>, here's a free generalization:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">range</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">div</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n    <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 421732538,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708027882
    },
    {
        "content": "<p>Could be even more general if you put a <code>*</code> after that <code>Type</code> (or so I hear, I don't know what universes are)</p>",
        "id": 421732700,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1708027947
    },
    {
        "content": "<p>And the target could be anything for which <code>|</code> makes sense I guess (e.g. any commutative ring? Probably something even more general?)</p>",
        "id": 421733015,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708028065
    },
    {
        "content": "<p>Thanks to everyone for the helpful replies.</p>\n<p>It hadn't occurred to me that accessing the existential <code>h i r</code> could require choice.  However if I wanted to build a function with an infinite domain that used an existential to compute its value at each point, then the axiom of choice would indeed be necessary.  So it's not surprising that Lean restricts access to an existential in a function definition (even though in my case I'm only accessing it for a finite number of values in the domain).</p>\n<p>Thanks especially to Junyan for the pointer to the <code>choose</code> tactic, which seems super helpful here.  This is another tactic I didn't know about, and will add to my vocabulary.  :)</p>",
        "id": 421833097,
        "sender_full_name": "Adam Dingle",
        "timestamp": 1708080134
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/stuck.20proving.20divisibility.20theorem/near/421733015\">said</a>:</p>\n<blockquote>\n<p>And the target could be anything for which <code>|</code> makes sense I guess (e.g. any commutative ring? Probably something even more general?)</p>\n</blockquote>\n<p>Semigroups (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=semigroupDvd#doc\">docs#semigroupDvd</a>)</p>",
        "id": 421835377,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1708080870
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687151\">@Adam Dingle</span> the \"axiom of choice\" in lean's dependent type theory refers to the concept of getting data out of a proof, ie moving from the <code>Prop</code> universe to the <code>Type</code> universe. So going from \"there exists an x\" to \"here is the x\" uses the axiom of choice (or even from \"there exists a unique x\" to \"here is the x\"! This would not use AC in set theory). The usual set-theoretic axiom of choice follows from this principle. The reason it's a bit different in type theory is that type theory isolates the noncomputable part of the process. Even if you can prove there's a unique x with a property, you still don't have a formula for it in the sense of constructive mathematics, so the process of getting it is noncomputable.</p>",
        "id": 421843601,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708084187
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  This is informative and helpful.  Thanks!</p>",
        "id": 421852075,
        "sender_full_name": "Adam Dingle",
        "timestamp": 1708087847
    },
    {
        "content": "<p><a href=\"https://xenaproject.wordpress.com/2019/06/11/the-inverse-of-a-bijection/\">Here</a>'s an explicit example of a situation where you can prove there's a unique x with some property, but there's no known algorithm to figure out what the x is. Another example would be the function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> related to Waring's problem: it's certainly true that there exists a unique natural number N such that every sufficiently large natural is the sum of N natural cubes, but there are infinitely many naturals which aren't the sum of N-1 natural cubes, but right now humanity knows of no algorithm to figure out this N, all we know is that it's between 4 and 7. So Lean would need what it calls the axiom of choice to define the function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> described <a href=\"https://en.wikipedia.org/wiki/Waring%27s_problem\">here</a>, but really this is just another way of saying \"there's no known computer program which computes this function\" (indeed if there were then it probably wouldn't be an open problem to figure out <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo stretchy=\"false\">(</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G(3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mopen\">(</span><span class=\"mord\">3</span><span class=\"mclose\">)</span></span></span></span>.)</p>",
        "id": 421853237,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708088348
    },
    {
        "content": "<p>Kevin, thanks for the interesting examples.</p>\n<p>I've tried to continue my proof, but I'm a bit stuck again.</p>\n<p>Once again, I'm trying to prove that</p>\n<p>If c divides a_1, .., a_k, then c divides (a_1 · u_1 + ... + a_k · u_k) for all integers u_1, ..., u_k.</p>\n<p>(As Kevin and others have pointed out, I could generalize this in various ways, but I'm sticking to integers and indices 1..k in the interest of keeping things simple and concrete, since this is just an exercise.)</p>\n<p>And once again, here's my proof in English:</p>\n<p>===<br>\nBy the definition of divisibility, there exist integers q_1 .. q_k such that a_i = q_i · c for i = 1, ..., k. Then</p>\n<p>(a_1 · u_1 + ... + a_k · u_k) = (q_1 · c · u_1 + ... + q_k · c · u_k) = (q_1 · u_1 + ... + q_k · u_k) · c.</p>\n<p>And so c divides (a_1 · u_1 + ... + a_k · u_k).<br>\n===</p>\n<p>As Junyan pointed out, I can use <code>choose</code> to get the integers q_i.  After that, as the first step of the proof I'd like to show that</p>\n<p>(a_1 · u_1 + ... + a_k · u_k) = (q_1 · c · u_1 + ... + q_k · c · u_k)</p>\n<p>At first I thought I could write this equality as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∑</span><span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span><span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">q</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>However <code>q</code> has type <code>(i : ℕ) → i ∈ range k → ℤ</code>, so it needs evidence that <code>i</code> is a valid index.  And as far as I can tell no such evidence is available inside an instance of ∑.  So as a workaround, I've written</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">let</span> <span class=\"n\">q'</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">k</span> <span class=\"k\">then</span> <span class=\"n\">q</span> <span class=\"n\">i</span> <span class=\"n\">r</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>This feels awkward, but at least it allows me to write the sum using q'.  So here is where I am now:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">range</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">div</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n            <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"bp\">∑</span><span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">choose</span> <span class=\"n\">q</span> <span class=\"n\">hq</span> <span class=\"n\">using</span> <span class=\"n\">h</span>\n  <span class=\"k\">let</span> <span class=\"n\">q'</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">k</span> <span class=\"k\">then</span> <span class=\"n\">q</span> <span class=\"n\">i</span> <span class=\"n\">r</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n  <span class=\"n\">intro</span> <span class=\"n\">u</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span><span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span><span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">q'</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I can't immediately see how to prove that the sums are equal.  At the first <code>sorry</code> the proof state is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">ℤ</span>\n<span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span>\n<span class=\"n\">q</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">k</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span>\n<span class=\"n\">hq</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a_1</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">q</span> <span class=\"n\">i</span> <span class=\"n\">a_1</span>\n<span class=\"n\">q'</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">k</span> <span class=\"k\">then</span> <span class=\"n\">q</span> <span class=\"n\">i</span> <span class=\"n\">r</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n<span class=\"n\">u</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">q'</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>For any <code>i</code> in <code>range k</code>, <code>hq</code> tells me that a_i = c * q_i.  So really I'd like to make this substitution in the goal.  But to do that I need evidence that i ∈ range k, and I don't see how I can get to that.  Perhaps I have to fall back on proving that these sums are equal using induction up to k, but that feels heavy-handed.  Is there an easier way?</p>",
        "id": 421870988,
        "sender_full_name": "Adam Dingle",
        "timestamp": 1708094374
    },
    {
        "content": "<p>I just figured out that instead of <code>choose</code> I can use <code>choose!</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">choose</span><span class=\"bp\">!</span> <span class=\"n\">q</span> <span class=\"n\">hq</span> <span class=\"n\">using</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>That gives me <code>q: ℕ → ℤ</code>, which is great - I no longer need the awkward <code>q'</code>.</p>\n<p>However I'm still unsure about how to substitute into the goal, because even with this change <code>hq</code> will still need evidence that <code>i ∈ range k</code>.</p>",
        "id": 421872534,
        "sender_full_name": "Adam Dingle",
        "timestamp": 1708094848
    },
    {
        "content": "<p>Aha - I just discovered this theorem in the library:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Finset.sum_congr</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>  <span class=\"o\">{</span><span class=\"n\">s₁</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span>  <span class=\"o\">{</span><span class=\"n\">s₂</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span>  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span>  <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">β</span><span class=\"o\">]</span>  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s₁</span> <span class=\"bp\">=</span> <span class=\"n\">s₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s₂</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Finset.sum</span> <span class=\"n\">s₁</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">Finset.sum</span> <span class=\"n\">s₂</span> <span class=\"n\">g</span>\n</code></pre></div>\n<p>This looks like what I need.  I'll try to use it to make the proof work.</p>",
        "id": 421873990,
        "sender_full_name": "Adam Dingle",
        "timestamp": 1708095311
    },
    {
        "content": "<p>Re where you are now: what are your imports? Your code doesn't work for me as it stands, and different imports making it work can have different behaviours.</p>",
        "id": 421883504,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708098052
    },
    {
        "content": "<p>Actually I just completed the proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">range</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">div</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n            <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"bp\">∑</span><span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">choose</span><span class=\"bp\">!</span> <span class=\"n\">q</span> <span class=\"n\">hq</span> <span class=\"n\">using</span> <span class=\"n\">h</span>\n  <span class=\"n\">intro</span> <span class=\"n\">u</span>\n  <span class=\"k\">let</span> <span class=\"n\">he</span> <span class=\"o\">:=</span>\n    <span class=\"k\">calc</span> <span class=\"bp\">∑</span><span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span>\n\n     <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span><span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">apply</span> <span class=\"n\">Finset.sum_congr</span> <span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n        <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n        <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"n\">mul_assoc</span><span class=\"o\">]</span>\n\n     <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"bp\">∑</span><span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">q</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Finset.mul_sum</span><span class=\"o\">]</span>\n\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 421886042,
        "sender_full_name": "Adam Dingle",
        "timestamp": 1708098783
    },
    {
        "content": "<p>Here's a <code>calc</code>-free proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span> <span class=\"c1\">-- not just Finset.range, we want more!</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">dvd</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"c1\">-- `div` is `/`, there is no `/` mentioned</span>\n    <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"bp\">∑</span><span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"c1\">-- move `u` before the colon to save `intro u`</span>\n  <span class=\"n\">choose</span><span class=\"bp\">!</span> <span class=\"n\">q</span> <span class=\"n\">hq</span> <span class=\"n\">using</span> <span class=\"n\">h</span>\n  <span class=\"n\">use</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">q</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_sum</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">sum_congr</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">intros</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"n\">mul_assoc</span><span class=\"o\">]</span>\n  <span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 421889804,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708099421
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/stuck.20proving.20divisibility.20theorem/near/421889804\">said</a>:</p>\n<blockquote>\n<p>Here's a <code>calc</code>-free proof:</p>\n</blockquote>\n<p>Thanks for the simplified proof!  I'll see what I can learn from it.  :)</p>",
        "id": 421890855,
        "sender_full_name": "Adam Dingle",
        "timestamp": 1708099681
    },
    {
        "content": "<p>Here's the proof in the correct generality: note that the same proof still works, using concrete types like Nat just (in my opinion) makes things more confusing (because there's more ways to go wrong).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Finset.dvd_sum'</span>\n    <span class=\"c1\">-- source</span>\n    <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"c1\">-- target</span>\n    <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"bp\">∑</span><span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- exactly the same proof (mutatis mutandis)</span>\n  <span class=\"n\">choose</span><span class=\"bp\">!</span> <span class=\"n\">q</span> <span class=\"n\">hq</span> <span class=\"n\">using</span> <span class=\"n\">h</span>\n  <span class=\"n\">use</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">q</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_sum</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">sum_congr</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">intros</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"n\">mul_assoc</span><span class=\"o\">]</span>\n  <span class=\"n\">assumption</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- your application</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">dvd</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"c1\">-- `div` is `/`, there is no `/` mentioned</span>\n    <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"bp\">∑</span><span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Finset.dvd_sum'</span>\n  <span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 421891251,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708099802
    },
    {
        "content": "<p>And here's the proof using the lemmas mathlib already has:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">dvd</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"bp\">∑</span><span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Finset.dvd_sum</span>\n  <span class=\"n\">peel</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">hn</span> <span class=\"n\">h</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Int.dvd_trans</span> <span class=\"n\">h</span> <span class=\"o\">⟨</span><span class=\"n\">u</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 421892222,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708100057
    },
    {
        "content": "<p>Using Kevin's version with a general indexing set (which often works better in Lean than using <code>range</code> or something of the like) you can also use Finset induction, (iirc <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.induction_on#doc\">docs#Finset.induction_on</a>) which is a much more natural proof. I'm not at a computer at the current moment but happy to write this up if you'd like an example</p>",
        "id": 421892747,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1708100208
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/113489-new-members/topic/stuck.20proving.20divisibility.20theorem/near/421892747\">said</a>:</p>\n<blockquote>\n<p>Using Kevin's version with a general indexing set (which often works better in Lean than using <code>range</code> or something of the like) you can also use Finset induction, (iirc <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.induction_on#doc\">docs#Finset.induction_on</a>) which is a much more natural proof. I'm not at a computer at the current moment but happy to write this up if you'd like an example</p>\n</blockquote>\n<p>Thanks.  If you'd be willing to write this version up, I'd be happy to see it - I am relatively new to Lean and learn something from every proof I see.  :)</p>",
        "id": 421905784,
        "sender_full_name": "Adam Dingle",
        "timestamp": 1708104412
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Finset.dvd_sum'</span>\n    <span class=\"c1\">-- source</span>\n    <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"c1\">-- target</span>\n    <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"bp\">∑</span><span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">classical</span> <span class=\"c1\">-- we need this for `Finset.induction_on`</span>\n  <span class=\"n\">induction</span> <span class=\"n\">S</span> <span class=\"n\">using</span> <span class=\"n\">Finset.induction_on</span>\n  <span class=\"n\">case</span> <span class=\"n\">empty</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span>\n  <span class=\"n\">case</span> <span class=\"n\">insert</span> <span class=\"n\">h</span> <span class=\"n\">k</span> <span class=\"n\">S</span> <span class=\"n\">hkS</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">ih</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"n\">hi</span> <span class=\"bp\">↦</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">mem_insert_of_mem</span> <span class=\"n\">hi</span><span class=\"o\">)</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Finset.sum_insert</span> <span class=\"n\">hkS</span><span class=\"o\">]</span>\n    <span class=\"n\">refine</span> <span class=\"n\">dvd_add</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"n\">ih</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">mem_insert_self</span> <span class=\"n\">k</span> <span class=\"n\">S</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mul_right</span> <span class=\"n\">_</span>\n\n<span class=\"c1\">-- with a bit more detail:</span>\n<span class=\"kd\">example</span>\n    <span class=\"c1\">-- source</span>\n    <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"c1\">-- target</span>\n    <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">c</span> <span class=\"bp\">∣</span> <span class=\"bp\">∑</span><span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">classical</span> <span class=\"c1\">-- we need this for `Finset.induction_on`</span>\n  <span class=\"c1\">-- when you get complaints about `DecidableEq`</span>\n  <span class=\"c1\">-- being needed _whilst already in a proof_, you should try `classical` beforehand.</span>\n  <span class=\"c1\">-- The situation is a bit more difficult if you're still writing the statement.</span>\n  <span class=\"c1\">-- I tried to use the `induction` and the last goal was `DecidableEq α`, hence I added `classical`.</span>\n  <span class=\"n\">induction</span> <span class=\"n\">S</span> <span class=\"n\">using</span> <span class=\"n\">Finset.induction_on</span>\n  <span class=\"n\">case</span> <span class=\"n\">empty</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span>\n  <span class=\"c1\">-- `simp` is a \"simplifier\" - this does not always mean it makes your</span>\n  <span class=\"c1\">-- expressions simpler, but it does mean it's often worth trying on</span>\n  <span class=\"c1\">-- goals that are \"structurally\" likely to be true.</span>\n  <span class=\"n\">case</span> <span class=\"n\">insert</span> <span class=\"n\">h</span> <span class=\"n\">k</span> <span class=\"n\">S</span> <span class=\"n\">hkS</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"c1\">-- I'm not sure why `ih` has this weird hypothesis, but it's easy to fix; let's do that first.</span>\n    <span class=\"c1\">-- I did not remember the name of `mem_insert_of_mem` (although it's not hard),</span>\n    <span class=\"c1\">-- but instead I originally wrote:</span>\n    <span class=\"c1\">-- `specialize ih (fun i hi ↦ h i &lt;| by exact?)`</span>\n    <span class=\"c1\">-- (&lt;| basically inserts brackets around the next expression)</span>\n    <span class=\"c1\">-- and that found it. You can also use:</span>\n    <span class=\"c1\">-- `specialize ih (fun i hi ↦ h i &lt;| exact?%)`</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">ih</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"n\">hi</span> <span class=\"bp\">↦</span> <span class=\"n\">h</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">mem_insert_of_mem</span> <span class=\"n\">hi</span><span class=\"o\">)</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Finset.sum_insert</span> <span class=\"n\">hkS</span><span class=\"o\">]</span>\n    <span class=\"c1\">-- Instead of `specialize`ing earlier, I could also have written:</span>\n    <span class=\"c1\">--  `refine dvd_add ?_ &lt;| ih (fun i hi ↦ h i &lt;| mem_insert_of_mem hi)`</span>\n    <span class=\"n\">refine</span> <span class=\"n\">dvd_add</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"n\">ih</span>\n    <span class=\"c1\">-- I could've found this by first writing `specialize h k exact?%` and then putting in</span>\n    <span class=\"c1\">-- what `exact?%` found; this actually gives you a slightly different suggestion</span>\n    <span class=\"c1\">-- try figure out what that one means!</span>\n    <span class=\"c1\">-- I then just did `exact?` after, and it found the right thing. I then tidied it using</span>\n    <span class=\"c1\">-- \"dot notation\"; the divides symbol is called `Dvd.dvd`, so you're allowed to use a hypothesis</span>\n    <span class=\"c1\">-- `h : something ∣ something_else` with a method called `Dvd.dvd.foo` by writing `h.foo`.</span>\n    <span class=\"c1\">-- To clarify: my original proof was:</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> specialize h k exact?%</span>\n<span class=\"cm\">      exact? -/</span>\n    <span class=\"c1\">-- which soon turned into:</span>\n    <span class=\"c\">/-</span>\n<span class=\"cm\">    specialize h k &lt;| mem_insert.mpr (Or.inl rfl)</span>\n<span class=\"cm\">    exact Dvd.dvd.mul_right h (u k)</span>\n<span class=\"cm\">    -/</span>\n    <span class=\"c1\">-- and then tidied it a bit more to: (I changed the theorem to use something a bit more designed for this)</span>\n    <span class=\"c1\">-- Note that I can skip `u k` and instead write `_` because Lean's elaborator sees what it must be.</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">mem_insert_self</span> <span class=\"n\">k</span> <span class=\"n\">S</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mul_right</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 421913628,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1708107145
    },
    {
        "content": "<p>Kevin, why are you providing a calc free proof? calc proofs are much easier to read.</p>",
        "id": 421915546,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1708107907
    },
    {
        "content": "<p>Because it's a beginner who showed some interest so I thought I'd show them another way</p>",
        "id": 421917760,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708108743
    }
]