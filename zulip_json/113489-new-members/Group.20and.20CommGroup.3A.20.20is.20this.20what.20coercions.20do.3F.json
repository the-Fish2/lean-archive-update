[
    {
        "content": "<p>Kia ora <span aria-label=\"nerd\" class=\"emoji emoji-1f913\" role=\"img\" title=\"nerd\">:nerd:</span></p>\n<p>My code is below, but my question is this: If I prove a bunch of theorems about groups, then do I have to write some sort of coercion to use those theorems to prove facts about Abelian groups? </p>\n<p>With the following definitions I prove some elementary theorems in group theory: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Magma are a type (set) with a single binary operation.</span>\n<span class=\"kd\">class</span> <span class=\"n\">Magma</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">bop</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Magma</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">HMul</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">hMul</span> <span class=\"o\">:=</span> <span class=\"n\">Magma.bop</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Magma</span>\n\n<span class=\"c1\">-- Semirgroups are a Magma whose binary operation is associative.</span>\n<span class=\"kd\">class</span> <span class=\"n\">Semigroup</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Magma</span> <span class=\"n\">G</span> <span class=\"n\">where</span>\n  <span class=\"n\">bop_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Semigroup</span>\n\n<span class=\"c1\">-- Monoids are Semigroups with an identity.</span>\n<span class=\"kd\">class</span> <span class=\"n\">Monoid</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Semigroup</span> <span class=\"n\">G</span> <span class=\"n\">where</span>\n  <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">G</span>\n  <span class=\"n\">id_bop</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Monoid</span>\n\n<span class=\"c1\">-- Groups are Monoids with inverses.</span>\n<span class=\"kd\">class</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Monoid</span> <span class=\"n\">G</span> <span class=\"n\">where</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span>\n  <span class=\"n\">inv_bop</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">e</span>\n\n<span class=\"kd\">postfix</span><span class=\"o\">:</span> <span class=\"mi\">100</span> <span class=\"s2\">\" ⁻¹ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Group.inv</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Group</span>\n</code></pre></div>\n<p>Including the fact that <code>∀ x : G, x * e = x </code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">bop_id</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n    <span class=\"kd\">by</span>\n      <span class=\"n\">intro</span> <span class=\"n\">g</span>\n      <span class=\"k\">calc</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">e</span>\n        <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"o\">)</span>     <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">inv_bop</span><span class=\"o\">]</span>\n        <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">g</span>     <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">bop_assoc</span><span class=\"o\">]</span>\n        <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">e</span> <span class=\"bp\">*</span> <span class=\"n\">g</span>             <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">bop_inv</span><span class=\"o\">]</span>\n        <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">g</span>                 <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">id_bop</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>When I add in the class of Abelian groups </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Abelian Groups are Groups whose binary operation is commutative.</span>\n<span class=\"kd\">class</span> <span class=\"n\">AbelianGroup</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Group</span> <span class=\"n\">G</span> <span class=\"n\">where</span>\n  <span class=\"n\">bop_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">x</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">AbelianGroup</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">commbop_id</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">AbelianGroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n    <span class=\"kd\">by</span>\n      <span class=\"n\">intro</span> <span class=\"n\">g</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">bop_comm</span><span class=\"o\">,</span> <span class=\"n\">id_bop</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I can prove the same theorem with a simpler argument. But If I wanted to employ all the theorems I have proven about groups more generally, then do I need to employ a coercion from AbelianGroup to Group? If so, how does that work? </p>\n<p>Thanks!</p>",
        "id": 418759026,
        "sender_full_name": "Robert Culling",
        "timestamp": 1706583525
    },
    {
        "content": "<p>If you use an instance implicit argument (ex <code>theorem bop_id (G : Type) [Group G] : ...</code>) then lean will use the <code>extends</code> clause that you have in your <code>AbelianGroup</code> class definition to automatically synthesize a <code>Group</code> instance from an <code>AbelianGroup</code> instance, and you should get your theorems for free.</p>",
        "id": 418777300,
        "sender_full_name": "N Gelwan",
        "timestamp": 1706597607
    },
    {
        "content": "<p>I think this covers it: <a href=\"https://leanprover-community.github.io/mathematics_in_lean/C07_Hierarchies.html#basics\">https://leanprover-community.github.io/mathematics_in_lean/C07_Hierarchies.html#basics</a></p>",
        "id": 418777499,
        "sender_full_name": "N Gelwan",
        "timestamp": 1706597749
    }
]