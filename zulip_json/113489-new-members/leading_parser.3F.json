[
    {
        "content": "<p>People, where can I find more about leading_parser? It appears many times in the source but I couldn't find mentions to it in any of the books, and its definition (???) in <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/BuiltinNotation.lean#L162\">Lean/Elab/BuiltinNotation.lean</a> is too difficult to read (IMO) and doesn't have comments...</p>\n<p>Thanks in advance! <span aria-label=\"oh no\" class=\"emoji emoji-1f615\" role=\"img\" title=\"oh no\">:oh_no:</span></p>",
        "id": 438403571,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1715618103
    },
    {
        "content": "<p>Aha, I just found <a href=\"#narrow/stream/113489-new-members/topic/Leading.20parser/near/431690866\">this message</a> by <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>! Let me change my question...</p>\n<p>Where can I find examples of how to translate calls to \"leading_parser\" to calls to \"syntax\"?</p>",
        "id": 438405257,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1715618652
    },
    {
        "content": "<p>Usually it's \"<code>&gt;&gt;</code> becomes space and <code>f x y z</code> becomes <code>f(x, y, z)</code>\" though sometimes the parser name for <code>syntax</code> can be a little different.</p>\n<p>There are also transformations like <code>many p</code> becomes <code>p*</code> and <code>many1 p</code> becomes <code>p+</code>, among some others.</p>",
        "id": 438418501,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715623152
    },
    {
        "content": "<p>Hi, another question...</p>\n<p>I decided to inspect the objects created by leading_parser, and I got this, after a lot of trial and error:</p>\n<div class=\"codehilite\" data-code-language=\"import\"><pre><span></span><code>import Lean.Parser.Types\nnamespace Lean\nnamespace Parser\ndef foo := leading_parser \"bar \"\n#check foo\n#check foo.info\n#check foo.info.firstTokens\n\ndef a := foo.info.firstTokens\ndef b := Lean.Parser.FirstTokens.tokens [\"$\", \"bar\"]\n#eval a\n#eval b\n</code></pre></div>\n<p>Here a and b are \"equal\" but not \"eq\".</p>\n<p>Is there an easy way to print the structure of a? My guess - as a newbie - is: \"no because FirstTokens doesn't derive Repr, but there are workarounds using instances\".</p>\n<p>Is that right? Is it possible to make FirstTokens an instance of Repr? If yes, how?</p>\n<p>Thanks in advance!</p>",
        "id": 439160716,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1715928231
    },
    {
        "content": "<p>What's the question about <code>a</code> and <code>b</code> not being \"eq\"? They're equal according to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 439289936,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715978962
    },
    {
        "content": "<p>(With <code>import Lean</code> imported, <code>#eval a</code> prints <code>[$, bar]</code>. I'm not sure what you're seeing, since your mwe fails on <code>leading_parser</code> for me on a version near Lean 4.8.0-rc1)</p>",
        "id": 439290163,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715979096
    },
    {
        "content": "<blockquote>\n<p>no because FirstTokens doesn't derive Repr, but there are workarounds using instances</p>\n</blockquote>\n<p>Note that \"deriving Repr\" means \"try to automatically create a Repr instance\". Mentioning that in case you think instances are some sort of workaround.</p>",
        "id": 439290321,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715979179
    },
    {
        "content": "<p>This is the easiest way to see what <code>leading_parser</code> is doing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"n\">leading_parser</span> <span class=\"s2\">\"bar \"</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">foo</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">def Lean.Parser.foo : Parser :=</span>\n<span class=\"cm\">withCache `Lean.Parser.foo</span>\n<span class=\"cm\">  (withAntiquot (mkAntiquot \"foo\" `Lean.Parser.foo true) (leadingNode `Lean.Parser.foo 1024 (symbol \"bar \")))</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>It's a macro that expands to that. The key thing it does is embed the declaration name for <code>foo</code> into itself, in the <code>leadingNode</code> parser combinator. That's what creates a <code>Syntax.node</code> with <code>Lean.Parser.foo</code> as the kind.</p>",
        "id": 439290520,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715979296
    },
    {
        "content": "<p>The antiquote business is for parsing <code> `(... $x:foo ...)</code> in syntax quotations in syntactically correct locations.</p>",
        "id": 439290569,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715979342
    },
    {
        "content": "<p>About \"eq\" and \"equal\", I was thinking about this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">eq</span>    <span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span>  <span class=\"bp\">;-&gt;</span> <span class=\"n\">nil</span>\n<span class=\"o\">(</span><span class=\"n\">equal</span> <span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span>  <span class=\"bp\">;-&gt;</span> <span class=\"n\">t</span>\n</code></pre></div>\n<p>It didn't occur to me that we could test \"equal\"ity in Lean using \"<code>example : a = b := rfl</code>\"... neat!</p>",
        "id": 439313632,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1715995923
    },
    {
        "content": "<p>Now about the output of \"<code>#print foo</code>\": wow and thanks! It works here, but I think that I need to understand other things before understanding that... and my guess is that would be a good idea to start by understand how \"<code>deriving Repr</code>\" works in a simple case. I tried this,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">myNat</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span>             <span class=\"o\">:</span> <span class=\"n\">myNat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">myNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">myNat</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">my1</span> <span class=\"o\">:=</span> <span class=\"n\">myNat.succ</span> <span class=\"n\">myNat.zero</span>\n<span class=\"k\">#check</span> <span class=\"n\">my1</span>\n<span class=\"k\">#eval</span>  <span class=\"n\">my1</span>\n<span class=\"k\">#print</span> <span class=\"n\">my1</span>\n<span class=\"k\">#check</span> <span class=\"n\">repr</span> <span class=\"n\">my1</span>\n<span class=\"k\">#eval</span>  <span class=\"n\">repr</span> <span class=\"n\">my1</span>\n<span class=\"k\">#print</span> <span class=\"n\">repr</span> <span class=\"n\">my1</span>\n<span class=\"k\">#check</span> <span class=\"n\">Std.Format</span>\n</code></pre></div>\n<p>and then:</p>\n<p>1) the method \"<code>repr</code>\" for the type <code>myNat</code> is not in a super-obvious place, like in <code>myNat.repr</code>,</p>\n<p>2) the output of \"<code>#check repr my1</code>\" is \"<code>repr my1 : Std.Format</code>\", and I don't have test snippets (yet) for the class <a href=\"https://github.com/leanprover/lean4/blob/master/src/Init/Data/Format/Basic.lean\">Std.Format</a>,</p>\n<p>3) but I read some parts of the source starting by \"<a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Deriving/Repr.lean#L118\">mkReprInstanceHandler</a>\" and I found references to \"<a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/MonadEnv.lean#L27\">isInductive</a>\" and \"<a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Structure.lean#L79\">getStructureFields</a>\" - they look very useful, can we start by them? If yes, question: how do I call \"<code>isInductive</code>\" and \"<code>getStructureFields</code>\" on the \"<code>myNat</code>\" or on the \"<code>my1</code>\" of the example above?</p>\n<p>Thanks in advance!</p>",
        "id": 439313997,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1715996278
    },
    {
        "content": "<p>Here's how you can get the name of the instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">Repr</span> <span class=\"n\">myNat</span>\n<span class=\"c1\">-- instReprMyNat</span>\n</code></pre></div>",
        "id": 439320742,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1716002804
    },
    {
        "content": "<p>Unfortunately you reach a dead end quick because the deriving handler defines a constant with an inaccessible name:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"n\">instReprMyNat</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">def instReprMyNat : Repr myNat :=</span>\n<span class=\"cm\">{ reprPrec := reprmyNat✝ }</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 439320794,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1716002877
    },
    {
        "content": "<p>Though if you set <code>set_option trace.Elab.command true</code> you can see what <code>deriving</code> constructs.</p>",
        "id": 439320917,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1716003000
    },
    {
        "content": "<p>Here, if you want to see:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">reprmyNat</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">myNat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">prec</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Format</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">myNat.zero</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">Repr.addAppParen</span>\n      <span class=\"o\">(</span><span class=\"n\">Format.group</span> <span class=\"o\">(</span><span class=\"n\">Format.nest</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">prec</span> <span class=\"bp\">&gt;=</span> <span class=\"n\">max_prec</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Std.Format.text</span> <span class=\"s2\">\"myNat.zero\"</span><span class=\"o\">)))</span> <span class=\"n\">prec</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">@</span><span class=\"n\">myNat.succ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">Repr.addAppParen</span>\n      <span class=\"o\">(</span><span class=\"n\">Format.group</span>\n        <span class=\"o\">(</span><span class=\"n\">Format.nest</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">prec</span> <span class=\"bp\">&gt;=</span> <span class=\"n\">max_prec</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">Std.Format.text</span> <span class=\"s2\">\"myNat.succ\"</span> <span class=\"bp\">++</span> <span class=\"n\">Format.line</span> <span class=\"bp\">++</span> <span class=\"n\">reprmyNat</span> <span class=\"n\">a</span> <span class=\"n\">max_prec</span><span class=\"o\">)))</span>\n      <span class=\"n\">prec</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Repr</span> <span class=\"n\">myNat</span> <span class=\"n\">where</span>\n  <span class=\"n\">reprPrec</span> <span class=\"o\">:=</span> <span class=\"n\">reprmyNat</span>\n</code></pre></div>",
        "id": 439321084,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1716003146
    },
    {
        "content": "<p>Repr instances aren't so interesting. They're just code to turn data into some string representation (using <code>Format</code> so that indentation is taken care of). I would not suggest going deep into the derive handler unless you're willing to venture forth into the less-documented parts of Lean. (You might look at the <a href=\"https://leanprover-community.github.io/lean4-metaprogramming-book/\">Lean 4 Metaprogramming Book</a> to get an idea of how some of the system works, but it's not comprehensive yet.)</p>\n<p><code>Repr</code> doesn't have anything to do with <code>#print</code>. What <code>#print</code> does is pretty print a declaration, whose value is an <code>Expr</code>.</p>",
        "id": 439321191,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1716003263
    },
    {
        "content": "<p>Re Lisp-like eq vs equal, in Lean the main equality type Eq is more like equal, and there's no such thing as eq unless you are willing to do <code>unsafe</code> things. The Eq is true mathematical equality. There's also BEq for user-defined equality operations.</p>",
        "id": 439321339,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1716003477
    }
]