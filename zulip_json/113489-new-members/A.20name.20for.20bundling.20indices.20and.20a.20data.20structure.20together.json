[
    {
        "content": "<p>I feel like this happens a lot, but I've never heard a name for the process. It comes down to passing around indices into a data structure, but stating properties about the parts of a data structure the indices point at.</p>\n<p>I've been building out some helper functions with the idea to view a dependent pair like <code>(l : List α) × Finset (Fin l.length)</code> as a <code>List α</code> except that indexing is done though the set of indices in the pair.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Char</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">l.length</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n<span class=\"c1\">-- index the list at the 4'th smallest ℕ in the Finset,</span>\n<span class=\"k\">#check</span> <span class=\"n\">foo</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"c1\">-- Char</span>\n<span class=\"c1\">-- the Finset contains an index that references 'a' in the list</span>\n<span class=\"k\">#check</span> <span class=\"sc\">'a'</span> <span class=\"bp\">∈</span> <span class=\"n\">foo</span> <span class=\"c1\">-- Prop</span>\n</code></pre></div>\n<p>This has been making it a bit easier notionally to talk about parts of a larger array. So I can write <code>(l,s)[i]</code> instead of <code>l[s.sort[i]]</code> especially in scenarios where it's nice to ignore that some term is actually a dependent pair.</p>\n<p>This seems to be the sort of thing many algorithms use (esp when doing recursion with arrays). When I'm not trying to prove anything about what's happening, I just pass around a list of indices and a data structure and just hope to maintain the necessary invariants ambiently. </p>\n<p>Is there a name for this?</p>",
        "id": 420500355,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1707411209
    },
    {
        "content": "<p>What's the purpose of keeping the indices separate? Is the idea that the array is large and sparsely populated? Or are your index Finsets more like different \"views\" on shared data?</p>",
        "id": 420585435,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1707453475
    },
    {
        "content": "<p>if it's a sparse array thing, that's kind of like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finsupp#doc\">docs#Finsupp</a></p>",
        "id": 420585537,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1707453558
    },
    {
        "content": "<p>instead of a list it's a function from indices to values</p>",
        "id": 420585608,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1707453616
    },
    {
        "content": "<p>with the potential downside that storing 0 is the same as storing nothing at all (and the type of values has to have a Zero element)</p>",
        "id": 420585688,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1707453710
    },
    {
        "content": "<p>Yeah, hmmm, this might be a bit of an <a href=\"https://xyproblem.info/\">XY problem</a>.</p>\n<p>The problem I've been working through is proving properties about sudoku boards. Generally, the properties of a region of the board can be stated without carrying around reference to indices. So the first row doesn't need to the be the first 9 indices, I can just make a corresponding list of cells and prove stuff about the the first row that way.</p>\n<p>But at least for Sudoku, it'll end up mattering which cell in the bigger board has a certain property as that will matter for 2 other regions (a column and a box) moving forward. </p>\n<p>So without passing around indices, I'm writing strange looking theorems connecting the proofs back to the original board. So in a sense, it becomes an API issue. I want to be able to state what happening at roughly the level of abstraction that I see human Sudoku solving techniques described at. </p>\n<hr>\n<p>Though more generally, I think this happens in algorithms where you keep pointers into an array. An undergrad programming problem might be to decide if any two numbers with a specific sum exists in a sorted array (<code>[1, 1, 2, 3, 4, 6, 8, 9]</code> with the sum being <code>11</code> is true for <code>2,9</code> or <code>3,8</code> for example ). A technique you'd expect here is to start with a pointer at either end of the array and move them inward until they you find the sum or they meet.</p>\n<p>If you want to prove that this algorithm always terminates with the correct answer, there's a nice recursive proof (your array gets smaller at each step), but if you then also want to also know which indices the summed numbers where found at, it starts to get a bit messier. Your recursive call effectively passes those pointers around. It feels nice to bundle the array and pointers together as they logically only matter as a unit. Also, a longer proof may look cleaner in places that way? I'm not sure.</p>",
        "id": 420666718,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1707490082
    },
    {
        "content": "<p>I think your description of different \"views\" on shared data is pretty much spot on.</p>",
        "id": 420697975,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1707499413
    }
]