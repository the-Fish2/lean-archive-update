[
    {
        "content": "<p>In the <a href=\"https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#classical-logic\">Classical Logic section of Theorem Proving in Lean 4</a> there is an exercise \"show that <code>em</code> can be proved from <code>dne</code>\".  <span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> provides several proof versions on <a href=\"https://proofassistants.stackexchange.com/questions/1856/lean4-exercise-double-negation-implies-law-of-excluded-middle\">Proof Assistant's Stack Exchange</a> and from these, <span class=\"user-mention\" data-user-id=\"250110\">@ZHAO Jiecheng</span> rewrote the proof as a one-liner as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">dne_implies_em</span> <span class=\"o\">(</span><span class=\"n\">dne</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"bp\">¬¬</span><span class=\"n\">p</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">p</span><span class=\"o\">)):</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"o\">:=</span>\n  <span class=\"n\">dne</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">Or.inr</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">hp</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">Or.inl</span> <span class=\"n\">hp</span><span class=\"o\">))))</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">dne_implies_em</span> <span class=\"c1\">-- dne_implies_em {p : Prop} (dne : ∀ {p : Prop}, ¬¬p → p) : p ∨ ¬p</span>\n</code></pre></div>\n<p>The one-liner is beautifully compact but hard to read.  I broke it down into its components as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">dne</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"bp\">¬¬</span><span class=\"n\">p</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">p</span><span class=\"o\">))</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">))</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">Or.inl</span> <span class=\"n\">hp</span><span class=\"o\">)</span> <span class=\"c1\">-- h (Or.inl hp) : False</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Or.inr</span> <span class=\"k\">fun</span> <span class=\"n\">hp</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">Or.inl</span> <span class=\"n\">hp</span><span class=\"o\">)</span> <span class=\"c1\">-- Or.inr fun hp =&gt; h (Or.inl hp) : ?m.107 ∨ (p → False)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">h</span> <span class=\"c1\">-- h : ¬(p ∨ ¬p)</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">Or.inr</span> <span class=\"k\">fun</span> <span class=\"n\">hp</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">Or.inl</span> <span class=\"n\">hp</span><span class=\"o\">))</span> <span class=\"c1\">-- Or.inr fun hp =&gt; h (Or.inl hp) : ?m.144 ∨ (p → False)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">Or.inr</span> <span class=\"k\">fun</span> <span class=\"n\">hp</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">Or.inl</span> <span class=\"n\">hp</span><span class=\"o\">))</span> <span class=\"c1\">-- h (Or.inr fun hp =&gt; h (Or.inl hp)) : False</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">term</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">h</span> <span class=\"o\">(</span>\n      <span class=\"n\">Or.inr</span> <span class=\"o\">(</span>\n        <span class=\"k\">fun</span> <span class=\"n\">hp</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">Or.inl</span> <span class=\"n\">hp</span><span class=\"o\">)</span>\n      <span class=\"o\">)</span>\n    <span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">term</span> <span class=\"c1\">-- term (p : Prop) (h : ¬(p ∨ ¬p)) : False</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">term</span> <span class=\"n\">p</span> <span class=\"c1\">-- term p : ¬(p ∨ ¬p) → False</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">dne</span> <span class=\"o\">(</span><span class=\"n\">term</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"c1\">-- dne (term p) : p ∨ ¬p</span>\n</code></pre></div>\n<p>From Lean 3 exercises I find I am more comfortable with verbose tactic-mode proofs than with dense λ-style proofs (what is the adverb for these?).  I'm not sure how to translate these separately <code>#check</code>ed bits into a tactic-style proof. I hope to learn about that in a <a href=\"https://lean-lang.org/theorem_proving_in_lean4/tactics.html\">later section</a>.</p>",
        "id": 410215712,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1703721980
    },
    {
        "content": "<p>Term proofs can generally be turned into a sequence of <code>intro</code> and <code>apply</code>/<code>exact</code>/<code>refine</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">dne_implies_em</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">dne</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"bp\">¬¬</span><span class=\"n\">p</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">dne</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hp</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hp</span>\n</code></pre></div>",
        "id": 410215991,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703722202
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>. I was also looking for inspiration in the <a href=\"https://proofwiki.org/wiki/Double_Negation_Elimination_implies_Law_of_Excluded_Middle/Proof_1\">ProofWiki version</a>.  I wonder if MathLib obsoletes ProofWiki, except that the ProofWiki version pretty-prints (manually) into a possibly easier to comprehend series of steps:<br>\n<a href=\"/user_uploads/3121/XDAYBFTAtPXkR6WH9yl9_rAs/image.png\">image.png</a><br>\nAnother idea would be to write a pretty-printer for Lean functional proofs that produces something like the ProofWiki tableau method table.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/XDAYBFTAtPXkR6WH9yl9_rAs/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/XDAYBFTAtPXkR6WH9yl9_rAs/image.png\"></a></div>",
        "id": 410301798,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1703773909
    },
    {
        "content": "<p>Try the <code>#explode</code> command</p>",
        "id": 410304295,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703775164
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>.  What do I need to import to get this to work in Lean 4 playground?  It says \"expected token\" in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">dne_implies_em</span> <span class=\"o\">(</span><span class=\"n\">dne</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"bp\">¬¬</span><span class=\"n\">p</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">p</span><span class=\"o\">)):</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"o\">:=</span>\n  <span class=\"n\">dne</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">Or.inr</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">hp</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">Or.inl</span> <span class=\"n\">hp</span><span class=\"o\">))))</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">dne_implies_em</span> <span class=\"c1\">-- dne_implies_em {p : Prop} (dne : ∀ {p : Prop}, ¬¬p → p) : p ∨ ¬p</span>\n\n<span class=\"bp\">#</span><span class=\"n\">explode</span> <span class=\"n\">dne_implies_em</span> <span class=\"c1\">-- expected token</span>\n</code></pre></div>\n<p>Also the <code>#check</code> is blue undersquiggled but the <code>#explode</code> is black with a red caret.<br>\n<a href=\"/user_uploads/3121/eHZ8_tqaYUaa0mGT9ybu8TPf/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/eHZ8_tqaYUaa0mGT9ybu8TPf/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/eHZ8_tqaYUaa0mGT9ybu8TPf/image.png\"></a></div>",
        "id": 410312253,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1703778890
    },
    {
        "content": "<p><code>import Mathlib.Tactic.Common</code> might be sufficient</p>",
        "id": 410356846,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703805943
    },
    {
        "content": "<p><code>import Mathlib.Tactic.Explode</code> imports just that command</p>",
        "id": 410356959,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703805984
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> the second one works.  Importing <code>Common</code> doesn't import <code>Explode</code>.</p>",
        "id": 410382601,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1703820395
    }
]