[
    {
        "content": "<p>I have a quantity which I want to prove is zero, but in my hypothesis, the terms of the equation are multiplied by a vector, using both <code>smul</code> and <code>mulVec</code>. Is there a way to factor out both types of multiplication at once? More specifically, I wish to transform this: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"mi\">1</span> <span class=\"bp\">*ᵥ</span> <span class=\"n\">e</span> <span class=\"bp\">+</span> <span class=\"n\">l</span> <span class=\"bp\">•</span> <span class=\"n\">e</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">•</span> <span class=\"n\">e</span> <span class=\"bp\">-</span> <span class=\"bp\">↑</span><span class=\"n\">d</span> <span class=\"bp\">*ᵥ</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>into this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">l</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">l</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">d</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>Here is an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> representing the context of this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.StronglyRegular</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.Matrix.Spectrum</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.Eigenspace.Basic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">SimpleGraph</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">G.Adj</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">RCLike</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">Matrix</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">he</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">Module.End.eigenspace</span> <span class=\"o\">(</span><span class=\"n\">Matrix.toLin'</span> <span class=\"o\">(</span><span class=\"n\">G.adjMatrix</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">ho</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">l</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">G.adjMatrix</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">((</span><span class=\"n\">G.adjMatrix</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">d</span> <span class=\"bp\">•</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">of</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Module.End.mem_eigenspace_iff</span><span class=\"o\">,</span> <span class=\"n\">toLin'_apply'</span><span class=\"o\">,</span> <span class=\"n\">mulVecLin_apply</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">he</span>\n  <span class=\"k\">have</span> <span class=\"n\">hesqr</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">G.adjMatrix</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">*ᵥ</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">repeat</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">pow_succ</span><span class=\"o\">,</span> <span class=\"n\">pow_one</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">mulVec_mulVec</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"n\">mulVec_smul_assoc</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">smul_assoc</span><span class=\"o\">,</span> <span class=\"n\">smul_eq_mul</span><span class=\"o\">]</span>\n  <span class=\"n\">apply_fun</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">*ᵥ</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_mulVec</span><span class=\"o\">,</span> <span class=\"n\">add_mulVec</span><span class=\"o\">,</span> <span class=\"n\">sub_mulVec</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"n\">hesqr</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"k\">have</span> <span class=\"n\">rhsZero</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Matrix.of</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">*ᵥ</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">ext</span> <span class=\"n\">i</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mulVec</span><span class=\"o\">,</span> <span class=\"n\">ho</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">rhsZero</span><span class=\"o\">,</span> <span class=\"n\">nsmul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"c1\">-- this : 1 *ᵥ e + l • e + (l ^ 2 • e - ↑d *ᵥ e) = 0</span>\n  <span class=\"c1\">-- goal : l ^ 2 + l - (↑d - 1) = 0</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 435805642,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1714268342
    },
    {
        "content": "<p>Regrettably, I don't think there is any painless way to do this. In fact, every step of the process seems to be painful in some way. But maybe you could help to fill some of the gaps in the library that make this particular example so difficult. (I would not give an answer like this to a total beginner, but I have seen you make several contributions, so I know you aren't one.)</p>\n<p>Here is the outline. It's quite similar to how you would make the argument on paper. Note that you need to assume that <code>e ≠ 0</code>, otherwise your theorem is false.</p>\n<ol>\n<li>Rewrite the <code>↑d *ᵥ e</code> as <code>d • e</code>. Unfortunately, the theory of matrices in mathlib is rather incomplete, so I don't think there is currently a theorem that lets you do this. But you could write your own.</li>\n<li>Rewrite the <code>1 *ᵥ e</code> as <code>1 • e</code>. You could do this by first rewriting the <code>1</code> as <code>((1 : ℕ) : Matrix α α β)</code> using <code>rfl</code>, and then using the theorem you proved in step 1. (See <a href=\"#narrow/stream/287929-mathlib4/topic/Rewriting.20an.20expression.20that.20involves.20.60OfNat.60/near/432367644\">here</a> for the reason that you have to do the first awkward rewriting step.)</li>\n<li>The resulting equation is <code>1 • e + l • e + (l ^ 2 • e - ↑d •  e) = 0</code>. Now rewrite it as <code>(1 + l + (l ^ 2 - ↑d)) • e = 0</code>. The easiest way I know to do this is to use <code>simp only [← add_nsmul, ← sub_nsmul] at this</code>. (I have been waiting for a tactic that does this sort of manipulation automatically, as I mentioned <a href=\"#narrow/stream/287929-mathlib4/topic/Feature.20request.3A.20.22module_nf.22\">here</a>, but that might not happen in the near future.)</li>\n<li>Now, apply <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Module/Basic.html#smul_eq_zero\">smul_eq_zero</a> to conclude that <code>1 + l + (l ^ 2 - ↑d) = 0</code>. This requires the extra assumption that <code>e ≠ 0</code>.</li>\n<li>Finally, you just need to observe that by the ring axioms, this equation is equivalent to the one you are trying to prove. To do so, you can use <code>ring_nf at this ⊢; assumption</code>.</li>\n</ol>",
        "id": 435811212,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1714273279
    },
    {
        "content": "<p>Here's a way to do it with <code>convert</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">he</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">Module.End.eigenspace</span> <span class=\"o\">(</span><span class=\"n\">Matrix.toLin'</span> <span class=\"o\">(</span><span class=\"n\">G.adjMatrix</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hnz</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">ho</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">l</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">G.adjMatrix</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">((</span><span class=\"n\">G.adjMatrix</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">d</span> <span class=\"bp\">•</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">of</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Module.End.mem_eigenspace_iff</span><span class=\"o\">,</span> <span class=\"n\">toLin'_apply'</span><span class=\"o\">,</span> <span class=\"n\">mulVecLin_apply</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">he</span>\n  <span class=\"k\">have</span> <span class=\"n\">hesqr</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">G.adjMatrix</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">*ᵥ</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">repeat</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">pow_succ</span><span class=\"o\">,</span> <span class=\"n\">pow_one</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">mulVec_mulVec</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"n\">mulVec_smul_assoc</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">smul_assoc</span><span class=\"o\">,</span> <span class=\"n\">smul_eq_mul</span><span class=\"o\">]</span>\n  <span class=\"n\">apply_fun</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">*ᵥ</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_mulVec</span><span class=\"o\">,</span> <span class=\"n\">add_mulVec</span><span class=\"o\">,</span> <span class=\"n\">sub_mulVec</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"n\">hesqr</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"k\">have</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"bp\">*ᵥ</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">change</span> <span class=\"n\">diagonal</span> <span class=\"n\">d</span> <span class=\"bp\">*ᵥ</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">_</span>\n    <span class=\"n\">ext</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mulVec_diagonal</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">l</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">d</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">•</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">convert</span> <span class=\"n\">this</span> <span class=\"n\">using</span> <span class=\"mi\">1</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_smul</span><span class=\"o\">,</span> <span class=\"n\">sub_smul</span><span class=\"o\">,</span> <span class=\"n\">foo</span><span class=\"o\">]</span>\n      <span class=\"n\">ring</span>\n    <span class=\"bp\">·</span> <span class=\"n\">ext</span> <span class=\"n\">i</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mulVec</span><span class=\"o\">,</span> <span class=\"n\">ho</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">smul_eq_zero_iff_left</span> <span class=\"n\">hnz</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">exact</span> <span class=\"n\">this</span>\n</code></pre></div>",
        "id": 435813533,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714274764
    },
    {
        "content": "<p>Thank you very much! Sorry for forgetting the <code>e ≠ 0</code> hypothesis, I was thinking \"<code>e</code> is an eigenvector, and eigenvectors are non-zero\", but now I notice why <code>he</code> doesn't imply that.<br>\n<span class=\"user-mention silent\" data-user-id=\"695266\">Mitchell Lee</span> <a href=\"#narrow/stream/113489-new-members/topic/Factor.20out.20a.20vector/near/435811212\">said</a>:</p>\n<blockquote>\n<p>But maybe you could help to fill some of the gaps in the library that make this particular example so difficult.</p>\n</blockquote>\n<p>I would love to, but I think I'm far from a level where I can attempt writing the <code>module_nf</code> tactic. Maybe the first step is to add the <code>d *ᵥ e = d  • e</code> lemma. Do you have suggestions on how to fill more of these gaps?</p>",
        "id": 435870768,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1714306906
    },
    {
        "content": "<p><code>d *ᵥ e = d • e</code> should definitely be a lemma we have; though we also add all of:</p>\n<ul>\n<li><code>diagonal_mulVec : (diagonal fun x =&gt; r) *ᵥ v = r • v</code></li>\n<li><code>natcast_mulVec : n *ᵥ v = n • v</code></li>\n<li><code>intcast_mulVec : z *ᵥ v = z • v</code></li>\n<li><code>ofNat_mulVec : (OfNat.ofNat (no_index n) : R) *ᵥ v = (OfNat.ofNat n : R) • v</code></li>\n</ul>",
        "id": 435871973,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714308059
    },
    {
        "content": "<p>(the first one should work as the proof for all the rest)</p>",
        "id": 435871986,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714308072
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/12538\">#12538</a> proves these, please let me know if you have suggestions or more lemmas to add to it.</p>",
        "id": 436205722,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1714459613
    },
    {
        "content": "<p>That looks good so far, I left some comments</p>",
        "id": 436206243,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714459863
    }
]