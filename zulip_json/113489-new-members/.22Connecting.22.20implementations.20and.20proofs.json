[
    {
        "content": "<p>Hello Lean community. I am a novice Lean user working on a type system where I have encoded the fact that an expression types with a given type in a given type environment using an inductive predicate of the following signature:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">exprTypes</span> <span class=\"o\">:</span> <span class=\"n\">TypeEnv</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Expr</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">my.Type</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span>\n<span class=\"c1\">-- ...</span>\n</code></pre></div>\n<p>(where <code>my.Type</code> is NOT the built-in <code>Type</code>=<code>Sort 1</code>, but just a simple struct defined by me)<br>\nNote that even fixing one expression and type environment, the predicate is true for several different types due to subtyping. This is, we can have both <code>exprTypes Γ expr t1</code> and <code>exprTypes Γ expr t2</code> hold for some <code>t1</code> and <code>t2</code> even if <code>t1 ≠ t2</code>.</p>\n<p>Additionally, I have also implemented a functional-style type inference algorithm which, given a type environment and an expression, yields exactly one type that satisfies <code>exprTypes</code>. It has the following signature:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">inferExprType</span> <span class=\"o\">:</span> <span class=\"n\">TypeEnv</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Expr</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">my.Type</span>\n<span class=\"c1\">-- ...</span>\n</code></pre></div>\n<p>I wish to connect the inductive predicate and the inference algorithm to show that the type it infers is actually a correct choice that types for that expression, i.e.:</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi mathvariant=\"normal\">Γ</mi><mo separator=\"true\">,</mo><mi>e</mi><mi mathvariant=\"normal\">.</mi><mtext> </mtext><mtext mathvariant=\"monospace\">exprTypes</mtext><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Γ</mi><mo separator=\"true\">,</mo><mi>e</mi><mo separator=\"true\">,</mo><mtext mathvariant=\"monospace\">inferExprType</mtext><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Γ</mi><mo separator=\"true\">,</mo><mi>e</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\forall \\Gamma, e .\\, \\texttt{exprTypes}(\\Gamma, e, \\texttt{inferExprType}(\\Gamma, e))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀Γ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord\">.</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">exprTypes</span></span><span class=\"mopen\">(</span><span class=\"mord\">Γ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">inferExprType</span></span><span class=\"mopen\">(</span><span class=\"mord\">Γ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mclose\">))</span></span></span></span></span></p>\n<p>What is the best/most idiomatic way of doing this in Lean? It seems that there are at least two options: (1) to just write a theorem that encodes the proposition above directly, and (2) to modify <code>inferExprType</code> such that it also returns a proof that the inferred type is correct. If we go for option (1), then the implementation of <code>inferExprType</code>, which is a bit low level not particularly amenable to proofs, needs to be unfolded for inputs that are very general, as we would need to \"call\" the function with the variables bound by the universal quantification. Option (2) seems easier to manage on the formal/proof part, but it is a bigger technical/implementation challenge as it requires modifying the implementation of a function which is already complex. </p>\n<p>What I have presented is a simple motivating example, but I have noticed from my limited experience that as things become more complex, the implementation and proof halves of a Lean codebase increasingly diverge and become harder to \"connect\". So, generally, when you wish to connect \"dirty\" and long implementation-level definitions with nice and proof-level predicates, how do you approach this? What drawbacks and gotchas should I be aware of? Thank you.</p>",
        "id": 424652765,
        "sender_full_name": "Daniel Galán",
        "timestamp": 1709558596
    },
    {
        "content": "<p>I'm a fairly new member myself, but the way I've usually done it/seen it done is to make <code>exprTypes</code> into a typeclass. Then, you can write </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"bp\">Γ</span><span class=\"o\">:</span> <span class=\"n\">TypeEnv</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ExprTypes</span> <span class=\"bp\">Γ</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">inferExprType</span> <span class=\"bp\">Γ</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>Wherever you would use <code>exprTypes Γ e T</code> before, replace it with the instance-implicit binder notation <code>[ExprTypes Γ e T]</code>; with the instance in scope, Lean will automatically fill in the instance (proof) you've provided.</p>",
        "id": 425289976,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1709813689
    }
]