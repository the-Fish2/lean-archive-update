[
    {
        "content": "<p>I am trying to define an ordering on the type <code>(D × D)</code> , that is defined upon the ordering of <code>D</code> but I am getting this error  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">don't</span> <span class=\"n\">know</span> <span class=\"n\">how</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">implicit</span> <span class=\"n\">argument</span>\n  <span class=\"bp\">@</span><span class=\"n\">less_truth</span> <span class=\"n\">D</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m.182</span> <span class=\"n\">instLEProd</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m.183</span> <span class=\"n\">instLEProd</span><span class=\"o\">)</span> <span class=\"n\">inst</span><span class=\"bp\">✝</span>\n<span class=\"n\">context</span><span class=\"o\">:</span>\n<span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝¹</span> <span class=\"o\">:</span> <span class=\"n\">Nonempty</span> <span class=\"n\">D</span>\n<span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"n\">LE</span> <span class=\"n\">D</span>\n<span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">BoundedOrder</span> <span class=\"n\">D</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"n\">PropLean</span> <span class=\"mi\">4</span>\n</code></pre></div>\n<p>Here is the code</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.BoundedOrder</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Subtype</span>\n\n<span class=\"kd\">variable</span>\n\n  <span class=\"o\">{</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n\n  <span class=\"o\">[</span><span class=\"n\">Nonempty</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n\n  <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n\n  <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n\n  <span class=\"o\">[</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">BoundedOrder</span> <span class=\"n\">D</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">less_truth</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">×</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d'</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">×</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n\n  <span class=\"n\">p</span> <span class=\"n\">d.1</span> <span class=\"bp\">=</span> <span class=\"n\">True</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"n\">d.2</span> <span class=\"bp\">=</span> <span class=\"n\">True</span> <span class=\"bp\">∧</span>\n\n  <span class=\"n\">p</span> <span class=\"n\">d'.1</span> <span class=\"bp\">=</span> <span class=\"n\">True</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"n\">d'.2</span> <span class=\"bp\">=</span> <span class=\"n\">True</span> <span class=\"bp\">∧</span>\n\n  <span class=\"n\">d.1</span> <span class=\"bp\">≤</span> <span class=\"n\">d'.1</span> <span class=\"bp\">∧</span> <span class=\"n\">d.2</span> <span class=\"bp\">≤</span> <span class=\"n\">d'.2</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">LE</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"bp\">×</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n\n<span class=\"o\">{</span> <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"n\">less_truth</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Sorry for the lazy question, just figured it must be something really obvious. I am not asking for a solution, a pointer would suffice. Thanks.</p>",
        "id": 439610750,
        "sender_full_name": "George Kojonis",
        "timestamp": 1716223170
    },
    {
        "content": "<p>The <code>p</code> and <code>q</code> variables are implicit, but neither the explicit arguments to <code>less_truth</code> nor the return type of <code>less_truth</code> (<code>Prop</code>) reference them, so they can't be solved for by unification.</p>",
        "id": 439611324,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1716223376
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 439611451,
        "sender_full_name": "George Kojonis",
        "timestamp": 1716223422
    },
    {
        "content": "<p>This is problematic for <code>LE (D × D)</code>, since from <code>D × D</code> alone there's no way to infer what <code>p</code> and <code>q</code> are supposed to be.</p>",
        "id": 439611452,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1716223422
    },
    {
        "content": "<p>Are you looking for <code>Subtype</code>? You could use <code>{x : D // p x} × {y : D // q x}</code></p>",
        "id": 439611793,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1716223525
    },
    {
        "content": "<p>Oh yeah that would probably work. Thank you so much</p>",
        "id": 439612301,
        "sender_full_name": "George Kojonis",
        "timestamp": 1716223701
    },
    {
        "content": "<p>also note that there's an <code>LE</code> instance on products already defined in <code>Mathlib.Order.Basic</code></p>",
        "id": 439612358,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1716223722
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Prod.instLE_mathlib#doc\">docs#Prod.instLE_mathlib</a></p>",
        "id": 439612531,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1716223791
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"720043\">George Kojonis</span> has marked this topic as resolved.</p>",
        "id": 439612697,
        "sender_full_name": "Notification Bot",
        "timestamp": 1716223839
    },
    {
        "content": "<p>Thank you so much guys</p>",
        "id": 439612708,
        "sender_full_name": "George Kojonis",
        "timestamp": 1716223844
    },
    {
        "content": "<p>Furthermore, there's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subtype.le#doc\">docs#Subtype.le</a>, so you probably don't need to define an instance at all.</p>",
        "id": 439613551,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1716224106
    }
]