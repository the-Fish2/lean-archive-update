[
    {
        "content": "<p>How can I prove this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.Projectivization.Basic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">DivisionRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">l2_rep</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">]</span> <span class=\"bp\">-&gt;</span>\n<span class=\"bp\">¬</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">]</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">]</span> <span class=\"bp\">-&gt;</span>\n<span class=\"bp\">¬</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 425469727,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1709886419
    },
    {
        "content": "<p>Maybe I should start with a less intimidating goal. How can I prove something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.Projectivization.Basic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">DivisionRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lindep_imp_span</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"bp\">→</span>\n<span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">Submodule.span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 426425103,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1710363356
    },
    {
        "content": "<p>That's not true? Consider <code>b = c</code> and <code>a</code> which is not a scalar multiple of them.</p>",
        "id": 426435167,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710367934
    },
    {
        "content": "<p>Did you mean to assume that <code>b</code> and <code>c</code> a linearly independent?</p>",
        "id": 426435290,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710368010
    },
    {
        "content": "<p>I think you want to apply <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=not_iff_not#doc\">docs#not_iff_not</a> to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=linearIndependent_fin_succ#doc\">docs#linearIndependent_fin_succ</a></p>",
        "id": 426435553,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710368124
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.LinearIndependent</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">DivisionRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lindep_imp_span</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">])</span>\n    <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">])</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">Submodule.span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">not_iff_not.mpr</span> <span class=\"n\">linearIndependent_fin_succ</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₂</span>\n  <span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"n\">h₂</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Fin.isValue</span><span class=\"o\">,</span> <span class=\"n\">Matrix.cons_val_zero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₂</span>\n  <span class=\"n\">convert</span> <span class=\"n\">h₂</span> <span class=\"n\">h₁</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"k\">show</span> <span class=\"n\">Fin.tail</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"k\">from</span> <span class=\"n\">rfl</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">or_comm</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 426437915,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710369208
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20work.20with.20LinearIndependent.3F/near/426435167\">said</a>:</p>\n<blockquote>\n<p>That's not true? Consider <code>b = c</code> and <code>a</code> which is not a scalar multiple of them.</p>\n</blockquote>\n<p>Yep, late night confusion I guess. <code>b</code>and <code>c</code>being linearly independent is fine. Thank you!</p>",
        "id": 426479132,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1710398908
    },
    {
        "content": "<p>Here is my progression so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">l2_rep</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">apq_dep</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">])</span>\n<span class=\"o\">(</span><span class=\"n\">bpq_dep</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">pq_indep</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">])</span> <span class=\"o\">:</span>\n<span class=\"bp\">¬</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"k\">have</span> <span class=\"n\">a_span_pq</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">Submodule.span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n<span class=\"n\">apply</span> <span class=\"n\">lin_dep_imp_span</span> <span class=\"n\">a</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">pq_indep</span> <span class=\"n\">apq_dep</span>\n<span class=\"o\">}</span>\n<span class=\"k\">have</span> <span class=\"n\">b_span_pq</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">Submodule.span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n<span class=\"n\">apply</span> <span class=\"n\">lin_dep_imp_span</span> <span class=\"n\">b</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">pq_indep</span> <span class=\"n\">bpq_dep</span>\n<span class=\"o\">}</span>\n<span class=\"k\">have</span> <span class=\"n\">ppq_dep</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">lin_dep_aab</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n<span class=\"k\">have</span> <span class=\"n\">qpq_dep</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">lin_dep_bab</span> <span class=\"n\">q</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n<span class=\"k\">have</span> <span class=\"n\">p_span_pq</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">Submodule.span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n<span class=\"n\">apply</span> <span class=\"n\">lin_dep_imp_span</span> <span class=\"n\">p</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">pq_indep</span> <span class=\"n\">ppq_dep</span>\n<span class=\"o\">}</span>\n<span class=\"k\">have</span> <span class=\"n\">q_span_pq</span> <span class=\"o\">:</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">Submodule.span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n<span class=\"n\">apply</span> <span class=\"n\">lin_dep_imp_span</span> <span class=\"n\">q</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">pq_indep</span> <span class=\"n\">qpq_dep</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>I have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo separator=\"true\">,</mo><mi>p</mi><mo separator=\"true\">,</mo><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">a,b,p,q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span></span></span></span> in the span of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo separator=\"true\">,</mo><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">p,q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span></span></span></span>. Now I want to say that any three of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo separator=\"true\">,</mo><mi>p</mi><mo separator=\"true\">,</mo><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">a,b,p,q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span></span></span></span> is linearly dependent, and conclude that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo separator=\"true\">,</mo><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">a,b,p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> are linearly dependent. <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> Do we have such a lemma in the library, I couldn't find any.</p>",
        "id": 428070245,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1711006392
    },
    {
        "content": "<p>To reformulate: Any family from a span is linearly dependent.</p>",
        "id": 428293142,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1711100516
    },
    {
        "content": "<p>It's true because the span of <code>p</code>, <code>q</code>is at most <code>2</code> (cf <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Dimension/Constructions.html#finrank_span_finset_le_card\">finrank_span_finset_le_card</a>) and a family of linearly independent vectors has cardinal at most the dimension (cf <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Dimension/Finite.html#LinearIndependent.finset_card_le_finrank\">LinearIndependent.finset_card_le_finrank</a>). I doubt there is a direct lemma doing exactly what you want.</p>",
        "id": 428301834,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1711103707
    },
    {
        "content": "<p>Oh, I never thought cardinalities would be useful here. But of course, yeah. Thank you, I'll try this direction.</p>",
        "id": 428303243,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1711104229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20work.20with.20LinearIndependent.3F/near/428301834\">said</a>:</p>\n<blockquote>\n<p>It's true because the span of <code>p</code>, <code>q</code>is at most <code>2</code> (cf <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Dimension/Constructions.html#finrank_span_finset_le_card\">finrank_span_finset_le_card</a>) and a family of linearly independent vectors has cardinal at most the dimension (cf <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Dimension/Finite.html#LinearIndependent.finset_card_le_finrank\">LinearIndependent.finset_card_le_finrank</a>). I doubt there is a direct lemma doing exactly what you want.</p>\n</blockquote>\n<p>Why does Lean fail to convert this Set to a Finset?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Set</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">toFinset</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span>\n<span class=\"c1\">-- failed to synthesize instance</span>\n<span class=\"c1\">--   Fintype ↑{p, q}</span>\n</code></pre></div>",
        "id": 428369208,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1711125338
    },
    {
        "content": "<p>You can see the error. Fintype and Finset are constructive so maybe you need some constructivist stuff to make it work. Does adding <code>[DecidableEq V]</code> help? Maybe the issue is that Lean doesn't know if p=q which will stop it from proving that {p,q} is constructively finite.</p>",
        "id": 428369858,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711125529
    },
    {
        "content": "<p>If you add <code>[DecidableEq V]</code>, then you can just write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"n\">q</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 428415110,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1711144622
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20work.20with.20LinearIndependent.3F/near/428369858\">said</a>:</p>\n<blockquote>\n<p>You can see the error. Fintype and Finset are constructive so maybe you need some constructivist stuff to make it work. Does adding <code>[DecidableEq V]</code> help? Maybe the issue is that Lean doesn't know if p=q which will stop it from proving that {p,q} is constructively finite.</p>\n</blockquote>\n<p>Yes, that works. Also yes, I actually can get $p \\neq q$ in the original context. Although, I guess I have some other problem there, will write more soon.</p>",
        "id": 429085797,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1711204266
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20work.20with.20LinearIndependent.3F/near/428415110\">said</a>:</p>\n<blockquote>\n<p>If you add <code>[DecidableEq V]</code>, then you can just write</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"n\">q</span><span class=\"o\">}</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>That's handy.</p>",
        "id": 429085838,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1711204321
    },
    {
        "content": "<p>If you have that p and q are different, you could also use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.cons#doc\">docs#Finset.cons</a> instead of set notation, which avoids the decidable instance; but either spelling is fine</p>",
        "id": 429095615,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711212249
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20work.20with.20LinearIndependent.3F/near/428301834\">said</a>:</p>\n<blockquote>\n<p>It's true because the span of <code>p</code>, <code>q</code>is at most <code>2</code> (cf <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Dimension/Constructions.html#finrank_span_finset_le_card\">finrank_span_finset_le_card</a>) and a family of linearly independent vectors has cardinal at most the dimension (cf <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Dimension/Finite.html#LinearIndependent.finset_card_le_finrank\">LinearIndependent.finset_card_le_finrank</a>). I doubt there is a direct lemma doing exactly what you want.</p>\n</blockquote>\n<p>I figured out the fist one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.FiniteDimensional</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span> <span class=\"n\">Submodule</span> <span class=\"n\">FiniteDimensional</span> <span class=\"n\">LinearIndependent</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">DivisionRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">pq_span_dim_ineq</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pq_diff</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set.finrank</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">toSet</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span> <span class=\"bp\">≤</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"k\">have</span> <span class=\"n\">pq_card</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">card</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span>\n<span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">&lt;-</span> <span class=\"n\">pq_card</span><span class=\"o\">]</span>\n<span class=\"n\">apply</span> <span class=\"n\">finrank_span_finset_le_card</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>In the second one, I am a bit tired at:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.FiniteDimensional</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span> <span class=\"n\">Submodule</span> <span class=\"n\">FiniteDimensional</span> <span class=\"n\">LinearIndependent</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">DivisionRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">abp_rank_le_span_rank</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">pq_diff</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">abp_indep</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">])</span>\n<span class=\"o\">(</span><span class=\"n\">a_span_pq</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span>\n<span class=\"o\">(</span><span class=\"n\">b_span_pq</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">card</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">})</span> <span class=\"bp\">≤</span> <span class=\"n\">finrank</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"n\">apply</span> <span class=\"n\">finset_card_le_finrank</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}))</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span>\n<span class=\"c1\">-- failed to synthesize instance</span>\n<span class=\"c1\">--   Module.Finite K ↥(span K {p, q})</span>\n</code></pre></div>\n<p>Should I chase something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Module.Finite</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 429124888,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1711235266
    },
    {
        "content": "<p>You can add something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">set</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">({</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toSet</span>\n<span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">FiniteDimensional</span> <span class=\"n\">K</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">span_finset</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>in your code to get the instance, but you'll also have to prove that <code>a,b,p</code> are linearly independent in <code>M</code> and not in <code>V</code> to give to <code>finset_card_le_finrank</code> as an argument. You can use <code>LinearIndependent.of_comp M.subtype</code> for this. (Maybe there is a better solution, I don't know.)</p>",
        "id": 429210616,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1711290229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20work.20with.20LinearIndependent.3F/near/429210616\">said</a>:</p>\n<blockquote>\n<p>You can add something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">set</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">({</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toSet</span>\n<span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">FiniteDimensional</span> <span class=\"n\">K</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">span_finset</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>in your code to get the instance, but you'll also have to prove that <code>a,b,p</code> are linearly independent in <code>M</code> and not in <code>V</code> to give to <code>finset_card_le_finrank</code> as an argument. You can use <code>LinearIndependent.of_comp M.subtype</code> for this. (Maybe there is a better solution, I don't know.)</p>\n</blockquote>\n<p>Hmm, this became a bit tricky, but you mean that I put these after <code>by</code>, right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">abp_rank_le_span_rank</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">pq_diff</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">abp_indep</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">])</span>\n<span class=\"o\">(</span><span class=\"n\">a_span_pq</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span>\n<span class=\"o\">(</span><span class=\"n\">b_span_pq</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">card</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">})</span> <span class=\"bp\">≤</span> <span class=\"n\">finrank</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"n\">set</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">({</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toSet</span>\n<span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">FiniteDimensional</span> <span class=\"n\">K</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">span_finset</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span>\n<span class=\"n\">apply</span> <span class=\"n\">finset_card_le_finrank</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}))</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Like this?</p>",
        "id": 429227247,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1711299629
    },
    {
        "content": "<p>Oh, I never passed it to <code>finset_card_le_finrank</code>. I should look at this a bit more.</p>",
        "id": 429227536,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1711299808
    },
    {
        "content": "<p>Yes, I meant that you put the <code>letI</code> lines after <code>by</code>. It lets you introduce an instance to be used during a proof (and then forgotten).</p>",
        "id": 429230308,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1711301777
    },
    {
        "content": "<p>There only left to rectify the type of the <code>{a, b, p}</code> in the declaration. It should also be of <code>Finset M</code>, so I also need <code>M</code> before <code>by</code>. I tried to put it there hard-coded for testing purposes, but I now get this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">abp_rank_le_span_rank</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">pq_diff</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">abp_indep</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">])</span>\n<span class=\"o\">(</span><span class=\"n\">a_span_pq</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">({</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toSet</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">b_span_pq</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">({</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toSet</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n<span class=\"o\">({</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">({</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toSet</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">≤</span>\n<span class=\"n\">finrank</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">({</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toSet</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"n\">set</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">({</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toSet</span>\n<span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">FiniteDimensional</span> <span class=\"n\">K</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">span_finset</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span>\n<span class=\"n\">apply</span> <span class=\"n\">finset_card_le_finrank</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span>\n<span class=\"c1\">-- overloaded, errors</span>\n<span class=\"c1\">--   failed to synthesize instance</span>\n<span class=\"c1\">--     Singleton V (Finset ↥(span K ↑{p, q}))</span>\n<span class=\"c1\">--</span>\n<span class=\"c1\">--   32:2 'a' is not a field of structure 'Finset'</span>\n</code></pre></div>",
        "id": 429231630,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1711302855
    },
    {
        "content": "<p>So, if I am understanding correctly, the problem is arising from the fact that <code>a</code> is of type <code>V</code>, and I should somehow point to the fact I have <code>(a_span_pq : a ∈ (span K ({p, q} : Finset V).toSet))</code>.</p>",
        "id": 429232595,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1711303388
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20work.20with.20LinearIndependent.3F/near/429230308\">said</a>:</p>\n<blockquote>\n<p>Yes, I meant that you put the <code>letI</code> lines after <code>by</code>. It lets you introduce an instance to be used during a proof (and then forgotten).</p>\n</blockquote>\n<p>For that you generally just want <code>let</code>. The `letI| additionally inlines the instance, which is not always desirable.</p>\n<p>Note also, the meaning of <code>letI</code> changed between Lean 3 and Lean 4</p>",
        "id": 429236660,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711306501
    },
    {
        "content": "<p>Oh, and in this case you can just use <code>have</code> because the instance doesn't contain any data.</p>",
        "id": 429236719,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711306550
    },
    {
        "content": "<p>Ah, nice, I didn't know that <code>let</code> was enough! <br>\nI didn't know what it means to \"inline\" an instance, so I looked stuff up and found <a href=\"https://en.wikipedia.org/wiki/Inline_expansion\">this</a>; is it the same meaning?</p>",
        "id": 429242514,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1711310768
    },
    {
        "content": "<p>Yes.</p>",
        "id": 429243317,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711311328
    },
    {
        "content": "<p>If I start with a b with type span, then I can apply the theorem, but then of course I lose my original form. I will post that example when I got home.</p>",
        "id": 430121512,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1711645346
    },
    {
        "content": "<p>I guess I need some kind of type casting for this?</p>",
        "id": 430121696,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1711645386
    },
    {
        "content": "<p>So let me post the example I talked above <span class=\"user-mention\" data-user-id=\"318709\">@Sophie Morel</span> and  <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> . This one works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">({</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toSet</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">ab_neq</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span><span class=\"o\">):</span>\n<span class=\"o\">({</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">({</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toSet</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span>\n</code></pre></div>\n<p>If I forget about the hypothesis for now and focus on the types: I want to make the following type-check:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">abp_rank_le_span_rank</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"o\">({</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">({</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toSet</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">≤</span>\n<span class=\"n\">finrank</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">({</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toSet</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"n\">set</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">({</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toSet</span>\n<span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">FiniteDimensional</span> <span class=\"n\">K</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">span_finset</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span>\n<span class=\"n\">apply</span> <span class=\"n\">finset_card_le_finrank</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">}</span>\n<span class=\"c1\">-- overloaded, errors</span>\n<span class=\"c1\">--   failed to synthesize instance</span>\n<span class=\"c1\">--     Singleton V (Finset ↥(span K ↑{p, q}))</span>\n<span class=\"c1\">--</span>\n<span class=\"c1\">--   28:2 'a' is not a field of structure 'Finset'</span>\n</code></pre></div>",
        "id": 430389186,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1711804324
    },
    {
        "content": "<p>On the third line, is that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.finrank#doc\">docs#Set.finrank</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FiniteDimensional.finrank#doc\">docs#FiniteDimensional.finrank</a> ?</p>",
        "id": 430414131,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711826762
    },
    {
        "content": "<p>Because the lemma to you are applying is apparently <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearIndependent.finset_card_le_finrank#doc\">docs#LinearIndependent.finset_card_le_finrank</a>, which is about the latter of these.</p>",
        "id": 430414289,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711826910
    },
    {
        "content": "<p>Right now I'm outside, so i can't look at my source, but yes, that should be the case. I'm also checking above the <code>open</code> line, and I think I never opened <code>Set</code>.</p>",
        "id": 430414453,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1711827111
    },
    {
        "content": "<p>So which one is on the third line?</p>",
        "id": 430417500,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711829867
    },
    {
        "content": "<p>Sorry, just realized my wording was implicit. Checked now, it's <code>FiniteDimensional.finrank</code>.</p>",
        "id": 430418724,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1711831318
    },
    {
        "content": "<p>On the second line, the expression <code>({a, b} : Finset (span K ({p, q} : Finset V)</code> is not well-typed, as <code>a</code> and <code>b</code> are of type <code>V</code>, not of type <code>span K ({p,q} : Finset V).toSet</code>. Also, you cannot apply <code>finset_card_le_finrank</code> if you don't assume that <code>a</code> and <code>b</code> are linearly independent.<br>\nFinally, when you post code like that, please include all imports, open namespaces and variable declarations, otherwise I have to guess myself what you have opened if I want to play with the code (and, as Jireh pointed, if we don't know which namespaces are open then some expressions become ambiguous). This wastes a lot of time, and I will not do it again.  Here your problem might just be that you forgot to declare <code>[DecidableEq V]</code>, but I cannot tell because you did not include that part.</p>",
        "id": 430462211,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1711876427
    },
    {
        "content": "<p>To prove that the subspace generated by <code>p</code> and <code>q</code> is finite-dimensional, I am really starting to think that it would be easier to use <code>Module.Finite.span_of_finite</code>, so you can write <code>Submodule.span K {p,q}</code> (but you'll have to prove that <code>Set.Finite {p,q}</code>, which should not be hard).</p>",
        "id": 430462372,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1711876588
    },
    {
        "content": "<p>Yes this post is a great example of why <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> s are important. Right now most of the comments here are asking for clarifications of the code; this would not have been necessary if a mwe was posted first time around. And it's still not too late to post one!</p>",
        "id": 430468037,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711882469
    },
    {
        "content": "<p>Lesson learned <span aria-label=\"saluting face\" class=\"emoji emoji-1fae1\" role=\"img\" title=\"saluting face\">:saluting_face:</span> Here it is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.FiniteDimensional</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span> <span class=\"n\">Submodule</span> <span class=\"n\">FiniteDimensional</span> <span class=\"n\">LinearIndependent</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">DivisionRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">abp_rank_le_span_rank</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">pq_neq</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">abp_indep</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">])</span>\n<span class=\"o\">(</span><span class=\"n\">a_span_pq</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">({</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toSet</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">b_span_pq</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">({</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toSet</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n<span class=\"o\">({</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">({</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toSet</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">≤</span>\n<span class=\"n\">finrank</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">({</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toSet</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"n\">set</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">({</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toSet</span>\n<span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">FiniteDimensional</span> <span class=\"n\">K</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">span_finset</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span>\n<span class=\"n\">apply</span> <span class=\"n\">finset_card_le_finrank</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span>\n<span class=\"c1\">-- overloaded, errors</span>\n<span class=\"c1\">--   failed to synthesize instance</span>\n<span class=\"c1\">--     Singleton V (Finset ↥(span K ↑{p, q}))</span>\n<span class=\"c1\">--</span>\n<span class=\"c1\">--   28:2 'a' is not a field of structure 'Finset'</span>\n</code></pre></div>",
        "id": 430473905,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1711888588
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"318709\">Sophie Morel</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20work.20with.20LinearIndependent.3F/near/430462372\">said</a>:</p>\n<blockquote>\n<p>To prove that the subspace generated by <code>p</code> and <code>q</code> is finite-dimensional, I am really starting to think that it would be easier to use <code>Module.Finite.span_of_finite</code>, so you can write <code>Submodule.span K {p,q}</code> (but you'll have to prove that <code>Set.Finite {p,q}</code>, which should not be hard).</p>\n</blockquote>\n<p>Alright, thank you. I will look into this.</p>",
        "id": 430475229,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1711890005
    },
    {
        "content": "<p>This has follow-ups but let me start with the following, hopefully this time with proper mwes. I proved submodule generated by <code>p</code> and <code>q</code> is finite dimensional.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.FiniteDimensional</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Submodule</span> <span class=\"n\">FiniteDimensional</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">DivisionRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">pq_subspace_finite</span>\n<span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">Module.Finite</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"n\">apply</span> <span class=\"n\">Module.Finite.span_of_finite</span>\n<span class=\"n\">aesop</span> <span class=\"c1\">-- proves Set.Finite {p,q}</span>\n</code></pre></div>\n<p>But there are a few things that surprised me. The first is that this didn't need <code>[DecidableEq V]</code>. The second is that <code>Module.Finite.span_of_finite</code> worked without providing <code>{p, q}</code> as a parameter. Last but not least, providing it explicitly returned the following error in the comment:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.FiniteDimensional</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Submodule</span> <span class=\"n\">FiniteDimensional</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">DivisionRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">pq_subspace_finite</span>\n<span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">Module.Finite</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"o\">(</span><span class=\"n\">apply</span> <span class=\"n\">Module.Finite.span_of_finite</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span>\n<span class=\"n\">aesop</span> <span class=\"c1\">-- proves Set.Finite {p,q}</span>\n<span class=\"c1\">-- overloaded, errors</span>\n<span class=\"c1\">--   failed to synthesize instance</span>\n<span class=\"c1\">--     Singleton V (Type ?u.1977)</span>\n<span class=\"c1\">--</span>\n<span class=\"c1\">--   invalid {...} notation, expected type is not of the form (C ...)</span>\n<span class=\"c1\">--     Type ?u.1977</span>\n</code></pre></div>\n<p>What does Lean inferred as parameter there, how did Lean do it?</p>",
        "id": 430873955,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1712092087
    },
    {
        "content": "<p>You only need DecidableEq if you're doing constructivist stuff, which you're not doing.</p>\n<p><code>apply Module.Finite.span_of_finite {p, q}</code> is nonsense because the first thing <code>Module.Finite.span_of_finite</code> wants to eat is <del><code>(hA : Set.Finite A)</code></del> (edit : <code>R : Type*</code>) and you've given it <code>{p, q}</code> which is not a term of that type, so Lean is just completely confused.</p>",
        "id": 430883223,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712095863
    },
    {
        "content": "<p>By the way, the usual way to do the indentation is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">pq_subspace_finite</span>  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Module.Finite</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Module.Finite.span_of_finite</span>\n  <span class=\"n\">aesop</span>\n</code></pre></div>",
        "id": 430883305,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712095902
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"557285\">@Abdullah Uyu</span>, if you look up the parameters of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.Finite.span_of_finite#doc\">docs#Module.Finite.span_of_finite</a>, you will see that the explicit parameters are <code>R</code> (the semiring for the module) and <code>hA</code> (the proof that <code>A</code> is a finite set).</p>\n<p>In your first example, <code>R</code> can be deduced (by comparing, on the one hand, the expected type <code>Module.Finite K ↥(Submodule.span K {p, q})</code>, and on the other hand, the resulting type <code>Module.Finite R ↥(Submodule.span R A)</code> from <code>Module.Finite.span_of_finite</code>). The implicit arguments can all be deduced or inferred too, leaving only the goal <code>Set.Finite {p, q}</code>, which <code>aesop</code> proves. (<code>exact?</code> would also have given you a proof.)</p>\n<p>In your second example, you supplied <code>{p, q}</code> for the explicit parameter <code>R : Type*</code>.</p>\n<p>The error message says:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- overloaded, errors</span>\n</code></pre></div>\n<p>Lean tried to elaborate the notation <code>{p, q}</code> in more than one way (it is <code>overloaded</code> notation), but none succeeded.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">--   failed to synthesize instance</span>\n<span class=\"c1\">--     Singleton V (Type ?u.1977)</span>\n</code></pre></div>\n<p>First, it tried to interpret <code>{p, q}</code> as set-builder notation. It was unable to deduce the element type, and in consequence was unable to infer the <code>Singleton</code> type class for the element type; that type class is needed for set-builder notation, so the attempt failed.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">--   invalid {...} notation, expected type is not of the form (C ...)</span>\n<span class=\"c1\">--     Type ?u.1977</span>\n</code></pre></div>\n<p>The error message for the second attempt is not very good, but it doesn't matter: Lean tried something else, and that didn't work either.</p>\n<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.FiniteDimensional</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">pq_subspace_finite</span> <span class=\"o\">[</span><span class=\"n\">DivisionRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Module.Finite</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">Submodule.span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Module.Finite.span_of_finite</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">Set.toFinite</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span>\n</code></pre></div>",
        "id": 430885081,
        "sender_full_name": "Richard Copley",
        "timestamp": 1712096660
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400544\">Richard Copley</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20work.20with.20LinearIndependent.3F/near/430885081\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"557285\">Abdullah Uyu</span>, if you look up the parameters of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.Finite.span_of_finite#doc\">docs#Module.Finite.span_of_finite</a>, you will see that the explicit parameters are <code>R</code> (the semiring for the module) and <code>hA</code> (the proof that <code>A</code> is a finite set).</p>\n<p>In your first example, <code>R</code> can be deduced (by comparing, on the one hand, the expected type <code>Module.Finite K ↥(Submodule.span K {p, q})</code>, and on the other hand, the resulting type <code>Module.Finite R ↥(Submodule.span R A)</code> from <code>Module.Finite.span_of_finite</code>). The implicit arguments can all be deduced or inferred too, leaving only the goal <code>Set.Finite {p, q}</code>, which <code>aesop</code> proves. (<code>exact?</code> would also have given you a proof.)</p>\n<p>In your second example, you supplied <code>{p, q}</code> for the explicit parameter <code>R : Type*</code>.</p>\n<p>The error message says:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- overloaded, errors</span>\n</code></pre></div>\n<p>Lean tried to elaborate the notation <code>{p, q}</code> in more than one way (it is <code>overloaded</code> notation), but none succeeded.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">--   failed to synthesize instance</span>\n<span class=\"c1\">--     Singleton V (Type ?u.1977)</span>\n</code></pre></div>\n<p>First, it tried to interpret <code>{p, q}</code> as set-builder notation. It was unable to deduce the element type, and in consequence was unable to infer the <code>Singleton</code> type class for the element type; that type class is needed for set-builder notation, so the attempt failed.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">--   invalid {...} notation, expected type is not of the form (C ...)</span>\n<span class=\"c1\">--     Type ?u.1977</span>\n</code></pre></div>\n<p>The error message for the second attempt is not very good, but it doesn't matter: Lean tried something else, and that didn't work either.</p>\n<p>This works:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.FiniteDimensional</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">pq_subspace_finite</span> <span class=\"o\">[</span><span class=\"n\">DivisionRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Module.Finite</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">Submodule.span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Module.Finite.span_of_finite</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">Set.toFinite</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thank you so much, it it much more clear now! I should sit and  read some basics apparently, going intuitively has limited efficiency.</p>",
        "id": 431172107,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1712176825
    },
    {
        "content": "<p>Let me then continue with this: I can now pass the instance <code>Module.Finite K (Submodule.span K {p, q})</code> to my ultimate theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.FiniteDimensional</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span> <span class=\"n\">Submodule</span> <span class=\"n\">FiniteDimensional</span> <span class=\"n\">LinearIndependent</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">DivisionRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">pq_subspace_finite</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Module.Finite</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">Submodule.span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Module.Finite.span_of_finite</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">Set.toFinite</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">abp_card_le_span_rank</span>\n    <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">finite_submodule_instance</span> <span class=\"o\">:=</span> <span class=\"n\">pq_subspace_finite</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">pq_neq</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">abp_indep</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">])</span>\n    <span class=\"o\">(</span><span class=\"n\">a_span_pq</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}))</span>\n    <span class=\"o\">(</span><span class=\"n\">b_span_pq</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}))</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">card</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">})</span> <span class=\"bp\">≤</span> <span class=\"n\">finrank</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">finset_card_le_finrank</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}))</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span>\n  <span class=\"c1\">-- tactic 'apply' failed, failed to unify</span>\n  <span class=\"c1\">--   ?m.9988.card ≤ finrank K ↥(span K {p, q})</span>\n  <span class=\"c1\">-- with</span>\n  <span class=\"c1\">--   {a, b, p}.card ≤ finrank K ↥(span K {p, q})</span>\n</code></pre></div>\n<p>Though, I still don't quite know how to state <code>{a, b, p}</code> as a finite set of <code>(span K {p, q})</code>.</p>",
        "id": 431174342,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1712177726
    },
    {
        "content": "<p>You could probably use something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">have</span> <span class=\"n\">p_span_pq</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">Submodule.subset_span</span> <span class=\"o\">(</span><span class=\"n\">Set.mem_insert</span> <span class=\"n\">p</span> <span class=\"o\">{</span><span class=\"n\">q</span><span class=\"o\">})</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"o\">{⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a_span_pq</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b_span_pq</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p_span_pq</span><span class=\"o\">⟩}</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">Finset.card</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Finset.card_image_of_injective</span> <span class=\"n\">s</span> <span class=\"n\">Subtype.val_injective</span><span class=\"o\">]</span>\n    <span class=\"n\">aesop</span>\n</code></pre></div>",
        "id": 431181951,
        "sender_full_name": "Richard Copley",
        "timestamp": 1712180742
    },
    {
        "content": "<p>Lean didn't automatically use the equality <code>let</code> introduced there, so I had to explicitly rewrite. Nevertheless, that worked like a charm. That syntax will be handy in my future struggles.</p>\n<p>I will now have to supply the condition that <code>a, b, p</code> are linearly independent in <code>span K {p, q}</code>. So I will somehow convert my hypothesis <code>LinearIndependent K ![a, b, p]</code>. With a sorry, I wrote:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.FiniteDimensional</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span> <span class=\"n\">Submodule</span> <span class=\"n\">FiniteDimensional</span> <span class=\"n\">LinearIndependent</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">DivisionRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">pq_subspace_finite</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Module.Finite</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">Submodule.span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Module.Finite.span_of_finite</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">Set.toFinite</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">indexer</span>\n  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">a_span_pq</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}))</span>\n  <span class=\"o\">(</span><span class=\"n\">b_span_pq</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}))</span>\n  <span class=\"o\">(</span><span class=\"n\">p_span_pq</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}))</span> <span class=\"o\">:</span>\n    <span class=\"n\">Fin</span> <span class=\"mi\">3</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a_span_pq</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b_span_pq</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p_span_pq</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">abp_card_le_span_rank</span>\n  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">finite_submodule_instance</span> <span class=\"o\">:=</span> <span class=\"n\">pq_subspace_finite</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">pq_neq</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">abp_indep</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">])</span>\n  <span class=\"o\">(</span><span class=\"n\">a_span_pq</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}))</span>\n  <span class=\"o\">(</span><span class=\"n\">b_span_pq</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}))</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">card</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">})</span> <span class=\"bp\">≤</span> <span class=\"n\">finrank</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">p_span_pq</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">Submodule.subset_span</span> <span class=\"o\">(</span><span class=\"n\">Set.mem_insert</span> <span class=\"n\">p</span> <span class=\"o\">{</span><span class=\"n\">q</span><span class=\"o\">})</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"o\">{⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a_span_pq</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b_span_pq</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p_span_pq</span><span class=\"o\">⟩}</span>\n  <span class=\"k\">have</span> <span class=\"n\">card_eq</span> <span class=\"o\">:</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">Finset.card</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Finset.card_image_of_injective</span> <span class=\"n\">s</span> <span class=\"n\">Subtype.val_injective</span><span class=\"o\">]</span>\n    <span class=\"n\">aesop</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">card_eq</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">finset_card_le_finrank</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">}))</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"n\">abp_indep_sub</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">indexer</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">a_span_pq</span> <span class=\"n\">b_span_pq</span> <span class=\"n\">p_span_pq</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">exact</span> <span class=\"n\">abp_indep_sub</span>\n  <span class=\"c1\">-- type mismatch</span>\n  <span class=\"c1\">--   abp_indep_sub</span>\n  <span class=\"c1\">-- has type</span>\n  <span class=\"c1\">--   LinearIndependent K (indexer a b p q a_span_pq b_span_pq p_span_pq) : Prop</span>\n  <span class=\"c1\">-- but is expected to have type</span>\n  <span class=\"c1\">--   LinearIndependent K fun x =&gt; ↑x : Prop</span>\n</code></pre></div>\n<p>I can't wrap my head around why <code>LinearIndependent</code> expects a function that takes a vector, shouldn't it expect an indexing function? For example, before, we passed <code>![a, b, p]</code> which is of type <code>Fin 3 → V</code>.</p>",
        "id": 431710657,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1712442571
    },
    {
        "content": "<p>At this time it might be helpful for you to read the comments at the top of the source file <code>LinearIndependent.lean</code>. There it's explained how statements about linearly independent <em>sets</em> are formalized.</p>",
        "id": 431716031,
        "sender_full_name": "Richard Copley",
        "timestamp": 1712448861
    }
]