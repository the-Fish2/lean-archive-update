[
    {
        "content": "<p>The Lean book claims that structures are essentially syntax sugar for inductive types, like these two definitions of prod:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Prod</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">fst</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">snd</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Prod</span> <span class=\"n\">α</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Prod</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">mk</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">fst</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">snd</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The Lean book says:</p>\n<blockquote>\n<p>In Lean, the keyword structure can be used to define such an inductive type as well as its projections, at the same time.</p>\n</blockquote>\n<p>However, I really want to make a structure mutually recursive with an inductive type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n  <span class=\"kd\">inductive</span> <span class=\"n\">ElementKind</span>\n    <span class=\"bp\">|</span> <span class=\"n\">text</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">group</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Element</span><span class=\"o\">)</span>\n\n  <span class=\"kd\">structure</span> <span class=\"n\">Element</span> <span class=\"n\">where</span>\n    <span class=\"n\">kind</span> <span class=\"o\">:</span> <span class=\"n\">ElementKind</span>\n    <span class=\"n\">box</span> <span class=\"o\">:</span> <span class=\"n\">Box</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>But Lean rejects this, saying I have to define <code>Element</code> as an inductive type. Is there a workaround that lets me define <code>Element</code> as a structure? Or is it fundamentally important that <code>Element</code> be defined via <code>inductive</code>?</p>",
        "id": 425716667,
        "sender_full_name": "Will Crichton",
        "timestamp": 1710016283
    },
    {
        "content": "<p>Only a subset of inductive types can be structures. They can only have one constructor, cannot be recursive, and cannot have indices.</p>",
        "id": 425718354,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1710018096
    },
    {
        "content": "<p>That makes sense. Perhaps a different question is: is there a way to get the ergonomics of structures with structure-like inductive types? Eg I really enjoy the curly-brace syntax with field punning and such.</p>",
        "id": 425731562,
        "sender_full_name": "Will Crichton",
        "timestamp": 1710032158
    },
    {
        "content": "<p>^ bumping this again in case anyone has an answer. It's quite frustrating to not be able to define complex tree types using auxiliary <code>structure</code> definitions. Is the only solution to define more single-branch inductive types?</p>",
        "id": 429128562,
        "sender_full_name": "Will Crichton",
        "timestamp": 1711238340
    },
    {
        "content": "<p>Sorry to say it's not supported yet, but I hope to see it in the not-too-distant future</p>",
        "id": 429128851,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711238543
    },
    {
        "content": "<p>Got it, I'll keep my eyes on the changelogs!</p>",
        "id": 429129164,
        "sender_full_name": "Will Crichton",
        "timestamp": 1711238875
    }
]