[
    {
        "content": "<p>Hi, I am curious how one can write functions which output things of completely different types depending on their input. Something of the sort, for instance: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">exampleFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">‚Ñï</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>this expectedly throws a type mismatch error, since it is expecting to get something of type Type 0 but instead is given a real number. How do you deal with this?</p>",
        "id": 444035719,
        "sender_full_name": "VayusElytra",
        "timestamp": 1718120627
    },
    {
        "content": "<p>You would return a custom inductive with cases for each usually.</p>\n<p>Though this might be <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a></p>",
        "id": 444040803,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1718121941
    },
    {
        "content": "<p>Certainly, I can explain. I am trying to define a functor between two categories - the interval functor defined in section 4.1 of <a href=\"https://arxiv.org/pdf/1205.3669\">this paper</a> by Bubenik and Scott. <br>\nThis functor depends on a number of parameters (an interval I and real numbers a, b), which the type of the output depends on.</p>",
        "id": 444043511,
        "sender_full_name": "VayusElytra",
        "timestamp": 1718122536
    },
    {
        "content": "<p>One almost-option is <code>def exampleFun (x : ‚Ñù) : if x ‚â§ 0 then Type else ‚Ñù := ...</code>, but this doesn't work because <code>Type</code> and <code>‚Ñù</code> are in different universes. (Even if it worked here, this is a pain to work with.)</p>",
        "id": 444044115,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718122640
    },
    {
        "content": "<p>I'm looking at section 4.1, and I'm not seeing what could need what you're doing with <code>exampleFun</code>. Could you explain your design so far and what definition you're working on formalizing?</p>",
        "id": 444044893,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718122793
    },
    {
        "content": "<p>Sure, this was just a toy example to ask about the topic without introducing a ton of cumbersome notation (which I'd already written down in another thread, and I did not want to ask similar questions 20 times). </p>\n<p>For a division ring F, these two definitions give the objects in ModuleCat F with carriers F and the 0-module, respectively: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ZeroSubmod</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DivisionRing</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SelfSubmod</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DivisionRing</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">F</span>\n</code></pre></div>\n<p>This is the \"object\" part of the interval module defined in 4.1: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IntervalModuleObject</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DivisionRing</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ModuleCat</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">SelfSubmod</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">ZeroSubmod</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>No issues here since both F itself and the trivial module are seen as objects of a single type, ModuleCat F.</p>\n<p>This is what I am working with for the morphisms: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IntervalModuleMorphism</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">DivisionRing</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SelfSubmod</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ZeroSubmod</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"c1\">-- some other stuff that I will take care of after this issue is resolved.</span>\n</code></pre></div>\n<p>Lean comes up with a type mismatch error here since <code>ùüô (SelfSubmod F)</code> and <code>ùüô (ZeroSubmod F)</code>, the identity morphisms of the 0-module and F seen as elements of the category of modules over F, have different types. So if I understand right, I just need to define my own new type, which would correspond to \"morphisms between F modules\", and construct elements of that type corresponding to these morphisms in order for them to live in the same type, and so  for Lean to accept my definition.</p>",
        "id": 444049947,
        "sender_full_name": "VayusElytra",
        "timestamp": 1718123871
    },
    {
        "content": "<blockquote>\n<p>So if I understand right, I just need to define my own new type, which would correspond to \"morphisms between F modules\"</p>\n</blockquote>\n<p>I don't think that's right. You're trying to make a morphism here in a pre-existing category (<code>ModuleCat F</code>), right? Wouldn't it be something like the following then?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IntervalModuleMorphism</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">DivisionRing</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IntervalModuleObject</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">IntervalModuleObject</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 444051830,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718124440
    },
    {
        "content": "<p>Oh, that is a really good idea. I don't know why I didn't think of it <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span> thank you! I'll try it.</p>",
        "id": 444055910,
        "sender_full_name": "VayusElytra",
        "timestamp": 1718125578
    }
]