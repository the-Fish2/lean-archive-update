[
    {
        "content": "<p>(Noting by  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">E(X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span> some metric space of functions on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>)<br>\nFor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">S \\subseteq X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, I have an isometric embedding <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo stretchy=\"false\">(</mo><mi>S</mi><mo stretchy=\"false\">)</mo><mo>↪</mo><mi>E</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">E(S)\\hookrightarrow E(X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↪</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span> </p>\n<p>I would like to make:</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mo>⋃</mo><mo stretchy=\"false\">{</mo><mi>E</mi><mo stretchy=\"false\">(</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∣</mi><mi>Y</mi><mo>⊆</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi><mtext> is finite</mtext><mo stretchy=\"false\">}</mo><mo>⊆</mo><mi>E</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\bigcup \\{E(Y) | Y \\subseteq X, Y \\text{ is finite} \\} \\subseteq E(X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.6em;vertical-align:-0.55em;\"></span><span class=\"mop op-symbol large-op\" style=\"position:relative;top:0em;\">⋃</span><span class=\"mopen\">{</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mord text\"><span class=\"mord\"> is finite</span></span><span class=\"mclose\">}</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>with the usual abuse of notation of identifying <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo stretchy=\"false\">(</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">E(Y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span></span></span></span>  as a subset  of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">E(X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span> with the embedding, but I seem to be having some trouble with set comprehension. What is the canonical way to make this construction?</p>",
        "id": 426633440,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1710452200
    },
    {
        "content": "<p>Can you provide an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ?</p>",
        "id": 426634880,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710452815
    },
    {
        "content": "<p>Not easily. I'll give it a try this weekend</p>",
        "id": 426640948,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1710455637
    },
    {
        "content": "<p>The space E(x) is defined as a structure if it helps</p>",
        "id": 426641046,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1710455670
    },
    {
        "content": "<p>You can likely omit the details, but mainly I'm wondering whether <code>X : Type*</code> and <code>S : Set X</code> or not. And does <code>E</code> take a type as an argument, or a set?</p>",
        "id": 426656888,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710465170
    },
    {
        "content": "<p>Good point. Indeed you guessed correctly <code>X : Type*</code> and <code>S : Set X</code>, and E takes a type, so it's technically <code>E(↑S)</code> (also note that up to the isometric embedding included, I have actual working lean proofs)</p>",
        "id": 426684644,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1710486372
    },
    {
        "content": "<p>Great! Then it should be not too much trouble to make that <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> which will make your question answerable.</p>",
        "id": 426702146,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710494284
    },
    {
        "content": "<p>Note that in a mwe you can sorry all proofs, the point is that you ask your chosen formalisation of your maths question so that other people don't waste their time answering a question which you didn't mean to ask (eg a question about a different implementation of the specification which you've already given above)</p>",
        "id": 426702412,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710494394
    },
    {
        "content": "<p>Indeed. So this should hopefully be close enough to a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> </p>\n<p>The following stuff is \"all good\" (by me at least):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MetricSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">mk_iff</span><span class=\"kd\">]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">IsKatetov</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">abs_sub_le_dist</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"bp\">|</span> <span class=\"bp\">≤</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n  <span class=\"n\">dist_le_add</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">KatetovMap</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">MetricSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"kn\">protected</span> <span class=\"n\">toFun</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span>\n  <span class=\"kn\">protected</span> <span class=\"n\">IsKatetovtoFun</span> <span class=\"o\">:</span> <span class=\"n\">IsKatetov</span> <span class=\"n\">toFun</span>\n\n<span class=\"kd\">notation</span> <span class=\"s2\">\"E(\"</span> <span class=\"n\">α</span> <span class=\"s2\">\")\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">KatetovMap</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span><span class=\"o\">:</span> <span class=\"n\">MetricSpace</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CompleteSpace</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">kuratwoski_embedding</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">MetricSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">Isometry</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- this has some actual work inside it</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">extend</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">MetricSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- this does merely the obvious thing</span>\n<span class=\"kd\">def</span> <span class=\"n\">restrict</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">MetricSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">--this uses \"extend\"</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">subset_embedding</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">MetricSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">Isometry</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>To give context, I now want the set I described at the start as a metric space, with the same metric as E(α). <br>\nSo the following \"direct\" adaptation I think is probably a terrible idea:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">FinSuppKatMaps</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"bp\">⋃₀</span> <span class=\"o\">{</span><span class=\"n\">subset_embed</span> <span class=\"n\">s</span> <span class=\"bp\">''</span> <span class=\"o\">(</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">Set.Finite</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)}</span>\n</code></pre></div>\n<p>(modulo the fact that it doesn't work because I clearly haven't understood how set comprehension works.)<br>\nAlternatively, I was thinking of doing something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- s here is called the \"support\" of f</span>\n<span class=\"kd\">def</span> <span class=\"n\">HasFinSuppKatMap</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n     <span class=\"bp\">∃</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">Set.Finite</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">extend</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">restrict</span> <span class=\"n\">s</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">FinSuppKatetovMap</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">MetricSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">KatetovMap</span> <span class=\"n\">α</span>  <span class=\"n\">where</span>\n    <span class=\"kn\">protected</span> <span class=\"n\">HasFinSuppKatetovtoFun</span> <span class=\"o\">:</span> <span class=\"n\">HasFinSuppKatMap</span> <span class=\"n\">toKatetovMap</span>\n\n<span class=\"kd\">notation</span> <span class=\"s2\">\"E(\"</span> <span class=\"n\">α</span> <span class=\"s2\">\", ω)\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">FinSuppKatetovMap</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>Which should be equivalent to the thing above, but then I found it surprisingly painful to make E(α, ω), inherit the metric structure, so I was considering that other approach above</p>\n<p>For further context, the next steps would be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">MetricSpace</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CompleteSpace</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">finsupp_kuratoswki_embedding</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">MetricSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">ω</span><span class=\"o\">),</span> <span class=\"n\">Isometry</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>  <span class=\"c1\">-- which is easy \"mathematically\", I just had the pain with E(α, ω)</span>\n</code></pre></div>\n<p>Then I make a sequence α_{n+1} = E(αₙ, ω) and get the limit space with <code>Metric.Inductive</code>, which is what I am actually interested in. I don't suppose that should be a problem with a decent  definition of E(α, ω)</p>",
        "id": 426725003,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1710502623
    },
    {
        "content": "<p>Some tube thoughts (which fit after your first code block above):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"c1\">-- I would go for this one</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">)),</span> <span class=\"n\">s.Finite</span> <span class=\"bp\">∧</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">extend</span> <span class=\"n\">s</span> <span class=\"n\">ψ</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- `Finset` is constructive so is slightly harder to use, but has its benefits</span>\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">)),</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">extend</span> <span class=\"n\">s</span> <span class=\"n\">ψ</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- To prove they're \"the same\" you seem to need some more API.</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">better_restrict_function</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MetricSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">better_restrict</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Isometry</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">KatetovMap.equiv</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">MetricSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MetricSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Isometry</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"n\">better_restrict</span> <span class=\"n\">f.symm</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">invFun</span> <span class=\"o\">:=</span> <span class=\"n\">better_restrict</span> <span class=\"n\">f</span> <span class=\"n\">hf</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">bar</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">φ</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">ψ</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">hs.toFinset</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">⟩</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Lean treats types and subsets on different footings, as you'll be aware. My gut feeling is that your <code>extend</code> and <code>restrict</code> should be refactored to deal with the more general situation of an isometric injection of metric spaces rather than subets with the induced metric structure; in Lean the former situation is more general and more useful. <code>foo</code> is my proposed answer to your question.</p>",
        "id": 426742613,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710508943
    },
    {
        "content": "<p>First off: thank you for the answer. Doing the refactoring you pointed out took a whole of two minutes, so that's good. But so you would still suggest going the set way? Presumably replacing <code>s</code> with something like this now:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hβ</span> <span class=\"o\">:</span> <span class=\"n\">MetricSpace</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hρ</span> <span class=\"o\">:</span> <span class=\"n\">Isometry</span> <span class=\"n\">ρ</span><span class=\"o\">)</span>\n   <span class=\"o\">(</span><span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"o\">)),</span> <span class=\"n\">Finite</span> <span class=\"n\">β</span> <span class=\"bp\">∧</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">extend₂</span> <span class=\"n\">ρ</span> <span class=\"n\">hρ</span> <span class=\"n\">ψ</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>or to keep it constructive:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hβ</span> <span class=\"o\">:</span> <span class=\"n\">MetricSpace</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hρ</span> <span class=\"o\">:</span> <span class=\"n\">Isometry</span> <span class=\"n\">ρ</span><span class=\"o\">)</span>\n   <span class=\"o\">(</span><span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"o\">)),</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">extend₂</span> <span class=\"n\">ρ</span> <span class=\"n\">hρ</span> <span class=\"n\">ψ</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>It doesn't seem very mathlib-y? Also if I try <code>instance : MetricSpace (@foo α _) := by infer_instance</code> I get </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">compiler</span> <span class=\"n\">IR</span> <span class=\"n\">check</span> <span class=\"n\">failed</span> <span class=\"n\">at</span> <span class=\"bp\">'</span><span class=\"n\">KatetovExtension.instMetricSpaceElemKatetovMapFoo._rarg'</span><span class=\"o\">,</span> <span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">unknown</span> <span class=\"n\">declaration</span> <span class=\"bp\">'</span><span class=\"n\">instMetricSpaceKatetovMap'</span>\n</code></pre></div>\n<p>which is an error I've never seen before, so I guess at least I Iearned something.</p>",
        "id": 426762280,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1710515048
    },
    {
        "content": "<p>the \"compiler IR check\" just means you need to mark it <code>noncomputable</code></p>",
        "id": 426766945,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710516374
    },
    {
        "content": "<p>My version would have been:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⋃</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">Set.range</span> <span class=\"o\">(</span><span class=\"n\">extend</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>And presumably you want to show that <code>Isometry (extend s)</code> instead of just <code>∃ f : E(s) → E(α), Isometry f</code>.</p>",
        "id": 426768308,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710516732
    },
    {
        "content": "<p>Also, I agree with Kevin. If you want make this material act on types and the appropriate kind of embeddings, I think it will be easier in the long run.</p>",
        "id": 426768465,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710516775
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113489-new-members/topic/Set.20union.20of.20spaces.20.28abuse.29.2C.20identifying.20.20as.20subset.3F/near/426766945\">said</a>:</p>\n<blockquote>\n<p>the \"compiler IR check\" just means you need to mark it <code>noncomputable</code></p>\n</blockquote>\n<p>Ah, now it works!</p>\n<p>For the second point, I have indeed eliminated all <code>s : Set α</code> and replaced it with <code> (β : Type*) [MetricSpace β] (ρ : β → α) (hρ : Isometry ρ)</code>. But then <code>bar</code> would remain the outlier... That is why I was thinking of making it its own type via <code>extends</code>.  But then I ran into all sorts of issues with the coercions between my new <code>FinsuppKatMap</code> type,  <code>KatetovMap</code>, and   <code>α → ℝ</code></p>",
        "id": 426770873,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1710517467
    },
    {
        "content": "<p>On the other hand, prooving the embedding of <code>α</code> into <code>bar</code> was easy, so I might leave it at that...</p>",
        "id": 426776954,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1710519274
    }
]