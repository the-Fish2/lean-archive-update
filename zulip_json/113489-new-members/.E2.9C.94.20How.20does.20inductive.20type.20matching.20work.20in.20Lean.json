[
    {
        "content": "<p>Hi, I'm a beginner on zulip and lean so I'm not sure if I'm doing this right but I have a question. In the functional programming with lean book, there's an example about inductive type matching where a definition isZero of type Bool is created like this <br>\n<a href=\"/user_uploads/3121/Pci30bzRLTssmn2bEBz1vcx5/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Pci30bzRLTssmn2bEBz1vcx5/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/Pci30bzRLTssmn2bEBz1vcx5/image.png\"></a></div>",
        "id": 433167637,
        "sender_full_name": "Jafar Tanoukhi",
        "timestamp": 1713131181
    },
    {
        "content": "<p>My question is how does this exactly work, like how does lean figure out that 999 can be matched with succ k, because to me it is unlikely that it recursively goes through all the succs until it reaches 0 (succ 998 -&gt; succ succ 997 -&gt; succ succ succ 996 .... -&gt; succ succ succ... 0 )</p>",
        "id": 433167797,
        "sender_full_name": "Jafar Tanoukhi",
        "timestamp": 1713131332
    },
    {
        "content": "<p>The number <code>999</code> is equivalent to <code>Nat.succ 998</code>, so it can see <code>k = 998</code> without any recursion.</p>",
        "id": 433168304,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713131802
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general/topic/How.20does.20inductive.20type.20matching.20work.20in.20Lean\">#general &gt; How does inductive type matching work in Lean</a> by <span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span>.</p>",
        "id": 433168316,
        "sender_full_name": "Notification Bot",
        "timestamp": 1713131817
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"710010\">@Jafar Tanoukhi</span> I moved your message here)</p>",
        "id": 433168341,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713131843
    },
    {
        "content": "<p>there are multiple facets to this question.</p>\n<p>First let's take the naive POV, we know that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat#doc\">docs#Nat</a> is either <code>Nat.zero : Nat</code> or <code>Nat.succ : Nat -&gt; Nat</code>. That means that a <code>Nat</code> that is not <code>zero</code> will be represented by a chain of <code>succ</code>'s that terminate in a <code>zero</code>. In memory this would be represented by Lean as basically a linked list of nodes, each of these nodes carry a tag that identifies them as either zero or a succ (in which case the node also contains a pointer to the next element). Thus to identify a <code>Nat</code> as a <code>succ</code> it will simply look at the first node of the linked list and check the tag, if its the tag for <code>zero</code> it goes into the first branch, if its the tag for <code>succ</code> the second. The <code>k</code> will just be the node that the first node points to.</p>\n<p>Now practically natural numbers are actually represented as an efficient type for big integers so what is really happening in the runtime of the program is that it checks if that big integer is zero and if it isnt it subtracts one and uses that for the <code>k</code> in the <code>succ</code> branch.</p>\n<p>That said in the general case when an inductive type is not represented by some efficient structure like a big integer the first idea applies</p>",
        "id": 433168412,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1713131891
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20does.20inductive.20type.20matching.20work.20in.20Lean/near/433168341\">said</a>:</p>\n<blockquote>\n<p>(<span class=\"user-mention silent\" data-user-id=\"710010\">Jafar Tanoukhi</span> I moved your message here)</p>\n</blockquote>\n<p>oh thanks</p>",
        "id": 433168970,
        "sender_full_name": "Jafar Tanoukhi",
        "timestamp": 1713132350
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20does.20inductive.20type.20matching.20work.20in.20Lean/near/433168412\">said</a>:</p>\n<blockquote>\n<p>there are multiple facets to this question.</p>\n<p>First let's take the naive POV, we know that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat#doc\">docs#Nat</a> is either <code>Nat.zero : Nat</code> or <code>Nat.succ : Nat -&gt; Nat</code>. That means that a <code>Nat</code> that is not <code>zero</code> will be represented by a chain of <code>succ</code>'s that terminate in a <code>zero</code>. In memory this would be represented by Lean as basically a linked list of nodes, each of these nodes carry a tag that identifies them as either zero or a succ (in which case the node also contains a pointer to the next element). Thus to identify a <code>Nat</code> as a <code>succ</code> it will simply look at the first node of the linked list and check the tag, if its the tag for <code>zero</code> it goes into the first branch, if its the tag for <code>succ</code> the second. The <code>k</code> will just be the node that the first node points to.</p>\n<p>Now practically natural numbers are actually represented as an efficient type for big integers so what is really happening in the runtime of the program is that it checks if that big integer is zero and if it isnt it subtracts one and uses that for the <code>k</code> in the <code>succ</code> branch.</p>\n<p>That said in the general case when an inductive type is not represented by some efficient structure like a big integer the first idea applies</p>\n</blockquote>\n<p>so this \"ability\" to effeciently just subtract 1 is cooked into Lean just for Nat ?</p>",
        "id": 433169043,
        "sender_full_name": "Jafar Tanoukhi",
        "timestamp": 1713132393
    },
    {
        "content": "<p>It also works for types that are built on top of <code>Nat</code> of course, so for example <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin#doc\">docs#Fin</a> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BitVec#doc\">docs#BitVec</a>. Furthermore we also have support for fixed width integers such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UInt8#doc\">docs#UInt8</a> that are a literal <code>uint8_t</code> in C.</p>",
        "id": 433169101,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1713132456
    },
    {
        "content": "<p>Note that <code>Nat</code> operations in general are also implemented efficiently. For example <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.add#doc\">docs#Nat.add</a> is implemented by an extern function as you can see by the <code>extern</code> attribute. THe implementation in Lean is an equivalent one for performing proofs while the <code>extern</code> one is a performant C function from the big integer library.</p>",
        "id": 433169593,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1713132793
    },
    {
        "content": "<p>i was trying something like this to see if it would be super slow or if it would crash because stack overflow or something but it failed to compile, i think its because in my succ2 i am trying to add a nat2 into a nat which is not defined. am i right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Nat2</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">Nat2</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ2</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">:</span><span class=\"n\">Nat2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat2</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">succ2</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Nat2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat2</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">isZero</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Nat2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">Nat2.zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"n\">Nat2.succ2</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">isZero</span> <span class=\"mi\">4</span>\n</code></pre></div>\n<p>anyways if you can assume this code is defined properly, would doing something like <br>\n#eval isZero 9999999999 cause some super slow solution or some stackoverflow because of the recursion that will need to be done to check the matching ?</p>",
        "id": 433169867,
        "sender_full_name": "Jafar Tanoukhi",
        "timestamp": 1713133029
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20does.20inductive.20type.20matching.20work.20in.20Lean/near/433169593\">said</a>:</p>\n<blockquote>\n<p>Note that <code>Nat</code> operations in general are also implemented efficiently. For example <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.add#doc\">docs#Nat.add</a> is implemented by an extern function as you can see by the <code>extern</code> attribute. THe implementation in Lean is an equivalent one for performing proofs while the <code>extern</code> one is a performant C function from the big integer library.</p>\n</blockquote>\n<p>also thanks for the references, I will make sure to check them out when i can</p>",
        "id": 433169998,
        "sender_full_name": "Jafar Tanoukhi",
        "timestamp": 1713133149
    },
    {
        "content": "<p>You are right about the first thing.</p>\n<p>You are wrong about the second thing. As I explained performing the match for <code>isZero</code> is <code>O(1)</code> regardless of whether you have the efficient or the basic representation at run time. The issue with running that program would be that you first have to build a linked list that corresponds to this giant number which will probably let you consume a ton of memory if not run out of memory</p>",
        "id": 433170000,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1713133149
    },
    {
        "content": "<p>oh wait is there such thing as defining \"matching rules\" or something that lean uses to check if a value matches a definition? like for <a href=\"http://Nat2.zero\">Nat2.zero</a> i think it is trivial and lean can do it on it's own but for Nat2.succ building the linked list as you said would be defining the matching rule</p>",
        "id": 433170251,
        "sender_full_name": "Jafar Tanoukhi",
        "timestamp": 1713133376
    },
    {
        "content": "<p>matching on the succ constructor does not build the linked list. The linked list is built upon the construction of a number and then inspected by the <code>match</code>, you cannot override the external representation of a type or the behavior of match without reaching for at least FFI or, depending on how crazy you want to go, runtime modifications.</p>",
        "id": 433170349,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1713133456
    },
    {
        "content": "<p>It's probably best to ignore the special representation for <code>Nat</code> when starting out. That's just for things like having fast <code>Nat.mul</code>, faster than the one that assumes a unary representation. It has no effect on the logic.</p>\n<p>The point is that, for example, <code>5</code> is logically <code>Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))</code>, so when pattern matching, it's clearly not <code>Nat.zero</code>, and then it can match against <code>Nat.succ k</code> with <code>k = Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))</code> by popping off the outermost <code>Nat.succ</code>. There's no recursion involved.</p>\n<p>It's worth emphasizing here that <code>5</code> <em>is</em> <code>Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero))))</code>, so there's no linked list building when a function is being called. It's when the number itself is elaborated.</p>",
        "id": 433170643,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713133684
    },
    {
        "content": "<p>(This is where that special handling of <code>Nat</code> that Henrik mentioned comes in. A number like <code>9999999999</code> doesn't literally get represented as a linked list internally. It's only logically a linked list. And furthermore, matching knows how to deal with the efficient representation: it can see that <code>9999999999</code> is non-zero efficiently, and it can calculate <code>9999999999 - 1</code> efficiently)</p>",
        "id": 433170697,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713133744
    },
    {
        "content": "<p>ok thanks a lot for you both, this helped clear up some confusion. I think as you said, I'll worry about understanding the special handling of Nat later.</p>",
        "id": 433171089,
        "sender_full_name": "Jafar Tanoukhi",
        "timestamp": 1713134045
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"710010\">Jafar Tanoukhi</span> has marked this topic as resolved.</p>",
        "id": 433174013,
        "sender_full_name": "Notification Bot",
        "timestamp": 1713136984
    }
]