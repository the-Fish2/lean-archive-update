[
    {
        "content": "<p>How do I construct a type which is the product of a Type and a Prop?</p>\n<p>I tried this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">True</span>\n</code></pre></div>\n<p>and got the following error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">True</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">True</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Prop</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"n\">u.1284</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">u.1284</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I'm confused because <code>Prod</code> appears to accept types that live in different universes at <a href=\"https://github.com/leanprover/lean4/blob/master/src/Init/Prelude.lean#L479\">https://github.com/leanprover/lean4/blob/master/src/Init/Prelude.lean#L479</a>.</p>\n<p>What I'm trying to do is define inductively a type of MaybeInvalidWidgets, and then define a Widget to be a MaybeInvalidWidget together with a proof that the widget is actually valid.</p>",
        "id": 420521363,
        "sender_full_name": "Preeyan Parmar",
        "timestamp": 1707418272
    },
    {
        "content": "<p>Oh, the next lines below show that I need <code>PProp</code>! Is there a \\times notation for that?</p>",
        "id": 420521574,
        "sender_full_name": "Preeyan Parmar",
        "timestamp": 1707418345
    },
    {
        "content": "<p>it sounds like you're just looking to create a Subtype</p>",
        "id": 420525908,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1707419944
    },
    {
        "content": "<p>something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Widget</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">MaybeInvalidWidget</span> <span class=\"bp\">//</span> <span class=\"n\">isValid</span> <span class=\"n\">w</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 420526122,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1707420026
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subtype#doc\">docs#Subtype</a></p>",
        "id": 420526859,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1707420315
    },
    {
        "content": "<p>Perfect, thanks! Looks like Subtype is just a structure and for more complicated things you'd just make your own structure?</p>",
        "id": 420528068,
        "sender_full_name": "Preeyan Parmar",
        "timestamp": 1707420823
    },
    {
        "content": "<p>Sure, if you have a more complicated arrangement of data and/or propositions then you can create your own structure to bundle them together. But if you're just pairing a type with a proposition about that type, <code>Subtype</code> is the way to go. There are plenty of lemmas about it in the codebase that make it easy to work with.</p>",
        "id": 420528557,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1707421007
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306502\">Preeyan Parmar</span> has marked this topic as resolved.</p>",
        "id": 420531355,
        "sender_full_name": "Notification Bot",
        "timestamp": 1707422128
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306502\">Preeyan Parmar</span> has marked this topic as unresolved.</p>",
        "id": 420927467,
        "sender_full_name": "Notification Bot",
        "timestamp": 1707690892
    },
    {
        "content": "<p>Subtype is very nice and I've used it a bit now. However I find myself wanting to write a function of type</p>\n<p><code>(m : Nat) -&gt; (n : Nat) × Option (String × (n &lt; m))</code></p>\n<p>i.e. given a natural m, you get another natural n, and either a message and a proof that n &lt; m, or no message and no claim about m and n.</p>\n<p>I'm not very clear how to do this sensibly; in particular, I'm not sure how to write a structure to capture this because of the dependence of the output on m and n.</p>",
        "id": 420927730,
        "sender_full_name": "Preeyan Parmar",
        "timestamp": 1707691167
    },
    {
        "content": "<p>For your original question, this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span> <span class=\"n\">PProd</span> <span class=\"n\">Nat</span> <span class=\"n\">True</span>\n</code></pre></div>",
        "id": 420928211,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707691633
    },
    {
        "content": "<p>As does</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">PLift</span> <span class=\"n\">True</span>\n</code></pre></div>",
        "id": 420928220,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707691647
    },
    {
        "content": "<p>Your issue is that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Prod#doc\">docs#Prod</a> is defined to only take <code>Type u</code>, not <code>Sort u</code>; so either you need <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PProd#doc\">docs#PProd</a> which takes the latter, or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PLift#doc\">docs#PLift</a> that promotes the latter to the former.</p>",
        "id": 420928237,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707691677
    },
    {
        "content": "<p>The best I've come up with for the second is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Option</span> <span class=\"n\">String</span> <span class=\"bp\">//</span> <span class=\"n\">t.2.isSome</span> <span class=\"bp\">→</span> <span class=\"n\">t.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>which seems a bit grim.</p>",
        "id": 420928243,
        "sender_full_name": "Preeyan Parmar",
        "timestamp": 1707691681
    },
    {
        "content": "<p><code>(m : Nat) -&gt; (n : Nat) × Option ({s : String // n &lt; m})</code> should be fine, using the same <code>Subtype</code> notation as before.</p>",
        "id": 420928302,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707691714
    },
    {
        "content": "<p>don't you need to use a sigma type here?</p>",
        "id": 420928322,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1707691741
    },
    {
        "content": "<p><code>(n : Nat) × foo n</code> <em>is</em> a sigma type (due to the binder, <code>×</code> is confusingly notation for <code>Sigma</code> not <code>Prod</code>)</p>",
        "id": 420928342,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707691754
    },
    {
        "content": "<p>oh huh, I thought it was just a <code>Prod</code>... didn't realize it was also dependent</p>",
        "id": 420928360,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1707691782
    },
    {
        "content": "<p>something seems wrong to me about using a subtype where the prop doesn't depend on the value</p>",
        "id": 420928455,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1707691857
    },
    {
        "content": "<p>but I suppose I'm just a purist</p>",
        "id": 420928470,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1707691871
    },
    {
        "content": "<p>Seems to be working <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> . I did indeed get very confused by <code>×</code> silently becoming Sigma and requiring a different constructor notation!</p>",
        "id": 420929829,
        "sender_full_name": "Preeyan Parmar",
        "timestamp": 1707693022
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306502\">Preeyan Parmar</span> has marked this topic as resolved.</p>",
        "id": 420929832,
        "sender_full_name": "Notification Bot",
        "timestamp": 1707693026
    }
]