[
    {
        "content": "<p>How to change \"simp only list\" into \"simp only single lines\"? Because i want to know every single step it takes. It helps new users more convenient to read theorems , Right?</p>\n<p>For example , </p>\n<p>Check this \"simp only [exists_prop,<br>\n      Finset.mem_biUnion, Finset.mem_filter, Finset.mem_range, mem_nthRoots, Finset.mem_mk,<br>\n      Nat.mem_divisors, and_true_iff, Ne.def, PNat.ne_zero, PNat.pos, not_false_iff]\"</p>\n<p>how to change it into the form like this , we can't just put the list in order , So , Is there a way ? :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">single_tactic</span><span class=\"o\">]</span>\n<span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">single_tactic</span><span class=\"o\">]</span>\n<span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">single_tactic</span><span class=\"o\">]</span>\n<span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">single_tactic</span><span class=\"o\">]</span>\n<span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">single_tactic</span><span class=\"o\">]</span>\n<span class=\"bp\">......</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">nthRoots_one_eq_biUnion_primitiveRoots'</span> <span class=\"o\">{</span><span class=\"n\">ζ</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">IsPrimitiveRoot</span> <span class=\"n\">ζ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">nthRootsFinset</span> <span class=\"n\">n</span> <span class=\"n\">R</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Nat.divisors</span> <span class=\"bp\">↑</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">biUnion</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">primitiveRoots</span> <span class=\"n\">i</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">symm</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Finset.eq_of_subset_of_card_le</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">x</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">nthRootsFinset</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Multiset.toFinset_eq</span> <span class=\"o\">(</span><span class=\"n\">nthRoots_nodup</span> <span class=\"n\">h</span><span class=\"o\">)]</span>\n    <span class=\"c1\">-- ⊢ (x ∈ Finset.biUnion (Nat.divisors ↑n) fun i ↦ primitiveRoots i R) →</span>\n    <span class=\"c1\">-- x ∈ { val := nthRoots (↑n) 1, nodup := (_ : Multiset.Nodup (nthRoots (↑n) 1)) }</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">exists_prop</span><span class=\"o\">,</span>\n      <span class=\"n\">Finset.mem_biUnion</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_filter</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_range</span><span class=\"o\">,</span> <span class=\"n\">mem_nthRoots</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_mk</span><span class=\"o\">,</span>\n      <span class=\"n\">Nat.mem_divisors</span><span class=\"o\">,</span> <span class=\"n\">and_true_iff</span><span class=\"o\">,</span> <span class=\"n\">Ne.def</span><span class=\"o\">,</span> <span class=\"n\">PNat.ne_zero</span><span class=\"o\">,</span> <span class=\"n\">PNat.pos</span><span class=\"o\">,</span> <span class=\"n\">not_false_iff</span><span class=\"o\">]</span>\n    <span class=\"c1\">-- ⊢ (∃ a, a ∣ ↑n ∧ x ∈ primitiveRoots a R) → x ^ ↑n = 1</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">hd</span><span class=\"o\">⟩,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span>\n    <span class=\"k\">have</span> <span class=\"n\">hazero</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">contrapose</span><span class=\"bp\">!</span> <span class=\"n\">hd</span> <span class=\"k\">with</span> <span class=\"n\">ha0</span>\n      <span class=\"n\">simp_all</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">nonpos_iff_eq_zero</span><span class=\"o\">,</span> <span class=\"n\">zero_mul</span><span class=\"o\">]</span>\n      <span class=\"n\">exact</span> <span class=\"n\">n.ne_zero</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_primitiveRoots</span> <span class=\"n\">hazero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">ha</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hd</span><span class=\"o\">,</span> <span class=\"n\">pow_mul</span><span class=\"o\">,</span> <span class=\"n\">ha.pow_eq_one</span><span class=\"o\">,</span> <span class=\"n\">one_pow</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">le_of_eq</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h.card_nthRootsFinset</span><span class=\"o\">,</span> <span class=\"n\">Finset.card_biUnion</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">nth_rw</span> <span class=\"mi\">1</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Nat.sum_totient</span> <span class=\"n\">n</span><span class=\"o\">]</span>\n      <span class=\"n\">refine'</span> <span class=\"n\">sum_congr</span> <span class=\"n\">rfl</span> <span class=\"n\">_</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Nat.mem_divisors</span><span class=\"o\">]</span>\n      <span class=\"n\">rintro</span> <span class=\"n\">k</span> <span class=\"o\">⟨⟨</span><span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">hd</span><span class=\"o\">⟩,</span> <span class=\"bp\">-</span><span class=\"o\">⟩</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hd</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[(</span><span class=\"n\">h.pow</span> <span class=\"n\">n.pos</span> <span class=\"n\">hd</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card_primitiveRoots</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">i</span> <span class=\"n\">_</span> <span class=\"n\">j</span> <span class=\"n\">_</span> <span class=\"n\">hdiff</span>\n      <span class=\"n\">exact</span> <span class=\"n\">disjoint</span> <span class=\"n\">hdiff</span>\n  <span class=\"n\">done</span>\n</code></pre></div>",
        "id": 427582888,
        "sender_full_name": "chenjulang",
        "timestamp": 1710799426
    },
    {
        "content": "<p>You might want <code>simp_rw [list, ...]</code> which is the best of both worlds for readability; but you have to assemble it by hand</p>",
        "id": 427583451,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710799687
    },
    {
        "content": "<p>Simp can use other theorems to discharge side conditions, so in general your simp only single line isn't possible.</p>",
        "id": 427583767,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1710799841
    },
    {
        "content": "<p>You should take a look at <a href=\"https://github.com/nomeata/lean-calcify\">https://github.com/nomeata/lean-calcify</a></p>",
        "id": 427583914,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1710799920
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"665035\">chenjulang</span> has marked this topic as resolved.</p>",
        "id": 427660550,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710844026
    }
]