[
    {
        "content": "<p>In T<a href=\"https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html\">heorem Proving in Lean 4 at the end of the section on Dependent Type Theory</a> we see</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">id</span>        <span class=\"c1\">-- {α : Type u_1} → α → α</span>\n</code></pre></div>\n<p>A run of <code>#check @id</code> in Lean 4 Web gives, instead of <code>{α : Type u_1} → α → α</code>, the result</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>We can put in two versions of <code>id</code> and get either <code>Type u_1</code> or <code>Sort u_1</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ident</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"n\">ident</span>        <span class=\"c1\">-- ident.{u} {α : Type u} (x : α) : α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ident1</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"n\">ident1</span>    <span class=\"c1\">-- ident1.{u} {α : Sort u} (x : α) : α</span>\n</code></pre></div>\n<p>So<code>Sort u</code> or <code>Type u</code> are equivalent in the above example. </p>\n<p>My understanding is that <code>Prop</code> is a synonym for <code>Sort 0</code> and <code>Type</code> is a synonym for <code>Type 0</code> and <code>Type 0</code> is a synonym for <code>Sort 1</code> making <code>Type n</code> a synonym for <code>Sort (n+1)</code>.</p>\n<p>Does having both <code>Sort</code> and <code>Type</code> in Lean 4 add value?  It seems like one or the other would be sufficient.  What am I missing?</p>",
        "id": 409851618,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1703462318
    },
    {
        "content": "<p><code>Type u</code> is exactly <code>Sort (u + 1)</code> internally.</p>\n<p>One reason for <code>Type u</code> is that <code>Prop</code> has some different rules for which universe a pi type lives in. If you work with <code>Sort u</code> sometimes the universe level expressions can get more complicated than if you just used <code>Type u</code>.</p>\n<p>One reason for <code>Sort u</code> is that then you can make definitions that work for <code>Prop</code> too. Potentially Lean could just not have <code>Sort</code> at all, leaving you to create separate definitions for <code>Prop</code> and <code>Type u</code>. It's nice being able to define a single definition that works for both when possible.</p>",
        "id": 409852428,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703462912
    },
    {
        "content": "<p>Thanks for the explanation!  It would be nice to write this down in a record similar to <a href=\"https://peps.python.org/\">Python PEPs</a>.  The explanation shows that it is a parsimonious choice.</p>\n<p>I'm curious why the choice of abbreviation is sticky in the interpreter in the sense that it remembers whether I used <code>Type</code> or <code>Sort</code> in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ident</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"n\">ident</span>        <span class=\"c1\">-- ident.{u} {α : Type u} (x : α) : α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ident1</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"n\">ident1</span>    <span class=\"c1\">-- ident1.{u} {α : Sort u} (x : α) : α</span>\n</code></pre></div>\n<p>when under the hood they are equivalent (i.e. why doesn't this normalize to one canonical choice).</p>",
        "id": 409925211,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1703522118
    },
    {
        "content": "<p>They are not equivalent. Type u will never be Prop. Sort u can be.</p>",
        "id": 409928654,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1703525717
    },
    {
        "content": "<p>As you said yourself</p>\n<p><span class=\"user-mention silent\" data-user-id=\"364351\">Lars Ericson</span> <a href=\"#narrow/stream/113489-new-members/topic/Sort.20vs.20Type/near/409851618\">said</a>:</p>\n<blockquote>\n<p><code>Type n</code> a synonym for <code>Sort (n+1)</code>.</p>\n</blockquote>\n<p>So of course Lean knows the difference between <code>Type u</code> and <code>Sort u</code>, because they are different</p>",
        "id": 409929010,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703526102
    },
    {
        "content": "<p>I suspect if you write <code>Sort (u +1)</code>, Lean still prints it as <code>Type u</code>, which would a way to disprove your \"stickiness\" claim.</p>",
        "id": 409929074,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703526157
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> consider this code</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ident</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"n\">ident</span>        <span class=\"c1\">-- ident.{u} {α : Type u} (x : α) : α</span>\n<span class=\"k\">#check</span> <span class=\"n\">ident</span> <span class=\"n\">True</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ident1</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"n\">ident1</span>    <span class=\"c1\">-- ident1.{u} {α : Sort u} (x : α) : α</span>\n<span class=\"k\">#check</span> <span class=\"n\">ident1</span> <span class=\"n\">True</span>\n</code></pre></div>\n<p>This gives the following messages in Lean 4 Playground (Zulip provides a button to push on top right corner of the snippet, so you can reproduce):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">LeanProject.lean</span><span class=\"o\">:</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"mi\">0</span>\n<span class=\"n\">ident.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"n\">LeanProject.lean</span><span class=\"o\">:</span><span class=\"mi\">3</span><span class=\"o\">:</span><span class=\"mi\">0</span>\n<span class=\"n\">ident</span> <span class=\"n\">True</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">LeanProject.lean</span><span class=\"o\">:</span><span class=\"mi\">6</span><span class=\"o\">:</span><span class=\"mi\">0</span>\n<span class=\"n\">ident1.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"n\">LeanProject.lean</span><span class=\"o\">:</span><span class=\"mi\">7</span><span class=\"o\">:</span><span class=\"mi\">0</span>\n<span class=\"n\">ident1</span> <span class=\"n\">True</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>The first version gives <code>Type u</code> in the signature.  The second version gives <code>Sort u</code> in the signature.  So Lean is remembering whether <code>Type</code> or <code>Sort</code> was used in the input definition.  Also, <code>ident</code> with <code>Type u</code> works fine on a <code>Prop</code> even though \"Type u will never be Prop\".  I wouldn't call \"stickiness\" a \"claim\".  It is just an observation of the behavior of the interpreter: <code>Sort</code> in comes out as <code>Sort</code>.  <code>Type</code> in comes out as <code>Type</code>.  And, in this case, <code>Prop</code> unifies with <code>Type</code>.</p>",
        "id": 409932058,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1703529407
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ident</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"n\">ident</span>        <span class=\"c1\">-- ident.{u} {α : Type u} (x : α) : α -- Not printed as Sort (u + 1)</span>\n<span class=\"k\">#check</span> <span class=\"n\">ident</span> <span class=\"n\">True</span>\n</code></pre></div>\n<p>is what Eric is telling you.<br>\n(As an aside, I've heard that Lean 4 normalizes universes aggressively.)</p>",
        "id": 409932287,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1703529631
    },
    {
        "content": "<p>Clearly not that aggressively ;)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"o\">(</span><span class=\"n\">imax</span> <span class=\"n\">u</span> <span class=\"o\">(</span><span class=\"n\">imax</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"kt\">Sort</span> <span class=\"o\">(</span><span class=\"n\">imax</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- fails :(</span>\n</code></pre></div>",
        "id": 409934829,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1703532454
    },
    {
        "content": "<p>OK so <code>Sort u</code> stays as <code>Sort u</code> because <code>u</code> could be 0 but <code>Sort (u+1)</code> normalizes to <code>Type u</code>.</p>\n<p>I'm still confused about this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ident</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"n\">ident</span> <span class=\"n\">True</span>\n</code></pre></div>\n<p>because per above <code>Type u</code> should never match <code>Prop</code> and <code>True</code> is a <code>Prop</code>.</p>\n<p>To verify that <code>True</code> is a <code>Prop</code> I write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">True</span>\n<span class=\"k\">#check</span> <span class=\"n\">x</span>  <span class=\"c1\">-- gives back x : Prop</span>\n<span class=\"k\">#eval</span> <span class=\"n\">x</span>     <span class=\"c1\">-- throws an error</span>\n</code></pre></div>\n<p>The <code>#eval x</code> gives error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span>\n  <span class=\"n\">Decidable</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>This is above my head.  Why can't it just give back <code>True</code>?</p>",
        "id": 409936221,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1703534112
    },
    {
        "content": "<p>I'm a bit surprised that this Type u with Prop thing works myself but regarding the eval question: Evaluation is not doing some type theoretic lambda calculus reduction stuff, it attempts to compile and (somewhat) efficiently execute your code in a VM.</p>\n<p>If you want to do reduction in the lambda calculus style you'll have to use #reduce, note that #reduce is not expected to be very performant so if you wish to do actual computation you should prefer eval.</p>",
        "id": 409936656,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1703534500
    },
    {
        "content": "<p>I don't see anything contradictory about this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ident</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"n\">ident</span> <span class=\"n\">True</span>\n</code></pre></div>\n<p>When you call <code>ident</code>, you pass in <code>True</code> as <code>x</code>. Since the type of <code>True</code> is <code>Prop</code> and you declared that the type of <code>x</code> is <code>α</code>, <code>α</code> equals <code>Prop</code>. And since the type of <code>Prop</code> is <code>Type</code> (which you can verify with <code>#check Prop</code>), <code>{α : Type u}</code> checks just fine.</p>",
        "id": 409937067,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1703534769
    },
    {
        "content": "<p>The failing test would be <code>#check ident trivial</code></p>",
        "id": 409938409,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703536414
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"364351\">Lars Ericson</span> <a href=\"#narrow/stream/113489-new-members/topic/Sort.20vs.20Type/near/409936221\">said</a>:</p>\n<blockquote>\n<p>OK so <code>Sort u</code> stays as <code>Sort u</code> because <code>u</code> could be 0 but <code>Sort (u+1)</code> normalizes to <code>Type u</code>.</p>\n</blockquote>\n<p>There's not really any normalization going on here, it's just the pretty-printing rules</p>",
        "id": 409938469,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703536471
    },
    {
        "content": "<p>I understand: <code>Prop</code> is a synonym for <code>Sort 0</code>, and <code>Sort 0</code> has type <code>Sort 1</code> a/k/a <code>Type 0</code> a/k/a <code>Type</code>, and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ident</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"n\">ident</span> <span class=\"n\">trivial</span> <span class=\"c1\">-- Fails</span>\n<span class=\"k\">#check</span> <span class=\"n\">ident</span> <span class=\"c1\">-- ident.{u} {α : Type u} (x : α) : α</span>\n<span class=\"k\">#check</span> <span class=\"n\">id</span> <span class=\"c1\">-- id.{u} {α : Sort u} (a : α) : α</span>\n<span class=\"k\">#check</span> <span class=\"n\">id</span> <span class=\"n\">trivial</span> <span class=\"c1\">-- Succeeds</span>\n</code></pre></div>",
        "id": 409967541,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1703561411
    }
]