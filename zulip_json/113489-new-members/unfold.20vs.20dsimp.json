[
    {
        "content": "<p>I know that the documentation discourages the use of <code>Set.inter</code>. But I would like to know why in the following <code>dsimp</code> works but <code>unfold</code> doesn't:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">u</span> <span class=\"bp\">⊆</span> <span class=\"n\">u</span> <span class=\"bp\">∩</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[(</span><span class=\"bp\">·</span> <span class=\"bp\">∩</span> <span class=\"bp\">·</span><span class=\"o\">)]</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">u</span> <span class=\"bp\">⊆</span> <span class=\"n\">u</span> <span class=\"bp\">∩</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">∩</span> <span class=\"bp\">·</span><span class=\"o\">)</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>In the second version, Lean complains about unexpected token '('. Is it simply a limitation of <code>unfold</code> that it cannot unfold operators?</p>",
        "id": 423612903,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1709042763
    },
    {
        "content": "<p>I'm surprised either of those work. The only good way to unfold notation that I've learned is to define a custom lemma like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.inter_def#doc\">docs#Set.inter_def</a> which can be proved by <code>rfl</code>. It seems like <code>simp</code> has some special support for the <code>·</code> notation for defining functions.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Basic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- This is the only one I would've expected to work. I thought `simp` and `unfold` only worked with declaration names.</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">u</span> <span class=\"bp\">⊆</span> <span class=\"n\">u</span> <span class=\"bp\">∩</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">Inter.inter</span><span class=\"o\">]</span> <span class=\"c1\">-- unfolds to `Set.inter`</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">u</span> <span class=\"bp\">⊆</span> <span class=\"n\">u</span> <span class=\"bp\">∩</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[(</span><span class=\"n\">Inter.inter</span> <span class=\"bp\">·</span> <span class=\"bp\">·</span><span class=\"o\">)]</span> <span class=\"c1\">-- unfolds to `Set.inter`</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">u</span> <span class=\"bp\">⊆</span> <span class=\"n\">u</span> <span class=\"bp\">∩</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[(</span><span class=\"bp\">·</span> <span class=\"bp\">∩</span> <span class=\"bp\">·</span><span class=\"o\">)]</span> <span class=\"c1\">-- unfolds to `Set.inter`</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">u</span> <span class=\"bp\">⊆</span> <span class=\"n\">u</span> <span class=\"bp\">∩</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Inter.inter</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)]</span> <span class=\"c1\">-- invalid 'simp', proposition expected</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">u</span> <span class=\"bp\">⊆</span> <span class=\"n\">u</span> <span class=\"bp\">∩</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[(</span><span class=\"n\">Inter.inter</span><span class=\"o\">)]</span> <span class=\"c1\">-- invalid 'simp', proposition expected</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">u</span> <span class=\"bp\">⊆</span> <span class=\"n\">u</span> <span class=\"bp\">∩</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[((</span><span class=\"bp\">·</span> <span class=\"bp\">∩</span> <span class=\"bp\">·</span><span class=\"o\">))]</span> <span class=\"c1\">-- invalid 'simp', proposition expected</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 423679513,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709061591
    },
    {
        "content": "<p>Interesting. Replacing <code>dsimp [Inter.inter]</code> with <code>unfold Inter.inter</code> gives the goal <code>instInterSet.1 s u ⊆ instInterSet.1 u s</code>,  not <code>Set.inter s u ⊆ Set.inter u s</code>.  I am now utterly confused. Why <code>instInterSet.1</code> here?</p>",
        "id": 423712553,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1709074087
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Inter#doc\">docs#Inter</a> is a \"notation typeclass\" that provides the notation to whichever types implement the instance.</p>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.instInterSet#doc\">docs#Set.instInterSet</a> is the instance for <code>Set</code>. When you unfold <code>Inter.inter</code>, you're seeing its definition, which is that it gets the definition from the instance.</p>",
        "id": 423713119,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709074390
    },
    {
        "content": "<p>If you do <code>unfold_projs</code> (mathlib tactic) it will unfold <code>instInterSet.1 s</code></p>",
        "id": 423713314,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709074468
    },
    {
        "content": "<p>The limitation of <code>unfold</code> is that the syntax expects a sequence of identifiers</p>",
        "id": 423713506,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709074573
    },
    {
        "content": "<p>So <code>unfold</code> cannot unfold operators?</p>",
        "id": 423713540,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1709074594
    },
    {
        "content": "<p>It seems that <code>dsimp</code> is more powerful than <code>unfold</code>. Are there reasons for using <code>unfold</code> but not <code>dsimp</code>?</p>",
        "id": 423713615,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1709074642
    },
    {
        "content": "<p>It can, if you give it the underlying identifier. Here it's <code>Inter.inter</code> (you can check that by hovering over the notation)</p>",
        "id": 423713628,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709074650
    },
    {
        "content": "<p>When I hover over <code> ∩ </code>, I saw only the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Set</span> <span class=\"n\">α</span>\n\n<span class=\"n\">a</span> <span class=\"bp\">∩</span> <span class=\"n\">b</span> <span class=\"n\">is</span> <span class=\"n\">the</span> <span class=\"n\">intersection</span> <span class=\"n\">of</span> <span class=\"n\">a</span> <span class=\"n\">and</span> <span class=\"n\">b.</span>\n\n<span class=\"kt\">Type</span> <span class=\"bp\">∩</span> <span class=\"n\">using</span> <span class=\"bp\">\\</span><span class=\"n\">i</span> <span class=\"n\">or</span> <span class=\"bp\">\\</span><span class=\"n\">inter</span> <span class=\"n\">or</span> <span class=\"bp\">\\</span><span class=\"n\">intersection</span> <span class=\"n\">or</span> <span class=\"bp\">\\</span><span class=\"n\">cap</span>\n</code></pre></div>",
        "id": 423713782,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1709074724
    },
    {
        "content": "<p>Oh. I have to hover in the Infoview to see the Inter.inter</p>",
        "id": 423713870,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1709074766
    },
    {
        "content": "<p>You can also \"go to declaration\" if you right click on it in the source</p>",
        "id": 423713943,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709074798
    },
    {
        "content": "<p>Thanks for the tip! I was trying so hard looking into the documentation to see where intersection is defined.</p>",
        "id": 423714174,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1709074895
    },
    {
        "content": "<p>Kyle, do you happen to know why <code>(f · ·)</code> is behaving differently from <code>(fun x y =&gt; f x y)</code> here? Is <code>simp</code> special casing the <code>·</code> syntax? Or does the <code>·</code> syntax have some eta-reduction built in?</p>",
        "id": 423715917,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709075860
    },
    {
        "content": "<p>Yeah, there's a special case for cdot syntax for simp (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Term.elabCDotFunctionAlias%3F#doc\">docs#Lean.Elab.Term.elabCDotFunctionAlias?</a>)</p>",
        "id": 423716958,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709076380
    }
]