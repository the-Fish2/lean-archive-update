[
    {
        "content": "<p>I'm trying to get a hang of working with the measure theory library and I have the following two proofs that I can't seem to close, I can't find the functions that do what I want. I'm working to show an alternative definition of tight measures! </p>\n<p>For the first, I'm looking for something that allows me to say that I can get epsilon-close to mu(M) with only finitely many sets. <br>\nFor the second, I need a very similar thing. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Measure.Regular</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">ENNReal</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">mα</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- A measure `μ` is tight if for all `0 &lt; ε`, there exists `K` compact such that `μ Kᶜ ≤ ε`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">IsTight</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">ε</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">IsCompact</span> <span class=\"n\">K</span> <span class=\"bp\">∧</span> <span class=\"n\">μ</span> <span class=\"n\">K</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">≤</span> <span class=\"n\">ε</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">countable_compact_cover</span> <span class=\"o\">[</span><span class=\"n\">IsFiniteMeasure</span> <span class=\"n\">μ</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">IsTight</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">IsSigmaCompact</span> <span class=\"n\">M</span> <span class=\"bp\">∧</span> <span class=\"n\">μ</span> <span class=\"n\">M</span> <span class=\"bp\">=</span> <span class=\"n\">μ</span> <span class=\"n\">Set.univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">IsTight</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"c1\">-- For every n &gt; 0, generate a set Kn compact such that μ Knᶜ ≤ 1/n</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">IsCompact</span> <span class=\"n\">K</span> <span class=\"bp\">∧</span> <span class=\"n\">μ</span> <span class=\"n\">K</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">n</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">zero_lt_one</span><span class=\"o\">])</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h</span>\n  <span class=\"c1\">-- Take the union of all Kn</span>\n  <span class=\"n\">choose</span><span class=\"bp\">!</span> <span class=\"n\">K</span> <span class=\"n\">hK</span> <span class=\"n\">using</span> <span class=\"n\">this</span>\n  <span class=\"k\">let</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"bp\">⋃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">K</span> <span class=\"n\">n</span>\n  <span class=\"n\">use</span> <span class=\"n\">M</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">isSigmaCompact_iUnion_of_isCompact</span>\n    <span class=\"n\">intro</span> <span class=\"n\">_</span>\n    <span class=\"n\">simp_all</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">one_div</span><span class=\"o\">,</span>\n      <span class=\"n\">ENNReal.le_inv_iff_mul_le</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- we need to show that the measures agree</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">of_countable_compact_cover</span> <span class=\"o\">[</span><span class=\"n\">IsFiniteMeasure</span> <span class=\"n\">μ</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">IsSigmaCompact</span> <span class=\"n\">M</span> <span class=\"bp\">∧</span> <span class=\"n\">μ</span> <span class=\"n\">M</span> <span class=\"bp\">=</span> <span class=\"n\">μ</span> <span class=\"n\">Set.univ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsTight</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">ε</span> <span class=\"n\">hε</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">hM</span><span class=\"o\">,</span> <span class=\"n\">hMμ</span><span class=\"o\">⟩</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">IsSigmaCompact</span> <span class=\"n\">at</span> <span class=\"n\">hM</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">hM</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">hK</span><span class=\"o\">,</span> <span class=\"n\">hKM</span><span class=\"o\">⟩</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hKM</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hMμ</span>\n  <span class=\"gr\">sorry</span> <span class=\"c1\">-- It suffices that for any ε, a finite union suffices, but what result is this?</span>\n</code></pre></div>",
        "id": 434950154,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1713867104
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Measure.Regular</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">ENNReal</span> <span class=\"n\">NNReal</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">mα</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- A measure `μ` is tight if for all `0 &lt; ε`, there exists `K` compact such that `μ Kᶜ ≤ ε`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">IsTight</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">ε</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">IsCompact</span> <span class=\"n\">K</span> <span class=\"bp\">∧</span> <span class=\"n\">μ</span> <span class=\"n\">K</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">≤</span> <span class=\"n\">ε</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">countable_compact_cover</span> <span class=\"o\">[</span><span class=\"n\">IsFiniteMeasure</span> <span class=\"n\">μ</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">IsTight</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">IsSigmaCompact</span> <span class=\"n\">M</span> <span class=\"bp\">∧</span> <span class=\"n\">μ</span> <span class=\"n\">M</span> <span class=\"bp\">=</span> <span class=\"n\">μ</span> <span class=\"n\">Set.univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">IsTight</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"c1\">-- For every n &gt; 0, generate a set Kn compact such that μ Knᶜ ≤ 1/n</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">IsCompact</span> <span class=\"n\">K</span> <span class=\"bp\">∧</span> <span class=\"n\">μ</span> <span class=\"n\">K</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">n</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">zero_lt_one</span><span class=\"o\">])</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h</span>\n  <span class=\"c1\">-- Take the union of all Kn</span>\n  <span class=\"n\">choose</span><span class=\"bp\">!</span> <span class=\"n\">K</span> <span class=\"n\">hK</span> <span class=\"n\">using</span> <span class=\"n\">this</span>\n  <span class=\"n\">use</span> <span class=\"bp\">⋃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">K</span> <span class=\"n\">n</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">isSigmaCompact_iUnion_of_isCompact</span>\n    <span class=\"n\">intro</span> <span class=\"n\">_</span>\n    <span class=\"n\">simp_all</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">one_div</span><span class=\"o\">,</span>\n      <span class=\"n\">ENNReal.le_inv_iff_mul_le</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"c1\">-- Changing the goal to `μ (⋂ i, (K i)ᶜ) ≤ 0`</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">measure_congr</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ae_eq_univ</span><span class=\"o\">,</span> <span class=\"n\">Set.compl_iUnion</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">le_zero_iff</span><span class=\"o\">]</span>\n    <span class=\"c1\">-- Use the fact that `a ≤ 0` iff for all `ε &gt; 0`, `a &lt; ε`</span>\n    <span class=\"n\">refine</span> <span class=\"n\">le_of_forall_lt'</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">ε</span> <span class=\"n\">hε</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"c1\">-- Find an `n` such that `1 / n &lt; ε`</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">hn</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ENNReal.exists_inv_nat_lt</span> <span class=\"n\">hε.ne.symm</span>\n    <span class=\"c1\">-- Use assumptions to conclude</span>\n    <span class=\"n\">exact</span> <span class=\"n\">lt_of_le_of_lt</span> <span class=\"o\">((</span><span class=\"n\">measure_mono</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Set.iInter_subset</span> <span class=\"n\">_</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">&lt;|</span>\n      <span class=\"o\">(</span><span class=\"n\">inv_eq_one_div</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">▸</span> <span class=\"o\">(</span><span class=\"n\">hK</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">hn</span>\n</code></pre></div>\n<p>This closes the first goal. The sorry you have doesn't really use any thing specific to measures however (other than monotonicity).</p>",
        "id": 434965194,
        "sender_full_name": "Jason KY.",
        "timestamp": 1713872477
    },
    {
        "content": "<p>Thanks, that's very insightful!</p>",
        "id": 434968263,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1713873610
    },
    {
        "content": "<p>I've tidied up the second one a bit, which now has two sorries. I'm not sure if my definition of <code>L</code> is very optimal here? This gets me stuck at the first sorry. The second sorry is because I need to approximate the measure of a sequence of nested sets by one of these sets, which I also can't seem to figure out... </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Measure.Regular</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">ENNReal</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">mα</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- A measure `μ` is tight if for all `0 &lt; ε`, there exists `K` compact such that `μ Kᶜ ≤ ε`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">IsTight</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">ε</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">IsCompact</span> <span class=\"n\">K</span> <span class=\"bp\">∧</span> <span class=\"n\">μ</span> <span class=\"n\">K</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">≤</span> <span class=\"n\">ε</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">of_countable_compact_cover</span> <span class=\"o\">[</span><span class=\"n\">IsFiniteMeasure</span> <span class=\"n\">μ</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">IsSigmaCompact</span> <span class=\"n\">M</span> <span class=\"bp\">∧</span> <span class=\"n\">μ</span> <span class=\"n\">M</span> <span class=\"bp\">=</span> <span class=\"n\">μ</span> <span class=\"n\">Set.univ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsTight</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">ε</span> <span class=\"n\">hε</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">hM</span><span class=\"o\">,</span> <span class=\"n\">hMμ</span><span class=\"o\">⟩</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">IsSigmaCompact</span> <span class=\"n\">at</span> <span class=\"n\">hM</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">hM</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">hK</span><span class=\"o\">,</span> <span class=\"n\">hKM</span><span class=\"o\">⟩</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hKM</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hMμ</span>\n  <span class=\"k\">let</span> <span class=\"n\">L</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"bp\">⋃</span> <span class=\"n\">m</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">K</span> <span class=\"n\">n</span>\n  <span class=\"k\">have</span> <span class=\"n\">hL</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">IsCompact</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">n</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Set.Finite.isCompact_biUnion</span>\n    <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">i</span> <span class=\"n\">hi</span>\n      <span class=\"n\">simp_all</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Nat.le_eq</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"n\">hLε</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">ε</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">≤</span> <span class=\"n\">ε</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">ε</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">hn</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hLε</span> <span class=\"n\">ε</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">L</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">hL</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">hn</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 434972250,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1713874997
    },
    {
        "content": "<p>I think I just managed (albeit not very elegantly). I'll golf this a bit and hide the legwork in a lemma, but for the interested reader:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Measure.Regular</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">ENNReal</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">mα</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n\n<span class=\"sd\">/-- A measure `μ` is tight if for all `0 &lt; ε`, there exists `K` compact such that `μ Kᶜ ≤ ε`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">IsTight</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">ε</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">IsCompact</span> <span class=\"n\">K</span> <span class=\"bp\">∧</span> <span class=\"n\">μ</span> <span class=\"n\">K</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">≤</span> <span class=\"n\">ε</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">of_countable_compact_cover</span> <span class=\"o\">[</span><span class=\"n\">IsFiniteMeasure</span> <span class=\"n\">μ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">T2Space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OpensMeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">IsSigmaCompact</span> <span class=\"n\">M</span> <span class=\"bp\">∧</span> <span class=\"n\">μ</span> <span class=\"n\">M</span> <span class=\"bp\">=</span> <span class=\"n\">μ</span> <span class=\"n\">Set.univ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsTight</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">ε</span> <span class=\"n\">hε</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">hM</span><span class=\"o\">,</span> <span class=\"n\">hMμ</span><span class=\"o\">⟩</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">IsSigmaCompact</span> <span class=\"n\">at</span> <span class=\"n\">hM</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">hM</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">hK</span><span class=\"o\">,</span> <span class=\"n\">hKM</span><span class=\"o\">⟩</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hKM</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hMμ</span>\n  <span class=\"k\">let</span> <span class=\"n\">L</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">Set.Accumulate</span> <span class=\"n\">K</span> <span class=\"n\">n</span>\n  <span class=\"k\">have</span> <span class=\"n\">hLK</span> <span class=\"o\">:</span> <span class=\"bp\">⋃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">L</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"bp\">⋃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">K</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">Set.iUnion_accumulate</span>\n  <span class=\"k\">have</span> <span class=\"n\">hL</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">IsCompact</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"n\">isCompact_accumulate</span> <span class=\"n\">hK</span> <span class=\"n\">n</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hLK</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hMμ</span>\n  <span class=\"k\">have</span> <span class=\"n\">hLm</span> <span class=\"o\">:</span> <span class=\"n\">Monotone</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"n\">Set.monotone_accumulate</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Filter.Tendsto</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"bp\">∘</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"n\">Filter.atTop</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">L</span> <span class=\"n\">n</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n    <span class=\"n\">MeasureTheory.tendsto_measure_iUnion</span> <span class=\"n\">hLm</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ENNReal.tendsto_atTop</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"k\">have</span> <span class=\"n\">hLε</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">ε</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">≥</span> <span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">L</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"n\">ε</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">ε</span> <span class=\"n\">hε</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">hn</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">this</span> <span class=\"n\">ε</span> <span class=\"n\">hε</span>\n    <span class=\"n\">use</span> <span class=\"n\">n</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">hn</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n    <span class=\"n\">simp_all</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">gt_iff_lt</span><span class=\"o\">,</span> <span class=\"n\">ge_iff_le</span><span class=\"o\">,</span> <span class=\"n\">Function.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_Icc</span><span class=\"o\">,</span> <span class=\"n\">tsub_le_iff_right</span><span class=\"o\">,</span>\n      <span class=\"n\">le_refl</span><span class=\"o\">,</span> <span class=\"n\">and_self</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">hn</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hLε</span> <span class=\"n\">ε</span> <span class=\"n\">hε</span>\n  <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">hL</span> <span class=\"n\">n</span>\n  <span class=\"bp\">·</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">hL</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isClosed.measurableSet</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">measure_compl</span> <span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">measure_ne_top</span> <span class=\"n\">μ</span> <span class=\"n\">_</span><span class=\"o\">)]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hMμ</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">tsub_le_iff_tsub_le.mp</span> <span class=\"n\">hn</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hMμ</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">measure_ne_top</span> <span class=\"n\">μ</span> <span class=\"n\">Set.univ</span>\n</code></pre></div>",
        "id": 435018578,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1713888476
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"673728\">Josha Dekker</span> has marked this topic as resolved.</p>",
        "id": 435018590,
        "sender_full_name": "Notification Bot",
        "timestamp": 1713888479
    }
]