[
    {
        "content": "<p>is there some good way to denote a product of a type with itself, n times? <br>\nbasically, supposing i have some type <code>T</code>, then i'd like to define some type <code>T ^ 6</code>, such that creating an element of that type is as simple as writing the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"bp\">^</span><span class=\"mi\">6</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"n\">t</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>i've have considered multiple options:</p>\n<ul>\n<li>creating a structure for each different exponent i need, but that seems a bit ad-hoc... it also requires you to create new instances for any classes which might be automatically created, by virtue of the fact that they lend themselves to being applied elementwise.</li>\n<li>use the type <code>ZMod n → T</code>. in this case i think i have some structure on my indexes i probably don't need, and i don't think i can use the notation described before to create objects of the type.</li>\n<li>using <code>T × T × T × T × T × T</code>. this allows for using the notation described before, and also automatically creates instances for add and stuff. however, accessing the individual elements seems to get annoying, as you have to use something like <code>x.2.2.2.2.2.1</code> to access the last component of elements of the type.</li>\n<li><code>T ^ 6</code> itself  is not liked by the compiler, the reason given being that there is no instance <code>HPow Type ℕ Type</code></li>\n</ul>\n<p>thus far, i'm leaning to the very first option, although creating instances again and again does get tedious.</p>\n<p>is there some option i'm missing? i imagine this is a very common pattern, so surely there is some better way to do this? is there perhaps a better way to access components  when using the 3rd option?</p>",
        "id": 419126991,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1706736824
    },
    {
        "content": "<p><code>Fin n -&gt; T</code> is the canonical answer; there's <code>![a, b, c]</code> syntax for terms</p>",
        "id": 419128276,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706737375
    },
    {
        "content": "<p>so for creating a term of this kind, i'd use <code>def x : Fin 6 -&gt; T := ![t,t,t,t,t,t]</code>?<br>\nand i'm guessing for accessing the mth component i can use something like <code>x (m-1)</code>?</p>",
        "id": 419128800,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1706737611
    },
    {
        "content": "<p>Yes</p>",
        "id": 419128875,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706737656
    },
    {
        "content": "<p>it appears this doesn't automatically do elementwise addition and such... is there an easy way to fix this?</p>",
        "id": 419129322,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1706737851
    },
    {
        "content": "<p>also, how do i add extensionality for this type?</p>",
        "id": 419130723,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1706738429
    },
    {
        "content": "<p>It should automatically do elementwise addition -- do you have an example where this fails?</p>",
        "id": 419132582,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706739151
    },
    {
        "content": "<p>Extensionality is also there too:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">37</span> <span class=\"bp\">→</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span>\n  <span class=\"c1\">-- works fine</span>\n</code></pre></div>",
        "id": 419132752,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706739236
    },
    {
        "content": "<p>maybe it fails because i create an alias? this is a small failing example...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Module.Submodule.Basic</span>\n<span class=\"kd\">def</span> <span class=\"n\">Ftest</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">Fin</span> <span class=\"mi\">6</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">F46</span>\n<span class=\"kn\">section</span> <span class=\"n\">base_instances</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Zero</span> <span class=\"n\">Ftest</span> <span class=\"n\">where</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span> <span class=\"n\">base_instances</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">Ftest</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">test2</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">6</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Ftest</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- failed to synthesize instance HAdd Ftest Ftest ?m.23424</span>\n</code></pre></div>",
        "id": 419133691,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1706739631
    },
    {
        "content": "<p>let me see if i can get a counterexample for ext too...</p>",
        "id": 419133925,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1706739727
    },
    {
        "content": "<p>It will work if you change <code>def Ftest : Type := Fin 6 → ℤ</code> to <code>abbrev Ftest : Type := Fin 6 → ℤ</code></p>",
        "id": 419134771,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706740085
    },
    {
        "content": "<p>curious... why does this make a difference?</p>",
        "id": 419134859,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1706740135
    },
    {
        "content": "<p><code>def Foo : Type := Bar</code> roughly means \"forget everything you know about <code>Bar</code> other than how it is represented\"</p>",
        "id": 419134912,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706740159
    },
    {
        "content": "<p>i thought <code>theorem</code> and such were the forgetful versions of definitions...</p>",
        "id": 419135064,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1706740208
    },
    {
        "content": "<p>It's like how if you do <code>def one := 1</code> then Lean doesn't know any more that <code>one + one = 2</code>, because you never told it you were allowed to look inside <code>one</code>. <code>rw [one]</code> fixes this, but it's not automatic.</p>",
        "id": 419135086,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706740218
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/113489-new-members/topic/power.20of.20a.20type.20using.20cartesian.20product/near/419135064\">said</a>:</p>\n<blockquote>\n<p>i thought <code>theorem</code> and such were the forgetful versions of definitions...</p>\n</blockquote>\n<p>This is true, but there are multiple levels of forgetfulness</p>",
        "id": 419135118,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706740230
    },
    {
        "content": "<p><code>def</code> is in most cases \"forget until I explicitly ask you to remember\"</p>",
        "id": 419135162,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706740250
    },
    {
        "content": "<p>I don't know if we have any good documentation explaining this <code>def Foo : Type := Bar</code> trap, but it hits new users over and over again</p>",
        "id": 419135272,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706740308
    },
    {
        "content": "<p>i've changed the <code>def</code> to <code>abbrev</code>,  but now it fails to apply <code>rfl</code> at the <code>test</code> theorem... why is that?</p>",
        "id": 419135756,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1706740509
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Ftest</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">Fin</span> <span class=\"mi\">6</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">F46</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">Ftest</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">test2</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">6</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Ftest</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 419137109,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706741088
    },
    {
        "content": "<p>but <em>why</em>?</p>",
        "id": 419137175,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1706741125
    },
    {
        "content": "<p>You mean \"why isn't the proof <code>rfl</code>?\"? It's no business of yours how things are defined under the hood -- this is implementation details, the world of the computer scientist. The proof that a space is compact iff every open cover has a finite subcover isn't <code>rfl</code> either, the definition of compact is some crazy thing involving filters. The only important thing is that the theorem is true, not that it's true by definition.</p>",
        "id": 419137355,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706741212
    },
    {
        "content": "<p>so i can't be interested in implementation details???????????? wtf</p>",
        "id": 419137524,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1706741294
    },
    {
        "content": "<p>You can be interested in what you like, I'm just pointing out that the question of how a definition is implemented is not a mathematical question, it depends on the specifcs of the type theory you're using, the design decisions of the library etc.</p>",
        "id": 419137653,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706741363
    },
    {
        "content": "<p>Did you know that the definition of a group has <del>about 15</del> 10 axioms in Lean? You don't need to know this, though, you can just use them like regular groups.</p>",
        "id": 419137706,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706741395
    },
    {
        "content": "<p>the curious thing is that even if i include the following, it still doesn't accept <code>rfl</code> as a proof... even though i'm <em>litterally saying it's equal by definition</em></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Zero</span> <span class=\"n\">Ftest</span> <span class=\"n\">where</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 419138219,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1706741598
    },
    {
        "content": "<p>Wooah if <code>Ftest</code> is still an <code>abbrev</code> then you don't want to be making an <code>instance : Zero Ftest</code> because it already has one, so after your definition it has two and now nobody knows which one it will use.</p>",
        "id": 419138361,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706741652
    },
    {
        "content": "<p>If you go back to making it a <code>def</code> (which has no Zero)  then you can do this and then it will work.</p>",
        "id": 419138399,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706741679
    },
    {
        "content": "<p>so i can't override instances?</p>",
        "id": 419138496,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1706741729
    },
    {
        "content": "<p>what you're doing doesn't override instances, it just adds new ones and thus breaks the assumption implicit in the system that classes only have one instance, leading to unpredictable behaviour. But you can remove instances.</p>",
        "id": 419138652,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706741796
    },
    {
        "content": "<p>You can do something like <code>attribute [-instance] Pi.instZero</code>. The zero element given by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Pi.instZero#doc\">docs#Pi.instZero</a> is <code>fun _ ↦ 0</code>, while <code>![0,0,0,0,0,0]</code> is a nested if-then-else, so they're not defeq.</p>",
        "id": 419141350,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1706743082
    },
    {
        "content": "<p>Here's a very simple demonstration of that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">|</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 419142696,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706743723
    },
    {
        "content": "<p>Or even</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"bp\">|</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 419142892,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706743808
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> has marked this topic as resolved.</p>",
        "id": 419227681,
        "sender_full_name": "Notification Bot",
        "timestamp": 1706787398
    }
]