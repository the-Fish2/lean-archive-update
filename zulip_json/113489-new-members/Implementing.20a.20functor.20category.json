[
    {
        "content": "<p>Hi, my goal right now is to attempt to write some code implementing the basics of the theory of persistence modules into Lean as a research project. I have a couple of questions relating to this. For context, the key definition in this setting is functors from poset categories (usually (ℝ, ≤)) into Vect.</p>\n<p>1) What are the must-reads so I can get started on this implementation? I have already read Chapter 6 of Mathematics in Lean about classes and structures, which seems to be the most relevant one, but I do not feel like it would be enough on its own. </p>\n<p>2) Are there specific resources on the implementation of category theory into mathlib that would be worth looking into? </p>\n<p>3) Are there similar objects already implemented into mathlib I could look to for comparison? Some other structure or class that is composed of functors from one category to another?</p>\n<p>Thank you very much for answers.</p>",
        "id": 442112569,
        "sender_full_name": "VayusElytra",
        "timestamp": 1717367116
    },
    {
        "content": "<p>What's Vect?</p>",
        "id": 442112844,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717367360
    },
    {
        "content": "<p>Usually the best way to learn is to just learn on the job, ie get started, and ask questions when you're stuck (beginner questions are fine in this channel and lots of questions are also fine).</p>",
        "id": 442112967,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717367461
    },
    {
        "content": "<p>Vect as in the category of vector spaces over some base field. And thank you! I will not hesitate to ask.</p>",
        "id": 442235582,
        "sender_full_name": "VayusElytra",
        "timestamp": 1717416865
    },
    {
        "content": "<p>The fact that R-modules over some field R form a category seems to not be implemented in mathlib, so I think I would need to implement the fact that vector spaces form an instance of a category on my own.  So this would mean something like: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DivisionRing</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">instCategory</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"c1\">-- other stuff</span>\n</code></pre></div>\n<p>However this is not really what I would want, because I would just be showing that one specific vector space has the structure of a category, as opposed to showing that the type of vector spaces is a category. How can I work around this?</p>",
        "id": 442267016,
        "sender_full_name": "VayusElytra",
        "timestamp": 1717424283
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ModuleCat#doc\">docs#ModuleCat</a></p>",
        "id": 442267271,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1717424337
    },
    {
        "content": "<p>Thanks, I wonder how I missed this</p>",
        "id": 442285209,
        "sender_full_name": "VayusElytra",
        "timestamp": 1717428220
    },
    {
        "content": "<p>FWIW <code>CategoryTheory.Category (Module K V)</code> actually means \"the set of all the ways you can make V into a K-module forms a category\" (not what you said, and not what you wanted either).</p>",
        "id": 442353866,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717443840
    },
    {
        "content": "<p>I think this makes sense to me. Is it accurate to think of <code>Module K V</code> as the set of all possible K-module structures on V? </p>\n<p>A related question: what is the appropriate type to speak about \"the set of all K-modules\"?  This question came up again as I was implementing this snippet:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">--IntervalObj is meant to be a function that takes as input 2 elements in ℝ, a and b, as</span>\n<span class=\"c1\">--well as some other real number x, and associates to x a K-vector space.</span>\n<span class=\"c1\">--If x is between a and b, that vector space is K itself, viewed as a 1 dimensional K vector space</span>\n<span class=\"c1\">--Otherwise, it is the trivial K-vector space {0}.</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DivisionRing</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IntervalObj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"bp\">⟨</span><span class=\"n\">K</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>It is clear to me in light of what you have said that <code>Module K K</code> is not the right type for this function: it would take values in the set of all possible K-module structures on K, as opposed to in the set of all K-modules. I would have expected the set of all K-modules to be <code>Module K _</code> but this returns an error (the typeclass instance problem gets stuck). What is the proper way to do this?</p>\n<p>(I am aware that the matching afterwards would not work properly even with the correct domain for this function, but let's ignore this for the moment).</p>",
        "id": 442382842,
        "sender_full_name": "VayusElytra",
        "timestamp": 1717452256
    },
    {
        "content": "<p>The \"set\" of all <code>K</code>-modules is <code>ModuleCat K</code>. (\"Set\" is in quotes for two reasons. (1) I just want to point out that this goes up a universe level since the collection of all <code>K</code>-modules is big. (2) Terms of <code>ModuleCat K</code> \"are\" <code>K</code>-modules -- while each term is everything you need for a normal Lean <code>K</code>-module all packaged up, there is some magic using coercions to make them behave as if they actually were normal Lean <code>K</code>-modules.)</p>",
        "id": 442384349,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1717452824
    },
    {
        "content": "<p>Sorry, I think there is a nuance here that I do not quite understand. The documentation for ModuleCat refers to <code>ModuleCat R</code> as the category of all R-modules and their morphisms. <br>\nThis seems like a different concept to me than the collection (thank you for the correction!) of all K-modules? For instance, <code>ModuleCat R</code> would also contain morphism sets between objects. </p>\n<p>Does this work the same for every other algebraic structure? For instance, say I wanted to define a function that takes as arguments a group and an element in the group and did some operation on it. Would I then want to write something like this? </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">GroupCat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"c1\">--something</span>\n</code></pre></div>",
        "id": 442389462,
        "sender_full_name": "VayusElytra",
        "timestamp": 1717454643
    },
    {
        "content": "<p><code>ModuleCat R</code> is a type whose terms correspond to <code>R</code>-modules. There's an additional structure attached to <code>ModuleCat R</code> that provides the morphisms, via a typeclass, in a similar way to how the <code>[Module R M]</code> typeclass can attach a module structure to a type <code>M</code>.</p>",
        "id": 442389728,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1717454740
    },
    {
        "content": "<p>You could write <code>def foo (G : GroupCat) (a : G) :=</code>, but writing <code>def foo (G : Type*) [Group G] (a : G) :=</code> is more common and more likely to avoid annoying minor technical challenges.</p>",
        "id": 442389951,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1717454807
    },
    {
        "content": "<p>This is an example of an \"impedance mismatch\" between the category theory library and the rest of the library.</p>",
        "id": 442390031,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1717454836
    },
    {
        "content": "<p>The nuance between these is that with <code>G : GroupCat</code>, this <code>G</code> is not itself a type, but a \"bundled\" object that contains both a type and the <code>Group G</code> instance; you can write <code>(a : G)</code> because there is a coercion from <code>G</code> to a type (this coercion merely accesses the <code>carrier</code> field from <code>G</code>). But with the second one, <code>G</code> is already a type, and it \"is\" a group since there is a <code>Group G</code> instance in context.</p>",
        "id": 442390340,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1717454929
    },
    {
        "content": "<p>The <code>GroupCat</code> version is the one that's \"actually\" working with groups, like in the \"a <em>group</em> is a 4-tuple <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>G</mi><mo separator=\"true\">,</mo><mo>⋅</mo><mo separator=\"true\">,</mo><msup><mrow></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(G,\\cdot,{}^{-1},1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">⋅</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>\" sense.</p>",
        "id": 442390740,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1717455060
    },
    {
        "content": "<p>I see, thank you very much. I think this is completely clear now. </p>\n<p>To check if I understand right: if I wanted to define a function that maps, say, a real number to a group, I could either write: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">GroupCat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"c1\">--definition</span>\n</code></pre></div>\n<p>which would not be preferable as you say, or I could write </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"c1\">--definition</span>\n</code></pre></div>\n<p>skipping the type ascription entirely and relying on typeclass inference to recover that structure later on?</p>",
        "id": 442583148,
        "sender_full_name": "VayusElytra",
        "timestamp": 1717521584
    },
    {
        "content": "<p>Perhaps</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"c1\">--definition of the underlying set</span>\n</code></pre></div>\n<p>would be better, and then later on</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"c1\">-- multiplication, inverse, identity and axioms go here</span>\n</code></pre></div>",
        "id": 442585425,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717522269
    },
    {
        "content": "<p>Yeah, what Kevin says is the way you'd formulate it in the \"non-bundled\" way, which is very prevalent in mathlib.</p>\n<p>These are each solutions to the problem of implementing <em>synecdoche</em> in mathematics, which is a figure of speech that both refers to referring to something by one of its parts or vice versa.</p>\n<p>With <code>(G : GroupCat)</code>, you can write <code>g : G</code> because there is a typeclass for coercing <code>G -&gt; Type</code>, letting you refer to <code>G</code> as if it were its set of elements.</p>\n<p>With <code>(G : Type) [Group G]</code>, you can write <code>g h : G</code> and <code>g * h</code>, letting you to refer to <code>G</code> as if it were a group structure even though it's just its set of elements.</p>",
        "id": 442596224,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1717525441
    },
    {
        "content": "<p>There are two reasons for not bundling:</p>\n<ol>\n<li>It lets you add new structure to a pre-existing type. You do not need to worry about giving an algebraic object the strongest possible structure at its definition.</li>\n<li>It lets you work with terms of the pre-existing type, rather than needing to phrase the type as, say, <code>NatMonoid</code> with <code>NatMonoid.carrier := Nat</code>. You would have to be consistent with using <code>NatMonoid</code> rather than <code>Nat</code> for theorems about monoids to apply.</li>\n</ol>\n<p>However, when you are interested about working with groups in general, rather than reasoning about individual pre-defined groups, bundling makes sense. In other words, when you're reasoning about the category of such objects in the abstract it's more-or-less necessary to work with the bundled objects.</p>",
        "id": 442597272,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1717525765
    }
]