[
    {
        "content": "<p>I have the following axiomatization of a projective geometry. I proved some properties of projective geometries with this, but then, I want to say that these properties hold for the projectivization of a vector space already defined in the library. So, what I want is to lift up the level of abstraction.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">ProjectiveGeometry</span> <span class=\"o\">(</span><span class=\"n\">point</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ell</span><span class=\"o\">:</span> <span class=\"n\">point</span> <span class=\"bp\">→</span> <span class=\"n\">point</span> <span class=\"bp\">→</span> <span class=\"n\">point</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"n\">where</span>\n<span class=\"n\">l1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">ell</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">a</span>\n<span class=\"n\">l2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">ell</span> <span class=\"n\">a</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">ell</span> <span class=\"n\">b</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">ell</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">p</span>\n<span class=\"n\">l3</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">ell</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">ell</span> <span class=\"n\">p</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">point</span><span class=\"o\">,</span> <span class=\"n\">ell</span> <span class=\"n\">q</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"bp\">∧</span> <span class=\"n\">ell</span> <span class=\"n\">q</span> <span class=\"n\">b</span> <span class=\"n\">d</span>\n</code></pre></div>\n<p>How to proceed from this? Is it possible to show that projectivization of a vector space is a model of this axiomatization? Or conversely, how can I create an axiomatization of which projectivization is a model? Can <code>instance</code>s help me with this?</p>",
        "id": 421426100,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1707910495
    },
    {
        "content": "<p>Not familiar with projective geometry, but I imagine you’d prove something like:</p>\n<p><del><code>\nexample [DivisionRing K] [AddCommGroup V] [Module K V] (v : Projectivization K V) :\n  ProjectiveGeometry v.submodule (fun a b c ↦ Collinear K {a, b, c}) := sorry\n</code></del></p>\n<p>(nevermind, I’m not sure that’s correct… it states that each element of the projectivization is a projective geometry, which I don’t think is what you want. I can’t get the correct version to work, because <code>Submodule</code> is not an <code>AddGroup</code> and so <code>Collinear</code> is refusing to typecheck)</p>\n<p><code>instance</code>s are only useful if your <code>ProjectiveGeometry</code> is a class to begin with.</p>",
        "id": 421479390,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1707926881
    },
    {
        "content": "<p>Ah I see. Yes, I want each Projectivization to be ProjectiveGeometry.</p>",
        "id": 421625809,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1707993585
    },
    {
        "content": "<p>But, this way of thinking is possible in Lean, right? Maybe I should try to translate this structure to a class, then. <span class=\"user-mention\" data-user-id=\"574896\">@Sabrina Jewson</span></p>",
        "id": 421896624,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1708101400
    },
    {
        "content": "<p>Well, whether you want it to be a class depends on how you use it (whether you want it use it as a <code>[]</code> parameter).</p>\n<p>Determining the correct type signature to use a different problem, you’d want to ask someone more knowledgable in this areä of maths.</p>",
        "id": 421898531,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1708102042
    },
    {
        "content": "<p>I understand, thank you.</p>",
        "id": 421899169,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1708102255
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266253\">@Joseph Myers</span> Could you take a look at this?</p>",
        "id": 421899590,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1708102404
    },
    {
        "content": "<p>You had suggested that the Desargue's Property should first be proved generally and then the affine versions should be derived from it. I am trying to somehow create a framework for it.</p>",
        "id": 421899933,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1708102536
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"557285\">@Abdullah Uyu</span> are you trying to do something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.Projectivization.Basic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">DivisionRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ProjectiveGeometry</span> <span class=\"o\">(</span><span class=\"n\">point</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n<span class=\"n\">ell</span> <span class=\"o\">:</span> <span class=\"n\">point</span> <span class=\"bp\">→</span> <span class=\"n\">point</span> <span class=\"bp\">→</span> <span class=\"n\">point</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">l1</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">ell</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">a</span>\n<span class=\"n\">l2</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">ell</span> <span class=\"n\">a</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">ell</span> <span class=\"n\">b</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">ell</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">p</span>\n<span class=\"n\">l3</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">ell</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">ell</span> <span class=\"n\">p</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">point</span><span class=\"o\">,</span> <span class=\"n\">ell</span> <span class=\"n\">q</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"bp\">∧</span> <span class=\"n\">ell</span> <span class=\"n\">q</span> <span class=\"n\">b</span> <span class=\"n\">d</span>\n\n<span class=\"c1\">-- Every Projectivization is a ProjectiveGeometry</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ProjectiveGeometry</span> <span class=\"o\">(</span><span class=\"n\">Projectivization</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- define `ell` for Projectivization K V</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- prove l1</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- prove l2</span>\n  <span class=\"gr\">sorry</span>  <span class=\"c1\">-- prove l3</span>\n<span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 421921784,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1708110393
    },
    {
        "content": "<p>I don't know enough about abstract projective geometry to advise on exactly what the general type class structure and associated API should look like.</p>",
        "id": 421965196,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1708134863
    },
    {
        "content": "<p>Hopefully the above will work out. I am going to fill the sorries throughout the next week.</p>",
        "id": 422043060,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1708204407
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/stream/113489-new-members/topic/Creating.20a.20higher.20level.20object/near/421921784\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"557285\">Abdullah Uyu</span> are you trying to do something like this?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.Projectivization.Basic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">DivisionRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ProjectiveGeometry</span> <span class=\"o\">(</span><span class=\"n\">point</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n<span class=\"n\">ell</span> <span class=\"o\">:</span> <span class=\"n\">point</span> <span class=\"bp\">→</span> <span class=\"n\">point</span> <span class=\"bp\">→</span> <span class=\"n\">point</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">l1</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">ell</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">a</span>\n<span class=\"n\">l2</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">ell</span> <span class=\"n\">a</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">ell</span> <span class=\"n\">b</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">ell</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">p</span>\n<span class=\"n\">l3</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">ell</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">ell</span> <span class=\"n\">p</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">point</span><span class=\"o\">,</span> <span class=\"n\">ell</span> <span class=\"n\">q</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"bp\">∧</span> <span class=\"n\">ell</span> <span class=\"n\">q</span> <span class=\"n\">b</span> <span class=\"n\">d</span>\n\n<span class=\"c1\">-- Every Projectivization is a ProjectiveGeometry</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ProjectiveGeometry</span> <span class=\"o\">(</span><span class=\"n\">Projectivization</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- define `ell` for Projectivization K V</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- prove l1</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- prove l2</span>\n  <span class=\"gr\">sorry</span>  <span class=\"c1\">-- prove l3</span>\n<span class=\"o\">⟩</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I have a few questions regarding this:</p>\n<ul>\n<li>Why class but not a structure?</li>\n<li>ell went inside but not point, why?</li>\n</ul>",
        "id": 423426813,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1708962954
    },
    {
        "content": "<p>Concerning your first question, a <code>class</code> is somewhat a special kind of structure that is taken into account by type-class inference: you can have a look at <a href=\"https://leanprover-community.github.io/mathematics_in_lean/C07_Hierarchies.html\">Chapter 7</a> of <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a>. At any rate the above code would have worked equally well replacing <code>class</code> by <code>structure</code>. Concerning the second point, what do you mean by \"went inside\"?</p>",
        "id": 423440650,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708966446
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"300245\">Filippo A. E. Nuccio</span> <a href=\"#narrow/stream/113489-new-members/topic/Creating.20a.20higher.20level.20object/near/423440650\">said</a>:</p>\n<blockquote>\n<p>Concerning your first question, a <code>class</code> is somewhat a special kind of structure that is taken into account by type-class inference: you can have a look at <a href=\"https://leanprover-community.github.io/mathematics_in_lean/C07_Hierarchies.html\">Chapter 7</a> of <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a>. At any rate the above code would have worked equally well replacing <code>class</code> by <code>structure</code>. Concerning the second point, what do you mean by \"went inside\"?</p>\n</blockquote>\n<p>I initially wrote the following. The suggestion above moves ell inside, but point stays. I meant what is special about ell or point?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">ProjectiveGeometry</span> <span class=\"o\">(</span><span class=\"n\">point</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ell</span><span class=\"o\">:</span> <span class=\"n\">point</span> <span class=\"bp\">→</span> <span class=\"n\">point</span> <span class=\"bp\">→</span> <span class=\"n\">point</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"n\">where</span>\n<span class=\"n\">l1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">ell</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">a</span>\n<span class=\"n\">l2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">ell</span> <span class=\"n\">a</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">ell</span> <span class=\"n\">b</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">ell</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">p</span>\n<span class=\"n\">l3</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">ell</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">ell</span> <span class=\"n\">p</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">point</span><span class=\"o\">,</span> <span class=\"n\">ell</span> <span class=\"n\">q</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"bp\">∧</span> <span class=\"n\">ell</span> <span class=\"n\">q</span> <span class=\"n\">b</span> <span class=\"n\">d</span>\n</code></pre></div>",
        "id": 423441536,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1708966654
    },
    {
        "content": "<p>We would say that <code>point</code> and <code>ell</code> \"contain data\": they are honest gadgets (one is a type, the other is a yes/no check on three variables, implemented as a function). On the other hand, <code>l1-l2-l3</code> are just propositions, so we are requiring that they hold. The key difference lies in \"propositional irrelevance\", saying that types in <code>Prop</code> behave differently because every such type contains at most one term (aka: all proofs of a certain proposition coincide), and this is not true for other types.</p>",
        "id": 423443142,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708967036
    },
    {
        "content": "<p>In general, to determine whether you choose to put something inside a class (“bundling”) or put it in the parameters (“unbundled”) is a choice with tradeoffs either way.</p>\n<ol>\n<li>If there is more than one possible implementation, then it must go in the parameters. For example, <code>point</code> must be a parameter because there is more than one projective geometry in existence. If, hypothetically, a single type that represents a projective geometry could have multiple different <code>ell</code> functions, then <code>ell</code> should definitely be a parameter.</li>\n<li>Otherwise, if there is only one implementation, but you need to easily enforce that it is _the same as something else_, one should use an _out parameter_. An example of this is Lean’s <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#HAdd\"><code>HAdd</code></a> typeclass. It has three parameters, <code>α</code>, <code>β</code> and <code>γ</code>, representing the left-hand input, right-hand input and output types respectively. <code>α</code> and <code>β</code> are both normal parameters, because they can be any two types, but <code>γ</code> is an out parameter, because given two types that you’re adding together, there should only be one possible output type. <code>γ</code> could have also been bundled in the <code>HAdd</code> class itself — the reason they _don’t_ do this is that it allows functions like the following:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">HAdd</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"c\">/-</span><span class=\"cm\"> whatever -/</span><span class=\"bp\">;</span>\n</code></pre></div>\n<p>That is, we are easily able to place further restrictions on <code>γ</code>  by adding more typeclasses to it. This would be harder if <code>γ</code> was bundled.</p>\n<ol start=\"3\">\n<li>If you don’t need the above use-case, which is often the case for functions like <code>ell</code>, you should bundle it, including it in the typeclass itself, as in the code sample given.</li>\n</ol>",
        "id": 423444220,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1708967320
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"574896\">Sabrina Jewson</span> <a href=\"#narrow/stream/113489-new-members/topic/Creating.20a.20higher.20level.20object/near/423444220\">said</a>:</p>\n<blockquote>\n<p>In general, to determine whether you choose to put something inside a class (“bundling”) or put it in the parameters (“unbundled”) is a choice with tradeoffs either way.</p>\n<ol>\n<li>If there is more than one possible implementation, then it must go in the parameters. For example, <code>point</code> must be a parameter because there is more than one projective geometry in existence. If, hypothetically, a single type that represents a projective geometry could have multiple different <code>ell</code> functions, then <code>ell</code> should definitely be a parameter.</li>\n<li>Otherwise, if there is only one implementation, but you need to easily enforce that it is _the same as something else_, one should use an _out parameter_. An example of this is Lean’s <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#HAdd\"><code>HAdd</code></a> typeclass. It has three parameters, <code>α</code>, <code>β</code> and <code>γ</code>, representing the left-hand input, right-hand input and output types respectively. <code>α</code> and <code>β</code> are both normal parameters, because they can be any two types, but <code>γ</code> is an out parameter, because given two types that you’re adding together, there should only be one possible output type. <code>γ</code> could have also been bundled in the <code>HAdd</code> class itself — the reason they _don’t_ do this is that it allows functions like the following:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">HAdd</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"c\">/-</span><span class=\"cm\"> whatever -/</span><span class=\"bp\">;</span>\n</code></pre></div>\n<p>That is, we are easily able to place further restrictions on <code>γ</code>  by adding more typeclasses to it. This would be harder if <code>γ</code> was bundled.</p>\n<ol start=\"3\">\n<li>If you don’t need the above use-case, which is often the case for functions like <code>ell</code>, you should bundle it, including it in the typeclass itself, as in the code sample given.</li>\n</ol>\n</blockquote>\n<p>Perfect, this makes complete sense. Thank you so much.</p>",
        "id": 423446194,
        "sender_full_name": "Abdullah Uyu",
        "timestamp": 1708967857
    }
]