[
    {
        "content": "<p>I was doing some Advent of Code to learn Lean (horrible code here: <a href=\"https://github.com/klockeph/AdventOfCode2023\">https://github.com/klockeph/AdventOfCode2023</a>; I definitely see improvement over the days, whenever I found better (syntax) features).</p>\n<p>So one recurring pattern is a kind of BFS over a 2D map <code>(List (List Char))</code>. I was usually too lazy to parse that as a graph; instead I implemented a function <code>getNext (Nat * Nat) -&gt; List (Nat * Nat)</code> that returned all valid neighbors.</p>\n<p>I repeated myself quite often (<a href=\"https://github.com/klockeph/AdventOfCode2023/blob/main/AdventOfCode/Day10.lean#L64\">https://github.com/klockeph/AdventOfCode2023/blob/main/AdventOfCode/Day10.lean#L64</a>, <a href=\"https://github.com/klockeph/AdventOfCode2023/blob/main/AdventOfCode/Day16.lean#L74\">https://github.com/klockeph/AdventOfCode2023/blob/main/AdventOfCode/Day16.lean#L74</a> to name two)... and while I could fix that by hardcoding less and making e.g. getNext an argument of bfs, the main thing that bothers me is the <code>partial</code>.</p>\n<p>How would I prove termination of bfs over a finite graph? One idea I had is using <code>Fin * Fin</code> as positions; would that be enough?<br>\nAnother idea would be having a HashSet of all nodes and removing visited ones, instead of adding; then that HashSet is always decreasing (or empty). But it would require a pass over the Graph beforehand.</p>\n<p>So what is the standard way of implementing bfs and proving that it terminates?</p>",
        "id": 411088072,
        "sender_full_name": "Philipp",
        "timestamp": 1704319026
    }
]