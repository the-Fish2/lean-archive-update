[
    {
        "content": "<p>I tried selecting part of a disjunction with <code>.1</code> in this code. The manuals describe the case if the goal is the disjunction but what if I need to match a disjunction that is the condition of a lemma?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">h</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hk</span><span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k</span><span class=\"o\">):</span> <span class=\"n\">p</span> <span class=\"bp\">≥</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hp</span>\n  <span class=\"n\">conv</span> <span class=\"n\">at</span> <span class=\"n\">hk</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ne_iff_lt_or_gt.mpr.1</span> <span class=\"n\">hk</span><span class=\"o\">]</span>     <span class=\"c1\">-- &lt;========</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">one_add_div</span> <span class=\"n\">hk</span> <span class=\"n\">k</span> <span class=\"mi\">1</span><span class=\"o\">]</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"n\">invalid</span> <span class=\"n\">field</span> <span class=\"kd\">notation</span><span class=\"o\">,</span> <span class=\"n\">type</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">form</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"bp\">...</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">C</span> <span class=\"n\">is</span> <span class=\"n\">a</span> <span class=\"kd\">constant</span>\n  <span class=\"n\">ne_iff_lt_or_gt.mpr</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.386</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">?</span><span class=\"n\">m.387</span> <span class=\"bp\">∨</span> <span class=\"bp\">?</span><span class=\"n\">m.386</span> <span class=\"bp\">&gt;</span> <span class=\"bp\">?</span><span class=\"n\">m.387</span> <span class=\"bp\">→</span> <span class=\"bp\">?</span><span class=\"n\">m.386</span> <span class=\"bp\">≠</span> <span class=\"bp\">?</span><span class=\"n\">m.387</span>\n</code></pre></div>\n<p>I think the <code>invalid field notation...</code> means that it just can't find <code>.1</code>. My plan is to pick the left part of the disjunction to rewrite <code>hk</code> to <code>k \\ne 0</code>, and then to use it to rewrite <code>(k+1)/k</code> to <code>k/k + 1/k</code>. Please help.</p>",
        "id": 433730069,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1713352378
    },
    {
        "content": "<p>Also, <code>0 &lt; k</code> as condition cannot be changed.</p>",
        "id": 433730923,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1713352729
    },
    {
        "content": "<p>So <code>ne_iff_lt_or_gt.mpr</code> has type <code>?m.61 &lt; ?m.62 ∨ ?m.61 &gt; ?m.62 → ?m.61 ≠ ?m.62</code>. That is, it's an implication whose premise is an or. In English: if either a &lt; b or b &lt; a, a and b are not equal. That means you need to apply it to a value of type <code>?m.61 &lt; ?m.62 ∨ ?m.61 &gt; ?m.62</code>. You can construct such a type either by giving a proof of the left hand side (<code>Or.inl hk</code>) or the right hand side (<code>Or.inr hk</code>), where <code>l</code> and <code>r</code> stand for left and right, respectively</p>",
        "id": 433747694,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1713358051
    },
    {
        "content": "<p>Now in either case , your conclusion is going to be an inequality, so you can't rewrite with it</p>",
        "id": 433747845,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1713358084
    },
    {
        "content": "<p>I meant I planned to use the (as <code>0 \\ne k</code>) rewritten <code>hk</code> to rewrite the right side of the goal <code>(k + 1)/k</code> to <code>k/k + 1/k</code> because <code>← one_add_div</code> has <code>0 \\ne k</code> as condition. And by delegating to a sublemma that suddenly resolved. But no.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">h</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hk</span><span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k</span><span class=\"o\">):</span> <span class=\"n\">p</span> <span class=\"bp\">≥</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hp</span>\n  <span class=\"k\">have</span> <span class=\"n\">hkk</span><span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≠</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"n\">ne_iff_lt_or_gt.mpr</span> <span class=\"o\">(</span><span class=\"n\">Or.inl</span> <span class=\"n\">hk</span><span class=\"o\">)</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">one_add_div</span> <span class=\"n\">hkk</span> <span class=\"mi\">1</span> <span class=\"n\">k</span><span class=\"o\">]</span>\n\n<span class=\"n\">function</span> <span class=\"n\">expected</span> <span class=\"n\">at</span>\n  <span class=\"n\">one_add_div</span> <span class=\"bp\">?</span><span class=\"n\">m.493</span>\n<span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">m.435</span> <span class=\"bp\">/</span> <span class=\"bp\">?</span><span class=\"n\">m.436</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m.436</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">m.435</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"bp\">?</span><span class=\"n\">m.436</span>\n</code></pre></div>\n<p>But what does this error mean? I gave the needed condition <code>hkk</code> and what should be substituted for <code>a</code> and <code>b</code> in <code>one_add_div</code>.<br>\n It looks like I should much more write <code>have</code> with subgoals instead of immediate attempts to rewrite/apply because the glue mechanics is so delicate (and the error messages so ... hmm).</p>",
        "id": 433783742,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1713364155
    },
    {
        "content": "<p><code>function expected at</code> means that you're passing more (explicit) arguments than <code>one_add_div</code> expects</p>",
        "id": 433817179,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1713367856
    },
    {
        "content": "<p>Many thanks. The final version will be in <code>\\R</code> and look like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">H</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hk</span><span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">):</span> <span class=\"n\">p</span> <span class=\"bp\">≥</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h_k_nonzero</span><span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">ne_iff_lt_or_gt.mpr</span> <span class=\"o\">(</span><span class=\"n\">Or.inr</span> <span class=\"n\">hk</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"n\">h_p_gt_one</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">have</span> <span class=\"n\">h_p_ne_one</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₁</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">one_add_div</span> <span class=\"n\">h_p_ne_one</span><span class=\"o\">,</span> <span class=\"n\">sub_add_cancel</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">one_add_div</span> <span class=\"n\">h_k_nonzero</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">add_le_add_iff_left</span><span class=\"o\">,</span>\n    <span class=\"n\">ge_iff_le</span><span class=\"o\">,</span> <span class=\"n\">one_div_le_one_div</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">succ_le_succ_iff</span><span class=\"o\">]</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>When finished, this could be part of Ch.01, 4th proof of The Formal BOOK. It's a bit concerning that a big part of such formalizations have to deal with manipulations of simple conditions, like from <code>k&lt;0</code> to <code>k \\ne 0</code> or from <code>p \\ge k+1</code> to <code>p &gt; 1</code>. Having something where one just states the conditions needed for all the rewrites and then invoking a tactic would substantially shrink proofs. Beginner's dreams.</p>",
        "id": 433987347,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1713427537
    },
    {
        "content": "<p>If you're willing to use a stronger tactic then you can just <code>intro; rw [div_le_div_iff]</code> and then <code>repeat linarith</code></p>",
        "id": 434024353,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1713439435
    },
    {
        "content": "<p>Can <code>linarith</code> somehow print what it finds, like <code>simp?</code> ?</p>",
        "id": 434045568,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1713446511
    },
    {
        "content": "<p>No, as it doesn't work by directly looking for lemmas which can simplify the problem but by applying a linear programming algorithm. You can use <code>set_option trace.linarith true</code> to get more details, though</p>",
        "id": 434048257,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1713447239
    },
    {
        "content": "<p>It could apparently generate a <code>linear_combination</code> tactic call, but this needs some work</p>",
        "id": 434057592,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1713449616
    }
]