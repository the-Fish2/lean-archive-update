[
    {
        "content": "<p>Hello,<br>\nis there a \"generalized\" rewrite tactic (ie a version of rewrite that works with any equivalence relation)?<br>\nI wanted to try prove some theorems about propositional logic, so I wrote up the following definitions.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">LTerm.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">LTrue</span>\n  <span class=\"bp\">|</span> <span class=\"n\">LFalse</span>\n  <span class=\"bp\">|</span> <span class=\"n\">LVar</span> <span class=\"o\">(</span><span class=\"n\">var</span> <span class=\"o\">:</span> <span class=\"n\">τ</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">LNot</span> <span class=\"o\">(</span><span class=\"n\">expr</span> <span class=\"o\">:</span> <span class=\"n\">LTerm</span> <span class=\"n\">τ</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">LAnd</span> <span class=\"o\">(</span><span class=\"n\">lexpr</span> <span class=\"n\">rexpr</span> <span class=\"o\">:</span> <span class=\"n\">LTerm</span> <span class=\"n\">τ</span><span class=\"o\">)</span>\n<span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">60</span> <span class=\"s2\">\" ∩ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">LTerm.LAnd</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">LTerm.eval.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">LTerm</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span>\n  <span class=\"bp\">|</span> <span class=\"n\">LTrue</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span>\n  <span class=\"bp\">|</span> <span class=\"n\">LFalse</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">LVar</span> <span class=\"n\">var</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">I</span> <span class=\"n\">var</span>\n  <span class=\"bp\">|</span> <span class=\"n\">LNot</span> <span class=\"n\">expr</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">!</span><span class=\"n\">expr.eval</span> <span class=\"n\">I</span>\n  <span class=\"bp\">|</span> <span class=\"n\">LAnd</span> <span class=\"n\">lexpr</span> <span class=\"n\">rexpr</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lexpr.eval</span> <span class=\"n\">I</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">rexpr.eval</span> <span class=\"n\">I</span>\n<span class=\"kd\">notation</span> <span class=\"s2\">\"⟦\"</span> <span class=\"n\">expr</span> <span class=\"s2\">\" | \"</span> <span class=\"n\">I</span> <span class=\"s2\">\"⟧\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">LTerm.eval</span> <span class=\"n\">I</span> <span class=\"n\">expr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">LEquiv.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">lexpr</span> <span class=\"n\">rexpr</span> <span class=\"o\">:</span> <span class=\"n\">LTerm</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">,</span> <span class=\"bp\">⟦</span><span class=\"n\">lexpr</span> <span class=\"bp\">|</span> <span class=\"n\">I</span><span class=\"bp\">⟧</span> <span class=\"bp\">=</span> <span class=\"bp\">⟦</span><span class=\"n\">rexpr</span> <span class=\"bp\">|</span> <span class=\"n\">I</span><span class=\"bp\">⟧</span>\n<span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"s2\">\" ≡ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">LEquiv</span>\n</code></pre></div>\n<p>Now it is easy to prove, that equivalence is preserved under substitution:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">subst_left_and.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">φ</span> <span class=\"n\">φ'</span> <span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">LTerm</span> <span class=\"n\">τ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">φ</span> <span class=\"bp\">≡</span> <span class=\"n\">φ'</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">φ</span> <span class=\"bp\">∩</span> <span class=\"n\">ψ</span> <span class=\"bp\">≡</span> <span class=\"n\">φ'</span> <span class=\"bp\">∩</span> <span class=\"n\">ψ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">I</span><span class=\"bp\">;</span> <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">LTerm.eval</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>This can be used in the following way</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">subst_left_and'.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">φ</span> <span class=\"n\">φ'</span> <span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">LTerm</span> <span class=\"n\">τ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">φ</span> <span class=\"bp\">≡</span> <span class=\"n\">φ'</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">φ</span> <span class=\"bp\">∩</span> <span class=\"n\">ψ</span> <span class=\"bp\">≡</span> <span class=\"n\">φ'</span> <span class=\"bp\">∩</span> <span class=\"n\">ψ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">subst_left_and</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>However what I am looking for would be the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">grewrite</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">subst_left_and.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">φ</span> <span class=\"n\">φ'</span> <span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">LTerm</span> <span class=\"n\">τ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">φ</span> <span class=\"bp\">≡</span> <span class=\"n\">φ'</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">φ</span> <span class=\"bp\">∩</span> <span class=\"n\">ψ</span> <span class=\"bp\">≡</span> <span class=\"n\">φ'</span> <span class=\"bp\">∩</span> <span class=\"n\">ψ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">I</span><span class=\"bp\">;</span> <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">LTerm.eval</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">subst_left_and'.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">φ</span> <span class=\"n\">φ'</span> <span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">LTerm</span> <span class=\"n\">τ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">φ</span> <span class=\"bp\">≡</span> <span class=\"n\">φ'</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">φ</span> <span class=\"bp\">∩</span> <span class=\"n\">ψ</span> <span class=\"bp\">≡</span> <span class=\"n\">φ'</span> <span class=\"bp\">∩</span> <span class=\"n\">ψ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">grw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 431688601,
        "sender_full_name": "Marmare314",
        "timestamp": 1712422819
    },
    {
        "content": "<p>Without really reading your question, at a glance <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/GCongr/Core.html\">gcongr</a> might be what you want</p>",
        "id": 431698065,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1712430362
    },
    {
        "content": "<p>In general, rather than <code>subst_left_and</code>, you want congruence theorems like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">congr_and.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">φ</span> <span class=\"n\">φ'</span> <span class=\"n\">ψ</span> <span class=\"n\">ψ'</span> <span class=\"o\">:</span> <span class=\"n\">LTerm</span> <span class=\"n\">τ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">φ</span> <span class=\"bp\">≡</span> <span class=\"n\">φ'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">φ</span> <span class=\"bp\">≡</span> <span class=\"n\">φ'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">φ</span> <span class=\"bp\">∩</span> <span class=\"n\">ψ</span> <span class=\"bp\">≡</span> <span class=\"n\">φ'</span> <span class=\"bp\">∩</span> <span class=\"n\">ψ'</span>\n</code></pre></div>\n<p>and so on, for every operation and function you care about.</p>\n<p>Then, do to a \"rewrite\", you <code>apply</code> these congruence theorems to navigate to the exact term you want to rewrite. You use the reflexivity of the relation for every term you don't want to rewrite. Though you need some additional mechanism to set up what it means to rewrite an <code>LTerm</code> term using the relation.</p>",
        "id": 431698325,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712430536
    },
    {
        "content": "<p>This is essentially how <code>simp</code> works. It's able to generate congruence theorems for <code>Eq</code> itself since <code>Eq</code> has some strong properties that let the congruence theorems not depend on the exact implementations of any of the definitions. It can also use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=cast#doc\">docs#cast</a> (or an equivalent) as that last mechanism to be able to replace a term with the rewritten one.</p>",
        "id": 431698764,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712430871
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466290\">Luigi Massacci</span> <a href=\"#narrow/stream/113489-new-members/topic/Generalized.20rewrite/near/431698065\">said</a>:</p>\n<blockquote>\n<p>Without really reading your question, at a glance <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/GCongr/Core.html\">gcongr</a> might be what you want</p>\n</blockquote>\n<p>With <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> 's version this definitely seems like a good suggestion. Although this may be the best solution, it is not really what I am looking for.</p>",
        "id": 431702847,
        "sender_full_name": "Marmare314",
        "timestamp": 1712434579
    },
    {
        "content": "<blockquote>\n<p>Though you need some additional mechanism to set up what it means to rewrite an <code>LTerm</code> term using the relation.</p>\n</blockquote>\n<p>I'm not quite sure what additional mechanisms you are referring to.</p>",
        "id": 431702889,
        "sender_full_name": "Marmare314",
        "timestamp": 1712434649
    },
    {
        "content": "<p>Let's say you have <code>φ ∩ ψ</code> and you want to do <code>grw [h]</code> on this term. That gives you <code>φ' ∩ ψ</code> along with a proof of <code>φ ∩ ψ ≡ φ' ∩ ψ</code>. How do you substitute <code>φ' ∩ ψ</code> for <code>φ ∩ ψ</code> using that proof? Or, what's the high-level operation you want <code>grw</code> to do to a term? It's something you have to think about.</p>",
        "id": 431703055,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712434814
    },
    {
        "content": "<p>If <code>grw</code> is meant to only handle targets with <code>≡</code>, then you could arrange for your <code>grw</code> to be able to rewrite <code>X ≡ Y</code> to <code>X' ≡ Y'</code> while creating a proof that <code>X ≡ Y ↔ X' ≡ Y'</code> (or, if you want, <code>(X ≡ Y) = (X' ≡ Y')</code>) to be able to do the replacement.</p>",
        "id": 431703159,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712434930
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Generalized.20rewrite/near/431703055\">said</a>:</p>\n<blockquote>\n<p>Let's say you have <code>φ ∩ ψ</code> and you want to do <code>grw [h]</code> on this term. That gives you <code>φ' ∩ ψ</code> along with a proof of <code>φ ∩ ψ ≡ φ' ∩ ψ</code>. How do you substitute <code>φ' ∩ ψ</code> for <code>φ ∩ ψ</code> using that proof? Or, what's the high-level operation you want <code>grw</code> to do to a term? It's something you have to think about.</p>\n</blockquote>\n<p>Ah, that makes sense, I forgot that not all expressions need to be of the form <code>X ≡ Y</code>.</p>",
        "id": 431703387,
        "sender_full_name": "Marmare314",
        "timestamp": 1712435207
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Generalized.20rewrite/near/431703159\">said</a>:</p>\n<blockquote>\n<p>If <code>grw</code> is meant to only handle targets with <code>≡</code>, then you could arrange for your <code>grw</code> to be able to rewrite <code>X ≡ Y</code> to <code>X' ≡ Y'</code> while creating a proof that <code>X ≡ Y ↔ X' ≡ Y'</code> (or, if you want, <code>(X ≡ Y) = (X' ≡ Y')</code>) to be able to do the replacement.</p>\n</blockquote>\n<p>How would I do that?</p>",
        "id": 431703424,
        "sender_full_name": "Marmare314",
        "timestamp": 1712435269
    },
    {
        "content": "<p>Also would it make sense to use a quotient type here instead?</p>",
        "id": 431703475,
        "sender_full_name": "Marmare314",
        "timestamp": 1712435314
    },
    {
        "content": "<p>I think the way you do this is you make a congruence theorem that <code>X ≡ Y ↔ X' ≡ Y'</code> follows from <code>X ≡ X'</code> and <code>Y ≡ Y'</code>. Then you start out by doing <code>rw</code> with this theorem, which sets up two additional goals that look like <code>X ≡ ?m.123</code>. From here, you can <code>apply</code> your <code>≡</code>-specific congruence theorems to navigate to the expression you want, in the LHS of these goals. Once you're done with any particular one of these goals, you apply reflexivity.</p>\n<p>This is mimicking how <code>conv =&gt; ...</code> works, but for your own relation.</p>",
        "id": 431803234,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712513864
    },
    {
        "content": "<p>Quotient types are a good idea too. They come with their own complexities, but there's something to be said for getting access to all the tactics that work with <code>=</code>.</p>",
        "id": 431803314,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712513920
    },
    {
        "content": "<p>Thank you, this was very helpful!</p>",
        "id": 432493656,
        "sender_full_name": "Marmare314",
        "timestamp": 1712752414
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"650736\">Marmare314</span> has marked this topic as resolved.</p>",
        "id": 432493690,
        "sender_full_name": "Notification Bot",
        "timestamp": 1712752426
    }
]