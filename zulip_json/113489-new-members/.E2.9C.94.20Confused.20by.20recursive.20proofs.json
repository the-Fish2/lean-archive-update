[
    {
        "content": "<p>I'm trying to solve the following problem:</p>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Reachable.exists_walk_of_dist#doc\">docs#SimpleGraph.Reachable.exists_walk_of_dist</a> only gives us a walk, meanwhile a lot of books define distance as the shortest path between vertices, which is fine, these two definitions are equivalent, because the shortest walk has to be a path, here is a proof: if it is not, then there is a duplicate vertex, delete the portion of the walk that is from it to itself and you end up with a shorter walk, contradiction!</p>\n<p>I've spent the whole day formalizing this seemingly simple proof, and here is the idea I came up with:<br>\n<code>by_contra</code>, there is a duplicate in the walk <code>p : G.Walk u v</code> (which is the walk we got from the theorem I linked up), there is two cases:</p>\n<ul>\n<li>The duplicated vertex in <code>p</code> is <code>u</code>, in this case we reach a contradiction (this part is done).</li>\n<li>The duplicated vertex is in <code>p.tail</code>, in this case, I would like to do recursion, this time dividing <code>p.tail</code> into <code>a :: p.tail.tail</code>, and so on.</li>\n</ul>\n<p>From my skimming through chapter 7 &amp; 8 of <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a>, it seems that this should be the correct way to prove this in lean.<br>\nHow could I do this? Here is my code so far (also I recognize this code is ugly and any help with techniques on how to tidy it up are appreciated too!)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Metric</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">SimpleGraph</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Reachable.exists_path_of_dist</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"n\">G.Reachable</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.Walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">p.length</span> <span class=\"bp\">=</span> <span class=\"n\">G.dist</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">∧</span> <span class=\"n\">p.IsPath</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">hnv</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">v</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hnv</span><span class=\"o\">]</span>\n    <span class=\"n\">use</span> <span class=\"bp\">.</span><span class=\"n\">nil</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Walk.length_nil</span><span class=\"o\">,</span> <span class=\"n\">Walk.isPath_iff_eq_nil</span><span class=\"o\">]</span>\n    <span class=\"n\">nth_rewrite</span> <span class=\"mi\">1</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hnv</span><span class=\"o\">]</span>\n    <span class=\"n\">apply</span> <span class=\"n\">And.intro</span>\n    <span class=\"bp\">·</span> <span class=\"n\">symm</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hr.dist_eq_zero_iff</span><span class=\"o\">,</span> <span class=\"n\">hnv</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">·</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hr.exists_walk_of_dist</span>\n    <span class=\"n\">use</span> <span class=\"n\">p</span>\n    <span class=\"n\">apply</span> <span class=\"n\">And.intro</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">hp</span>\n    <span class=\"bp\">·</span> <span class=\"k\">have</span> <span class=\"n\">hnn</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p.Nil</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">by_contra</span> <span class=\"n\">pnil</span>\n        <span class=\"n\">exact</span> <span class=\"n\">hnv</span> <span class=\"o\">(</span><span class=\"n\">Walk.Nil.eq</span> <span class=\"n\">pnil</span><span class=\"o\">)</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Walk.isPath_def</span><span class=\"o\">]</span>\n      <span class=\"n\">by_contra</span> <span class=\"n\">hnp</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">List.exists_duplicate_iff_not_nodup.mpr</span> <span class=\"n\">hnp</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">p.cons_support_tail</span> <span class=\"n\">hnn</span><span class=\"o\">,</span> <span class=\"n\">List.duplicate_cons_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span>\n      <span class=\"n\">cases'</span> <span class=\"n\">hx</span> <span class=\"k\">with</span> <span class=\"n\">h</span> <span class=\"n\">h'</span>\n      <span class=\"bp\">·</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">h1</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h2</span>\n        <span class=\"k\">have</span> <span class=\"n\">hw</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">G.Walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w.length</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p.length</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n          <span class=\"k\">let</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">p.tail</span> <span class=\"n\">hnn</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">dropUntil</span> <span class=\"n\">u</span> <span class=\"n\">h2</span>\n          <span class=\"n\">use</span> <span class=\"n\">w</span>\n          <span class=\"k\">have</span> <span class=\"n\">hwl</span> <span class=\"o\">:</span> <span class=\"n\">w.length</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">p.tail</span> <span class=\"n\">hnn</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Walk.tail</span> <span class=\"n\">p</span> <span class=\"n\">hnn</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length_dropUntil_le</span> <span class=\"n\">h2</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">add_le_add_iff_right</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">p.length_tail_add_one</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hwl</span>\n          <span class=\"n\">omega</span>\n        <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">hw</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hw</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hp</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hw</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">w.length</span> <span class=\"bp\">≥</span> <span class=\"n\">G.dist</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">dist_le</span> <span class=\"n\">w</span>\n        <span class=\"n\">omega</span>\n      <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I've tried writing it with <code>match p.support with ...</code> notation but couldn't get it to work.</p>",
        "id": 430464770,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1711879125
    },
    {
        "content": "<p>I'm 90% sure this proof already exists in the library</p>",
        "id": 430464812,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711879197
    },
    {
        "content": "<p>I think it might help to split the theorem into two: there exists a walk of length <code>G.dist u v</code>, and also any walk of this length is a path</p>",
        "id": 430464933,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711879278
    },
    {
        "content": "<p>I believe <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> has written(/put in mathlib?) a definition to deduplicate the vertices of a walk</p>",
        "id": 430465013,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711879331
    },
    {
        "content": "<p>If not, I can rewrite it for you when I get back to a computer (but I think it would be good practice for you to try writing it yourself)</p>",
        "id": 430465054,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711879388
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Confused.20by.20recursive.20proofs/near/430464933\">said</a>:</p>\n<blockquote>\n<p>I think it might help to split the theorem into two: there exists a walk of length <code>G.dist u v</code>, and also any walk of this length is a path</p>\n</blockquote>\n<p>Yes, the first part already exists, I'm trying to write the second part (which doesn't exist yet).  I decided to state it as \"there exists a path\" because it felt easier to prove as a starter.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/Confused.20by.20recursive.20proofs/near/430465054\">said</a>:</p>\n<blockquote>\n<p>If not, I can rewrite it for you when I get back to a computer (but I think it would be good practice for you to try writing it yourself)</p>\n</blockquote>\n<p>I would like to attempt writing it myself, do you have any advice on how to approach it?</p>",
        "id": 430465290,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1711879635
    },
    {
        "content": "<p>Yes, write a function <code>Walk.toPath : G.Walk u v -&gt; G.Path u v</code> by recursion. You will need an auxiliary function <code>Walk.stop : \\forall w : G.Walk u v, v' \\in w -&gt; G.Walk u v'</code>. For the latter, you will need to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Walk.copy#doc\">docs#SimpleGraph.Walk.copy</a> at some point.</p>",
        "id": 430465671,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711879995
    },
    {
        "content": "<p>(I'm not sure <code>Walk.stop</code> is a great name)</p>",
        "id": 430465680,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711880020
    },
    {
        "content": "<p>I think it's called <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Walk.bypass#doc\">docs#SimpleGraph.Walk.bypass</a></p>",
        "id": 430465870,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711880196
    },
    {
        "content": "<p>ah it already exists, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Walk.toPath#doc\">docs#SimpleGraph.Walk.toPath</a></p>",
        "id": 430465967,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1711880327
    },
    {
        "content": "<p>The theorem isn't stated exactly like your code, but I think it follows from the properties of this function:</p>\n<ul>\n<li><code>bypass</code> is a path</li>\n<li>the support is a subset of the original walk</li>\n<li>the length is less or equal to the original length</li>\n</ul>\n<p>Being a path from u to v, the length is at least <code>dist u v</code>, so the length of the path must be equal to <code>dist u v</code> if the original walk has this length, and moreover the support must have size <code>dist u v</code>, hence the path is nodup and the original walk is in fact a path</p>",
        "id": 430466207,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711880565
    },
    {
        "content": "<p>Awesome. Thank you! <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 430466383,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1711880728
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"580947\">Rida Hamadani</span> has marked this topic as resolved.</p>",
        "id": 430466390,
        "sender_full_name": "Notification Bot",
        "timestamp": 1711880738
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"580947\">Rida Hamadani</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Confused.20by.20recursive.20proofs/near/430465967\">said</a>:</p>\n<blockquote>\n<p>ah it already exists, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Walk.toPath#doc\">docs#SimpleGraph.Walk.toPath</a></p>\n</blockquote>\n<p>Another win for the <a href=\"https://leanprover-community.github.io/contribute/naming.html\">#naming</a> convention <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 430477135,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711891944
    },
    {
        "content": "<p>It looks like I proved this in a branch of Mathlib 3 but never contributed it: <a href=\"https://github.com/leanprover-community/mathlib/blob/kmill_hamiltonian/src/hamiltonian2.lean#L47-L76\">https://github.com/leanprover-community/mathlib/blob/kmill_hamiltonian/src/hamiltonian2.lean#L47-L76</a></p>\n<p>It uses <code>bypass</code> directly and uses a lemma that if <code>p.length &lt;= p.bypass.length</code> then <code>p = p.bypass</code>, by sort of inducting on the recursion of <code>bypass</code>.</p>",
        "id": 430488260,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711901478
    },
    {
        "content": "<p>Here it is in Lean 4:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">SimpleGraph</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Walk.bypass_eq_of_length_le</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.Walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p.length</span> <span class=\"bp\">≤</span> <span class=\"n\">p.bypass.length</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">p.bypass</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">p</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">h</span> <span class=\"n\">p</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Walk.bypass</span><span class=\"o\">]</span>\n    <span class=\"n\">split_ifs</span> <span class=\"k\">with</span> <span class=\"n\">hb</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exfalso</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"n\">Walk.bypass</span><span class=\"o\">,</span> <span class=\"n\">Walk.length_cons</span><span class=\"o\">,</span> <span class=\"n\">dif_pos</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Nat.not_succ_le_self</span> <span class=\"n\">p.length</span>\n      <span class=\"k\">calc</span> <span class=\"n\">p.length</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n        <span class=\"n\">_</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">p.bypass.dropUntil</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n        <span class=\"n\">_</span> <span class=\"bp\">≤</span> <span class=\"n\">p.bypass.length</span> <span class=\"o\">:=</span> <span class=\"n\">Walk.length_dropUntil_le</span> <span class=\"n\">p.bypass</span> <span class=\"n\">hb</span>\n        <span class=\"n\">_</span> <span class=\"bp\">≤</span> <span class=\"n\">p.length</span> <span class=\"o\">:=</span> <span class=\"n\">Walk.length_bypass_le</span> <span class=\"n\">_</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"n\">Walk.bypass</span><span class=\"o\">,</span> <span class=\"n\">Walk.length_cons</span><span class=\"o\">,</span> <span class=\"n\">not_false_iff</span><span class=\"o\">,</span> <span class=\"n\">dif_neg</span><span class=\"o\">,</span> <span class=\"n\">add_le_add_iff_right</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ih</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kn\">protected</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Reachable.exists_path_of_dist</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"n\">G.Reachable</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.Walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">),</span> <span class=\"n\">p.IsPath</span> <span class=\"bp\">∧</span> <span class=\"n\">p.length</span> <span class=\"bp\">=</span> <span class=\"n\">G.dist</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">classical</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hr.exists_walk_of_dist</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">p.bypass</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Walk.bypass_eq_of_length_le</span>\n    <span class=\"k\">calc</span> <span class=\"n\">p.length</span>\n      <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">G.dist</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n      <span class=\"n\">_</span> <span class=\"bp\">≤</span> <span class=\"n\">p.bypass.length</span> <span class=\"o\">:=</span> <span class=\"n\">dist_le</span> <span class=\"n\">p.bypass</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">this</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Walk.bypass_isPath</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">SimpleGraph</span>\n</code></pre></div>",
        "id": 430488948,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711902163
    },
    {
        "content": "<p>Theorem: every missing <code>SimpleGraph</code> lemma has been proven by Kyle at some point. <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 430501737,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1711913923
    }
]