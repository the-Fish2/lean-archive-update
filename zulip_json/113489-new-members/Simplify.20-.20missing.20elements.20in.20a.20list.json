[
    {
        "content": "<p>I'm stuck on a proof where I can think of a laborious way to prove it, but I'm not sure how to do it concisely (if that's even possible)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"bp\">|</span> <span class=\"n\">c</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span><span class=\"o\">,</span> <span class=\"n\">Fintype</span>\n\n<span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Foo</span><span class=\"o\">,</span> <span class=\"n\">a.length</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">∉</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">l</span> <span class=\"n\">_</span>\n  <span class=\"k\">match</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[</span><span class=\"n\">e₁</span><span class=\"o\">,</span> <span class=\"n\">e₂</span><span class=\"o\">]</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">cases</span> <span class=\"n\">e₁</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">cases</span> <span class=\"n\">e₂</span>\n    <span class=\"n\">repeat</span> <span class=\"o\">(</span> <span class=\"n\">first</span>\n      <span class=\"bp\">|</span> <span class=\"n\">use</span> <span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"bp\">;</span> <span class=\"n\">decide</span>\n      <span class=\"bp\">|</span> <span class=\"n\">use</span> <span class=\"bp\">.</span><span class=\"n\">b</span><span class=\"bp\">;</span> <span class=\"n\">decide</span>\n      <span class=\"bp\">|</span> <span class=\"n\">use</span> <span class=\"bp\">.</span><span class=\"n\">c</span><span class=\"bp\">;</span> <span class=\"n\">decide</span> <span class=\"o\">)</span>\n</code></pre></div>\n<p>Looking through Mathlib, it seems like <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Combinatorics/Pigeonhole.html\">Combinatorics.Pigeonhole</a> might be related, though I can't directly see how.</p>\n<p>My feeling is that I should be able to exploit the relationship between <code>(@Finset.univ Foo).card</code> and <code>a.length</code> somehow. Such that I don't need to brute force the proof.</p>",
        "id": 418198872,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1706238132
    },
    {
        "content": "<p>one strategy you could try: use <code>by_contra!</code> and work from the hypothesis that the list contains every member of the type</p>",
        "id": 418207535,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706240989
    },
    {
        "content": "<p>use this false hypothesis to \"prove\" that the list, when converted to a finset, is equal to <code>Finset.univ</code>, and then show that the cardinality of the finset doesn't match the cardinality of the Fintype</p>",
        "id": 418207813,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706241065
    },
    {
        "content": "<p>do you want me to share a proof? not sure if this is something you wanted to figure out yourself</p>",
        "id": 418208613,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706241756
    },
    {
        "content": "<p>Here's a bit of a simplification:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Foo</span><span class=\"o\">,</span> <span class=\"n\">a.length</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">∉</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">l</span> <span class=\"n\">_</span>\n  <span class=\"k\">match</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[</span><span class=\"n\">e₁</span><span class=\"o\">,</span> <span class=\"n\">e₂</span><span class=\"o\">]</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">revert</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span>\n    <span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 418208714,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706241865
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> that's giving me an error in the Lean web editor... is there a specific import that it requires?</p>",
        "id": 418209600,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706242622
    },
    {
        "content": "<p>It seems to work so long as <code>deriving Fintype</code> works.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.DeriveFintype</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"bp\">|</span> <span class=\"n\">c</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span><span class=\"o\">,</span> <span class=\"n\">Fintype</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Foo</span><span class=\"o\">,</span> <span class=\"n\">a.length</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">∉</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">l</span> <span class=\"n\">_</span>\n  <span class=\"k\">match</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[</span><span class=\"n\">e₁</span><span class=\"o\">,</span> <span class=\"n\">e₂</span><span class=\"o\">]</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">revert</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span>\n    <span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 418209755,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706242770
    },
    {
        "content": "<p>here's something I put together using the strategy I described above:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Card</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a.length</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">∉</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">ha</span>\n  <span class=\"n\">by_contra</span><span class=\"bp\">!</span> <span class=\"n\">h</span>\n  <span class=\"k\">have</span> <span class=\"n\">a_eq_univ</span> <span class=\"o\">:</span> <span class=\"n\">a.toFinset</span> <span class=\"bp\">=</span> <span class=\"n\">Finset.univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Finset.eq_univ_iff_forall</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"n\">a_card_le</span> <span class=\"o\">:</span> <span class=\"n\">a.toFinset.card</span> <span class=\"bp\">≤</span> <span class=\"n\">a.length</span> <span class=\"o\">:=</span> <span class=\"n\">List.toFinset_card_le</span> <span class=\"n\">a</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">a_eq_univ</span><span class=\"o\">,</span> <span class=\"n\">Finset.card_univ</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">a_card_le</span>\n  <span class=\"n\">exact</span> <span class=\"n\">ha.not_le</span> <span class=\"n\">a_card_le</span>\n</code></pre></div>",
        "id": 418210563,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706243464
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"380294\">@Matt Diamond</span>  Ah, that works well! I didn't think of that approach at all because by_contra is classical, though for my purposes I don't think I actually need this to be constructive. I managed a very similar proof to yours based on the strategy you described :)</p>\n<p>I'm thinking a constructive approach might be to do something like recursively keep record of the set of elements that are not in the head of the list, proving at each step that the set of elements aren't empty. Which will leave me with exactly the non-empty set not found in the list.</p>",
        "id": 418262303,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1706270494
    },
    {
        "content": "<p>Pattern matching on Arrays works differently than on Lists, so the following doesn't compile</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"bp\">|</span> <span class=\"n\">c</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span><span class=\"o\">,</span> <span class=\"n\">Fintype</span>\n\n<span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Foo</span><span class=\"o\">,</span> <span class=\"n\">a.size</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">∉</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">l</span> <span class=\"n\">_</span>\n  <span class=\"k\">match</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">e₁</span><span class=\"o\">,</span> <span class=\"n\">e₂</span><span class=\"o\">]</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">revert</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span>\n    <span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 418285411,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1706279032
    },
    {
        "content": "<p>It looks like you can pattern match deeper into the list that theoretically backs the Array.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Foo</span><span class=\"o\">,</span> <span class=\"n\">a.size</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">∉</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">l</span> <span class=\"n\">_</span>\n  <span class=\"k\">match</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨[</span><span class=\"n\">e₁</span><span class=\"o\">,</span> <span class=\"n\">e₂</span><span class=\"o\">]⟩</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">revert</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span>\n    <span class=\"n\">decide</span>\n</code></pre></div>\n<p>(Theoretical because this only is used in proofs -- at runtime there's no such List.)</p>",
        "id": 418299240,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706283335
    },
    {
        "content": "<p>So, here's an almost proof that may work constructively once complete:</p>\n<p>I need to dig around in mathlib and/or figure how how to prove:</p>\n<ol>\n<li><code>setList[0] ∈ setList</code> - elements of a list are in the list</li>\n<li><code>b.erase head ⊆ b</code> - erasing an element from a set give you a subset</li>\n<li><code>head ∉ b.erase head</code> - elements are not in sets they've been erased from</li>\n<li>After erasing an element, the new set's cardinality smaller by 0 or 1 </li>\n</ol>\n<p>I think <span class=\"user-mention\" data-user-id=\"380294\">@Matt Diamond</span> 's idea makes for a much nicer proof, but this one's been informative nonetheless.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">DecidableRel</span> <span class=\"n\">α</span> <span class=\"n\">LE.le</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">IsTrans</span> <span class=\"n\">α</span> <span class=\"n\">LE.le</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsAntisymm</span> <span class=\"n\">α</span> <span class=\"n\">LE.le</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsTotal</span> <span class=\"n\">α</span> <span class=\"n\">LE.le</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">missing</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a.length</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b.card</span><span class=\"o\">):</span> <span class=\"bp\">∃</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">∉</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">match</span> <span class=\"n\">a</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">setList</span> <span class=\"o\">:=</span> <span class=\"n\">b.sort</span> <span class=\"n\">LE.le</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">setList.length</span> <span class=\"bp\">=</span> <span class=\"n\">b.card</span> <span class=\"o\">:=</span> <span class=\"n\">Finset.length_sort</span> <span class=\"n\">LE.le</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">setList.length</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.lt_of_lt_of_eq</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"n\">h₁.symm</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">setList</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n    <span class=\"n\">use</span> <span class=\"n\">e</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">.</span> <span class=\"k\">have</span> <span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">setList</span> <span class=\"bp\">↔</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">Finset.mem_sort</span> <span class=\"n\">LE.le</span>\n      <span class=\"n\">apply</span> <span class=\"n\">h₃.mp</span>\n      <span class=\"k\">have</span> <span class=\"n\">h₄</span> <span class=\"o\">:</span> <span class=\"n\">setList</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">∈</span> <span class=\"n\">setList</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n      <span class=\"n\">assumption</span>\n    <span class=\"bp\">.</span> <span class=\"n\">apply</span> <span class=\"n\">List.not_mem_nil</span>\n  <span class=\"bp\">|</span> <span class=\"n\">head</span> <span class=\"o\">::</span> <span class=\"n\">tail</span> <span class=\"bp\">=&gt;</span>\n\n    <span class=\"k\">have</span> <span class=\"n\">newSet</span> <span class=\"o\">:=</span> <span class=\"n\">b.erase</span> <span class=\"n\">head</span>\n    <span class=\"k\">have</span> <span class=\"n\">newSubSet</span> <span class=\"o\">:</span> <span class=\"n\">newSet</span> <span class=\"bp\">⊆</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"k\">have</span> <span class=\"n\">newHeadless</span> <span class=\"o\">:</span> <span class=\"n\">head</span> <span class=\"bp\">∉</span> <span class=\"n\">newSet</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n    <span class=\"k\">have</span> <span class=\"n\">newCard</span> <span class=\"o\">:</span>\n      <span class=\"o\">(</span><span class=\"n\">newSet.card</span> <span class=\"bp\">=</span> <span class=\"n\">b.card</span><span class=\"o\">)</span> <span class=\"bp\">∨</span>\n      <span class=\"o\">(</span><span class=\"n\">newSet.card</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">b.card</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n    <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">eis</span><span class=\"o\">,</span><span class=\"n\">ent</span><span class=\"o\">⟩⟩</span> <span class=\"o\">:=</span> <span class=\"n\">missing</span> <span class=\"n\">tail</span> <span class=\"n\">newSet</span> <span class=\"o\">(</span><span class=\"kd\">by</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">List.length_cons</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n      <span class=\"n\">cases</span> <span class=\"n\">newCard</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">linarith</span><span class=\"o\">)</span>\n\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">List.mem_cons</span><span class=\"o\">]</span>\n\n    <span class=\"n\">use</span> <span class=\"n\">e</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"n\">newSubSet</span> <span class=\"n\">eis</span>\n\n    <span class=\"bp\">.</span> <span class=\"n\">intro</span> <span class=\"n\">ht</span>\n      <span class=\"n\">cases</span> <span class=\"n\">ht</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"n\">eh</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eh</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">eis</span>\n        <span class=\"n\">contradiction</span>\n      <span class=\"bp\">|</span> <span class=\"n\">inr</span> <span class=\"n\">et</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">contradiction</span>\n</code></pre></div>",
        "id": 418321201,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1706290574
    },
    {
        "content": "<ol>\n<li>is <code>List.get_mem _ _ _</code></li>\n<li>is <code>Finset.erase_subset _ _</code> (but you have to change <code>have newSet</code> to <code>let newSet</code>, as <code>have</code> doesn't preserve the value of the variable, only the type)</li>\n</ol>",
        "id": 418323739,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706291469
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/stream/113489-new-members/topic/Simplify.20-.20missing.20elements.20in.20a.20list/near/418323739\">said</a>:</p>\n<blockquote>\n<p>change <code>have newSet</code> to <code>let newSet</code>, as <code>have</code> doesn't preserve the value of the variable, only the type</p>\n</blockquote>\n<p>I've done this to myself more often than I care to admit. Good catch, and thanks for the tips :)</p>",
        "id": 418325089,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1706291930
    },
    {
        "content": "<p>no problem!</p>\n<ol start=\"3\">\n<li>is <code>Finset.not_mem_erase _ _</code>, if you're still looking</li>\n</ol>",
        "id": 418325733,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706292186
    },
    {
        "content": "<p>So far, the only way I've managed to get an element of a Finset is through <code>sort</code>. Which is fine, but only works on types with a relation that support <code>DecidableRel, IsTrans, IsAntisymm,</code> and <code>IsTotal</code></p>\n<p>My guess is that taking an element of a non empty finset is strange because which element you get isn't well defined. But so long as I don't depend on it being any particular element, shouldn't that be fine?</p>",
        "id": 418325828,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1706292227
    },
    {
        "content": "<p>if you're only using the element in the service of proving some proposition, then you could just destructure <code>s.Nonempty</code> to get a random element</p>",
        "id": 418327302,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706292736
    },
    {
        "content": "<p>btw I noticed you wrote <code>missing</code> as a <code>def</code> even though the return type is a <code>Prop</code>... that seems a bit weird to me</p>",
        "id": 418327948,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706292986
    },
    {
        "content": "<p>:), if there's any benefit to this version of the proof, it's that you can have the data, otherwise <code>by_contra!</code> seems like a much cleaner solution</p>",
        "id": 418328023,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1706293026
    },
    {
        "content": "<p>well that's the thing... if you've returned it as an <code>Exists</code>, then I don't believe you can have the data... I don't think you can computably extract data from an <code>Exists</code> even if you proved it without choice</p>",
        "id": 418328351,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706293163
    },
    {
        "content": "<p>That's correct. You could use a sigma type instead</p>",
        "id": 418328687,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706293280
    },
    {
        "content": "<p>Ah, right. A dependent pair in <code>Type 0+</code> can have data, but in <code>Prop</code> it cannot.</p>",
        "id": 418329343,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1706293540
    },
    {
        "content": "<blockquote>\n<p>But so long as I don't depend on it being any particular element, shouldn't that be fine?</p>\n</blockquote>\n<p>if your goal is to write a function that returns a random value from the <code>finset</code> that isn't in the list, then unfortunately I don't think you can do that computably even if you don't care which value it is... if you're returning data from a function, its value must be concretely determined</p>",
        "id": 418330648,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706294020
    },
    {
        "content": "<p>it's kinda like wavefunction collapse in a way... if you're able to access the value, then it can't be indeterminate</p>",
        "id": 418331079,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706294194
    },
    {
        "content": "<p>Couldn't it be concretely determined without it being clear exactly how? Determined, but not in a way the system will let you prove anything about - that's how I'd imagine it. Behind the scenes it's just the first element of a non-empty list, that determined by some previous computation, but the information is lost (on purpose).</p>\n<p>Probably that leads to some bad things in the corner cases I'm not considering.</p>",
        "id": 418333818,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1706295360
    },
    {
        "content": "<p>4.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">newCard</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">newSet.card</span> <span class=\"bp\">=</span> <span class=\"n\">b.card</span><span class=\"o\">)</span> <span class=\"bp\">∨</span>\n  <span class=\"o\">(</span><span class=\"n\">newSet.card</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">b.card</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">head</span> <span class=\"bp\">∈</span> <span class=\"n\">b</span>\n    <span class=\"k\">then</span> <span class=\"kd\">by</span> <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">Finset.card_erase_add_one</span> <span class=\"n\">h</span>\n    <span class=\"k\">else</span> <span class=\"kd\">by</span> <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>That's a good feeling, thanks for you help <span class=\"user-mention\" data-user-id=\"380294\">@Matt Diamond</span> :)</p>",
        "id": 418336485,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1706296332
    },
    {
        "content": "<p>No problem!</p>",
        "id": 418338020,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706296979
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"664276\">@Treq</span> was thinking about this a little more and just wanted to note that you can have a simple computable solution if you write a function that simply returns all of the missing elements... the only non-computable part is picking a random one out of the finset:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.DeriveFintype</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Sort</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"bp\">|</span> <span class=\"n\">c</span> <span class=\"bp\">|</span> <span class=\"n\">d</span> <span class=\"bp\">|</span> <span class=\"n\">e</span> <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"bp\">|</span> <span class=\"n\">g</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span><span class=\"o\">,</span> <span class=\"n\">DecidableEq</span><span class=\"o\">,</span> <span class=\"n\">Fintype</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Foo</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">missing</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Foo</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hl</span> <span class=\"o\">:</span> <span class=\"n\">l.length</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">Foo</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"bp\">Σ'</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Foo</span><span class=\"o\">,</span> <span class=\"n\">s.Nonempty</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span>\n  <span class=\"n\">Finset.univ</span> <span class=\"bp\">\\</span> <span class=\"n\">l.toFinset</span><span class=\"o\">,</span>\n  <span class=\"o\">⟨</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"o\">⟩</span>\n<span class=\"o\">⟩</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">missing</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 418357530,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706306708
    },
    {
        "content": "<p>That's the way to do it! Man. Of course</p>",
        "id": 418377928,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1706321544
    },
    {
        "content": "<p>I filled in the missing proof, because why not.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">missing</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Foo</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hl</span> <span class=\"o\">:</span> <span class=\"n\">l.length</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">Foo</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"bp\">Σ'</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Foo</span><span class=\"o\">,</span> <span class=\"n\">s.Nonempty</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">l</span> <span class=\"o\">:=</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span> <span class=\"n\">Finset.univ</span>\n  <span class=\"k\">let</span> <span class=\"n\">lSet</span> <span class=\"o\">:=</span> <span class=\"n\">l.toFinset</span>\n  <span class=\"k\">let</span> <span class=\"n\">dSet</span> <span class=\"o\">:=</span> <span class=\"n\">univ</span> <span class=\"bp\">\\</span> <span class=\"n\">lSet</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">dSet_ne</span> <span class=\"o\">:</span> <span class=\"n\">dSet.Nonempty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">have</span> <span class=\"n\">cd</span> <span class=\"o\">:</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">Foo</span> <span class=\"bp\">=</span> <span class=\"n\">univ.card</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">lSet</span> <span class=\"bp\">⊆</span> <span class=\"n\">univ</span> <span class=\"o\">:=</span> <span class=\"n\">Finset.subset_univ</span> <span class=\"n\">lSet</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">lSet.card</span> <span class=\"bp\">≤</span> <span class=\"n\">l.length</span> <span class=\"o\">:=</span> <span class=\"n\">List.toFinset_card_le</span> <span class=\"n\">l</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"n\">dSet.card</span> <span class=\"bp\">=</span> <span class=\"n\">univ.card</span> <span class=\"bp\">-</span> <span class=\"n\">lSet.card</span> <span class=\"o\">:=</span> <span class=\"n\">Finset.card_sdiff</span> <span class=\"n\">h₁</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₄</span> <span class=\"o\">:</span> <span class=\"n\">lSet.card</span> <span class=\"bp\">&lt;</span> <span class=\"n\">univ.card</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₅</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">univ.card</span> <span class=\"bp\">-</span> <span class=\"n\">lSet.card</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.le_sub_of_add_le'</span> <span class=\"n\">h₄</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">h₃</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₅</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Finset.card_pos.mp</span> <span class=\"n\">h₅</span>\n\n  <span class=\"o\">⟨</span><span class=\"n\">dSet</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">dSet_ne</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩⟩</span>\n</code></pre></div>",
        "id": 418436602,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1706379363
    },
    {
        "content": "<p>One comment: for Type/Prop pairs, usually you see Subtype rather than PSigma, so <code>{s : Finset Foo // s.Nonempty ∧ ∀ x ∈ s, x ∉ l}</code> rather than <code>Σ' s : Finset Foo, s.Nonempty ∧ ∀ x ∈ s, x ∉ l</code>. Ultimately the type is equivalent, but there's more about Subtype than PSigma in the library.</p>",
        "id": 418450082,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706393441
    },
    {
        "content": "<p>Can I extract an element from a Singleton?<br>\nSeems like it should be possible as which element you get is then fully determined.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">getFromSingleton</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">//</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 418458309,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1706401748
    },
    {
        "content": "<p>This is a bit weird but in theory it should work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Card</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">getFromSingleton</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">//</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">exists_unique</span> <span class=\"o\">:</span> <span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Finset.card_eq_one</span><span class=\"o\">,</span> <span class=\"n\">Finset.singleton_iff_unique_mem</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"o\">⟨</span><span class=\"n\">Finset.choose</span> <span class=\"n\">_</span> <span class=\"n\">s</span> <span class=\"n\">exists_unique</span><span class=\"o\">,</span> <span class=\"n\">Finset.choose_mem</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 418460768,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706404369
    },
    {
        "content": "<p>would be great if there was a more straightforward way that I'm unaware of</p>",
        "id": 418460981,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706404596
    },
    {
        "content": "<p>Guessing the name <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.card_pos#doc\">docs#Finset.card_pos</a></p>",
        "id": 418485806,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706432711
    },
    {
        "content": "<p>That would make it more low-level</p>",
        "id": 418485826,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706432744
    },
    {
        "content": "<p>I made a version that I think expresses that it's always possible to get the data out of a singleton.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">getFromSingleton</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"bp\">//</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">}}</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"n\">unique</span> <span class=\"o\">:</span> <span class=\"bp\">∃!</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>  <span class=\"o\">(</span><span class=\"n\">Finset.singleton_iff_unique_mem</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">h</span>\n  <span class=\"k\">have</span> <span class=\"n\">unique'</span> <span class=\"o\">:</span> <span class=\"bp\">∃!</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">and_true</span><span class=\"o\">,</span> <span class=\"n\">unique</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">e₁</span> <span class=\"o\">:=</span> <span class=\"n\">Finset.choose</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">_</span><span class=\"bp\">↦</span><span class=\"n\">True</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"n\">unique'</span>\n  <span class=\"k\">have</span> <span class=\"n\">e₁_in</span> <span class=\"o\">:</span> <span class=\"n\">e₁</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">Finset.choose_mem</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">_</span><span class=\"bp\">↦</span><span class=\"n\">True</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"n\">unique'</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">e₁</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n    <span class=\"n\">Finset.eq_singleton_iff_unique_mem.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">e₁_in</span><span class=\"o\">,</span> <span class=\"bp\">λ</span><span class=\"n\">e₂</span> <span class=\"n\">e₂_in</span> <span class=\"bp\">↦</span>\n      <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">unique</span>\n      <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">f</span> <span class=\"n\">e₁</span> <span class=\"n\">e₁_in</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">e₂</span> <span class=\"n\">e₂_in</span><span class=\"o\">]</span>\n    <span class=\"o\">⟩</span>\n  <span class=\"o\">⟨</span><span class=\"n\">e₁</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>Really, though this could be something like <code>(∃e, s = {e}) ↔ {e // s = {e}}</code>, but I'm not sure the type that best carries that idea. A Bijection?</p>",
        "id": 418518971,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1706461861
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"664276\">@Treq</span> The proper way to do this, I think, is to prove that the goal is a <code>Subsingleton</code> type and then use <code>Quotient.recOnSubsingleton</code> to extract the value. Here's my attempt:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Multiset.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Card</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Multiset</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">subsingleton_of_card_one</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">card</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Subsingleton</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">//</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">m</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">card_eq_one</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hm</span>\n  <span class=\"n\">cases'</span> <span class=\"n\">hm</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">mem_singleton</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Multiset.getFromSingleton</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">card</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">//</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">m</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"n\">Quotient.recOnSubsingleton</span> <span class=\"n\">m</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">l</span> <span class=\"n\">card_eq_one</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">not_empty</span> <span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"bp\">≠</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">apply</span> <span class=\"n\">List.ne_nil_of_length_pos</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">quot_mk_to_coe</span><span class=\"o\">,</span> <span class=\"n\">coe_card</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">card_eq_one</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">card_eq_one</span><span class=\"o\">]</span>\n    <span class=\"o\">⟨</span><span class=\"n\">l.head</span> <span class=\"n\">not_empty</span><span class=\"o\">,</span> <span class=\"n\">List.head_mem</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Finset.getFromSingleton</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">//</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"n\">Multiset.getFromSingleton</span> <span class=\"n\">s.val</span> <span class=\"n\">hs</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">Finset.getFromSingleton</span> <span class=\"o\">{</span><span class=\"mi\">123</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 418542627,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706482117
    },
    {
        "content": "<p>re: <code>(∃e, s = {e}) ↔ {e // s = {e}}</code>, that doesn't really work because the left side is a Prop and the right side is a Type</p>",
        "id": 418543852,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706483518
    },
    {
        "content": "<p>you could do <code>(∃e, s = {e}) ↔ Nonempty {e // s = {e}}</code> but I have a feeling that doesn't express what you're trying to express</p>",
        "id": 418544217,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706483895
    },
    {
        "content": "<p>Maybe <code>(∃e, s = {e}) ↔ Inhabited {e // s = {e}}</code> is closer, as you can get the default value from an inhabited type? But I was thinking something like an isomorphism/bijection seems to act like a biconditional (At least superficially?), but allows for different types.</p>",
        "id": 418546428,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1706486393
    },
    {
        "content": "<p><code>Iff</code> for Sorts is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv#doc\">docs#Equiv</a></p>",
        "id": 418586172,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706517505
    },
    {
        "content": "<p>I suspect this proof would have been easier using <code>Subsingleton</code>. I think an equivalence between not empty Subsingleton types is trivial (It kinda like <code>P Q ⊢ P ↔ Q</code>). I'm still working my way through to understanding what <code>Quotient.recOnSubsingleton</code> is doing though.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">singletonEquiv</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">})</span> <span class=\"bp\">≃</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"bp\">//</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">}}</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">toFun</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">})</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"bp\">//</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">}}</span> <span class=\"o\">:=</span> <span class=\"n\">getFromSingleton</span>\n  <span class=\"k\">let</span> <span class=\"n\">invFun</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"bp\">//</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">}}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span><span class=\"n\">e</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨</span><span class=\"n\">e.val</span><span class=\"o\">,</span> <span class=\"n\">e.property</span><span class=\"o\">⟩</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">left_inv</span> <span class=\"o\">:</span> <span class=\"n\">Function.LeftInverse</span> <span class=\"n\">invFun</span> <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"n\">congrFun</span> <span class=\"n\">rfl</span>\n  <span class=\"k\">let</span> <span class=\"n\">right_inv</span> <span class=\"o\">:</span> <span class=\"n\">Function.RightInverse</span> <span class=\"n\">invFun</span> <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">e₁</span><span class=\"o\">,</span> <span class=\"n\">e₁_sng</span><span class=\"o\">⟩</span>\n    <span class=\"k\">have</span> <span class=\"n\">ep</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">e₁</span><span class=\"o\">,</span> <span class=\"n\">e₁_sng</span><span class=\"o\">⟩</span>\n    <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">e₂</span><span class=\"o\">,</span> <span class=\"n\">e₂_sng</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">toFun</span> <span class=\"n\">ep</span>\n    <span class=\"k\">have</span> <span class=\"n\">e₁_in</span> <span class=\"o\">:</span> <span class=\"n\">e₁</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp_all</span>\n    <span class=\"k\">have</span> <span class=\"n\">e₂_in</span> <span class=\"o\">:</span> <span class=\"n\">e₂</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp_all</span>\n    <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">∃!</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>  <span class=\"o\">(</span><span class=\"n\">Finset.singleton_iff_unique_mem</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">ep</span>\n    <span class=\"k\">have</span> <span class=\"n\">e_eq</span> <span class=\"o\">:</span> <span class=\"n\">e₁</span> <span class=\"bp\">=</span> <span class=\"n\">e₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">f</span> <span class=\"n\">e₁</span> <span class=\"n\">e₁_in</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">e₂</span> <span class=\"n\">e₂_in</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">SetCoe.ext</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"n\">e_eq.symm</span><span class=\"o\">)</span>\n\n  <span class=\"o\">⟨</span><span class=\"n\">toFun</span><span class=\"o\">,</span> <span class=\"n\">invFun</span><span class=\"o\">,</span> <span class=\"n\">left_inv</span><span class=\"o\">,</span> <span class=\"n\">right_inv</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 418668865,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1706544099
    }
]