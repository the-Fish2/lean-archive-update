[
    {
        "content": "<p>After having written …</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span> <span class=\"o\">(</span><span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span> <span class=\"o\">(</span><span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span> <span class=\"o\">(</span><span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>\n<p>… I assumed that at least one of …</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span> <span class=\"o\">(</span><span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">𝔽</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span> <span class=\"o\">(</span><span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">Field</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>\n<p>… would work as well, but I was wrong. Where did my reasoning go wrong?</p>\n<p>Is …</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span> <span class=\"o\">(</span><span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>\n<p>… the idiomatic way to formulate \"<code>Matrix (Fin n) (Fin n) 𝔽</code>\"?</p>",
        "id": 424442259,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1709410305
    },
    {
        "content": "<p>No, but it's the idiomatic way to formulate the ring structure on that type.</p>",
        "id": 424442533,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709410536
    },
    {
        "content": "<p>Yes, sorry I meant that. The idiomatic way to do \"<code>instance : Ring (Matrix (Fin n) (Fin n) 𝔽) := …</code>\".</p>",
        "id": 424442625,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1709410604
    },
    {
        "content": "<p>I'm trying to understand the reason to why it works with ℚ/ℝ/ℂ, but not with 𝔽.</p>",
        "id": 424442789,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1709410745
    },
    {
        "content": "<p>Is your <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">F</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{F}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">F</span></span></span></span> just a completely random type? How would you put a ring structure on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n\\times n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> matrices with coefficients in some completely random set?</p>",
        "id": 424442915,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709410867
    },
    {
        "content": "<p>Oh, no I meant <code>𝔽</code> as in field.</p>",
        "id": 424442945,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1709410902
    },
    {
        "content": "<p>But did you tell Lean that it was a field? You never mentioned it in your example</p>",
        "id": 424442966,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709410916
    },
    {
        "content": "<p>Oh, sorry I naïvely assumed that Mathlib defined 𝔽. I should have mentioned that I'm using Mathlib in the example above. Sorry about that!</p>",
        "id": 424443091,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1709410986
    },
    {
        "content": "<p>It worked when you told lean that the type was a field, and I would imagine that it would also work if you told lean that the type was a ring</p>",
        "id": 424443134,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709411042
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"683979\">Isak Colboubrani</span> <a href=\"#narrow/stream/113489-new-members/topic/Matrix.20.28Fin.20n.29.20.28Fin.20n.29.20.F0.9D.94.BD.3F/near/424443091\">said</a>:</p>\n<blockquote>\n<p>Oh, sorry I naïvely assumed that Mathlib defined 𝔽.</p>\n</blockquote>\n<p>Defined it as what?</p>",
        "id": 424443299,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709411188
    },
    {
        "content": "<p>I guess as <code>{F : Type*} [Field F]</code></p>",
        "id": 424443340,
        "sender_full_name": "Julian Berman",
        "timestamp": 1709411231
    },
    {
        "content": "<p>Which doesn't seem like the weirdest thing to think to me, but yeah Mathlib doesn't do that for you.</p>",
        "id": 424443377,
        "sender_full_name": "Julian Berman",
        "timestamp": 1709411247
    },
    {
        "content": "<p>I think it's important to realize that to Lean, that isn't a \"definition\", it's an <em>assumption</em>. You're not defining 𝔽 to be a random field, you're assuming it's an unspecified one.</p>",
        "id": 424443497,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709411307
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">Ring</span> <span class=\"o\">(</span><span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"c1\">-- Matrix.instRing</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Matrix.instRing</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Matrix.instRing.{u_3, v} {n : Type u_3} {α : Type v} [inst✝ : Fintype n]</span>\n<span class=\"cm\">    [inst✝¹ : DecidableEq n] [inst✝² : Ring α] :</span>\n<span class=\"cm\">    Ring (Matrix n n α)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>So indeed Lean just wants the input type to be a ring (or as Eric says, more precisely, Lean wants a type and a ring structure on the type, and then typeclass inference will automatically put a ring structure on the matrix type over that type)</p>",
        "id": 424443765,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709411617
    },
    {
        "content": "<p>Sorry about the assumption vs definition mix-up.</p>\n<p>I naïvely assumed that …</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n<span class=\"c1\">-- variable {𝔽 : Type*} [Field 𝔽]</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span> <span class=\"o\">(</span><span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span> <span class=\"o\">(</span><span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span> <span class=\"o\">(</span><span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span> <span class=\"o\">(</span><span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">𝔽</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>\n<p>…  would work without uncommenting <code>-- variable {𝔽 : Type*} [Field 𝔽]</code>).</p>",
        "id": 424443824,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1709411651
    },
    {
        "content": "<p>Maybe I'm misunderstanding the source of the confusion myself, but I understood the question to be \"mathlib defines what \\bbR is because everyone uses that for the reals, so I assumed it does that for F because everyone uses that to mean some arbitrary field.\"</p>",
        "id": 424443837,
        "sender_full_name": "Julian Berman",
        "timestamp": 1709411682
    },
    {
        "content": "<p>And the answer is \"it just doesn't do that for random stuff that arent' concrete objects\".</p>",
        "id": 424443851,
        "sender_full_name": "Julian Berman",
        "timestamp": 1709411696
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8556em;vertical-align:-0.1667em;\"></span><span class=\"mord mathbb\">Q</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> are all notation for explicit concrete types, so that's quite different to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">F</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{F}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">F</span></span></span></span>.</p>",
        "id": 424443860,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709411702
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/stream/113489-new-members/topic/Matrix.20.28Fin.20n.29.20.28Fin.20n.29.20.F0.9D.94.BD.3F/near/424443851\">said</a>:</p>\n<blockquote>\n<p>And the answer is \"it just doesn't do that for random stuff that arent' concrete objects\".</p>\n</blockquote>\n<p>More strongly, \"it can't possibly do that because that's not how definitions work in Lean\"</p>",
        "id": 424444006,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709411803
    },
    {
        "content": "<p>Obviously mathlib could contain <code>def 𝔽 := ℝ</code> or something, but that's not what is meant by \"some arbitrary field\"!</p>",
        "id": 424444054,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709411855
    },
    {
        "content": "<p>I'm sure it's me who doesn't know things. But why not? None of the magic declaration-making things could be coaxed into making that work? Such that the first time you reference some name in a namespace it adds a type and an instance to the environment scoped to the namespace?</p>",
        "id": 424444858,
        "sender_full_name": "Julian Berman",
        "timestamp": 1709412624
    },
    {
        "content": "<p>Mathlib probably <em>could</em> auto-add a <code>variables</code> command for you</p>",
        "id": 424445468,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709413198
    },
    {
        "content": "<p>Heck, autoImplicit already adds the variables themselves, its not too much of a stretch for it to be even more magic and guess what typeclass you meant</p>",
        "id": 424445550,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709413236
    },
    {
        "content": "<p>(but this would be even more of a disaster for beginners than <code>autoImplicit</code>)</p>",
        "id": 424445578,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709413275
    },
    {
        "content": "<p>Right, to me the answer is just \"you should learn Mathlib doesn't <em>quite</em> do this level of magic today\" (and I trust you that probably \"ever\") :)</p>",
        "id": 424445780,
        "sender_full_name": "Julian Berman",
        "timestamp": 1709413509
    },
    {
        "content": "<p>Perhaps more useful is to realize that 𝔽 would require lots of magic, but ℝ is very different and doesn't require any.</p>",
        "id": 424446598,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709414452
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"683979\">Isak Colboubrani</span> has marked this topic as resolved.</p>",
        "id": 424554446,
        "sender_full_name": "Notification Bot",
        "timestamp": 1709509898
    },
    {
        "content": "<p>Thanks! Now it makes sense!</p>\n<p>In the context of mathematics, my mental model (note: I'm not sure if my mental model has been correct!) has been that the expression a ∈ 𝔽 represents a concept at the same level of specificity as a ∈ ℂ, meaning that I viewed both 𝔽 and ℂ as sets with similar degrees of abstraction or concreteness.</p>\n<p>However, from a type-theoretic perspective, I recognize a distinction: 𝔽 can be seen as an abstract type, whereas ℂ is a concrete instantiation of that type, effectively implementing the field interface that 𝔽 represents.</p>",
        "id": 424721338,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1709577649
    }
]