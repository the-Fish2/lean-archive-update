[
    {
        "content": "<p>I was trying to provide a function. I then tried to use <code>cases</code> inside the proof, and it would not allow me. I feel like I am missing something very obvious. How does one extract <code>k</code> from <code>junk</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">junk</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">use</span> <span class=\"mi\">1</span>\n  <span class=\"n\">cases</span> <span class=\"n\">junk</span>\n</code></pre></div>",
        "id": 411639876,
        "sender_full_name": "André Hernández-Espiet (Rutgers)",
        "timestamp": 1704668564
    },
    {
        "content": "<p>You cannot do this. Proofs are irrelevant in Lean (to be more precise: Lean allows you to prove that any two proofs of the same proposition are the same and thus the actual value of the proof is irrelevant) the Lean compiler makes use of this by erasing all proof values at compile time so once you are outside of Prop and operate in run time relevant univeses (i.e. everything except Prop) you cannot do case distinctions etc. on a Prop.</p>\n<p>That said you can use the Type variant of exists, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subtype#doc\">docs#Subtype</a> (or also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PSigma#doc\">docs#PSigma</a>) to achieve basically what you want to do.</p>",
        "id": 411640185,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1704668834
    },
    {
        "content": "<p>Or you can use choice, if you do not need the result to be computable, and do not want the exact same k back.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">junk</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">use</span> <span class=\"mi\">1</span>\n  <span class=\"n\">choose</span> <span class=\"n\">n</span> <span class=\"n\">h</span> <span class=\"n\">using</span> <span class=\"n\">junk</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a</span>\n  <span class=\"n\">use</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 411640608,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1704669196
    },
    {
        "content": "<p>Very interesting! The choice alternative works fine. However, I am curious about how to implement these with <code>Subtype</code>, as I don´t think I have done this before.</p>",
        "id": 411642694,
        "sender_full_name": "André Hernández-Espiet (Rutgers)",
        "timestamp": 1704671108
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> There are exceptions -- you can do <code>cases</code> on an Eq for example; this is known as \"large subsingleton elimination\".</p>\n<p>A logical reason why you can't do cases on Exists, rather than a compiler engineering explanation, also starts with proof irrelevance; what it implies is that if <code>Exists.intro x p</code> and <code>Exists.intro y q</code> are proofs of the same existential, if you could do cases you'd be able to prove that <code>x = y</code>, but that can quickly lead to a contradiction. For example, both <code>Exists.mk 0 rfl</code> and <code>Exists.mk 1 rfl</code> are proofs of <code>∃ (k : ℕ), k = k</code>.</p>\n<p>In particular, it would let you define the following two axioms and prove False.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">Exists.extract</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">Exists.extract_mk</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Exists.extract</span> <span class=\"o\">(</span><span class=\"n\">Exists.intro</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.proofs</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n    <span class=\"k\">calc</span>\n      <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">Exists.extract</span> <span class=\"o\">(</span><span class=\"n\">Exists.intro</span> <span class=\"mi\">0</span> <span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Exists.extract_mk</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rfl</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n      <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">Exists.extract</span> <span class=\"o\">(</span><span class=\"n\">Exists.intro</span> <span class=\"mi\">1</span> <span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n      <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">Exists.extract_mk</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n</code></pre></div>",
        "id": 411643974,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704672159
    },
    {
        "content": "<p>Here are those axioms implemented using the \"bad casesOn\". The error you get from the <code>cases</code> tactic is reporting that it's not able to use <code>casesOn</code> due to the universe limitation in the <code>motive</code> argument.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Bad casesOn. Does large elimination (the motive is `Sort _` valued instead of `Prop valued)</span>\n<span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"kd\">]</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">Exists.casesOn'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">Exists</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Exists</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">intro</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">Exists.intro</span> <span class=\"n\">w</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">t</span>\n\n<span class=\"c1\">-- Computation rule for casesOn. This comes with the normal casesOn as a defeq.</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">Exists.casesOn'_intro</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">Exists</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">intro</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">Exists.intro</span> <span class=\"n\">w</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Exists.casesOn'</span> <span class=\"o\">(</span><span class=\"n\">Exists.intro</span> <span class=\"n\">w</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">intro</span> <span class=\"bp\">=</span> <span class=\"n\">intro</span> <span class=\"n\">w</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">Exists.extract</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Exists.casesOn'</span> <span class=\"n\">h</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Exists.extract_mk</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Exists.extract</span> <span class=\"o\">(</span><span class=\"n\">Exists.intro</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Exists.extract</span><span class=\"o\">,</span> <span class=\"n\">Exists.casesOn'_intro</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 411644543,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704672585
    }
]