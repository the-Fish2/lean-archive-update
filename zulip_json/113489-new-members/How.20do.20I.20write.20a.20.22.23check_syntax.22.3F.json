[
    {
        "content": "<p>Hi all,</p>\n<p>I'm taking far too long to do this myself, so I decided to ask...</p>\n<p>In the section \"<a href=\"https://leanprover-community.github.io/lean4-metaprogramming-book/main/05_syntax.html#free-form-syntax-declarations\">Free form syntax declarations</a>\" of the metaprogramming book there's an example - inside \"namespace Playground2\" - in which the command \"#check_failure ⊥ OR (⊤ AND ⊥)\" fails with the error \"elaboration function for 'Playground2.term_OR_' has not been implemented\". I only found that error message in two places in the source:</p>\n<p><a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Command.lean#L316\">here</a> in Lean/Elab/Command.lean, and<br>\n<a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Term.lean#L1069\">here</a> in Lean/Elab/Term.lean,</p>\n<p>but lots of things happen before that error message...</p>\n<p>How do I write a variant of #check or #check_failure - let me call that variant \"#check_syntax\" - that parses the rest of the line like #check or #check_failure, i.e., like <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Parser/Command.lean#L401\">this</a>,</p>\n<p>@[builtin_command_parser] def check := leading_parser \"#check \" &gt;&gt; termParser</p>\n<p>but that does not try to elaborate the result of \"termParser\"? I would like it to just print the resulting Syntax object...</p>",
        "id": 438919441,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1715827522
    },
    {
        "content": "<p>I usually use <code>#check `(my_custom_syntax)</code> for this</p>",
        "id": 438920180,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715827807
    },
    {
        "content": "<p>Neat! If I run this,</p>\n<p>#check `(42 + \"foo\")</p>\n<p>then the output is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">info</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.MonadRef.mkInfoFromRefPos</span>\n  <span class=\"k\">let</span> <span class=\"n\">scp</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.getCurrMacroScope</span>\n  <span class=\"k\">let</span> <span class=\"n\">mainModule</span> <span class=\"bp\">←</span> <span class=\"n\">Lean.getMainModule</span>\n  <span class=\"n\">pure</span>\n      <span class=\"o\">{</span>\n        <span class=\"n\">raw</span> <span class=\"o\">:=</span>\n          <span class=\"n\">Lean.Syntax.node3</span> <span class=\"n\">info</span> <span class=\"bp\">`</span><span class=\"n\">term_</span><span class=\"bp\">+</span><span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Lean.Syntax.node1</span> <span class=\"n\">info</span> <span class=\"bp\">`</span><span class=\"n\">num</span> <span class=\"o\">(</span><span class=\"n\">Lean.Syntax.atom</span> <span class=\"n\">info</span> <span class=\"s2\">\"42\"</span><span class=\"o\">))</span>\n            <span class=\"o\">(</span><span class=\"n\">Lean.Syntax.atom</span> <span class=\"n\">info</span> <span class=\"s2\">\"+\"</span><span class=\"o\">)</span>\n            <span class=\"o\">(</span><span class=\"n\">Lean.Syntax.node1</span> <span class=\"n\">info</span> <span class=\"bp\">`</span><span class=\"n\">str</span> <span class=\"o\">(</span><span class=\"n\">Lean.Syntax.atom</span> <span class=\"n\">info</span> <span class=\"s2\">\"</span><span class=\"se\">\\\"</span><span class=\"s2\">foo</span><span class=\"se\">\\\"</span><span class=\"s2\">\"</span><span class=\"o\">))</span> <span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">?</span><span class=\"n\">m.233</span> <span class=\"o\">(</span><span class=\"n\">Lean.TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">lsp</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 438921354,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1715828602
    },
    {
        "content": "<p>I would still like to learn how to write a new command that works as the first half of #check, but that helps!</p>",
        "id": 438921485,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1715828682
    },
    {
        "content": "<p>Here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">Playground2</span>\n\n<span class=\"n\">scoped</span> <span class=\"n\">syntax</span> <span class=\"s2\">\"⊥\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"c1\">-- ⊥ for false</span>\n<span class=\"n\">scoped</span> <span class=\"n\">syntax</span> <span class=\"s2\">\"⊤\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"c1\">-- ⊤ for true</span>\n<span class=\"n\">scoped</span> <span class=\"n\">syntax</span><span class=\"o\">:</span><span class=\"mi\">40</span> <span class=\"n\">term</span> <span class=\"s2\">\" OR \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">scoped</span> <span class=\"n\">syntax</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"n\">term</span> <span class=\"s2\">\" AND \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"#check_syntax \"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">Lean.logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{t}\"</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check_syntax</span> <span class=\"bp\">⊥</span> <span class=\"n\">OR</span> <span class=\"o\">(</span><span class=\"bp\">⊤</span> <span class=\"n\">AND</span> <span class=\"bp\">⊥</span><span class=\"o\">)</span>\n<span class=\"c1\">-- ⊥ OR (⊤ AND ⊥)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Playground2</span>\n</code></pre></div>",
        "id": 438921791,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715828900
    },
    {
        "content": "<p>It doesn't look like it's doing anything, but it's parsing the syntax (getting a <code>Syntax</code>) and then printing that <code>Syntax</code> back out.</p>",
        "id": 438921820,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715828938
    },
    {
        "content": "<p>If you change the logging line to <code>Lean.logInfo m!\"{repr t.raw}\"</code> you can see the structure of the <code>Syntax</code>.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>Lean.Syntax.node\n  (Lean.SourceInfo.none)\n  `Playground2.term_OR_\n  #[Lean.Syntax.node\n      (Lean.SourceInfo.none)\n      `Playground2.«term⊥»\n      #[Lean.Syntax.atom\n          (Lean.SourceInfo.original \"\".toSubstring { byteIdx := 946 } \" \".toSubstring { byteIdx := 949 })\n          \"⊥\"],\n    Lean.Syntax.atom\n      (Lean.SourceInfo.original \"\".toSubstring { byteIdx := 950 } \" \".toSubstring { byteIdx := 952 })\n      \"OR\",\n    Lean.Syntax.node\n      (Lean.SourceInfo.none)\n      `Lean.Parser.Term.paren\n      #[Lean.Syntax.atom\n          (Lean.SourceInfo.original \"\".toSubstring { byteIdx := 953 } \"\".toSubstring { byteIdx := 954 })\n          \"(\",\n        Lean.Syntax.node\n          (Lean.SourceInfo.none)\n          `Playground2.term_AND_\n          #[Lean.Syntax.node\n              (Lean.SourceInfo.none)\n              `Playground2.«term⊤»\n              #[Lean.Syntax.atom\n                  (Lean.SourceInfo.original \"\".toSubstring { byteIdx := 954 } \" \".toSubstring { byteIdx := 957 })\n                  \"⊤\"],\n            Lean.Syntax.atom\n              (Lean.SourceInfo.original \"\".toSubstring { byteIdx := 958 } \" \".toSubstring { byteIdx := 961 })\n              \"AND\",\n            Lean.Syntax.node\n              (Lean.SourceInfo.none)\n              `Playground2.«term⊥»\n              #[Lean.Syntax.atom\n                  (Lean.SourceInfo.original \"\".toSubstring { byteIdx := 962 } \"\".toSubstring { byteIdx := 965 })\n                  \"⊥\"]],\n        Lean.Syntax.atom\n          (Lean.SourceInfo.original\n            \"\".toSubstring\n            { byteIdx := 965 }\n            \"\\x0d\\n-- ⊥ OR (⊤ AND ⊥)\\x0d\\n\\x0d\\n\".toSubstring\n            { byteIdx := 966 })\n          \")\"]]\n</code></pre></div>\n</div></div>",
        "id": 438921944,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715829006
    },
    {
        "content": "<p>Fantastic! Many thanks! <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span><span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span><span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span> <br>\nIf anyone else is reading this, here is a version that is trivial to run:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Elab.Command</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Playground2</span>\n\n<span class=\"n\">scoped</span> <span class=\"n\">syntax</span> <span class=\"s2\">\"⊥\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">scoped</span> <span class=\"n\">syntax</span> <span class=\"s2\">\"⊤\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">scoped</span> <span class=\"n\">syntax</span><span class=\"o\">:</span><span class=\"mi\">40</span> <span class=\"n\">term</span> <span class=\"s2\">\" OR \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n<span class=\"n\">scoped</span> <span class=\"n\">syntax</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"n\">term</span> <span class=\"s2\">\" AND \"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"#check_syntax \"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"n\">Lean.logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{t}\"</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"#check_syntax \"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"n\">Lean.logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"{repr t.raw}\"</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check_syntax</span> <span class=\"bp\">⊥</span> <span class=\"n\">OR</span> <span class=\"o\">(</span><span class=\"bp\">⊤</span> <span class=\"n\">AND</span> <span class=\"bp\">⊥</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Playground2</span>\n</code></pre></div>\n<p>The definition of \"#check_syntax\" that holds is the last one - to change its behavior, reorder the \"elab\" lines.</p>",
        "id": 438953824,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1715843119
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 439159954,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1715927863
    }
]