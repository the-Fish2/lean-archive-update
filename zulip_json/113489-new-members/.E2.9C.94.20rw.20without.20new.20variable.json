[
    {
        "content": "<p>Hi, I'm trying to use <code>rw</code> to make the type of a variable more specific, but it seems to be creating a new variable with the rewritten value and leaving all references to the variable pointing to the old variable as a placeholder. Here's a simple example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Fin1_is_0</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">1</span><span class=\"o\">):</span> <span class=\"n\">x.val</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x.val</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">x</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Fin1_is_0</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>which gives the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">Fin1_is_0</span> <span class=\"n\">x</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">↑</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"bp\">✝</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>since the goal is now using <code>x✝ : Fin n</code> instead of <code>x : Fin 1</code>. Is there a way to do this kind of rewrite? Thanks!</p>",
        "id": 434248399,
        "sender_full_name": "Reed",
        "timestamp": 1713479306
    },
    {
        "content": "<p><code>subst h</code> will work in this situation</p>",
        "id": 434249475,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713479948
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"711164\">Reed</span> has marked this topic as resolved.</p>",
        "id": 434249630,
        "sender_full_name": "Notification Bot",
        "timestamp": 1713480027
    },
    {
        "content": "<p>Thanks! I didn't know about the <code>subst</code> tactic. As a follow up question, is there a way to use <code>subst</code> or a different tactic in more complex scenarios such as this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Fin1_is_0</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">1</span><span class=\"o\">):</span> <span class=\"n\">x.val</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Struct</span> <span class=\"n\">where</span>\n  <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">struct</span> <span class=\"o\">:</span> <span class=\"n\">Struct</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">struct.n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">struct.n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x.val</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">subst</span> <span class=\"n\">h</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Fin1_is_0</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>which gives the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">tactic</span> <span class=\"bp\">'</span><span class=\"n\">subst'</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">invalid</span> <span class=\"n\">equality</span> <span class=\"n\">proof</span><span class=\"o\">,</span> <span class=\"n\">it</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">form</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">or</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"n\">struct.n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 434251858,
        "sender_full_name": "Reed",
        "timestamp": 1713481347
    },
    {
        "content": "<p>No, <code>subst</code> will only work if one of the sides of the equality is a variable (that doesn't occur in the other side of the equality), and it will replace that variable by the other side, and then remove the variable and equality from the context.</p>",
        "id": 434253025,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1713482056
    },
    {
        "content": "<p>Sometimes you just need to do <code>cases</code> on enough things to get enough variables.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">struct</span> <span class=\"o\">:</span> <span class=\"n\">Struct</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">struct.n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">struct.n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x.val</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">struct</span>\n  <span class=\"n\">subst</span> <span class=\"n\">h</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Fin1_is_0</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 434253516,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713482386
    },
    {
        "content": "<p>(You can do <code>cases h</code> here -- <code>subst h</code> is sort of a more limited version of <code>cases</code>)</p>",
        "id": 434253592,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713482416
    },
    {
        "content": "<p>I think that is a consequence of this MWE. In general you cannot get a variable on one side.</p>",
        "id": 434254082,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1713482735
    },
    {
        "content": "<p>The library is quite weak on rewriting within dependent functions. You can do it manually:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fin.Basic</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Fin1_is_0</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">1</span><span class=\"o\">):</span> <span class=\"n\">x.val</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Fin.coe_fin_one</span><span class=\"o\">]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Struct</span> <span class=\"n\">where</span>\n  <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">something</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b'</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">a'</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">b</span> <span class=\"n\">b'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a'</span> <span class=\"n\">b'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">subst</span> <span class=\"n\">ha</span><span class=\"bp\">;</span> <span class=\"n\">subst</span> <span class=\"n\">hb</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">struct</span> <span class=\"o\">:</span> <span class=\"n\">Struct</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">struct.n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">struct.n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x.val</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"n\">something</span> <span class=\"bp\">@</span><span class=\"n\">Fin.val</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">cast_heq</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">Fin</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">trans</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Fin1_is_0</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 434254106,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1713482761
    },
    {
        "content": "<p>This Lean 2 file has a bunch of variants of congr-lemmas for dependent functions (which we needed in the HoTT library): <a href=\"https://github.com/leanprover/lean2/blob/master/hott/arity.hlean\">https://github.com/leanprover/lean2/blob/master/hott/arity.hlean</a></p>",
        "id": 434254188,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1713482808
    },
    {
        "content": "<p><code>something</code> corresponds to <code>apdt011</code>.</p>",
        "id": 434254212,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1713482825
    },
    {
        "content": "<p>It would be nice to have some kind of <code>dependent_rw</code> (and <code>dependent_simp</code>) tactic that would just insert casts whenever the usual <code>rw</code> gives the \"motive is not  type-correct error\". So something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">struct</span> <span class=\"o\">:</span> <span class=\"n\">Struct</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">struct.n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">struct.n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x.val</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">(</span><span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">Fin</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"kd\">by</span> <span class=\"c\">/-</span><span class=\"cm\"> or (h ▸ x).val = 0 -/</span>\n    <span class=\"gr\">sorry</span> <span class=\"c\">/-</span><span class=\"cm\"> dependent_rw [h]; exact this -/</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Fin1_is_0</span>\n</code></pre></div>\n<p>This tactic might have to generate lemmas like <code>apdt011</code>, <code>apdt0111</code>, <code>apdt01111</code>, ... from the linked file above on the fly, depending on how many dependent arguments the function has.</p>",
        "id": 434255005,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1713483442
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> Congr lemmas for dependent functions is what that congruence generator I wrote is for:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">something</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b'</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">a'</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">b</span> <span class=\"n\">b'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a'</span> <span class=\"n\">b'</span> <span class=\"o\">:=</span> <span class=\"n\">congr</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">$</span><span class=\"n\">ha</span> <span class=\"bp\">$</span><span class=\"n\">hb</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 434256806,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713484778
    },
    {
        "content": "<p>Using <code>congr(...)</code> the <code>example</code> with <code>something</code> looks like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">struct</span> <span class=\"o\">:</span> <span class=\"n\">Struct</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">struct.n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">struct.n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x.val</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">cast_heq</span> <span class=\"n\">congr</span><span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"bp\">$</span><span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">x</span>\n  <span class=\"n\">exact</span> <span class=\"n\">congr</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Fin.val</span> <span class=\"bp\">$</span><span class=\"n\">h</span> <span class=\"bp\">$</span><span class=\"n\">this.symm</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">Fin1_is_0</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 434257473,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713485200
    },
    {
        "content": "<p>There's also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.cast#doc\">docs#Fin.cast</a>, which is a more specialized rewrite that has nice properties.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">struct</span> <span class=\"o\">:</span> <span class=\"n\">Struct</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">struct.n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">struct.n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x.val</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"k\">calc</span> <span class=\"n\">x.val</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">x.cast</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n       <span class=\"n\">_</span>     <span class=\"bp\">=</span> <span class=\"mi\">0</span>              <span class=\"o\">:=</span> <span class=\"n\">Fin1_is_0</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 434258137,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713485687
    },
    {
        "content": "<p>Nice!</p>",
        "id": 434294139,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1713508238
    }
]