[
    {
        "content": "<p>Hello, I'm trying to get a bit into the formal verification aspects of Lean4 and tried my hand at implementing ordered lists and I have two questions.</p>\n<p>1.)<br>\nI'm struggling to prove the <code>sorry</code> in <code>oinsert</code>. Here is a MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">IsOrdered</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">List.Pairwise</span> <span class=\"n\">LE.le</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">OrderedList</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n  <span class=\"n\">ordered</span> <span class=\"o\">:</span> <span class=\"n\">IsOrdered</span> <span class=\"n\">val</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">:</span> <span class=\"n\">Membership</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">OrderedList</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">xs.val</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">cons_le_is_ordered</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">IsOrdered</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hle</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">xs</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">IsOrdered</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">IsOrdered</span><span class=\"o\">,</span> <span class=\"n\">List.pairwise_cons</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">hle</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- Prepend an element to the list, given it's smaller than all elements in the list</span>\n<span class=\"kd\">def</span> <span class=\"n\">ocons</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">OrderedList</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hle</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">xs</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">OrderedList</span> <span class=\"n\">α</span>\n<span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">xs.val</span><span class=\"o\">,</span> <span class=\"n\">cons_le_is_ordered</span> <span class=\"n\">xs.ordered</span> <span class=\"n\">hle</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- Insert an element into the list at the right spot</span>\n<span class=\"kd\">def</span> <span class=\"n\">oinsert</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">OrderedList</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">hp.le</span><span class=\"o\">]</span>\n  <span class=\"o\">:</span> <span class=\"n\">OrderedList</span> <span class=\"n\">α</span>\n<span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨[],</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨[</span><span class=\"n\">a</span><span class=\"o\">],</span> <span class=\"n\">List.pairwise_singleton</span> <span class=\"n\">LE.le</span> <span class=\"n\">a</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">ordered</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">if</span> <span class=\"n\">hle</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span>\n      <span class=\"k\">then</span> <span class=\"n\">ocons</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"n\">hle</span>\n      <span class=\"k\">else</span> <span class=\"n\">ocons</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">oinsert</span> <span class=\"n\">a</span> <span class=\"o\">⟨</span><span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">List.Pairwise.of_cons</span> <span class=\"n\">ordered</span><span class=\"o\">⟩)</span>\n        <span class=\"o\">(</span><span class=\"gr\">sorry</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Sorry if this MWE is a bit long. I guess, in general, it's not clear to me how to prove some property when doing a recursive call. I wasn't able to use <code>rw [oinsert]</code> as the termination checker complained. Any pointers would be much appreciated, thanks :)</p>\n<p>2.)<br>\nOn another note, is there a construction of <code>OrderedList</code> using <code>inductive</code>? I tried my hand at it using mutual recursion (inspired by <a href=\"https://gist.github.com/aristidb/1684202#file-sortedlist-agda-L26\">this gist</a>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">OrderedList'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">onil'</span> <span class=\"o\">:</span> <span class=\"n\">OrderedList'</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">ocons'</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">OrderedList'</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">less</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">→</span> <span class=\"n\">OrderedList'</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">less</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">OrderedList'</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">xs</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">OrderedList'.onil'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n  <span class=\"bp\">|</span> <span class=\"n\">OrderedList'.ocons'</span> <span class=\"n\">y</span> <span class=\"n\">ys</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>But I'm getting <code>invalid mutual block</code>... Has anyone implemented something similar? I saw the other post about <code>OrderedLists</code>on here already, but it's the responses are not entirely satisfying. Also, I realize this construction is not equivalent to the one above, as transitivity is not ensured here, but I'm fine with that.</p>\n<p>Thanks!</p>",
        "id": 409718233,
        "sender_full_name": "Aron Erben",
        "timestamp": 1703338822
    },
    {
        "content": "<p>Interleaving algorithms and proofs, while doable, can be tricky. Something you could consider is splitting it into three parts: (1) write the insert function for List with no additional assumptions, (2) prove that if you start with an ordered list you get an ordered list, and (3) define the OrderedList version from these two ingredients.</p>",
        "id": 409723436,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703343600
    },
    {
        "content": "<p>Re 2, I'm not sure about the mutual block portion, but one reason to not make an inductive type for OrderedList is that (1) it prevents you from splitting up algorithms and proof and (2) there's more of a barrier for re-using anything already created for List.</p>",
        "id": 409723845,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703343798
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  Ah thanks, I'll give that a shot! So, in general, for formal verification, it is advisable to do this separation of algorithms and proofs?</p>",
        "id": 409725008,
        "sender_full_name": "Aron Erben",
        "timestamp": 1703344678
    },
    {
        "content": "<p>I'm not sure I'd raise what I said from general thoughts to general advice -- maybe the advice is \"if interleaving is hard, try not interleaving\". Also, \"if not interleaving is hard, try interleaving\" :-)</p>\n<p>The representation you have, as a structure of a List and a proof, is good because it gives you flexibility to try both.</p>",
        "id": 409725523,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703345036
    },
    {
        "content": "<p>By the way, I just spent some time trying to prove your <code>oinsert</code> is correct, and it seems like you need additional conditions for it to work. What if <code>a</code> is incomparable with everything in the list?</p>",
        "id": 409725768,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703345158
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/OrderedList.20questions/near/409725523\">said</a>:</p>\n<blockquote>\n<p>I'm not sure I'd raise what I said from general thoughts to general advice -- maybe the advice is \"if interleaving is hard, try not interleaving\". Also, \"if not interleaving is hard, try interleaving\" :-)</p>\n<p>The representation you have, as a structure of a List and a proof, is good because it gives you flexibility to try both.</p>\n</blockquote>\n<p>I see, I'm looking for some metrics or patterns to recognize when to apply what method, but I guess that comes with enough practice. I'll use the <code>structure</code> style for now for the flexibility you mentioned.</p>",
        "id": 409728933,
        "sender_full_name": "Aron Erben",
        "timestamp": 1703347413
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/OrderedList.20questions/near/409725768\">said</a>:</p>\n<blockquote>\n<p>By the way, I just spent some time trying to prove your <code>oinsert</code> is correct, and it seems like you need additional conditions for it to work. What if <code>a</code> is incomparable with everything in the list?</p>\n</blockquote>\n<p>Hmmm, I had not thought of that, so I guess I need some totality constraint on that... Maybe a <code>IsTotal</code>constraint</p>",
        "id": 409729052,
        "sender_full_name": "Aron Erben",
        "timestamp": 1703347494
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Turns out I had to add a <code>LinearOrder</code> constraint even for the approach with splitting up the algo and the proof. I needed <code>not_le</code> and did not find a way around it. But it works so far, so I'm resolving this. Thanks again :)</p>",
        "id": 410156042,
        "sender_full_name": "Aron Erben",
        "timestamp": 1703685058
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"460930\">Aron Erben</span> has marked this topic as resolved.</p>",
        "id": 410156070,
        "sender_full_name": "Notification Bot",
        "timestamp": 1703685072
    }
]