[
    {
        "content": "<p>What's the easiest tactic to turn something of type succ (n-1) into n where n is a natural number and the hypothesis n&gt;0 is in the proof environment? I would prefer just a single tactic rather that some sequence of cancellations etc.</p>",
        "id": 409691850,
        "sender_full_name": "Andy Jiang",
        "timestamp": 1703314972
    },
    {
        "content": "<p>Maybe <code>simp [n_ne_zero]</code> will do it? It seems pretty specific to get its own tactic</p>",
        "id": 409692692,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1703315831
    },
    {
        "content": "<p>Hmmm, I guess I have a more generic question actually. do these tactics only work inside like a by ... clause? Like if I am applying some function inline, and the second argument of the function has some type, can I use simp to get that object? In other words is it possible to apply a function f to x and specify x with a tactic? or do I have to have some different environment like a by clause to use tactics. Hope this question makes sense. Like I would like a way to conjure an element of some type by saying the type and saying by some tactic we should have this element but inline if possible.</p>",
        "id": 409693346,
        "sender_full_name": "Andy Jiang",
        "timestamp": 1703316476
    },
    {
        "content": "<p><code>by tac</code> is a term, you can put it anywhere a term is expected</p>",
        "id": 409693811,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703316934
    },
    {
        "content": "<p>Thank you guys. I think now I understand it conceptually better. Although I am still struggling at something very basic I think. I tried using simp but it has failed. The precise situation I'm in is described by the error message below. Sorry for the troubles but I can't seem to find a tactic that can resolve this situation easily. simp was not really working for some reason. Can you guys confirm that simp is supposed to be able to work in this situation?</p>\n<p>unsolved goals<br>\nn : ℕ<br>\nh✝ : length (sorted_divisors n) &gt; 0<br>\ndivs : List ℕ := sorted_divisors n<br>\ni : Fin (length divs - 1)<br>\nh : ↑i &lt; length divs - 1 := sorryAx (↑i &lt; length divs - 1) true<br>\n⊢ ↑i + 1 &lt; length (sorted_divisors n)Lean 4</p>",
        "id": 409694275,
        "sender_full_name": "Andy Jiang",
        "timestamp": 1703317407
    },
    {
        "content": "<p>no, that's not a goal for simp</p>",
        "id": 409694805,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703317908
    },
    {
        "content": "<p>the recently landed <code>omega</code> should be able to handle it, maybe <code>linarith</code> if it's not available yet, and if that doesn't work you just have to use the theorem which will be named something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.add_lt_of_lt_sub#doc\">docs#Nat.add_lt_of_lt_sub</a></p>",
        "id": 409694902,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703317990
    },
    {
        "content": "<p>aha so simp is used to simplify like each side of an inequality but never across the inequality sign i'm taking as the takeaway?</p>",
        "id": 409695182,
        "sender_full_name": "Andy Jiang",
        "timestamp": 1703318243
    },
    {
        "content": "<p>no it can simplify inequalities but it mostly only applies eq and iff statements. If you use the iff version of add_lt_of_lt_sub then simp will be able to rewrite the goal</p>",
        "id": 409695272,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703318330
    },
    {
        "content": "<p>but it won't be a simp lemma by default because the result isn't really simpler</p>",
        "id": 409695288,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703318347
    },
    {
        "content": "<p>ah ok thanks! And omega worked!</p>",
        "id": 409695645,
        "sender_full_name": "Andy Jiang",
        "timestamp": 1703318554
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"662620\">Andy Jiang</span> <a href=\"#narrow/stream/113489-new-members/topic/Very.20Basic.20question/near/409695645\">said</a>:</p>\n<blockquote>\n<p>ah ok thanks! And omega worked!</p>\n</blockquote>\n<p>Perhaps moot now that <code>omega</code> exists, but <code>zify</code> followed by <code>ring</code> (or <code>abel</code>) tends to work pretty well also, e.g., </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat.succ</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">zify</span> <span class=\"o\">[</span><span class=\"n\">hn</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">ring</span>\n</code></pre></div>",
        "id": 409758013,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703373899
    },
    {
        "content": "<p>FYI, for the specific case of <code>Nat.succ (n - 1) = n</code>, you can also just do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat.succ</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.succ_pred</span> <span class=\"n\">hn.ne'</span>\n</code></pre></div>\n<p>(sorry if this is obvious)</p>",
        "id": 409758432,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1703374356
    }
]