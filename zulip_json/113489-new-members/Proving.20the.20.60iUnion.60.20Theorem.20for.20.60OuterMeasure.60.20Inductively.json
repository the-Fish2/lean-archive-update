[
    {
        "content": "<p>Hello everyone,</p>\n<p>I'm currently delving into measure theory within Lean and am tackling the <code>iUnion</code> theorem for an <code>OuterMeasure</code> structure. In Mathlib, there's already an elegant one-liner proof leveraging <code>rel_iSup_tsum</code>, but I'm curious about the possibility of an inductive approach. Here's the context:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.PiSystem</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span> <span class=\"n\">ENNReal</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">OuterMeasure</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">measureOf</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span>\n  <span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"n\">measureOf</span> <span class=\"bp\">∅</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n  <span class=\"n\">mono</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">s₁</span> <span class=\"n\">s₂</span><span class=\"o\">},</span> <span class=\"n\">s₁</span> <span class=\"bp\">⊆</span> <span class=\"n\">s₂</span> <span class=\"bp\">→</span> <span class=\"n\">measureOf</span> <span class=\"n\">s₁</span> <span class=\"bp\">≤</span> <span class=\"n\">measureOf</span> <span class=\"n\">s₂</span>\n  <span class=\"n\">iUnion_nat</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">measureOf</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"bp\">∑'</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">measureOf</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instCoeFun</span> <span class=\"o\">:</span> <span class=\"n\">CoeFun</span> <span class=\"o\">(</span><span class=\"n\">OuterMeasure</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">m.measureOf</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">iUnion</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">OuterMeasure</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Countable</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"bp\">∑'</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rel_iSup_tsum</span> <span class=\"n\">m</span> <span class=\"n\">m.empty</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">≤</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"n\">m.iUnion_nat</span> <span class=\"n\">s</span>\n</code></pre></div>\n<p>Before tackling this, I managed to prove the <code>union</code> theorem for two sets in a more traditional, textbook-like manner:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">union</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">OuterMeasure</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s₁</span> <span class=\"n\">s₂</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">s₁</span> <span class=\"bp\">∪</span> <span class=\"n\">s₂</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">m</span> <span class=\"n\">s₁</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"n\">s₂</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Is there an established inductive principle for countable types in Lean that could facilitate such a proof building upon the <code>union</code> theorem?</p>",
        "id": 425260142,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1709803590
    },
    {
        "content": "<p>It might be instructive to go through the proof within <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=rel_iSup_tsum#doc\">docs#rel_iSup_tsum</a></p>",
        "id": 425266884,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709805686
    },
    {
        "content": "<p>I suppose the proof might be inductive in the broadest sense of the word, but I was kinda hoping one could reason about countable types using their cardinality - if that makes sense. Something along the line of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">theorem</span> <span class=\"n\">ifUnion</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">OuterMeasure</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">φ</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">≤</span>  <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">,</span> <span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"bp\">∑</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"n\">Finset.range</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">φ</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Nat.lt_succ</span><span class=\"o\">]</span>\n    <span class=\"n\">induction'</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">NH</span>\n    <span class=\"n\">simp</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">Finset.sum_range_succ</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">biUnion_lt_succ</span><span class=\"o\">]</span>\n    <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">φ.union</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">add_le_add</span> <span class=\"n\">NH</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 425293228,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1709814879
    }
]