[
    {
        "content": "<p>Hi all...</p>\n<p>we have this in <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Expr.lean\">Expr.lean#L292</a>,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">expressions</span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">This</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">used</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">kernel</span><span class=\"w\"> </span><span class=\"n\">and</span>\n<span class=\"n\">elaborator</span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">However</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">expressions</span><span class=\"w\"> </span><span class=\"n\">sent</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">kernel</span><span class=\"w\"> </span><span class=\"n\">should</span><span class=\"w\"> </span><span class=\"n\">not</span>\n<span class=\"n\">contain</span><span class=\"w\"> </span><span class=\"n\">metavariables</span><span class=\"bp\">.</span>\n</code></pre></div>",
        "id": 446515142,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1719202967
    },
    {
        "content": "<p>and \"<a href=\"https://github.com/digama0/lean-type-theory/releases\">The Type Theory of Lean</a>\" - Mario Carneiro's thesis - only describes the type theory of the kernel...</p>\n<p>The \"non-kernel\" type theory of Lean has lots of other features - like metavariables, optional parameters, typeclasses, etc etc etc.</p>\n<p>Where can I read more about how they are formalized?</p>",
        "id": 446515278,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1719203043
    },
    {
        "content": "<p>I am trying to read the four main books about Lean - FPiL, TPiL, Metaprogramming in Lean4, and the Lean Manual - and there are many places in which the code only makes sense to me when I do \"type inference by hand\", by copying an expression on a sheet of paper, drawing underbraces under its subexpressions, and then writing the type of each subexpression...</p>\n<p>The problem is that my algorithm and my notation for this \"type inference by hand\" are improvised, and very messy - and I think that if I try to read papers on, say, optional parameters, they will give me lots of useful ideas.</p>\n<p>Thanks in advance!</p>",
        "id": 446515333,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1719203080
    },
    {
        "content": "<p>Maybe I am misunderstanding what you are asking, but don't you get \"current expected type information\" by moving around the syntax with the cursors and looking at the infoview?</p>",
        "id": 446524554,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1719209161
    },
    {
        "content": "<p>These algorithms are not fully formalized. All of them contain lots of heuristics that were added over time due to people having issues. Note that these algorithms are also continuously evolving, a paper that explained the implementation of definitional equality a year back would be outdated by now.</p>\n<p>For the basic ideas you'll definitely find some papers floating around still. However if you really want to know what's going on, reading the Lean compiler itself is pretty much the only resource for the precise behavior of the Lean compiler.</p>\n<p>All that being said I don't think there is a reason to understand these algorithms to get a feeling for how Lean does type inference. You just write more and more Lean code, look how it works and eventually get a feeling for how things work. For example if you were to read the tabled type class resolution paper that describes the underlying algorithm for type class synthesis, I don't think you'd get a better feeling for how to work with type classes, that comes from experience.</p>",
        "id": 446529673,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719211029
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span>,</p>\n<p>I do that all the time, and sometimes I write several similar \"#check\"s one below the other to compare their results, like here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">unusedVariables</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myfst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">×</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">myfst</span><span class=\"w\">                          </span><span class=\"o\">(</span><span class=\"s2\">\"a\"</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">myfst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s2\">\"a\"</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">myfst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\">            </span><span class=\"o\">(</span><span class=\"s2\">\"a\"</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">myfst</span><span class=\"w\">               </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s2\">\"a\"</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">myfst</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">myfst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">myfst</span><span class=\"w\">               </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">myfst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">myfst</span><span class=\"w\">                                                   </span><span class=\"o\">(</span><span class=\"s2\">\"a\"</span><span class=\"w\">     </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\">    </span><span class=\"o\">)</span>\n<span class=\"c1\">--    -------------------------------  -----------             --------  -----</span>\n<span class=\"c1\">--    : {A:Type} → {B:Type} → A×B → A  (A:=String)             : String  : Nat</span>\n<span class=\"c1\">--    --------------------------------------------  --------  -----------------</span>\n<span class=\"c1\">--    : {B:Type} → String×B → String                (B:=Nat)  : String×Nat</span>\n<span class=\"c1\">--    ------------------------------------------------------</span>\n<span class=\"c1\">--    : String×Nat → String</span>\n<span class=\"c1\">--    -------------------------------------------------------------------------</span>\n<span class=\"c1\">--    : String</span>\n</code></pre></div>",
        "id": 446888553,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1719323202
    },
    {
        "content": "<p>Let me try to explain my question in a better way.</p>\n<p>In the middle of the pandemic I tried to learn Haskell for the nth time - that time using Hutton's book, because a friend was TAing a course that used it. But I got stuck at the chapter with monads - I had the impression that the author expected that the readers would be able to do all the type checkings and type inferences by sight, and I couldn't do that, my mental buffer was too small...</p>",
        "id": 446888895,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1719323263
    },
    {
        "content": "<p>I also tried to infer the types by drawing underbrace diagrams by hand. My diagrams were like the one below - they used several conventions that were quite bad, and I was not happy with them.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">m1</span><span class=\"w\">     </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\">   </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">m2</span><span class=\"w\">     </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\">   </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\">                 </span><span class=\"n\">x1</span><span class=\"w\">   </span><span class=\"n\">x2</span>\n<span class=\"c1\">------       ----    ------       ----    ----------------  ---- ----</span>\n<span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\">       </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\">    </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\">       </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\">    </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\">  </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">                                          </span><span class=\"c1\">----------------------</span>\n<span class=\"w\">                                          </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">                                          </span><span class=\"c1\">---------------------------</span>\n<span class=\"w\">                                          </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">                                </span><span class=\"c1\">-------------------------------------</span>\n<span class=\"w\">                                </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">                     </span><span class=\"c1\">------------------------------------------------</span>\n<span class=\"w\">                     </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">           </span><span class=\"c1\">----------------------------------------------------------</span>\n<span class=\"w\">           </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"c1\">---------------------------------------------------------------------</span>\n<span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">c</span>\n</code></pre></div>",
        "id": 446889973,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1719323450
    },
    {
        "content": "<p>You can hover over Lean terms to figure out their type or put a <code>sorry</code> anywhere (it works for terms also, not only proofs) and if the type checker already has enough information to figure out the type of the term it expects at that point hovering the <code>sorry</code> will give you all of the type information as well.</p>\n<p>Note that in particular with monads you do not necessarily need to understand the desugaring to <code>&gt;&gt;=</code> to work with them. You can purely work in <code>do</code> notation and just keep in mind that <code>&lt;-</code> does some sort of extra thing depending on the moand you are in:</p>\n<ul>\n<li>For <code>IO</code> it indicates that an interaction with the outside world might be happening at that point. In particular there might be an error being thrown that exits you early from the computation</li>\n<li>For <code>Option</code> and <code>Except</code> you similarly have the <code>none</code>/<code>error</code> check with an early exit</li>\n<li>For <code>ReaderM</code> you pass in an additional argument implicitly that the function can use as a context to derive information from, often used for implementing things like global program configurations</li>\n<li><code>StateM</code> both passes in some state and fetches the updated state from the computation to use it when it passes in a state for the next time.</li>\n</ul>\n<p>The desugaring into <code>&gt;&gt;=</code> and <code>pure</code> is really more of an interesting thing than one that you need to know to use a language that does monadic programming. For example the Rust language has the <code>?</code> operator which mimicks the <code>Option</code> and <code>Except</code> monad but the majority of Rustaceans has no clue what a monad is at all.</p>\n<p>If you want to learn about the details of monadic programming in Lean I suggest reading <a href=\"https://lean-lang.org/functional_programming_in_lean/monads.html\">https://lean-lang.org/functional_programming_in_lean/monads.html</a> chapter 5-7.</p>",
        "id": 446892330,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719323879
    },
    {
        "content": "<p>In regards to meta-variables, elaboration etc. the Meta-programming book explains the mechanisms.  However, you do need to understand how monads work, so if you don't, Henrik's suggestion is the best place to start.</p>",
        "id": 446894212,
        "sender_full_name": "Number Eighteen",
        "timestamp": 1719324276
    },
    {
        "content": "<p>Thanks for the pointer to <code>sorry</code>! I was using only the underbrace, I'll try the tricks with <code>sorry</code> soon...</p>",
        "id": 446894483,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1719324347
    },
    {
        "content": "<p>More on the long story: a few days ago I announced - in \"<a href=\"#narrow/stream/113489-new-members/topic/Animating.20type.20inferences\">Animating type inferences</a>\" - that I had found a nice way to draw animated underbrace diagrams for type inferences by starting with a a diagram in ascii art like the ones above. There's some information about that in <a href=\"http://anggtwu.net/eev-lean4.html#animating\">this section of my page on Lean</a> - but I need to update that to show how to make the tool use <code>\\textsf{...}</code> by default.</p>",
        "id": 446895265,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1719324541
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"701522\">Number Eighteen</span> <a href=\"#narrow/stream/113489-new-members/topic/References.20on.20the.20.28non-kernel!.29.20type.20theory.20of.20Lean.3F/near/446894212\">said</a>:</p>\n<blockquote>\n<p>In regards to meta-variables, elaboration etc. the Meta-programming book explains the mechanisms.  However, you do need to understand how monads work, so if you don't, Henrik's suggestion is the best place to start.</p>\n</blockquote>\n<p>The meta programming book doesn't really explain how the underlying algorihtms work in detail, it gives a slightly verbose API reference with examples and for a few things also some general explanations for the strategy of some algorithms.</p>",
        "id": 446896887,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719324928
    },
    {
        "content": "<p>I found the chapters on monads of FPiL and the material on the metaprogramming book <em>very</em> hard, and that may be because that they have \"missing diagrams\" in <a href=\"http://anggtwu.net/math-b.html#2022-md\">this sense</a> (<a href=\"https://arxiv.org/pdf/2204.10630\">ArXiV</a>)...</p>",
        "id": 446897363,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1719325039
    },
    {
        "content": "<p>There is also no reason to read or know any category theory to understand monads as they are used in functional programming. I would not expect a beginner explanation of FP monads to ever have a category theory diagram unless it is explicitly targeting people that know category theory already.</p>",
        "id": 446898223,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719325230
    },
    {
        "content": "<p>And I would expect even less category theory related material in the meta programming book. I would say that many if not the majority of Lean meta programmers have no or very little clue about category theory.</p>",
        "id": 446898721,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719325350
    },
    {
        "content": "<p>...so \"drawing the missing diagrams\" - even if they look weird at first - looks like an activity that will bring good karma. And I thought that reading the right source code comments on type inference could be useful, because they would mention how some things are done internally in several steps, and would show better notations for things in which I'm still improvising.</p>",
        "id": 446899041,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1719325434
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span>, that paper started from problems in Category Theory, but most of its conventions for drawing \"missing diagrams\" can be adapted to other contexts...</p>",
        "id": 446899572,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1719325557
    },
    {
        "content": "<p>Btw, the <a href=\"https://github.com/leanprover-community/mathlib4/wiki/Monad-map\">Monad map</a> in the wiki looks like a treasure trove of good ideas, but it doesn't have examples... I am trying to write some of the examples that it omits - and leaves as exercises...</p>",
        "id": 446900749,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1719325829
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"381195\">Eduardo Ochs</span> <a href=\"#narrow/stream/113489-new-members/topic/References.20on.20the.20.28non-kernel!.29.20type.20theory.20of.20Lean.3F/near/446888895\">said</a>:</p>\n<blockquote>\n<p>In the middle of the pandemic I tried to learn Haskell for the nth time - that time using Hutton's book, because a friend was TAing a course that used it.</p>\n</blockquote>\n<p>The pedagogy around this interesting.</p>\n<p>Given the current place I am in my learning, my feeling is somewhat that because they're reliably automated, Type Checking and Type Inference are systems for which one needs to understand what's happening but which you're rarely going to need to do it yourself.</p>\n<p>Perhaps it's kind of like sorting a list. There's a lot of algorithms that do this, but it's only the edge cases where the one in use really matters. Most of the time, the important bit is understanding the result. In fact, before learning your first sorting algorithm you probably already need an understanding of which permutations of a list are ordered or not.</p>\n<p>Though we'll all forever implement our own sorting algorithms because they're good learning tools for other purposes.</p>\n<hr>\n<p>Is Type Inference like this? I'm not really sure. When I write expressions — especially ones where type classes/elaboration/macros are at work, I feel like I'm guided by heuristics and then rely on the compiler to catch the inevitable shortcomings of that approach.</p>\n<p>Hard to say though!</p>",
        "id": 446925653,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1719331268
    }
]