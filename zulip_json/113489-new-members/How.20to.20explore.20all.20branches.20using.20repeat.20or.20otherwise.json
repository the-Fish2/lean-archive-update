[
    {
        "content": "<p>I am doing an exercise in the Theorem Proving in Lean 4 book, to get a one-line version of a proof.  First I supply a multi-line proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n        <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">And.intro</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hp</span>\n  <span class=\"n\">apply</span> <span class=\"n\">And.intro</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hp</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span>\n</code></pre></div>\n<p>The obvious one-liner doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n        <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">(</span><span class=\"n\">any_goals</span> <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">And.intro</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span> <span class=\"bp\">|</span> <span class=\"n\">exact</span> <span class=\"n\">hp</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>It leaves me in this state:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">pqr</span><span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">hp</span><span class=\"o\">:</span> <span class=\"n\">p</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">q</span>\n<span class=\"n\">pqr</span><span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">hp</span><span class=\"o\">:</span> <span class=\"n\">p</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">q</span>\n</code></pre></div>\n<p>It can get here because many combinations of the list of tactics in the <code>first</code> can lead to <code>⊢ q</code> or <code>⊢ r</code> but fewer branches lead to <code>⊢ p</code>.</p>\n<p>How would I change the above so that it would recursively explore every non-failing sequence of applications of the list of tactics in the <code>first</code> until it found a sequence that worked or exhausted all sequences?</p>",
        "id": 418550105,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1706489794
    },
    {
        "content": "<p>You won't find many examples of people trying to build algorithms out of tactic combinators. Is that your real aim, or would any kind of one-liner satisfy you? Here's one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Tauto</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">tauto</span>\n</code></pre></div>\n<p>If the exercise asks for a one-line proof, chances are it means you to translate your proof into term mode. I've done that in two stylistic variations, with no clever tricks, in the spoiler tag.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">And.intro</span> <span class=\"o\">(</span><span class=\"n\">Or.inl</span> <span class=\"n\">hp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">And.intro</span> <span class=\"o\">(</span><span class=\"n\">Or.inr</span> <span class=\"o\">(</span><span class=\"n\">Or.inl</span> <span class=\"n\">hp</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Or.inr</span> <span class=\"o\">(</span><span class=\"n\">Or.inr</span> <span class=\"n\">hp</span><span class=\"o\">)))</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">hp</span><span class=\"o\">⟩</span>\n</code></pre></div>\n</div></div>",
        "id": 418558409,
        "sender_full_name": "Richard Copley",
        "timestamp": 1706497633
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"400544\">@Richard Copley</span>  and <span class=\"user-mention\" data-user-id=\"417654\">@Martin Dvořák</span>, term proofs were the topic of the previous chapters.  The <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/tactics.html\">tactics chapter</a> is about tactic proofs and introduces <code>repeat</code> in the <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/tactics.html#tactic-combinators\">Tactics Combinator</a> section and after that rewriting, extending <code>simp</code> and <code>split</code>.   The <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/tactics.html#exercises\">exercise</a> starts with \"Use tactic combinators\".  Your Spoiler proofs do not address the \"use tactic combinator\" requirement.   That is why I am fussing with <code>repeat</code>.  I need a combinator or two, but not too many to fit in one line.  <code>tauto</code> feels like dodging the pedagogical intent, in the context of the chapter.</p>",
        "id": 419563584,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1706924341
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"364351\">@Lars Ericson</span>  interesting exercise! here's a solution I found:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n        <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">And.intro</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">hp</span> <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span> <span class=\"bp\">|</span> <span class=\"n\">exact</span> <span class=\"n\">hp</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 419565499,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706925966
    },
    {
        "content": "<p>the key is to write the combinator so that applying <code>Or.inl</code> is considered a failure if we're not able to close the goal with <code>hp</code> immediately afterward</p>",
        "id": 419565941,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706926397
    },
    {
        "content": "<p>(also I removed your use of <code>any_goals</code> because it didn't seem necessary)</p>",
        "id": 419566061,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706926505
    },
    {
        "content": "<p>it seems like a good rule of thumb when using <code>repeat</code> and <code>first</code> is to ask, for each branch, \"would this ever cause a problem if it succeeded? if so, how can I make it more specific so that it fails in those cases?\"</p>",
        "id": 419566424,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706926877
    },
    {
        "content": "<p>Thanks!  Is there a less insightful way to write this with my initial list of tactics so that Lean does a brute force depth first search of the possible combinations in the list, backing up when it reaches a non-empty goal state for which no tactic in the list applies?  I understand this search could be intractable.  I am just curious if it is possible to express it.</p>",
        "id": 419608077,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1706966374
    },
    {
        "content": "<p>I'm not sure there's a way to do this without making a recursive tactic macro.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"s2\">\"my_tauto\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">my_tauto</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span>\n        <span class=\"n\">first</span>\n        <span class=\"bp\">|</span> <span class=\"n\">done</span>\n        <span class=\"bp\">|</span> <span class=\"n\">assumption</span>\n        <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Or.inl</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">my_tauto</span>\n        <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">Or.inr</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">my_tauto</span>\n        <span class=\"bp\">|</span> <span class=\"n\">apply</span> <span class=\"n\">And.intro</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">my_tauto</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n        <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">my_tauto</span>\n</code></pre></div>",
        "id": 419625532,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706980762
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> that's great, the last sections on defining new tactics scared me a little.  This gives me a good guide.  I had kind of assumed that there would be a recursive search macro already designed in Lean since it seems like it would be a core idea.  I'm glad to see how to do it. For the exact problem in the text <span class=\"user-mention\" data-user-id=\"380294\">@Matt Diamond</span> 's answer seems closest to the intent of the problem.</p>",
        "id": 419629719,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1706984125
    },
    {
        "content": "<p>I.e. instead of <code>first</code> a macro called <code>recursive_repeat_first</code>, like your <code>my_tauto</code> but taking a list of tactics as an argument like <code>first</code>.</p>",
        "id": 419629919,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1706984266
    }
]