[
    {
        "content": "<p>In a lot of the material I see about dependent types (esp with respect to programming with them), I keep seeing the example of a list that is indexed by it's size. Is this implemented in std4 or mathlib4? I'm not seeing it as such.</p>\n<p>Is it just idiomatic to use Subtypes to refer to Arrays of a specific length?</p>",
        "id": 413232774,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1705436514
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Vector#doc\">docs#Vector</a> ?</p>",
        "id": 413234985,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1705437519
    },
    {
        "content": "<p>Yup. There it is. Not my brightest. Thanks for the help.</p>",
        "id": 413241362,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1705440260
    },
    {
        "content": "<p>It doesn't have the same runtime characteristics as <code>Array</code>. Might be worth having the <code>Array</code> version with <code>push</code> instead of <code>cons</code>, also defined as a <code>Subtype</code></p>",
        "id": 413241794,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705440476
    },
    {
        "content": "<p>I've been haphazardly wrapping Subtypes of Array with an api a bit like Vector's. Seems to work okay and should have Array's runtime characteristics (more or less)</p>",
        "id": 413242486,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1705440752
    },
    {
        "content": "<p>Seems more comp-sci than math, but that's sort of my interest with Lean anyhow.</p>",
        "id": 413242702,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1705440854
    },
    {
        "content": "<p>At runtime, <code>Subtype</code> of <code>Array</code> has the same representation as <code>Array</code>, so I'd expect it to be exactly the same. The compiler eliminates \"computationally irrelevant\" fields, and it turns single-field structures into just that field.</p>",
        "id": 413243322,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705441176
    },
    {
        "content": "<p>There is the (probably very minor) overhead that the <code>Nat</code> in the index of that subtype has to be passed around to all functions, even though it’s already present in the array itself (<code>a.size</code>).</p>",
        "id": 413244305,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705441555
    },
    {
        "content": "<p>I'm also just not knowledgeable enough to know how well the wrapper is itself optimized away. Worst case scenario, nothing is inlined and it's doubling he number of functions calls pushed to the stack. I suspect that's more of less not a problem (seems to be the sort of thing dependent typing excels at), but I don't really <strong>know</strong>.</p>",
        "id": 413245307,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1705441983
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> It looks like it might be able to erase the length argument at least sometimes. In the following, <code>MyVector.inc</code> ends up compiled taking just a single argument.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">MyVector</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">a.size</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.compiler.ir</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MyVector.inc</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">MyVector</span> <span class=\"n\">Nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyVector</span> <span class=\"n\">Nat</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">v.val.map</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Array.size_map</span><span class=\"o\">,</span> <span class=\"n\">v.property</span><span class=\"o\">]⟩</span>\n</code></pre></div>\n<p>I also checked</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">MyVector.map</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">MyVector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyVector</span> <span class=\"n\">β</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">v.val.map</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Array.size_map</span><span class=\"o\">,</span> <span class=\"n\">v.property</span><span class=\"o\">]⟩</span>\n</code></pre></div>\n<p>and it seems to take just two arguments when compiled.</p>",
        "id": 413247265,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705442771
    },
    {
        "content": "<p>TIL, thanks!</p>",
        "id": 413247621,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705442943
    },
    {
        "content": "<p>I wasn't sure what was going to happen. Maybe this is a matter of erasing unused variables?</p>",
        "id": 413248207,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705443223
    },
    {
        "content": "<p>That'd be my guess as well</p>",
        "id": 413248376,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705443288
    },
    {
        "content": "<p>I suppose that might mean if you're going to use the variable, using <code>v.val.size</code> in lieu of <code>n</code> might be preferable?</p>",
        "id": 413781382,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1705444046
    },
    {
        "content": "<p>Yes. Unless the extra parameter is cheaper than the extra indirection. But the difference is probably negligible either way.</p>",
        "id": 413781553,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705444114
    },
    {
        "content": "<p>I wonder if it matters whether n is fixed or not. In most cases you might want MyVector, you probably statically know the value of n, which means you can compile it in (monomorphize, I think). I'm not really sure if that looks different for <code>size</code> in the array's structure.</p>",
        "id": 415376340,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1705444607
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Vector.2FArray.20indexed.20by.20.E2.84.95/near/413248207\">said</a>:</p>\n<blockquote>\n<p>I wasn't sure what was going to happen. Maybe this is a matter of erasing unused variables?</p>\n</blockquote>\n<p>Yes, see also <a href=\"https://github.com/leanprover/lean4/blob/f8edf452dec50d2d310737c266a1db112386ecda/src/library/compiler/reduce_arity.cpp#L32\">reduce_arity</a>. The code for the type erasure is <a href=\"https://github.com/leanprover/lean4/blob/f8edf452dec50d2d310737c266a1db112386ecda/src/library/compiler/erase_irrelevant.cpp#L55\">here</a>.</p>",
        "id": 415979931,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1705481983
    },
    {
        "content": "<p>Thanks! TIL that it’s important to put the unused parameters before any used parameters, if I read the code correctly.</p>",
        "id": 415989302,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705485173
    },
    {
        "content": "<p>Yup. If we move β after v in <code>MyVector.map</code>, we instead get:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">MyVector.map._rarg</span> <span class=\"o\">(</span><span class=\"n\">x_1</span> <span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x_2</span> <span class=\"o\">:</span> <span class=\"bp\">◾</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x_3</span> <span class=\"o\">:</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>Note that <code>foo._rarg</code> will only be used instead of <code>foo</code> in full applications. <code>pap</code> calls still have to use the version where none of the unused parameters have been erased.</p>",
        "id": 415992358,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1705486061
    }
]