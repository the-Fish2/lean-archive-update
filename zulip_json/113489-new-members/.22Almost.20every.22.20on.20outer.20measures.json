[
    {
        "content": "<p>Hi,</p>\n<p>Random question: is there a preferred way to access the \"complements of null-sets\" -filter of an outer measure?</p>\n<p>Measures have \"<a href=\"http://Measure.ae\">Measure.ae</a>\", which has all kinds of useful notation and results associated. But outer measures don't seem to have anything similar. </p>\n<p>I'm thinking about if I then should convert the measure into an outer measure with its sigma algebra of Caratheodory sets (since nullsets seem to me to be automatically Caratheodory) and access the filter from there; for an outer measure \"m\" there is \"m.toMeasure\", but I don't know how I would pass  \"m.caratheodory\" to the square bracket parameter of that result for just that one definition,  or if doing something like this makes any sense at all (e.g. due to potential problems with how the square bracket parameter system works).</p>",
        "id": 437051909,
        "sender_full_name": "Ilmari Kangasniemi",
        "timestamp": 1714856812
    },
    {
        "content": "<p>Indeed, as you say, introducing the Carathéodory sigma algebra <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.OuterMeasure.caratheodory#doc\">docs#MeasureTheory.OuterMeasure.caratheodory</a> for the outer measure and then talking about the a.e. filter w.r.t. the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OuterMeasure.toMeasure#doc\">docs#OuterMeasure.toMeasure</a> is possible, at least if one is willing to fill in all implicit arguments (including the typeclass argument for the sigma algebra):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ν</span> <span class=\"o\">:</span> <span class=\"n\">OuterMeasure</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">OuterMeasure.toMeasure</span> <span class=\"n\">X</span> <span class=\"n\">ν.caratheodory</span> <span class=\"n\">ν</span> <span class=\"n\">rfl.le</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ae</span> <span class=\"c1\">-- (ν.toMeasure ⋯).ae : Filter X</span>\n</code></pre></div>\n<p>I believe you are also right in that this filter should have the right null sets for the original outer measure, although by definition this uses the measure associated with it (so indirectly <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.OuterMeasure.trim#doc\">docs#MeasureTheory.OuterMeasure.trim</a> which is an a priori different outer measure than the original).</p>",
        "id": 437148628,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1714929875
    },
    {
        "content": "<p>...but are you really sure you want to use outer measures? <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span> (Ok, I believe you know what you are doing, but just to make sure this is not a case of <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>.)</p>",
        "id": 437148958,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1714929997
    },
    {
        "content": "<p>One could also introduce an abbreviation if one really intends to use this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ν</span> <span class=\"o\">:</span> <span class=\"n\">OuterMeasure</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">MeasureTheory.OuterMeasure.ae</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">OuterMeasure.toMeasure</span> <span class=\"n\">X</span> <span class=\"n\">ν.caratheodory</span> <span class=\"n\">ν</span> <span class=\"n\">rfl.le</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ae</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">ν.ae</span> <span class=\"c1\">-- ν.ae : Filter X</span>\n</code></pre></div>",
        "id": 437149384,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1714930433
    },
    {
        "content": "<p>Hi,</p>\n<p>That @-syntax is something I haven't yet found out about. So that allows you to pass parameters that are otherwise inferred? I've ran into this a couple times before where I want to pass something that's not a ()-parameter, so I definitely have to experiment with that - thanks for pointing it out.</p>\n<p>What I did in the meantime was just to define a <code>OuterMeasure.ae</code>. The definition (which includes the proof that it's a filter) is almost identical to the Measure-version. The main reason why I'm not sure if this is the right way to go is the fact that there's a bunch of existing results and notation related to <a href=\"http://Measure.ae\">Measure.ae</a>, so having it be based on the same definition would probably instantly give access to these tools. Though since you pointed out that it's based on a different measure, it might be that the idea of reducing to <a href=\"http://Measure.ae\">Measure.ae</a> is worse than what I already did.</p>\n<p>I'm using outer measures since I'm defining the p-modulus of measure families, an outer measure on measures that essentially has the purpose of \"if a function is in Lᵖ, then it has a well-behaving integral over p-modulus -almost every measure\". It has really few measurable sets, and it's often applied to sets that aren't Caratheodory for it, so it's generally defined to just be an outer measure. (All this is really an exercise I came up with to learn the measure theory module of Mathlib - most of the things I'm interested in are locked behind Sobolev space theory which I can't find in Mathlib, and that seems too widely important for me to start randomly trying to define for an exercise, but p-modulus seemed feasible enough and also non-mainstream enough that I'm unlikely to interfere with anyone by writing down its basics).</p>",
        "id": 437154743,
        "sender_full_name": "Ilmari Kangasniemi",
        "timestamp": 1714935424
    },
    {
        "content": "<p>That indeed seems like a good reason to want an a.e. filter for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.OuterMeasure#doc\">docs#MeasureTheory.OuterMeasure</a>.</p>\n<p>As you say, if one bases the definition to that of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.Measure.ae#doc\">docs#MeasureTheory.Measure.ae</a>, then one gets <em>some</em> results for free. I don't have a very educated estimate of how much and how relevant results, but avoiding having to build at least something from scratch can still make a difference in formalization (plus avoiding duplication is probably a design that is appreciated if you PR your results to Mathlib).</p>\n<p>Here is a proof that the implementation I suggested above (following rather literally what you asked for) is characterized exactly by the property that sets are in the filter if the outer measure of their complement is zero. So the <code>OuterMeasure.ae</code> coincides with what you wanted, and being based on <code>Measure.ae</code>, you should get some things for free with it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ν</span> <span class=\"o\">:</span> <span class=\"n\">OuterMeasure</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- The almost everywhere (a.e.) filter of an outer measure. -/</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">MeasureTheory.OuterMeasure.ae</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">OuterMeasure.toMeasure</span> <span class=\"n\">X</span> <span class=\"n\">ν.caratheodory</span> <span class=\"n\">ν</span> <span class=\"n\">rfl.le</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ae</span>\n\n<span class=\"c1\">-- Missing???</span>\n<span class=\"sd\">/-- Sets of zero outer measure are Carathéodory-measurable. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">OuterMeasure.isCaratheodory_of_null</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s_null</span> <span class=\"o\">:</span> <span class=\"n\">ν</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ν.IsCaratheodory</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">change</span> <span class=\"bp\">@</span><span class=\"n\">MeasurableSet</span> <span class=\"n\">X</span> <span class=\"n\">ν.caratheodory</span> <span class=\"n\">s</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">OuterMeasure.isCaratheodory_iff_le</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">t</span>\n  <span class=\"k\">have</span> <span class=\"n\">obs</span> <span class=\"o\">:</span> <span class=\"n\">ν</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">∩</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n    <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">s_null</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">ν.mono</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Set.inter_subset_right</span> <span class=\"n\">t</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">zero_le</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">obs</span><span class=\"o\">,</span> <span class=\"n\">zero_add</span><span class=\"o\">,</span> <span class=\"n\">ge_iff_le</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">ν.mono</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Set.diff_subset</span> <span class=\"n\">t</span> <span class=\"n\">s</span>\n\n<span class=\"sd\">/-- A set belongs to the outer measure a.e. filter if and only if its complement has zero outer measure. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_outerMeasure_ae_iff</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">ν.ae</span> <span class=\"bp\">↔</span> <span class=\"n\">ν</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">MeasureTheory.OuterMeasure.ae</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">mem_ae_iff</span> <span class=\"n\">X</span> <span class=\"n\">ν.caratheodory</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">OuterMeasure.toMeasure</span> <span class=\"n\">X</span> <span class=\"n\">ν.caratheodory</span> <span class=\"n\">ν</span> <span class=\"n\">rfl.le</span><span class=\"o\">)</span> <span class=\"n\">s</span><span class=\"o\">]</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">s_in_ae</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">toMeasure_toOuterMeasure</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">s_in_ae</span>\n    <span class=\"n\">apply</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">((</span><span class=\"bp\">@</span><span class=\"n\">le_toMeasure_apply</span> <span class=\"n\">X</span> <span class=\"n\">ν.caratheodory</span> <span class=\"n\">ν</span> <span class=\"n\">rfl.le</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">zero_le</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">s_in_ae</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">OuterMeasure.mono'</span> <span class=\"n\">_</span> <span class=\"n\">rfl.le</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">s_outerNull</span>\n    <span class=\"k\">have</span> <span class=\"n\">s_mble</span> <span class=\"o\">:=</span> <span class=\"n\">OuterMeasure.isCaratheodory_of_null</span> <span class=\"n\">ν</span> <span class=\"n\">s_outerNull</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">toMeasure_apply</span> <span class=\"n\">X</span> <span class=\"n\">ν.caratheodory</span> <span class=\"n\">ν</span> <span class=\"o\">(</span><span class=\"n\">Eq.le</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">s_mble</span><span class=\"o\">,</span> <span class=\"n\">s_outerNull</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 437161427,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1714941436
    },
    {
        "content": "<p>And yes, the <code>@</code> indeed allows (and requires) you to provide all arguments explicitly. I use it a lot (too much) when trying to get things to type check. (You can still use underscores <code>_</code> for those arguments that Lean can correctly <del>guess</del> infer).</p>",
        "id": 437161737,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1714941755
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"373986\">Kalle Kytölä</span> <a href=\"#narrow/stream/113489-new-members/topic/.22Almost.20every.22.20on.20outer.20measures/near/437148958\">said</a>:</p>\n<blockquote>\n<p>...but are you really sure you want to use outer measures?</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"708605\">Ilmari Kangasniemi</span> <a href=\"#narrow/stream/113489-new-members/topic/.22Almost.20every.22.20on.20outer.20measures/near/437154743\">said</a>:</p>\n<blockquote>\n<p>I'm using outer measures since I'm defining the p-modulus of measure families</p>\n</blockquote>\n<p>Ha! This is exactly the example I was going to respond with when <span class=\"user-mention silent\" data-user-id=\"373986\">Kalle Kytölä</span> asked that question. In my mind, this is one of the major use cases of outer measures where actual measures really don't work.</p>",
        "id": 437162544,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714942633
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"708605\">@Ilmari Kangasniemi</span> I work in operator algebras, but my alma mater had an excellent group in geometric measure theory and I have friends that work in this area, so I learned a bunch of this stuff at the time. If you'd like help or suggestions in your formalization of p-modulus and related topics, let me know.</p>",
        "id": 437162691,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714942795
    },
    {
        "content": "<p>Hi,</p>\n<p>Thanks for that: that definition does seemingly work. Though I've already observed a drawback: because there is one more intermediary layer in the definition, you have  to do an extra step of using \"mem_outerMeasure_ae_iff\" to convert statements.</p>\n<p>To illustrate, suppose one uses a direct definition by basically mimicking the one for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.Measure.ae#doc\">docs#MeasureTheory.Measure.ae</a>,  like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">OuterMeasure.ae</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">OuterMeasure</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">ofCountableUnion</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"bp\">·</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">hSc</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">μ.sUnion_null_iff</span> <span class=\"n\">hSc</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">ht</span> <span class=\"n\">_</span> <span class=\"n\">hs</span> <span class=\"bp\">↦</span> <span class=\"n\">μ.mono_null</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">OuterMeasure.aeInstCountableInterFilter</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">OuterMeasure</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">:</span> <span class=\"n\">CountableInterFilter</span> <span class=\"n\">μ.ae</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">OuterMeasure.ae</span><span class=\"bp\">;</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>\n<p>Then it can seemingly be more directly used with results that say something of the form \"μ(S) = 0\". For example, taking  one  relatively short proof from my exercise so far (that isn't really understandable standalone):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">pMod_lintegral_ae_finite</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">pg</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">f_meas</span> <span class=\"o\">:</span> <span class=\"n\">Measurable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f_Lp</span> <span class=\"o\">:</span> <span class=\"bp\">∫⁻</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">p</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∀ᶠ</span> <span class=\"n\">ν</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">pMod</span> <span class=\"n\">pg</span> <span class=\"n\">μ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ae</span><span class=\"o\">,</span> <span class=\"bp\">∫⁻</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∂</span><span class=\"n\">ν</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">∞</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">pMod_eq_zero</span> <span class=\"n\">pg</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">f_meas</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"n\">f_Lp</span>\n  <span class=\"n\">intro</span> <span class=\"n\">ν</span> <span class=\"n\">νcond</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_compl_iff</span><span class=\"o\">,</span> <span class=\"n\">mem_setOf_eq</span><span class=\"o\">,</span> <span class=\"n\">not_lt</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">νcond</span>\n  <span class=\"n\">exact</span> <span class=\"n\">νcond</span>\n</code></pre></div>\n<p>On the other hand, with the definition that goes through the induced measure, I need to add one extra conversion, precisely because of that difference between measures that was mentioned:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">pMod_lintegral_ae_finite</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">pg</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">f_meas</span> <span class=\"o\">:</span> <span class=\"n\">Measurable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f_Lp</span> <span class=\"o\">:</span> <span class=\"bp\">∫⁻</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">p</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∀ᶠ</span> <span class=\"n\">ν</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">pMod</span> <span class=\"n\">pg</span> <span class=\"n\">μ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ae</span><span class=\"o\">,</span> <span class=\"bp\">∫⁻</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∂</span><span class=\"n\">ν</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">∞</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">mem_outerMeasure_ae_iff</span> <span class=\"o\">(</span><span class=\"n\">pMod</span> <span class=\"n\">pg</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span>\n  <span class=\"n\">refine</span> <span class=\"n\">pMod_eq_zero</span> <span class=\"n\">pg</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">f_meas</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"n\">f_Lp</span>\n  <span class=\"n\">intro</span> <span class=\"n\">ν</span> <span class=\"n\">νcond</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_compl_iff</span><span class=\"o\">,</span> <span class=\"n\">mem_setOf_eq</span><span class=\"o\">,</span> <span class=\"n\">not_lt</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">νcond</span>\n  <span class=\"n\">exact</span> <span class=\"n\">νcond</span>\n</code></pre></div>\n<p>So it's in some sense a tradeoff between less reuse of arguments and more convenience. Not at all sure which approach is better overall.</p>",
        "id": 437164556,
        "sender_full_name": "Ilmari Kangasniemi",
        "timestamp": 1714944620
    },
    {
        "content": "<p>Personally, I would strongly suggest using the definition that goes through the induced measure. I can't emphasize enough how much parallel API sucks (I would know something about it, as I've spent a ton of time doing this kind of thing for unital / non-unital C⋆-algebras), especially when you can't reuse things from one part of the API in the other. It may cost an extra <code>rw</code> here or there, but the gain of having access to all the material on almost-everywhere for measures is almost certainly worth it.</p>",
        "id": 437165494,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1714945526
    },
    {
        "content": "<p>Seems like a reasonable argument, especially since the cost probably only is one line whenever I need to use it. Thanks for the input.</p>",
        "id": 437165983,
        "sender_full_name": "Ilmari Kangasniemi",
        "timestamp": 1714946041
    },
    {
        "content": "<p>Also, you should not need to <code>apply (mem_outerMeasure_ae_iff (pMod pg μ) _).mpr</code>; just <code>rw [mem_outerMeasure_ae_iff]</code> or <code>simp [mem_outerMeasure_ae_iff]</code> should be simple ways to do it. (As Jireh said, the cost is mostly an extra <code>rw</code> here or there, the benefits probably more.)</p>",
        "id": 437166083,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1714946126
    },
    {
        "content": "<p>(I was even going to suggest making <code>mem_outerMeasure_ae_iff</code> a <code>@[simp]</code> lemma, but that might somewhat defeat the point of conveniently reusing the existing <code>Measure.ae</code> API.)</p>",
        "id": 437166290,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1714946303
    },
    {
        "content": "<p>I did try that first and it didn't work. Though now that you said it, I tried a bit harder, and it does seem that <code>rw [Filter.Eventually, mem_outerMeasure_ae_iff]</code>or <code>simp only [Filter.Eventually, mem_outerMeasure_ae_iff]</code> does work.</p>",
        "id": 437167676,
        "sender_full_name": "Ilmari Kangasniemi",
        "timestamp": 1714947764
    },
    {
        "content": "<p>See <a href=\"https://github.com/leanprover-community/mathlib4/pull/13022\">#13022</a></p>",
        "id": 439467338,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1716153454
    },
    {
        "content": "<p>I've recently introduced <code>OuterMeasureClass</code>, so we don't need to develop parallel API.</p>",
        "id": 439467431,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1716153545
    }
]