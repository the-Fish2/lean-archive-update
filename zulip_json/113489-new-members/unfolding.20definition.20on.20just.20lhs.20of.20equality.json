[
    {
        "content": "<p>I'm trying to prove something about a recursive function that is almost exactly the definition, but not quite. It would be easy to do if I could use <code>unfold</code> on just the left hand side. But <code>unfold</code> replaces the definition on both the left and the right. How can I limit unfolding to just the left?</p>",
        "id": 426193387,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1710269783
    },
    {
        "content": "<p>It's very hard to answer this kind of question without a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 426200593,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710272752
    },
    {
        "content": "<p>It's very hard to answer this kind of question without a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 426200609,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710272757
    },
    {
        "content": "<p>Though perhaps you're looking for <code>conv_lhs =&gt; unfold foo</code></p>",
        "id": 426200612,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710272758
    },
    {
        "content": "<p>good point, I'll produce one</p>",
        "id": 426200875,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1710272863
    },
    {
        "content": "<p>it's quite large because I am too inexperienced to produce a more concise proof of termination.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Atom</span> <span class=\"o\">:=</span> <span class=\"n\">Array</span> <span class=\"n\">UInt8</span>\n\n<span class=\"c1\">-- the next two theorems are just to help prove `nat_to_atom` terminates</span>\n<span class=\"c1\">-- almost certainly there's a better way to do this</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">shift_as_division</span> <span class=\"o\">{</span> <span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">}:</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;&gt;&gt;</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">HShiftRight.hShiftRight</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">instHShiftRight</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">ShiftRight.shiftRight</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">Nat.instShiftRightNat</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">induction</span> <span class=\"n\">k</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">k</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">HShiftRight.hShiftRight</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">instHShiftRight</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">Nat.shiftRight</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">ShiftRight.shiftRight</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">Nat.instShiftRightNat</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">Nat.shiftRight</span>\n      <span class=\"n\">simp</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ih</span><span class=\"o\">]</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.div_div_eq_div_mul</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"mi\">2</span><span class=\"o\">]</span>\n      <span class=\"n\">rfl</span>\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">shift_decreasing</span> <span class=\"o\">:</span> <span class=\"n\">n</span><span class=\"bp\">&gt;</span><span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;&gt;&gt;</span> <span class=\"mi\">8</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">shift_as_division</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Nat.div_lt_self</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">nat_to_atom</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Atom</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">inner_func</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Atom</span> <span class=\"o\">:=</span>\n    <span class=\"k\">if</span> <span class=\"n\">h256</span><span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;=</span> <span class=\"mi\">256</span> <span class=\"k\">then</span>\n      <span class=\"k\">have</span> <span class=\"n\">h0</span><span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.zero_lt_of_lt</span> <span class=\"n\">h256</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;&gt;&gt;</span> <span class=\"mi\">8</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">shift_decreasing</span> <span class=\"n\">h0</span>\n      <span class=\"o\">(</span><span class=\"n\">inner_func</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">&gt;&gt;&gt;</span> <span class=\"mi\">8</span><span class=\"o\">))</span> <span class=\"bp\">++</span>  <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">n.toUInt8</span><span class=\"o\">]</span>\n    <span class=\"k\">else</span>\n      <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">n.toUInt8</span><span class=\"o\">]</span>\n  <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span>\n    <span class=\"bp\">#</span><span class=\"o\">[]</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">inner_func</span> <span class=\"n\">n</span>\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">nat_to_atom_prefix</span><span class=\"o\">:</span> <span class=\"n\">n</span><span class=\"bp\">&gt;</span><span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">nat_to_atom.inner_func</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">nat_to_atom.inner_func</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">&gt;&gt;&gt;</span> <span class=\"mi\">8</span><span class=\"o\">))</span> <span class=\"bp\">++</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h_n</span>\n  <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">%</span> <span class=\"mi\">256</span><span class=\"o\">)</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">nat_to_atom.inner_func</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 426202876,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1710273702
    },
    {
        "content": "<p>anyway, the unfold at the bottom unfolds both sides, which is not what I want. If I could find a way to unfold just the left, I believe the proof would be straightforward after that</p>",
        "id": 426203215,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1710273831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/unfolding.20definition.20on.20just.20lhs.20of.20equality/near/426200612\">said</a>:</p>\n<blockquote>\n<p>Though perhaps you're looking for <code>conv_lhs =&gt; unfold foo</code></p>\n</blockquote>\n<p>Did you try this?</p>",
        "id": 426206090,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710275000
    },
    {
        "content": "<p>that looks like it should do exactly what I want, thank you!!</p>",
        "id": 426206380,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1710275118
    },
    {
        "content": "<p>is there something I should be using besides <code>unfold</code>? I notice sometimes <code>simp</code> is helpful and other times it isn't, although I haven't been able to figure out exactly when. Maybe something to do with <code>include</code> statements (maybe <code>unfold</code> does transitive includes and <code>simp</code> doesn't?)</p>",
        "id": 426206605,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1710275200
    },
    {
        "content": "<p>Lean 3 had <code>include</code> and <code>omit</code> declarations, but I don't think they are implemented in Lean 4.<br>\nWhen the thing that you intend to do is unfold a definition, using <code>unfold</code> is the straightforward, expressive way to say so. Using <code>simp only [xxx]</code> to unfold the definition of <code>xxx</code> can be useful because it can also expand match statements and do beta-reduction. You can also do <code>rw [xxx]</code>, which might be convenient if you're doing other <code>rewrite</code>s at the same time.</p>",
        "id": 426211055,
        "sender_full_name": "Richard Copley",
        "timestamp": 1710277037
    },
    {
        "content": "<p>Correct, there's no more <code>include</code> and <code>omit</code>. I also don't have a clear idea of when <code>unfold</code> and <code>simp</code> work for definitions, but usually one of them does</p>",
        "id": 426222541,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1710282233
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"686420\">@Richard Kiss</span> btw <code>shift_as_division</code> is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.shiftRight_eq_div_pow#doc\">docs#Nat.shiftRight_eq_div_pow</a></p>",
        "id": 426227252,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710284784
    },
    {
        "content": "<p>I knew it had to exist somewhere</p>",
        "id": 426231024,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1710287096
    },
    {
        "content": "<p><code>exact?</code> didn't find it though, I suppose because I hadn't imported <code>Init.Data.Nat.Lemmas</code></p>",
        "id": 426231092,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1710287142
    },
    {
        "content": "<p>oh wait, things in <code>Init</code> are built-ins</p>",
        "id": 426231325,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1710287303
    },
    {
        "content": "<p>you can often find these things by searching the mathlib web docs using relevant terms... when you type in \"shift right div\" it's the first result</p>",
        "id": 426232075,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710287821
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"686420\">Richard Kiss</span> <a href=\"#narrow/stream/113489-new-members/topic/unfolding.20definition.20on.20just.20lhs.20of.20equality/near/426202876\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"k\">if</span> <span class=\"n\">h256</span><span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;=</span> <span class=\"mi\">256</span> <span class=\"k\">then</span>\n      <span class=\"bp\">...</span>\n    <span class=\"k\">else</span>\n     <span class=\"bp\">...</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Is there documentation for this syntax and how it is desugared? In particular, I want to know how the then clause can be unlocked with a proof of n &gt;= 256 and vice versa for the else clause.</p>",
        "id": 426235159,
        "sender_full_name": "Raunak Chhatwal",
        "timestamp": 1710289612
    },
    {
        "content": "<p>I think it's just <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ite#doc\">docs#ite</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=dite#doc\">docs#dite</a></p>\n<p>also I think your \"unlocking\" question is about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=if_pos#doc\">docs#if_pos</a> / <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=if_neg#doc\">docs#if_neg</a> / <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=dif_pos#doc\">docs#dif_pos</a> / <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=dif_neg#doc\">docs#dif_neg</a></p>",
        "id": 426235353,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710289695
    },
    {
        "content": "<p>I've used <code>split</code> or <code>by_cases</code> but both seem to have archaic lean 3 smell because they don't play nice with adding additional whitespace. I'm not sure what the modern lean 4 alternatives are. I can't figure out how to get <code>cases</code> to work every time</p>",
        "id": 426235549,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1710289805
    },
    {
        "content": "<p><code>split</code> can be frustrating because it often creates unnameable hypotheses and I can't figure out how to manipulate them</p>",
        "id": 426235608,
        "sender_full_name": "Richard Kiss",
        "timestamp": 1710289854
    },
    {
        "content": "<p>I have also never worked out how to name hypotheses after <code>split</code>; for me a very common idiom with Lean 3 <code>split_ifs</code> was <code>split_ifs with AAA BBB CCC DDD EEE FFF GGG HHH III JJJ KKK</code> and then go back and rename the variables correctly once I see their types (some would always be mysteriously missing, I never got to the bottom of this). But in Lean 4 we do have the smelly <code>rename_i</code> (which I can use) and then there are things like <code>next</code> and <code>case</code> which I can never get working, not least because I can never remember the names of any constructors; I don't know if they help you here.</p>",
        "id": 426286417,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710319999
    },
    {
        "content": "<p><code>split</code> does not have syntax to rename the variables, I use <code>split &lt;;&gt; rename_i AAA BBB CCC</code> instead</p>",
        "id": 426287294,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710320291
    },
    {
        "content": "<p>or <code>next AAA BBB CCC =&gt;</code> if I want to name the variables differently in each case (you don't need to know the name of the constructor to use <code>next</code>, it's equivalent to <code>case _</code>)</p>",
        "id": 426287579,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710320384
    },
    {
        "content": "<p>Does <code>next</code> work after a <code>\\.</code>? I don't use <code>|</code>, it's too CS for my liking (and I'm always in tactic mode)</p>",
        "id": 426289804,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710321160
    },
    {
        "content": "<p>For some reason I'm still always struggling with these sorts of silly things</p>",
        "id": 426290051,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710321250
    },
    {
        "content": "<p>I prefer to use both <code>.</code> and <code>next</code> even though it's redundant because it looks more regular if you are already using <code>.</code> for subgoals everywhere else</p>",
        "id": 426290276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710321326
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">foo</span><span class=\"bp\">;</span> <span class=\"n\">split</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">·</span> <span class=\"n\">next</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_comm</span> <span class=\"mi\">1</span> <span class=\"n\">n</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 426290572,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710321423
    },
    {
        "content": "<p>you can't use <code>|</code> either with <code>split</code>. Might be nice if you could</p>",
        "id": 426290708,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710321477
    },
    {
        "content": "<p>TBH it's a pretty bare bones interface</p>",
        "id": 426290783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710321489
    },
    {
        "content": "<p>\"it's redundant\" meaning that this has the same effect:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">foo</span><span class=\"bp\">;</span> <span class=\"n\">split</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">next</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_comm</span> <span class=\"mi\">1</span> <span class=\"n\">n</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>but the asymmetric handling of subgoals here bugs me</p>",
        "id": 426291042,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710321584
    }
]