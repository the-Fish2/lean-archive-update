[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- I think `160` is higher than precedence of `=`</span>\n<span class=\"kd\">infixl</span><span class=\"o\">:</span><span class=\"mi\">160</span><span class=\"w\"> </span><span class=\"s2\">\" ⊕ \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">xor</span>\n\n<span class=\"c1\">-- but this raise an error...</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">application type mismatch</span>\n<span class=\"cm\">  Sum true</span>\n<span class=\"cm\">argument</span>\n<span class=\"cm\">  true</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  Bool : Type</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  Type ?u.1547 : Type (?u.1547 + 1)</span>\n<span class=\"cm\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"c1\">-- no error</span>\n<span class=\"bp\">#</span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span>\n</code></pre></div>",
        "id": 445415314,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1718730560
    },
    {
        "content": "<p><a href=\"https://lean-lang.org/theorem_proving_in_lean4/interacting_with_lean.html?highlight=notation%20precedence#notations-and-precedence\">TPiL</a> says the precedence of <code>=</code> is 50!</p>",
        "id": 445415519,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1718730620
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">infixl</span><span class=\"o\">:</span><span class=\"mi\">160</span><span class=\"w\"> </span><span class=\"s2\">\" newnotation \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">xor</span>\n\n<span class=\"c1\">-- Both work</span>\n<span class=\"bp\">#</span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"n\">newnotation</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"bp\">#</span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"n\">newnotation</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span>\n</code></pre></div>",
        "id": 445415860,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718730723
    },
    {
        "content": "<p>The issue is that your notation is conflicting with the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sum#doc\">docs#Sum</a> notation which has precedence 30</p>",
        "id": 445415947,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718730756
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Thank you! </p>\n<p>However, if the symbols are overlapped, it would be nice to get some warning when the infixl command is executed. Is there any direct way for the command to know if the symbols are overlapped?</p>",
        "id": 445416545,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1718730934
    },
    {
        "content": "<p>You can set a higher priority on your new notation to override <code>Sum</code>'s notation</p>",
        "id": 445416554,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718730938
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">infixl</span><span class=\"o\">:</span><span class=\"mi\">160</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">high</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\" ⊕ \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">xor</span>\n</code></pre></div>",
        "id": 445416611,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718730960
    },
    {
        "content": "<p>I don't know of any command to get warnings about overlapping notations.</p>",
        "id": 445416756,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718730992
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Thank you!! but It is sad that I don't know how to know with Lean commands whether the notation is conflicting or not.</p>",
        "id": 445417977,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1718731380
    },
    {
        "content": "<p>At least you run into issues quickly. The \"application type mismatch\" is giving a hint that it's conflicting with some notation having to do with <code>Sum</code>, which gives you some information about what to search for in the source code.</p>",
        "id": 445418287,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718731449
    },
    {
        "content": "<p>By the way, is it possible to get the notation precedence without having to go and look at the definitions or write tests?</p>",
        "id": 445419686,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1718731903
    },
    {
        "content": "<p>It was possible in Lean 3, but I don't think it is in Lean 4?</p>",
        "id": 445420149,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718732046
    },
    {
        "content": "<p>I'm not sure. There's <code>#help term</code> but it doesn't show precedences (and it doesn't show very much information about operators defined using <code>infix</code>)</p>",
        "id": 445420316,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718732100
    },
    {
        "content": "<p>In principle it's possible of course.</p>\n<p>What I do for now is right click on notations and go to their definitions.</p>",
        "id": 445420424,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718732140
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"626349\">Asei Inoue</span> has marked this topic as resolved.</p>",
        "id": 445421795,
        "sender_full_name": "Notification Bot",
        "timestamp": 1718732569
    },
    {
        "content": "<p>Thank you all!</p>",
        "id": 445421818,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1718732578
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"626349\">Asei Inoue</span> has marked this topic as unresolved.</p>",
        "id": 445422842,
        "sender_full_name": "Notification Bot",
        "timestamp": 1718732903
    },
    {
        "content": "<p>still error...?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">160</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">high</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\" ⊕ \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">xor</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">application type mismatch</span>\n<span class=\"cm\">  Sum true</span>\n<span class=\"cm\">argument</span>\n<span class=\"cm\">  true</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  Bool : Type</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  Type ?u.3535 : Type (?u.3535 + 1)</span>\n<span class=\"cm\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span>\n</code></pre></div>",
        "id": 445422897,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1718732915
    },
    {
        "content": "<p>Sorry, I didn't test it. It seems that you can't override it if you change anything about the notation.</p>",
        "id": 445423206,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718733019
    },
    {
        "content": "<p>...Is it not possible to set it so that xor is always called when <code>⊕</code> is used against a Bool term?</p>",
        "id": 445423519,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1718733117
    },
    {
        "content": "<p>If you make the precedence be 30 you can make it be xor, but then you need to remember to use parentheses.</p>",
        "id": 445423663,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718733152
    },
    {
        "content": "<p>Here's another way to override the meaning of a preexisting notation instead of using priorities:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">macro_rules</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">xor</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 445423794,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718733196
    },
    {
        "content": "<p>oh, that's nice. but why this works? Is macro_rules expanded before infix?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro_rules</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">xor</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"bp\">#</span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">#</span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">#</span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span>\n</code></pre></div>",
        "id": 445424376,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1718733348
    },
    {
        "content": "<p>The <code>infix</code> command does three things: it defines the <code>syntax</code>, it creates a <code>macro_rules</code> for expanding the syntax, and it (tries to) create an <code>app_unexpander</code> for pretty printing.</p>\n<p>Macro rules are considered in reverse order of definition. Adding your own macro rules means it overrides the one that came from <code>infix</code>.</p>",
        "id": 445424707,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718733430
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  Thank you! Indeed, using macro_rules seems to disable the Sum notation. Override.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro_rules</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">xor</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"bp\">#</span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">#</span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">#</span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check_failure</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n</code></pre></div>",
        "id": 445433507,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1718735946
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"626349\">Asei Inoue</span> has marked this topic as resolved.</p>",
        "id": 445891601,
        "sender_full_name": "Notification Bot",
        "timestamp": 1718900384
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"626349\">Asei Inoue</span> has marked this topic as unresolved.</p>",
        "id": 446061491,
        "sender_full_name": "Notification Bot",
        "timestamp": 1718968627
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I forgot to ask an important question ...</p>\n<p>why this does not work?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">160</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">high</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\" ⊕ \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">xor</span>\n\n<span class=\"bp\">#</span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span>\n</code></pre></div>",
        "id": 446061679,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1718968682
    },
    {
        "content": "<p>priority of notation of <code>Sum</code> is not  set as <code>priority := high</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">inherit_doc</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">30</span><span class=\"w\"> </span><span class=\"s2\">\" ⊕ \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Sum</span>\n</code></pre></div>",
        "id": 446061861,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1718968746
    },
    {
        "content": "<p>I wonder priority cannot override <code>notation</code>...?</p>",
        "id": 446105523,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1718983494
    },
    {
        "content": "<p>My guess is that having the same notation with different precedences is confusing the parser. The <code>priority</code> as far as I know is only used when disambiguating after a successful parse. Both the <code>Sum</code> and <code>xor</code> notations can parse successfully, but they have completely different parse trees, and I don't know what happens in that case. Experimentally, we see in your example that it goes back to interpreting <code>true ⊕ true = false</code> as <code>Sum true (Eq true false)</code> rather than <code>Eq (xor true true) false</code>. However, if you do <code>true ⊕ true</code> alone it respects the priority and is interpreted as <code>xor true true</code>.</p>",
        "id": 446131529,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718990367
    }
]