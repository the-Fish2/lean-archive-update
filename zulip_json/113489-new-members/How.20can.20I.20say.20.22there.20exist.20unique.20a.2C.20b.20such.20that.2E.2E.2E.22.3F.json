[
    {
        "content": "<p>I'd like to translate this statement into Lean:  \"There is a unique pair of natural numbers (a, b) such that a * b = 1.\"</p>\n<p>I can write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"n\">p.1</span> <span class=\"bp\">*</span> <span class=\"n\">p.2</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>But p.1 and p.2 are a bit ugly.  Really I'd like to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"bp\">∃!</span> <span class=\"o\">((</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>but Lean won't accept this syntax.  Is there any way to write this nicely?</p>",
        "id": 420796069,
        "sender_full_name": "Adam Dingle",
        "timestamp": 1707567934
    },
    {
        "content": "<p>This could work: <code>example: ∃! (a : Nat) (b : Nat), a * b = 1 := ...</code></p>",
        "id": 420797036,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1707568911
    },
    {
        "content": "<p>I believe that Lean interprets that as meaning <code>∃! (a : Nat), ∃! (b : Nat), a * b = 1</code>, which is not semantically the same.</p>",
        "id": 420797241,
        "sender_full_name": "Adam Dingle",
        "timestamp": 1707569123
    },
    {
        "content": "<p>So perhaps take (a, b) to be an element of Nat x Nat?</p>",
        "id": 420797333,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1707569210
    },
    {
        "content": "<p>I realized that this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"bp\">∃!</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">p</span><span class=\"bp\">;</span>\n  <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>This isn't too bad.  I'd still be happy to know about a nicer syntax if it exists.</p>",
        "id": 420797368,
        "sender_full_name": "Adam Dingle",
        "timestamp": 1707569269
    },
    {
        "content": "<p>Josha: I don't understand your comment.  Are you suggesting a particular syntax that will work?</p>",
        "id": 420797439,
        "sender_full_name": "Adam Dingle",
        "timestamp": 1707569330
    },
    {
        "content": "<p>They are provably the same though, no?</p>",
        "id": 420797963,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1707569836
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687151\">Adam Dingle</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20can.20I.20say.20.22there.20exist.20unique.20a.2C.20b.20such.20that.2E.2E.2E.22.3F/near/420797368\">said</a>:</p>\n<blockquote>\n<p>I realized that this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"bp\">∃!</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">p</span><span class=\"bp\">;</span>\n  <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>This isn't too bad.  I'd still be happy to know about a nicer syntax if it exists.</p>\n</blockquote>\n<p>This is basically what I was suggesting indeed: you want to say that there is a unique pair of integers, so you consider the set of all pairs of integers, i.e. Nat x Nat</p>",
        "id": 420798318,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1707570131
    },
    {
        "content": "<p>I think there’s a way of doing the ‘let’ part immediately, but I’m not sure about that.</p>",
        "id": 420798384,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1707570193
    },
    {
        "content": "<p>i believe you can do <code>((x,y): Nat \\x Nat)</code></p>",
        "id": 420798490,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707570291
    },
    {
        "content": "<p>Lean won't accept that syntax.  If I write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"bp\">∃!</span> <span class=\"o\">((</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Lean reports</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unexpected</span> <span class=\"n\">token</span> <span class=\"sc\">'('</span><span class=\"bp\">;</span> <span class=\"n\">expected</span> <span class=\"sc\">'_'</span> <span class=\"n\">or</span> <span class=\"n\">identifier</span>\n</code></pre></div>\n<p>at the left parenthesis in <code>(x, y)</code>.</p>",
        "id": 420798661,
        "sender_full_name": "Adam Dingle",
        "timestamp": 1707570441
    },
    {
        "content": "<p>oh...</p>",
        "id": 420798706,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707570481
    },
    {
        "content": "<p><del>in that case, maybe just <code>\\exists! (x y : Nat),...</code>?</del></p>",
        "id": 420798767,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707570514
    },
    {
        "content": "<p>Note that <code>\\exists! x, \\exists! y, foo(x, y)</code> does not mean the same thing as <code>\\exists! (x, y), foo(x, y)</code>.</p>",
        "id": 420799335,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707571009
    },
    {
        "content": "<p>ah right... and i'm guessing that what i suggested expands to the first?</p>",
        "id": 420799440,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707571100
    },
    {
        "content": "<p><code>  example : ExistsUnique fun (a, b) =&gt; a * b = 1 := _</code> works, but not with notation</p>",
        "id": 420799491,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707571166
    },
    {
        "content": "<p>You could also say: <code>∃ (a b : Nat), a * b = 1 ∧ ∀ (a' b' : Nat), a' * b' = 1 → a' = a ∧ b' = b</code>.</p>",
        "id": 420836269,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1707602818
    },
    {
        "content": "<blockquote>\n<p>They are provably the same though, no?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"687151\">@Adam Dingle</span> <span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span> they are provably different! This is a fabulous gotcha. Saying \"there's a unique <code>a</code> such that there's a unique <code>b</code> which works\" allows the possibility that there's an <code>a</code> for which only one <code>b</code> works, but for all the other <code>a</code>'s, more than one <code>b</code> works (as opposed to no <code>b</code> working)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span>\n    <span class=\"bp\">¬</span> <span class=\"o\">((</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"n\">ab</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">ab.1</span> <span class=\"n\">ab.2</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">use</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">⟩</span> <span class=\"c1\">-- left-&gt;right is the problem</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">h1</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span><span class=\"o\">⟩,</span> <span class=\"k\">fun</span> <span class=\"n\">c</span> <span class=\"o\">⟨</span><span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">hd1</span><span class=\"o\">,</span> <span class=\"n\">hd2</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">specialize</span> <span class=\"n\">hd2</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"n\">aesop</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rcases</span> <span class=\"n\">h1</span> <span class=\"k\">with</span> <span class=\"o\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩,</span> <span class=\"bp\">-</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">⟩</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">hab</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"n\">aesop</span>\n</code></pre></div>",
        "id": 420836496,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707603068
    },
    {
        "content": "<p>Here are some concrete examples:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">),</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">use</span> <span class=\"mi\">0</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">use</span> <span class=\"mi\">0</span>\n    <span class=\"n\">simp</span>\n    <span class=\"n\">intro</span> <span class=\"n\">_</span> <span class=\"n\">h</span>\n    <span class=\"n\">exact</span> <span class=\"n\">pow_eq_zero</span> <span class=\"n\">h.symm</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">y</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h.1</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">),</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"bp\">∃!</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"bp\">×</span> <span class=\"n\">Int</span><span class=\"o\">,</span> <span class=\"n\">p.1</span> <span class=\"bp\">=</span> <span class=\"n\">p.2</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">⟩,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h.1</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"o\">((</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 420845762,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707612611
    },
    {
        "content": "<p><a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type/near/268472332\">cross link</a></p>",
        "id": 420848041,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1707615091
    },
    {
        "content": "<p>Thanks for the explanation, Kevin! Now I understand why I didn't manage to prove the equivalence :)</p>",
        "id": 420870309,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1707638292
    },
    {
        "content": "<p>In lean 3 we were stuck with this behavior because <code>notation</code> was inflexible; can we just make <code>∃! (x y : Int),</code> an error now?</p>",
        "id": 433824047,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713369762
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> <a href=\"https://github.com/leanprover-community/mathlib4/pull/12218\">mathlib4#12218</a></p>",
        "id": 433828903,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713371247
    },
    {
        "content": "<p>If anyone wants to help with the errors, all you need to do is turn expressions like <code>∃! (b : _) (_ : b ∈ c), a ∈ b</code> into <code>∃! b, ∃! _ : b ∈ c, a ∈ b</code>. Notice the lack of parentheses, the ability to drop <code>: _</code>, and, furthermore, the fact that this isn't being re-stated more reasonably. (It would be more simple as <code>∃! b, b ∈ c ∧ a ∈ b</code>.)</p>\n<p>I figure a follow-up PR could review all uses of <code>∃!</code> and clean them up.</p>",
        "id": 433839995,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713374994
    },
    {
        "content": "<p>I guess <code>ExistsUnique</code> could allow chained prop binders?</p>",
        "id": 433851556,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713379179
    },
    {
        "content": "<p>I think rather it would be good to have extended binder syntax so that <code>∃! b ∈ c, a ∈ b</code> is <code>∃! b, b ∈ c ∧ a ∈ b</code>, just like for <code>Exists</code>. That could be in that follow-up PR.</p>",
        "id": 433866904,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713384649
    },
    {
        "content": "<p>Is there a technical reason Lean doesn't allow destructuring in the parameter position? <br>\nDoes it get weird with dependent types?</p>",
        "id": 433876466,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1713388682
    },
    {
        "content": "<p>Lean allows it in <code>fun</code>, but there's some inconsistency between various notations that accept binders. The main issue is that if you allow destructuring, you get a <code>match</code> expression in the body of your quantifier.</p>",
        "id": 433876655,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713388793
    },
    {
        "content": "<p>Is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NumberField.Units.exist_unique_eq_mul_prod#doc\">docs#NumberField.Units.exist_unique_eq_mul_prod</a> (the Dirichlet unit theorem) stated correctly?</p>",
        "id": 433878986,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713389953
    },
    {
        "content": "<p>My guess is no, and that the assertion is too weak</p>",
        "id": 433884110,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713392643
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> <a href=\"https://github.com/leanprover-community/mathlib4/pull/12237\">#12237</a></p>",
        "id": 434005204,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713432462
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Thanks — here's a fix <a href=\"https://github.com/leanprover-community/mathlib4/pull/12240\">#12240</a></p>",
        "id": 434009027,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713433796
    }
]