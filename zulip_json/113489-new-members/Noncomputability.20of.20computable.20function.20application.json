[
    {
        "content": "<p>I recently came up with a proof of the statement <code>¬Computable₂ fun (f : NatComputable) (n : ℕ) =&gt; f n</code>, where <code>NatComputable</code> is defined as <code>{ f : ℕ → ℕ // Computable f }</code>. However, I don't completely understand <em>why</em> this is true. (My proof was a proof by contradiction in the style of Lawvere's theorem, but \"assuming the opposite allows you to prove False\" isn't a very satisfying explanation.)</p>\n<p>I would think that applying a computable function would itself be a computable function. However, this is clearly not the case. Could anyone help me gain a deeper understanding of why function application isn't computable?</p>",
        "id": 424785360,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709607569
    },
    {
        "content": "<p>Does <code>Computable</code> give you an explicit algorithm for it, or just gives you a guarantee that such an algorithm exists?</p>",
        "id": 424786013,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1709607966
    },
    {
        "content": "<p>well it's a Prop so I don't think you can extract the algorithm, but if you look at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.Partrec#doc\">docs#Nat.Partrec</a> you can see that the type itself is explicit</p>",
        "id": 424786344,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709608155
    },
    {
        "content": "<p><code>Computable</code> is just <code>Partrec</code> with total functions, and <code>Partrec</code> is just a wrapper around <code>Nat.Partrec</code> with encoding/decoding</p>",
        "id": 424786558,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709608253
    },
    {
        "content": "<p>You don't want to extract the algorithm, it's hilariously terrible</p>",
        "id": 424787157,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709608708
    },
    {
        "content": "<p>I guess that's the issue, you can't have a universal algorithm for computing a function just because you know in theory that it is computable</p>",
        "id": 424787160,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1709608712
    },
    {
        "content": "<p>but you could, in principle</p>",
        "id": 424787199,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709608749
    },
    {
        "content": "<p>I'm not sure what algorithm we're talking about extracting since I'm asking about a proof that function application <em>isn't</em> computable</p>",
        "id": 424787344,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709608829
    },
    {
        "content": "<p>I'm not sure I would describe it as function application, it's more like a universal turing machine</p>",
        "id": 424787415,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709608893
    },
    {
        "content": "<p>I don't know what would be the most intuitive \"explanation\" for your theorem; for example that function grows faster than any computable function so it can't be computable</p>",
        "id": 424787601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709609016
    },
    {
        "content": "<p>that's a good point</p>",
        "id": 424787751,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709609115
    },
    {
        "content": "<p>How is <code>NatComputable</code> primcoded?</p>",
        "id": 424787886,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709609220
    },
    {
        "content": "<p>I think this theorem might be trivial, <code>NatComputable</code> doesn't look like it would have any sensible <code>Primcodable</code> instance</p>",
        "id": 424787946,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709609276
    },
    {
        "content": "<p>I proved that it was <code>Countable</code> and <code>Infinite</code> and then chose a <code>Denumerable</code> instance using Choice</p>",
        "id": 424788040,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709609332
    },
    {
        "content": "<p>oof</p>",
        "id": 424788043,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709609337
    },
    {
        "content": "<p>haha yeah, I know</p>",
        "id": 424788052,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709609345
    },
    {
        "content": "<p>and then I relied on the fact that <code>Denumerable.ofNat</code> is \"computable\" to create a fixed point around <code>Nat.succ</code></p>",
        "id": 424788096,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709609394
    },
    {
        "content": "<p>it was definitely hacky</p>",
        "id": 424788113,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709609402
    },
    {
        "content": "<p>It might be interesting to prove that every <code>Primcodable NatComputable</code> instance is pathological in some way</p>",
        "id": 424788168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709609429
    },
    {
        "content": "<p>You should probably be able to prove your theorem generic over the <code>Primcodable NatComputable</code> instance</p>",
        "id": 424788190,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709609457
    },
    {
        "content": "<p>not sure what you mean by \"generic\"</p>",
        "id": 424788279,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709609534
    },
    {
        "content": "<p>Take that instance as an argument to the theorem instead of proving it about one particular choice</p>",
        "id": 424788293,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709609558
    },
    {
        "content": "<p>Note that with your definition, I'm not even sure you can evaluate <code>app 0 0</code>, so it's not going to be computable in a very literal sense</p>",
        "id": 424788330,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709609594
    },
    {
        "content": "<p>yeah, I realize the whole thing is noncomputable in a sense</p>",
        "id": 424788456,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709609734
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Noncomputability.20of.20computable.20function.20application/near/424788168\">said</a>:</p>\n<blockquote>\n<p>It might be interesting to prove that every <code>Primcodable NatComputable</code> instance is pathological in some way</p>\n</blockquote>\n<p>I suppose your theorem is essentially proving this (especially if you generalize over the instance instead of using the one you found using choice): there is no \"nice\" instance you can pick which makes function application computable</p>",
        "id": 424788457,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709609734
    },
    {
        "content": "<p>right</p>",
        "id": 424788475,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709609760
    },
    {
        "content": "<p>that is possibly another way to answer your question about why the theorem should be true: there are ways to enumerate turing machines, but (1) you don't know when you have enumerated the same machine twice and (2) you don't know if it halts. Using choice to solve both issues results in an enumeration which has unknowably scrambled things and now you can't evaluate it</p>",
        "id": 424788642,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709609847
    },
    {
        "content": "<p>ah, true</p>",
        "id": 424788720,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709609911
    }
]