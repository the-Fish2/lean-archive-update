[
    {
        "content": "<p>Hi, newbie here.</p>\n<p>I'm trying to define an inductive dependent type:</p>\n<p>variable {α : Type} [LinearOrder α]</p>\n<p>inductive Tree : Type<br>\n| leaf : Tree<br>\n| node (value : α) (left : Tree) (right : Tree) : Tree<br>\nderiving Repr</p>\n<p>I can easily make an example instance and evaluate it<br>\ndef example_tree := Tree.node 1 Tree.leaf Tree.leaf<br>\n#eval example_tree  -- Tree.node 1 (Tree.leaf) (Tree.leaf)</p>\n<p>However when trying to implement a new function dependent on this type I get a message<br>\ndef is_heap : Tree → Prop<br>\n  | Tree.leaf =&gt; true<br>\n  | Tree.node v l r =&gt;<br>\n    (match l with<br>\n    | Tree.leaf =&gt; true<br>\n    | Tree.node lv _ _ =&gt; lv ≤ v )<br>\n    ∧ (match r with<br>\n    | Tree.leaf =&gt; true<br>\n    | Tree.node rv _ _ =&gt; rv ≤ v)<br>\n    ∧ is_heap l<br>\n    ∧ is_heap r</p>\n<p>don't know how to synthesize implicit argument<br>\n  @Tree ?m.1202<br>\ncontext:<br>\nα: Type<br>\ninst✝: LinearOrder α<br>\n⊢ Type</p>\n<p>when the resulting type of a declaration is explicitly provided, all holes (e.g., <code>_</code>) in the header are resolved before the declaration body is processed.</p>\n<p>What is the problem?</p>",
        "id": 421310468,
        "sender_full_name": "Roey Hel-Or",
        "timestamp": 1707852148
    },
    {
        "content": "<p>Neither this syntax work: def is_heap (t : Tree) : Prop :=</p>\n<p>Or this one as well: def is_heap (t : Tree α) : Prop :=<br>\n(Error now is:<br>\nfunction expected at<br>\n  Tree<br>\nterm has type<br>\n  Type<br>\n)</p>",
        "id": 421310823,
        "sender_full_name": "Roey Hel-Or",
        "timestamp": 1707852286
    },
    {
        "content": "<p>It would be better to make <code>α</code> be an explicit variable to <code>Tree</code>, since otherwise Lean can't really figure out what this argument should be.</p>",
        "id": 421333744,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707862194
    },
    {
        "content": "<p>note: <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a></p>",
        "id": 421333765,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707862205
    },
    {
        "content": "<p>For example, set up your type with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Tree</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>That then makes <code>α</code> be implicit afterwards.</p>",
        "id": 421333912,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707862284
    }
]