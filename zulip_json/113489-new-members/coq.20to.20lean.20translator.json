[
    {
        "content": "<p>Has there been any effort to write a Coq to Lean translator? Has anybody thought of the issues in such a project<br>\nThe only discussion I could find is <a href=\"#narrow/stream/113489-new-members/topic/Beginner's.20Question/near/273058665\">this</a> one which I could not follow. I guess defeq means definitional equality in that post? I do see that the mismatch of definitional equality poses some complexity but to me those are far from unsurmountable.<br>\nI am not super familiar with Lean 4, but it seems more like an extensional dependent type theory, similar to Nuprl. <br>\nI do know Coq and Nuprl quite well and I would say it is very much possible to write a very useful translator from Coq to Nuprl, although it may take months to perfect.</p>",
        "id": 429521410,
        "sender_full_name": "Abhishek Anand",
        "timestamp": 1711405631
    },
    {
        "content": "<p>yes, defeq = definitional equality</p>",
        "id": 429522225,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1711406119
    },
    {
        "content": "<p>(And thanks for digging up the link: I found it useful. I cannot add anything to this.)</p>",
        "id": 429522340,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1711406180
    },
    {
        "content": "<p>I'm not an expert in this area but having watched several of these conversations go by in the past, one observation is that there might not be much point making such a translator, because it will not translate idiomatic Coq into idiomatic Lean so it's not clear how to use the output of such a translator effectively.</p>",
        "id": 429524050,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1711407146
    },
    {
        "content": "<blockquote>\n<p>it will not translate idiomatic Coq into idiomatic Lean </p>\n</blockquote>\n<p>yes, naive ways to do this translation will suffer from this problem. but again, I don't really see why this problem is unsurmountable. the translator can be tailored to take into account such idioms</p>",
        "id": 429525000,
        "sender_full_name": "Abhishek Anand",
        "timestamp": 1711407618
    },
    {
        "content": "<p>We now have a much better answer to this question. Doing an approximate Lean 3 to Lean 4 translator was already extremely challenging and not producing fully working code. Anything else will be much harder.</p>",
        "id": 429526130,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1711408107
    },
    {
        "content": "<p>So this problem is simply much harder than what optimistic people think.</p>",
        "id": 429526227,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1711408161
    },
    {
        "content": "<p>do you have any specifics on the challenging issues? Getting idiomatic code may be harder largely because the idioms are not very formally/precisely defined, but I am skeptical of the difficulty of getting working code: people have built (verified) compilers between very different languages</p>",
        "id": 429526949,
        "sender_full_name": "Abhishek Anand",
        "timestamp": 1711408507
    },
    {
        "content": "<p>I am pretty sure the examples you have any mind do not involve anything like an elaborator.</p>",
        "id": 429527279,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1711408671
    },
    {
        "content": "<p>yes, but the translation input doesn't need to be the unelaborated src file. For example, in certicoq (Coq-&gt;C), we got access to the fully elaborated AST</p>",
        "id": 429527517,
        "sender_full_name": "Abhishek Anand",
        "timestamp": 1711408805
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259905\">Abhishek Anand</span> <a href=\"#narrow/stream/113489-new-members/topic/coq.20to.20lean.20translator/near/429521410\">said</a>:</p>\n<blockquote>\n<p>I am not super familiar with Lean 4, but it seems more like an extensional dependent type theory, similar to Nuprl.</p>\n</blockquote>\n<p>No, it is not an extensional type theory. If it was things would probably be a lot simpler, but it is similar to Coq in this respect. If you have an equality which is not a defeq then there is no way to upgrade it to one, so if this is an equality of types then you need to insert <code>cast</code> functions to coerce elements of those types across the equality, and then you need coherence lemmas for the <code>cast</code>s and everything sort of piles up. It's possible that in practice the complexity stays bounded but the worst case is very bad.</p>",
        "id": 429528957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711409726
    },
    {
        "content": "<p>To be honest, my experience with the lean 3 -&gt; lean 4 translation actually made me <em>more</em> positive on the possibility of Coq to Lean translation, at the <em>syntax</em> level. Translating already-elaborated terms will result in a mess <em>even if</em> you somehow manage to solve all the theory issues I mentioned in that earlier post, but syntax translation and manual cleanup can get you a long way and result in something reasonably idiomatic at the end as well. This is especially important given that both Coq and Lean have a tendency toward tactic style proofs, while the kernel terms are completely different. Throwing away the tactic structure and translating at the term level will result in something which can only be used as a black box, and it would be a lot closer to \"compilation\" than \"translation\".</p>",
        "id": 429529255,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711409976
    },
    {
        "content": "<p>Of course, you can still do syntax -&gt; syntax translation using the elaborated information as an interpretation hint. Lean 4 is good at providing that kind of information, but Coq -&gt; Lean translation would require it from Coq and I'm not sure how feasible that is (it might be okay, I don't have enough information on the matter).</p>",
        "id": 429529428,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711410090
    },
    {
        "content": "<p>for projects like iris-lean, which is what motivated me to think about this translation, it may be fine for me if the translator produces only kernel terms (no tactic scripts) for proofs. (it would help for the definitions to be lean-idiomatic though)<br>\nultimately, the ground truth of iris will live in Coq, at least for now, so there is not much point IMO in editing those proofs in lean.<br>\nI have been <em>using</em> iris in Coq for several years and built hundreds of proofs on top of it, but never ever needed to look at a proof script inside iris anyway.</p>",
        "id": 429531801,
        "sender_full_name": "Abhishek Anand",
        "timestamp": 1711411633
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/coq.20to.20lean.20translator/near/429528957\">said</a>:</p>\n<blockquote>\n<p>No, it is not an extensional type theory. If it was things would probably be a lot simpler, but it is similar to Coq in this respect. If you have an equality which is not a defeq then there is no way to upgrade it to one, so if this is an equality of types then you need to insert <code>cast</code> functions to coerce elements of those types across the equality, and then you need coherence lemmas for the <code>cast</code>s and everything sort of piles up. It's possible that in practice the complexity stays bounded but the worst case is very bad.</p>\n</blockquote>\n<p>Do you have example of two definitionally equal terms in Coq whose \"idiomatic\" translations to Lean will not be definitionally equal? I thought Lean had strictly more definitional equalities.</p>",
        "id": 429532708,
        "sender_full_name": "Abhishek Anand",
        "timestamp": 1711412251
    },
    {
        "content": "<p>Anything making use of universe cumulativity won't be expressible in Lean without a <code>ULift</code></p>",
        "id": 429536579,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711415033
    },
    {
        "content": "<p>it's a bit difficult to get an example which is as \"crisp\" as your request; mostly there are just a bunch of features where the translation is a bit of a ??? but where there is a mostly okay translation choice you can make, and then when you combine enough of those mostly okay translations you get something that is not okay</p>",
        "id": 429536709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711415130
    },
    {
        "content": "<p>The most obvious ??? is Coq's fixed universes and the whole partial order of constraints on these universes. Lean has no analogue of this, but Coq makes use of them extremely frequently and it is quite difficult syntactically not to introduce them</p>",
        "id": 429536808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711415202
    }
]