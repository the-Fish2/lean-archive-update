[
    {
        "content": "<p>When you apply the <em>simp</em> tactic, I'm wondering what the algorithm is to filter which simplification rules to try. I'm just fascinated by how it works so quickly. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> Given there are thousands of rules.</p>\n<p>The way I'd probably go about it, if I were to attempt to implement it might be:</p>\n<ul>\n<li>Order simplification rules from smallest to largest</li>\n<li>Create a dictionary of every atomic term in every simplification rule. e.g. \"zero\"=0, \"S\"=1, \"add\"=2</li>\n<li>Against each word store the number of each simplification rule that contains that word (reverse index)</li>\n<li>Sort dictionary by rarest word to most common</li>\n<li>Precompute the set of atomic terms for each simplification rule. </li>\n<li>Translate those into numbers from the dictionary. So the expression might have R[3]={3,6,4,14}</li>\n<li>Collect a set of the atomic terms in the expression. e.g. E= {5,6,11,17}</li>\n<li>Using the reverse index start with the rarest word and start filtering the rules.</li>\n<li>\n<p>Try each rule from the filtered list in turn until find a match.</p>\n</li>\n<li>\n<p>Could possibly do something clever by noting which parts of the formula had changed. e.g. it would be no good trying to match a sub expression in the same place again if that part of the tree hadn't changed.</p>\n</li>\n<li>Repeat</li>\n</ul>\n<p>Is this something close to what's done? Or is it more heuristically based?</p>\n<p>Maybe filtering the sentences would actually be more costly than just trying each one at each point in the tree.</p>",
        "id": 446741540,
        "sender_full_name": "Mr Proof",
        "timestamp": 1719272390
    },
    {
        "content": "<p>I do not know much about it, but I believe a keyword search term is \"discrimination tree\".</p>",
        "id": 446743028,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1719273262
    }
]