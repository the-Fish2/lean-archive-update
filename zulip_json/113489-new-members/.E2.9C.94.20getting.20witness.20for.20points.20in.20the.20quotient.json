[
    {
        "content": "<p>I have two points <code>qx qy</code> in a quotient space (SeparationQuotient X) - how can I grab witnesses <code>x y</code> with <code>mk x= qx</code> and <code>mk y=qy</code>?</p>",
        "id": 435771438,
        "sender_full_name": "Steven Clontz",
        "timestamp": 1714235554
    },
    {
        "content": "<p>Ah, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Core.html#Quotient.exists_rep\">https://leanprover-community.github.io/mathlib4_docs/Init/Core.html#Quotient.exists_rep</a></p>",
        "id": 435771686,
        "sender_full_name": "Steven Clontz",
        "timestamp": 1714235790
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"468051\">Steven Clontz</span> has marked this topic as resolved.</p>",
        "id": 435772343,
        "sender_full_name": "Notification Bot",
        "timestamp": 1714236336
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"468051\">@Steven Clontz</span> this is extremely rarely useful, much more rare than what Lean beginner expect. My advice is to paste here a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> where you think you need it.</p>",
        "id": 435780285,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1714242437
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"468051\">Steven Clontz</span> has marked this topic as unresolved.</p>",
        "id": 435785579,
        "sender_full_name": "Notification Bot",
        "timestamp": 1714247874
    },
    {
        "content": "<p>Sure, it's worth documenting the preferred way to do things. I was able to use that to close my goal, but I suspected there was a slicker way. Give me a moment to create that <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 435785676,
        "sender_full_name": "Steven Clontz",
        "timestamp": 1714247952
    },
    {
        "content": "<p><code>induction qx using Quotient.inductionOn</code> is often a better choice</p>",
        "id": 435785862,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714248108
    },
    {
        "content": "<p>Ooh, I see a very similar result at <a href=\"https://github.com/leanprover-community/mathlib4/blob/a9286932d8eeee7184c919d96a734dadf661bf96/Mathlib/Topology/Separation.lean#L269C1-L272C1\">https://github.com/leanprover-community/mathlib4/blob/a9286932d8eeee7184c919d96a734dadf661bf96/Mathlib/Topology/Separation.lean#L269C1-L272C1</a> that will provide clues.</p>\n<p>Here is the WIP: <a href=\"https://github.com/leanprover-community/mathlib4/blob/a9286932d8eeee7184c919d96a734dadf661bf96/Mathlib/Topology/Separation.lean#L930\">https://github.com/leanprover-community/mathlib4/blob/a9286932d8eeee7184c919d96a734dadf661bf96/Mathlib/Topology/Separation.lean#L930</a> I'm going to take a swing at sprucing up things myself with this new lead.</p>",
        "id": 435786023,
        "sender_full_name": "Steven Clontz",
        "timestamp": 1714248270
    },
    {
        "content": "<p>Patrick's point is that often on paper we say \"now choose an arbitrary representative, do something, and check that what we just did was well-defined\", whereas in Lean we instead say \"now use the universal property of quotients\" (and Eric explained how to do this). The issue with doing something and then checking that it's \"well-defined\" is that in Lean the act of choosing a random element of an equivalence class is already well-defined by the axiom of choice (which in Lean picks a preferred element of every non-empty set at the beginning of time), so now doing the thing to that arbitrary representative is also well-defined.</p>",
        "id": 435786183,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1714248450
    },
    {
        "content": "<p>I've made <a href=\"https://github.com/leanprover-community/mathlib4/pull/12471\">#12471</a> to show how to adapt <code>exists_rep</code> code to <code>induction</code></p>",
        "id": 435786459,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714248756
    },
    {
        "content": "<p>The \"choosing a random element\" approach via <code>exists_rep</code> is mostly fine, and doesn't run into the awkwardness with uniqueness that Kevin mentions; it's just clumsy, because the first thing you do with that is induct on the existential, then induct on the equality. Better to just induct on the right thing in the first place.</p>",
        "id": 435786506,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714248829
    },
    {
        "content": "<p>Steven, the issue we have with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">t1Space_TFAE</span> <span class=\"o\">(</span><span class=\"n\">SeparationQuotient</span> <span class=\"n\">X</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">out</span> <span class=\"mi\">0</span> <span class=\"mi\">9</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>is a very annoying elaboration issue. You can tell Lean to change strategy using a smiley annotation <code>:)</code>. The full explanation is a bit technical but you can remember to try that when Lean misbehaves in this specific way. Here this allows <code>rw [(t1Space_TFAE (SeparationQuotient X)).out 0 9 :)]</code>.</p>",
        "id": 435788752,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1714251133
    },
    {
        "content": "<p>Next, in addition to what Eric wrote, <code>rintro</code> know about quotients so you can use <code>rintro h ⟨x⟩ ⟨y⟩ sxspecsy</code> in you second branch. This gets rid of needing to rewrite later, but it creates a goal that is not syntactically the one you want, although it is definitely definitionaly equal to what you hope for.</p>",
        "id": 435788877,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1714251251
    },
    {
        "content": "<p>Note also that the combination</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">Inducing.specializes_iff</span> <span class=\"bp\">?</span><span class=\"n\">hf</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">h</span>\n    <span class=\"n\">exact</span> <span class=\"n\">SeparationQuotient.inducing_mk</span>\n</code></pre></div>\n<p>is very verbose. You can replace it with <code>exact inducing_mk.specializes_iff.mpr h</code>.</p>",
        "id": 435788943,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1714251355
    },
    {
        "content": "<p>This uses dot notation and the fact that the <code>SeparationQuotient</code> namespace is open to abbreviate <code>Inducing.specializes_iff SeparationQuotient.inducing_mk</code> to <code>inducing_mk.specializes_iff</code>.</p>",
        "id": 435789037,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1714251438
    },
    {
        "content": "<p>All this allows to easily clean up the proof down to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">SeparationQuotient.t1Space_iff</span> <span class=\"o\">:</span> <span class=\"n\">T1Space</span> <span class=\"o\">(</span><span class=\"n\">SeparationQuotient</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">R0Space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">r0Space_iff</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"n\">t1Space_TFAE</span> <span class=\"o\">(</span><span class=\"n\">SeparationQuotient</span> <span class=\"n\">X</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">out</span> <span class=\"mi\">0</span> <span class=\"mi\">9</span> <span class=\"o\">:)]</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">xspecy</span>\n    <span class=\"n\">apply</span> <span class=\"n\">inducing_mk.specializes_iff.mp</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">mk</span> <span class=\"n\">x</span> <span class=\"bp\">⤳</span> <span class=\"n\">mk</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">inducing_mk.specializes_iff.mpr</span> <span class=\"n\">xspecy</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"n\">this</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"n\">h</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">⟩</span> <span class=\"n\">sxspecsy</span>\n    <span class=\"k\">have</span> <span class=\"n\">xspecy</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⤳</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">inducing_mk.specializes_iff.mp</span> <span class=\"n\">sxspecsy</span>\n    <span class=\"k\">have</span> <span class=\"n\">yspecx</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">⤳</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"n\">xspecy</span>\n    <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">mk_eq_mk</span><span class=\"o\">,</span> <span class=\"n\">inseparable_iff_specializes_and</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">xspecy</span><span class=\"o\">,</span> <span class=\"n\">yspecx</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 435789115,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1714251490
    },
    {
        "content": "<p>But one could clean it up further using a custom induction principle.</p>",
        "id": 435789150,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1714251525
    },
    {
        "content": "<p>The custom induction principle allows to get rid of the syntactic spelling mismatch because you can enforce the spelling you want. Something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">SeparationQuotient.induction_on₂</span>  <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"n\">SeparationQuotient</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">SeparationQuotient</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">q₁</span> <span class=\"o\">:</span> <span class=\"n\">SeparationQuotient</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q₂</span> <span class=\"o\">:</span> <span class=\"n\">SeparationQuotient</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">),</span> <span class=\"n\">δ</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n<span class=\"n\">δ</span> <span class=\"n\">q₁</span> <span class=\"n\">q₂</span> <span class=\"o\">:=</span> <span class=\"n\">Quot.induction_on₂</span> <span class=\"n\">q₁</span> <span class=\"n\">q₂</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 435789775,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1714252062
    },
    {
        "content": "<p>Which allows to get rid of the <code>erw</code> to get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">SeparationQuotient.t1Space_iff</span> <span class=\"o\">:</span> <span class=\"n\">T1Space</span> <span class=\"o\">(</span><span class=\"n\">SeparationQuotient</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">R0Space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">r0Space_iff</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"n\">t1Space_TFAE</span> <span class=\"o\">(</span><span class=\"n\">SeparationQuotient</span> <span class=\"n\">X</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">out</span> <span class=\"mi\">0</span> <span class=\"mi\">9</span> <span class=\"o\">:)]</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">xspecy</span>\n    <span class=\"n\">apply</span> <span class=\"n\">inducing_mk.specializes_iff.mp</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">mk</span> <span class=\"n\">x</span> <span class=\"bp\">⤳</span> <span class=\"n\">mk</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">inducing_mk.specializes_iff.mpr</span> <span class=\"n\">xspecy</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"n\">this</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">refine</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">↦</span> <span class=\"n\">induction_on₂</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n    <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">spec</span>\n    <span class=\"k\">have</span> <span class=\"n\">xspecy</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⤳</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">inducing_mk.specializes_iff.mp</span> <span class=\"n\">spec</span>\n    <span class=\"k\">have</span> <span class=\"n\">yspecx</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">⤳</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"n\">xspecy</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mk_eq_mk</span><span class=\"o\">,</span> <span class=\"n\">inseparable_iff_specializes_and</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">xspecy</span><span class=\"o\">,</span> <span class=\"n\">yspecx</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 435789826,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1714252089
    },
    {
        "content": "<p>But the refine line is ugly, so this is probably still not the optimal setup.</p>",
        "id": 435789836,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1714252106
    },
    {
        "content": "<p>In a similar spirit you can define a specialized version of <code>Quotient.forall</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">SeparationQuotient.forall</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">SeparationQuotient</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">SeparationQuotient</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient.forall</span>\n</code></pre></div>",
        "id": 435790181,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1714252539
    },
    {
        "content": "<p>At that point you are allowed to grow tired of this theorem and simply throw the ingredients at Lean, trusting <code>aesop</code> can do stupid logic for you:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">SeparationQuotient.t1Space_iff</span> <span class=\"o\">:</span> <span class=\"n\">T1Space</span> <span class=\"o\">(</span><span class=\"n\">SeparationQuotient</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">R0Space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">r0Space_iff</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"n\">t1Space_TFAE</span> <span class=\"o\">(</span><span class=\"n\">SeparationQuotient</span> <span class=\"n\">X</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">out</span> <span class=\"mi\">0</span> <span class=\"mi\">9</span> <span class=\"o\">:),</span>\n    <span class=\"n\">SeparationQuotient.forall</span><span class=\"o\">,</span> <span class=\"n\">Symmetric</span><span class=\"o\">,</span> <span class=\"n\">inducing_mk.specializes_iff</span><span class=\"o\">,</span> <span class=\"n\">mk_eq_mk</span><span class=\"o\">,</span>\n    <span class=\"n\">inseparable_iff_specializes_and</span><span class=\"o\">]</span>\n  <span class=\"n\">aesop</span>\n</code></pre></div>",
        "id": 435790269,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1714252651
    },
    {
        "content": "<p>Thanks everyone for your thoughtful feedback. I'll get some code written soon, but likely not this evening. (It sounds like Patrick is suggesting a slick proof, but I want to work through it all myself of course.)</p>\n<p>I've seen this a couple times from the Lean community, so I'll ask. When I'm doing informal mathematics, AC is not required to pick a representative from two equivalence classes: the definition of non-empty is that there exists some element, so I can choose that witness. If I have two or seven empty sets, there's similarly no problem; AC is only required when I have an infinite family of sets that I need arbitrary elements from. So I'm a little confused when Lean folks express concerns about using Choice when there's just a couple sets that need choices - what subtlety am I missing here?</p>",
        "id": 435795503,
        "sender_full_name": "Steven Clontz",
        "timestamp": 1714258511
    },
    {
        "content": "<p>In dependent type theory, the thing people call \"the axiom of choice\" is a different thing, as you are observing. The thing which in Lean is called the axiom of choice is the act of moving from the <code>Prop</code> universe to the <code>Type</code> universe, so, for example, going from an existence statement to a witness. In particular in Lean it is <em>not</em> true that you can choose a witness from a nonempty type without AC, but what you really need to understand here is that set theory and type theory are just different ways of setting up the foundations of mathematics, and so in some sense it does not even make sense to say that some axiom of type theory corresponds to another axiom of set theory, even if (as in this case) they happen to be called the same thing.</p>",
        "id": 435795719,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1714258736
    },
    {
        "content": "<p>Ah, that's very good to know!</p>",
        "id": 435795831,
        "sender_full_name": "Steven Clontz",
        "timestamp": 1714258819
    },
    {
        "content": "<p>Here is another way of looking at it. Lean's version of AC is a super-strong version, which the set theorists might call Hilbert's Epsilon Operator. It looks pretty innocuous -- it's a function which given a proof that there exists an x satisfying P(x), spits out an explicit x. But given that this function exists you can think of it as being a choice, once and for all, of an element of every nonempty type, chosen at the beginning of time. The type theory version of the usual set-theoretic axiom of choice follows from this immediately: given a product of nonempty types, use the epsilon operator (i.e. the choose function) to choose the canonical element in each one of the types in the product, and there's your element of the product type.</p>",
        "id": 435795947,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1714258928
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"468051\">Steven Clontz</span> <a href=\"#narrow/stream/113489-new-members/topic/getting.20witness.20for.20points.20in.20the.20quotient/near/435795503\">said</a>:</p>\n<blockquote>\n<p>Thanks everyone for your thoughtful feedback. I'll get some code written soon, but likely not this evening. (It sounds like Patrick is suggesting a slick proof, but I want to work through it all myself of course.)</p>\n</blockquote>\n<p>I have explicitly tried to avoid suggesting any specific choice among the various things I mentioned. I tried to show you several ways you can experiment with. This final proof using aesop is interesting in suggesting that an automated theorem prover should be able to do this completely autonomously. But I would understand if you find it frustrating and obfuscating, I’m not pushing towards using it.</p>",
        "id": 435919903,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1714349050
    },
    {
        "content": "<p>Well that's good news, because ultimately I did not implement any of your suggestions strictly verbatim (nor did I intend to). But again, thank you for the feedback; I decided the <code>rintro</code> tactic you suggested was the best tool to elegantly close this goal without too much magic obfuscating the idea of the proof.  <a href=\"https://github.com/leanprover-community/mathlib4/pull/12458\">#12458</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">SeparationQuotient.t1Space_iff</span> <span class=\"o\">:</span> <span class=\"n\">T1Space</span> <span class=\"o\">(</span><span class=\"n\">SeparationQuotient</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">R0Space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">r0Space_iff</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"n\">t1Space_TFAE</span> <span class=\"o\">(</span><span class=\"n\">SeparationQuotient</span> <span class=\"n\">X</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">out</span> <span class=\"mi\">0</span> <span class=\"mi\">9</span> <span class=\"o\">:)]</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">xspecy</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Inducing.specializes_iff</span> <span class=\"n\">inducing_mk</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">xspecy</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"n\">h</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">⟩</span> <span class=\"n\">sxspecsy</span>\n    <span class=\"k\">have</span> <span class=\"n\">xspecy</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⤳</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Inducing.specializes_iff</span> <span class=\"n\">inducing_mk</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">sxspecsy</span>\n    <span class=\"k\">have</span> <span class=\"n\">yspecx</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">⤳</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"n\">xspecy</span>\n    <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">mk_eq_mk</span><span class=\"o\">,</span> <span class=\"n\">inseparable_iff_specializes_and</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span> <span class=\"n\">xspecy</span><span class=\"o\">,</span> <span class=\"n\">yspecx</span> <span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 435930658,
        "sender_full_name": "Steven Clontz",
        "timestamp": 1714356659
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"468051\">Steven Clontz</span> has marked this topic as resolved.</p>",
        "id": 435930665,
        "sender_full_name": "Notification Bot",
        "timestamp": 1714356663
    }
]