[
    {
        "content": "<p>In Mathlib.Topology.Basic, the openness property <code>IsOpen</code> is implemented with <code>def</code>, while <code>IsClosed</code> is a <code>class</code>. What's the difference, why are they implemented this way, and why is neither of them a <code>structure</code>, which I thought would be the simplest way to wrap a property into a named object?</p>",
        "id": 416330706,
        "sender_full_name": "Ilkka Törmä",
        "timestamp": 1705523266
    },
    {
        "content": "<p>I'm very surprised to find out that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsClosed#doc\">docs#IsClosed</a> is a <code>class</code></p>",
        "id": 416339974,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705527391
    },
    {
        "content": "<p>The change was in <a href=\"https://github.com/leanprover-community/mathlib/pull/6552\">!3#6552</a>; where <span class=\"user-mention\" data-user-id=\"110050\">@Sébastien Gouëzel</span>  writes:</p>\n<blockquote>\n<p>In <code>lean-liquid</code>, it would be useful that <code>is_closed</code> would be a class, to be able to infer a normed space structure on <code>E/F</code> when <code>F</code> is a closed subspace of a normed space <code>E</code>.</p>\n</blockquote>",
        "id": 416340256,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705527498
    },
    {
        "content": "<p>Yep, that's the reason: to infer nice behavior of quotient spaces <code>G / H</code>  through typeclass inference, the typeclass inference mechanism needs to be able to see that <code>H</code> is closed, and this is only possible if <code>IsClosed</code> is a class.</p>",
        "id": 416512815,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1705563460
    },
    {
        "content": "<p>fwiw, I think another option might have been to use <code>[Fact (IsClosed H)]</code>.</p>",
        "id": 416513991,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1705564015
    },
    {
        "content": "<p>We didn't have that option with things like <code>[Fact (r &lt; 1)]</code> in LTE because making <code>LT.lt</code> a class would probably not have gone down well, but in this situation what are the advantages/disadvantages of the two choices (Fact / no Fact)? At the end of the day are they basically the same thing?</p>",
        "id": 416549868,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705576741
    },
    {
        "content": "<p>I think the main disadvantage is the weird asymmetry it creates between <code>IsOpen</code> and <code>IsClosed</code></p>",
        "id": 416552236,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705577656
    },
    {
        "content": "<p>I think <code>Fact</code> would have a been a better choice here, as we use it already for things like <code>ZMod.field</code></p>",
        "id": 416552470,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705577732
    },
    {
        "content": "<p>Maybe a good idea would be to also make <code>IsOpen</code>a class, then, as quotienting by open subgroups also has very nice properties.</p>",
        "id": 416555607,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1705578995
    },
    {
        "content": "<p>All open subgroups are closed though ;-) (consider a cover by cosets)</p>",
        "id": 416557266,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705579603
    },
    {
        "content": "<p>An idea I think would be very interesting is a new binder type that's like <code>{...}</code> binders, but which get solved for <code>by assumption</code>, especially if instances can use these binders.</p>\n<p>It's like being able to use <code>Fact</code> with all local hypotheses without needing to create <code>Fact</code> instances.</p>",
        "id": 416558246,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705579993
    },
    {
        "content": "<p>couldn't you just literally do <code>(x : T := by assumption)</code>?</p>",
        "id": 416558418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705580054
    },
    {
        "content": "<p>oh I missed the thing about instances</p>",
        "id": 416558481,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705580078
    },
    {
        "content": "<p>I'm going to put another nickel in my jar of \"reasons we should be allowed to have tactics in instance search\"</p>",
        "id": 416558568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705580112
    },
    {
        "content": "<p>Yeah, and it's also a bit different from default arguments because I'd want them to behave like implicit arguments (i.e., no passing them positionally)</p>",
        "id": 416558592,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705580123
    },
    {
        "content": "<p>we could have <code>{x : T := by assumption}</code> too</p>",
        "id": 416558800,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705580198
    },
    {
        "content": "<p>An inspiration here is GHC's obscure <a href=\"https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/implicit_parameters.html\">implicit parameters</a> feature, but it seems like it would see more use in Lean land, to help with passing facts around, rather than data.</p>",
        "id": 416559003,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705580275
    },
    {
        "content": "<p>Also, the feature I'm proposing is different in that the GHC one is by name, but mine is by type. Having some ability to try to capture variables by name would be interesting though -- we'd be able to recover <code>parameter</code> variables in some form.</p>",
        "id": 416559487,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705580428
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/IsOpen.20vs.2E.20IsClosed/near/416557266\">said</a>:</p>\n<blockquote>\n<p>All open subgroups are closed though ;-) (consider a cover by cosets)</p>\n</blockquote>\n<p>Sure. But quotients by open subgroups are even better behaved than quotients by closed subgroups!</p>",
        "id": 416560296,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1705580731
    }
]