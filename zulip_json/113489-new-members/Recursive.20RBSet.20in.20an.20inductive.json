[
    {
        "content": "<p>Hi all, I was here a few days ago asking about putting recursive lists in inductives, now I'm trying to put recursive <code>RBSet</code>s in inductives. The problem is that I can't get the Ord instances to work out:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Batteries</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">RBMap</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Batteries</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RBSet</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ord</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ord</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">aux</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"bp\">.</span><span class=\"n\">eq</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"bp\">.</span><span class=\"n\">lt</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"bp\">.</span><span class=\"n\">gt</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">::</span><span class=\"n\">as</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">::</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">Ord</span><span class=\"bp\">.</span><span class=\"n\">compare</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"bp\">.</span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">aux</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">bs</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">o</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">compare</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">aux</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ord</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ord</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RBSet</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">Ord</span><span class=\"bp\">.</span><span class=\"n\">compare</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">compare</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Ord</span><span class=\"bp\">.</span><span class=\"n\">compare</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">unit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RBSet</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"w\"> </span><span class=\"n\">Ord</span><span class=\"bp\">.</span><span class=\"n\">compare</span><span class=\"o\">)</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Ord</span>\n</code></pre></div>\n<p>This should be valid in theory (the Ord instance is well-defined) but I can't tell if there's a way to convince Lean. Would love advice if you have any.</p>",
        "id": 443908368,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1718077556
    },
    {
        "content": "<p>I'm not sure the problem is in the Ord instance, because changing to <code>  | map (m : RBSet Value fun x y =&gt; Ordering.eq)</code> gives the same error message (<code>(kernel) arg #1 of 'Value.map' contains a non valid occurrence of the datatypes being declared</code>).</p>",
        "id": 443921876,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1718085997
    },
    {
        "content": "<p>I wonder if it helps to first define</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">unit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Batteries</span><span class=\"bp\">.</span><span class=\"n\">RBNode</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and define the well-formedness of a <code>Value</code> instance later.</p>",
        "id": 443937831,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1718092245
    },
    {
        "content": "<p>Yes the <code>RBNode</code> approach is the way to go here.</p>",
        "id": 443938777,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1718092567
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"686704\">Harry Goldstein</span> has marked this topic as resolved.</p>",
        "id": 444098324,
        "sender_full_name": "Notification Bot",
        "timestamp": 1718138949
    },
    {
        "content": "<p>Got it, thanks!</p>",
        "id": 444098373,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1718138979
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"686704\">Harry Goldstein</span> has marked this topic as unresolved.</p>",
        "id": 444098747,
        "sender_full_name": "Notification Bot",
        "timestamp": 1718139142
    },
    {
        "content": "<p>Hmm, I think there may still be an issue. If I define my well-formedness condition as a separate inductive, the proof that recursively contained values are actually well-formed can't be used for computation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"bp\">.</span><span class=\"n\">WF</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">wf_unit</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WF</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">wf_map</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">WF</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">WF</span><span class=\"w\"> </span><span class=\"n\">Ord</span><span class=\"bp\">.</span><span class=\"n\">compare</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"n\">WF</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Value</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">recursive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">WF</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">WF</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Value</span><span class=\"bp\">.</span><span class=\"n\">unit</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Value</span><span class=\"bp\">.</span><span class=\"n\">unit</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Value</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Value</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RBNode</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">recursive</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n</code></pre></div>\n<p>In that last line, I can't prove that <code>v</code> is a <code>{v : Value // v.WF}</code> because in order to do that I'd need to pattern match on <code>h</code> (which doesn't seem to be allowed).</p>",
        "id": 444100275,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1718139781
    },
    {
        "content": "<p>But one problem is that in <code>refine ⟨Value.map f m), ?_⟩</code>, <code>f</code> must take any <code>v : Value</code> as its argument, without the hypothesis <code>v ∈ m</code> so we cannot assert that the output of <code>f</code> is well-formed. Maybe there is an alternate version (or a better use pattern) of <code>map</code> that solves this problem.</p>",
        "id": 444132655,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1718158515
    },
    {
        "content": "<p>Even if we could show that <code>v ∈ m</code>, I'm not sure we could actually get to the proof that it is a valid <code>Value</code>, but yes, that's an issue too.</p>",
        "id": 444137913,
        "sender_full_name": "Harry Goldstein",
        "timestamp": 1718162075
    },
    {
        "content": "<p>This is where I got to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">recursive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">WF</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">WF</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Value</span><span class=\"bp\">.</span><span class=\"n\">unit</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Value</span><span class=\"bp\">.</span><span class=\"n\">unit</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Value</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">recursive</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">wf_map</span><span class=\"w\"> </span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">        </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">hv</span>\n<span class=\"w\">    </span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">f0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Value</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RBNode</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f0</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n<span class=\"w\">    </span><span class=\"n\">constructor</span>\n<span class=\"w\">    </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hmap</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f0</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">hmap</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">hv0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hv1</span><span class=\"bp\">⟩⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hv1</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">property</span>\n<span class=\"w\">    </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">RBNode</span><span class=\"bp\">.</span><span class=\"n\">WF</span><span class=\"w\"> </span><span class=\"n\">compare</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RBNode</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f0</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"gr\">sorry</span>\n<span class=\"w\">    </span><span class=\"n\">decreasing_by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 444142544,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1718165187
    },
    {
        "content": "<p>To do this you probably need something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.attach#doc\">docs#List.attach</a> for RBNode, which can then be composed with <code>RBNode.map</code> so that you have a condition to make the descent well founded. Ping <span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> : this is another instance of the general problem where proving theorems about nested inductives requires some user-extensible mechanism for doing the equivalent of the <code>ite</code> -&gt; <code>dite</code> replacement trick to get more assumptions in the context when doing a recursive call via <code>map</code></p>",
        "id": 444569503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718315614
    }
]