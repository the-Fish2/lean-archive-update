[
    {
        "content": "<p>I have a term <code>x</code> of type <code>Group g</code>, and I'm making another term <code>y</code> also of type <code>Group g</code>. If I write my expression for y bare, like <code>f x foo bar</code>, then Lean can't infer all the types it needs and gets stuck. If I supply a cast like <code>(f x foo bar : Group g)</code>, then Lean computes it fine.</p>\n<p>Now, I could write <code>( ... : Group g)</code> everywhere in my code. But this expression <code>f x foo bar</code> is kind of long and I'm using it lots of places, so I'm defining a notation for it, something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"n\">x</span> <span class=\"s2\">\" ∘[ \"</span> <span class=\"n\">p</span> <span class=\"s2\">\" ] \"</span> <span class=\"n\">y</span>  <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">composeAt</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The above doesn't actually compile, because <code>g</code> isn't in scope. I can do <code>set_option quotPrecheck false</code> right before, and then this notation works, but only as long it's actually called <code>g</code>. Which is kind of gross, I'll admit.</p>\n<p>I would like to be able to write something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"n\">x</span> <span class=\"s2\">\" ∘[ \"</span> <span class=\"n\">p</span> <span class=\"s2\">\" ] \"</span> <span class=\"n\">y</span>  <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">composeAt</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">typeof</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>and then my notation would do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"bp\">∘</span><span class=\"o\">[</span> <span class=\"n\">foo</span> <span class=\"o\">]</span> <span class=\"n\">bar</span>\n<span class=\"c1\">---&gt;</span>\n<span class=\"o\">(</span><span class=\"n\">composeAt</span> <span class=\"n\">x</span> <span class=\"n\">foo</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">typeof</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"c1\">---&gt;</span>\n<span class=\"o\">(</span><span class=\"n\">composeAt</span> <span class=\"n\">x</span> <span class=\"n\">foo</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and work how I want. Is there any way to do this in Lean?</p>",
        "id": 416491178,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1705549546
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 416491504,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1705549709
    },
    {
        "content": "<p>is <code>composeAt x p y : typeof(x)</code> a simplification or the actual code you want to be able to write?</p>",
        "id": 416494960,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1705551754
    },
    {
        "content": "<p>The actual code I want to be able to write. I realize that <code>typeof</code> is not real syntax, so I'm wondering if there's anything else I could write of a similar form, to say \"elaborate this expression into the same type as the term x you already have\".</p>",
        "id": 416495028,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1705551812
    },
    {
        "content": "<p>I'm curious what the type signature of <code>composeAt</code> is then... wouldn't the type signature make it clear that the type of the output of the function should be identical to the type of the first variable passed into it? I'm wondering how Lean gets confused here</p>",
        "id": 416495259,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1705551961
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/stream/113489-new-members/topic/notation.20for.20.22type.20of.20x.22/near/416495028\">said</a>:</p>\n<blockquote>\n<p>I realize that <code>typeof</code> is not real syntax,</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">type_of</span><span class=\"bp\">%</span> <span class=\"mi\">1</span> <span class=\"c1\">-- Nat : Type</span>\n</code></pre></div>",
        "id": 416495430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705552049
    },
    {
        "content": "<p>oh nice! Thanks. :)</p>",
        "id": 416495551,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1705552122
    },
    {
        "content": "<p>But why can't you write a new function which binds its output type to the type of <code>x</code>?</p>",
        "id": 416495593,
        "sender_full_name": "N Gelwan",
        "timestamp": 1705552171
    },
    {
        "content": "<p>So, the type signature is <code>Group g -&gt; (some thing I defined) -&gt; Group g -&gt; Group g</code>. So yes, you would expect it to be able to deduce it from the type of x.</p>\n<p>The weird part is that I was using it in forms like <code>composeAt 1 0 y</code>, and I think it was somehow getting tripped up with what type to cast <code>1</code> into and then how to interpret the value of p, <code>0</code> (which had a dependent type on x). This fixed my problem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"mi\">71</span> <span class=\"s2\">\" ∘[ \"</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"s2\">\" ] \"</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"mi\">70</span>  <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">composeAt</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">typeof</span><span class=\"bp\">%</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and now it all elaborates fine!</p>",
        "id": 416495766,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1705552283
    },
    {
        "content": "<p>(If this sounds suspicious, like, \"Alex you're doing something wrong if this is the problem you're having\", please let me know)</p>",
        "id": 416495786,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1705552308
    },
    {
        "content": "<p>an MWE would be helpful</p>",
        "id": 416495883,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705552366
    },
    {
        "content": "<p>Okay, in the process of trying to make a mwe and running into more issues, I think I found the 'real' solution, which is that I should change the order of arguments in composeAt to be <code>x y p</code>. The type of p still depends on x, but now the elaborator hits y before p, so it goes back and knows the right type for x, and doesn't get stuck at p. My notation reorders the arguments to make sense anyway.</p>",
        "id": 416497343,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1705553444
    },
    {
        "content": "<p>If you want to see exactly what's going on, here's the code I've actually got. Trying to build up to operads</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Family</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Sigma</span> <span class=\"n\">A</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">MultiComposable</span> <span class=\"n\">where</span>\n  <span class=\"n\">compose</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"n\">m</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ComposableOne</span> <span class=\"n\">where</span>\n  <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">ComposableOne.toOne</span> <span class=\"o\">[</span><span class=\"n\">ComposableOne</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">One</span> <span class=\"o\">(</span><span class=\"n\">Family</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">one</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">BadExample</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">composeAt</span> <span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MultiComposable</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Family</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">x.fst</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Family</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">Family</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n    <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">MultiComposable.compose</span> <span class=\"n\">x.snd</span> <span class=\"n\">p</span> <span class=\"n\">y.snd</span><span class=\"o\">⟩</span>\n\n<span class=\"n\">scoped</span> <span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"mi\">71</span> <span class=\"s2\">\" ∘[ \"</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"s2\">\" ] \"</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"mi\">70</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">composeAt</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Operad</span> <span class=\"kd\">extends</span> <span class=\"n\">MultiComposable</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">ComposableOne</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n  <span class=\"n\">id_left</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Family</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">∘</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"c1\">--error here</span>\n  <span class=\"c1\">--if I do some casting in my notation based on y, then this fails instead</span>\n  <span class=\"n\">id_right</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Family</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">a.fst</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∘</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">BadExample</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">GoodExample</span>\n\n<span class=\"c1\">--now we change the order of the arguments</span>\n<span class=\"kd\">def</span> <span class=\"n\">composeAt</span> <span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MultiComposable</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Family</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Family</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">x.fst</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">Family</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n    <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">MultiComposable.compose</span> <span class=\"n\">x.snd</span> <span class=\"n\">p</span> <span class=\"n\">y.snd</span><span class=\"o\">⟩</span>\n\n<span class=\"n\">scoped</span> <span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"mi\">71</span> <span class=\"s2\">\" ∘[ \"</span> <span class=\"n\">p</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"s2\">\" ] \"</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"mi\">70</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">composeAt</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">p</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Operad</span> <span class=\"kd\">extends</span> <span class=\"n\">MultiComposable</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">ComposableOne</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n  <span class=\"n\">id_left</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Family</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">∘</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"c1\">--works fine</span>\n  <span class=\"n\">id_right</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Family</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">a.fst</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∘</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"c1\">--works fine</span>\n</code></pre></div>",
        "id": 416497734,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1705553734
    },
    {
        "content": "<p>FYI there's a typo in <code>BadExample</code>, you wrote <code>∘1[</code> instead of <code>∘[</code> when you declared the notation</p>\n<p>I know it's not the actual issue here</p>",
        "id": 416498165,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1705554038
    },
    {
        "content": "<p>oops yeah, fixed</p>",
        "id": 416498245,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1705554089
    },
    {
        "content": "<p>Another approach if you want two district <code>Group</code> structures on one type <code>g</code> is to make a type synonym <code>def g' := g</code> and put the second group structure on <code>g'</code> instead. You can define the bijection from <code>g</code> to <code>g'</code> using <code>rfl</code> and then typeclass interference will know what you mean by <code>*</code> because it will be able to look at the type.</p>",
        "id": 416504750,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705558775
    },
    {
        "content": "<p>Ah, it wasn't really <code>Group</code>, it was some type I had defined (<code>Family</code>) -- but I figured that would distract from the question...</p>",
        "id": 416504876,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1705558838
    },
    {
        "content": "<p>Is <code>Family</code> a structure or a class?</p>",
        "id": 416504943,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705558874
    },
    {
        "content": "<p>It's</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Family</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Sigma</span> <span class=\"n\">A</span>\n</code></pre></div>\n<p>I'm modelling my code to a decent degree off of <code>GradedMonoid</code> (which is defined the same as <code>Family</code>, except that it takes an arbitrary <code>(A : ι → Type*)</code> and not just <code>Nat</code>)</p>",
        "id": 416505089,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1705558957
    },
    {
        "content": "<p>Oh ok. The type synonym trick is a way to get two distinct instances of a class on the same type so is probably not relevant here.</p>",
        "id": 416505261,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705559058
    },
    {
        "content": "<p>yeah, maybe <code>Group</code> was a poor choice for my stand-in then, whoops</p>",
        "id": 416505307,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1705559094
    },
    {
        "content": "<p>Dependent types are getting me down. :( I don't know how to show that things are equal when the starting types are different... and I get messages like this that I can't understand:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">case</span> <span class=\"n\">h.h</span>\n<span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">((</span><span class=\"n\">Fin</span> <span class=\"n\">k</span> <span class=\"bp\">→</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"n\">asnd</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">a.fst</span> <span class=\"bp\">→</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">v</span>\n<span class=\"n\">vs</span><span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">a.fst</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">v</span>\n<span class=\"n\">k2</span><span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">a.fst</span>\n<span class=\"bp\">|</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"bp\">↑</span><span class=\"n\">k2</span><span class=\"o\">,</span> <span class=\"n\">isLt</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"n\">k2</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">a.fst</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n<span class=\"n\">Messages</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">Operad.lean</span><span class=\"o\">:</span><span class=\"mi\">190</span><span class=\"o\">:</span><span class=\"mi\">10</span>\n<span class=\"n\">tactic</span> <span class=\"bp\">'</span><span class=\"n\">rewrite'</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">did</span> <span class=\"n\">not</span> <span class=\"n\">find</span> <span class=\"kd\">instance</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">pattern</span> <span class=\"k\">in</span> <span class=\"n\">the</span> <span class=\"n\">target</span> <span class=\"n\">expression</span>\n  <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"bp\">↑?</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">isLt</span> <span class=\"o\">:=</span> <span class=\"bp\">?</span><span class=\"n\">h</span> <span class=\"o\">}</span>\n<span class=\"n\">case</span> <span class=\"n\">h.h</span>\n<span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">((</span><span class=\"n\">Fin</span> <span class=\"n\">k</span> <span class=\"bp\">→</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"n\">asnd</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">a.fst</span> <span class=\"bp\">→</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">v</span>\n<span class=\"n\">vs</span><span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">a.fst</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">v</span>\n<span class=\"n\">k2</span><span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">a.fst</span>\n<span class=\"bp\">|</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"bp\">↑</span><span class=\"n\">k2</span><span class=\"o\">,</span> <span class=\"n\">isLt</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"n\">k2</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">a.fst</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>So here the goal (in <code>conv</code> mode) was</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"bp\">↑</span><span class=\"n\">k2</span><span class=\"o\">,</span> <span class=\"n\">isLt</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"n\">k2</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">a.fst</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>and I did <code>rw [Fin.eta]</code> but it says it can't find that... urgh....</p>",
        "id": 416530217,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1705570167
    },
    {
        "content": "<p>Equality is a relation defined on two terms with the same type, so in general you should not do that.</p>",
        "id": 416531398,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1705570574
    },
    {
        "content": "<p>We have a more general notion, but it's probably a good idea to avoid it</p>",
        "id": 416531455,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1705570593
    },
    {
        "content": "<p>I'm aware there's <code>HEq</code> but I have a very bad idea of how to use it</p>",
        "id": 416533081,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1705571145
    },
    {
        "content": "<p>I mean, it seems worth being able to say that <code>(x : Fin (n+m)) = (y : Fin (m+n))</code> and stuff like that. And I'm not sure how I'm \"supposed\" to handle things like that</p>",
        "id": 416533218,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1705571180
    },
    {
        "content": "<p>This is really a limit case. Sometimes you can <code>rw [add_comm]</code> (maybe <code>simp_rw</code>) at <code>x</code>, where <code>x : Fin (n+m)</code>. The clean way of doing this is to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=finCongr#doc\">docs#finCongr</a></p>",
        "id": 416534298,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1705571522
    },
    {
        "content": "<p>It gives you a bijection <code>Fin m ≃ Fin n</code> if <code>n = m</code> that you should use to pass from <code>Fin m</code> to <code>Fin n</code></p>",
        "id": 416534432,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1705571563
    },
    {
        "content": "<p>How do things like GradedMonoid handle it...? I mean, I have a <code>mul : A i -&gt; A j -&gt; A (i+j)</code>, which means that I can't express commutativity as <code>mul (x : A i) (y : A j) = mul y x</code>, because one side is an <code>A (i+j)</code> and the other is <code>A (j+i)</code>. I see that clearly they <em>do</em> express things like commutativity, but I'm struggling to understand how. It looks like they just render some kind of forgetful thing that turns mul into a \"union\" multiply over the whole thing, with no dependent information...?</p>",
        "id": 416535895,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1705572007
    },
    {
        "content": "<p>One solution is to define <code>mul i j k : A i -&gt; A j -&gt; A k</code> that's zero unless <code>k = i + j</code>. Chain complexes do something similar.</p>",
        "id": 416539684,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705573115
    },
    {
        "content": "<p>I suppose a tradeoff is that <code>k</code> isn't inferred from <code>i</code> and <code>j</code>.</p>",
        "id": 416539776,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705573155
    },
    {
        "content": "<p>can you use default arguments for that?</p>",
        "id": 416540168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705573288
    },
    {
        "content": "<p>The trick is that if <code>A : ι → Type u</code>, than <code>GradedMonoid A</code> (that is defined as <code>Sigma A</code>) has a \"normal\" multiplication</p>",
        "id": 416540741,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1705573469
    },
    {
        "content": "<p>And we require this one to be commutative</p>",
        "id": 416540774,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1705573484
    },
    {
        "content": "<p>So we have a class <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=GradedMonoid.GMul#doc\">docs#GradedMonoid.GMul</a> and an instance saying that <code>Mul (GradedMonoid A)</code> if <code>[GradedMonoid.GMul A]</code>. The definition of the multiplication is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">GradedMonoid</span> <span class=\"n\">A</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">GMul.mul</span> <span class=\"n\">x.snd</span> <span class=\"n\">y.snd</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 416541047,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1705573571
    },
    {
        "content": "<p>In particular, the equality for the commutativity is just <code>x * y = y * x</code>, where now <code>x</code>, <code>y</code>, <code>x*y</code> and <code>y*x</code> have all type <code>GradedMonoid A</code>. The equality <code>x * y = y * x</code> is an equality in a Sigma type, so it is the same as requiring that both components are equal. The equality of the first component says what you want, and the other one is automatically true since <code>ι</code> is a commutative monoid.</p>",
        "id": 416541682,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1705573799
    },
    {
        "content": "<p>(I think you mean the equality of the <em>second</em> component says what you want?)</p>",
        "id": 416596786,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705592118
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/stream/113489-new-members/topic/notation.20for.20.22type.20of.20x.22/near/416497734\">said</a>:</p>\n<blockquote>\n<p>If you want to see exactly what's going on, here's the code I've actually got. </p>\n</blockquote>\n<p>Adding <code>instance [ComposableOne A] : NeZero ((1 : Family A).1) := ⟨one_ne_zero⟩</code> fixes this</p>",
        "id": 416597254,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705592258
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/notation.20for.20.22type.20of.20x.22/near/416596786\">said</a>:</p>\n<blockquote>\n<p>(I think you mean the equality of the <em>second</em> component says what you want?)</p>\n</blockquote>\n<p>Yes, of course</p>",
        "id": 416645922,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1705610342
    },
    {
        "content": "<p>Here's a question I had that ended up on the grading topic recently, if you're interested: <a href=\"#narrow/stream/113488-general/topic/Identities.20to.20Equivalences.20in.20Graded.20Structures/near/410059564\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Identities.20to.20Equivalences.20in.20Graded.20Structures/near/410059564</a>.</p>",
        "id": 416659693,
        "sender_full_name": "N Gelwan",
        "timestamp": 1705616705
    },
    {
        "content": "<p>Alright, I'm trying to muddle my way through HEq. I understand that a painful part of HEq it (HEq f g) (HEq x y) doesn't imply (HEq (f x) (g y)). Are either of these true, at least? Are they named in Mathlib, or if not, is there a tactic that applies them for me?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">heq_funext</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α₁</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α₂</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hxy</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">heq_congr</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α₁</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α₂</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 416730087,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1705653035
    },
    {
        "content": "<p>I am not completely sure, but we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.hfunext#doc\">docs#Function.hfunext</a>, that suggests your first lemma is not true.</p>",
        "id": 416731926,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1705653857
    },
    {
        "content": "<p>And the second one seems to me exactly the fact that <code>HEq f g</code> and <code>HEq x y</code> implies <code>HEq (f x) (f y)</code> (just use <code>heq_iff_eq</code>), that does not hold.</p>",
        "id": 416732752,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1705654254
    },
    {
        "content": "<p>the second one is true</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">heq_congr</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α₁</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α₂</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h₂</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h₁</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 416732753,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705654256
    },
    {
        "content": "<p>OK, I could have waited 10 more seconds :D</p>",
        "id": 416732792,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1705654277
    },
    {
        "content": "<p>Ah, of course, the difference is that we have the same <code>β</code> both for <code>f</code> and <code>g</code>.</p>",
        "id": 416733000,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1705654368
    },
    {
        "content": "<p><code>heq_funext</code> looks even more strongly false, you should be able to disprove it if you take <code>α₁</code> and <code>α₂</code> to be provably different types</p>",
        "id": 416733244,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705654454
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"448405\">@Alex Meiburg</span> you can of course doing whatever you prefer, but there are reasons why we suggest to avoid <code>HEq</code>. The design choices we made in mathlib can look not very natural (for example the current design of graded monoid), but we thought carefully about it, and it's probably not a good idea for a beginner to try to reinvent the wheel.</p>\n<p>Having said that, I completely understand that trying to do it by yourself is funny and interesting!</p>",
        "id": 416734098,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1705654766
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Logic.Equiv.Basic</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">heq_funext</span> <span class=\"o\">{</span><span class=\"n\">α₁</span> <span class=\"n\">α₂</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α₁</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α₂</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hxy</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">f</span> <span class=\"n\">g</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">heq_funext</span> <span class=\"n\">False</span> <span class=\"n\">True</span> <span class=\"n\">Bool</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"bp\">.</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">False</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"o\">(</span><span class=\"n\">True</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">type_eq_of_heq</span> <span class=\"n\">this</span> <span class=\"bp\">▸</span> <span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">_</span>\n  <span class=\"n\">cases</span> <span class=\"n\">congrFun</span> <span class=\"o\">(</span><span class=\"n\">this.symm.subsingleton.allEq</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span><span class=\"o\">))</span> <span class=\"o\">⟨⟩</span>\n</code></pre></div>",
        "id": 416734736,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705655021
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113489-new-members/topic/notation.20for.20.22type.20of.20x.22/near/416734098\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> you can of course doing whatever you prefer, but there are reasons why we suggest to avoid <code>HEq</code>. The design choices we made in mathlib can look not very natural (for example the current design of graded monoid), but we thought carefully about it, and it's probably not a good idea for a beginner to try to reinvent the wheel.</p>\n<p>Having said that, I completely understand that trying to do it by yourself is funny and interesting!</p>\n</blockquote>\n<p>I think HEq is unfairly maligned; it definitely can have its uses. Also, Eric W's indexed eq was an interesting experiment that still has time to go somewhere</p>",
        "id": 416749117,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1705660217
    },
    {
        "content": "<p>Ah, that's a shame about the funext. Yes, I would like to avoid HEq, but I really don't see any way to define operads without Sigma types: the basic composition operation in operads is dependently typed. And then, whenever I want <code>Sigma.ext</code>, HEq gets in there.</p>",
        "id": 416749990,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1705660537
    },
    {
        "content": "<p>I don't know anything about operads, but I suggest you ask exactly what you need and I am sure someone will help.</p>",
        "id": 416755435,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1705662305
    },
    {
        "content": "<p>Avoiding <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a></p>",
        "id": 416755507,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1705662329
    },
    {
        "content": "<blockquote>\n<p>I think HEq is unfairly maligned; it definitely can have its uses.</p>\n</blockquote>\n<p>I think the correct tool that you usually want to use in place of HEq is called a \"pathover\" in HoTT, and represents an equality dependent on another equality.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Pathover</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">Pathover</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">rfl</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>The trouble with <code>HEq</code> is that it is equivalent to the specific combination <code>∃ h : α = β, Pathover id α x β h y</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">Pathover</span> <span class=\"n\">id</span> <span class=\"n\">α</span> <span class=\"n\">x</span> <span class=\"n\">β</span> <span class=\"n\">h</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨⟩⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟨⟩,</span> <span class=\"o\">⟨⟩⟩</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"bp\">.</span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>and so it bakes a type equality into the definition (i.e. we set the <code>α</code> in Pathover to <code>Type u</code>), which is less introspectable than if the type was, say, an inductive type and <code>P</code> was a nontrivial function, since then we can do inversion on that equality. (The other awkward thing about <code>HEq</code> is the fact that it erases the proof <code>h : α = β</code> by quantifying over it, although in lean this is not much of an issue because of proof irrelevance. In actual HoTT without proof irrelevance you can't do this because you might need to remember that your pathover is over a particular equality and forgetting it and reintroducing a new one can produce nontrivial loops.)</p>\n<p>You might ask why mathlib doesn't have pathovers given all of this. One reason is that \"just avoid the whole area\" is surprisingly effective advice, and another reason is that one pathover is not enough, you might need 2-pathovers as well:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Pathover2</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"n\">Pathover</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"n\">y</span> <span class=\"n\">h</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span> <span class=\"n\">y</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">Pathover2</span> <span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"n\">q</span> <span class=\"n\">x</span> <span class=\"n\">rfl</span> <span class=\"n\">a</span> <span class=\"bp\">.</span><span class=\"n\">rfl</span> <span class=\"n\">q</span>\n</code></pre></div>\n<p>The more generalizable way of getting these equalities is by using equalities in sigma types instead.</p>",
        "id": 416755565,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705662348
    },
    {
        "content": "<p>There is a counterpoint to this though, which is that pathovers are equivalent to <code>HEq</code> because of proof irrelevance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Pathover</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"n\">y</span> <span class=\"n\">h</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">HEq</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"bp\">.</span><span class=\"n\">rfl</span>\n  <span class=\"bp\">·</span> <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"bp\">.</span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>So you can kind of pretend that a <code>HEq</code> is really a pathover and ignore the type equality it bakes in. This only works in the presence of the equality <code>x = y</code> though (which is also a prerequisite for stating a pathover), you should not attempt to do \"inversion\" on a HEq to get type equalities out of it because that's where all the undesirable properties come from. Just think of this as the \"second half\" of a sigma type equality: <code>(⟨x, a⟩ : Σ x : α, P x) = ⟨y, b⟩ &lt;-&gt; ∃ h : x = y, ???</code>, where the equality <code>h : x = y</code> is already in context and hence the type equality expressed by the <code>HEq a b</code> is already provable from other things in the context.</p>",
        "id": 416758232,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705663405
    },
    {
        "content": "<p>(Re \"inversion\", the <code>congr!</code> tactic tries to help you with this by giving you all the relevant preceding Eq/HEq goals as additional hypotheses. This isn't strictly necessary though, since you can re-prove these in later goals as needed.)</p>",
        "id": 416759565,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705663938
    },
    {
        "content": "<p>Here's a list of ways I know for handling these equality problems. HEq is one of them, but it's at the end of the list because there's usually a better option. Sometimes HEq pops up in the middle of a proof, and it's fine, but you don't necessarily want to make a whole theory using it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! # Use a cast function and equality</span>\n\n<span class=\"cm\">Pros:</span>\n<span class=\"cm\">- Sticks with equality</span>\n<span class=\"cm\">- Uses a function that rewrites just type indices so it's possible to write</span>\n<span class=\"cm\">  lemmas saying how the cast function interacts with other functions</span>\n<span class=\"cm\">- Lemmas can extract this equality directly from the term when rewriting</span>\n<span class=\"cm\">Cons:</span>\n<span class=\"cm\">- Asymmetric</span>\n<span class=\"cm\">- Need to set up `cast_rfl`, `cast_cast`, etc. lemmas</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">castα</span> <span class=\"o\">{</span><span class=\"n\">x₁</span> <span class=\"n\">x₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">x₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x₁</span> <span class=\"bp\">=</span> <span class=\"n\">x₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">x₂</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">x₁</span> <span class=\"n\">x₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x₁</span> <span class=\"bp\">=</span> <span class=\"n\">x₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y₁</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">x₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y₂</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">x₂</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">castα</span> <span class=\"n\">y₁</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">y₂</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! # Use a custom equality type</span>\n\n<span class=\"cm\">Pros:</span>\n<span class=\"cm\">- Unlike `HEq`, remembers the index equality</span>\n<span class=\"cm\">- Symmetric</span>\n<span class=\"cm\">Cons:</span>\n<span class=\"cm\">- Is a \"global\" notion</span>\n<span class=\"cm\">- There's no `rw`/`simp` for rewriting with your equality type</span>\n<span class=\"cm\">- Need to prove rfl, symm, trans</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Eqα</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x₁</span> <span class=\"n\">x₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">x₁</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">x₂</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">rfl</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eqα</span> <span class=\"n\">y</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x₁</span> <span class=\"n\">x₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y₁</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">x₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y₂</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">x₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Eqα</span> <span class=\"n\">y₁</span> <span class=\"n\">y₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x₁</span> <span class=\"bp\">=</span> <span class=\"n\">x₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! # Use equality of sigma types</span>\n\n<span class=\"cm\">Pros:</span>\n<span class=\"cm\">- Unlike `HEq`, remembers the index equality.</span>\n<span class=\"cm\">- Avoids making a custom relation, and uses built-in types</span>\n<span class=\"cm\">- Sticks with equality, so `rw`/`simp` is possible</span>\n<span class=\"cm\">Cons:</span>\n<span class=\"cm\">- Is a \"global\" notion in that the equality is on this auxiliary sigma type</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">mk</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x₁</span> <span class=\"n\">x₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y₁</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">x₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y₂</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">x₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">mk</span> <span class=\"n\">y₁</span> <span class=\"bp\">=</span> <span class=\"n\">mk</span> <span class=\"n\">y₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x₁</span> <span class=\"bp\">=</span> <span class=\"n\">x₂</span> <span class=\"o\">:=</span>\n  <span class=\"n\">congr_arg</span> <span class=\"n\">Sigma.fst</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! # Use HEq</span>\n\n<span class=\"cm\">Pros:</span>\n<span class=\"cm\">- It's a built-in relation with some tactic support.</span>\n<span class=\"cm\">- So long as you still keep the index equality in context, it's equivalent to the others.</span>\n<span class=\"cm\">- You can \"rewrite\" with it using `congr(...)` quotations (a mathlib syntax)</span>\n<span class=\"cm\">Cons:</span>\n<span class=\"cm\">- There is nothing tying the index equality to the HEq, so it can get lost.</span>\n<span class=\"cm\">- You can't `rw`/`simp` with it.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x₁</span> <span class=\"n\">x₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y₁</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">x₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y₂</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">x₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">y₁</span> <span class=\"n\">y₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x₁</span> <span class=\"bp\">=</span> <span class=\"n\">x₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span> <span class=\"c1\">-- Impossible</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 416761069,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705664586
    },
    {
        "content": "<p>Ah! I think <code>congr!</code> solves my problems nicely! I can now prove several things I couldn't previously. I should probably learn how it works, I mean, but <code>congr</code> generates HEq's where <code>congr!</code> seems better at simplifying it and getting me Eq's instead. :) I'm doing the \"Sigma\" approach mentioned at <a href=\"https://github.com/eric-wieser/lean-graded-rings/blob/cf463b1b9317e16499a51b20037ad8319311bd21/src/cicm2022/examples/graded_semigroup.lean#L42?decl=h%20:%20i+j=k.g_semigroup\">https://github.com/eric-wieser/lean-graded-rings/blob/cf463b1b9317e16499a51b20037ad8319311bd21/src/cicm2022/examples/graded_semigroup.lean#L42?decl=h%20:%20i+j=k.g_semigroup</a>, but the \"h : i+j=k\" approach looks nice too..</p>",
        "id": 416810132,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1705680424
    }
]