[
    {
        "content": "<p>Hi I have a question about the error Lean is throwing in the following setup<br>\nI have some list prime_factors_sorted together with a proof that the length is at least 2. The following code throws an error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">*</span><span class=\"n\">some</span> <span class=\"n\">code</span> <span class=\"n\">here</span><span class=\"bp\">*</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">prime_factors_sorted.length</span> <span class=\"bp\">≥</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">h₄</span>\n    <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">prime_factors_sorted</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n    <span class=\"k\">let</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"n\">prime_factors_sorted</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>namely:<br>\nfailed to prove index is valid, possible solutions:</p>\n<p>- Use <code>have</code>-expressions to prove the index is valid<br>\n  - Use <code>a[i]!</code> notation instead, runtime check is perfomed (sic), and 'Panic' error message is produced if index is not valid<br>\n  - Use <code>a[i]?</code> notation instead, result is an <code>Option</code> type<br>\n  - Use <code>a[i]'h</code> notation instead, where <code>h</code> is a proof that index is valid</p>\n<p>but </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">prime_factors_sorted.length</span> <span class=\"bp\">≥</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">h₄</span>\n    <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">prime_factors_sorted</span><span class=\"o\">[(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)]</span>\n    <span class=\"k\">let</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"n\">prime_factors_sorted</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>works<br>\nIs this expected behavior?</p>",
        "id": 409774961,
        "sender_full_name": "Andy Jiang",
        "timestamp": 1703385677
    },
    {
        "content": "<p>Can you have a quick look at <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a> and change your question so it uses them to be a bit easier to read?</p>",
        "id": 409774985,
        "sender_full_name": "Julian Berman",
        "timestamp": 1703385711
    },
    {
        "content": "<p>I suspect the answer is yes though just looking at the error message -- I guess it's slightly surprising <code>0 : Fin 2</code> works -- are you more surprised at the working example or the nonworking one?</p>",
        "id": 409775104,
        "sender_full_name": "Julian Berman",
        "timestamp": 1703385812
    },
    {
        "content": "<p>Well I guess I just want to understand what's going on so it's less of a trial-and-error process. At first I tried inserting (0: Fin prime_factors_sorted.length) and it rejected that as well. I assume (0 : Fin 2) is not the \"correct\" way to index this list? What is the correct way to do it? (Assuming that my code is only working accidentally)</p>",
        "id": 409776274,
        "sender_full_name": "Andy Jiang",
        "timestamp": 1703386828
    },
    {
        "content": "<p>Is the correct way to do it<br>\n<code>\nlet p := prime_factors_sorted.get ⟨0, by omega⟩ \n</code><br>\n?</p>",
        "id": 409776885,
        "sender_full_name": "Andy Jiang",
        "timestamp": 1703387283
    },
    {
        "content": "<p>Not the answer to your question but <code>by simpa using h_4</code> is more idiomatic than the non-terminal <code>simp</code>. You haven't posted a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> -- is the error you're reporting on <code>p</code> or <code>q</code>? I don't see anything wrong with the approach using <code>omega</code> but it might be slow -- you might be better off just supplying a proof directly (maybe find the term using <code>exact?</code>?)</p>",
        "id": 409796876,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1703406452
    },
    {
        "content": "<p>Thanks for the reply, the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> for my original question is </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.List.Basic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l.length</span> <span class=\"bp\">≥</span> <span class=\"mi\">2</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">l</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">l</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">l</span><span class=\"o\">[(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">l.length</span><span class=\"o\">)]</span>\n<span class=\"kd\">def</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"n\">l</span><span class=\"o\">[(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)]</span>\n<span class=\"kd\">def</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">l.get</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">Nat.zero_lt_of_lt</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">l.get</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"kd\">by</span> <span class=\"n\">omega</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>here a and c fail and the rest work.<br>\nBy the way, I also am confused why omega works sometimes but not other times under seemingly the same hypotheses. For example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Linarith</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">easy</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">&gt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">omega</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">easy2</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)):</span> <span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">&gt;</span> <span class=\"n\">n.val</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n.val</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">n.isLt</span>\n  <span class=\"n\">omega</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">easy3</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)):</span> <span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">&gt;</span> <span class=\"n\">n.val</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n.val</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">n.isLt</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">n.val</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">n.val</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">tauto</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">h2</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">h2</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">omega</span>\n</code></pre></div>\n<p>The first one works but the second and third don't even though in the third example the tactic state is basically the same just with some extra assumptions.</p>",
        "id": 409824718,
        "sender_full_name": "Andy Jiang",
        "timestamp": 1703433281
    },
    {
        "content": "<p>Please take another look at <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a> and edit your message; you need three backticks not just one</p>",
        "id": 409824822,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703433379
    },
    {
        "content": "<p><code>c</code> doesn't work because <code>0 : Fin n</code> doesn't make sense in general (because <code>n</code> might be 0), and Lean is not going to magically spot that in this case it can't be 0 -- you have to tell it (Lean does not even \"know\" that <code>x &gt;= 2</code> implies <code>x = t + 1</code> for some <code>t</code>, again this needs a proof; it's not hard but it must be present).</p>",
        "id": 409826207,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1703434580
    },
    {
        "content": "<p>Thanks, mainly I'm trying to understand why b works but not a. Lean is doing some automatic inferences under the hood to get b to work right? Is it some search-boundary that's preventing it from doing a?</p>",
        "id": 409828820,
        "sender_full_name": "Andy Jiang",
        "timestamp": 1703437389
    },
    {
        "content": "<p>I don't know the direct answer to your question, but from changing <code>2</code> to <code>3</code> I think we see that it has something to do with the last index, and that's all Lean is aware of -- as you say,  yeah, however this feature works, Lean is trying to prove the index is valid, and that seems to be doing so correctly only for the last index. I think to understand why we have to find what tactic is being used to prove the length is longer and that'll answer the question, but I'm not sure yet how to do so, trying to figure that out myself</p>",
        "id": 409838795,
        "sender_full_name": "Julian Berman",
        "timestamp": 1703448154
    },
    {
        "content": "<p>(What I changed your code to is simply:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.List.Basic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">3</span> <span class=\"bp\">&lt;</span> <span class=\"n\">l.length</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">a0</span> <span class=\"o\">:=</span> <span class=\"n\">l</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">a1</span> <span class=\"o\">:=</span> <span class=\"n\">l</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">a2</span> <span class=\"o\">:=</span> <span class=\"n\">l</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">a3</span> <span class=\"o\">:=</span> <span class=\"n\">l</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">l</span><span class=\"o\">[(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">l.length</span><span class=\"o\">)]</span>\n<span class=\"kd\">def</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"n\">l</span><span class=\"o\">[(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)]</span>\n<span class=\"kd\">def</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">l.get</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">Nat.zero_lt_of_lt</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">l.get</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"kd\">by</span> <span class=\"n\">omega</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>where you'll see that no matter what, if you play with the 2 numbers, only the last index is proven correctly<br>\n)</p>",
        "id": 409838862,
        "sender_full_name": "Julian Berman",
        "timestamp": 1703448203
    },
    {
        "content": "<p>OK simply grepping for the error message says the answer is <code>get_elem_tactic</code>, and that that basically tries either <code>trivial</code> or else <code>simp (config := { arith := true })</code></p>",
        "id": 409839150,
        "sender_full_name": "Julian Berman",
        "timestamp": 1703448458
    },
    {
        "content": "<p>(I am brain dumping in case this is helpful to you for figuring out how to answer the question -- someone else I'm sure will straight up just know the answer)</p>",
        "id": 409839219,
        "sender_full_name": "Julian Berman",
        "timestamp": 1703448507
    },
    {
        "content": "<p>OK and it looks like <code>get_elem_tactic</code> is meant to be extensible -- which means there's a chance Mathlib extends it to use a more powerful tactic, but that you/we haven't imported enough to make that happen. Let's see... I guess by grepping through mathlib for that tactic.</p>",
        "id": 409839251,
        "sender_full_name": "Julian Berman",
        "timestamp": 1703448545
    },
    {
        "content": "<p>No that doesn't appear in Mathlib, so it looks like the answer is \"no\". <code>omega</code> discharged your goal there -- I know it's new -- not sure if it's a candidate for making these more automatic in all those cases, now I think I've exhausted what I'd be able to figure out quickly on my own</p>",
        "id": 409839322,
        "sender_full_name": "Julian Berman",
        "timestamp": 1703448623
    },
    {
        "content": "<p>Yeah, adding:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">get_elem_tactic_trivial</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">omega</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>makes all those examples work automatically. I have no idea how bad of an idea that is, now someone who knows more will teach us both, or tell us to PR that.</p>",
        "id": 409839424,
        "sender_full_name": "Julian Berman",
        "timestamp": 1703448726
    },
    {
        "content": "<p>ah ok so Lean tries some tactics automatically here and those tactics only can solve the less than one case. thanks for the help!</p>",
        "id": 409847264,
        "sender_full_name": "Andy Jiang",
        "timestamp": 1703457115
    },
    {
        "content": "<p>actually even more confusing to me is the failure of omega in the second example above. It seems like the tactic state is the same (with some extra junk) but omega fails when you add more hypotheses into the tactic state. This is really confusing to me</p>",
        "id": 409847330,
        "sender_full_name": "Andy Jiang",
        "timestamp": 1703457178
    },
    {
        "content": "<p>Which second example? Here, all examples (other than the <code>Fin l.length</code> one) pass.</p>",
        "id": 409849544,
        "sender_full_name": "Julian Berman",
        "timestamp": 1703459860
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Linarith</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">easy</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">&gt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">omega</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">easy2</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)):</span> <span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">&gt;</span> <span class=\"n\">n.val</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n.val</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">n.isLt</span>\n  <span class=\"n\">omega</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">easy3</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)):</span> <span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">&gt;</span> <span class=\"n\">n.val</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n.val</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">n.isLt</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">n.val</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">n.val</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">tauto</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">h2</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">h2</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">omega</span>\n</code></pre></div>\n<p>This example I made up. Perhaps I should start a new thread about this. It's kind of confusing why omega fails sometimes but not other times to me</p>",
        "id": 409849609,
        "sender_full_name": "Andy Jiang",
        "timestamp": 1703459924
    },
    {
        "content": "<p>I can't say I understand which kinds of goals <code>omega</code> is meant for either, but the last two statements are quite different from the first one -- you firstly have natural subtraction there which I know doesn't have a great reputation for behaving sanely.</p>",
        "id": 409850563,
        "sender_full_name": "Julian Berman",
        "timestamp": 1703461076
    },
    {
        "content": "<p><code>omega</code> is supposed to be able to handle nat subtraction, although IIRC it has some iterative splitting thing to handle it and it's possible there are bugs in it</p>",
        "id": 409863189,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703470263
    },
    {
        "content": "<p><code>omega</code> is new this week so if we can isolate some bugs that would be helpful</p>",
        "id": 409865869,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1703472550
    }
]