[
    {
        "content": "<p>If I use a let-binding without pattern matching, then the environment retains knowledge of the equality of the binding. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ex1</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">l.length</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">l.get</span> <span class=\"n\">i</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">l.get</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"c1\">-- ok</span>\n  <span class=\"o\">()</span>\n</code></pre></div>\n<p>However, if I use pattern matching (eg by destructuring a tuple), that knowledge seems to be lost.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ex2</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">l.length</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">l.get</span> <span class=\"n\">i</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">l.get</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"c1\">-- fail</span>\n  <span class=\"o\">()</span>\n</code></pre></div>\n<p>Is there a way to retain the knowledge of that equality? (Besides the obvious option of not using pattern matching?)</p>",
        "id": 424441164,
        "sender_full_name": "Will Crichton",
        "timestamp": 1709409429
    },
    {
        "content": "<p><code>let</code> doesn't have any syntax for capturing that equality, but you can use what pattern match <code>let</code> expands to (a <code>match</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ex2</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">l.length</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l.get</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">l.get</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n    <span class=\"o\">()</span>\n</code></pre></div>",
        "id": 424442081,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709410142
    },
    {
        "content": "<p>Ah, ok that's too bad. I'll play around with the <code>match</code>, thanks <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>.</p>",
        "id": 424442191,
        "sender_full_name": "Will Crichton",
        "timestamp": 1709410219
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"625391\">Will Crichton</span> has marked this topic as resolved.</p>",
        "id": 424442200,
        "sender_full_name": "Notification Bot",
        "timestamp": 1709410226
    },
    {
        "content": "<p>This has come up before in the past; I don't remember if there were any syntax proposals for exposing this via <code>let</code></p>",
        "id": 424444223,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709412002
    },
    {
        "content": "<p>Is there anything preventing Lean from saying that </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">l.get</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>Introduces into the environment</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">l.get</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">l.get</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n</code></pre></div>\n<p>Instead of just</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">\\</span><span class=\"n\">N</span>\n<span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">\\</span><span class=\"n\">N</span>\n</code></pre></div>\n<p>It's not clear to me why a separate syntax would be needed.</p>",
        "id": 424444335,
        "sender_full_name": "Will Crichton",
        "timestamp": 1709412100
    },
    {
        "content": "<p>It would be interesting if <code>let</code> (and more generally <code>match</code>) could see that this is a structure type and generate these local variables using projections, but that would need special support.</p>",
        "id": 424444718,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709412489
    },
    {
        "content": "<p>If you're ok with double evaluation, if this isn't for programming, then here's a macro:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"let_prod \"</span> <span class=\"s2\">\"(\"</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\", \"</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\")\"</span> <span class=\"s2\">\" := \"</span> <span class=\"n\">v</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\";\"</span><span class=\"bp\">?</span> <span class=\"n\">body</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">let</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:=</span> <span class=\"n\">Prod.fst</span> <span class=\"bp\">$</span><span class=\"n\">v</span><span class=\"bp\">;</span> <span class=\"k\">let</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:=</span> <span class=\"n\">Prod.snd</span> <span class=\"bp\">$</span><span class=\"n\">v</span><span class=\"bp\">;</span> <span class=\"bp\">$</span><span class=\"n\">body</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ex2</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">l.length</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">let_prod</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">l.get</span> <span class=\"n\">i</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">l.get</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"o\">()</span>\n</code></pre></div>",
        "id": 424445202,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709412958
    },
    {
        "content": "<p>This doesn't generalize in the same way that <code>let</code> does, though; it won't substitute <code>l.get i</code> in the goal with <code>(x, y)</code></p>",
        "id": 424445272,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709413019
    },
    {
        "content": "<p>(Kyle obviously knows this, but this approach of adding projections doesn't work in general for things like <code>let some x := optX</code>)</p>",
        "id": 424445410,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709413084
    },
    {
        "content": "<p>Yeah, that's why structures are important here, and it suggests why it's a feature that doesn't exist (yet?)</p>",
        "id": 424445450,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709413148
    },
    {
        "content": "<p>Though for <code>Option</code>, I suppose it could use something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Option.get#doc\">docs#Option.get</a> and synthesize a proof, or even just use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Option.get%21#doc\">docs#Option.get!</a>, though that needs Inhabited.</p>",
        "id": 424445544,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709413231
    },
    {
        "content": "<p>Yeah, I would only expect this to work on irrefutable patterns.</p>",
        "id": 424445583,
        "sender_full_name": "Will Crichton",
        "timestamp": 1709413285
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"625391\">Will Crichton</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Retaining.20equality.20with.20pattern-matched.20bindings/near/424445583\">said</a>:</p>\n<blockquote>\n<p>Yeah, I would only expect this to work on irrefutable patterns.</p>\n</blockquote>\n<p>You run into trouble for small eliminators like <code>Exists.rec</code> (which can't provide projections) too, even though the pattern is irrefutable</p>",
        "id": 424445644,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709413341
    }
]