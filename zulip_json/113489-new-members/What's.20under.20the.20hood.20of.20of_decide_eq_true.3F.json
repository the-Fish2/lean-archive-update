[
    {
        "content": "<p>I am happy to see that it is so easy to prove that a particular (small) number is prime. For example,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">prime_7</span> <span class=\"o\">:</span> <span class=\"n\">Nat.Prime</span> <span class=\"mi\">7</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">prime_7</span>\n</code></pre></div>\n<p>When I look at the proof term, it's simply <code>of_decide_eq_true (Eq.refl true)</code>. I tried looking into the source code for <code>of_decide_eq_true</code> but got completely lost. What is under the hood of this magic function? Pointers and insights greatly appreciated.</p>",
        "id": 420340868,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1707339260
    },
    {
        "content": "<p>Here lean uses <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.decidablePrime#doc\">docs#Nat.decidablePrime</a> (or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.decidablePrime1#doc\">docs#Nat.decidablePrime1</a>), that essentially is the fact the \"being a prime\" is decidable, meaning there is an algorithm do check primality.</p>",
        "id": 420341613,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1707339597
    },
    {
        "content": "<p>Note that this is a terrible algorithm, in practice using <code>norm_num</code> is much better.</p>",
        "id": 420342176,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1707339794
    },
    {
        "content": "<p>Does <code>norm_num</code> basically do a brute force search for prime factors?</p>",
        "id": 420342262,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1707339836
    },
    {
        "content": "<p>I don't know exactly what it does, but the doc says \"It also has a relatively simple primality prover\" so, even if it's not super sophisticated it's not trivial either.</p>",
        "id": 420343522,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1707340343
    },
    {
        "content": "<p>You can have a look at the code source if you are interested</p>",
        "id": 420343558,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1707340364
    },
    {
        "content": "<p>I am willing to go down the rabbit hole. It's just that reading Lean code is not that easy at the moment given my limited experience programming anything nontrivial in Lean.</p>",
        "id": 420343718,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1707340437
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/NormNum/Prime.html\">here</a></p>",
        "id": 420343773,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1707340446
    },
    {
        "content": "<p>Thank you.</p>",
        "id": 420343821,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1707340469
    },
    {
        "content": "<p>Are you interested in writing math proof or rather programming in Lean?</p>",
        "id": 420343878,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1707340500
    },
    {
        "content": "<p>Both.</p>",
        "id": 420344056,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1707340565
    },
    {
        "content": "<p>I will need the programming part because I will need to develop my own tactics for the project I have in mind.</p>",
        "id": 420344105,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1707340594
    },
    {
        "content": "<p>Note that <code>norm_num</code> is a complicated tactic, it's maybe better to start with something easier.</p>",
        "id": 420344418,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1707340710
    },
    {
        "content": "<p>Sure. Thanks for the tip.</p>",
        "id": 420344516,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1707340758
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/learn.html\">here</a> you can find several learning resources, including about metaprogramming. And of course asking here is always a good idea.</p>",
        "id": 420344722,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1707340836
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"397075\">Kevin Cheung</span> <a href=\"#narrow/stream/113489-new-members/topic/What's.20under.20the.20hood.20of.20of_decide_eq_true.3F/near/420340868\">said</a>:</p>\n<blockquote>\n<p>When I look at the proof term, it's simply <code>of_decide_eq_true (Eq.refl true)</code>. I tried looking into the source code for <code>of_decide_eq_true</code> but got completely lost. What is under the hood of this magic function? Pointers and insights greatly appreciated.</p>\n</blockquote>\n<p>To figure out what Riccardo pointed out, when you hover over <code>of_decide_eq_true</code>, you want to look at its second argument, which is the Decidable argument. Here it's <code>Nat.decidablePrime 7</code>. A <code>Decidable p</code> value is like Bool, but it contains a proof that the boolean is the evaluation of the proposition <code>p</code>.</p>\n<p>The magic is that <code>of_decide_eq_true</code> is causing  typechecker to see that <code>Nat.decidablePrime 7 : Decidable (Nat.Prime 7)</code> evaluates to true.</p>",
        "id": 420348222,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707342269
    },
    {
        "content": "<p>Is the evaluation performed in the Lean VM or in the Lean proof kernel?</p>",
        "id": 420349024,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1707342609
    },
    {
        "content": "<p>It's evaluated twice, once by the elaborator's typechecker (which is also what's responsible for finding the instances using typeclass instance search), and once again by the kernel.</p>",
        "id": 420349155,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707342671
    },
    {
        "content": "<p>The <code>norm_num</code> code for <code>Nat.Prime</code> computes <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.minFac#doc\">docs#Nat.minFac</a>, which (1) returns <code>2</code> if the number is even and otherwise (2) does trial division using 3,5,7,9,... up to the square root of the number. This function is evaluated by the VM.</p>\n<p>If the number's composite, then the <code>norm_num</code> extension proves it's composite by showing it's a nontrivial product. Otherwise, it constructs a proof that <code>Nat.minFac</code> equals what it equals. It looks like the proof isn't super big, so it must be sending some of it to the kernel for evaluation-by-reduction. These evaluations are done by the kernel using reduction.</p>",
        "id": 420349450,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707342790
    },
    {
        "content": "<p>Interesting. So much magic going on behind the scenes.</p>",
        "id": 420349539,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1707342842
    }
]