[
    {
        "content": "<p>Experienced mathematicians:  I’m wondering if Lean and Mathlib feel consistent and coherent to you.</p>\n<p>I’m trying to evaluate how much of the wrangling I do with syntax and overall feel comes as a result of me, as a programmer, having less mathematical maturity.</p>\n<p>As an example, after working with Obtain a bit, it makes sense to me why the syntax is different for AND and OR.  The obtain ⟨h1, h2⟩ := h and obtain hx | hy := h syntax (more closely) fits the way a mathematician would hand write those operations.  As a programmer, it initially felt inconsistent, but now I see the logic.  I’m wondering how much this holds true more broadly.</p>\n<p>There are other examples, for example the use of ·, that I /think/ are language syntax and not part of the signature of a particular lemma, but which feel inscrutable. </p>\n<p>I’m enjoying Lean.  It’s very satisfying when I complete a proof.  I’m just calibrating. Thanks!</p>",
        "id": 420564077,
        "sender_full_name": "Dan Grigsby",
        "timestamp": 1707437489
    },
    {
        "content": "<p>In the case of <code>obtain</code>, those syntaxes actually do different things. One gives you two hypotheses and one goal. The other gives you two goals, each with one hypothesis.</p>",
        "id": 420568421,
        "sender_full_name": "llllvvuu",
        "timestamp": 1707439791
    },
    {
        "content": "<p>I'm very new to all of this too and my background is much more compsci than math. So perhaps my answer won't be too enlightening. </p>\n<p>I find a lot of the term level language feels like programming to me. Function definitions, dot syntax, destructuring/pattern matching,  product &amp; sum data types, lambda expressions. These have been around in Haskell since before I was born. They're commonplace in functional languages, but they're out in force elsewhere too like TypeScript and Rust.</p>\n<p>Rust uses the same syntax for structs and enums, but if you look at most other languages with sum types/varients you'll often see them expressed with <code>|</code>. Look at F#, OCaml, PureScript, Elm, Haskell, etc.</p>\n<p>In a way it makes sense that to pattern match on a sum type you use the pattern as when you created it. Though it only makes sense when you have a proof state that can be split by the pattern. You'll see it in an <code>rcases</code> pattern but not a <code>match</code> pattern because <code>rcases</code> can handle it by creating multiple goals. </p>\n<hr>\n<blockquote>\n<p>use of ·</p>\n</blockquote>\n<p>I don't think that's a math thing, I think that's a <code>Lean</code>-specific feature. It creates a λ-term for you.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">incr_a</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span><span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n<span class=\"kd\">def</span> <span class=\"n\">incr_b</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">incr_a</span> <span class=\"mi\">5</span> <span class=\"c1\">-- eval to 6</span>\n<span class=\"k\">#eval</span> <span class=\"n\">incr_b</span> <span class=\"mi\">5</span>  <span class=\"c1\">-- eval to 6 also</span>\n\n<span class=\"c1\">-- actually, they're the same by definition since · is just syntactic sugar</span>\n<span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"n\">incr_a</span> <span class=\"bp\">=</span> <span class=\"n\">incr_b</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Haskell lets you do the same : <code>(+1)</code> and so does PureScript <code>(_ + 1)</code>. Though the syntax is a bit different and Lean's version is more powerful as it can be used a bit more freely instead of just with operators.</p>",
        "id": 420725162,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1707510200
    },
    {
        "content": "<blockquote>\n<p>⟨h1, h2⟩ := h and obtain hx | hy := h</p>\n</blockquote>\n<p>Some low-level type theory stuff going on here: <code>,</code> separates multiple arguments in the same constructor of an inductive type, <code>|</code> separates different constructors of an inductive type.</p>",
        "id": 420725820,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1707510467
    },
    {
        "content": "<p>Using . to create lambdas is very close to what I’d say as a mathematician, eg “consider the function f(. + c)”</p>\n<p>The syntax “\\lambda x . t” or “fun x =&gt; t” I’ve always found a bit strange as a mathematician; I’d more naturally write something like “x =&gt; t”. (This is how you create lambdas in C#!)</p>",
        "id": 420791106,
        "sender_full_name": "Preeyan Parmar",
        "timestamp": 1707562955
    },
    {
        "content": "<p>It's a pity that \" f(. + c)\" doesn't actually work; you need <code>(f &lt;| . + c)</code> for that which an untrained mathematician can't parse.</p>",
        "id": 420811629,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1707581213
    },
    {
        "content": "<p><code>f (· + c)</code> does work, but it's not clear from this context if that's what you want - it passes <code>fun x =&gt; x + c</code> as an argument to <code>f</code>. If you want to compose the two functions you  could do <code>f ∘ (· + c)</code>.</p>",
        "id": 420826689,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707593147
    },
    {
        "content": "<p>Yeah, but with composition it's no longer reducible defeq to the other one.</p>",
        "id": 420827018,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1707593441
    }
]