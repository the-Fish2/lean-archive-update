[
    {
        "content": "<p>Hi I came accross this kind of werid question while I am learning the coherence theorem of monoidal categories. In usual textbook occasionally we use proof as data. Like the def of a category on \"ℕ\" that there is a  <strong>unique</strong> arrow from x to y if and only if x ≤ y. I saw that the definition of <code>Category</code> avoids doing this by requiring that arrow can not be <code>Prop</code>. I did an exercise like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">infer_instance</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">le</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">CategoryWithProofAsArrow</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The identity morphism on an object. -/</span>\n<span class=\"w\">  </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Composition of morphisms in a category, written `f ≫ g`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">proofAsArrow</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CategoryWithProofAsArrow</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\"> </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">le</span><span class=\"o\">])</span>\n<span class=\"w\"> </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">le</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*;</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_trans</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">repeat</span><span class=\"w\"> </span><span class=\"n\">assumption</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>what would happen for definition like this? It seems to be an advantage for it: the uniqueness of arrow between two objects is directly from <code>propext</code>. But I don't know the disadvantage though.</p>",
        "id": 445885702,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1718898716
    },
    {
        "content": "<p>Allowing the hom types to be propositions would make it much harder to integrate the category theory library with the rest of mathlib. That's because <code>Type u</code> is the standard.</p>\n<p>For example, <code>AddCommGroup A</code> requires <code>A : Type u</code>. So if you wanted to later state that ℕ is an additive category, you couldn't do it if the hom types were propositions.</p>\n<p>Fortunately, there is already a mechanism for constructing categories whose hom types are subsingleton: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Preorder.smallCategory#doc\">docs#Preorder.smallCategory</a>.</p>",
        "id": 445909564,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1718903443
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"695266\">Mitchell Lee</span> <a href=\"#narrow/stream/113489-new-members/topic/What.20would.20happen.20using.20proof.20as.20data.3F/near/445909564\">said</a>:</p>\n<blockquote>\n<p>Allowing the hom types to be propositions would make it much harder to integrate the category theory library with the rest of mathlib. That's because <code>Type u</code> is the standard.</p>\n</blockquote>\n<p>This is not <em>quite</em> the reason</p>",
        "id": 445910147,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718903642
    },
    {
        "content": "<p>Okay, bad example because ℕ isn't an additive category, but maybe I can think of a different one</p>",
        "id": 445910240,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1718903675
    },
    {
        "content": "<p>Thank you for the information! Yeah I check the link and find it using <code>Ulift</code>. Rather than this way, the free monoidal category uses totally a different approach via quotient and proves the hom types are singletons in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Monoidal/Free/Basic.html\">free monoidal category</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Monoidal/Free/Coherence.html\">the coherence theorem</a></p>",
        "id": 445910969,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1718903931
    },
    {
        "content": "<p>the original example for me is that I want to see what would happen if fuzzily defined the morphisms of the free monoidal category to be proof of words has same length, i.e, that there is an unique morphsim between two words x and y iff they have the same length, like <code>((aa)e)a</code> to <code>(((ea)a)a</code></p>",
        "id": 445911686,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1718904153
    },
    {
        "content": "<p><code>Ulift</code> seems kind of using prop as morphisms, since it turns <code>Prop</code> to a <code>Type u</code>. Maybe it’s not a big issue here.</p>",
        "id": 445912337,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1718904363
    }
]