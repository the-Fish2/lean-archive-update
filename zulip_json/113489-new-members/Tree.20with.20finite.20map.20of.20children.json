[
    {
        "content": "<p>I would like to define a tree data type where a node consists of a finite map from naturals to children:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">tree</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">tree</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">:</span> <span class=\"n\">finmap</span> <span class=\"n\">Nat</span> <span class=\"n\">tree</span> <span class=\"bp\">→</span> <span class=\"n\">tree</span>\n</code></pre></div>\n<p>A <code>finmap K V</code> should be like <code>K → Option V</code> but with the constraint that only finitely many <code>K</code> map to <code>Some</code>. I am having trouble arranging this in such a way that I can write functions by recursion and prove theorems by induction. For example, a function that negates all the booleans at the leaves, and prove that doing this twice is the identity. What is the right approach in this situation?</p>",
        "id": 423110145,
        "sender_full_name": "Jules Jacobs",
        "timestamp": 1708730767
    },
    {
        "content": "<p>maybe something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">tree</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tree</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">tree</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tree</span>\n</code></pre></div>",
        "id": 423125622,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1708743765
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">tree</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tree</span>\n<span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">tree</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tree</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">negate</span> <span class=\"o\">:</span> <span class=\"n\">tree</span> <span class=\"bp\">→</span> <span class=\"n\">tree</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">!</span><span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">negate</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">negate</span> <span class=\"bp\">∘</span> <span class=\"n\">negate</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">t</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Function.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">id_eq</span><span class=\"o\">]</span>\n  <span class=\"n\">induction'</span> <span class=\"n\">t</span> <span class=\"k\">with</span> <span class=\"n\">l</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"n\">IH</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">negate</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">negate</span><span class=\"o\">,</span> <span class=\"n\">IH</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 423127833,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1708745581
    },
    {
        "content": "<p>If you really need <code>Nat -&gt; Option Tree</code> it's going to be a pain. Lean's limited support for nested inductive types does allow you to write <code>| node : (Nat → (Option Tree)) → Tree</code>, but it doesn't allow you to add any further arguments which depend on that function, so you'll have trouble adding a finiteness condition. In the future, hopefully we'll have a proper datatypes package which supports use cases like this, but for now we're stuck with some ugly workarounds. The best way I know is to create an initial inductive type without the side conditions and then define <code>Tree</code> as a subtype of that.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- A tree data type which doesn't quite meet the specification - each node can have potentially infinite children</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">PreTree</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">PreTree</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">PreTree</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">PreTree</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">IsFinmap</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">≥</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">none</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">PreTree</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">IsFinite</span> <span class=\"o\">:</span> <span class=\"n\">PreTree</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsFinite</span> <span class=\"o\">(</span><span class=\"n\">leaf</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">PreTree</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">IsFinmap</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">IsFinite</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">IsFinite</span> <span class=\"o\">(</span><span class=\"n\">node</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">PreTree</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Tree</span> <span class=\"n\">where</span>\n  <span class=\"n\">toPreTree</span> <span class=\"o\">:</span> <span class=\"n\">PreTree</span>\n  <span class=\"n\">isFinite</span> <span class=\"o\">:</span> <span class=\"n\">toPreTree.IsFinite</span>\n</code></pre></div>",
        "id": 423133596,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708749937
    },
    {
        "content": "<p>I suspect the <code>Option</code> requirement is an <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> problem... if the requirement is only \"a finite map from naturals to children\" then there are better ways to handle it, I think</p>",
        "id": 423134964,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1708750919
    },
    {
        "content": "<p>If you do need nested <code>Option Tree</code>, the other annoying thing is that it becomes impossible to use structural recursion. The typical way of doing recursive definitions with a nested inductive type is to establish a well-founded relation like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">PreTree</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">PreTree</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">PreTree</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">PreTree</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">PreTree</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">IsChildOf</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">PreTree</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">node</span> <span class=\"n\">f</span> <span class=\"bp\">∧</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">not_isChildOf_leaf</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">PreTree</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">x.IsChildOf</span> <span class=\"o\">(</span><span class=\"n\">leaf</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">IsChildOf</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">isChildOf_node</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">PreTree</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">PreTree</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x.IsChildOf</span> <span class=\"o\">(</span><span class=\"n\">node</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">IsChildOf</span><span class=\"o\">]</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">PreTree.rec</span> <span class=\"c1\">-- Nested inductive types have recurses with multiple motives</span>\n\n<span class=\"c1\">-- Luckily, once we define this well-founded relation, we'll never have to use the recursor again.</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">wellFounded_IsChildOf</span> <span class=\"o\">:</span> <span class=\"n\">WellFounded</span> <span class=\"n\">IsChildOf</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span>\n  <span class=\"n\">apply</span> <span class=\"n\">PreTree.rec</span> <span class=\"o\">(</span><span class=\"n\">motive_1</span> <span class=\"o\">:=</span> <span class=\"n\">Acc</span> <span class=\"n\">IsChildOf</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">motive_2</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">PreTree</span> <span class=\"bp\">↦</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">o</span><span class=\"o\">,</span> <span class=\"n\">Acc</span> <span class=\"n\">IsChildOf</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">b</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"n\">simp</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">f</span> <span class=\"n\">ih</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"n\">intro</span> <span class=\"n\">y</span> <span class=\"n\">h</span>\n    <span class=\"k\">suffices</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rcases</span> <span class=\"n\">this</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span>\n      <span class=\"n\">exact</span> <span class=\"n\">ih</span> <span class=\"n\">i</span> <span class=\"n\">y</span> <span class=\"n\">hi</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">h</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">WellFoundedRelation</span> <span class=\"n\">PreTree</span> <span class=\"n\">where</span>\n  <span class=\"n\">rel</span> <span class=\"o\">:=</span> <span class=\"n\">IsChildOf</span>\n  <span class=\"n\">wf</span> <span class=\"o\">:=</span> <span class=\"n\">wellFounded_IsChildOf</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">flip</span> <span class=\"o\">:</span> <span class=\"n\">PreTree</span> <span class=\"bp\">→</span> <span class=\"n\">PreTree</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">leaf</span> <span class=\"bp\">!</span><span class=\"n\">b</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">node</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">↦</span>\n      <span class=\"k\">match</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n        <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n      <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">t</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">flip_flip</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">PreTree</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">flip</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">t</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">flip</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">flip</span><span class=\"o\">]</span>\n    <span class=\"n\">funext</span> <span class=\"n\">i</span>\n    <span class=\"k\">match</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">flip_flip</span> <span class=\"n\">c</span><span class=\"o\">]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">t</span>\n</code></pre></div>",
        "id": 423135868,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708751609
    },
    {
        "content": "<p>Another option if you need the mapping from naturals to children to be sparse is to split the <code>Nat -&gt; Option Tree</code> into two components <code>apply : Nat -&gt; Tree</code> and <code>contains : Nat -&gt; Bool</code>. Then <code>apply i</code> is a garbage value whenever <code>contains i</code> is false.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">PreTree</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">PreTree</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node'</span> <span class=\"o\">(</span><span class=\"n\">apply</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">PreTree</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">contains</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">isFinite</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">≥</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">contains</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">ff</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This avoids nested inductives so gives you nice structural recursion again. You could then define <code>Tree</code> as a quotient of <code>PreTree</code> to ignore the garbage values.</p>",
        "id": 423138500,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708753971
    },
    {
        "content": "<p>Thanks for the helpful answer, that's exactly what I needed!</p>",
        "id": 423139294,
        "sender_full_name": "Jules Jacobs",
        "timestamp": 1708754763
    }
]