[
    {
        "content": "<p>I'm trying to write a function to calculate the length of a list by using a divide-and-conquer algorithm, but I get some problems when it comes to proving the termination of the function.  My code is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">dac_length</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">b</span><span class=\"o\">::</span><span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">sp</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">List.split</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">b</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">))</span><span class=\"bp\">;</span>\n    <span class=\"k\">let</span> <span class=\"n\">llen</span> <span class=\"o\">:=</span> <span class=\"n\">dac_length</span> <span class=\"n\">sp.1</span><span class=\"bp\">;</span>\n    <span class=\"k\">let</span> <span class=\"n\">rlen</span> <span class=\"o\">:=</span> <span class=\"n\">dac_length</span> <span class=\"n\">sp.2</span><span class=\"bp\">;</span>\n    <span class=\"n\">llen</span> <span class=\"bp\">+</span> <span class=\"n\">rlen</span>\n  <span class=\"n\">termination_by</span> <span class=\"n\">List.length</span> <span class=\"n\">l</span>\n    <span class=\"n\">decreasing_by</span>\n      <span class=\"n\">simp_wf</span>\n      <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The context are as follow:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">ab</span><span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"n\">xs</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n<span class=\"n\">sp</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">List.split</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">Nat.succ</span> <span class=\"o\">(</span><span class=\"n\">List.length</span> <span class=\"o\">(</span><span class=\"n\">List.split</span> <span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Nat.succ</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"o\">(</span><span class=\"n\">List.length</span> <span class=\"n\">xs</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>My idea is to use a pair to replace <code>List.split a::b::xs</code> and apply <code>List.length_split_lt</code> . In the context, <code>sp : List α × List α := List.split (a :: b :: xs) </code>, I don't know how to construct a <code>pair</code> to rewrite this rule to make it like <code>sp : (llen, rlen) = List.split (a::b::xs)</code>. And another question is that after using <code>simp_wf</code>, <code>a::b::xs</code> is evaluated by <code>List.length.</code> How to prevent this form?</p>",
        "id": 430104348,
        "sender_full_name": "Fangyu Hu",
        "timestamp": 1711641606
    },
    {
        "content": "<p>Hmm, these <code>List.lenght_split.lt</code> lemmas aren’t written very helpfully, at least not for your use case. I would suggest you write a helper lemma saying <code>List.length (List.split xs).1 ≤ List.length xs</code> and use it here.</p>",
        "id": 430109800,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1711642903
    },
    {
        "content": "<p>Oh, yes, it does work! <br>\nThanks for your help!</p>",
        "id": 430115745,
        "sender_full_name": "Fangyu Hu",
        "timestamp": 1711644230
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"694651\">Fangyu Hu</span> has marked this topic as resolved.</p>",
        "id": 430115765,
        "sender_full_name": "Notification Bot",
        "timestamp": 1711644234
    },
    {
        "content": "<p>I guess this is useful as an exercise. But <code>List.split</code> is defined recursivly without tail recursion. So while <code>List.length</code> correctly evaluates for <code>List.range 10000</code>, <code>List.split</code> and therefore <code>dac_length</code> will lead to a stack overflow. Even if this were fixed for <code>List.split</code>, this code still wouldn't be faster than <code>List.length</code>.</p>",
        "id": 430135797,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1711649174
    },
    {
        "content": "<p>Yes, I haven't notice that before. I only considered divide and conquer without thinking about the tail recursion. This may not be a good way to implement it. Thanks for reminding me.</p>",
        "id": 430202324,
        "sender_full_name": "Fangyu Hu",
        "timestamp": 1711688129
    }
]