[
    {
        "content": "<p><a href=\"/user_uploads/3121/mdWdddM_K9mX6dgtF86Jsm6F/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/mdWdddM_K9mX6dgtF86Jsm6F/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/mdWdddM_K9mX6dgtF86Jsm6F/image.png\"></a></div><p>Hello,</p>\n<p>I've implemented a prime sieve based on juggling arithmetic sequences around, and I see that it works. But now I would like to prove it.</p>\n<p><a href=\"https://github.com/tangentstorm/treesiv/blob/main/Main.lean\">https://github.com/tangentstorm/treesiv/blob/main/Main.lean</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\">  </span><span class=\"c1\">-- arithmetic series (k + dn)</span>\n<span class=\"w\">  </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">  </span><span class=\"c1\">-- constant</span>\n<span class=\"w\">  </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">  </span><span class=\"c1\">-- difference</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ord</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\">  </span><span class=\"c1\">-- but there's no List.sort? !!</span>\n<span class=\"w\">  </span><span class=\"n\">compare</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">compare</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"bp\">.</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"bp\">.</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">compare</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"bp\">.</span><span class=\"n\">d</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ord</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ord</span>\n\n<span class=\"c1\">-- mk k d = k + d*n</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- apply formula to n</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"c1\">-- apply one formula to another: r(n) := s(t(n))</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">compose</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- identity series</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">id1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">partition</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">compose</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ToString</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"s2\">\"n\"</span>\n<span class=\"w\">      </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{s.d}n\"</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{s.k}\"</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"n + {s.k}\"</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{s.d}n + {s.k}\"</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">terms</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"n\">ap</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">i</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">         </span><span class=\"c1\">-- all primes we've used so far</span>\n<span class=\"w\">  </span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">              </span><span class=\"c1\">-- current primorial (product of ps)</span>\n<span class=\"w\">  </span><span class=\"n\">np</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">              </span><span class=\"c1\">-- next prime</span>\n<span class=\"w\">  </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"w\">        </span><span class=\"c1\">-- list of sequences</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ToString</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"ps: {s.ps}, pr: {s.pr}, np: {s.np}, ss: {s.ss}\"</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">np</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">id1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s0</span><span class=\"bp\">.</span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">s0</span><span class=\"bp\">.</span><span class=\"n\">np</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s0</span><span class=\"bp\">.</span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">s0</span><span class=\"bp\">.</span><span class=\"n\">np</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ss0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s0</span><span class=\"bp\">.</span><span class=\"n\">ss</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">partition</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">s0</span><span class=\"bp\">.</span><span class=\"n\">np</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">join</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ss0</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">s0</span><span class=\"bp\">.</span><span class=\"n\">np</span><span class=\"w\"> </span><span class=\"bp\">!=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"c1\">-- strip out multiples of np</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">np</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">minimum?</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">f1</span><span class=\"o\">:=</span><span class=\"n\">ap</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">f1</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">ap</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">f1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">get!</span><span class=\"w\"> </span><span class=\"c1\">-- series with next prime</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pr</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">np</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">np</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">printStep</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">println</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">ss</span><span class=\"bp\">.</span><span class=\"n\">forM</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">width</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">15</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">formula</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">pushn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"n\">width</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">take</span><span class=\"w\"> </span><span class=\"n\">width</span>\n<span class=\"w\">    </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">println</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{formula}: {(terms s n)}\"</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">main</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">sv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">init</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">10</span>\n<span class=\"w\">  </span><span class=\"n\">printStep</span><span class=\"w\"> </span><span class=\"n\">sv</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"mi\">5</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">sv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"n\">sv</span>\n<span class=\"w\">    </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">println</span><span class=\"w\"> </span><span class=\"s2\">\"----------------\"</span>\n<span class=\"w\">    </span><span class=\"n\">printStep</span><span class=\"w\"> </span><span class=\"n\">sv</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">main</span>\n</code></pre></div>\n<p>But how do I even start?</p>\n<p>Currently, it tracks a list of known primes and a next prime (<code>np</code>). I think I want to force things so that the next prime is of type <code>Prime</code>... Would I just bake a \"prime\" type directly into my data structure?</p>\n<p>I <em>think</em> what I want to do is use the type system to assert:</p>\n<ul>\n<li>the \"next prime\" is a prime</li>\n<li>the \"known primes\" are all prime, and also contain ALL primes less than \"next prime\"</li>\n</ul>\n<p>Then I think I to prove that I calculate the next prime correctly, I'd have to demonstrate that my list of arithmetic series together generate all natural numbers that are not multiples of a known prime, and (since they all have the same slope) the next prime is the minimal term in one of the series.</p>\n<p>Does this general plan make sense? And if so, how do I even express it?</p>\n<p>I'm going to start by just setting the type of \"next prime\" and see where it leads, but if anyone could give me a few hints, I'd really appreciate it.</p>\n<p>Thanks!</p>",
        "id": 446923432,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719330786
    },
    {
        "content": "<p>We prefer <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a> to unreadable screenshots. Can you update?</p>",
        "id": 446937306,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1719333796
    },
    {
        "content": "<p>I think the link to the code matches what's in the screenshot (minus the infoview output)</p>",
        "id": 446939162,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1719334223
    },
    {
        "content": "<p>Yes, but I'll post the code directly. :)</p>",
        "id": 446943206,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719335200
    },
    {
        "content": "<p>(oops, I'm sorry, I missed this <code>SHOW MORE</code> button this time, my apologies)</p>",
        "id": 446949262,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1719336557
    },
    {
        "content": "<p>It seems like <code>Mathlib.Data.Nat.Prime</code> is a proposition, not just a Type.</p>\n<p>I found this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ToString</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{s.val}\"</span>\n</code></pre></div>\n<p>Then I was able to declare my types like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\">      </span><span class=\"c1\">-- all primes we've used so far</span>\n<span class=\"w\">  </span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">              </span><span class=\"c1\">-- current primorial (product of ps)</span>\n<span class=\"w\">  </span><span class=\"n\">np</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\">           </span><span class=\"c1\">-- next prime</span>\n<span class=\"w\">  </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"w\">        </span><span class=\"c1\">-- list of sequences</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n</code></pre></div>\n<p>So far that required two changes: every time I assign the <code>np</code> field, I now need to pair it with a proof that the number is prime in special angle brackets.</p>\n<p>The proof that the initial 2 is prime is provided by the Mathlib:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">np</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">prime_two</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">id1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>But for <code>step</code>, I'm on my own:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pr</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">np</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">np</span><span class=\"o\">,</span><span class=\"gr\">sorry</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>I'm not sure how I can even start to prove this without knowing that <code>ps</code> contains <em>all</em> the primes less than  np, which won't be true unless I bake it into the type, and I don't know how to express that yet.</p>\n<p>Possibly I can just add any proposition to the type with the magic <code>//</code> symbol?</p>",
        "id": 446976613,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719343816
    },
    {
        "content": "<p>You can add fields to your structure that are propositions</p>",
        "id": 446984294,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1719346160
    },
    {
        "content": "<p>Interesting.. I can almost see how that would work. I think the proof outline is something like this:</p>\n<ul>\n<li>theorem: <code>np</code> really is the next prime after each <code>step</code>, because<ul>\n<li>the items in <code>ss</code> together contain all nats &gt; 2 that are not multiples of a current prime (and i need to prove that this holds at each partition step). this means:<ul>\n<li>the <code>partition</code> operation must actually partition the series (and not accidentally lose a value that might be the next prime)</li>\n<li>the <code>filter</code> operation removes exactly the multiples of the current <code>next prime</code></li>\n</ul>\n</li>\n<li>the sequences all have the same slope (.ss[i].d = .pr) so the lowest first term is the next prime (though currently I still have a 1 floating around as the first term in one series at each step)</li>\n</ul>\n</li>\n</ul>",
        "id": 446988226,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719347365
    },
    {
        "content": "<p>On further reflection, I think what I really ought to do is prove a basic theorem about the idea of prime sieves:</p>\n<ul>\n<li>The smallest natural number that is coprime to all primes smaller than it is prime.</li>\n</ul>\n<p>Then for my particular implementation, I need to show that:</p>\n<ul>\n<li>the list of known primes is complete up to the \"next prime\" variable</li>\n<li>the list of arithmetic progressions together represent every natural number except those coprime to the list of known primes. </li>\n<li>that from these, i am correctly identifying the minimal coprime number</li>\n</ul>\n<p>I think the \"representing all the coprimes\" part is two more or less induction, except not using the \"induction\" tactic but an invariant on the type itself, so:</p>\n<div class=\"codehilite\"><pre><span></span><code>-  the initial sieve value represents all natural numbers (maybe all &gt; 2)\n- at each step we remove exactly the multiples of the next prime (so we use the proof on the input as the induction hypothesis)\n</code></pre></div>\n\n<p>So the first part is an obvious-to-me mathematical statement about why prime sieves produce primes (so hopefully easy to prove in lean??)... And then once that framework is in place to describe formally what a prime sieve is, I can prove that this particular algorithm and data structure actually is a prime sieve.</p>\n<p>I will continue to post here to document my progress. If anyone has observations/ideas for making any of this more approachable, please comment!</p>",
        "id": 447271099,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719420397
    },
    {
        "content": "<p>Woo! I managed to prove that if a natural number greater than 1 has no prime factors less than it, it must be prime:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">no_prime_factors_im_no_factors</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"c1\">-- c is a candidate prime</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hcg2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\">                              </span><span class=\"c1\">-- c is greater than 2</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hnpf</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"n\">c</span><span class=\"o\">))</span><span class=\"w\">      </span><span class=\"c1\">-- c has no prime factors</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hno</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">=</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\">  </span><span class=\"c1\">-- c has no divisors at all</span>\n<span class=\"w\">      </span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">hmc</span><span class=\"w\"> </span><span class=\"n\">hmdc</span><span class=\"w\"> </span><span class=\"c1\">-- give names to the above assumptions</span>\n<span class=\"w\">      </span><span class=\"n\">by_contra</span><span class=\"w\"> </span><span class=\"n\">hnme1</span><span class=\"w\">   </span><span class=\"c1\">-- assume ¬(m=1) and show contradiction</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hmn1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">assumption</span>\n<span class=\"w\">      </span><span class=\"c1\">-- obtain a prime factor of m since it isn't 1</span>\n<span class=\"w\">      </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hpp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hpm</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">exists_prime_and_dvd</span><span class=\"w\"> </span><span class=\"n\">hmn1</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h0</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">dvd_trans</span><span class=\"w\"> </span><span class=\"n\">hpm</span><span class=\"w\"> </span><span class=\"n\">hmdc</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hzlc</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hzlm</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">pos_of_dvd_of_pos</span><span class=\"w\"> </span><span class=\"n\">hmdc</span><span class=\"w\"> </span><span class=\"n\">hzlc</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hplm</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_dvd</span><span class=\"w\"> </span><span class=\"n\">hzlm</span><span class=\"w\"> </span><span class=\"n\">hpm</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hplc</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"w\">        </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hnpf</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">hplc</span><span class=\"w\"> </span><span class=\"n\">hpp</span>\n<span class=\"w\">      </span><span class=\"n\">contradiction</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">prime_def_lt</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">hcg2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hno</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>This was the main step that was worrying me, because it maps the conditions provided by a sieve to the conditions that mathlib uses in the definition of <code>Nat.Prime</code>.</p>",
        "id": 447872026,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719608618
    },
    {
        "content": "<p>I guess if you are using <code>Nat.exists_prime_and_dvd</code> you may as well do this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">no_prime_factors_im_no_factors</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"c1\">-- c is a candidate prime</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hcg2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\">                              </span><span class=\"c1\">-- c is greater than 2</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hnpf</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"n\">c</span><span class=\"o\">))</span><span class=\"w\">      </span><span class=\"c1\">-- c has no prime factors</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hcn1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Ne</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">ne_of_lt</span><span class=\"w\"> </span><span class=\"n\">hcg2</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hpp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hpc</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">exists_prime_and_dvd</span><span class=\"w\"> </span><span class=\"n\">hcn1</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hpec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hzlc</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hplc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_dvd</span><span class=\"w\"> </span><span class=\"n\">hzlc</span><span class=\"w\"> </span><span class=\"n\">hpc</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hpgc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_not_lt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">hnpf</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">hpp</span><span class=\"w\"> </span><span class=\"n\">hpc</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_antisymm</span><span class=\"w\"> </span><span class=\"n\">hplc</span><span class=\"w\"> </span><span class=\"n\">hpgc</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">hpec</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hpp</span>\n</code></pre></div>",
        "id": 447921047,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1719635251
    },
    {
        "content": "<p>I am quite stuck at the moment. I want to refer to the infimum of the following set:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- the set of naturals with no prime factors less than some c</span>\n<span class=\"c1\">-- \"remaining set\"? \"residual set?\"</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">rs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>I want to prove that :</p>\n<ul>\n<li>my algorithm produces the infimum of this set, and</li>\n<li>the infimum of the set is prime</li>\n</ul>\n<p>I am pretty sure I can prove both of these statements, but I'm stuck trying to figure out how to express the idea of an infimum... I see that <code>Inf $ rs c</code> is an expression that produces a type, but I don't understand what to do with it.</p>\n<p>How would I obtain a member of that type? What would I do with it? I think I'm missing something basic here.</p>",
        "id": 448089996,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719737190
    },
    {
        "content": "<p>Actually I might even be using the term wrong. I want the minimal element of the set. I know it exists. I can obtain it. I just don't know how to express the concept so I can prove I'm doing it. Any ideas?</p>",
        "id": 448090276,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719737447
    },
    {
        "content": "<p>You want <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=sInf#doc\">docs#sInf</a>, s for set</p>",
        "id": 448093036,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719739210
    },
    {
        "content": "<p>That will give you a Nat. Plain Inf is the binary operator of two elements</p>",
        "id": 448093102,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719739243
    },
    {
        "content": "<p>Regarding your definition, wouldn't 1 be in the set?</p>",
        "id": 448093165,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719739280
    },
    {
        "content": "<p>If c&lt;=2 then the min is zero and if c&gt;2 it's 1, so in fact the minimum is never prime. Is there a typo somewhere?</p>",
        "id": 448093993,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1719739660
    },
    {
        "content": "<p>Perhaps adding the predicate that c &lt; n to the set will rescue the definition?</p>",
        "id": 448118550,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719756701
    },
    {
        "content": "<p>It might be easier to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.find#doc\">docs#Nat.find</a> ?</p>",
        "id": 448129077,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1719761582
    },
    {
        "content": "<p>you realize you are reinventing <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.minFac#doc\">docs#Nat.minFac</a> ?</p>",
        "id": 448135041,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719764407
    },
    {
        "content": "<p><code>no_prime_factors_im_no_factors</code> also looks like a theorem that should already exist</p>",
        "id": 448135106,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719764443
    },
    {
        "content": "<p>I don't understand what you guys are saying. I'm trying to express the idea that rs(c) is the set of all natural numbers (n) such that n is not a multiple of a prime less than c.    It's a prime sieve, so I'm trying to describe all the numbers that haven't been crossed out yet, and then I want to obtain the smallest number in that set so I can demonstrate that it is prime.</p>",
        "id": 448139952,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719766062
    },
    {
        "content": "<p>Is <code>rs</code> saying something other than that?</p>",
        "id": 448140045,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719766091
    },
    {
        "content": "<p>this already works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- if c is a member of rs c, then c is prime</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">cprime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">≥</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hcrc</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">rs</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\">  </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hh</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">rs</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hcrc</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hcrc</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">no_prime_factors_im_no_factors</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"n\">hh</span>\n\n<span class=\"c1\">-- show that 2 is part of rs 2 for initial case</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">cprime2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">rs</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">rs</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"n\">hprime</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_lt_succ</span><span class=\"w\"> </span><span class=\"n\">hp</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">prime_def_lt</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hprime</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">left</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">not_le_of_gt</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n<span class=\"w\">  </span><span class=\"n\">contradiction</span>\n</code></pre></div>",
        "id": 448140384,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719766291
    },
    {
        "content": "<p>Oh ... I see my error now. Yes, I need to add <code>c ≤ n</code>... I think in this case the infimum is also the minimum but I'm not sure. I'll try to proceed with <code>sInf</code>. Thanks!</p>",
        "id": 448142222,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719767087
    },
    {
        "content": "<p>do you have a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> of this?</p>",
        "id": 448143067,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719767517
    },
    {
        "content": "<p>Sort of. Here's what I have so far, and all of this typechecks.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Linarith</span><span class=\"bp\">.</span><span class=\"n\">Frontend</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">no_prime_factors_im_no_factors</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"c1\">-- c is a candidate prime</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h2lc</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\">                              </span><span class=\"c1\">-- c is at least 2</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hnpf</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"n\">c</span><span class=\"o\">))</span><span class=\"w\">      </span><span class=\"c1\">-- c has no prime factors</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">=</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\">  </span><span class=\"c1\">-- c has no divisors but 1 and c</span>\n<span class=\"w\">      </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">hmc</span><span class=\"w\"> </span><span class=\"n\">hmdc</span><span class=\"w\">  </span><span class=\"c1\">-- give names to the above assumptions</span>\n<span class=\"w\">      </span><span class=\"n\">by_contra</span><span class=\"w\">         </span><span class=\"c1\">-- assume ¬(m=1) and show contradiction</span>\n<span class=\"w\">      </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hpp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hpm</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">        </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">exists_prime_and_dvd</span><span class=\"w\"> </span><span class=\"bp\">‹</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">›</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">dvd_trans</span><span class=\"w\"> </span><span class=\"n\">hpm</span><span class=\"w\"> </span><span class=\"n\">hmdc</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">pos_of_dvd_of_pos</span><span class=\"w\"> </span><span class=\"n\">hmdc</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_dvd</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">hpm</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"w\">        </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hnpf</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">hpp</span>\n<span class=\"w\">      </span><span class=\"n\">contradiction</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">prime_def_lt</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"bp\">⟨‹</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">›</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">rs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">cprime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">≥</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hcrc</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">rs</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\">  </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hh</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">rs</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hcrc</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hcrc</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">no_prime_factors_im_no_factors</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"n\">hh</span>\n\n<span class=\"c1\">-- show that 2 is part of rs 2 for initial case</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">cprime2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">rs</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">rs</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"n\">hprime</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_lt_succ</span><span class=\"w\"> </span><span class=\"n\">hp</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">prime_def_lt</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hprime</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">left</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">not_le_of_gt</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n<span class=\"w\">  </span><span class=\"n\">contradiction</span>\n</code></pre></div>\n<p>But I don't have anything about the minimal item, because I don't know how to express it.</p>",
        "id": 448143988,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719767968
    },
    {
        "content": "<p>what happened to the sieve program?</p>",
        "id": 448144556,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719768198
    },
    {
        "content": "<p>Oh, the sieve is here: <a href=\"https://github.com/tangentstorm/treesiv/blob/main/Main.lean\">https://github.com/tangentstorm/treesiv/blob/main/Main.lean</a></p>",
        "id": 448144715,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719768244
    },
    {
        "content": "<p>What is it you are trying to prove?</p>",
        "id": 448144720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719768245
    },
    {
        "content": "<p>I think what you want to prove by induction or execution is that <code>minFac n &gt;= a</code></p>",
        "id": 448144996,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719768338
    },
    {
        "content": "<p>and if <code>a</code> gets to <code>n</code> then you know <code>n</code> is prime</p>",
        "id": 448145033,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719768350
    },
    {
        "content": "<p>Hang on. I'm trying to put the answer to your first question into words.</p>",
        "id": 448145224,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719768430
    },
    {
        "content": "<blockquote>\n<p><code>-- but there's no List.sort? !!</code></p>\n</blockquote>\n<p>There is <code>List.mergeSort</code></p>",
        "id": 448146319,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719768700
    },
    {
        "content": "<p>What is the purpose of this program? It seems like it does exponential work compared to the actual list of primes coming out in <code>ps</code></p>",
        "id": 448146848,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719768828
    },
    {
        "content": "<p>A prime sieve (at least one that works like the sieve of eratosthenes) is some algorithm that at each step, has identified all the primes up to some prime P, and has \"scratched out\" all the multiples of those primes from the set of all natural numbers.</p>\n<p>I have implemented a prime sieve, and want to prove that the algorithm works: that it always finds the next prime.</p>\n<p>But I guess there are many ways you could implement a sieve like this. For example, the traditional implementation generates an array of booleans corresponding to a range of numbers, and then loops through and flips the bit for each multiple... The algorithm here is not as efficient. It's taking an initial arithmetic sequence (2 + n) and at each step is partitioning it into sub-sequences, using this to find the next prime, and removing the sequences that are multiples of a prime.</p>",
        "id": 448147076,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719768879
    },
    {
        "content": "<p>The first step in proving an algorithm like this correct is to define the invariants. What are all the properties you expect to be true of the input and result of the <code>step</code> function?</p>",
        "id": 448147232,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719768917
    },
    {
        "content": "<p>Yes. There's no real practical point to it, other than as an exercise. Although it does have a nice property that it very quickly generates a bunch of huge candidate numbers that are somewhat likely to be prime.</p>",
        "id": 448147322,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719768942
    },
    {
        "content": "<p>Some of them are in comments, and you can move them to fields of the structure like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">              </span><span class=\"c1\">-- current primorial (product of ps)</span>\n</code></pre></div>\n<p>as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">pr_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"bp\">.</span><span class=\"n\">foldr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 448147350,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719768951
    },
    {
        "content": "<p>Oh I wasn't questioning the practicality, only trying to understand what properties you are going for</p>",
        "id": 448147505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719768987
    },
    {
        "content": "<p>From a doc I'm writing:</p>\n<p>The sieve tracks this info:</p>\n<ul>\n<li>C is the “current prime”</li>\n<li>S is the set of all primes less than C.</li>\n<li>R (for “remaining”) is the set of naturals with no prime factors in S.</li>\n<li>Q is the set of sequences that model R</li>\n</ul>\n<p>The smallest of these is the next prime. (May still need to prove this.) </p>\n<p>I suppose I would need to show the following:</p>\n<ul>\n<li>At each step, I have a correct mapping to R.</li>\n<li>R’ := R - multiples of C</li>\n<li>C’ is the smallest one.</li>\n</ul>\n<p>How do I prove that I’m tracking R correctly?<br>\nAgain by “induction” using a proposition field.</p>\n<p>-The field says I have a mapping to all naturals that are not multiples of found primes.</p>\n<ul>\n<li>I’m now removing multiples of one new prime.</li>\n<li>\n<p>A sequence is of the form ( k + dn )<br>\n- k∣d this means it’s k + (jk)n or  k(1+jn)]</p>\n</li>\n<li>\n<p>Same applies to any ik + (jk)n </p>\n</li>\n<li>Every item in these series will be a multiple of K.</li>\n<li>How to show that only sequences whose constant terms are multiples of k yield multiples of k?</li>\n<li>K∣(X + JKN) iff X%K=0, because (JKN+X)%K reduces to X%K</li>\n<li>D is of the form JK, since D is the primorial whose largest factor is K</li>\n<li>So this is how we justify the step of partitioning the previous list of sequences by K: the goal is to make the difference coefficient a multiple of K. The way to do that is to split each sequence into K sequences, or rather to apply each sequence to the sequences  0+Kn, 1+Kn, 2+Kn… (K-1)+Kn</li>\n</ul>\n<p>How do I prove that my algorithm finds the smallest item in R?</p>\n<ul>\n<li>Q partitions R into sequences of the form K+Dn</li>\n<li>The smallest item in R must be the smallest constant coefficient in one of these</li>\n</ul>",
        "id": 448147594,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719769060
    },
    {
        "content": "<p>I guess you renamed everything in the lean code? I don't see C, S, R, Q</p>",
        "id": 448147694,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719769106
    },
    {
        "content": "<p>C S R Q are like an abstract description of what any prime sieve along the lines of eratosthenes must be doing... But the actual implementation can vary.</p>",
        "id": 448147960,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719769289
    },
    {
        "content": "<p>well I'm asking more specifically what properties hold of the object you have called <code>PrimeSieve</code></p>",
        "id": 448147989,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719769314
    },
    {
        "content": "<p>First, if it's not clear: I'm a software developer, not in any way a mathematician.... So I'm thinking like a software developer, and that might be a problem here. In my mind, I don't want to just directly prove that this prime sieve works... I want to make a general description of what a generic prime sieve does, and then demonstrate that this particular one does all those things.</p>\n<p>So, I'm attempting to write an abstract proof in terms of these C S R Q  things, and then I want to demonstrate that at each step, the prime sieve is somehow modelling these things.</p>",
        "id": 448148380,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719769500
    },
    {
        "content": "<p>I think you end up with this list of invariants:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\">      </span><span class=\"c1\">-- all primes we've used so far</span>\n<span class=\"w\">  </span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">              </span><span class=\"c1\">-- current primorial (product of ps)</span>\n<span class=\"w\">  </span><span class=\"n\">np</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\">           </span><span class=\"c1\">-- next prime</span>\n<span class=\"w\">  </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ASeq</span><span class=\"w\">        </span><span class=\"c1\">-- list of sequences</span>\n<span class=\"w\">  </span><span class=\"n\">pr_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"bp\">.</span><span class=\"n\">foldr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"c1\">-- pr is the product of ps</span>\n<span class=\"w\">  </span><span class=\"n\">ps_sorted</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">np</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">Pairwise</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">·.</span><span class=\"m\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- ps ++ [np] is sorted</span>\n<span class=\"w\">  </span><span class=\"n\">all_primes</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">np</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"c1\">-- ps ++ [np] contains the complete list of primes</span>\n<span class=\"w\">  </span><span class=\"n\">divisible</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">np</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">np</span><span class=\"o\">]),</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ap</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">    </span><span class=\"c1\">-- a number larger than np is contained in one of the sequences iff it does not divide all listed primes</span>\n</code></pre></div>",
        "id": 448148413,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719769519
    },
    {
        "content": "<p>If you want to describe a \"generic prime sieve\", then write that down as a definition and prove that this prime sieve relates to that</p>",
        "id": 448148597,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719769664
    },
    {
        "content": "<p>Like, I'm also looking at another sieve someone else implemented:  <a href=\"https://github.com/ykonstant1/esiv\">https://github.com/ykonstant1/esiv</a><br>\nAnd I want to show that that, too, has the behaviors I want in terms of C/S/R/Q.</p>\n<p>But none of these algorithms actually have the \"set of all natural numbers\" lying around... You'd need infinite RAM. But instead, you can show that the algorithm somehow has a mapping to these  numbers (a traditional sieve just generates it a bit at a time, this one models it as the list of sequences...)</p>",
        "id": 448148709,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719769706
    },
    {
        "content": "<p>no worries, lean is good at holding \"the set of all natural numbers\" in its head :)</p>",
        "id": 448148718,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719769729
    },
    {
        "content": "<p>Yes, that's what I want to do. But I basically need to say \"C' is the min item in R\" and I don't know how to write that sentence.</p>",
        "id": 448148744,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719769753
    },
    {
        "content": "<p>the simple way is to just write that out as a predicate: <code>C' ∈ R ∧ ∀ x ∈ R, C' ≤ x</code></p>",
        "id": 448148862,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719769808
    },
    {
        "content": "<p>Let me try to actually write <code>AbstractPrimeSieve</code> in terms of these numbers.</p>",
        "id": 448148870,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719769814
    },
    {
        "content": "<p>... that... looks... pretty straightforward... :D</p>",
        "id": 448148915,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719769853
    },
    {
        "content": "<p>Hrm. Okay. I will try this. Thanks, <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> !!</p>",
        "id": 448149204,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719769935
    },
    {
        "content": "<p>It seems like the \"generic PrimeSieve\" ought to be defined as like <code>class PrimeSieve</code> and then I should rename the current thing and show <code>instance : PrimeSieve MyPrimeSieve</code>.</p>",
        "id": 448149976,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719770353
    },
    {
        "content": "<p>That depends, the way you described a prime sieve was more like a concrete prime sieve but for the fact that it deals in noncomputable objects, and you would instead have some representation relation between your prime sieve and the abstract one</p>",
        "id": 448150228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719770469
    },
    {
        "content": "<p>this is basically the same situation as between <code>Set A</code> and <code>Finset A</code>: the former is an abstract mathematical thing and the latter is a concrete computable representation which can be interpreted to a <code>Set</code></p>",
        "id": 448150379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719770530
    },
    {
        "content": "<p>It is possible to describe <code>PrimeSieve</code> as a class but in that case it's still not very abstract, more like parametric over representations</p>",
        "id": 448150530,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719770617
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"423842\">Michal Wallace (tangentstorm)</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20do.20I.20prove.20my.20prime.20sieve.20works.3F/near/448149976\">said</a>:</p>\n<blockquote>\n<p>It seems like the \"generic PrimeSieve\" ought to be defined as like <code>class PrimeSieve</code> and then I should rename the current thing and show <code>instance : PrimeSieve MyPrimeSieve</code>.</p>\n</blockquote>\n<p>Note, in lean, <code>class</code> and <code>instance</code> don't mean what they mean in Python, for example. Instead, <code>class</code> in Python is equivalent to <code>structure</code> in lean. And one creates an instance of a structure by a <code>def foo : MyStruct := ...</code> declaration.</p>\n<p><code>class</code> in lean defined a structure that _additionally_, for the parameters provided, should be found automatically by the typeclass search system, and as such, there should morally be only one <code>instance</code> for every <code>MyStruct X</code>.</p>",
        "id": 448152916,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719771589
    },
    {
        "content": "<p>So... I wanted to define actual sets, but whenever I refer to membership in the sets, I get errors about being unable to synthesize a \"Membership\" instance, and I don't know how to address that. It would have made the code look kind of nice:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">NonWorkingPrimeSieve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NPrime</span>\n<span class=\"w\">  </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"c1\">-- primes &lt; C</span>\n<span class=\"w\">  </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"c1\">-- ^ failed to synthesize  Membership ?m.512 ↑{n | ↑n &lt; ↑(C x)}</span>\n</code></pre></div>",
        "id": 448167171,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719777693
    },
    {
        "content": "<p>So here is what I came up with. So far, it's just a definition, but it typechecks.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- a generic prime sieve</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NPrime</span>\n<span class=\"w\">  </span><span class=\"c1\">-- nltC says a naturals less than C</span>\n<span class=\"w\">  </span><span class=\"n\">nltC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n<span class=\"w\">  </span><span class=\"c1\">-- primes less than C (the \"known primes\")</span>\n<span class=\"w\">  </span><span class=\"n\">pltC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n<span class=\"w\">  </span><span class=\"c1\">-- natural number coprime to all the known primes</span>\n<span class=\"w\">  </span><span class=\"n\">cpks</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pltC</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- this is the invariant we need to have a sieve.</span>\n<span class=\"w\">  </span><span class=\"c1\">-- if I can show that a particular instance produces a C</span>\n<span class=\"w\">  </span><span class=\"c1\">-- that is the smallest natural that is coprime</span>\n<span class=\"w\">  </span><span class=\"c1\">-- to all the known primes, then I should be able to</span>\n<span class=\"w\">  </span><span class=\"c1\">-- prove the main result (hSiv) below.</span>\n<span class=\"w\">  </span><span class=\"n\">hMin</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"n\">cpks</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\">                 </span><span class=\"c1\">-- C is in R</span>\n<span class=\"w\">    </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">cpks</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\">  </span><span class=\"c1\">-- C is min of R</span>\n<span class=\"w\">  </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"c1\">-- the key property to prove:</span>\n<span class=\"w\">  </span><span class=\"c1\">-- we generate the next consecutive prime at each step</span>\n<span class=\"w\">  </span><span class=\"n\">hSiv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">x'</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\">        </span><span class=\"c1\">-- \"after each step\"</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\">  </span><span class=\"c1\">-- \"we have a new, bigger prime\"</span>\n<span class=\"w\">      </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">¬∃</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\">   </span><span class=\"c1\">-- \"and there is no prime between them\"</span>\n<span class=\"w\">        </span><span class=\"o\">((</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">&lt;</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">&lt;</span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">      </span><span class=\"c1\">-- I *think* I can prove this for all sieves,</span>\n<span class=\"w\">      </span><span class=\"c1\">-- provided the sieve gives me the hMin fact</span>\n</code></pre></div>",
        "id": 448168104,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719777967
    },
    {
        "content": "<p>When you write <code>S : (x:α) → { n: NPrime | n.val &lt; (C x).val }</code>, you aren't declaring a set, you are declaring an element of a set. <code>{ n: NPrime | n.val &lt; (C x).val }</code> is one particular set and <code>S</code> is a function producing elements of that set</p>",
        "id": 448168356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719778106
    },
    {
        "content": "<p>I am somewhat worried that the predicates here are like \"default definitions\" and that it's possible to override them with <em>any</em> proposition. I want a keyword like \"final\" in java.</p>",
        "id": 448168378,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719778125
    },
    {
        "content": "<p>as a result, writing <code>p ∈ (S x)</code> later doesn't make sense because <code>S x</code> isn't a set</p>",
        "id": 448168426,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719778149
    },
    {
        "content": "<blockquote>\n<p>I am somewhat worried that the predicates here are like \"default definitions\" and that it's possible to override them with <em>any</em> proposition. I want a keyword like \"final\" in java.</p>\n</blockquote>\n<p>That's correct, this is not what you want. Try defining functions like <code>nltC</code> before the class, taking <code>C</code> as an argument</p>",
        "id": 448168556,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719778214
    },
    {
        "content": "<p>... ah, so the set comprehension is also a type signature. how would I declare a function that returns a set then?</p>",
        "id": 448168624,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719778253
    },
    {
        "content": "<p><code>S : A -&gt; Set NPrime</code> or something</p>",
        "id": 448168975,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719778434
    },
    {
        "content": "<p>and then you can put constraints on the set in later arguments</p>",
        "id": 448169086,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719778483
    },
    {
        "content": "<p>Hrm. Okay, I see how to do it as a separate proposition...</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pltC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">NPrime</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">NPrime</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NPrime</span>\n<span class=\"w\">  </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">NPrime</span>\n<span class=\"w\">  </span><span class=\"n\">hS</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">pltC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span>\n</code></pre></div>\n<p>When you say \"later argument\", are you saying I can define S and hS together in one definition?</p>",
        "id": 448170140,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719778999
    },
    {
        "content": "<p>no, I was saying you can write <code>hS</code></p>",
        "id": 448170231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719779032
    },
    {
        "content": "<p>got it. thanks! this is very helpful!</p>",
        "id": 448170288,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719779047
    },
    {
        "content": "<p>you can bundle some information inside <code>S</code> as well, but you will have to change the uses slightly since it won't be a plain <code>Set NPrime</code> anymore</p>",
        "id": 448170327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719779073
    },
    {
        "content": "<p>for example for that <code>hS</code> example you could also say</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">pltC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>but then any later statements using <code>S x</code> should use <code>(S x).1</code> instead</p>",
        "id": 448170563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719779152
    },
    {
        "content": "<p>or alternatively</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">pltC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>but now it's not a set of <code>NPrime</code> so you will have some proof obligations or so when talking about <code>NPrime</code>s being a member of the set</p>",
        "id": 448170880,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719779222
    },
    {
        "content": "<p>I would usually opt for the version you wrote, with a plain set and then constraints on it, so that usage code isn't mucked up with casting things into the correct subtypes</p>",
        "id": 448171356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719779331
    },
    {
        "content": "<p>It seems like lean will completely ignore a proof in a class definition, presumably until you instantiate that class.<br>\nis there a way to force it to check the proof without an instance of the class?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NPrime</span>\n<span class=\"w\">  </span><span class=\"n\">hMyAssertion</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">234234</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">you_can_say_anything_here</span>\n<span class=\"w\">    </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 448185279,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719787714
    },
    {
        "content": "<p>The syntax <code>:= by</code> in class declarations is sneakily a separate thing, it means to run the provided tactic if the field is omitted</p>",
        "id": 448185317,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719787795
    },
    {
        "content": "<p>if you put the by block in parentheses it will be checked at declaration time instead, as a regular optional value</p>",
        "id": 448185369,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719787813
    },
    {
        "content": "<p>aha! thanks!</p>",
        "id": 448185421,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719787886
    },
    {
        "content": "<p>But I think you don't really want that either, especially for proof fields. If you can prove it outright from earlier fields then there is no point putting it in the structure</p>",
        "id": 448185429,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719787899
    },
    {
        "content": "<p>This particular example of course can't be proved outright, since an arbitrary function <code>C : α → NPrime</code> need not have its values all greater than 234234</p>",
        "id": 448185510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719787957
    },
    {
        "content": "<p>if you think that <code>C</code> will normally be given in some explicitly computable way such that <code>by decide</code> or <code>by omega</code> or something will prove this side goal then you can use <code>:= by decide</code> for that</p>",
        "id": 448185547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719788004
    },
    {
        "content": "<p>Well, again, I'm thinking about this from a software perspective. I think of a <code>class</code> as something like an <code>interface</code> in java or C#, where there might be many sieves lying around. I want to define some hypotheses / contracts that any algorithm has to fufill, and then provide one proof that demonstrates that those conditions are enough to give you a working prime sieve.</p>",
        "id": 448185609,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719788063
    },
    {
        "content": "<p>(I was just making up an assertion that was obviously false for that example)</p>",
        "id": 448185621,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719788091
    },
    {
        "content": "<p>Can this proof be conducted only using the assumptions in the structure?</p>",
        "id": 448185627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719788097
    },
    {
        "content": "<p>if so, the proof should not be in the structure itself</p>",
        "id": 448185640,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719788109
    },
    {
        "content": "<p>the structure is where you put the initial data and assumptions about that data that every implementer must prove</p>",
        "id": 448185660,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719788141
    },
    {
        "content": "<p>here's what i have currently:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ToString</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{s.val}\"</span>\n\n<span class=\"c1\">-- naturals less than C</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nltC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">NPrime</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n<span class=\"c1\">-- primes less than C</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pltC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">NPrime</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">NPrime</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n<span class=\"c1\">-- natural numbers coprime to some known primes:</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">cpks</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ks</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\">  </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">ks</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- a generic prime sieve</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"c1\">-- implement your algorithm in terms of these:</span>\n<span class=\"w\">  </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NPrime</span>\n<span class=\"w\">  </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- this class defines some sets for you to</span>\n<span class=\"w\">  </span><span class=\"c1\">-- refer to when proving that it works:</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- S: the set of \"known primes\", less than C</span>\n<span class=\"w\">  </span><span class=\"n\">S</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pltC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">hS</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pltC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- R is the remainding nats, coprime to all p∈S</span>\n<span class=\"w\">  </span><span class=\"n\">R</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cpks</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">hR</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">cpks</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- these are tne steps you need to prove:</span>\n<span class=\"w\">  </span><span class=\"c1\">-- apostrophe indicates result of the 'next' operation</span>\n<span class=\"w\">  </span><span class=\"n\">hCinR</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\">             </span><span class=\"c1\">-- C is in R</span>\n<span class=\"w\">  </span><span class=\"n\">hCinS</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\">          </span><span class=\"c1\">-- C is in S'</span>\n<span class=\"w\">  </span><span class=\"n\">hRmin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\">  </span><span class=\"c1\">-- C is min of R</span>\n<span class=\"w\">  </span><span class=\"n\">hSmax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\">  </span><span class=\"c1\">-- C is max of S'</span>\n<span class=\"w\">  </span><span class=\"n\">hNewC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"c1\">-- C' &gt; C</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span>\n<span class=\"c1\">-- demonstrate that (hS, hR, hMin, hNew) are enough to prove</span>\n<span class=\"c1\">-- that a sieve generates the next consecutive prime at each step</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hs_suffice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x'</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hnx</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\">  </span><span class=\"c1\">-- \"we have a new, bigger prime\"</span>\n<span class=\"w\">  </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">¬∃</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">NPrime</span><span class=\"o\">,</span><span class=\"w\">   </span><span class=\"c1\">-- \"and there is no prime between them\"</span>\n<span class=\"w\">    </span><span class=\"o\">((</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">&lt;</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">&lt;</span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"c1\">-- \"new bigger prime\" is class invariant</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">hnx</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">hNewC</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">by_contra</span><span class=\"w\"> </span><span class=\"n\">ex_p</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ex_p</span><span class=\"w\"> </span><span class=\"c1\">-- assume p exists.</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">cpks</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hR</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">hCinR</span><span class=\"w\"> </span><span class=\"n\">x'</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">cpks</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">hc'g2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hc'coprime</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">      </span><span class=\"c1\">-- if there's a prime between C and C', then</span>\n<span class=\"w\">      </span><span class=\"c1\">-- C'</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hNewC</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hnx</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 448185666,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719788154
    },
    {
        "content": "<p>I'm thinking that for any sieve implementation, you want to somehow talk about these sets... Otherwise you're tightly coupling the proof to the implementation.</p>",
        "id": 448185760,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719788238
    },
    {
        "content": "<p>but the sets depend on a value in the structure (<code>C</code>, the \"current prime\")</p>",
        "id": 448185788,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719788280
    },
    {
        "content": "<p>This does feel like a clunky way to structure it, though. Maybe a class isn't the right tool for the job?</p>",
        "id": 448185848,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719788343
    },
    {
        "content": "<p>(afk for a couple hours, will be back on this tonight)</p>",
        "id": 448185952,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719788419
    },
    {
        "content": "<p>Here's how I would structure this class, since you have some fields, some definitions and then some more fields:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveBase</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"c1\">-- implement your algorithm in terms of these:</span>\n<span class=\"w\">  </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NPrime</span>\n<span class=\"w\">  </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveBase</span>\n\n<span class=\"sd\">/-- S: the set of \"known primes\", less than C -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PrimeSieveBase</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- R is the remainding nats, coprime to all p∈S -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PrimeSieveBase</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- a generic prime sieve</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveBase</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"c1\">-- these are the steps you need to prove:</span>\n<span class=\"w\">  </span><span class=\"c1\">-- apostrophe indicates result of the 'next' operation</span>\n<span class=\"w\">  </span><span class=\"n\">hCinR</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\">             </span><span class=\"c1\">-- C is in R</span>\n<span class=\"w\">  </span><span class=\"n\">hCinS</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\">          </span><span class=\"c1\">-- C is in S'</span>\n<span class=\"w\">  </span><span class=\"n\">hRmin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\">  </span><span class=\"c1\">-- C is min of R</span>\n<span class=\"w\">  </span><span class=\"n\">hSmax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\">  </span><span class=\"c1\">-- C is max of S'</span>\n<span class=\"w\">  </span><span class=\"n\">hNewC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"c1\">-- C' &gt; C</span>\n</code></pre></div>",
        "id": 448186269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719788739
    },
    {
        "content": "<p>Here's an alternative structuring which eliminates the type alpha entirely and just uses an abstract state:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- S: the set of \"known primes\", less than C -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- R is the remainding nats, coprime to all p∈S -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveOK</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"c1\">-- implement your algorithm in terms of these:</span>\n<span class=\"w\">  </span><span class=\"n\">hCp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\">             </span><span class=\"c1\">-- C is prime</span>\n<span class=\"w\">  </span><span class=\"n\">hCinR</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\">               </span><span class=\"c1\">-- C is in R</span>\n<span class=\"w\">  </span><span class=\"n\">hRmin</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\">      </span><span class=\"c1\">-- C is min of R</span>\n<span class=\"w\">  </span><span class=\"n\">hSmax</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\">  </span><span class=\"c1\">-- C is max of S'</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveNext</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hCinS</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"w\">       </span><span class=\"c1\">-- C is in S'</span>\n<span class=\"w\">  </span><span class=\"n\">hNewC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\">     </span><span class=\"c1\">-- C' &gt; C</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveNext</span><span class=\"bp\">.</span><span class=\"n\">no_prime_between</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveOK</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveNext</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hC</span><span class=\"bp\">.</span><span class=\"n\">hCp</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">¬∃</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">NPrime</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">&lt;</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">&lt;</span><span class=\"n\">C'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveNext</span><span class=\"bp\">.</span><span class=\"n\">next</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveOK</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveNext</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hC</span><span class=\"bp\">.</span><span class=\"n\">hCp</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">PrimeSieveOK</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(I was going to have a structure for the state but in this formulation there is only one number in the state, the current prime value <code>C</code>, so it's overkill.) The idea is that in practice you would prove that your prime sieve relates to some abstract state <code>C</code> satisfying <code>PrimeSieveOK</code>, and <code>next</code> returns a value which is related via <code>PrimeSieveNext</code></p>",
        "id": 448187578,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719789964
    },
    {
        "content": "<p>At this point though <code>PrimeSieveOK</code> is just some predicate on natural numbers which probably has a name already. Indeed:</p>\n<ul>\n<li><code>hCinR</code> is provable outright, because C, being prime, is coprime to all primes less than it</li>\n<li><code>hRmin</code> is false because it contains (non-prime) natural numbers less than C, but if you add <code>n &gt;= C</code> instead of <code>n &gt;= 2</code> to the definition of R then it becomes trivially provable outright</li>\n<li><code>hSmax</code> is trivially true by definition</li>\n</ul>\n<p>So all of the additional assumptions are unnecessary and <code>PrimeSieveOK C</code> is just another name for <code>Nat.Prime C</code> (and similarly <code>PrimeSieveNext</code> has two assumptions which are redundant with each other), suggesting a reformulation as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hCinR</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\">               </span><span class=\"c1\">-- C is in R</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hRmin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\">      </span><span class=\"c1\">-- C is min of R</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hSmax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\">  </span><span class=\"c1\">-- C is max of S'</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveNext</span><span class=\"bp\">.</span><span class=\"n\">next</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>although at this point we're clearly missing some assumption with which to prove <code>C'</code> is prime; most likely you want to say that <code>C'</code> is in <code>R C</code> or something along those lines</p>",
        "id": 448188368,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719790742
    },
    {
        "content": "<p>Oh, wow. Thanks for all this! Lots to process. :)</p>",
        "id": 448200071,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719798610
    },
    {
        "content": "<blockquote>\n<p><code>hRmin</code> is false because it contains (non-prime) natural numbers less than C,</p>\n</blockquote>\n<p>Are you sure? Because if you're right, I'm misunderstanding something about my definition:</p>\n<p><code>def R (C : Nat) : Set Nat := { n | n ≥ 2 ∧ ∀ p ∈ S C, ¬(p.val ∣ n) }</code></p>\n<p>I think this is a \"set comprehension\" that says \"the set of natural numbers that greater than or equal to two, and are co-prime to every (prime) number in S\"... So if C is 11, a non-prime number smaller than C (like 4) can't be in the set, because 4 is divisible by 2, and <code>2 ∈ S C</code>.</p>",
        "id": 448200864,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719799197
    },
    {
        "content": "<p><code>structure PrimeSieveOK (C : Nat) : Prop where ...</code> is warping my mind a little bit. It's a <code>structure</code> that can be applied like a function, and when applied, returns a <code>Prop</code> ?</p>",
        "id": 448201236,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719799292
    },
    {
        "content": "<p><code>PrimeSieveOK C</code> is a predicate, like <code>Nat.Prime C</code>. When your predicate is a big conjunction of things <code>structure</code> is a natural way to define it and give the sub-properties names</p>",
        "id": 448201768,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719799419
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"423842\">Michal Wallace (tangentstorm)</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20do.20I.20prove.20my.20prime.20sieve.20works.3F/near/448200864\">said</a>:</p>\n<blockquote>\n<p>I think this is a \"set comprehension\" that says \"the set of natural numbers that greater than or equal to two, and are co-prime to every (prime) number in S\"... So if C is 11, a non-prime number smaller than C (like 4) can't be in the set, because 4 is divisible by 2, and <code>2 ∈ S C</code>.</p>\n</blockquote>\n<p>You are right, that was my mistake. <code>R</code> will not have any numbers less than C in it</p>",
        "id": 448202108,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719799501
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20do.20I.20prove.20my.20prime.20sieve.20works.3F/near/448201768\">said</a>:</p>\n<blockquote>\n<p><code>PrimeSieveOK C</code> is a predicate, like <code>Nat.Prime C</code>. When your predicate is a big conjunction of things <code>structure</code> is a natural way to define it and give the sub-properties names</p>\n</blockquote>\n<p>Very cool! I guess that's similar to <code>__call__</code> in python, but for some reason I didn't expect to find something like that in a functional language.</p>",
        "id": 448202806,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719799682
    },
    {
        "content": "<p>I'm not sure what you mean: Lean does have an analogue of <code>__call__</code> but this isn't it</p>",
        "id": 448202928,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719799717
    },
    {
        "content": "<p>This is just \"propositions are types\"</p>",
        "id": 448203019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719799743
    },
    {
        "content": "<p><code>structure</code> can be used to make data, and it can also be used to make propositions</p>",
        "id": 448203090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719799766
    },
    {
        "content": "<p>and <code>structure</code> can depend on parameters, which makes parametric data types when applied to data and predicates when used with propositions</p>",
        "id": 448203352,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719799812
    },
    {
        "content": "<p>another aspect of this is the fact that you can have properties next to data fields in a structure, and lean doesn't differentiate between them, they are all just fields in the structure but some are data values and some are proofs</p>",
        "id": 448203637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719799891
    },
    {
        "content": "<blockquote>\n<p><code>hSmax</code> is trivially true by definition<br>\nI couldn't see that before, because that was buried way down in the definition of <code>pltC</code>... Your rewrite makes the available facts much clearer.</p>\n</blockquote>",
        "id": 448204617,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719800211
    },
    {
        "content": "<p>By the way, the analogue of <code>__call__</code> is <code>CoeFun</code>, for example if we wanted your <code>ASeq</code> to act like a function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ASeq</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\">  </span><span class=\"c1\">-- arithmetic sequence (k + dn)</span>\n<span class=\"w\">  </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">  </span><span class=\"c1\">-- constant</span>\n<span class=\"w\">  </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">  </span><span class=\"c1\">-- difference</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"c1\">-- apply formula to n</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ASeq</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeFun</span><span class=\"w\"> </span><span class=\"n\">ASeq</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">ap</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mySeq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ASeq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mySeq</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mySeq</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mySeq</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- (5, 8, 11)</span>\n</code></pre></div>",
        "id": 448204743,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719800284
    },
    {
        "content": "<p>Oh, that's nice. That's definitely going in! </p>\n<p>I see the difference between this and the previous code (namely this has an implementation), but in my mind, I read <code>struct Foo (arg:Nat) : Prop</code> as \"Foo takes a Nat and returns a Prop\"</p>\n<p>It seems like the only reason you can't say <code>structure ASeq (n:Nat) : Nat where...</code> to do what you just did is because <code>structure</code> doesn't have anywhere to put the <code>:= ⟨ap⟩</code>.</p>\n<p>But... You can do that with <code>Prop</code> because prop doesn't require an implementation? </p>\n<p>Or is <code>: Prop</code> somehow special and means \"take the AND-sum of all the proposition fields in this structure\" ?</p>",
        "id": 448205309,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719800681
    },
    {
        "content": "<p>The reason you can't write <code>structure ASeq (n:Nat) : Nat where</code> is because <code>structure</code> declares a type, and the type of a type must be <code>Prop</code> or <code>Type u</code> for some <code>u</code> (these two cases are subsumed by the more general <code>Sort u</code>, where <code>Prop = Sort 0</code> and <code>Type u = Sort (u+1)</code>)</p>",
        "id": 448205562,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719800860
    },
    {
        "content": "<p>That is, you should read <code>Prop</code> as a kind of type universe, similar to <code>Type</code> and unlike <code>Nat</code></p>",
        "id": 448205677,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719800933
    },
    {
        "content": "<p>You can also write <code>structure Foo : Type 37 where</code> if you want, although there aren't many reasons to use such big universes</p>",
        "id": 448205811,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719801017
    },
    {
        "content": "<p>Got it. So it <em>is</em> a bit like an AND of all the facts, but it isn't magic... If you have a value of this type, you must have instances of all those facts attached, or it wouldn't type check.</p>",
        "id": 448205929,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719801086
    },
    {
        "content": "<p>(and if you want the OR of facts, you will want to look into <code>inductive</code>, which <code>structure</code> is actually syntax sugar for, and which also works to make both data and propositions)</p>",
        "id": 448206109,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719801234
    },
    {
        "content": "<p>Okay. I like what you've done here. I think <code>no_prime_between</code> still has to be part of the spec, because otherwise I think <code>next $ StateWhereCis 5</code> might return <code>next $ StateWhereCis 11</code> ... Like it might internally track 7, but you would never be able to observe C=7 because it got skipped over.</p>",
        "id": 448206201,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719801277
    },
    {
        "content": "<p>right, the idea was that this goes into <code>PrimeSieveNext</code>, although it's not clear how you want to state this property in a way that doesn't make it tautological</p>",
        "id": 448206289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719801344
    },
    {
        "content": "<p>but if it's just one or two assumptions you might just not bother with a structure and just have a theorem that says everything you want from the abstraction</p>",
        "id": 448206420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719801430
    },
    {
        "content": "<p>I also think maybe this spec ought to be called something like <code>PrimeGenerator</code> because it isn't <em>necessarily</em> a sieve, and whether it is or not, who cares? (Like, given C, you could just test whether each subsequent number is prime or not, without ever remembering any primes)</p>",
        "id": 448206439,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719801445
    },
    {
        "content": "<p>I did not try very hard at the names :)</p>",
        "id": 448206459,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719801464
    },
    {
        "content": "<p>Oh, I didn't mean you. I'm the one calling it a Sieve the whole time. :)</p>",
        "id": 448206482,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719801482
    },
    {
        "content": "<p>I agree at this level of abstraction it's not very sieve-like</p>",
        "id": 448206495,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719801482
    },
    {
        "content": "<p>the concrete implementation was sieve like but this is just a sequence of primes</p>",
        "id": 448206539,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719801508
    },
    {
        "content": "<p>in fact with my refactoring it's not even really a sequence, it's just a relation between adjacent primes</p>",
        "id": 448206557,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719801540
    },
    {
        "content": "<p>Do I even need sets? I was sort of imagining these prop fields as induction hypotheses... So at each step <code>(S' :=  S ∪ {C})</code> and I just have to say something about removing the multiples of C from R. But maybe I can say this with types?</p>",
        "id": 448207121,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719801960
    },
    {
        "content": "<p>sets are just sugar over predicates, but it can be nice to have the notation of e.g. adding an element like you just wrote</p>",
        "id": 448207241,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719802033
    },
    {
        "content": "<p>I don't know if anyone would be interested in hanging out for this, but I'm live-streaming some work on this today. <a href=\"https://youtube.com/live/MNz6R4g0pOU?feature=share\">https://youtube.com/live/MNz6R4g0pOU?feature=share</a></p>",
        "id": 448381343,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719851475
    },
    {
        "content": "<p>Well, that probably wasn't worth watching since it was just me fumbling around and looking dumb, but here's the main result: a second prime generator that just uses <code>Nat.find</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">simple_gen</span>\n\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">prime_gt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">p</span>\n\n<span class=\"w\">  </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prime_gt</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">prime_gt</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">inferInstanceAs</span>\n\n<span class=\"w\">  </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ex_prime_gt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prime_gt</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">prime_gt</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"c1\">-- because the line below has ≤ and we need &lt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hcp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hprime</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">      </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">exists_infinite_primes</span><span class=\"w\"> </span><span class=\"n\">d</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hprime</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Use Nat.find to get the smallest n that satisfies P</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">next_prime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">ex_prime_gt</span><span class=\"w\"> </span><span class=\"n\">c</span>\n\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">PrimeGt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">prime_gt</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- !! seems like this would do the search twice?</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">next_primegt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeGt</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"bp\">⟨</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ex_prime_gt</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find_spec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ex_prime_gt</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nprime_gt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">PrimeGt</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"bp\">⟨</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">prime_gt</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">property</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">prime_gt</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">next_nprime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">nprime_gt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">next_primegt</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SimpleGen</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPrime</span>\n\n<span class=\"w\">  </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveState</span><span class=\"w\"> </span><span class=\"n\">SimpleGen</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">c</span>\n<span class=\"w\">    </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">prime_two</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">nprime_gt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">next_primegt</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">simple_gen</span>\n</code></pre></div>",
        "id": 448431496,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719865619
    },
    {
        "content": "<p>I broke the code up into separate files, too.. the prime generator spec is now here: <a href=\"https://github.com/tangentstorm/treesiv/blob/main/PrimeGen.lean\">https://github.com/tangentstorm/treesiv/blob/main/PrimeGen.lean</a></p>",
        "id": 448432691,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719865974
    },
    {
        "content": "<p>So. This one is <em>not</em> a sieve, and having it to compare kind of helps me think a little. The core thing I really want to show is that from a given state of the system, I can generate the next prime in sequence.</p>\n<p>For this simple generator, the entire state of the algorithm is contained in C (the current prime). It doesn't remember any other primes that it has found, and it doesn't do any sieving, so there's no need to refer to those sets R and S.</p>\n<p>So... I guess my goal now is to make a <code>PrimeGenOk</code> type that just demands a proof that C' is the next consecutive prime after C, and then prove that this simple generator succeeds here. (Looks like Nat.find_min will make this easy enough.)</p>\n<p>From there, I think I make a general rule about prime sieves using the sets I've been talking about. The argument would be: <em>if</em> you track these three things C (a prime), S (primes less than C) and R (all naturals greater than 1 and coprime to C), and at each step, C' &gt; C, <em>then</em> your prime generator is a sieve.</p>",
        "id": 448435165,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719866846
    }
]