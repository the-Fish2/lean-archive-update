[
    {
        "content": "<p>I'm sorry to ask this question again but I remain confused.</p>\n<p>I do understand the use of <code>by</code> when using tactics, such as <code>:= by ring</code> or <code>:= by norm_num</code>.</p>\n<p>But I don't understand why some examples online do and don't have <code>by</code> at the end of the first line of the proof (the theorem statement - name, variable types, hypothesis, overall proof goal). </p>\n<p>The following proof generates no warnings or errors:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">calc</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n</code></pre></div>\n<p>Removing the <code>by</code> also generates no warnings or errors:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">calc</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n</code></pre></div>\n<p>Perhaps the following questions will help resolve my confusion: </p>\n<ul>\n<li>\n<p>When is it ok not to have <code>by</code> after a <code>:=</code> ?</p>\n</li>\n<li>\n<p>Is it considered good or ok practice to always use <code>by</code> after a <code>:=</code> ?</p>\n</li>\n</ul>",
        "id": 445960015,
        "sender_full_name": "rzeta0",
        "timestamp": 1718920673
    },
    {
        "content": "<p>The thing which never changes is <code>by</code> means \"enter tactic mode\". So the things that work after it are tactics, until/unless you exit tactic mode and enter some other one. Let's take term mode as another mode -- that's the mode you start in without writing <code>by</code>. The confusing thing is that some words exist <em>both</em> as tactics as well as terms. So <code>by calc ...</code> is a tactic called <code>calc</code>. Without <code>by</code>, there is a <em>term</em> <code>calc</code> which has very similar syntax. The same is true of <code>have</code> and some other tactics -- there is both a tactic and a term with quite similar syntax.</p>",
        "id": 445960954,
        "sender_full_name": "Julian Berman",
        "timestamp": 1718921087
    },
    {
        "content": "<p>The style guide (<a href=\"https://leanprover-community.github.io/contribute/style.html#tactic-mode\">https://leanprover-community.github.io/contribute/style.html#tactic-mode</a>) doesn't seem to really opine on how much one should prefer tactic mode, though here on Zulip I know there are a few previous threads I think on the subject, and different people have different preferences on how much they like one or the other. I think starting out it's probably fine to always start with <code>by</code>, you certainly can always remove it if your proof ends up being so short/simple that it makes sense to turn into a term mode proof.</p>",
        "id": 445961208,
        "sender_full_name": "Julian Berman",
        "timestamp": 1718921231
    },
    {
        "content": "<p>Perhaps to contrast, some tactics do <em>not</em> have term-mode equivalents, at least not with the same syntax. <code>rw</code> is an example of this <code>... := rw foo</code> does not work. (However, there actually <em>is</em> term-mode functionality for something like <code>rw</code>, it just has different syntax; it's  called<code>Eq.subst</code> and/or what you get from typing <code>\\t</code>)</p>",
        "id": 445962038,
        "sender_full_name": "Julian Berman",
        "timestamp": 1718921465
    },
    {
        "content": "<p>The <code>calc</code> term is also a tactic so that you don't have to write <code>refine calc ...</code> or <code>exact calc ...</code> to use it.</p>",
        "id": 445970084,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718925273
    },
    {
        "content": "<p>Thanks Julian and Kyle. I think I need to know more about \"term mode\" and \"tactic mode\" before I can finally crack this one. Hopefully it will resolve itself as I work through the tutorial \"Mechanics of Proof\".</p>",
        "id": 445972001,
        "sender_full_name": "rzeta0",
        "timestamp": 1718926551
    },
    {
        "content": "<p>I think <code>rfl</code> is also a very well-known example where there is a term and a tactic with identical name, so <code>:= by rfl</code> uses the tactic while <code>:= rfl</code> and <code>:= by exact rfl</code> use the term. All three ways do apriori slightly different things but in practise you can mostly use any of the three proofs interchangeably.</p>",
        "id": 446015891,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1718952073
    },
    {
        "content": "<p>Thanks Jon. I'm a fan of the principle of \"least surprise\" and \"preferably one way to do it\" in programming language design. I wonder to what extent this is a priority for the lean/mathlib designers?</p>",
        "id": 446019713,
        "sender_full_name": "rzeta0",
        "timestamp": 1718953827
    },
    {
        "content": "<p>Since quite a few of the operations that proof-checking involves are undecidable, there are various heuristics that Lean uses to try to get what it is that you might mean when you say something like <code>rfl</code>.  Depending on whether you say <code>rfl</code>, <code>by exact rfl</code> or <code>by rfl</code> you are skewing slightly these heuristics.</p>\n<p>From this perspective, I would say that the principle of least surprise is that you see <code>rfl</code> in all cases.  The detail of which version of <code>rfl</code> works in your situation is often irrelevant, but sometimes gives you an extra edge.</p>",
        "id": 446022001,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1718954809
    },
    {
        "content": "<p>Indeed, this is completely by design: you are expected to create a proof <em>term</em> which has the correct type, and <code>:= rfl</code> is exactly that. However, in any serious proving it will be way to hard to construct such a term by hand. Therefore we have tactics, which are basically programs that create such a proof term.</p>\n<p>For tactics, the \"one - and preferably only one - obvious way to do it\" mentality doesn't fully apply. Rather you have tons of different tools that might help you in specific cases. For simple problems, you can often choose which tool you use. You could compare that to trying to compute some inverses of matrices or something (e.g. in Python): There might be a general-purpose algorithm, but depending on what you know about your matrix there might be much more efficient and cleaner algorithms to use, so you do want to have a selection of these algorithms available.</p>",
        "id": 446049376,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1718964179
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> <a href=\"#narrow/stream/113489-new-members/topic/correct.20use.20of.20.60by.60/near/445972001\">said</a>:</p>\n<blockquote>\n<p>Thanks Julian and Kyle. I think I need to know more about \"term mode\" and \"tactic mode\" before I can finally crack this one. Hopefully it will resolve itself as I work through the tutorial \"Mechanics of Proof\".</p>\n</blockquote>\n<p>My feeling is that you have the right of it. The more you use them, the more they will start to distinguish themselves and make sense. Many tactics ask for one or more terms and terms may have proofs within them which are best solved with a tactic. I've learn to switch between them as I go.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> <a href=\"#narrow/stream/113489-new-members/topic/correct.20use.20of.20.60by.60/near/446019713\">said</a>:</p>\n<blockquote>\n<p>I'm a fan of the principle of \"least surprise\" and \"preferably one way to do it\" in programming language design. </p>\n</blockquote>\n<p>Part of Lean's design is to have a small, hopefully bug-free core and then language extensions and such built ontop of this. This is a good way to maintain confidence that if a proof type-checks it isn't due to a bug, but it means \"more than one way to do things,\" is going to be common.</p>\n<p>A common idiom in Lean is that collaborators let you get away with omitting parts of your code. For example, if Lean can infer the type of a variable, then it's up to you whether you want to include the type ascription. Sometimes including extra detail makes it easier to read/maintain code and sometimes it's clutter that does the opposite (where that line is seems to be a matter of taste).</p>\n<p>As I understand it, for Lean all builtin syntax is parsed and processed using the same mechanisms and APIs open to users. This means some pretty powerful extensibility capabilities are available. Domain Specific Languages like Do-notation and string interpolation are embedded into Lean using Macros this way. Which, in effect, means you can use these DSLs <strong>or</strong> write out the code these DSLs would expand to yourself - meaning there are suddenly multiple ways to do the same thing. </p>\n<p>The principles of language design you mentioned are (to some extent) sort of lifted to the preferences of the various communities using Lean. I do feel like cohesiveness with the extensions that are adopted is valued by the core/mathlib devs.</p>",
        "id": 446070714,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1718972103
    },
    {
        "content": "<p>This is also being discussed on <a href=\"https://proofassistants.stackexchange.com/q/4029/122\">this PA.SX question</a> (and another question that was marked as a duplicate).  Given that this is also asked here, maybe it is a complicated and difficult to understand topic.  If there is a clearer explanation discover here, feel free to add another answer on PA.SX.</p>",
        "id": 446083253,
        "sender_full_name": "Jason Rute",
        "timestamp": 1718976367
    }
]