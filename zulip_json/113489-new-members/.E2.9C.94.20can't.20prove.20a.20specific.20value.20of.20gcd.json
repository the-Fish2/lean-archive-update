[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Euclidean algorithm -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">gcd</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span>\n    <span class=\"n\">n</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">gcd</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">%</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">m</span>\n\n  <span class=\"c1\">-- Avoid proving that `gcd` terminates as a recursive function</span>\n  <span class=\"n\">termination_by</span> <span class=\"n\">m</span>\n  <span class=\"n\">decreasing_by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- 1</span>\n<span class=\"k\">#eval</span> <span class=\"n\">gcd</span> <span class=\"mi\">42998431</span> <span class=\"mi\">120019</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">type mismatch</span>\n<span class=\"cm\">  Iff.rfl</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  ?m.276 ↔ ?m.276 : Prop</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  gcd 42998431 120019 = 1 : Prop</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">gcd</span> <span class=\"mi\">42998431</span> <span class=\"mi\">120019</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- why does this code raise an error?</span>\n</code></pre></div>",
        "id": 427075376,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1710670308
    },
    {
        "content": "<p>My thought: Because <code>#eval gcd 42998431 120019</code> is equal to 1,  <code>example : gcd 42998431 120019 = 1 := by rfl</code> should pass.</p>\n<p>what was wrong?</p>",
        "id": 427075638,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1710670378
    },
    {
        "content": "<p>This won't work because <code>gcd</code> is defined by \"well-founded recursion\", which blocks reduction, which is what <code>rfl</code> uses</p>",
        "id": 427075912,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710670446
    },
    {
        "content": "<p><code>#eval</code> uses a different algorithm to come up with a value</p>",
        "id": 427075965,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710670463
    },
    {
        "content": "<p>Thank you! How can I make it provable with rfl?</p>",
        "id": 427078667,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1710671218
    },
    {
        "content": "<p>You can add a fuel variable</p>",
        "id": 427078759,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710671239
    },
    {
        "content": "<p>You can prove it with <code>native_decide</code> instead, the statement \"if #eval can do it then so can native_decide\" is much closer to being true than with rfl. Note that by using this proof technique you are trusting the compiler, but in this situation that is relatively trustworthy (imo)</p>",
        "id": 427079530,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1710671442
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> Thank you very much!!!</p>",
        "id": 427080092,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1710671592
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"626349\">Asei Inoue</span> has marked this topic as resolved.</p>",
        "id": 427080125,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710671600
    },
    {
        "content": "<p>BTW you can use the following for the proof</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Euclidean algorithm -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">gcd</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">_h</span> <span class=\"o\">:</span><span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span>\n    <span class=\"n\">n</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">gcd</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">%</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">m</span>\n\n  <span class=\"c1\">-- Avoid proving that `gcd` terminates as a recursive function</span>\n  <span class=\"n\">termination_by</span> <span class=\"n\">m</span>\n  <span class=\"n\">decreasing_by</span>\n    <span class=\"n\">simp_wf</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Nat.mod_lt</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Nat.pos_of_ne_zero</span> <span class=\"n\">_h</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 427080547,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1710671711
    },
    {
        "content": "<p>That happens to be exactly <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.gcd#doc\">docs#Nat.gcd</a></p>",
        "id": 427189213,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710700787
    },
    {
        "content": "<p>I was wondering why the following works</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Nat.gcd</span> <span class=\"mi\">42998431</span> <span class=\"mi\">120019</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>and I guess it's because it's one of the <code>Nat</code> operations that has an accelerator! <a href=\"https://github.com/leanprover/lean4/blob/master/src/kernel/type_checker.cpp#L612\">https://github.com/leanprover/lean4/blob/master/src/kernel/type_checker.cpp#L612</a></p>",
        "id": 427190208,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710701053
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Proving the value without proving termination was what I wanted to do.</p>",
        "id": 427265413,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1710721157
    },
    {
        "content": "<p><code>by simp [gcd]</code> solves the goal by repeatedly applying equation lemmas. I think that's a better proof that <code>native_decide</code> since it doesn't depend on additional axioms</p>",
        "id": 427277647,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1710724381
    },
    {
        "content": "<p>I would avoid using <code>simp [gcd]</code> because it can loop infinitely. You should use <code>singlePass := true</code> if you use <code>simp</code> on a WF definition like this</p>",
        "id": 427277984,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710724471
    },
    {
        "content": "<p>Isn't it guaranteed not to loop infinitely when <code>gcd</code> only appears applied to constants (precisely because the function is guaranteed to terminate)?  Maybe this is only true because of the <code>ite</code> simpproc and in the past the simplifier could keep unfolding the definition in unreachable branches</p>",
        "id": 427278956,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1710724711
    },
    {
        "content": "<p>I don't think so necessarily, simp does not do call by value evaluation order in general</p>",
        "id": 427279404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710724825
    },
    {
        "content": "<p>so it may end up stacking up constants to evaluate instead of actually doing the evaluation</p>",
        "id": 427279568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710724876
    },
    {
        "content": "<p>in the particular case of <code>gcd</code> this presumably doesn't happen if you tried it and it works</p>",
        "id": 427279664,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710724902
    },
    {
        "content": "<p>since if this issue exists it will always occur for a given function</p>",
        "id": 427279773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710724924
    },
    {
        "content": "<p>(plus as Kyle observed this is a kernel-accelerated function so it will also work in one go if you enable <code>decide := true</code>)</p>",
        "id": 427280108,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710725025
    },
    {
        "content": "<p>This sort of handles Mario's concerns:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">gcd</span> <span class=\"mi\">42998431</span> <span class=\"mi\">120019</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">repeat</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">gcd</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">norm_num</span>\n</code></pre></div>\n<p>I guess <code>simp [gcd]</code> works because <code>simp</code> simplifies arithmetic now with some simprocs, and <code>gcd</code> appears just once inside its own definition?</p>",
        "id": 427281011,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710725260
    },
    {
        "content": "<p>If the target expression has no free variables and the simplifier is only ever visiting reachable expressions, then I think simplifying with a recursive definition is guaranteed to terminate, regardless of the order in which simp steps are taken. The recursive definition has to reach a base case after being unfolded finitely many times, and at that point since we're not visiting unreachable expressions we will stop unfolding the definition and promptly terminate.</p>",
        "id": 427286552,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1710726639
    },
    {
        "content": "<p>Here's a recursive definition that diverges:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">gcd</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">0</span> <span class=\"k\">then</span>\n    <span class=\"n\">gcd</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span>\n    <span class=\"n\">n</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">gcd</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">%</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">m</span>\n  <span class=\"n\">termination_by</span> <span class=\"n\">m</span>\n  <span class=\"n\">decreasing_by</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h</span>\n    <span class=\"n\">simp_wf</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Nat.mod_lt</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Nat.pos_of_ne_zero</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">assumption</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>This is assuming that <code>simp</code> defers evaluating <code>m &lt; 0</code> until later.</p>",
        "id": 427287457,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710726863
    },
    {
        "content": "<p>Right but that assumption contradicts my assumption that simp only visits reachable expressions. In this case, I believe my assumption holds: due to the simpproc for <code>if ... then ... else</code>, simp always attempts to decide the condition before visiting the branches</p>",
        "id": 427287996,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1710727013
    },
    {
        "content": "<p>I focused on \"regardless of the order in which simp steps are taken\" (like when analyzing different normalization schemes for lambda calculus) and wasn't sure what a \"reachable expression\" would be. (There's also a notion of which expressions <code>simp</code> is actually able to rewrite. It can't reach every expression, or at least it falls back to <code>dsimp</code> for expressions that can't be reached with congruence lemmas.)</p>",
        "id": 427291948,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710727970
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"500038\">Timo Carlin-Burns</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20can't.20prove.20a.20specific.20value.20of.20gcd/near/427287996\">said</a>:</p>\n<blockquote>\n<p>Right but that assumption contradicts my assumption that simp only visits reachable expressions. In this case, I believe my assumption holds: due to the simpproc for <code>if ... then ... else</code>, simp always attempts to decide the condition before visiting the branches</p>\n</blockquote>\n<p>I don't think that this is true for <code>match</code></p>",
        "id": 427292129,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710728023
    },
    {
        "content": "<p>Looks like you're right, at least for dependent match:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">gcd</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">decide</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"n\">false</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">gcd</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">%</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">m</span>\n  <span class=\"n\">termination_by</span> <span class=\"n\">m</span>\n  <span class=\"n\">decreasing_by</span>\n    <span class=\"n\">simp_wf</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Nat.mod_lt</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Nat.pos_of_ne_zero</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">gcd</span> <span class=\"mi\">6</span> <span class=\"mi\">9</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">gcd</span><span class=\"o\">]</span> <span class=\"c1\">-- maximum recursion depth</span>\n</code></pre></div>",
        "id": 427293876,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1710728454
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"500038\">Timo Carlin-Burns</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20can't.20prove.20a.20specific.20value.20of.20gcd/near/427277647\">said</a>:</p>\n<blockquote>\n<p><code>by simp [gcd]</code> solves the goal by repeatedly applying equation lemmas. I think that's a better proof that <code>native_decide</code> since it doesn't depend on additional axioms</p>\n</blockquote>\n<p>Well \"better\" depends what you are optimising for surely, if you are worried about bugs in the compiler impacting your proofs then sure. But if you want something that's pretty damn fast (won't time out for large numbers) and quite versatile and doesn't produce ridiculously large proof terms then I'd take native decide any day.</p>",
        "id": 427375027,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1710748301
    }
]