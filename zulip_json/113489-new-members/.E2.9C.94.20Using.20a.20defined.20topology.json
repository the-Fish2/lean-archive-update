[
    {
        "content": "<p>How does one define and then use a nonstandard topology on a type?</p>\n<p>I have renamed the function type <code>ℕ → A</code> and I'd like to endow it with the prodiscrete topology, i.e. the product topology with each component <code>A</code> having the discrete topology. I believe I've managed to do this in the mwe below using <code>Pi.topologicalSpace</code>. But I can't seem to actually do much with this topology. For example, I'd like to prove that a neighborhood of a point <code>x</code> contains all points that share a long enough prefix with <code>x</code>, but I don't know what to do with the assumption <code>IsOpen U</code>. I've tried to recursively <code>unfold</code> the definition and <code>simp</code> whenever it becomes too hairy, but that quickly produces things like <code>GaloisCoinsertion.liftCompleteLattice</code> and eventually enters a loop. Perhaps there's a theorem about <code>Pi.topologicalSpace</code> that I could apply, but I didn't find one.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Constructions</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Conf</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">A</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">conf_topo</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"o\">(</span><span class=\"n\">Conf</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">topologicalSpace</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t₂</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">⊥</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">A</span><span class=\"o\">))</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">open_prefix</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Conf</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Conf</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_open</span> <span class=\"o\">:</span> <span class=\"n\">IsOpen</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_mem</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Conf</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">IsOpen</span> <span class=\"n\">TopologicalSpace.IsOpen</span> <span class=\"n\">conf_topo</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">topologicalSpace</span> <span class=\"n\">TopologicalSpace.induced</span> <span class=\"n\">iInf</span> <span class=\"n\">sInf</span> <span class=\"n\">ConditionallyCompleteLattice.toInfSet</span> <span class=\"n\">CompleteLattice.toConditionallyCompleteLattice</span> <span class=\"n\">TopologicalSpace.instCompleteLatticeTopologicalSpace</span> <span class=\"n\">GaloisCoinsertion.liftCompleteLattice</span> <span class=\"n\">at</span> <span class=\"n\">h_open</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h_open</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">OrderDual.toDual</span> <span class=\"n\">Equiv.refl</span> <span class=\"n\">Set.range</span> <span class=\"n\">at</span> <span class=\"n\">h_open</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h_open</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">Set.sUnion</span> <span class=\"n\">sSup</span> <span class=\"n\">Set.instSupSetSet</span> <span class=\"n\">at</span> <span class=\"n\">h_open</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h_open</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">IsOpen</span> <span class=\"n\">TopologicalSpace.IsOpen</span> <span class=\"n\">at</span> <span class=\"n\">h_open</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h_open</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">Bot.bot</span> <span class=\"n\">CompleteLattice.toBot</span> <span class=\"n\">OrderDual.completeLattice</span> <span class=\"n\">at</span> <span class=\"n\">h_open</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h_open</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">TopologicalSpace.generateFrom</span> <span class=\"n\">at</span> <span class=\"n\">h_open</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h_open</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 418230233,
        "sender_full_name": "Ilkka Törmä",
        "timestamp": 1706257421
    },
    {
        "content": "<p>Okay, I just found <code>isOpen_pi_iff</code>, but using <code>rw [isOpen_pi_iff] at h_open</code> gives the error <code>failed to synthesize instance ℕ → TopologicalSpace A</code>.</p>",
        "id": 418231493,
        "sender_full_name": "Ilkka Törmä",
        "timestamp": 1706257953
    },
    {
        "content": "<p>Why not assume that <code>A</code> is discrete? Then you’ll automatically get the topology you want on the function space</p>",
        "id": 418237532,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1706260795
    },
    {
        "content": "<p>Do we have a type synonym that puts discrete topology on a type?</p>",
        "id": 418242285,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706262659
    },
    {
        "content": "<p>I don't think so, but people have been talking about it multiple time and I think we should definitely have.</p>",
        "id": 418243517,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1706263188
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/113489-new-members/topic/Using.20a.20defined.20topology/near/418237532\">said</a>:</p>\n<blockquote>\n<p>Why not assume that <code>A</code> is discrete? Then you’ll automatically get the topology you want on the function space</p>\n</blockquote>\n<p>Hmm yes, with <code>DiscreteTopology A</code>. Thanks, that might be the most reasonable option.</p>",
        "id": 418250936,
        "sender_full_name": "Ilkka Törmä",
        "timestamp": 1706265933
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"678359\">Ilkka Törmä</span> has marked this topic as resolved.</p>",
        "id": 418251068,
        "sender_full_name": "Notification Bot",
        "timestamp": 1706265980
    }
]