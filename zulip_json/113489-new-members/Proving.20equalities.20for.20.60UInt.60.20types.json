[
    {
        "content": "<p>Greetings, everyone!</p>\n<p>Lately, I've been working on a Lean project which makes use of fixed-length unsigned integer types such as <code>UInt32</code>, but I've been having some issues in proving some trivial equalities using these types.</p>\n<p>For example, proving an equality on natural numbers such as the one below is fairly straightforward :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hneq</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≠</span> <span class=\"n\">β</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">α</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≠</span> <span class=\"n\">β</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hneq</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>The same example on UInt32 seems to fail, however:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"n\">UInt32</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hneq</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≠</span> <span class=\"n\">β</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">α</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≠</span> <span class=\"n\">β</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hneq</span><span class=\"o\">]</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unsolved</span> <span class=\"n\">goals</span>\n<span class=\"n\">αβ</span><span class=\"o\">:</span> <span class=\"n\">UInt32</span>\n<span class=\"n\">hneq</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≠</span> <span class=\"n\">β</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">¬</span><span class=\"n\">α</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">β</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span>\n</code></pre></div>\n<p>By tracing which <code>simp</code> rules are applied by using <code>set_option trace.Meta.Tactic.simp true</code>, I observed that unification fails at this step for UInt32 numbers:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.unify</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">add_left_inj</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">unify</span>\n      <span class=\"bp\">?</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">?</span><span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">a</span>\n    <span class=\"k\">with</span>\n      <span class=\"n\">α</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">β</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span>\n</code></pre></div>\n<p>Meanwhile, for natural numbers, it succedes just as expected:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.rewrite</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">add_left_inj</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">β</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">==&gt;</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">β</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>Interestingly enough, if I add theorems for associativity and <code>2 = 1 + 1</code> for UInt32 numbers, along with mentioning which rules <code>simp</code> should use, the example works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">test_two</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">UInt32</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">UInt32</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">UInt32</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ac_rfl</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">test_assoc</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">UInt32</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">c</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ac_rfl</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"n\">UInt32</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hneq</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≠</span> <span class=\"n\">β</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">α</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≠</span> <span class=\"n\">β</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"n\">add_left_inj</span><span class=\"o\">,</span> <span class=\"n\">not_false_eq_true</span><span class=\"o\">,</span> <span class=\"n\">hneq</span><span class=\"o\">,</span> <span class=\"n\">test_two</span><span class=\"o\">,</span> <span class=\"n\">test_assoc</span><span class=\"o\">]</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Tactic</span> <span class=\"n\">state</span>\n<span class=\"n\">No</span> <span class=\"n\">goals</span>\n</code></pre></div>\n<p>However, these kind of theorems are already included in <code>mathlib</code>. Furthermore, <code>UInt32</code> types are defined as <code>Fin 2^32</code>, for which there is already an abelian group instantiation in <code>mathlib</code> and should already cover properties such as associativity.<br>\nWhy do I need to state them explicitly in order to prove trivial equalities like the one I've shown?</p>\n<p>I'm not sure whether I'm not importing the right library files, or even that I may need to use different tactics/proof techniques to prove equalities like this. Any insights would be greatly appreciated! Thank you!</p>",
        "id": 438093602,
        "sender_full_name": "Eduard Vintilă",
        "timestamp": 1715418318
    }
]