[
    {
        "content": "<p>I was able to find most notations using the <a href=\"https://leanprover-community.github.io/mathlib4_docs/search.html?sitesearch=https%3A%2F%2Fleanprover-community.github.io%2Fmathlib4_docs&amp;q=\">docs search</a> but I was unable to find anything on <code>⦃⦄</code> even though I've seen them in some places in the source code. What do they do?</p>",
        "id": 433364633,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1713207669
    },
    {
        "content": "<p>These are part of the core language, \"strict implicits\". Here are some examples: <a href=\"#narrow/stream/113489-new-members/topic/Need.20help.20to.20understand.20strict.20implicit.20vs.20implicit/near/419354924\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Need.20help.20to.20understand.20strict.20implicit.20vs.20implicit/near/419354924</a></p>",
        "id": 433365505,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713207955
    },
    {
        "content": "<p>They're less eager than <code>{}</code> implicit arguments.</p>",
        "id": 433365768,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713208031
    },
    {
        "content": "<p>how far are we from having hovers for strict implicit braces?</p>",
        "id": 433367645,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713208678
    },
    {
        "content": "<p>it appears <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parser.Term.strictImplicitBinder#doc\">docs#Lean.Parser.Term.strictImplicitBinder</a> already has docs</p>",
        "id": 433367826,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713208734
    },
    {
        "content": "<p>I'm not sure why <code>declSig</code> seems to be the end of the line for hovering, at least until it gets into the binder types.</p>",
        "id": 433368965,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713209125
    },
    {
        "content": "<p>this is that issue with builtin docstrings, I'm sure (it's not a <code>@[builtin_term_parser]</code> itself, but something used in one)</p>",
        "id": 433371466,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713209919
    },
    {
        "content": "<p>Hovers would be great. It would also be great if <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parser.Term.strictImplicitBinder#doc\">docs#Lean.Parser.Term.strictImplicitBinder</a> could be found by searching for '⦃'. And lastly that doc string should probably mention the <code>⦃ ... ⦄</code> notation.</p>",
        "id": 433382700,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1713213671
    },
    {
        "content": "<p>Added documentation in <a href=\"https://github.com/leanprover/lean4/pull/3917\">lean4#3917</a> and got the hovers to work</p>",
        "id": 433390185,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713216300
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/3918\">lean4#3918</a> also gets the hovers to work for strict implicits, among other things</p>",
        "id": 433395442,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713218571
    },
    {
        "content": "<p>Now that I understand what they do, why are strict implicits not used more often? </p>\n<p>I can think of two cases on when to use implicits. First, most often, when they can be inferred from subsequent arguments. Second, more rarely, when they can be inferred from the return type. It sounds to me that in the first case strict implicits would be more useful, and regular implicits only for the second case.</p>",
        "id": 433466859,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1713255434
    },
    {
        "content": "<p>I agree. I assume the reason why strict implicts are used fairly sparingly is part historical accident and part laziness (it is easier to type \"{\" than \"\\{{\").</p>",
        "id": 433478207,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1713259238
    },
    {
        "content": "<p>no, I think it is more than that. They were almost dropped from lean 4, we petitioned to add them back</p>",
        "id": 433479395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713259632
    },
    {
        "content": "<p>they are very deliberately being discouraged</p>",
        "id": 433479445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713259649
    },
    {
        "content": "<p>Why?</p>",
        "id": 433485519,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1713261722
    },
    {
        "content": "<p>implicit lambdas mean that lean can often \"just figure it out\" when you use an expression with implicits unapplied</p>",
        "id": 433485685,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713261777
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span> <span class=\"c1\">-- don't know how to synthesize implicit argument @foo ?m.24</span>\n  <span class=\"n\">trivial</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">bar</span> <span class=\"o\">⦃</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">bar</span> <span class=\"c1\">-- OK</span>\n  <span class=\"n\">trivial</span>\n</code></pre></div>\n<p>My experience is that when I use a lemma with (usual) implicits unapplied, then Lean complains, because it tries to fill the implicit arguments, but can't do so, because it is missing the information from the later explicit arguments.</p>",
        "id": 433486965,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1713262195
    },
    {
        "content": "<p>E.g.,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">baz</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"n\">n</span> <span class=\"bp\">≥</span> <span class=\"mi\">37</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">baz</span> <span class=\"c1\">-- complains</span>\n  <span class=\"n\">trivial</span>\n</code></pre></div>\n<p>I don't really see the downside of using strict implicits in cases like this.</p>",
        "id": 433487470,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1713262386
    },
    {
        "content": "<p>Indeed do we have a lot of examples where normal implicits are better than strict implicits?</p>",
        "id": 433488729,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1713262833
    },
    {
        "content": "<p>I thought about this some more and realized that the distinction I made above isn't as clear cut as I first thought.</p>\n<p>By my original argument for a function <code>foo {α β : Type} (x : α) : β</code>, I would have claimed that <code>α</code> can be inferred from a subsequent argument and <code>β</code> from the return type, but the same function signature could also have been written as <code>foo {α β : Type} : α → β</code>, in which case it would appear that both implicit arguments can be referred from the return type.</p>\n<p>To make this more concrete consider the function <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=id#doc\">docs#id</a> , by my original argument it may look like a strict implicit for <code>α</code> might sound reasonable, but then this would result in an error in the following example.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">id'</span> <span class=\"o\">⦃</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">id</span> <span class=\"c1\">-- works</span>\n<span class=\"k\">#eval</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">id'</span> <span class=\"c1\">-- error</span>\n</code></pre></div>\n<p>For <code>id</code>, lean can infer <code>α</code> from the return type, but for <code>id'</code> it is forbidden to do so.</p>",
        "id": 433551261,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1713281670
    },
    {
        "content": "<p>I think strict implicits make sense where a sequence of implicit arguments followed by an explicit argument should all be considered to be \"one\" binder. For example, <code>∀ n ≥ 37, n ≠ 0</code> should be <code>∀ {{n}}, n ≥ 37 → n ≠ 0</code>, since if it expands using <code>{n}</code> it's confusing, leaking an implementation detail of how the <code>n ≥ 37</code> binder works.</p>",
        "id": 433552112,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713281836
    },
    {
        "content": "<p>Though, you do frequently want to pass in <code>n</code> explicitly, leaving the following proof for tactics. I wonder what syntax there could be to pass in a single implicit argument without going into <code>@</code> explicit mode and without using named arguments?</p>",
        "id": 433554530,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713282508
    },
    {
        "content": "<p>Like, if <code>h : ∀ {{n}}, n ≥ 37 → n ≠ 0</code>, maybe you could write <code>h @(5)</code>? Though, right now <code>@(...)</code> is syntax for disabling the implicit lambda feature.</p>",
        "id": 433555170,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713282693
    },
    {
        "content": "<p>Something like <code>h (_ := 5)</code> that would match the first argument?</p>",
        "id": 433556267,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1713283000
    },
    {
        "content": "<p>That might work</p>",
        "id": 433558380,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713283596
    }
]