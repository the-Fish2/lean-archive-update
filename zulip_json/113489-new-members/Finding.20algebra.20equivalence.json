[
    {
        "content": "<p>Hi!</p>\n<p>How would one go about proving that there is an <code>AlgEquiv</code> between a 1-dimensional Division Algebra <code>A</code> over a field <code>F</code> and the field itself?</p>\n<p>I managed to prove that there is a <code>LinearEquiv</code> using <code>nonempty_linearEquiv_of_finrank_eq</code>, but what I really need is a <code>RingEquiv</code> which commutes with scalar multiplication.</p>\n<p>Is there something like that in Mathlib, or do I have to build the map manually?</p>",
        "id": 409223847,
        "sender_full_name": "Francesco Minnocci",
        "timestamp": 1703090885
    },
    {
        "content": "<p>The map is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=algebraMap#doc\">docs#algebraMap</a>, you can prove that it is bijective</p>",
        "id": 409224466,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1703091146
    },
    {
        "content": "<p>Sorry, it's better to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Algebra.ofId#doc\">docs#Algebra.ofId</a></p>",
        "id": 409224826,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1703091287
    },
    {
        "content": "<p>Something like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">FiniteDimensional</span> <span class=\"n\">Function</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">K</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">finrank</span> <span class=\"n\">K</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Bijective</span> <span class=\"o\">(</span><span class=\"n\">Algebra.ofId</span> <span class=\"n\">K</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Nontrivial</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">FiniteDimensional.nontrivial_of_finrank_eq_succ</span> <span class=\"n\">h</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">FiniteDimensional</span> <span class=\"n\">K</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">finiteDimensional_of_finrank_eq_succ</span> <span class=\"n\">h</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">NoZeroSMulDivisors.algebraMap_injective</span> <span class=\"n\">K</span> <span class=\"n\">A</span>\n  <span class=\"bp\">·</span> <span class=\"k\">show</span> <span class=\"n\">Function.Surjective</span> <span class=\"o\">(</span><span class=\"n\">Algebra.ofId</span> <span class=\"n\">K</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toLinearMap</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">LinearMap.injective_iff_surjective_of_finrank_eq_finrank</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">NoZeroSMulDivisors.algebraMap_injective</span> <span class=\"n\">K</span> <span class=\"n\">A</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">AlgEquiv.ofBijective</span> <span class=\"o\">(</span><span class=\"n\">Algebra.ofId</span> <span class=\"n\">K</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 409228729,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1703092241
    },
    {
        "content": "<p>Golfed</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">FiniteDimensional</span> <span class=\"n\">Algebra</span> <span class=\"n\">Subalgebra</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">K</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">finrank</span> <span class=\"n\">K</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Nontrivial</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">FiniteDimensional.nontrivial_of_finrank_eq_succ</span> <span class=\"n\">h</span>\n  <span class=\"n\">AlgEquiv.ofBijective</span> <span class=\"o\">(</span><span class=\"n\">ofId</span> <span class=\"n\">K</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bijective_algebraMap_iff.2</span> <span class=\"o\">(</span><span class=\"n\">bot_eq_top_of_finrank_eq_one</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 409230180,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1703092847
    },
    {
        "content": "<p>Thanks a lot!</p>",
        "id": 409230995,
        "sender_full_name": "Francesco Minnocci",
        "timestamp": 1703093173
    },
    {
        "content": "<p>To find the second version I used loogle, with algebraMap, Function.Bijective</p>",
        "id": 409231504,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1703093354
    },
    {
        "content": "<p>I had actually already tried using <code>bot_eq_top_of_finrank_eq_one</code> but had gotten stuck with it, the <code>algebraMap</code> business was what I missed, although mathematically is the first thing I should've looked for...</p>",
        "id": 409233740,
        "sender_full_name": "Francesco Minnocci",
        "timestamp": 1703094249
    },
    {
        "content": "<p>If I have an hypothesis like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Module.rank</span> <span class=\"n\">ℝ</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"n\">n</span>\n</code></pre></div>\n<p>how can I close the goal</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Module.rank</span> <span class=\"n\">ℝ</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"bp\">↑?</span><span class=\"n\">n</span>\n</code></pre></div>\n<p>It should be easy, but I cannot do it.</p>",
        "id": 409246880,
        "sender_full_name": "Francesco Minnocci",
        "timestamp": 1703100225
    },
    {
        "content": "<p>Is there an mwe?<br>\nI'm guessing <code>obtain ⟨n, hn⟩ := h; exact hn</code> would work, but it is strange that there is a metavariable <code>?n</code> in the goal.</p>",
        "id": 409247519,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1703100486
    },
    {
        "content": "<p>that's because I applied FiniteDimensional.finiteDimensional_of_rank_eq_nat</p>",
        "id": 409247611,
        "sender_full_name": "Francesco Minnocci",
        "timestamp": 1703100531
    },
    {
        "content": "<p>Thanks for the tip, <code>obtain</code> worked.</p>",
        "id": 409248102,
        "sender_full_name": "Francesco Minnocci",
        "timestamp": 1703100765
    },
    {
        "content": "<p>Why is this not closed by <code>linarith</code> or <code>ring</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"n\">hn</span><span class=\"o\">:</span> <span class=\"n\">Module.rank</span> <span class=\"n\">ℝ</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"n\">n</span>\n<span class=\"n\">this</span><span class=\"o\">:</span> <span class=\"n\">finrank</span> <span class=\"n\">ℝ</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n<span class=\"n\">h₁</span><span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span>\n<span class=\"n\">gt₂</span><span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 409249781,
        "sender_full_name": "Francesco Minnocci",
        "timestamp": 1703101567
    },
    {
        "content": "<p><code>ring</code> isn't intended for simultaneous equations, and maybe linarith doesn't know how to use that Nat is locally finite?</p>",
        "id": 409252538,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703102749
    },
    {
        "content": "<p>Here the goal is very easy, but for this kind of stuff you can use the <code>fin_cases</code> tactic. First of all you prove <code>h : n ∈ Finset.range 2</code>, and then you can do <code>fin_cases h</code>.</p>",
        "id": 409255480,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1703104174
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 409256158,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1703104486
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113489-new-members/topic/Finding.20algebra.20equivalence/near/409255480\">said</a>:</p>\n<blockquote>\n<p>Here the goal is very easy, but for this kind of stuff you can use the <code>fin_cases</code> tactic. First of all you prove <code>h : n ∈ Finset.range 2</code>, and then you can do <code>fin_cases h</code>.</p>\n</blockquote>\n<p>That works, but I'm surprised that it's not closed by any of the \"automatic\" tactics I know.</p>",
        "id": 409428781,
        "sender_full_name": "Francesco Minnocci",
        "timestamp": 1703177897
    },
    {
        "content": "<p>I think the issue is that <code>linarith</code> doesn't work with naturals. Maybe <code>omega</code> would, but I don't think mathlib was updated to a version of std that has it yet</p>",
        "id": 409435273,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1703180200
    }
]