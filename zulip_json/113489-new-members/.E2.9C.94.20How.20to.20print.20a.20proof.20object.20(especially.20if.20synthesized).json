[
    {
        "content": "<p>Sorry if this is a FAQ, but I spent some time looking for it, with no luck<br>\n. <br>\nBelow is a simple proof in category theory (from an exercise). The user only provides part of the proof and the rest is synthesized by Lean. I thought it would be instructive to see the proof objects for the parts Lean did by itself, but when I try to use #eval I get the error message below. Is there some other command to print the synthesized proof?:<br>\nexpression<br>\n  iso_of_hom_iso X Y h<br>\nhas type<br>\n  X ‚âÖ Y<br>\nbut instance<br>\n  Lean.MetaEval (X ‚âÖ Y)<br>\nfailed to be synthesized, this instance instructs Lean on how to display the resulting value, recall that any type implementing the <code>Repr</code> class also implements the <code>Lean.MetaEval</code> class</p>\n<p>Here is the whole example:<br>\nimport Mathlib.CategoryTheory.Yoneda</p>\n<p>namespace CategoryTheory </p>\n<p>open Category<br>\nopen Opposite</p>\n<p>variable {C : Type*} [Category C]</p>\n<p>def iso_of_hom_iso (X Y : C) (h : yoneda.obj X ‚âÖ yoneda.obj Y) : X ‚âÖ Y := by<br>\n -- #check (yoneda.obj X).obj (op X) ‚âÖ (yoneda.obj Y).obj (op X) <br>\nexact<br>\n{<br>\n hom := (<a href=\"http://h.app\">h.app</a> (op X)).hom (ùüô X) <br>\n inv := (<a href=\"http://h.symm.app\">h.symm.app</a> (op Y)).hom (ùüô Y),<br>\n}</p>\n<p>variable (X Y : C)<br>\nvariable (h : yoneda.obj X ‚âÖ yoneda.obj Y)</p>\n<p>#eval (iso_of_hom_iso X Y h)</p>",
        "id": 426504509,
        "sender_full_name": "Dan Synek",
        "timestamp": 1710409899
    },
    {
        "content": "<p>Please use <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a></p>",
        "id": 426504679,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1710409952
    },
    {
        "content": "<p>Here: <a href=\"https://lean-lang.org/theorem_proving_in_lean4/interacting_with_lean.html?highlight=%23print#displaying-information\">https://lean-lang.org/theorem_proving_in_lean4/interacting_with_lean.html?highlight=%23print#displaying-information</a></p>",
        "id": 426504790,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710409996
    },
    {
        "content": "<p>Sure <span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span> , will use  <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a> from now. Unfortunately <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> , I had already read that section but could find nothing about printing proof objects. I reread it and could still not find any indication on how to get around the lack of printing of proofs. The only commands mentioned that I could see are #eval, #print and #check and none of them does it. Could you please give a hint on where it is described!?</p>",
        "id": 426506665,
        "sender_full_name": "Dan Synek",
        "timestamp": 1710410648
    },
    {
        "content": "<p>Did you already try <code>#print iso_of_hom_iso</code>?</p>",
        "id": 426507231,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710410843
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"698527\">Dan Synek</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20print.20a.20proof.20object.20.28especially.20if.20synthesized.29/near/426506665\">said</a>:</p>\n<blockquote>\n<p>Sure <span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> , will use  <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a> from now. </p>\n</blockquote>\n<p>Can you use them retroactively too by editing your post above?</p>",
        "id": 426511010,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710412114
    },
    {
        "content": "<p>Thanks for your patience <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  . I did not print  iso_of_hom_iso beause I wanted the instantiated proof and not the definition (that I just entered). Your suggestion gave me the idea to define  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">dummy</span> <span class=\"o\">:=</span>  <span class=\"o\">(</span><span class=\"n\">iso_of_hom_iso</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">dummy</span>\n</code></pre></div>\n<p>but that just printed the definition of dummy and not its  evaluated form . And #eval dummy gives the same error message as before. Also, if I do print iso_of_hom_iso the automatically deduced parts (the proof that the composition is identity) are not printed.  II tried setting pp.explicit to true, but that did not print the proof objects that were automatically deducted.(for example, there shuld be a field hom_inv with the proof that the composition is identity, but it is not present in the gigantic proof term of iso_of_hom_iso. It did however insert all coercions (prety impressive)  As a beginner, maybe I am barking up the wrong tree. For example, is there perhaps instead a debug option so I could see the automatically deducted proof terms when they are being computed? Or some other way?  It is a bit unstatifactory, not to be able to see the full proof.</p>",
        "id": 426525669,
        "sender_full_name": "Dan Synek",
        "timestamp": 1710417443
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  Done!</p>",
        "id": 426525879,
        "sender_full_name": "Dan Synek",
        "timestamp": 1710417531
    },
    {
        "content": "<p>I don't understand what you're getting by instantiating <code>iso_of_hom_iso</code> using arguments with the exact types of the parameters. Wouldn't what you're looking for be what's after <code>fun</code> when you do <code>#print</code>?</p>",
        "id": 426526008,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710417585
    },
    {
        "content": "<p>Or maybe you're somehow wanting to see the proof term that's been reduced somehow?</p>\n<p>That's not computed by Lean. You can keep <code>#print</code>ing definitions that you see in the Infoview</p>",
        "id": 426526228,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710417659
    },
    {
        "content": "<p>Oh, when you say \"not printed\", what do you mean precisely?</p>",
        "id": 426526926,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710417933
    },
    {
        "content": "<p>Are you talking about the <code>...</code>s in the following?</p>\n<p><a href=\"/user_uploads/3121/JHmUTETgCY3o_aKzJyoAE9no/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/JHmUTETgCY3o_aKzJyoAE9no/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/JHmUTETgCY3o_aKzJyoAE9no/image.png\"></a></div>",
        "id": 426527014,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710417964
    },
    {
        "content": "<ol>\n<li>You can hover over them to see the proof term that is being omitted.</li>\n<li>You can <code>set_option pp.proofs true</code> to make them not be omitted.</li>\n</ol>",
        "id": 426527122,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710418009
    },
    {
        "content": "<p>Or, do you mean the <code>iso_of_hom_iso.proof_1</code> terms that appear?</p>\n<p>You can <code>#print</code> those too.</p>",
        "id": 426527253,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710418054
    },
    {
        "content": "<p>As an optimization, to keep the system from repeatedly rechecking that proofs are well-typed, sub-proofs are abstracted away into new definitions. That's these <code>....proof_n</code> terms.</p>",
        "id": 426527392,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710418095
    },
    {
        "content": "<p>(With some metaprogramming, it's possible to write a command that would print the proof term after unfolding such definitions.)</p>",
        "id": 426527626,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710418186
    },
    {
        "content": "<p>As far as I could see pp.explicit prints all coercions that are omitted. But I did not see the proofs that are automatically deducted. To be explicit, a proof object for an isomorphism looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Iso</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- The forward direction of an isomorphism. -/</span>\n  <span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Y</span>\n  <span class=\"sd\">/-- The backwards direction of an isomorphism. -/</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">X</span>\n  <span class=\"sd\">/-- Composition of the two directions of an isomorphism is the identity on the source. -/</span>\n  <span class=\"n\">hom_inv_id</span> <span class=\"o\">:</span> <span class=\"n\">hom</span> <span class=\"bp\">‚â´</span> <span class=\"n\">inv</span> <span class=\"bp\">=</span> <span class=\"mi\">ùüô</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop_cat</span>\n  <span class=\"sd\">/-- Composition of the two directions of an isomorphism in reverse order</span>\n<span class=\"sd\">  is the identity on the target. -/</span>\n  <span class=\"n\">inv_hom_id</span> <span class=\"o\">:</span> <span class=\"n\">inv</span> <span class=\"bp\">‚â´</span> <span class=\"n\">hom</span> <span class=\"bp\">=</span> <span class=\"mi\">ùüô</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop_cat</span>\n</code></pre></div>\n<p>where the field hom_inv_id and inv_hom_id are derived automatically by the tactic aesop_cat (if I understand correctly)<br>\nWhen I print the iso_of_hom_iso these fields are not visible (did string search) even when pp.explicit is true. So how can I see what aesop_cat derived for these two fields of the Iso structure? There must be a way, for example I could imagine that the developer of aesop_cat what would to know it...</p>",
        "id": 426528714,
        "sender_full_name": "Dan Synek",
        "timestamp": 1710418596
    },
    {
        "content": "<p>Just populate the <code>hom_inv_id</code> and <code>inv_hom_id</code> fields manually with <code>by show_term aesop_cat</code>.</p>",
        "id": 426529313,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710418852
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"698527\">@Dan Synek</span> It seems that you missed what I was suggesting? Not <code>pp.explicit</code>, but <code>pp.proofs</code></p>\n<p>Plus, <code>pp.explicit</code> turns off printing the names of structure instances. You won't see <code>hom_inv_id</code> in the proof term if you have that set.</p>",
        "id": 426531458,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710419677
    },
    {
        "content": "<p>Kevin's suggestion of <code>show_term</code> is good too, for inspecting terms from within.</p>",
        "id": 426531563,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710419721
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  and <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> . The pp.proofs option did it.  It is not mentioned at <a href=\"https://lean-lang.org/theorem_proving_in_lean4/interacting_with_lean.html?highlight=%23print#displaying-information\">https://lean-lang.org/theorem_proving_in_lean4/interacting_with_lean.html?highlight=%23print#displaying-information</a> . Perhaps it should be.</p>",
        "id": 426554944,
        "sender_full_name": "Dan Synek",
        "timestamp": 1710426725
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"698527\">Dan Synek</span> has marked this topic as resolved.</p>",
        "id": 426554994,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710426739
    }
]