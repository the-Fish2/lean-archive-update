[
    {
        "content": "<p>Is it possible to prove properties of an existential witness? This is a silly example, but say:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p>Is there a way to express that <code>foo a b → a ≤ c</code> where <code>c</code> is the witness to the truth of <code>foo a b</code>?</p>",
        "id": 423030103,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1708699684
    },
    {
        "content": "<p>By inspecting this proof, you can see that it is possible to use the witness from the antecedent as a witness to the consequent</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span> <span class=\"n\">foo</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"n\">hle</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span><span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"n\">le_iff_exists_add.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">h.symm</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">λ</span><span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hle</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>but of course, you don't need to. You can ignore the antecedent altogether:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span> <span class=\"n\">foo</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span><span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">Nat.le.refl</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 423030932,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1708699980
    },
    {
        "content": "<blockquote>\n<p>Is there a way to express that <code>foo a b → a ≤ c</code> where <code>c</code> is the witness to the truth of <code>foo a b</code>?</p>\n</blockquote>\n<p>sure: <code>foo a b → a ≤ (foo a b).choose</code></p>",
        "id": 423045203,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1708704137
    },
    {
        "content": "<p>That makes sense to me! Though foo is a proposition, not a proof, that's easy to fix</p>",
        "id": 423052888,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1708706289
    },
    {
        "content": "<p>Been trying to prove this, but I'm not sure how to work it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">h.choose</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h₁</span>\n  <span class=\"k\">match</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">h₁</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">x</span> <span class=\"o\">,</span><span class=\"n\">h₃</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₄</span> <span class=\"o\">:</span> <span class=\"n\">h₁.choose</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h₄</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Nat.le_add_right</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n</code></pre></div>",
        "id": 423063016,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1708709576
    },
    {
        "content": "<p>I think what you need is <code>h₁.choose_spec</code> which tells you the property that is satisfied by <code>h₁.choose</code></p>",
        "id": 423064750,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1708710229
    },
    {
        "content": "<p>So, since your equality is the reverse order of the property, you can replace your <code>sorry</code> with <code>h₁.choose_spec.symm</code> to make Lean happy</p>",
        "id": 423065107,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1708710351
    },
    {
        "content": "<p>Yup, that works :)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">h.choose</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h₁</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">h₁.choose</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">h₁.choose_spec.symm</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h₂</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Nat.le_add_right</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>Though, I have a followup question. It feels like <code>intro</code> returns both the value and the property, but it doesn't give me a way to connect it back to the output.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">h.choose</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">heq</span><span class=\"o\">⟩</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Here's it feels like <code>x = h.choose</code> should be true, but I don't really have access to this fact?</p>",
        "id": 423069116,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1708711735
    },
    {
        "content": "<p>Ah, right, nevermind, I do get access to that fact using the match statement. Looks good.</p>",
        "id": 423069584,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1708711918
    },
    {
        "content": "<blockquote>\n<p>Here's it feels like x = h.choose should be true, but I don't really have access to this fact?</p>\n</blockquote>\n<p>In general it's unprovable, you can only prove it here because there is only one possible witness</p>",
        "id": 423070761,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708712419
    },
    {
        "content": "<p>good point... a proof about <code>h.choose</code> is going to be pointless in contexts where you've destructured the existential</p>\n<p>in those contexts, all you need is a lemma of the form <code>∀ {x}, p x → q x</code>... the fact that <code>x</code> is an existential witness is irrelevant</p>",
        "id": 423074445,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1708713942
    },
    {
        "content": "<p>I would expect something like this to work.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">t₁</span> <span class=\"o\">:=</span> <span class=\"n\">foo.choose</span>\n<span class=\"k\">let</span> <span class=\"n\">t₂</span> <span class=\"o\">:=</span> <span class=\"n\">foo.choose</span>\n<span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">t₁</span> <span class=\"bp\">=</span> <span class=\"n\">t₂</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>This isn't how it works, but I have a lingering intuition that when I destructure, I should somehow have access to how that value connects back to the value it was destructured from...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">t₁</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span>\n<span class=\"k\">let</span> <span class=\"n\">t₂</span> <span class=\"o\">:=</span> <span class=\"n\">foo.choose</span>\n<span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">t₁</span> <span class=\"bp\">=</span> <span class=\"n\">t₂</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>but that doesn't work. That or I'm off base on what the destructuring even does here, I think it uses choice underneath as well.</p>",
        "id": 423077194,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1708715065
    },
    {
        "content": "<p>Maybe it helps to realize that <code>(Exists.intro x hx).choose = x</code> is usually unprovable</p>",
        "id": 423078341,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708715540
    },
    {
        "content": "<p>(destructuring has some extra complications that are a distraction here; you need a different syntax to destruct things without forgetting what they are)</p>",
        "id": 423078403,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708715571
    },
    {
        "content": "<p>I think that makes sense. Choice doesn't give me back any particular element (for example, the witness I just used). </p>\n<p>What I'm thinking is generally closer to <code>(Exists.intro x hx).choose = (Exists.intro x hx).choose</code> though sometimes lean doesn't see it that way right away. Esp, when destructuring since that information is lost.</p>\n<p>But this has been a helpful exercise in wrapping my head around what's happening.</p>",
        "id": 423081045,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1708716619
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"664276\">Treq</span> <a href=\"#narrow/stream/113489-new-members/topic/Proving.20properties.20of.20an.20existential.20witness/near/423077194\">said</a>:</p>\n<blockquote>\n<p>This isn't how it works, but I have a lingering intuition that when I destructure, I should somehow have access to how that value connects back to the value it was destructured from...</p>\n</blockquote>\n<p>I wonder if you are looking for something like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">set</span> <span class=\"n\">t₁</span> <span class=\"o\">:=</span> <span class=\"n\">h₁.choose</span> <span class=\"k\">with</span> <span class=\"n\">g₁</span>\n</code></pre></div>\n<p>This adds two hypotheses: <code>t₁ : ℕ := Exists.choose h₁</code> and <code>g₁ : t₁ = Exists.choose h₁</code> Then you can use <code>rw</code> to substitute back and forth with <code>t₁</code> and <code>Exists.choose h₁</code> as necessary.</p>\n<p>In other words, <code>let</code> is great if you just need to define a value of a certain type and it doesn't matter how you got it. <code>set ... with</code> is useful if you need to retain the defining equation of what you are declaring.</p>\n<p>Please feel free to ignore if I have completely missed the mark.</p>",
        "id": 423090294,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1708720477
    }
]