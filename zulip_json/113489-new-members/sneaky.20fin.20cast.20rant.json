[
    {
        "content": "<p>&lt;rant&gt; I can't believe this was allowed to compile.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">garbage</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">10</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"mi\">37</span>\n</code></pre></div>\n<p>After a long while digging I learned that there's an implicit cast of <code>37</code> to <code>Fin 10</code> using <code>Fin.ofNat'</code> which just uses <code>37 % 10</code>. But that is very hidden, and unless you have used <code>Fin.ofNat'</code> deliberately before, that seems easy to miss!</p>\n<p>While this isn't exactly a \"bug\", it seems like the kind of sneaky error that could easily lead to a bad theorem. That is... with a formal theorem prover, of course we should only have to trust the core + the theorem statement. But this kind of sneaky and surprising implicit cast seems like the kind of thing that could easily lead to an incorrect theorem statement.<br>\n&lt;/rant&gt;</p>",
        "id": 413107005,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1705395362
    },
    {
        "content": "<p>It would be possible to have Fin numerals only compile if they were less than the max value. The problem is that we want <code>Fin n</code> to be a ring, and we want rings to have arbitrary numerals</p>",
        "id": 413108542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705395873
    },
    {
        "content": "<p>Not everybody wants <code>Fin n</code> to be a ring! That's the point of <code>ZMod n</code>. Like Alex I think our design decisions here have been very weird. Note that <code>Fin 0</code> isn't a ring, which makes things even more confusing.</p>",
        "id": 413112831,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705397274
    },
    {
        "content": "<p>Now numerals work completely differently we can have the thing that we actually want (3 : Fin 10 working) without having to also allow the thing that far fewer people seem to want (37 : Fin 10 working) and which drove the community to define an addition on Fin n in the first place.</p>",
        "id": 413115691,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705398234
    },
    {
        "content": "<p>Maybe the ring instance is used rarely enough that we can put it behind an <code>open scoped</code>?</p>",
        "id": 413117887,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705398942
    },
    {
        "content": "<p>When using <code>Fin (2 ^ n)</code> (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.BitVec#doc\">docs#Std.BitVec</a>, <code>UInt64</code>, etc) we definitely want it to be a ring, but those files could happily open the scope</p>",
        "id": 413118032,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705398978
    },
    {
        "content": "<p><code>Fin n</code> is used for indices where informal mathematics would have indices from 1 to n, and it's very common in such informal mathematics for out-of-range indices to be considered mod n. I think allowing 37 in <code>Fin 10</code>, and having it at least be an additive group, is entirely consistent with this informal usage (this is nothing like the case of junk values from e.g. division by zero, which is not common in informal usage), even if the full ring structure is less common.</p>",
        "id": 415393338,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1705451938
    }
]