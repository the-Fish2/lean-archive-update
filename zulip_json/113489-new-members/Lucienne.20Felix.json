[
    {
        "content": "<p>I am trying to formalize some theorems from Lucienne Felix's book \"Elementarmathematik<br>\nin moderner Darstellung\". I think what I learned from Set Theory Game and Formaloversum should be enough for this. Somehow Lean doesn't show me my progress. How do you setup a proof like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Have</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.ByContra</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Cases</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.ApplyAt</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lfelix'</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">B</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">∪</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">h</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">inter_def</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 420104739,
        "sender_full_name": "Yagub Aliyev",
        "timestamp": 1707242626
    },
    {
        "content": "<p>It seems to choke on the \\^c, not sure what you need to make that so work</p>",
        "id": 420108020,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1707243827
    },
    {
        "content": "<p>This</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lfelix'</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">B</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">∪</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">h</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">inter_def</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>works (except that <code>inter_def</code> does not exists). I think something is needed to use the notation.</p>",
        "id": 420108981,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1707244156
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.inter_def#doc\">docs#Set.inter_def</a> or <code>open Set</code></p>",
        "id": 420109217,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1707244226
    },
    {
        "content": "<p>Also <code>import Mathlib.Tactic</code> is enough.</p>",
        "id": 420109247,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1707244237
    },
    {
        "content": "<p>but I think the right thing is <code>Set.mem_inter</code> or <code>Set.mem_inter_iff</code></p>",
        "id": 420109291,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1707244258
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/Lucienne.20Felix/near/420109217\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.inter_def#doc\">docs#Set.inter_def</a> or <code>open Set</code></p>\n</blockquote>\n<p>Yes, of course. The strange problem is that with the imports in the first post there is an error about the notation <code>Cᶜ</code>.</p>",
        "id": 420109352,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1707244277
    },
    {
        "content": "<p>I mean that this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Have</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.ByContra</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Cases</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.ApplyAt</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lfelix'</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">B</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">∪</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>gives an error.</p>",
        "id": 420109471,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1707244313
    },
    {
        "content": "<p>Needs <code>Mathlib.Order.Notation</code></p>",
        "id": 420109784,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1707244415
    },
    {
        "content": "<p>Does that import come in via the mentioned tactics?</p>",
        "id": 420109866,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1707244443
    },
    {
        "content": "<p>Those tactics look really basic, such that they wouldn't pull in set definitional API</p>",
        "id": 420109926,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1707244464
    },
    {
        "content": "<p>Ah yes, it needs <code>Mathlib.Data.Set.Defs</code>.</p>",
        "id": 420109960,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1707244475
    },
    {
        "content": "<p>I totally forgot that <code>ᶜ</code>  is not notation for <code>Set.compl</code>, but it is obtained via the class <code>HasCompl</code>.</p>",
        "id": 420110096,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1707244533
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"682831\">@Yagub Aliyev</span> the short answer to your question is: to use the <code>ᶜ</code> just add <code>import Mathlib.Data.Set.Defs</code>.</p>",
        "id": 420110233,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1707244569
    },
    {
        "content": "<p>In general don't try to minimize so much the imports. <code>import Mathlib.Tactic</code> is probably a good trade off.</p>",
        "id": 420110428,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1707244651
    },
    {
        "content": "<p>(I find the choice to use <code>foo_def</code> for what mathlib calls <code>mem_foo</code> in the set theory game odd)</p>",
        "id": 420118470,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1707247320
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"682831\">@Yagub Aliyev</span> The tactics used in the set theory game are all standard tactics, but there are a some theorems defined in the set theory game that you can't use outside of that game.  <code>inter_def</code> is one of them.</p>",
        "id": 420119580,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1707247721
    },
    {
        "content": "<p>Thank you! I completed with your help.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Defs</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lfelix'</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">B</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">∪</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">h</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Set.mem_inter_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n<span class=\"k\">have</span> <span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">h.left</span>\n<span class=\"k\">have</span> <span class=\"n\">hB</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">h.right</span>\n<span class=\"k\">have</span> <span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span><span class=\"bp\">ᶜ</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Set.mem_union</span><span class=\"o\">]</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Set.union_compl_self</span><span class=\"o\">]</span>\n<span class=\"n\">tauto</span>\n<span class=\"n\">cases'</span> <span class=\"n\">h0</span> <span class=\"k\">with</span> <span class=\"n\">h5</span> <span class=\"n\">h6</span>\n<span class=\"n\">left</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Set.mem_inter_iff</span><span class=\"o\">]</span>\n<span class=\"n\">constructor</span>\n<span class=\"n\">exact</span> <span class=\"n\">hA</span>\n<span class=\"n\">exact</span> <span class=\"n\">h5</span>\n<span class=\"n\">right</span>\n<span class=\"n\">constructor</span>\n<span class=\"n\">exact</span> <span class=\"n\">hB</span>\n<span class=\"n\">exact</span> <span class=\"n\">h6</span>\n</code></pre></div>",
        "id": 420122354,
        "sender_full_name": "Yagub Aliyev",
        "timestamp": 1707248756
    },
    {
        "content": "<p>How do you save it or keep for further reference? Will this stay in Zulip forever? How do you include it in mathlib if it is useful?</p>",
        "id": 420122652,
        "sender_full_name": "Yagub Aliyev",
        "timestamp": 1707248856
    },
    {
        "content": "<p>Also I find it interesting that the following works, too</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Defs</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lfelix'</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">B</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">∪</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">h</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Set.mem_inter_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n<span class=\"k\">have</span> <span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">h.left</span>\n<span class=\"k\">have</span> <span class=\"n\">hB</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">h.right</span>\n<span class=\"k\">have</span> <span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span><span class=\"bp\">ᶜ</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Set.mem_union</span><span class=\"o\">]</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Set.union_compl_self</span><span class=\"o\">]</span>\n<span class=\"n\">tauto</span>\n<span class=\"n\">tauto</span>\n</code></pre></div>\n<p>but the following doesn't</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Defs</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lfelix'</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">B</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">∪</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">h</span>\n<span class=\"n\">tauto</span>\n</code></pre></div>\n<p>Something in the middle made <code>tauto</code> work but I don't know what.</p>",
        "id": 420124752,
        "sender_full_name": "Yagub Aliyev",
        "timestamp": 1707249588
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"453098\">Dan Velleman</span> <a href=\"#narrow/stream/113489-new-members/topic/Lucienne.20Felix/near/420119580\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"682831\">Yagub Aliyev</span> The tactics used in the set theory game are all standard tactics, but there are a some theorems defined in the set theory game that you can't use outside of that game.  <code>inter_def</code> is one of them.</p>\n</blockquote>\n<p>Maybe the users of the game should be informed about this from the beginning. Some might prefer not to learn the commands that they can't use outside of the game.</p>",
        "id": 420125473,
        "sender_full_name": "Yagub Aliyev",
        "timestamp": 1707249797
    },
    {
        "content": "<p>I'll think about this.  In some cases there are complications that arise with the standard theorem names that I did't want to have to explain in the set theory game.  (For example, in some standard theorems arguments are implicit, in others they are not.)  I avoided this issue by using my own system of names.  But I can see that there's a disadvantage to that.</p>",
        "id": 420127752,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1707250548
    },
    {
        "content": "<p>Note that most of the theorems in the set theory game are proven <em>in the game</em>, and become available for use once you have proven them.  Those are, of course, not available outside of the game.</p>",
        "id": 420127895,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1707250592
    },
    {
        "content": "<p>Does <code>aesop</code> prove all of them? In mathlib I mean</p>",
        "id": 420128715,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1707250898
    },
    {
        "content": "<p>Do you mean does <code>aesop</code> prove all of the theorems in the set theory game?  Probably many of them, but not all of them.  The game is intended for beginners, so the early theorems are quite easy.  But by the end there are some hard ones.</p>",
        "id": 420130641,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1707251592
    },
    {
        "content": "<p>Sure, I wasn't suggesting to use it in the game!</p>",
        "id": 420139913,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1707255362
    },
    {
        "content": "<p>I found another solution. Does it deserve to be in Mathlib? What are the criteria? :-)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Defs</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lfelix'</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">B</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">∪</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Set.inter_eq_right</span><span class=\"o\">]</span>\n<span class=\"n\">nth_rewrite</span> <span class=\"mi\">1</span> <span class=\"o\">[</span><span class=\"n\">Set.inter_comm</span><span class=\"o\">]</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Set.inter_union_distrib_left</span><span class=\"o\">]</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Set.inter_inter_distrib_left</span><span class=\"o\">]</span>\n<span class=\"n\">nth_rewrite</span> <span class=\"mi\">2</span> <span class=\"o\">[</span><span class=\"n\">Set.inter_inter_distrib_left</span><span class=\"o\">]</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Set.inter_assoc</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Set.inter_left_comm</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Set.inter_assoc</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Set.inter_self</span><span class=\"o\">]</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Set.inter_self</span><span class=\"o\">]</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Set.inter_comm</span><span class=\"o\">]</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Set.inter_comm</span> <span class=\"n\">B</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Set.inter_comm</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">B</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">B</span><span class=\"o\">)]</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Set.inter_union_distrib_left</span><span class=\"o\">]</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Set.inter_union_distrib_left</span><span class=\"o\">]</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Set.union_compl_self</span><span class=\"o\">]</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Set.inter_univ</span><span class=\"o\">]</span>\n<span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Set.inter_self</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 420145847,
        "sender_full_name": "Yagub Aliyev",
        "timestamp": 1707257925
    },
    {
        "content": "<p>I think that mathlib already has all the useful statements needed to do basic set theory; I suspect that something like this would only be added if someone was working on a more advanced result and discovered that this theorem was needed in order to make progress. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">lfelix'</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">B</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">∪</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">x</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">em</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n  <span class=\"n\">aesop</span>\n</code></pre></div>",
        "id": 420156325,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707263910
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Lucienne.20Felix/near/420156325\">said</a>:</p>\n<blockquote>\n<p>I think that mathlib already has all the useful statements needed to do basic set theory; I suspect that something like this would only be added if someone was working on a more advanced result and discovered that this theorem was needed in order to make progress. </p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">lfelix'</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">B</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">∪</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">∩</span> <span class=\"n\">C</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">x</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">em</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n  <span class=\"n\">aesop</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thank you! I wonder how to prove this without aesop</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Defs</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lfelix3</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 420818558,
        "sender_full_name": "Yagub Aliyev",
        "timestamp": 1707586591
    },
    {
        "content": "<p>Just prove it yourself using <code>ext</code>?</p>",
        "id": 420819025,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707586986
    },
    {
        "content": "<p>What does it mean <code>ext?</code>. You also mentioned before <code>exact?</code><br>\nLean doesn't react when you type this. Should Lean suggest some variant when we type it? I use online version of Lean.</p>",
        "id": 420819413,
        "sender_full_name": "Yagub Aliyev",
        "timestamp": 1707587313
    },
    {
        "content": "<p><code>ext</code> is a tactic, just try it as the first line of your proof</p>",
        "id": 420819479,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707587384
    },
    {
        "content": "<p>By the way, <code>ext</code> is introduced in the set theory game, Intersection World, level 8</p>",
        "id": 420834191,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1707600724
    }
]