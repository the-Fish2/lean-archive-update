[
    {
        "content": "<p>Second day writing Lean; so I'm not even sure this is a well formed question. How can I get the universal set of some subtype <code>B</code> of <code>A</code>, but as a <code>Set A</code>?</p>",
        "id": 423344034,
        "sender_full_name": "Eric Zhao",
        "timestamp": 1708935919
    },
    {
        "content": "<p>If you have enough imports, this might work: <code>((Set.univ : Set B) : Set A)</code>. That inserts a coercion function, which is defined to be the image of the set through the function <code>Subtype.val : B -&gt; A</code>.</p>",
        "id": 423344696,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708936187
    },
    {
        "content": "<p>Is this your question?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">up</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 423344994,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1708936308
    },
    {
        "content": "<p>Yes, for example I want something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">Set.univ</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">//</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">4</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Is this supposed to work automatically? It doesn't seem to</p>",
        "id": 423345685,
        "sender_full_name": "Eric Zhao",
        "timestamp": 1708936560
    },
    {
        "content": "<p>The secret is to use a Set coerced to a type rather than a Subtype directly.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">Set.univ</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">4</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 423345935,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708936646
    },
    {
        "content": "<p>These are fundamentally the same, but syntactically different, and this coercion is only defined for this case. It's possible to define one for Subtype if you need it.</p>",
        "id": 423346156,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708936723
    },
    {
        "content": "<p>The coercion is defined at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.instCoeHeadSetElem#doc\">docs#Set.instCoeHeadSetElem</a></p>",
        "id": 423346284,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708936778
    },
    {
        "content": "<p>Oh I see. Though in my case I already have a subtype that I'd like to use. How would I go about defining the coercion for it?</p>",
        "id": 423346502,
        "sender_full_name": "Eric Zhao",
        "timestamp": 1708936849
    },
    {
        "content": "<p>Oh, it seems to go through by invoking <code>Subtype.val '' ...</code>?</p>",
        "id": 423346647,
        "sender_full_name": "Eric Zhao",
        "timestamp": 1708936894
    },
    {
        "content": "<p>To check my understanding: we're projecting out the value for each element of the set (which are of the subtype B) back to the type A</p>",
        "id": 423347019,
        "sender_full_name": "Eric Zhao",
        "timestamp": 1708937018
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Thank you!</p>",
        "id": 423453083,
        "sender_full_name": "Eric Zhao",
        "timestamp": 1708970052
    }
]