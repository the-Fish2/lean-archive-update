[
    {
        "content": "<p>I've got Axler's Linear Algebra done up to (checks notes) page 20... at <a href=\"https://github.com/arienmalec/axler\">https://github.com/arienmalec/axler</a></p>\n<p>I'm up to <code>Sums of Subspaces</code> which are defined as \"the set of all possible sums of elements\" of the respective subspaces. I see definitions for finite sums, and for direct sums, but not for (possibly infinite) sums, as Axler defines.</p>\n<p>An example proof here is that if <code>U  = {&lt;x, 0, 0&gt;}</code> and <code>V = {&lt;0, y, 0&gt;}</code> over <code>R^3</code> then <code>U + V = {&lt;x, y, 0&gt;}</code></p>\n<p>What's the natural translation in Mathlib terms?</p>",
        "id": 423216642,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708821241
    },
    {
        "content": "<p>infinite sums are <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=tsum#doc\">docs#tsum</a>, I think...</p>",
        "id": 423219549,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1708824403
    },
    {
        "content": "<p>Hmm. Has a <code>TopologicalSpace</code> constraint....</p>",
        "id": 423220605,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708825174
    },
    {
        "content": "<p>Is Axler's definition AoC under the hood?</p>",
        "id": 423220652,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708825200
    },
    {
        "content": "<p>The standard notation for this is <code>U ⊔ V</code> or if you <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Module/Submodule/Pointwise.html\"><code>open Pointwise</code></a>, <code>U + V</code>.</p>",
        "id": 423220803,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708825335
    },
    {
        "content": "<p>Googling, is this AKA the Minkowski sum</p>",
        "id": 423220806,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708825341
    },
    {
        "content": "<p>Infinite sums mean something different from pointwise sums of (possibly infinite) sets</p>",
        "id": 423220838,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708825401
    },
    {
        "content": "<p>I'm down to this goal state, which should close easily, but unsure what closes it</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fin.VecNotation</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}:</span> <span class=\"n\">Add.add</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 423296637,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708899883
    },
    {
        "content": "<p>Maybe <code>ext; simp</code>, or with <code>fin_cases</code> in between?</p>",
        "id": 423297276,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1708900477
    },
    {
        "content": "<p>Though it's odd that you have <code>Add.add</code> rather than <code>+</code></p>",
        "id": 423297305,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1708900510
    },
    {
        "content": "<p>The subspace of elements formed from finite sums of an infinite family of subspaces is <code>⨆ i, p i</code></p>",
        "id": 423298631,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708901877
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/113489-new-members/topic/Sums.20of.20subspaces.20.28Axler's.20Linear.20Algebra.20Done.20Right.29/near/423297305\">said</a>:</p>\n<blockquote>\n<p>Though it's odd that you have <code>Add.add</code> rather than <code>+</code></p>\n</blockquote>\n<p>Overaggressive <code>simp</code></p>",
        "id": 423306158,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708909250
    },
    {
        "content": "<p>But <code>simp</code> shouldn't change <code>+</code> to <code>Add.add</code> -- it should be the other way around!</p>",
        "id": 423334506,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708931283
    },
    {
        "content": "<p>I requested <code>simp</code> of <code>HAdd.hAdd, Set.add</code> -- I'm sure there's a better way here...</p>",
        "id": 423433465,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708964732
    },
    {
        "content": "<p>The original setup and current proof state are:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fin.VecNotation</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Pointwise</span>\n<span class=\"kd\">def</span> <span class=\"n\">ex1_37_U</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">3</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">x₁</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x₁</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)}</span>\n<span class=\"kd\">def</span> <span class=\"n\">ex1_37_V</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">3</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">x₂</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">|</span>  <span class=\"o\">(</span><span class=\"n\">x₂</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ex1_37</span><span class=\"o\">:</span> <span class=\"n\">ex1_37_U</span> <span class=\"bp\">+</span> <span class=\"n\">ex1_37_V</span> <span class=\"bp\">=</span> <span class=\"o\">{</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">x₁</span><span class=\"o\">,</span> <span class=\"n\">x₂</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x₁</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x₂</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ex1_37_U</span><span class=\"o\">,</span><span class=\"n\">ex1_37_V</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">HAdd.hAdd</span><span class=\"o\">,</span> <span class=\"n\">Set.add</span><span class=\"o\">,</span> <span class=\"n\">Set.image2</span><span class=\"o\">]</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"bp\">.</span> <span class=\"n\">cases'</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">y</span> <span class=\"n\">h</span>\n    <span class=\"n\">cases'</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">z</span> <span class=\"n\">h</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_setOf_eq</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n    <span class=\"n\">use</span> <span class=\"n\">y</span><span class=\"bp\">;</span> <span class=\"n\">use</span> <span class=\"n\">z</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">symm</span>\n    <span class=\"k\">have</span> <span class=\"n\">h2</span><span class=\"o\">:</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">+</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">ext</span> <span class=\"n\">x</span> <span class=\"bp\">;</span> <span class=\"n\">fin_cases</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h2</span>\n  <span class=\"bp\">.</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n    <span class=\"n\">use</span> <span class=\"n\">y</span><span class=\"bp\">;</span> <span class=\"n\">use</span> <span class=\"n\">z</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">h</span><span class=\"o\">]</span>\n    <span class=\"k\">have</span> <span class=\"n\">h2</span><span class=\"o\">:</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">+</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">ext</span> <span class=\"n\">x</span> <span class=\"bp\">;</span> <span class=\"n\">fin_cases</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h2</span>\n</code></pre></div>",
        "id": 423433800,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708964811
    },
    {
        "content": "<p>You could also do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">ex1_37</span><span class=\"o\">:</span> <span class=\"n\">ex1_37_U</span> <span class=\"bp\">+</span> <span class=\"n\">ex1_37_V</span> <span class=\"bp\">=</span> <span class=\"o\">{</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">x₁</span><span class=\"o\">,</span> <span class=\"n\">x₂</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x₁</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x₂</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_add</span><span class=\"o\">,</span> <span class=\"n\">ex1_37_U</span><span class=\"o\">,</span><span class=\"n\">ex1_37_V</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 423434473,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708964991
    },
    {
        "content": "<p>(and if you used <code>abbrev</code> instead of <code>def</code>s, you would not even need to explicitly unfold <code>ex1_37_U</code> and <code>ex1_37_V</code>.)</p>",
        "id": 423434924,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708965086
    },
    {
        "content": "<p>That's, uh, quite a bit simpler</p>",
        "id": 423436097,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708965344
    },
    {
        "content": "<p>If you look at the statement, it is simply saying that a double existential is the same a two consecutive existentials: this is something that simp should know about and you simply have to tell it what it means to be a member of the sum of two sets.  Hence, <code>simp [Set.mem_add]</code> (+ the unfolding).</p>",
        "id": 423436608,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708965456
    },
    {
        "content": "<p>Also, as an almost universal rule: unfolding <code>Add.add</code> (or similar instances) means you are making your proof harder than it should be.</p>",
        "id": 423437086,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708965582
    },
    {
        "content": "<p>You should trust that whoever defined <code>Add.add</code> also introduced the useful statements about it.  You could be in a situation where there is missing API, but then you should look for the missing API lemma, instead of embedding it into your proof.</p>",
        "id": 423437314,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708965639
    },
    {
        "content": "<p>The trick was using <code>ext</code> prior  -- I tried <code>mem_add</code> previously.</p>",
        "id": 423483079,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708981438
    },
    {
        "content": "<p>Here's where this got to -- weird that <code>add_mem'</code> required a bunch of tactics where the others are <code>simp</code>. Digging around, it seems like some of the core lemmata in <code>Mathlib.Data.Fin.VecNotation</code> were dependent on <code>bit0/1</code> in Mathlib3?</p>",
        "id": 423700063,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709069402
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fin.VecNotation</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Pointwise</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">subspace_ex1_37_U</span><span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">3</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span>  <span class=\"o\">{</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">x₁</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x₁</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)}</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"n\">c</span> <span class=\"n\">y</span> <span class=\"n\">d</span><span class=\"bp\">;</span> <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">d</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">ext</span> <span class=\"n\">z</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">fin_cases</span> <span class=\"n\">z</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">subsdpace_ex1_37_V</span><span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">3</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">x₂</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">|</span>  <span class=\"o\">(</span><span class=\"n\">x₂</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)}</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"n\">c</span> <span class=\"n\">y</span> <span class=\"n\">d</span><span class=\"bp\">;</span> <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">d</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">ext</span> <span class=\"n\">z</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">fin_cases</span> <span class=\"n\">z</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ex1_37</span><span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">x₁</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x₁</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)}</span> <span class=\"bp\">+</span> <span class=\"o\">{</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">x₂</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">|</span>  <span class=\"o\">(</span><span class=\"n\">x₂</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">x₁</span><span class=\"o\">,</span> <span class=\"n\">x₂</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x₁</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x₂</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span> <span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_add</span><span class=\"o\">]</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">Module</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">subspace_ex1_37_U</span> <span class=\"bp\">+</span> <span class=\"n\">subsdpace_ex1_37_V</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 423700151,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709069423
    },
    {
        "content": "<p><code>aesop</code> proves your <code>add_mem'</code> fields.</p>",
        "id": 423700449,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1709069558
    },
    {
        "content": "<p>I'm a bit burnt by <code>hint</code> telling me to try <code>aesop</code> then <code>aesop</code> failing to do anything :-)</p>",
        "id": 423702450,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709070466
    },
    {
        "content": "<p>How do I show that <code>U + V</code> is <code>Submodule ℝ (Fin 3 → ℝ)</code>?</p>",
        "id": 423708346,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709072279
    },
    {
        "content": "<p>Ah <code>#check</code></p>",
        "id": 423709010,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709072461
    },
    {
        "content": "<p>It follows from the definition of \"Submodule\" and the fact it has an <code>Add</code> instance, so it's a bit of a tautology. I think a more \"rigorous\" way would be to show that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">U_plus_V</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"bp\">...</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"n\">pointwise</span> <span class=\"n\">addition</span> <span class=\"n\">of</span> <span class=\"n\">U</span> <span class=\"n\">as</span> <span class=\"n\">a</span> <span class=\"n\">set</span> <span class=\"n\">and</span> <span class=\"n\">V</span> <span class=\"n\">as</span> <span class=\"n\">a</span> <span class=\"n\">set</span>\n  <span class=\"n\">prove</span> <span class=\"n\">the</span> <span class=\"kd\">axioms</span> <span class=\"n\">of</span> <span class=\"n\">a</span> <span class=\"n\">Submodule</span>\n</code></pre></div>\n<p>and then show that <code>U_plus_V = U + V</code> (either as submodules or as sets). I bet the proof will be <code>ext; rfl</code> or <code>rfl</code>.</p>",
        "id": 423711224,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1709073411
    },
    {
        "content": "<p>which is basically the specialization of the proof that <code>(. + .)</code> as defined respects the submodule conditions</p>",
        "id": 423711456,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1709073519
    },
    {
        "content": "<p>Yeah, the instance for <code>AddCommMonoid</code> does the work to show the closure....</p>",
        "id": 423711689,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709073644
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"542196\">Arien Malec</span> <a href=\"#narrow/stream/113489-new-members/topic/Sums.20of.20subspaces.20.28Axler's.20Linear.20Algebra.20Done.20Right.29/near/423702450\">said</a>:</p>\n<blockquote>\n<p>I'm a bit burnt by <code>hint</code> telling me to try <code>aesop</code> then <code>aesop</code> failing to do anything :-)</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"542196\">@Arien Malec</span>, do we have a repro for this? Please ping me and/or Jannis if so.</p>",
        "id": 423737581,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1709089137
    },
    {
        "content": "<p>Next time I see it, I'll #MWE</p>",
        "id": 423744199,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709093593
    },
    {
        "content": "<p>#MWE for <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fin.VecNotation</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Pointwise</span>\n<span class=\"kd\">def</span> <span class=\"n\">ex4_Subspace</span><span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Set.Ioo</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">DifferentiableAt</span> <span class=\"n\">ℝ</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">HasDerivAt</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"mi\">2</span><span class=\"o\">)}</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">.</span> <span class=\"n\">intro</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n      <span class=\"n\">exact</span> <span class=\"n\">differentiableAt_const</span> <span class=\"mi\">0</span>\n    <span class=\"bp\">.</span> <span class=\"n\">apply</span> <span class=\"n\">hasDerivAtFilter_const</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span>\n    <span class=\"c1\">-- intro a b h1 h2</span>\n    <span class=\"c1\">-- constructor</span>\n    <span class=\"c1\">-- . intro x h</span>\n    <span class=\"c1\">--   rcases (h1.left x h) with ⟨ f'x, f_has ⟩</span>\n    <span class=\"c1\">--   rcases (h2.left x h) with ⟨ g'x, g_has ⟩</span>\n    <span class=\"c1\">--   use f'x + g'x</span>\n    <span class=\"c1\">--   exact f_has.add g_has</span>\n    <span class=\"c1\">-- . have h3:= h1.right.add h2.right</span>\n    <span class=\"c1\">--   simp [@Pi.add_def] at *</span>\n    <span class=\"c1\">--   assumption</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">f</span> <span class=\"n\">hf</span>\n    <span class=\"n\">cases'</span> <span class=\"n\">hf</span> <span class=\"k\">with</span> <span class=\"n\">hf1</span> <span class=\"n\">hf2</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">.</span> <span class=\"n\">intro</span> <span class=\"n\">b</span> <span class=\"n\">h</span>\n      <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">hf1</span> <span class=\"n\">b</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">smul_const</span> <span class=\"n\">a</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">smul_def</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n      <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">_</span><span class=\"o\">)]</span>\n      <span class=\"n\">exact</span> <span class=\"n\">h2</span>\n    <span class=\"bp\">.</span> <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">hf2.smul_const</span> <span class=\"n\">a</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">smul_def</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n      <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">_</span><span class=\"o\">)]</span>\n      <span class=\"n\">exact</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 423744696,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709093978
    },
    {
        "content": "<p><code>hint</code> here says to try <code>aesop</code>, but <code>aesop</code> does nothing.</p>",
        "id": 423744833,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709094092
    },
    {
        "content": "<p>Doesn't <code>aesop</code> do intros?</p>",
        "id": 423786038,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709115294
    },
    {
        "content": "<p>Note that <code>hint</code> gives suggestions <em>plus</em> what the goal will be after you try these suggestions, if <code>hint</code> can't close the goal. If <code>hint</code> closes the goal then the suggestion is in green, and if it doesn't then the suggestion is in blue.</p>",
        "id": 423818635,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709127342
    },
    {
        "content": "<p>Here, the <code>aesop</code> goal state is a garble</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"n\">DifferentiableAt</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">_uniq.201000</span> <span class=\"bp\">+</span> <span class=\"n\">_uniq.201001</span><span class=\"o\">)</span> <span class=\"n\">_uniq.233268</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">HasDerivAt</span> <span class=\"o\">(</span><span class=\"n\">_uniq.201000</span> <span class=\"bp\">+</span> <span class=\"n\">_uniq.201001</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"mi\">2</span>\n</code></pre></div>\n<p>It's possible I just need to update Mathlib?</p>",
        "id": 423850797,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709136212
    },
    {
        "content": "<p>Anyway, the lass proof in Axler is <br>\n\"Suppose <code>𝑉_1, ..., 𝑉_𝑚</code> are subspaces of <code>𝑉</code>. Then <code>𝑉_1 + ⋯ + 𝑉_𝑚</code> is the smallest subspace of <code>𝑉</code> containing <code>𝑉_1, ..., 𝑉_𝑚</code>.\"</p>\n<p>When I translate this to Lean and Mathlib the way I understand it (post exposure to Lean and Mathlib, I find myself staring at simple definitions not understanding what they are supposed to mean), I get something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">example</span> <span class=\"n\">axler_1_40</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Submodule</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">)}:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">U.carrier</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">V.carrier</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">W.carrier</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"bp\">+</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">carrier</span> <span class=\"bp\">⊆</span> <span class=\"n\">W.carrier</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But not only doesn't this work, it's so set theoretic that it's certainly not the right way to express the proof statement and proofs in terms of <code>carrier</code>  seem suspect anyway. Is this a one liner in Mathlib? What's the right way to express the proof statement?</p>",
        "id": 423852149,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709136562
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"542196\">Arien Malec</span> <a href=\"#narrow/stream/113489-new-members/topic/Sums.20of.20subspaces.20.28Axler's.20Linear.20Algebra.20Done.20Right.29/near/423850797\">said</a>:</p>\n<blockquote>\n<p>Here, the <code>aesop</code> goal state is a garble</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"n\">DifferentiableAt</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">_uniq.201000</span> <span class=\"bp\">+</span> <span class=\"n\">_uniq.201001</span><span class=\"o\">)</span> <span class=\"n\">_uniq.233268</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">HasDerivAt</span> <span class=\"o\">(</span><span class=\"n\">_uniq.201000</span> <span class=\"bp\">+</span> <span class=\"n\">_uniq.201001</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"mi\">2</span>\n</code></pre></div>\n<p>It's possible I just need to update Mathlib?</p>\n</blockquote>\n<p>Just tried to update Mathlib and same state.</p>",
        "id": 423852603,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709136686
    },
    {
        "content": "<p>Are you getting concerned because of the <code>_uniq.N</code>? I think those are just computer-generated variable names</p>",
        "id": 423857483,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709138015
    },
    {
        "content": "<p>That goal state is not necessarily indicative of a problem</p>",
        "id": 423857523,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709138030
    },
    {
        "content": "<p>It is definitely a bug in aseop, a missing context update.</p>",
        "id": 423857963,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709138161
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"542196\">@Arien Malec</span> you are not getting help about your latest question because you didn’t provide a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>.</p>",
        "id": 423859379,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709138563
    },
    {
        "content": "<p>Otherwise I’d be happy to help.</p>",
        "id": 423859436,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709138580
    },
    {
        "content": "<p>Thanks!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Module.Submodule.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Module.Submodule.Pointwise</span>\n\n\n<span class=\"c\">/-</span>\n\n<span class=\"cm\">Axler, Linear Algebra Done Right, Example 1.40:</span>\n\n<span class=\"cm\">\"Suppose `𝑉_1, ..., 𝑉_𝑚` are subspaces of `𝑉`. Then `𝑉_1 + ⋯ + 𝑉_𝑚` is the smallest subspace of `𝑉`</span>\n<span class=\"cm\">containing `𝑉_1, ..., 𝑉_𝑚`.\"</span>\n\n<span class=\"cm\">We know `V_1 + ... + V_m` is a subspace because the `Submodule.pointwiseAddCommMonoid` instance</span>\n<span class=\"cm\">proves additive closure.</span>\n\n<span class=\"cm\">If we can prove the claim of \"smallest\" for pairs of subspaces `U` and `V` we can prove for arbitrary</span>\n<span class=\"cm\">additve chains by _waves hand_ *induction*</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">open</span> <span class=\"n\">Pointwise</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"n\">W</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Submodule</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">)}:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">S.carrier</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">T.carrier</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">W.carrier</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"bp\">+</span> <span class=\"n\">T</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">carrier</span> <span class=\"bp\">⊆</span> <span class=\"n\">W.carrier</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 423861365,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709139142
    },
    {
        "content": "<p>The supplied translation is absolutely wrong for the reasons I mentioned above. The Axler paper proof is intuitive : \"Conversely, every subspace of 𝑉 containing 𝑉1, ..., 𝑉𝑚 contains 𝑉1 + ⋯ + 𝑉𝑚 (because subspaces must contain all finite sums of their elements). Thus 𝑉1 +⋯+𝑉𝑚 is the smallest subspace of 𝑉 containing 𝑉1, ..., 𝑉𝑚.\"</p>",
        "id": 423861842,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709139310
    },
    {
        "content": "<p>I don't even know the Mathlibism for proof over potentially countably infinite chains of operations. The computer scientist in me is content to think about this as recursion with the base case of a pair.</p>",
        "id": 423862157,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709139416
    },
    {
        "content": "<p>Why do you write all those <code>carrier</code>?</p>",
        "id": 423862412,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709139496
    },
    {
        "content": "<p>And you have several things called V</p>",
        "id": 423862577,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709139554
    },
    {
        "content": "<p>And you try to name an example so Lean is completely confused. Note that your binders choices are completely random but this isn’t a problem for an example since you cannot use it anyway.</p>",
        "id": 423863659,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709139883
    },
    {
        "content": "<p>You got your operator precedence wrong to. Your statement is not what you intended, even after fixing syntax issues.</p>",
        "id": 423864056,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709140015
    },
    {
        "content": "<p>The textual proof claim is that <code>V + U</code> is the smallest subspace containing <code>V</code> and <code>U</code>. When I try to translate what \"containing\" is supposed to mean, I think I want \"if v is in V then v is in W\" or the type theoretic version of that. The <code>carrier</code> stuff is admittedly wrong -- as I wrote above: \"But not only doesn't this work, it's so set theoretic that it's certainly not the right way to express the proof statement and proofs in terms of carrier seem suspect anyway.\"</p>",
        "id": 423866616,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709140925
    },
    {
        "content": "<p>Fixed the syntax issues -- the <code>V</code> confusion hid the fact that <code>example</code> isn't named...</p>",
        "id": 423867031,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709141097
    },
    {
        "content": "<p>Also parenthesized to make operator precedence clearer. But again, I'm not claiming this translation is correct -- the help I'm looking for is \"what is the Mathlib statement that means  \"every subspace of 𝑉 containing 𝑉1, ..., 𝑉𝑚 contains 𝑉1 + ⋯ + 𝑉𝑚 ... thus 𝑉1 +⋯+𝑉𝑚 is the smallest subspace of 𝑉 containing 𝑉1, ..., 𝑉𝑚\"</p>",
        "id": 423867544,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709141282
    },
    {
        "content": "<p>(or the translation of that down to \"every subspace of <code>V</code> containing <code>V_1</code> and <code>V_2</code> contains <code>V_1 + V_2</code> thus....\")</p>",
        "id": 423869464,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709141949
    },
    {
        "content": "<p>The parentheses are still wrong because the implication arrow is right-associative.</p>",
        "id": 423872449,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709143009
    },
    {
        "content": "<p>What you mean is</p>",
        "id": 423872466,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709143018
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">F</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">F</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">U</span> <span class=\"bp\">+</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">W</span>\n</code></pre></div>",
        "id": 423872488,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709143026
    },
    {
        "content": "<p>I don’t understand why aesop can’t do that without hand-holding.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">F</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">U</span> <span class=\"bp\">+</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">W</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span> <span class=\"n\">h</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">all_goals</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n  <span class=\"n\">aesop</span>\n</code></pre></div>",
        "id": 423874239,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709143568
    },
    {
        "content": "<p>Anyway the two lemmas you wanted are <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.add_eq_sup#doc\">docs#Submodule.add_eq_sup</a> and the very generic <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=sup_le_iff#doc\">docs#sup_le_iff</a></p>",
        "id": 423874415,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709143635
    },
    {
        "content": "<p>The first one is getting rid of the pointwise addition stuff that is the very wrong way of thinking about this, and then it becomes a completely generic reasoning.</p>",
        "id": 423874585,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709143690
    },
    {
        "content": "<p><span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span></p>",
        "id": 423882624,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709146487
    },
    {
        "content": "<p>Although I'm confused in general about <code>Sup</code> as a binary operator (rather than as a unary operator on a set), and in specific about how <code>add_eq_sup</code> in this case.... Any pointers to the underlying treatment here would be helpful.</p>",
        "id": 423904202,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709154875
    },
    {
        "content": "<p>Whenever the unary on the set version exists (which is a very strong assumption on an ordered type) then the binary one on elements a and b is the unary one on sets on {a, b}.</p>",
        "id": 423904476,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709154988
    },
    {
        "content": "<p>Maybe you should watch the beginning of <a href=\"https://www.slmath.org/summer-schools/1021/schedules/33442\">https://www.slmath.org/summer-schools/1021/schedules/33442</a> which explains this stuff.</p>",
        "id": 423904738,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709155113
    },
    {
        "content": "<p>I think I mentioned the story of sums of subspaces during that lecture.</p>",
        "id": 423904807,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709155147
    },
    {
        "content": "<p>It also appears a bit in Chapter 8 of <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a> when discussing subgroups.</p>",
        "id": 423905096,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709155273
    },
    {
        "content": "<p>Thank you -- your lecture is incredibly helpful! There's so much embedded in the structure of Mathlib that, particularly in the exercise that I'm trying (formalizing second year linear algebra) I need to jump from the math that's in the text book to the more abstract concepts that Mathlib is built out of...</p>",
        "id": 423907676,
        "sender_full_name": "Arien Malec",
        "timestamp": 1709156345
    }
]