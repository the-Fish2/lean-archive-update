[
    {
        "content": "<p>When using the rw tactic with an inductively-defined function, it seems to introduce a case split that I don't understand at all.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Tree</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">Leaf</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span>\n<span class=\"bp\">|</span> <span class=\"n\">Pair</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"bp\">→</span> <span class=\"n\">Tree</span> <span class=\"bp\">→</span> <span class=\"n\">Tree</span>\n\n<span class=\"c1\">-- This isn't a sensible definition of anything real, it's just for an example</span>\n<span class=\"c1\">-- The key point is that I want a special definition for Pair Leaf _, and a fallback definition for when the first argument of Pair is not a Leaf</span>\n<span class=\"kd\">def</span> <span class=\"n\">Prune</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"bp\">→</span> <span class=\"n\">Tree</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">Leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">Leaf</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">Pair</span> <span class=\"bp\">.</span><span class=\"n\">Leaf</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">Leaf</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">Pair</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">Pair</span> <span class=\"o\">(</span><span class=\"n\">Prune</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span>\n\n<span class=\"c1\">-- This isn't a true theorem, it's just to illustrate the tactic state after using rw</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"n\">Prune</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">Leaf</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Pair</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">ih</span> <span class=\"n\">ih'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Prune</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>What I want to do is treat the two cases Pair Leaf _ and Pair (not leaf) _ separately. The rw tactic has introduced two cases here, but the two subgoals are</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">case</span> <span class=\"n\">Pair</span>\n<span class=\"n\">xy</span><span class=\"o\">:</span> <span class=\"n\">Tree</span>\n<span class=\"n\">ih</span><span class=\"o\">:</span> <span class=\"n\">Prune</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">Tree.Leaf</span>\n<span class=\"n\">ih'</span><span class=\"o\">:</span> <span class=\"n\">Prune</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">Tree.Leaf</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">Tree.Pair</span> <span class=\"o\">(</span><span class=\"n\">Prune</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">Tree.Leaf</span>\n\n<span class=\"n\">case</span> <span class=\"n\">Pair.x_2</span>\n<span class=\"n\">xy</span><span class=\"o\">:</span> <span class=\"n\">Tree</span>\n<span class=\"n\">ih</span><span class=\"o\">:</span> <span class=\"n\">Prune</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">Tree.Leaf</span>\n<span class=\"n\">ih'</span><span class=\"o\">:</span> <span class=\"n\">Prune</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">Tree.Leaf</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">Tree.Leaf</span> <span class=\"bp\">→</span> <span class=\"n\">False</span>\n</code></pre></div>\n<p>which I can't make sense of. What's going on here?</p>",
        "id": 423470229,
        "sender_full_name": "Preeyan Parmar",
        "timestamp": 1708976254
    },
    {
        "content": "<p>I think <code>rw</code> is doing a lot of work behind the scenes to already solve the case when <code>x = Leaf</code>. What you are seeing in the first goal is the result of rewriting <code>Prune</code> when <code>x \\ne Leaf</code>. The second goal is asking you to prove that <code>x \\ne Leaf</code>. </p>\n<p>A more verbose, but also more transparent strategy is to take cases on <code>x</code> before continuing. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"n\">Prune</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">Leaf</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Pair</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">ih</span> <span class=\"n\">ih'</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">cases</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Pair</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 423480478,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1708980350
    },
    {
        "content": "<blockquote>\n<p>The second goal is asking you to prove that x \\ne Leaf</p>\n</blockquote>\n<p>Why does it introduce this goal? It's possible for x to be a Leaf.</p>",
        "id": 423482291,
        "sender_full_name": "Preeyan Parmar",
        "timestamp": 1708981108
    },
    {
        "content": "<p>I should caveat everything below by saying that I don't really know how <code>rw</code> works, so I'm making some educated guesses. If anybody else has a better explanation, I'd love to see it. </p>\n<p>At the place you are trying to perform a <code>rw</code>, Lean only knows that the argument to Prune is <code>Tree.Pair x y</code>. This means that two of your patterns might be viable here. I believe <code>rw</code> tries to work with each of them in turn. The first pattern match replaces <code>x</code> with <code>Leaf</code> and the rewrite easily takes care of that case behind the scenes (i.e. you never see it). Because patterns are matched in order, the third pattern for <code>Prune</code> only applies when <code>x \\ne Leaf</code>. That is, in order to use this case, you have an obligation to prove that <code>x \\ne leaf</code>. But the pattern itself is not strong enough to impose any particular structure on <code>x</code> in this case and <code>rw</code> isn't smart enough to fill in the blanks. </p>\n<p>To see a contrast, you could write your Prune function as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Prune</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"bp\">→</span> <span class=\"n\">Tree</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">Leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">Leaf</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">Pair</span> <span class=\"bp\">.</span><span class=\"n\">Leaf</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">Leaf</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">Pair</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">Pair</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">Pair</span> <span class=\"o\">(</span><span class=\"n\">Prune</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">Pair</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span><span class=\"o\">))</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>If you do that, and keep your proof attempt at Foo unchanged, the stronger pattern now replaces <code>x</code> with <code>Tree.Pair x' y'</code> and Lean is smart enough to figure out that this can't be equal to <code>Leaf</code>. The result is that you only get one goal as expected. However, behind the scenes, it still creates an obligation to prove that <code>x \\ne Leaf</code>, but since the pattern match replaces <code>x</code> with <code>Tree.Pair x' y'</code>, <code>rw</code> <em>is</em> smart enough to discharge that goal on its own.</p>",
        "id": 423491674,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1708984987
    },
    {
        "content": "<p>If this was an intentional feature of <code>rw</code>, I would expect that <code>x ≠ Tree.leaf</code> would be a hypothesis in goal state after rewriting by the third equation (<code>Prune x y</code> to <code>.Pair (Prune x) y</code>), not a new goal.</p>",
        "id": 423495146,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708986533
    },
    {
        "content": "<p>I also don't know exactly how <code>rw</code> works. My best guess for what's happening is that when <code>Prune</code> is defined, a lemma is generated for each of its equations. Then <code>rw [Prune]</code> ends up rewriting by the third equation lemma because that's the only one which is applicable.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">prune_case1</span> <span class=\"o\">:</span> <span class=\"n\">Prune</span> <span class=\"bp\">.</span><span class=\"n\">Leaf</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">Leaf</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">prune_case2</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span><span class=\"o\">):</span> <span class=\"n\">Prune</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">Pair</span> <span class=\"bp\">.</span><span class=\"n\">Leaf</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">Leaf</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">prune_case3</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"bp\">.</span><span class=\"n\">Leaf</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Prune</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">Pair</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">Pair</span> <span class=\"o\">(</span><span class=\"n\">Prune</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"n\">Prune</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">Leaf</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Pair</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">ih</span> <span class=\"n\">ih'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">prune_case3</span><span class=\"o\">]</span> <span class=\"c1\">-- case 3 is the only lemma which is applicable</span>\n</code></pre></div>",
        "id": 423496190,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708987007
    },
    {
        "content": "<p>Here is another example with similar behavior</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">myFun</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">String</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">5</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"five\"</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">myFun</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"n\"</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">myFun</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"s2\">\"foo\"</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">myFun</span><span class=\"o\">]</span> <span class=\"c1\">-- seems to be rewriting by the third equation, even though the first or second could theoretically apply.</span>\n<span class=\"c\">/-</span><span class=\"cm\"> unsolved goals</span>\n\n<span class=\"cm\">  n: Nat</span>\n<span class=\"cm\">  ⊢ \"n\" = \"foo\"</span>\n\n<span class=\"cm\">  n: Nat</span>\n<span class=\"cm\">  ⊢ n = 5 → False</span>\n\n<span class=\"cm\">  n: Nat</span>\n<span class=\"cm\">  ⊢ ∀ (n_1 : Nat), n = Nat.succ (Nat.succ n_1) → False</span>\n\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 423498232,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708987901
    },
    {
        "content": "<p>In fact, you can find out what are the auto-generated lemmas:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Util.WhatsNew</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Tree</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">Leaf</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span>\n<span class=\"bp\">|</span> <span class=\"n\">Pair</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"bp\">→</span> <span class=\"n\">Tree</span> <span class=\"bp\">→</span> <span class=\"n\">Tree</span>\n\n<span class=\"n\">whatsnew</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">Prune</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"bp\">→</span> <span class=\"n\">Tree</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">Leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">Leaf</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">Pair</span> <span class=\"bp\">.</span><span class=\"n\">Leaf</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">Leaf</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">Pair</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">Pair</span> <span class=\"o\">(</span><span class=\"n\">Prune</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span>\n</code></pre></div>",
        "id": 423501269,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708989129
    },
    {
        "content": "<p>I tried that but I don't see any equation lemmas listed in the output of <code>whatsnew</code>...</p>",
        "id": 423508147,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708992952
    },
    {
        "content": "<p>They are not generated immediately but on demand.</p>",
        "id": 423518300,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1708999550
    },
    {
        "content": "<p>So how can I actually prove something about a function that is inductively defined with fallback cases? I like Timo's example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">myFun</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">5</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">myFun</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">myFun</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">5</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">myFun</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">myFun</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">Foo</span> <span class=\"n\">n</span><span class=\"bp\">;</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">myFun</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"gr\">sorry</span><span class=\"bp\">;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The theorem here is actually true, so it ought to have a proof. But I haven't managed to find a proof yet. In my attempt above, the <code>sorry</code>s are goals like <code>n \\neq 3</code> which are true because that case would have already been matched, but I don't know how to fill in the proof.</p>",
        "id": 423596047,
        "sender_full_name": "Preeyan Parmar",
        "timestamp": 1709037177
    },
    {
        "content": "<p>I can fold the proof into the definition like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">myFun</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">//</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">}</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">5</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">rfl</span> <span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">myFun</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">rfl</span> <span class=\"o\">⟩</span>\n</code></pre></div>\n<p>but folding everything you need to know about the function into the definition might be unwieldy in general?</p>",
        "id": 423599239,
        "sender_full_name": "Preeyan Parmar",
        "timestamp": 1709038277
    },
    {
        "content": "<p>In the future (once <a href=\"https://github.com/leanprover/lean4/pull/3432\">https://github.com/leanprover/lean4/pull/3432</a> reaches you) you'll get a custom induction principle for your (recursive) function that takes care of this.</p>\n<p>Until then , does <code>unfold</code> followed by <code>split</code> help?</p>",
        "id": 423664395,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1709056052
    },
    {
        "content": "<p><code>unfold</code> then <code>split</code> does work for this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Foo</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">myFun</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">myFun</span><span class=\"bp\">;</span> <span class=\"n\">split</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">Foo</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 423680220,
        "sender_full_name": "Preeyan Parmar",
        "timestamp": 1709061851
    }
]