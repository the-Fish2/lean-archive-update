[
    {
        "content": "<p>Is there a tactic that simplifies a goal of the form </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">if</span> <span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>to P(x).<br>\nP(x) is a rather complicated expression. I think I could do it with have :P(x):=by ...  and then use simp[this]. But it would be simpler if there was a tactic that simplifies the if away.</p>",
        "id": 416219978,
        "sender_full_name": "Henrik Rueping",
        "timestamp": 1705522614
    },
    {
        "content": "<p>You could try using the <code>split</code> tactic. It's not exactly what you suggest, but it might help you avoid writing <code>P(x)</code>.</p>",
        "id": 416329864,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705522877
    },
    {
        "content": "<p>Or you could prove that if <code>a \\ne b</code> and if <code>if P then a else b = a</code> then <code>P</code> separately (for an abstract <code>P</code>) as a preliminary lemma (with <code>split</code>), and then just apply that.</p>",
        "id": 416331899,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705523765
    },
    {
        "content": "<p>(right now what you posted simplifies to \\not P by the way) (and the backticks you want are <code> ``` </code> not <code> ´´´ </code>)</p>",
        "id": 416331984,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705523805
    },
    {
        "content": "<p>With a usual simp? Hm strange. I did not write out what P is, because I hoped that this would not have an effect, it is just a rather complicated expression.</p>",
        "id": 416332246,
        "sender_full_name": "Henrik Rueping",
        "timestamp": 1705523922
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">P</span> <span class=\"k\">then</span> <span class=\"n\">a</span> <span class=\"k\">else</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">revert</span> <span class=\"n\">h2</span>\n  <span class=\"n\">split</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">aesop</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">verylongproposition</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">verylongproposition</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">verylongproposition</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">verylongproposition</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- note that the proof never mentions `verylongproposition`</span>\n  <span class=\"n\">apply</span> <span class=\"n\">foo</span> <span class=\"n\">_</span> <span class=\"n\">h</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 416332867,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705524196
    },
    {
        "content": "<p>I'm surprised a lemma like <code>(c : Prop) [d : Decidable c] {α : Sort u} {t e : α} (h : e ≠ t) : @ite c d t e = t ↔ c</code>  doesn't already exist, though.</p>",
        "id": 416333120,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1705524333
    },
    {
        "content": "<p>I think I saw something similar recently, but where...</p>",
        "id": 416334623,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1705525031
    },
    {
        "content": "<p>Can't find it, though. This is an alternative proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">P</span> <span class=\"k\">then</span> <span class=\"n\">a</span> <span class=\"k\">else</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ite_eq_left_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h2</span>\n  <span class=\"n\">exact</span> <span class=\"n\">of_not_not</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">mt</span> <span class=\"n\">h2</span> <span class=\"n\">h.symm</span>\n</code></pre></div>",
        "id": 416335767,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1705525502
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ne.ite_eq_left_iff#doc\">docs#Ne.ite_eq_left_iff</a></p>",
        "id": 416513380,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705563730
    }
]