[
    {
        "content": "<p>greetings, consider the following code snippet</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">allways_some_fun</span> <span class=\"o\">(</span><span class=\"n\">some_proof</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">o</span><span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"n\">o.isSome</span><span class=\"o\">):</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">o1</span><span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"mi\">3</span>\n  <span class=\"k\">let</span> <span class=\"n\">some_calc1</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">o1.get</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">some_proof</span><span class=\"o\">]))</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span>   <span class=\"c1\">-- normal syntax</span>\n  <span class=\"k\">let</span> <span class=\"n\">some_calc2</span><span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">o1</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span>                  <span class=\"c1\">-- desired syntax</span>\n  <span class=\"o\">()</span>\n</code></pre></div>\n<p>a function from within a certain wrapping type is allways guaranteed to be present.<br>\nWhenever i use any Option Values inside this function i have to type out \".get\" + the proof of \".isSome\". in my use case that happens allot, and id rather write \"o1\" directly as the wrapped value since the intent would be clear. If anyone has a idea how that could be implemented id appreciate some pointers :)</p>",
        "id": 423200411,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1708805397
    },
    {
        "content": "<p>I feel like this might be an <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> problem... could you say a bit more about the context? what's returning <code>Option</code> values and how do you know they're <code>.some</code>?</p>",
        "id": 423206237,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1708811258
    },
    {
        "content": "<p>Do you need it to be proved within your definition? If not, you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Option.get%21#doc\">docs#Option.get!</a> and defer proving that was valid for your theorems.</p>\n<p>If you do want Lean to prove it's not none, you could copy how GetElem works to try to automatically discharge the proof that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Option.get#doc\">docs#Option.get</a> wants. You could set up notation like <code>o1[] + 3</code>.</p>",
        "id": 423206478,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1708811505
    },
    {
        "content": "<p>my actual use case are distributed computations where distributed Values exist</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">DistVal</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">loc</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">Wrap</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">DistVal</span> <span class=\"n\">α</span> <span class=\"n\">loc</span>\n<span class=\"bp\">|</span> <span class=\"n\">Empty</span><span class=\"o\">:</span> <span class=\"n\">DistVal</span> <span class=\"n\">α</span> <span class=\"n\">loc</span>\n</code></pre></div>\n<p>loc is a name for a computing node, DistVal.Empty means the Value is not present at loc.<br>\ni now want to write local computations:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- takes a function as an argument that maps DistVal to actual values by proving ther existance at l</span>\n<span class=\"kd\">def</span> <span class=\"n\">local_comp_type</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span><span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">({</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">DistVal</span> <span class=\"n\">x</span>  <span class=\"n\">l</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">IO</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">local_comp</span><span class=\"o\">:</span> <span class=\"n\">local_comp_type</span> <span class=\"s2\">\"alice\"</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">unpack</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"c1\">-- here i can use Dist_Vals using unpack</span>\n</code></pre></div>\n<p>what bothers me is that now my local computations always have to specify a name (unpack) for the unpacking function and i have to apply this function to every DistVal x \"alice\" before using it</p>",
        "id": 423207762,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1708812621
    },
    {
        "content": "<p>inside a local computation it would be nice if there is an implicit \"unpack\" function, and every value of type (v: DistVal x \"alice\") gets replaced by (unpack v) implicitly</p>",
        "id": 423207937,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1708812783
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/custom.20syntax/near/423206478\">said</a>:</p>\n<blockquote>\n<p>Do you need it to be proved within your definition? If not, you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Option.get%21#doc\">docs#Option.get!</a> and defer proving that was valid for your theorems.</p>\n<p>If you do want Lean to prove it's not none, you could copy how GetElem works to try to automatically discharge the proof that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Option.get#doc\">docs#Option.get</a> wants. You could set up notation like <code>o1[] + 3</code>.</p>\n</blockquote>\n<p>what im trying to avoid is writing out Option.get! out explicetely, since implicitly i want to call this function on every Optional / DistVal object</p>",
        "id": 423208246,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1708813051
    },
    {
        "content": "<p>so you're saying you want <code>local_comp</code> to be a function with no arguments (or a unit argument, I guess) that automatically coerces <code>DistVal</code> objects to values?</p>",
        "id": 423208855,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1708813605
    },
    {
        "content": "<p>inside the body of a  local_comp_type  function id like to treat DistVal objects like values to make it look syntactically like normal code. <br>\nSo in this case yes, but local_comp may depend on (DistVal x \"alice) arguments to use for computation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">local_comp</span> <span class=\"o\">(</span><span class=\"n\">dv</span><span class=\"o\">:</span> <span class=\"n\">DistVal</span> <span class=\"n\">Nat</span> <span class=\"s2\">\"alice\"</span><span class=\"o\">):</span> <span class=\"n\">local_comp_type</span> <span class=\"s2\">\"alice\"</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">unpack</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">unpack</span> <span class=\"n\">dv</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 423209604,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1708814329
    },
    {
        "content": "<p>right, so what would the code you posted look like in your ideal world? something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">local_comp</span> <span class=\"o\">(</span><span class=\"n\">dv</span><span class=\"o\">:</span> <span class=\"n\">DistVal</span> <span class=\"n\">Nat</span> <span class=\"s2\">\"alice\"</span><span class=\"o\">):</span> <span class=\"n\">local_comp_type</span> <span class=\"s2\">\"alice\"</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">return</span> <span class=\"n\">dv</span>\n</code></pre></div>",
        "id": 423209696,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1708814410
    },
    {
        "content": "<p>or maybe</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">local_comp</span> <span class=\"o\">(</span><span class=\"n\">dv</span><span class=\"o\">:</span> <span class=\"n\">DistVal</span> <span class=\"n\">Nat</span> <span class=\"s2\">\"alice\"</span><span class=\"o\">):</span> <span class=\"n\">local_comp_type</span> <span class=\"s2\">\"alice\"</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">return</span> <span class=\"n\">dv</span>\n</code></pre></div>",
        "id": 423209829,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1708814551
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/stream/113489-new-members/topic/custom.20syntax/near/423209829\">said</a>:</p>\n<blockquote>\n<p>or maybe</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">local_comp</span> <span class=\"o\">(</span><span class=\"n\">dv</span><span class=\"o\">:</span> <span class=\"n\">DistVal</span> <span class=\"n\">Nat</span> <span class=\"s2\">\"alice\"</span><span class=\"o\">):</span> <span class=\"n\">local_comp_type</span> <span class=\"s2\">\"alice\"</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">return</span> <span class=\"n\">dv</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>yea the second option would be ideal, something that<br>\n1 introduces a new anonymous function of type ({x:Type} -&gt; DistVal x  l -&gt; x)<br>\n2 apllies it to all occurrences of a DistVal (or DistVal x \"alice\")<br>\nwithout having write it out explicitly</p>",
        "id": 423210137,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1708814869
    },
    {
        "content": "<p>How about this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">local_comp_type</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span><span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">DistVal</span> <span class=\"n\">α</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">IO</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">local_comp</span> <span class=\"o\">(</span><span class=\"n\">dv</span><span class=\"o\">:</span> <span class=\"n\">DistVal</span> <span class=\"n\">Nat</span> <span class=\"s2\">\"alice\"</span><span class=\"o\">):</span> <span class=\"n\">local_comp_type</span> <span class=\"s2\">\"alice\"</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">return</span> <span class=\"n\">dv</span>\n</code></pre></div>",
        "id": 423210476,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708815200
    },
    {
        "content": "<p>yea that seems pretty cool, i didnt know about Coe!<br>\nhow would i then supply the instance of the typeclass?<br>\nat some point i have the proof that all DistVals are not empty at a location exist</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">DistVal.notEmpty</span><span class=\"o\">:</span> <span class=\"n\">DistVal</span> <span class=\"n\">a</span> <span class=\"n\">loc</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">Wrap</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"n\">Empty</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">all_alice_exist</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dv</span><span class=\"o\">:</span> <span class=\"n\">DistVal</span> <span class=\"n\">x</span> <span class=\"s2\">\"alice\"</span><span class=\"o\">),</span> <span class=\"n\">dv.notEmpty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">):</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">DistVal</span> <span class=\"n\">α</span> <span class=\"s2\">\"alice\"</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"n\">dv</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">dv</span><span class=\"o\">,</span> <span class=\"n\">all_alice_exist</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">DistVal.Wrap</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">v</span>\n  <span class=\"bp\">|</span> <span class=\"n\">DistVal.Empty</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">contradiction</span> <span class=\"c1\">-- doesnt work :/</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">res</span> <span class=\"o\">:=</span> <span class=\"n\">local_comp</span> <span class=\"o\">(</span><span class=\"n\">DistVal.Wrap</span> <span class=\"mi\">3</span> <span class=\"s2\">\"alice\"</span><span class=\"o\">)</span> <span class=\"c1\">-- shouldnt thise be able to synthesize Coe instance now?</span>\n</code></pre></div>",
        "id": 423211752,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1708816401
    },
    {
        "content": "<p>Maybe like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">DistVal.notEmpty</span><span class=\"o\">:</span> <span class=\"n\">DistVal</span> <span class=\"n\">a</span> <span class=\"n\">loc</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">Wrap</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span> <span class=\"c1\">-- Capitalized. `true` is a Bool which was being coerced into a `Prop`</span>\n<span class=\"bp\">|</span> <span class=\"n\">Empty</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">local_comp</span> <span class=\"o\">(</span><span class=\"n\">dv</span><span class=\"o\">:</span> <span class=\"n\">DistVal</span> <span class=\"n\">Nat</span> <span class=\"s2\">\"alice\"</span><span class=\"o\">):</span> <span class=\"n\">local_comp_type</span> <span class=\"s2\">\"alice\"</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">return</span> <span class=\"n\">dv</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">all_alice_exist</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dv</span><span class=\"o\">:</span> <span class=\"n\">DistVal</span> <span class=\"n\">x</span> <span class=\"s2\">\"alice\"</span><span class=\"o\">),</span> <span class=\"n\">dv.notEmpty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">DistVal.unwrap</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">dv</span> <span class=\"o\">:</span> <span class=\"n\">DistVal</span> <span class=\"n\">α</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">dv.notEmpty</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Wrap</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Empty</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">notEmpty</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">res</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">DistVal</span> <span class=\"n\">α</span> <span class=\"s2\">\"alice\"</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">dv</span> <span class=\"bp\">↦</span> <span class=\"n\">DistVal.unwrap</span> <span class=\"o\">(</span><span class=\"n\">all_alice_exist</span> <span class=\"n\">α</span> <span class=\"n\">dv</span><span class=\"o\">)⟩</span>\n  <span class=\"c1\">-- ^ You can always make a helper definition for creating these instances</span>\n  <span class=\"n\">local_comp</span> <span class=\"o\">(</span><span class=\"n\">DistVal.Wrap</span> <span class=\"mi\">3</span> <span class=\"o\">(</span><span class=\"n\">loc</span> <span class=\"o\">:=</span> <span class=\"s2\">\"alice\"</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 423213575,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708818126
    },
    {
        "content": "<p>i didnt know you can define Instance like this, but it makes sense<br>\n thanks for your patience and detailed help!</p>",
        "id": 423213922,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1708818510
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684702\">Simon Daniel</span> has marked this topic as resolved.</p>",
        "id": 423213927,
        "sender_full_name": "Notification Bot",
        "timestamp": 1708818518
    },
    {
        "content": "<p>One papercut I noticed with my suggestion is that whenever you write <code>local_comp dv</code>, Lean immediately tries to synthesize the <code>[∀ α, Coe (DistVal α l) α]</code>, even if you weren't yet ready to evaluate the computation. You could block Lean from attempting synthesis until you're ready by changing <code>local_comp_type</code> to <code>Unit -&gt; [∀ α, Coe (DistVal α l) α] -&gt; IO a</code>. That way <code>local_comp dv</code> represents a future computation and <code>local_comp dv ()</code> actually performs the computation.</p>",
        "id": 423216894,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708821494
    },
    {
        "content": "<p>another thing i noticed is that doesnt try to coerce if it does not need to. And if the right type cannot be deferred it gets a little less pretty.<br>\n When using for example, lets say two DistVal Nat Values a and b: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"c1\">--doesnt work if both sides are DistVal Nats</span>\n<span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">b</span><span class=\"o\">)</span>  <span class=\"c1\">-- same</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cast_dv</span> <span class=\"o\">(</span><span class=\"n\">dv</span><span class=\"o\">:</span> <span class=\"n\">DistVal</span> <span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">:</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">DistVall</span> <span class=\"n\">x</span>  <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">]:</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe</span> <span class=\"n\">dv</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"⤉\"</span> <span class=\"n\">dv</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cast_dv</span> <span class=\"n\">dv</span>\n\n<span class=\"o\">(</span><span class=\"bp\">⤉</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"bp\">⤉</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"c1\">--my solution</span>\n</code></pre></div>\n<p>a nice improvement already, if you can think of a more elegant way let me know :)</p>",
        "id": 423217698,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1708822534
    },
    {
        "content": "<p>Can you use a type ascription like <code>(a : Nat) &lt; b</code>?</p>",
        "id": 423217801,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708822668
    },
    {
        "content": "<p>yes that works aswell</p>",
        "id": 423217975,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1708822862
    }
]