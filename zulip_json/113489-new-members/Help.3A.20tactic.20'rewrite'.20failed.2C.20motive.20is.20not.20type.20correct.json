[
    {
        "content": "<p>I'm trying to figure out how to do rewriting when \"type casting\" is used in the statement of my conjecture. Here's a small illustrative example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.List.Basic</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">data</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">lenc</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">List.length</span> <span class=\"n\">data</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">append</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">a.data</span> <span class=\"bp\">++</span> <span class=\"n\">b.data</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">List.length_append</span><span class=\"o\">,</span> <span class=\"n\">a.lenc</span><span class=\"o\">,</span> <span class=\"n\">b.lenc</span><span class=\"o\">]⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">zero_append</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"o\">(</span><span class=\"n\">append</span> <span class=\"o\">⟨[],</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">⟩</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">append</span><span class=\"o\">]</span>\n  <span class=\"n\">revert</span> <span class=\"n\">h</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">zero_add</span><span class=\"o\">]</span> <span class=\"c1\">-- tactic 'rewrite' failed, motive is not type correct</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Could someone please help me prove <code>zero_append</code> and also explain why the <code>rw [zero_add]</code> above fails with that message? Thanks!</p>",
        "id": 411636619,
        "sender_full_name": "Shilpi Goel",
        "timestamp": 1704665923
    },
    {
        "content": "<p><code>simp_rw [zero_add]</code> deals with that error, but the rest doesn't seem easy either</p>",
        "id": 411637698,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1704666770
    },
    {
        "content": "<p>With some setup of a <code>Vector.cast</code> API, the proof is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">zero_append</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">Vector.append</span> <span class=\"o\">⟨[],</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext1</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Vector.append</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.List.Basic</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">data</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">lenc</span> <span class=\"o\">:</span> <span class=\"n\">List.length</span> <span class=\"n\">data</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simps</span><span class=\"kd\">]</span> <span class=\"c1\">-- creates `Vector.nil_data` simp lemma</span>\n<span class=\"kd\">def</span> <span class=\"n\">Vector.nil</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"o\">⟨[],</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"c1\">-- note: `by decide` for equalities is often `rfl`</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Vector.append</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">a.data</span> <span class=\"bp\">++</span> <span class=\"n\">b.data</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">List.length_append</span><span class=\"o\">,</span> <span class=\"n\">a.lenc</span><span class=\"o\">,</span> <span class=\"n\">b.lenc</span><span class=\"o\">]⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Vector.cast</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">n'</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">a</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">-- Cast API not necessary for this example</span>\n<span class=\"cm\">@[simp]</span>\n<span class=\"cm\">theorem Vector.cast_rfl (a : Vector n) : a.cast rfl = a := rfl</span>\n\n<span class=\"cm\">@[simp]</span>\n<span class=\"cm\">theorem Vector.cast_cast (a : Vector n) (h : n = n') (h' : n' = n'') :</span>\n<span class=\"cm\">    (a.cast h).cast h' = a.cast (h.trans h') := by</span>\n<span class=\"cm\">  subst_vars; rfl</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Vector.cast_data</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">a.cast</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">data</span> <span class=\"bp\">=</span> <span class=\"n\">a.data</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">subst_vars</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">-- Not necessary for this example</span>\n<span class=\"cm\">theorem append_cast_left (a : Vector n) (b : Vector m) (h : n = n') :</span>\n<span class=\"cm\">    (a.cast h).append b = (a.append b).cast (by simp [h]) := by</span>\n<span class=\"cm\">  subst_vars; rfl</span>\n\n<span class=\"cm\">theorem append_cast_right (a : Vector n) (b : Vector m) (h : m = m') :</span>\n<span class=\"cm\">    a.append (b.cast h) = (a.append b).cast (by simp [h]) := by</span>\n<span class=\"cm\">  subst_vars; rfl</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">zero_append</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">Vector.append</span> <span class=\"o\">⟨[],</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext1</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Vector.append</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 411639791,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704668521
    },
    {
        "content": "<p>This is being asked more and more since we switched to lean 4. I wonder whether it's worth preserving this answer by writing up some helpful document on the community website (like the lean 3 simp and conv documents)</p>",
        "id": 411642318,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704670772
    },
    {
        "content": "<p>Collecting tricks to manage dependent types is a good idea. I'm not sure this is related to Lean 4 though -- the <code>cast</code> idea comes from mathlib3</p>",
        "id": 411642430,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704670877
    },
    {
        "content": "<p>The conv documentation is here by the way (and expanded):</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/docs/Conv/Introduction.html\">https://leanprover-community.github.io/mathlib4_docs/docs/Conv/Introduction.html</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/docs/Conv/Guide.html\">https://leanprover-community.github.io/mathlib4_docs/docs/Conv/Guide.html</a></li>\n</ul>\n<p>I have a partially-ported simp document somewhere...</p>",
        "id": 411642546,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704670985
    },
    {
        "content": "<p>Once we have such a document, the error message can point to it.</p>",
        "id": 411700273,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1704706437
    },
    {
        "content": "<p>The reason I mentioned Lean 4 was simply that I've noticed that we've got more people coming along asking questions about the Vector type and how it causes trouble in dependent type theory, since we switched to Lean 4 and perhaps started attracting more computer scientists.</p>",
        "id": 411704167,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704707798
    },
    {
        "content": "<p>Thank you so much, <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>! That was very helpful.</p>\n<p>It'd be really helpful to have a doc. topic where some frequently encountered errors are listed, along with suggestions <em>and</em> examples on what they mean and how to fix them.</p>",
        "id": 411792916,
        "sender_full_name": "Shilpi Goel",
        "timestamp": 1704737799
    },
    {
        "content": "<p>Since we're on this topic, I find myself defining my own version of <code>cast</code> for bitvectors in the following, which suggests to me that perhaps I'm not making optimal use of <code>Std.BitVec.cast</code>. What can I do to avoid defining <code>my_cast</code> below? Thanks! </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- leanprover/lean4:v4.5.0-rc1</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std.Data.BitVec.Lemmas</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Std.BitVec</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">empty_bitvector_append_left_cast</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Std.BitVec</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">Std.BitVec.cast</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">#</span><span class=\"mi\">0</span> <span class=\"bp\">++</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">HAppend.hAppend</span><span class=\"o\">,</span> <span class=\"n\">Std.BitVec.append</span><span class=\"o\">,</span> <span class=\"n\">shiftLeftZeroExtend</span><span class=\"o\">,</span> <span class=\"n\">zeroExtend'</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">HOr.hOr</span><span class=\"o\">,</span> <span class=\"n\">OrOp.or</span><span class=\"o\">,</span> <span class=\"n\">Std.BitVec.or</span><span class=\"o\">,</span> <span class=\"n\">Nat.lor</span><span class=\"o\">]</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">Nat.bitwise</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Std.BitVec.cast</span><span class=\"o\">]</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">my_cast</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Std.BitVec</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Std.BitVec</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">my_cast_eq_cast</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Std.BitVec</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">my_cast</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">Std.BitVec.cast</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">subst_vars</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">my_cast</span><span class=\"o\">,</span> <span class=\"n\">Std.BitVec.cast_eq</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">empty_bitvector_append_left</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Std.BitVec</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">#</span><span class=\"mi\">0</span> <span class=\"bp\">++</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:=</span> <span class=\"n\">empty_bitvector_append_left_cast</span> <span class=\"n\">x</span> <span class=\"n\">h</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">my_cast_eq_cast</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">my_cast</span> <span class=\"n\">at</span> <span class=\"n\">h2</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h2</span><span class=\"o\">]</span>\n  <span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 411794703,
        "sender_full_name": "Shilpi Goel",
        "timestamp": 1704738491
    }
]