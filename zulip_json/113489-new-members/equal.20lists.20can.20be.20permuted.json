[
    {
        "content": "<p>I want to show that there exists some <code>Equiv.Perm</code> for any two equal finite lists. No clue how to go about this tbh, any help would be appreciated:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Logic.Equiv.Defs</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.BigOperators.Basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A₁</span> <span class=\"n\">A₂</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">A₁</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">A₂</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Equiv.Perm</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">A₂</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">A₁</span> <span class=\"o\">((</span><span class=\"n\">Equiv.symm</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 416647406,
        "sender_full_name": "Monica Omar",
        "timestamp": 1705611055
    },
    {
        "content": "<p>I don't think it holds. Consider <code>A₁ = !['a', 'a', 'b']</code> and <code>A₂ = !['a', 'b', 'b']</code>.</p>",
        "id": 416649658,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705611928
    },
    {
        "content": "<p>Oh right, we'd need to probably say something about uniqueness for it to hold and the lists to actually be equal (up to permutation)?</p>",
        "id": 416650202,
        "sender_full_name": "Monica Omar",
        "timestamp": 1705612141
    },
    {
        "content": "<p>Depends on what kind of characterization you want and what type you want to apply it to. You may want to talk about <code>~</code> on <code>List</code>s, you may want to talk about <code>=</code> on <code>Multiset</code>s...</p>",
        "id": 416651252,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705612607
    },
    {
        "content": "<p>You may want to have <code>Finset</code> which is <code>Multiset</code> without duplicates.</p>",
        "id": 416651526,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705612738
    },
    {
        "content": "<p>(<code>~</code> is notation for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Perm#doc\">docs#List.Perm</a> which is the thing you seemed to be asking for at first)</p>",
        "id": 416651711,
        "sender_full_name": "Richard Copley",
        "timestamp": 1705612816
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.isPerm_iff#doc\">docs#List.isPerm_iff</a> might be useful too</p>",
        "id": 416651982,
        "sender_full_name": "Richard Copley",
        "timestamp": 1705612964
    },
    {
        "content": "<p>Let's stick with <code>Fin n -&gt; R</code> for now.</p>\n<p>So what I wanted to say is that both vectors are equal, and also that they have the same multiplicities. So if <code>A₁</code> has two <code>'a'</code>'s then so should <code>A₂</code>. Then there should exist a permutation <code>Equiv.Perm</code> that permutes one to the other.</p>\n<p>How do I say this in Lean though, my mind is drawing a blank at the moment.</p>",
        "id": 416654092,
        "sender_full_name": "Monica Omar",
        "timestamp": 1705613993
    },
    {
        "content": "<p>It seems to me that you have a weird notion of \"both vectors are equal\".</p>",
        "id": 416654215,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705614051
    },
    {
        "content": "<p>Do you want to say, as you assumption, that converting both vectors to a multisets gives equal multisets?</p>",
        "id": 416654323,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705614121
    },
    {
        "content": "<p>Yeah, actually, you're right, it does seem weird.</p>\n<p>Okay, let's go for <code>Set R</code> then? And say that both sets are equal with equal multiplicities?</p>",
        "id": 416654462,
        "sender_full_name": "Monica Omar",
        "timestamp": 1705614191
    },
    {
        "content": "<p>I didn't offer <code>Set</code> for a reason — it doesn't track multiplicities.</p>",
        "id": 416654530,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705614239
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113489-new-members/topic/equal.20lists.20can.20be.20permuted/near/416654323\">said</a>:</p>\n<blockquote>\n<p>Do you want to say, as you assumption, that converting both vectors to a multisets gives equal multisets?</p>\n</blockquote>\n<p>Perhaps, perhaps. You know, I kind of lost track of what I was trying to even prove in the first place lmao</p>",
        "id": 416654642,
        "sender_full_name": "Monica Omar",
        "timestamp": 1705614293
    },
    {
        "content": "<p>Lemme have a rethink of all this, and get back on this tomorrow</p>",
        "id": 416654681,
        "sender_full_name": "Monica Omar",
        "timestamp": 1705614316
    },
    {
        "content": "<p>Okay, what's a nice way to describe that every entry of <code>A₁</code> and <code>A₂</code> are equal with the same multiplicity?</p>",
        "id": 416832653,
        "sender_full_name": "Monica Omar",
        "timestamp": 1705685856
    },
    {
        "content": "<p>It's hard to know how to answer. If this is an exercise you've set yourself, it would be a shame to spoil it for you. If it's something you think you need as part of the solution to a broader problem, the best advice would depend on the details of that problem (but would probably be \"you should rephrase the problem in terms of multisets\").</p>",
        "id": 416835423,
        "sender_full_name": "Richard Copley",
        "timestamp": 1705686784
    },
    {
        "content": "<p>Naw, naw, it's ok. Please spoil it haha</p>",
        "id": 416836992,
        "sender_full_name": "Monica Omar",
        "timestamp": 1705687277
    },
    {
        "content": "<p>Well, no, because while it won't be difficult, it will take a long time and it will be boring, and it will serve no useful purpose. The good ways to do this already exist.</p>",
        "id": 416838116,
        "sender_full_name": "Richard Copley",
        "timestamp": 1705687585
    },
    {
        "content": "<p>What are the good ways? How do I transform <code>(A₁ A₂ : Fin n -&gt; R)</code> to multisets?</p>",
        "id": 416838405,
        "sender_full_name": "Monica Omar",
        "timestamp": 1705687684
    },
    {
        "content": "<p><code>Multiset.ofList (List.ofFn f)</code> is one way. There might be a direct conversion.</p>",
        "id": 416839250,
        "sender_full_name": "Richard Copley",
        "timestamp": 1705687973
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"477483\">Monica Omar</span> <a href=\"#narrow/stream/113489-new-members/topic/equal.20lists.20can.20be.20permuted/near/416832653\">said</a>:</p>\n<blockquote>\n<p>Okay, what's a nice way to describe that every entry of <code>A₁</code> and <code>A₂</code> are equal with the same multiplicity?</p>\n</blockquote>\n<p>Richard already mentioned <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Perm#doc\">docs#List.Perm</a>... would that work? That seems like a pretty direct statement of what you're asking.</p>",
        "id": 416855417,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1705693644
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400544\">Richard Copley</span> <a href=\"#narrow/stream/113489-new-members/topic/equal.20lists.20can.20be.20permuted/near/416839250\">said</a>:</p>\n<blockquote>\n<p><code>Multiset.ofList (List.ofFn f)</code> is one way. There might be a direct conversion.</p>\n</blockquote>\n<p>I believe that <code>Finset.univ.val.map A₁</code> should also produce the multiset.</p>",
        "id": 416856674,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705694121
    },
    {
        "content": "<p>For <code>Fin n -&gt; R</code> functions, you could say that for each element of <code>R</code> that the preimages have the same cardinality. You could write a preimage cardinality as <code>(Finset.filter (fun i =&gt; A₁ i = r)).card</code>.</p>\n<p>I'm not sure if this is any good in practice, but at least it's a simple definition.</p>",
        "id": 416858330,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705694719
    },
    {
        "content": "<p>on a side note, <span class=\"user-mention\" data-user-id=\"477483\">@Monica Omar</span> was asking for proof that an <code>Equiv.Perm</code> exists but that doesn't actually make sense in the context of lists, right? <code>Equiv.Perm</code> only works for types or sets coerced to types</p>",
        "id": 416858709,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1705694866
    },
    {
        "content": "<p>At least you could ask for an <code>Equiv.Perm</code> for the type of indices for a list, so that when you reindex according to it you get the other list.</p>",
        "id": 416859275,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705695084
    }
]