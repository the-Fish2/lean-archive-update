[
    {
        "content": "<p>I've defined the diameter of a <code>SimpleGraph</code> as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">diam</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">∞</span> <span class=\"o\">:=</span>\n  <span class=\"n\">sSup</span> <span class=\"o\">{</span><span class=\"n\">d</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">G.dist</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>I would like to have a lemma stating that there exists <code>u</code> and <code>v</code> such that <code>G.dist u v = G.diam</code>, perhaps when <code>α</code> is finite.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Metric</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Girth</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">SimpleGraph</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">diam</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">∞</span> <span class=\"o\">:=</span>\n  <span class=\"n\">sSup</span> <span class=\"o\">{</span><span class=\"n\">d</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">G.dist</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">diam_eq_dist</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">G.diam</span> <span class=\"bp\">≠</span> <span class=\"bp\">⊤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"c1\">-- is this condition correct?</span>\n    <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">G.diam</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">G.diam</span> <span class=\"bp\">=</span> <span class=\"n\">G.dist</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">∧</span> <span class=\"n\">G.Reachable</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">∧</span> <span class=\"n\">u</span> <span class=\"bp\">≠</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">.</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- what to do</span>\n  <span class=\"bp\">.</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h.1</span><span class=\"o\">,</span> <span class=\"n\">Nat.one_le_cast</span><span class=\"o\">]</span>\n    <span class=\"n\">apply</span> <span class=\"n\">LT.lt.nat_succ_le</span> <span class=\"o\">(</span><span class=\"n\">Reachable.pos_dist_of_ne</span> <span class=\"n\">h.2.1</span> <span class=\"n\">h.2.2</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It seems that the perfect lemma to use here is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.sSup_mem#doc\">docs#Nat.sSup_mem</a>, but it needs a hypothesis stating that the set of distances is <code>BddAbove</code>. Or maybe we can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Nonempty.csSup_mem#doc\">docs#Set.Nonempty.csSup_mem</a>, but in that case, we need to show that the set is finite and non-empty.</p>\n<p>In both cases, I don't know how to continue this, any help is highly appreciated!</p>",
        "id": 431712375,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1712444677
    },
    {
        "content": "<p>Actually I would be happy with a lemma of this form:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">diam_exists</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">G.diam</span> <span class=\"bp\">≠</span> <span class=\"bp\">⊤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span>  <span class=\"n\">G.dist</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">G.diam</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>As proving the lemma above is easy after I've obtained such a lemma.</p>",
        "id": 431712596,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1712445000
    },
    {
        "content": "<p>You can apply this theorem to find the upper bound you need: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/ENat/Lattice.html#ENat.iSup_coe_ne_top\">ENat.iSup_coe_ne_top</a></p>",
        "id": 431714206,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712447030
    },
    {
        "content": "<p>Sorry, maybe this doesn't work. I'll be back soon to find something.</p>",
        "id": 431714272,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712447093
    },
    {
        "content": "<p>One way is to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/WithBot.html#WithTop.coe_untop\">WithTop.coe_untop</a> to prove that <code>G.diam</code> is actually a natural number, and then use that as your upper bound.</p>",
        "id": 431714321,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712447159
    },
    {
        "content": "<p>You might need a <code>Nonempty α</code> assumption, unless I'm missing something</p>",
        "id": 431714410,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1712447236
    },
    {
        "content": "<p>man, this is surprisingly annoying to prove... you'd think we'd have this lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">ENat.sSup_mem_of_nonempty_ne_top</span>\n  <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.Nonempty</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs2</span> <span class=\"o\">:</span> <span class=\"n\">sSup</span> <span class=\"n\">s</span> <span class=\"bp\">≠</span> <span class=\"bp\">⊤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">sSup</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 431716936,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1712449812
    },
    {
        "content": "<p>Thank you for the suggestions! I've read a bit in the file of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/WithBot.html#WithTop.coe_untop\">WithTop.coe_untop</a> and found another useful lemma <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/WithBot.html#WithTop.ne_top_iff_exists\">WithTop.ne_top_iff_exists</a>. Here is my code so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Metric</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Girth</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">SimpleGraph</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">diam</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">∞</span> <span class=\"o\">:=</span>\n  <span class=\"n\">sSup</span> <span class=\"o\">{</span><span class=\"n\">d</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">G.dist</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">diam_exists</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">G.diam</span> <span class=\"bp\">≠</span> <span class=\"bp\">⊤</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span>  <span class=\"n\">G.dist</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">G.diam</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">hn</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">WithTop.ne_top_iff_exists.mp</span> <span class=\"n\">ht</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hn</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ENat.some_eq_coe</span><span class=\"o\">,</span> <span class=\"n\">Nat.cast_inj</span><span class=\"o\">]</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">    α: Type u_1</span>\n<span class=\"cm\">    G: SimpleGraph α</span>\n<span class=\"cm\">    ht: diam G ≠ ⊤</span>\n<span class=\"cm\">    n: ℕ</span>\n<span class=\"cm\">    hn: ↑n = diam G</span>\n<span class=\"cm\">    ⊢ ∃ u v, dist G u v = n</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>My problem is that I am unable to use a theorem such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Nat/Lattice.html#Nat.sSup_def\">Nat.sSup_def</a> because of the coercion, so I am unable do something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">d</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"n\">d</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">G.dist</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">},</span> <span class=\"n\">d</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hn</span><span class=\"o\">]</span> <span class=\"c1\">-- tactic 'rewrite' failed, did not find instance of the pattern in the target expression</span>\n  <span class=\"bp\">↑</span><span class=\"n\">n</span>\n</code></pre></div>",
        "id": 431717041,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1712449977
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WithTop.sSup_eq#doc\">docs#WithTop.sSup_eq</a> might be relevant... if you could prove that <code>WithTop.some ⁻¹' s</code> is bounded above, then you could shift to the Nat context</p>",
        "id": 431717298,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1712450342
    },
    {
        "content": "<p>When I try something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">have</span> <span class=\"n\">hs'</span> <span class=\"o\">:</span> <span class=\"n\">BddAbove</span> <span class=\"o\">(</span><span class=\"n\">WithTop.some</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I get the following error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">application type mismatch</span>\n<span class=\"cm\">  WithTop.some ⁻¹' s</span>\n<span class=\"cm\">argument</span>\n<span class=\"cm\">  s</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  Set ℕ : Type</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  Set (WithTop ?m.3332) : Type</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>Is there a way to get the statement accepted?</p>",
        "id": 431718236,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1712451393
    },
    {
        "content": "<p>my guess is that when you defined <code>s</code> you didn't specify that the elements are ENats, so Lean assumed they were Nats</p>\n<p>try something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">∞</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">G.dist</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 431718460,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1712451633
    },
    {
        "content": "<p>Maybe it is more useful to prove <code>ENat.sSup_mem_of_nonempty_ne_top</code> which you provided above first. I'll sleep on it today and reattempt proving it tomorrow. I'll use this topic to send any new questions I get.  Thank you! <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 431719000,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1712452231
    },
    {
        "content": "<p>sounds good... I've actually got a proof of <code>diam_exists</code> though it could probably use some golfing, I'll post shortly</p>",
        "id": 431719052,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1712452295
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">top_not_mem_of_sup_ne_top</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">sSup</span> <span class=\"n\">s</span> <span class=\"bp\">≠</span> <span class=\"bp\">⊤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⊤</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">contrapose</span><span class=\"bp\">!</span> <span class=\"n\">hs</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sSup_eq_top</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">b</span> <span class=\"n\">hb</span>\n  <span class=\"n\">use</span> <span class=\"bp\">⊤</span><span class=\"o\">,</span> <span class=\"n\">hs</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">diam_exists</span> <span class=\"o\">[</span><span class=\"n\">Nonempty</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">G.diam</span> <span class=\"bp\">≠</span> <span class=\"bp\">⊤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span>  <span class=\"n\">G.dist</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">G.diam</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">diam</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">set</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">∞</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">G.dist</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n  <span class=\"k\">let</span> <span class=\"n\">s'</span> <span class=\"o\">:=</span> <span class=\"n\">WithTop.some</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span>\n  <span class=\"k\">have</span> <span class=\"n\">nonempty_s'</span> <span class=\"o\">:</span> <span class=\"n\">s'.Nonempty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">have</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">Classical.arbitrary</span> <span class=\"n\">α</span>\n    <span class=\"n\">use</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">v</span>\n    <span class=\"n\">exact</span> <span class=\"n\">congrArg</span> <span class=\"n\">_</span> <span class=\"n\">SimpleGraph.dist_self.symm</span>\n  <span class=\"k\">have</span> <span class=\"n\">bddAbove_s'</span> <span class=\"o\">:</span> <span class=\"n\">BddAbove</span> <span class=\"n\">s'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">sSup_eq_top.not</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">ht</span>\n    <span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"n\">ht</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">ht</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">ub</span><span class=\"o\">,</span> <span class=\"n\">ub_lt_top</span><span class=\"o\">,</span> <span class=\"n\">hub</span><span class=\"o\">⟩</span>\n    <span class=\"n\">use</span> <span class=\"n\">WithTop.untop</span> <span class=\"n\">ub</span> <span class=\"n\">ub_lt_top.ne</span>\n    <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">ha</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">WithTop.le_untop_iff</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_preimage</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">ha</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hub</span> <span class=\"n\">a</span> <span class=\"n\">ha</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">huv</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.sSup_mem</span> <span class=\"n\">nonempty_s'</span> <span class=\"n\">bddAbove_s'</span>\n  <span class=\"k\">have</span> <span class=\"n\">top_not_mem</span> <span class=\"o\">:=</span> <span class=\"n\">top_not_mem_of_sup_ne_top</span> <span class=\"n\">ht</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">WithTop.sSup_eq</span> <span class=\"n\">top_not_mem</span> <span class=\"n\">bddAbove_s'</span><span class=\"o\">]</span>\n  <span class=\"n\">use</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">huv.symm</span>\n</code></pre></div>",
        "id": 431720575,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1712453750
    }
]