[
    {
        "content": "<p>hello, i'm quite new here so apologies and please let me know if this isn't the right place to ask this.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- `OneHom M N` is the type of functions `M → N` that preserve one.</span>\n\n<span class=\"sd\">When possible, instead of parametrizing results over `(f : OneHom M N)`,</span>\n<span class=\"sd\">you should parametrize over `(F : Type*) [OneHomClass F M N] (f : F)`.</span>\n\n<span class=\"sd\">When you extend this structure, make sure to also extend `OneHomClass`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">OneHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">One</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">One</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The underlying function -/</span>\n<span class=\"w\">  </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">N</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The proposition that the function preserves 1 -/</span>\n<span class=\"w\">  </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">map_one'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span><span class=\"w\"> </span><span class=\"n\">one_hom</span><span class=\"w\"> </span><span class=\"n\">OneHom</span>\n</code></pre></div>\n<p>i follow that mathlib implements group homs as an extension(?) of <code>Monoid</code> homs, and that it deals with this using type classes and structures, but what confuses me is the parametrization. to me, the first method that the comment proposes seems perfectly fine. in a related vein, is there any reason that the map toFun is provided as a field of the structure rather than defining a homomorphism on its own, something like <code>def Homomorphism [Group G] [Group H] (\\phi : G \\rightarrow H) : Prop := \\forall a b \\in G, \\phi(a * b) = \\phi(a) * \\phi(b)</code>? does the way that it' s done in mathlib allow for more flexibility? thank you in advance! :)</p>",
        "id": 444971684,
        "sender_full_name": "Arim",
        "timestamp": 1718540445
    },
    {
        "content": "<p>With <code>def Homomorphism [Group G] [Group H] (\\phi : G \\rightarrow H) : Prop := \\forall a b \\in G, \\phi(a * b) = \\phi(a) * \\phi(b)</code> you end up carrying two different things around, the homomorphism itself and the proof that it is a homeomorphism. It's more convenient to bundle them into one structure.</p>",
        "id": 445038003,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1718586646
    },
    {
        "content": "<p>Another reason for bundling is that it allows for more automation to rewrite things like <code>f (x * y) = f x * f y</code></p>",
        "id": 445073956,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1718610923
    },
    {
        "content": "<p>also, the reason why the comment suggests proving things for <code>OneHomClass</code> rather than for <code>OneHom</code> is that there is an instance <code>OneHomClass (MonoidHom a b) a b</code> (and others like it), which will allow you to use lemmas for the general <code>OneHom</code> concept in more specific cases like for group/field/vectorspace homomorphisms. This is an immense help for deduplicating API, because just like for the \"space-like\" objects in algebra, there is a towering hierarchy for maps between two \"space-like\" objects.</p>\n<p>as a concrete example: suppose you have proven some property <code>Foo</code> of functions always is the case for <code>OneHom</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Group</span><span class=\"bp\">.</span><span class=\"n\">Hom</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">One</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OneHomClass</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">onehom_is_foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OneHom</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">onehom_is_foo'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MonoidHom</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- fails</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">onehom_is_foo</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"c1\">-- application type mismatch ...</span>\n<span class=\"c1\">-- argument `f` has type `MonoidHom a a` but is expected to have type `OneHom a a`</span>\n\n<span class=\"c1\">-- kind of works, but is verbose and annoying to work with. basically an ugly fix.</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">onehom_is_foo</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">toOneHom</span><span class=\"w\"> </span><span class=\"c1\">-- onehom_is_foo ↑f : Foo ⇑↑f</span>\n\n<span class=\"c1\">-- works, giving the statement we want.</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">onehom_is_foo'</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"c1\">-- onehom_is_foo' f : Foo ⇑f</span>\n\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>as you can see, we are able to use facts proven using the suggested method for more specific cases this way, by using the automation lean provides.</p>",
        "id": 445118580,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1718626508
    },
    {
        "content": "<p>i see, thank you all for the clear explanations, and thanks edward for the great demo!</p>",
        "id": 445163022,
        "sender_full_name": "Arim",
        "timestamp": 1718638579
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"728335\">Arim</span> has marked this topic as resolved.</p>",
        "id": 445163045,
        "sender_full_name": "Notification Bot",
        "timestamp": 1718638585
    }
]