[
    {
        "content": "<p>Here is a small example where I've been trying to work out what the error is telling me.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">5</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The error I'm seeing says:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">argument</span>\n  <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">5</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Prop</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"n\">u.202</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">u.202</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I think that this wants a <code>Type</code> when I gave it a <code>Sort</code>? Though isn't <code>Type i</code> just sugar for <code>Sort (i - 1)</code>?</p>\n<p>I do get that what this is doing is strange. <code>t</code> is what? ... a predicate for perhaps a proof? I'm assuming impredicative Prop might be the reason this isn't allowed, but I'm still having trouble parsing the error.</p>",
        "id": 416819135,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1705682431
    },
    {
        "content": "<p><code>Option</code> expects an argument that lives in <code>Type</code>, and doesn't take in predicates (things that live in <code>Prop</code>). <code>Type u</code> is sugar for <code>Sort (u+1)</code>, not <code>Sort (u-1)</code>.</p>",
        "id": 416820868,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1705682838
    },
    {
        "content": "<p>In order to do this, you could either define your own optional type which would live in Prop, i.e use:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">OptionP</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">True</span>\n</code></pre></div>\n<p>Another way you could to it would be to use a universe lift <code>PLift</code>, your type would then be <code>Option (PLift (x &gt; 5))</code> instead of <code>Option (x &gt; 5)</code>.</p>",
        "id": 416821878,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1705683064
    },
    {
        "content": "<p>Ah yes. That makes sense</p>",
        "id": 416822371,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1705683195
    },
    {
        "content": "<p>PLift's implementation is so simple - which makes sense. Very cool.</p>",
        "id": 416824640,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1705683763
    },
    {
        "content": "<p>I suppose my follow up question is whether there's a deeper reason behind why Option isn't implemented for Prop as well?</p>\n<p>Playing around with the following seems to work</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Option'</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:</span> <span class=\"n\">Option'</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option'</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>The universe polymorphic type is like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Option'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"mi\">1</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 416841780,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1705688804
    },
    {
        "content": "<p>Is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">OptionP</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">True</span>\n</code></pre></div>\n<p>really useful? It’s equivalent to <code>True</code> no matter what <code>P</code> is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">OptionP</span> <span class=\"n\">P</span> <span class=\"bp\">=</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"n\">or_true</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 416841870,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705688828
    },
    {
        "content": "<p>yeah, you want <code>⊕'</code> there instead</p>",
        "id": 416841964,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705688867
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"664276\">@Treq</span> the <code>max 1 u</code> universe tends to generate harder universe unification problems because it is not injective, compared to <code>u+1</code> which is what <code>Option</code> has. That's why we have <code>PSum</code> and <code>PSigma</code> as more general versions of <code>Sum</code> and <code>Sigma</code> which allow any sort, but don't use them by default</p>",
        "id": 416842363,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705688994
    },
    {
        "content": "<p><code>A ⊕' B</code> is notation for <code>PSum A B</code></p>",
        "id": 416842505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705689030
    },
    {
        "content": "<p>Ah, okay! Good to know :)</p>",
        "id": 416842896,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1705689164
    }
]