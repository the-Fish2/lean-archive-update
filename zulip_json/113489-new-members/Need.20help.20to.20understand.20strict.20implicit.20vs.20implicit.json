[
    {
        "content": "<p>There are a few theorems in <code>Finset</code> that contain strict implicits. I am not quite getting what the documentation about strict implicit says: \"Strict-implicit binder. In contrast to { ... } regular implicit binders, a strict-implicit binder is inserted automatically only when at least one subsequent explicit parameter is specified.\"</p>\n<p>Suppose I have something simple like the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">⦃</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">⦄</span> <span class=\"o\">{</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">q</span>\n</code></pre></div>\n<p>How would strict implicit around <code>m </code>here behave differently as opposed to being just an implicit?</p>",
        "id": 419353038,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1706830476
    },
    {
        "content": "<p>Let's compare strict implicit and regular implicits:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">⦃</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">⦄</span> <span class=\"o\">{</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">q</span>\n<span class=\"kd\">def</span> <span class=\"n\">bar'</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">q</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">Using parentheses forces `#check` to show you the type of the expression,</span>\n<span class=\"cm\">rather than giving a declaration-style signature for a constant.</span>\n<span class=\"cm\">-/</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">bar</span><span class=\"o\">)</span>\n<span class=\"c1\">-- bar : ⦃m : ℕ⦄ → {n : ℕ} → ℕ → Fin m → Fin n → ℕ</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">bar'</span><span class=\"o\">)</span>\n<span class=\"c1\">-- bar' : ℕ → Fin ?m.9034 → Fin ?m.9035 → ℕ</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">bar'</span>\n<span class=\"c1\">-- @bar' : {m n : ℕ} → ℕ → Fin m → Fin n → ℕ</span>\n<span class=\"k\">#check</span> <span class=\"n\">bar</span> <span class=\"mi\">1</span>\n<span class=\"c1\">-- bar 1 : Fin ?m.9037 → Fin ?m.9038 → ℕ</span>\n<span class=\"k\">#check</span> <span class=\"n\">bar'</span> <span class=\"mi\">1</span>\n<span class=\"c1\">-- bar' 1 : Fin ?m.9055 → Fin ?m.9056 → ℕ</span>\n</code></pre></div>",
        "id": 419354924,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706831343
    },
    {
        "content": "<p>Notice that <code>bar</code> keeps the <code>m</code> argument, but <code>bar'</code> immediately turns it into a metavariable (<code>?m.9034</code> here).</p>",
        "id": 419355094,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706831411
    },
    {
        "content": "<p>Interesting. So why do <code>#check bar 1</code> and <code>#check bar' 1</code> seem to be the same?</p>",
        "id": 419355207,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1706831474
    },
    {
        "content": "<p>They're both filling in <code>q</code> with <code>1</code>, so in both cases <code>m</code> is treated as an implicit.</p>",
        "id": 419355463,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706831600
    },
    {
        "content": "<p>So in this case, there is really no practical reason to use strict implicit?</p>",
        "id": 419355612,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1706831670
    },
    {
        "content": "<p>Strict implicits behave like regular implicits so long as an explicit argument is provided <em>after</em> it.</p>",
        "id": 419355614,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706831671
    },
    {
        "content": "<p>If you want to be able to pass <code>bar</code> around while preserving that <code>m</code> could be anything, then strict implicits are useful.</p>",
        "id": 419355699,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706831711
    },
    {
        "content": "<p>Let me if I understand this. Once Lean assigns a metavariable (e.g. ?m.9034), it's fixed for the rest of the code? But having it as m means it can change depending on who accepts bar as an argument?</p>",
        "id": 419355903,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1706831804
    },
    {
        "content": "<p>Yeah, exactly.</p>",
        "id": 419355937,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706831824
    },
    {
        "content": "<p>Many times, rather than strict implicits, you can make it be an explicit argument and then pass <code>_</code> for that argument when you want to simulate regular implicits.</p>",
        "id": 419355965,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706831838
    },
    {
        "content": "<p>Thank you.  I wish your explanation could be found in a book somewhere.</p>",
        "id": 419356127,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1706831909
    },
    {
        "content": "<p>I don't have the best sense of when strict implicits are useful, but they can be useful for properties like <code>∀ ⦃x⦄, x ∈ s → x ∈ t</code>, since then <code>x</code> stays free until you pass in the \"actual\" data, the proof of <code>x ∈ s</code></p>",
        "id": 419356131,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706831910
    },
    {
        "content": "<p>With <code>∀ x ∈ s, x ∈ t</code> notation (available in mathlib), maybe it should make the <code>x</code> be a strict implicit, but for now it's explicit. (That is, the current meaning is <code>∀ x, x ∈ s → x ∈ t</code>.)</p>",
        "id": 419356242,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706831977
    },
    {
        "content": "<p>I see. Now, it makes sense.</p>",
        "id": 419356560,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1706832110
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Need.20help.20to.20understand.20strict.20implicit.20vs.20implicit/near/419356242\">said</a>:</p>\n<blockquote>\n<p>With <code>∀ x ∈ s, x ∈ t</code> notation (available in mathlib), maybe it should make the <code>x</code> be a strict implicit, but for now it's explicit. (That is, the current meaning is <code>∀ x, x ∈ s → x ∈ t</code>.)</p>\n</blockquote>\n<p>I think for these binders it'd be nice to have these be configurable to be whatever level of implicitness is right</p>",
        "id": 419439587,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706873765
    },
    {
        "content": "<p>How would such configurability look like?</p>",
        "id": 419441204,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1706874401
    },
    {
        "content": "<p>maybe something crazy like <code>∀ ({x} ∈ s), x ∈ t</code></p>",
        "id": 419441973,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706874751
    }
]