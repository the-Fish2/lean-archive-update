[
    {
        "content": "<p>Here's something I was wondering about. If I write a bad Fibonacci implementation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fibs</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">fibs</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">fibs</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It unsurprisingly takes a few seconds to calculate e.g. <code>fibs 30</code>.</p>\n<p>But, if I write  a proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"n\">fibs</span> <span class=\"mi\">30</span> <span class=\"bp\">=</span> <span class=\"mi\">1346269</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>It type-checks instantly. Neat!</p>\n<p>What's the trick here?</p>",
        "id": 439658505,
        "sender_full_name": "Graham Leach-Krouse",
        "timestamp": 1716231296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"577178\">Graham Leach-Krouse</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20does.20rfl.20manage.20this.3F/near/439658505\">said</a>:</p>\n<blockquote>\n<p>It unsurprisingly takes a few seconds to calculate e.g. <code>fibs 30</code>.</p>\n</blockquote>\n<p>Does it really? In theory it shouldn't, memoization should happen automagically.</p>",
        "id": 439659960,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1716231789
    },
    {
        "content": "<p>There's definitely perceptible lag with <code>#eval fibs 30</code>, and several seconds worth at 35. 100 essentially hangs.</p>",
        "id": 439660498,
        "sender_full_name": "Graham Leach-Krouse",
        "timestamp": 1716231999
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20does.20rfl.20manage.20this.3F/near/439659960\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"577178\">Graham Leach-Krouse</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20does.20rfl.20manage.20this.3F/near/439658505\">said</a>:</p>\n<blockquote>\n<p>It unsurprisingly takes a few seconds to calculate e.g. <code>fibs 30</code>.</p>\n</blockquote>\n<p>Does it really? In theory it shouldn't, memoization should happen automagically.</p>\n</blockquote>\n<p>It definitely can happen in the kernel. The kernel does have caches as it performs reduction so if it has already seen some term being reduced it can reuse that result and thus effectively mimick memoization.</p>\n<p>But from the compiler POV there is no reason that memoization should be happening, it will produce the code you told it to</p>",
        "id": 439661701,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1716232399
    },
    {
        "content": "<p>Interesting. So that's presumably how rfl checks quickly in this case?</p>",
        "id": 439662097,
        "sender_full_name": "Graham Leach-Krouse",
        "timestamp": 1716232538
    },
    {
        "content": "<p>Yes, though we do not have instrumentation on the kernel caches afaik so without modifying Lean there doesn't exist an easy way to be 100% sure</p>",
        "id": 439662221,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1716232570
    },
    {
        "content": "<p>But if this were actually compiled, the performance would be as bad as you'd expect?</p>",
        "id": 439662225,
        "sender_full_name": "Graham Leach-Krouse",
        "timestamp": 1716232570
    },
    {
        "content": "<p>It is compiled, <code>#eval</code> compiles to some IR and runs that in a custom VM. You can also make it compile the IR all the way to C at which point it would get faster but it still won't auto memoize.</p>",
        "id": 439662441,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1716232648
    },
    {
        "content": "<p>Got it. Thanks!</p>",
        "id": 439662569,
        "sender_full_name": "Graham Leach-Krouse",
        "timestamp": 1716232686
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"577178\">Graham Leach-Krouse</span> has marked this topic as resolved.</p>",
        "id": 439662621,
        "sender_full_name": "Notification Bot",
        "timestamp": 1716232702
    },
    {
        "content": "<p>In fact I would be deeply worried if our compiler performed auto memoization. That sounds like a very easy way to get crazy performance changes by miniscule code changes that end up making the compiler not do memoization anymore.</p>",
        "id": 439662652,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1716232706
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20How.20does.20rfl.20manage.20this.3F/near/439662221\">said</a>:</p>\n<blockquote>\n<p>Yes, though we do not have instrumentation on the kernel caches afaik so without modifying Lean there doesn't exist an easy way to be 100% sure</p>\n</blockquote>\n<p>I can confirm that this is the source of the difference. The kernel caches the result of all typechecking and whnf'ing queries, so a highly redundant computation like this will typecheck in basically linear time.</p>",
        "id": 439672779,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1716236341
    }
]