[
    {
        "content": "<p>Hello! As an exercise for myself, I am trying to prove some facts about binary trees, namely that they are counted by Catalan numbers.  I was hoping to show that the type of trees with n leaves is a Fintype, so that I could do an #eval and  actually list off the trees with n leaves. Unfortunately, Lean warns me this definition is noncomputable, and I was wondering if anyone could give me tips on how to fix that.</p>\n<p>I have the definitions</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">BT</span> <span class=\"n\">where</span> <span class=\"c1\">-- A binary tree is either</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">:</span> <span class=\"n\">BT</span> <span class=\"c1\">-- a leaf or</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">:</span> <span class=\"n\">BT</span> <span class=\"bp\">→</span> <span class=\"n\">BT</span> <span class=\"bp\">→</span> <span class=\"n\">BT</span> <span class=\"c1\">-- a pair of binary trees.</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BT</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">NumLeaves</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">BT</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">T</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"n\">T2</span> <span class=\"n\">T3</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">NumLeaves</span> <span class=\"n\">T2</span> <span class=\"bp\">+</span> <span class=\"n\">NumLeaves</span> <span class=\"n\">T3</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">HasNumLeaves</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">:</span> <span class=\"n\">BT</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">NumLeaves</span> <span class=\"n\">T</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n<span class=\"kd\">def</span> <span class=\"n\">BTWithNumLeaves</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">BT</span> <span class=\"bp\">//</span> <span class=\"o\">(</span><span class=\"n\">HasNumLeaves</span> <span class=\"n\">T</span> <span class=\"n\">n</span><span class=\"o\">)}</span>\n</code></pre></div>\n<p>and I was able to prove the equivalence</p>\n<p><code>def TreeEq (n: ℕ) (nz: n &gt; 1): BTWithNumLeaves n ≃  Σ (k : Fin (n-1)), ( (BTWithNumLeaves (k+1)) × (BTWithNumLeaves (n-k-1)))</code> </p>\n<p>and used this with strong induction to show</p>\n<p><code>def Treefin (n: ℕ) (nz: n &gt; 0): Fintype (BTWithNumLeaves n)</code> </p>\n<p>but Lean warns me this is noncomputable. The problem seems to be with the base case</p>\n<p><code>def LeafFinite: Fintype (BTWithNumLeaves 1)</code></p>\n<p>which is also noncomputable.  My proof of LeafFinite is <a href=\"https://live.lean-lang.org/#code=import%20Mathlib%0D%0A%0D%0Ainductive%20BT%20where%20--%20A%20binary%20tree%20is%20either%0D%0A%20%20%7C%20leaf%20%3A%20BT%20--%20a%20leaf%20or%0D%0A%20%20%7C%20node%20%3A%20BT%20%E2%86%92%20BT%20%E2%86%92%20BT%20--%20a%20pair%20of%20binary%20trees.%0D%0A%0D%0Aopen%20BT%0D%0A%0D%0Adef%20exT%20%3A%20BT%20%3A%3D%20node%20(node%20leaf%20leaf)%20leaf%20--%20example%20binary%20tree.%0D%0A%0D%0Adef%20NumLeaves%20(T%20%3A%20BT)%20%3A%20%E2%84%95%20%3A%3D%0D%0A%20%20match%20T%20with%0D%0A%20%20%7C%20leaf%20%3D%3E%201%0D%0A%20%20%7C%20node%20T2%20T3%20%3D%3E%20NumLeaves%20T2%20%2B%20NumLeaves%20T3%0D%0A%0D%0Adef%20HasNumLeaves%20(T%3A%20BT)%20(n%3A%20%E2%84%95)%20%3A%20Prop%20%3A%3D%20NumLeaves%20T%20%3D%20n%0D%0Adef%20BTWithNumLeaves%20(n%20%3A%20%E2%84%95)%20%3A%20Type%20%3A%3D%20%7BT%20%3A%20BT%20%2F%2F%20(HasNumLeaves%20T%20n)%7D%0D%0A%0D%0Atheorem%20BTsPosLeaves1%20(T%3A%20BT)%20%3A%20NumLeaves%20T%20%E2%89%A5%201%20%3A%3D%20by%20%7B%0D%0A%20%20unfold%20NumLeaves%0D%0A%20%20induction%20T%20with%0D%0A%20%20%7C%20leaf%20%3D%3E%20%7B%0D%0A%20%20%20%20rfl%20%0D%0A%20%20%20%7D%0D%0A%20%20%7C%20node%20T2%20T3%20T2_pos%20%3D%3E%20%7B%0D%0A%20%20%20%20have%20h%3A%20NumLeaves%20T2%20%E2%89%A5%201%20%3A%3D%20by%20%7B%0D%0A%20%20%20%20%20%20unfold%20NumLeaves%0D%0A%20%20%20%20%20%20exact%20T2_pos%0D%0A%20%20%20%20%7D%0D%0A%20%20%20%20exact%20le_add_of_le_left%20h%0D%0A%20%20%7D%0D%0A%7D%0D%0A%0D%0Alemma%20SingletonLeaf%20(T%3A%20BT)%20(h%3A%20NumLeaves%20T%20%3D%201)%3A%20T%20%3D%20leaf%20%3A%3D%20by%20%7B%0D%0A%20%20induction%20T%20with%0D%0A%20%20%7C%20leaf%20%3D%3E%20%7B%0D%0A%20%20%20%20rfl%0D%0A%20%20%20%7D%0D%0A%20%20%7C%20node%20T2%20T3%20_%20%3D%3E%20%7B%0D%0A%20%20%20%20have%20h3%3A%20NumLeaves%20T2%20%2B%20NumLeaves%20T3%20%E2%89%A5%202%20%3A%3D%20Nat.add_le_add%20(BTsPosLeaves1%20T2)%20(BTsPosLeaves1%20T3)%0D%0A%20%20%20%20have%20h4%3A%20NumLeaves%20T2%20%2B%20NumLeaves%20T3%20%E2%89%A0%201%20%3A%3D%20%20Nat.ne_of_lt'%20h3%0D%0A%20%20%20%20exact%20(h4%20h).elim%0D%0A%20%20%7D%0D%0A%7D%0D%0A%0D%0Alemma%20SingletonLeaf2%20%3A%20%E2%88%80%20(T%3A%20BTWithNumLeaves%201)%2C%20T%20%3D%20%E2%9F%A8leaf%2C%20rfl%E2%9F%A9%20%3A%3D%20by%20%7B%0D%0A%20%20intro%20T%20%0D%0A%20%20exact%20Subtype.eq%20(SingletonLeaf%20T.val%20T.property)%0D%0A%7D%0D%0A%0D%0Alemma%20LeafInhabited%3A%20Inhabited%20(BTWithNumLeaves%201)%20%3A%3D%20%0D%0A%20%7B%20default%20%3A%3D%20%E2%9F%A8%20leaf%2C%20rfl%20%E2%9F%A9%7D%0D%0A%0D%0Alemma%20LeafSubsingleton%3A%20Subsingleton%20%20(BTWithNumLeaves%201)%20%3A%3D%20by%20%7B%0D%0A%20%20let%20Leaf%3A%20BTWithNumLeaves%201%20%3A%3D%20%E2%9F%A8leaf%2C%20rfl%E2%9F%A9%0D%0A%20%20exact%20(subsingleton_iff_forall_eq%20Leaf%20).mpr%20SingletonLeaf2%0D%0A%7D%0D%0A%0D%0Alemma%20LeafUnique%3A%20Unique%20(BTWithNumLeaves%201)%20%3A%3D%20%0D%0A%20%40Unique.mk'%20(BTWithNumLeaves%201)%20LeafInhabited%20%20LeafSubsingleton%0D%0A%0D%0Alemma%20LeafEquiv%3A%20(BTWithNumLeaves%201%20%E2%89%83%20Fin%201)%20%3A%3D%20%0D%0A%20%40Equiv.equivOfUnique%20(BTWithNumLeaves%201)%20(Fin%201)%20LeafUnique%20Fin.uniqueFinOne%0D%0A%0D%0Adef%20LeafFinite%3A%20Fintype%20(BTWithNumLeaves%201)%20%3A%3D%20--%20noncomputable%20%3A(%0D%0A%20%20Fintype.ofEquiv%20(Fin%201)%20(LeafEquiv.symm)\">here</a>.</p>\n<p>I wonder if the problem is this lemma where I use contradiction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">SingletonLeaf</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">:</span> <span class=\"n\">BT</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">NumLeaves</span> <span class=\"n\">T</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">):</span> <span class=\"n\">T</span> <span class=\"bp\">=</span> <span class=\"n\">leaf</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">induction</span> <span class=\"n\">T</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span>\n    <span class=\"n\">rfl</span>\n   <span class=\"o\">}</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"n\">T2</span> <span class=\"n\">T3</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span>\n    <span class=\"k\">have</span> <span class=\"n\">h3</span><span class=\"o\">:</span> <span class=\"n\">NumLeaves</span> <span class=\"n\">T2</span> <span class=\"bp\">+</span> <span class=\"n\">NumLeaves</span> <span class=\"n\">T3</span> <span class=\"bp\">≥</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.add_le_add</span> <span class=\"o\">(</span><span class=\"n\">BTsPosLeaves1</span> <span class=\"n\">T2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">BTsPosLeaves1</span> <span class=\"n\">T3</span><span class=\"o\">)</span>\n    <span class=\"k\">have</span> <span class=\"n\">h4</span><span class=\"o\">:</span> <span class=\"n\">NumLeaves</span> <span class=\"n\">T2</span> <span class=\"bp\">+</span> <span class=\"n\">NumLeaves</span> <span class=\"n\">T3</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>  <span class=\"n\">Nat.ne_of_lt'</span> <span class=\"n\">h3</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">h4</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n  <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>and if so if there's a way to prove this in a computable way.</p>",
        "id": 412908408,
        "sender_full_name": "Jair Taylor",
        "timestamp": 1705307904
    },
    {
        "content": "<p>If you're just trying to prove a theorem then you typically don't need to worry about whether things are computable or not.</p>",
        "id": 412908552,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705307973
    },
    {
        "content": "<p>That's true. I just find it more aesthetically pleasing if things are computable.</p>",
        "id": 412909451,
        "sender_full_name": "Jair Taylor",
        "timestamp": 1705308329
    },
    {
        "content": "<p>no I think that's not the issue, usage of classical logic is independent of whether things are <code>noncomputable</code></p>",
        "id": 412910516,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705308730
    },
    {
        "content": "<p>the way in which you prove a theorem will not impact <code>noncomputable</code></p>",
        "id": 412910575,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705308753
    },
    {
        "content": "<p>The problem is that you marked an <code>Equiv</code> as a <code>lemma</code> (<code>LeafEquiv</code> is data, it also needs to be computable), and the reason this is noncomputable is because you used <code>Equiv.equivOfUnique</code> which skips the construction of an inverse function</p>",
        "id": 412910819,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705308844
    },
    {
        "content": "<p>oh no, actually everything you used is computable already. You just mistakenly marked <code>LeafInhabited</code>, <code>LeafUnique</code>, and <code>LeafEquiv</code> as <code>lemma</code> instead of <code>def</code></p>",
        "id": 412911530,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705309094
    },
    {
        "content": "<p><code>#lint</code> will tell you about this</p>",
        "id": 412911570,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705309115
    },
    {
        "content": "<p>oh, nice! OK, that's a simple fix. Thanks so much.</p>",
        "id": 412912356,
        "sender_full_name": "Jair Taylor",
        "timestamp": 1705309410
    },
    {
        "content": "<p>Ah, but now another issue: in my proof of Fintype (BTWithNumLeaves n) I am seeing </p>\n<p><code>failed to compile definition, consider marking it as 'noncomputable' because it depends on 'Nat.strongInductionOn', and it does not have executable code</code></p>\n<p>So is there an alternative to Nat.strongInductionOn that is computable?</p>",
        "id": 412912924,
        "sender_full_name": "Jair Taylor",
        "timestamp": 1705309622
    },
    {
        "content": "<p>usually you can rewrite it as a well founded recursion, where the termination arguments correspond to uses of the inductive hypothesis</p>",
        "id": 412914519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705310270
    },
    {
        "content": "<p>OK, I will look into well founded recursion. Thank you!</p>",
        "id": 412915390,
        "sender_full_name": "Jair Taylor",
        "timestamp": 1705310628
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"674925\">Jair Taylor</span> <a href=\"#narrow/stream/113489-new-members/topic/Computable.20equivalence.20of.20types/near/412912924\">said</a>:</p>\n<blockquote>\n<p>Ah, but now another issue: in my proof of Fintype (BTWithNumLeaves n) I am seeing </p>\n<p><code>failed to compile definition, consider marking it as 'noncomputable' because it depends on 'Nat.strongInductionOn', and it does not have executable code</code></p>\n</blockquote>\n<p>Am I right in thinking this is a bug?</p>",
        "id": 412919025,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705311845
    },
    {
        "content": "<p>Maybe more a missing feature, I'd say.</p>",
        "id": 412919568,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705312017
    },
    {
        "content": "<p>kinda weird that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsWellFounded.fix#doc\">docs#IsWellFounded.fix</a> is computable while <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WellFounded.fix#doc\">docs#WellFounded.fix</a> isn't</p>",
        "id": 413004735,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1705339853
    },
    {
        "content": "<p>in fact, the former appears to be defined in terms of the latter so I'm not sure how that's possible</p>",
        "id": 413005052,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1705339980
    },
    {
        "content": "<p>There is some trickery in Std to define a computable <code>fix</code> and then set</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">csimp</span><span class=\"kd\">]</span> <span class=\"kn\">private</span> <span class=\"kd\">theorem</span> <span class=\"n\">fix_eq_fixC</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">fix</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">fixC</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Full details at <a href=\"https://github.com/leanprover/std4/blob/975b766b35f07e81fc34d66d026ad5bb2c1dbf45/Std/WF.lean#L10-L39\">https://github.com/leanprover/std4/blob/975b766b35f07e81fc34d66d026ad5bb2c1dbf45/Std/WF.lean#L10-L39</a></p>",
        "id": 413012725,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705343829
    },
    {
        "content": "<p>I'm curious if <span class=\"user-mention\" data-user-id=\"674925\">@Jair Taylor</span>'s computability problem would be fixed by switching from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.strongInductionOn#doc\">docs#Nat.strongInductionOn</a> to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.strong_induction_on#doc\">docs#Nat.strong_induction_on</a></p>\n<p>unless the fundamental problem is that it's a theorem and therefore can't be used to create data</p>",
        "id": 413023025,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1705349625
    },
    {
        "content": "<p>No, it's a definition.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Treefin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nz</span><span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">):</span> <span class=\"n\">Fintype</span> <span class=\"o\">(</span><span class=\"n\">BTWithNumLeaves</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">using</span> <span class=\"n\">Nat.strongInductionOn</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ind</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span> <span class=\"bp\">...</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>I wasn't familiar with strong_induction_on but I think I can't use it here since it's only for Prop. I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">when</span> <span class=\"n\">assigning</span> <span class=\"n\">motive</span>\n  <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ℕ</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:</span> <span class=\"n\">TypeLean</span> <span class=\"mi\">4</span>\n</code></pre></div>",
        "id": 413024238,
        "sender_full_name": "Jair Taylor",
        "timestamp": 1705350348
    },
    {
        "content": "<p>Sorry, I meant the issue being that <code>Nat.strongInductionOn</code> and <code>Nat.strong_induction_on</code> are theorems. But you're right about <code>Nat.strong_induction_on</code> only working for <code>Prop</code>... I didn't notice that difference, so I don't think it will help after all.</p>",
        "id": 413024836,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1705350601
    },
    {
        "content": "<p>I'll just add that creating data in tactic mode is generally a bad idea anyway (or at least it was in Lean 3)</p>",
        "id": 413025294,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1705350851
    },
    {
        "content": "<p>Oh I see. Actually, if I just copy the definition of strongInductionOn but change it from <code>theorem</code> to <code>def</code>,  that seems to resolve the issue!</p>",
        "id": 413026216,
        "sender_full_name": "Jair Taylor",
        "timestamp": 1705351420
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/stream/113489-new-members/topic/Computable.20equivalence.20of.20types/near/413025294\">said</a>:</p>\n<blockquote>\n<p>I'll just add that creating data in tactic mode is generally a bad idea anyway (or at least it was in Lean 3)</p>\n</blockquote>\n<p>Is that so? Depends on what you do; I'd expect some set of tactics (<code>apply</code>, <code>cases</code>, <code>induction</code> etc.) to be fairly innocent</p>",
        "id": 413028096,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705352537
    },
    {
        "content": "<p>Often a recursive definition is easier to work with than <code>strong_induction_on</code>. (As Mario already said earlier)</p>",
        "id": 413028179,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705352605
    },
    {
        "content": "<p>It's often very handy to assemble large terms with <code>refine</code> in tactic mode; in Lean 3, sometimes it was ever necessary for better performance</p>",
        "id": 413028284,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705352651
    },
    {
        "content": "<p>ah, I see</p>",
        "id": 413028395,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1705352721
    }
]