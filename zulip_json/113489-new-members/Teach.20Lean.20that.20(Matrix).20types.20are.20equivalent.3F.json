[
    {
        "content": "<p>I am working with a lot of matrices, and one problem I am continuously running into is that I need to <code>reindex</code> the matrices I have to give them the correct types. This was fine with a single reindex that I defined, but now, I need to keep track of 3 types of reindexes, and it is growing difficult to manage.</p>\n<p>I was wondering if it is possible to teach Lean that these types are identical so reindex is not necessary anymore, or if there is a better way to apply reindex, so I only have one single custom <code>reindex</code> command. Here's some code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Matrix.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Matrix.Notation</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Matrix.Kronecker</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Complex.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Matrix</span>\n<span class=\"kn\">open</span> <span class=\"n\">Kronecker</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- Num of qubits</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">QCount</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">nMatrix</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">QCount</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">QCount</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">nRMatrix</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">QCount</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">QCount</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">mnMatrix</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">QCount</span> <span class=\"n\">m</span> <span class=\"bp\">×</span> <span class=\"n\">QCount</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">QCount</span> <span class=\"n\">m</span> <span class=\"bp\">×</span> <span class=\"n\">QCount</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">QCount_mul_QCount</span> <span class=\"o\">{</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">QCount</span> <span class=\"n\">m</span> <span class=\"bp\">×</span> <span class=\"n\">QCount</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"n\">QCount</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">QCount</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.pow_add</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">finProdFinEquiv</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">QCount_mul_one</span> <span class=\"o\">{</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">QCount</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">≃</span> <span class=\"n\">QCount</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">QCount</span><span class=\"o\">]</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"sd\">/-- Reindex a circuit matrix to Fin 2 ^ n × Fin 2 ^ n dimensions -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">reindex</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">mnMatrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nMatrix</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Matrix.reindex</span> <span class=\"n\">QCount_mul_QCount</span> <span class=\"n\">QCount_mul_QCount</span> <span class=\"n\">A</span>\n\n<span class=\"sd\">/-- Deal with * 1 in the matrix dimensions -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">reindex'</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">nMatrix</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">nMatrix</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Matrix.reindex</span> <span class=\"n\">QCount_mul_one</span> <span class=\"n\">QCount_mul_one</span> <span class=\"n\">A</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">Fin_mul_Fin_one</span> <span class=\"o\">{</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">1</span> <span class=\"bp\">×</span> <span class=\"n\">Fin</span> <span class=\"n\">m</span> <span class=\"bp\">≃</span> <span class=\"n\">Fin</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Equiv.uniqueProd</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- This one is from trying to prove that (1 : Nat) ⊗ₖ M = M... -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">reindex''</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">1</span> <span class=\"bp\">×</span> <span class=\"n\">Fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">1</span> <span class=\"bp\">×</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Matrix.reindex</span> <span class=\"n\">Fin_mul_Fin_one</span> <span class=\"n\">Fin_mul_Fin_one</span> <span class=\"n\">M</span>\n</code></pre></div>\n<p>As can be seen, I already have three different reindex definitions that I need to keep track of, and proving they work together with one another becomes a terrible mess as it grows exponentially.</p>",
        "id": 437209229,
        "sender_full_name": "Jake Jongejans",
        "timestamp": 1714980740
    },
    {
        "content": "<p>Can you make Lean's more flexible index system work for you rather than just following the books who will insist on matrices being labelled by {1,...,n}?</p>",
        "id": 437224404,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1714987051
    },
    {
        "content": "<p>I came to my abbreviations (nMatrix, Count, etc.) based on different things I tried making. Working with the kronecker product gives back different types of matrices based on its input, and the current way I am handling it seemed the easiest to me. <br>\nKronecker product example: given <code>A B : Matrix (Fin n) (Fin n) \\C</code>, <code>kroneckerMap A B</code> has the type <code>Matrix ((Fin n) x (Fin n)) ((Fin n) x (Fin n)) \\C)</code> instead of having <code>(Fin (n * n))</code> or <code>(Fin (n ^ 2))</code>. When I am working with a tensor power, this became impossible to manage, because for each <code>n</code>, the type was different. Hence the reindex, but that only handles a single equivalence in <code>Fin</code> types. <br>\nI am not sure what I could do different to utilise the index system from Lean in a better way. Do I need to change out my tensor power to not be a recursive kroneckerMap? Am I missing something else?</p>",
        "id": 437230790,
        "sender_full_name": "Jake Jongejans",
        "timestamp": 1714989513
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"691918\">Jake Jongejans</span> <a href=\"#narrow/stream/113489-new-members/topic/Teach.20Lean.20that.20.28Matrix.29.20types.20are.20equivalent.3F/near/437230790\">said</a>:</p>\n<blockquote>\n<p>given <code>A B : Matrix (Fin n) (Fin n) ℂ </code>kroneckerMap A B<code> has the type </code>Matrix ((Fin n) x (Fin n)) ((Fin n) x (Fin n)) ℂ instead of having <code>(Fin (n * n))</code> or <code>(Fin (n ^ 2))</code>.</p>\n</blockquote>\n<p>Can you simply not try to index by <code>Fin (n * n)</code>?</p>",
        "id": 437232077,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1714990002
    },
    {
        "content": "<p>Note that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.kronecker#doc\">docs#Matrix.kronecker</a> takes in more general things than <code>A B : Matrix (Fin n) (Fin n) ℂ</code></p>",
        "id": 437232246,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1714990083
    },
    {
        "content": "<p>I could try, but I still think the kronecker product will mess with the dimensions of the matrix type, because it always handles it like so: given <code>(A : Matrix (Fin a1) (Fin a2) \\C) (B : Matrix (Fin b1) (Fin b2) \\C)</code>we get <code>kroneckerMap A B</code> as type <code>Matrix ((Fin a1) x (Fin b1)) ((Fin a2) x (Fin b2)) \\C</code>, and I'd still need to use a reindex to get it to <code>Matrix (Fin (a1 * b1)) (Fin (a2 * b2)) \\C</code>.</p>\n<p>One place I was struggling is here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Matrix.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Matrix.Notation</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Matrix.Kronecker</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Complex.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Matrix</span>\n<span class=\"kn\">open</span> <span class=\"n\">Kronecker</span>\n<span class=\"kn\">open</span> <span class=\"n\">Complex</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">kronecker_natOne</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₖ</span> <span class=\"n\">M</span> <span class=\"bp\">=</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"c1\">-- type mismatch</span>\n<span class=\"c1\">--    M</span>\n<span class=\"c1\">-- has type</span>\n<span class=\"c1\">--    Matrix A B ℂ : Type</span>\n<span class=\"c1\">-- but is expected to have type</span>\n<span class=\"c1\">--    Matrix (1 × A) (1 × B) ℂ : Type</span>\n</code></pre></div>\n<p>I am trying to prove that kronecker with a 1 that is just a natural number (i.e. Matrix (Fin 1) (Fin 1)) with any matrix is equal to that matrix. but I cannot because of the type change.</p>",
        "id": 437235875,
        "sender_full_name": "Jake Jongejans",
        "timestamp": 1714991778
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"691918\">Jake Jongejans</span> <a href=\"#narrow/stream/113489-new-members/topic/Teach.20Lean.20that.20.28Matrix.29.20types.20are.20equivalent.3F/near/437235875\">said</a>:</p>\n<blockquote>\n<p>it always handles it like so: given <code>(A : Matrix (Fin a1) (Fin a2) ℂ (B : Matrix (Fin b1) (Fin b2) ℂ</code> get <code>kroneckerMap A B</code> as type <code>Matrix ((Fin a1) x (Fin b1)) ((Fin a2) x (Fin b2)) ℂ</code></p>\n</blockquote>\n<p>No it doesn't? Can you give a concrete example where this happens?</p>",
        "id": 437236457,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1714992067
    },
    {
        "content": "<p>The last code I sent shows the problem I am having—I updated it to be ever more clear.  I'm getting <code>Matrix (1 x A) (1 x B) \\C</code> instead of <code>Matrix A B \\C</code>.</p>",
        "id": 437237150,
        "sender_full_name": "Jake Jongejans",
        "timestamp": 1714992337
    },
    {
        "content": "<p>(A misreading of this thread inspired me to make <a href=\"https://github.com/leanprover-community/mathlib4/pull/12703\">#12703</a>)</p>",
        "id": 437240985,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714994023
    },
    {
        "content": "<p>Here's the working version of your statement:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Matrix.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Matrix.Notation</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Matrix.Kronecker</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Complex.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Matrix</span>\n<span class=\"kn\">open</span> <span class=\"n\">Kronecker</span>\n<span class=\"kn\">open</span> <span class=\"n\">Complex</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">kronecker_natOne</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">Unit</span> <span class=\"n\">Unit</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₖ</span> <span class=\"n\">M</span> <span class=\"bp\">=</span> <span class=\"n\">reindex</span> <span class=\"o\">(</span><span class=\"n\">Equiv.punitProd</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">Equiv.punitProd</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">one_kronecker</span><span class=\"o\">]</span>\n  <span class=\"n\">ext</span> <span class=\"o\">⟨⟨⟩,</span> <span class=\"n\">i</span><span class=\"o\">⟩</span> <span class=\"o\">⟨⟨⟩,</span> <span class=\"n\">j</span><span class=\"o\">⟩</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">blockDiagonal</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 437241852,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714994396
    },
    {
        "content": "<p>Or leaving it with <code>Fin 1</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">kronecker_natOne</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₖ</span> <span class=\"n\">M</span> <span class=\"bp\">=</span>\n      <span class=\"n\">Matrix.reindex</span> <span class=\"o\">(</span><span class=\"n\">Equiv.uniqueProd</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">Equiv.uniqueProd</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 437241983,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714994443
    },
    {
        "content": "<p>Or generalized to both:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">kronecker_natOne</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Unique</span> <span class=\"n\">U</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">U</span> <span class=\"n\">U</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₖ</span> <span class=\"n\">M</span> <span class=\"bp\">=</span>\n      <span class=\"n\">Matrix.reindex</span> <span class=\"o\">(</span><span class=\"n\">Equiv.uniqueProd</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">Equiv.uniqueProd</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 437242101,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714994507
    },
    {
        "content": "<p>I think that even if there is a better indexing set for these matrices than (bad-looking choices such as) <code>Fin (a * b)</code> (and there may or may not be), you are probably still going to run into trouble identifying <code>(X x Y) x Z</code> with <code>X x (Y x Z)</code> and <code>Fin 1 x X</code> with <code>X</code> (the \"monoid laws\" for the monoidal category of finite types)</p>",
        "id": 437246605,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1714996326
    },
    {
        "content": "<p>I agree, Kevin. I am trying to figure out how to avoid these troubles. Any suggestions?</p>",
        "id": 437246992,
        "sender_full_name": "Jake Jongejans",
        "timestamp": 1714996500
    },
    {
        "content": "<p>I think the actual missing lemma here is about <code>blockDiagonal</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">blockDiagonal_unique</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">U</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Unique</span> <span class=\"n\">U</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">Matrix</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">α</span><span class=\"o\">]:</span>\n  <span class=\"n\">blockDiagonal</span> <span class=\"n\">d</span> <span class=\"bp\">=</span>\n    <span class=\"n\">Matrix.reindex</span> <span class=\"o\">(</span><span class=\"n\">Equiv.prodUnique</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">Equiv.prodUnique</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">default</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ua</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">ub</span><span class=\"o\">⟩</span>\n  <span class=\"n\">obtain</span> <span class=\"n\">rfl</span> <span class=\"o\">:=</span> <span class=\"n\">Subsingleton.elim</span> <span class=\"n\">ua</span> <span class=\"n\">default</span>\n  <span class=\"n\">obtain</span> <span class=\"n\">rfl</span> <span class=\"o\">:=</span> <span class=\"n\">Subsingleton.elim</span> <span class=\"n\">ub</span> <span class=\"n\">default</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">kronecker_natOne</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Unique</span> <span class=\"n\">U</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">U</span> <span class=\"n\">U</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₖ</span> <span class=\"n\">M</span> <span class=\"bp\">=</span>\n      <span class=\"n\">Matrix.reindex</span> <span class=\"o\">(</span><span class=\"n\">Equiv.uniqueProd</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">Equiv.uniqueProd</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">one_kronecker</span><span class=\"o\">,</span> <span class=\"n\">blockDiagonal_unique</span><span class=\"o\">]</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 437247261,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714996594
    },
    {
        "content": "<p>I think one answer here might be a <code>prod_simp%</code> helper that automatically glues <code>uniqueProd</code>, <code>prodComm</code>, <code>prodAssoc</code> etc together into the <code>reindex</code> args, but this is still painful when working with rewrites</p>",
        "id": 437247720,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714996762
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"691918\">@Jake Jongejans</span> This is one of those fundamental issues with dependent types, and unfortunately we don't have any way to make association come for free.</p>\n<p>However, we do have some automation here and there to help out. For example, there's <code>prod_assoc%</code>, which automatically constructs equivalences for any reassociation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"n\">C</span> <span class=\"bp\">×</span> <span class=\"n\">D</span> <span class=\"bp\">≃</span> <span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">×</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"n\">prod_assoc</span><span class=\"bp\">%</span>\n</code></pre></div>",
        "id": 437247738,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714996771
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> Should we make <code>prod_assoc%</code> be aware of <code>Unit</code>? Or <code>[Unique _]</code> in general? Or do you think that would be out of scope?)</p>",
        "id": 437247967,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714996841
    },
    {
        "content": "<p>I see, so there's no way of solving this outright. I will have to look into these helpers, see if they can make my life less of a pain. Any place where I can find out more on <code>prod_simp%</code> and <code>prod_assoc%</code>? I guess I can throw those terms in Loogle.</p>",
        "id": 437248329,
        "sender_full_name": "Jake Jongejans",
        "timestamp": 1714996962
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"691918\">Jake Jongejans</span> <a href=\"#narrow/stream/113489-new-members/topic/Teach.20Lean.20that.20.28Matrix.29.20types.20are.20equivalent.3F/near/437246992\">said</a>:</p>\n<blockquote>\n<p>I agree, Kevin. I am trying to figure out how to avoid these troubles. Any suggestions?</p>\n</blockquote>\n<p>These troubles really are there, and to make proofs rigorous you might have to deal with these issues. Maybe you need explicit reindex maps corresponding to <code>one_mul</code>, <code>mul_one</code>, <code>mul_comm</code> and <code>mul_assoc</code>, but these bijections will be there already.</p>",
        "id": 437248452,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1714997014
    },
    {
        "content": "<p><code>prod_simp%</code> doesn't exist, Eric was just saying \"wouldn't it be nice if it did\"</p>",
        "id": 437250623,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714997845
    },
    {
        "content": "<p>For <code>prod_assoc%</code>, it's probably better looking at Mathlib/Tactic/ProdAssoc.lean and reading the documentation, and looking at test/ProdAssoc.lean to see examples</p>",
        "id": 437250801,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714997901
    },
    {
        "content": "<p>And welcome to the world of non-strict symmetric monoidal categories! It's known that there's a coherence theorem here, which is essentially that there's just one obvious map when reassociating and canceling \"monoidal units\" (types with one element) when dealing with cartesian products.</p>",
        "id": 437251820,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714998293
    },
    {
        "content": "<p>There are some techniques for dealing with associativity, but I don't know how well they'd work in practice for matrices. For example, rather than types, you work with functors. Then you can get defeq associativity:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">F.lift</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">m</span> <span class=\"bp\">×</span> <span class=\"n\">r</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">F.prod</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"n\">m</span> <span class=\"bp\">∘</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">F.toType</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">m</span> <span class=\"n\">Unit</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"kt\">Type</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">F.lift</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">35</span> <span class=\"s2\">\" ×f \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">F.prod</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">Nat</span> <span class=\"bp\">×</span><span class=\"n\">f</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">×</span><span class=\"n\">f</span> <span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toType</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Nat</span> <span class=\"bp\">×</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">Nat</span> <span class=\"bp\">×</span><span class=\"n\">f</span> <span class=\"n\">Nat</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toType</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Maybe this would be a workable definition of a matrix? I don't know:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Matrix'</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>In any case, this would be going in a completely new direction from what's already there in the library.</p>",
        "id": 437253508,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714998902
    },
    {
        "content": "<p>Ah, non-strict symmetric monoidal categories. I will do some reading on that, and see how I can perhaps implement it and utilise it. Stepping away from mathlib will be a big loss, though. Thank you for the suggested code!</p>",
        "id": 437254996,
        "sender_full_name": "Jake Jongejans",
        "timestamp": 1714999460
    },
    {
        "content": "<p>Could you share what your original goal is here, and perhaps an equation from it that brought you to this pain?</p>",
        "id": 437255623,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714999720
    },
    {
        "content": "<p>Sure, though it's quite some code in separate files. Would you like me to condense it and remove unnecessary code, or would it be better to set my repository to public and share the link, and then pinpoint where I am struggling?</p>",
        "id": 437256031,
        "sender_full_name": "Jake Jongejans",
        "timestamp": 1714999836
    },
    {
        "content": "<p>I mean maybe just share a line or two of LaTeX (either in <code>$$ $$</code>s or in a screenshot) that captures the sort of equation where you run into trouble</p>",
        "id": 437256108,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714999867
    },
    {
        "content": "<p>Ah, currently I am trying to create a set of theorems that help with formalising quantum algorithms (basic ones for now, like Bernstein-Vazirani), so it's less of a single goal and more of a family of theorems and definitions I am trying to create, so I am not quite capable of giving a single \"goal\". <br>\nI am incorporating definitions such as <code>pow_kronecker</code> (a tensor power), and <code>qapply</code> that allows for applying a gate (or circuit, at some point) to certain qubits. I haven't got the logic of the last part quite right, yet, though. <br>\nThe idea is to build up a library of gates and circuits that can be applied, to define the working of algorithms, and to formally prove them through Lean. In the grand scheme of things, Quantum Hoare Logic would be implemented, but I have insufficient time to implement that, in my thesis. </p>\n<p>Anyhow, one issue right now is, where the <code>kronecker_natOne</code> does not recognise the 1 I get from <code>pow_kronecker' 0 M</code>. But in general, the reindexing and different forms matrices have been difficult to work with.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">pow_kronecker'</span> <span class=\"o\">{</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">nMatrix</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nMatrix</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">reindex</span> <span class=\"o\">(</span><span class=\"n\">pow_kronecker'</span> <span class=\"n\">n</span> <span class=\"n\">M</span> <span class=\"bp\">⊗ₖ</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">pow_kronecker_zero'</span> <span class=\"o\">{</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">nMatrix</span> <span class=\"n\">m</span> <span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">pow_kronecker'</span> <span class=\"mi\">0</span> <span class=\"n\">M</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">pow_kronecker'</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">pow_kronecker_one'</span> <span class=\"o\">{</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">nMatrix</span> <span class=\"n\">m</span> <span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Circuits.reindex'</span> <span class=\"o\">(</span><span class=\"n\">pow_kronecker'</span> <span class=\"mi\">1</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">pow_kronecker'</span><span class=\"o\">,</span> <span class=\"n\">pow_kronecker_zero'</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- This next rewrite fails, because the type of my 1 and its 1 is different.</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">kronecker_natOne</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">one_kronecker_one</span><span class=\"o\">,</span> <span class=\"n\">smul_reindex</span><span class=\"o\">,</span> <span class=\"n\">reindex_one</span><span class=\"o\">]</span>\n  <span class=\"n\">norm_num</span>\n</code></pre></div>\n<p>Does this answer your request? I am happy to offer more information.</p>",
        "id": 437258445,
        "sender_full_name": "Jake Jongejans",
        "timestamp": 1715000738
    },
    {
        "content": "<p>For that particular example it would be tempting to use</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">powKronecker</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">k</span> <span class=\"bp\">→</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">k</span> <span class=\"bp\">→</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">fm</span> <span class=\"n\">fn</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">((</span><span class=\"n\">List.finRange</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">fm</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fn</span> <span class=\"n\">i</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">prod</span>\n</code></pre></div>",
        "id": 437259797,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715001217
    },
    {
        "content": "<p>But I think ultimately you hit the same issue</p>",
        "id": 437259914,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715001249
    },
    {
        "content": "<p>At some point, I also think I will come across a wall again. The mention of the monoidal categories did make me wonder whether my approach to the problem is wrong, but I couldn't say right now.</p>",
        "id": 437260591,
        "sender_full_name": "Jake Jongejans",
        "timestamp": 1715001528
    },
    {
        "content": "<p>Hey, it's me again. I hope reviving this thread is fine. </p>\n<p>I am trying to understand a bit how to utilise these functors properly, using Kyle's code, and I am trying to implement that into basically a shadow version of the Mathlib Matrix Basic file. Because the matrix now isn't just a function anymore with two variables and one output, I am quite lost as I don't know how to retrieve any value from this new matrix shape anymore. <br>\nI thought I could do, given <code>M : Matrix' m n a</code>, <code>M Unit Unit</code> to get the matrix at its current size, then <code>M Unit Unit i j</code> for the <code>i</code> and <code>j</code> index of the matrix, but it keeps complaining about types. Maybe a small code example (note I renamed to Matrix without '):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"n\">of</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">Unit</span> <span class=\"n\">Unit</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This gives me the following error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">M</span> <span class=\"n\">Unit</span> <span class=\"n\">Unit</span> <span class=\"n\">I</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">I</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">m</span> <span class=\"n\">Unit</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n</code></pre></div>\n<p>Maybe I am missing something trivial but I have tried quite a few things already. Perhaps there is another part of Mathlib that utilises functors more? That would be great to study. Any help is greatly appreciated!</p>",
        "id": 438213095,
        "sender_full_name": "Jake Jongejans",
        "timestamp": 1715548950
    },
    {
        "content": "<p>An <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> would be helpful.</p>\n<p>Here's a guess:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"n\">of</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 438213327,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715549256
    },
    {
        "content": "<p>Or in other words,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 438213391,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715549288
    },
    {
        "content": "<p>I hope this functor idea doesn't lead you too far down a dead end!</p>",
        "id": 438213434,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1715549363
    }
]