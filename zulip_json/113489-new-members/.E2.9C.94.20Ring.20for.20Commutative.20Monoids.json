[
    {
        "content": "<p>Is there a tactic which takes two expressions in a commutative Monoid and using associativity and commutativity can detect that the two expressions are equal?</p>",
        "id": 421591103,
        "sender_full_name": "Omar Mohsen",
        "timestamp": 1707979196
    },
    {
        "content": "<p>Isn't there a simp call that should do this? [Assoc,comm,right_comm] or something like that?</p>",
        "id": 421591834,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1707979593
    },
    {
        "content": "<p>Sounds like you are describing <a href=\"https://github.com/haruhisa-enomoto/mathlib4-all-tactics/blob/main/all-tactics.md#abel-1\"><code>abel</code></a>?</p>",
        "id": 421592007,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1707979690
    },
    {
        "content": "<p>Thanks, thats exactly what I needed.</p>",
        "id": 421592064,
        "sender_full_name": "Omar Mohsen",
        "timestamp": 1707979730
    },
    {
        "content": "<p>I have to say though abel doesn't really work very well. I have the equality</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x'.2</span> <span class=\"bp\">*</span> <span class=\"n\">y'.1</span> <span class=\"bp\">*</span> <span class=\"n\">k'</span> <span class=\"bp\">*</span> <span class=\"n\">x.2</span> <span class=\"bp\">*</span> <span class=\"n\">y.1</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">x.2</span> <span class=\"bp\">*</span> <span class=\"n\">x'.2</span> <span class=\"bp\">*</span> <span class=\"n\">y.1</span> <span class=\"bp\">*</span> <span class=\"n\">y'.1</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">*</span> <span class=\"n\">k'</span>\n</code></pre></div>\n<p>in a commutative monoid which abel fails to detect.</p>",
        "id": 421593285,
        "sender_full_name": "Omar Mohsen",
        "timestamp": 1707980465
    },
    {
        "content": "<p>Perhaps the issue is that it only works for additive monoids?</p>",
        "id": 421593467,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1707980600
    },
    {
        "content": "<p>Hmm, yes, seems that's an issue, I'll add it to the tactic wishlist.</p>",
        "id": 421593608,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1707980682
    },
    {
        "content": "<p>You are right that's the issue. Thanks !</p>",
        "id": 421593891,
        "sender_full_name": "Omar Mohsen",
        "timestamp": 1707980848
    },
    {
        "content": "<p>For multiplicative monoids, I think Ruben's suggestion is the way to go.</p>",
        "id": 421594028,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707980923
    },
    {
        "content": "<p>I did try his method. It simplifies the expression using assoc but it doesn't seem to be smart enough to reorder the terms even when I add commutativity assumption</p>",
        "id": 421594194,
        "sender_full_name": "Omar Mohsen",
        "timestamp": 1707981022
    },
    {
        "content": "<p>Abel works fine though once I changed all monoids to additive monoids</p>",
        "id": 421594288,
        "sender_full_name": "Omar Mohsen",
        "timestamp": 1707981096
    },
    {
        "content": "<p>Exactly what simp call did you use? You need more than assoc and comm -- you also need mul_right_comm</p>",
        "id": 421594293,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707981099
    },
    {
        "content": "<p>(see the algorithm world levels of the natural number game for an explanation)</p>",
        "id": 421594367,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707981127
    },
    {
        "content": "<p>I am using this one simp [add_assoc,add_comm,add_right_comm]. I might be using it incorrectly but it is incapable of detecting this  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x.1</span> <span class=\"bp\">+</span> <span class=\"n\">z.2</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">y.2</span> <span class=\"bp\">+</span> <span class=\"n\">k'</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">y.1</span> <span class=\"bp\">+</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">x.1</span> <span class=\"bp\">+</span> <span class=\"n\">y.2</span> <span class=\"bp\">+</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">y.1</span> <span class=\"bp\">+</span> <span class=\"n\">z.2</span> <span class=\"bp\">+</span> <span class=\"n\">k'</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 421594471,
        "sender_full_name": "Omar Mohsen",
        "timestamp": 1707981225
    },
    {
        "content": "<p>Oh I am surprised at this. Do you have a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> repro?</p>",
        "id": 421594634,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707981314
    },
    {
        "content": "<p>Does <code>simp only...</code> help?</p>",
        "id": 421594680,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707981351
    },
    {
        "content": "<p>No. My example is very short. I just started </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">Semigroup</span>\n<span class=\"k\">#print</span> <span class=\"n\">AddAddCommMonoid</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">Semigroup</span>\n<span class=\"kn\">section</span> <span class=\"n\">AddCommMonoid</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"o\">)</span> <span class=\"bp\">↦</span>  <span class=\"o\">((</span><span class=\"n\">x.1</span><span class=\"o\">,</span> <span class=\"n\">y.2</span><span class=\"o\">):</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n<span class=\"kd\">def</span> <span class=\"n\">Grothendieck_Completion_Setoid</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span>  <span class=\"n\">where</span>\n  <span class=\"n\">r</span><span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">↦</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span><span class=\"o\">,</span>  <span class=\"n\">x.1</span> <span class=\"bp\">+</span> <span class=\"n\">y.2</span> <span class=\"bp\">+</span> <span class=\"n\">k</span><span class=\"bp\">=</span> <span class=\"n\">x.2</span> <span class=\"bp\">+</span> <span class=\"n\">y.1</span> <span class=\"bp\">+</span> <span class=\"n\">k</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">refl</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid.add_comm</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"n\">use</span> <span class=\"mi\">1</span>\n  <span class=\"n\">symm</span><span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"n\">hk</span><span class=\"o\">⟩</span> <span class=\"bp\">;</span> <span class=\"n\">use</span> <span class=\"n\">k</span><span class=\"bp\">;</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid.add_comm</span> <span class=\"n\">y.2</span> <span class=\"n\">x.1</span><span class=\"o\">,</span><span class=\"n\">hk</span><span class=\"o\">,</span><span class=\"n\">AddCommMonoid.add_comm</span> <span class=\"n\">x.2</span> <span class=\"n\">_</span><span class=\"o\">]</span>\n  <span class=\"n\">trans</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n          <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">h</span> <span class=\"n\">h'</span><span class=\"bp\">;</span> <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"n\">hk</span><span class=\"o\">⟩</span><span class=\"bp\">;</span><span class=\"n\">rcases</span> <span class=\"n\">h'</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">k'</span><span class=\"o\">,</span><span class=\"n\">h'k</span><span class=\"o\">⟩</span><span class=\"bp\">;</span><span class=\"n\">use</span> <span class=\"n\">y.2</span><span class=\"bp\">+</span><span class=\"n\">k'</span><span class=\"bp\">+</span><span class=\"o\">(</span><span class=\"n\">y.1</span><span class=\"bp\">+</span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_assoc</span> <span class=\"n\">x.2</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span><span class=\"bp\">←</span> <span class=\"n\">add_assoc</span> <span class=\"n\">z.1</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span><span class=\"bp\">←</span> <span class=\"n\">add_assoc</span> <span class=\"n\">z.1</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span><span class=\"n\">add_comm</span> <span class=\"n\">z.1</span> <span class=\"n\">_</span><span class=\"o\">,</span><span class=\"bp\">←</span> <span class=\"n\">h'k</span><span class=\"o\">,</span>\n           <span class=\"n\">add_comm</span> <span class=\"o\">(</span><span class=\"n\">y.1</span><span class=\"bp\">+</span><span class=\"n\">z.2</span><span class=\"bp\">+</span><span class=\"n\">k'</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span><span class=\"bp\">←</span> <span class=\"n\">add_assoc</span> <span class=\"n\">x.2</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span><span class=\"bp\">←</span> <span class=\"n\">add_assoc</span> <span class=\"n\">x.2</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span><span class=\"bp\">←</span> <span class=\"n\">hk</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"o\">,</span><span class=\"n\">add_right_comm</span><span class=\"o\">,</span><span class=\"n\">add_assoc</span><span class=\"o\">]</span>\n  <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 421594783,
        "sender_full_name": "Omar Mohsen",
        "timestamp": 1707981401
    },
    {
        "content": "<p><a href=\"https://adam.math.hhu.de/#/g/leanprover-community/nng4/world/Algorithm/level/3\">https://adam.math.hhu.de/#/g/leanprover-community/nng4/world/Algorithm/level/3</a></p>\n<p>Oh it's maybe <code>add_left_comm</code> you need, not <code>add_right_comm</code>?</p>",
        "id": 421594842,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707981455
    },
    {
        "content": "<p>Ok that solves that part (thanks a lot). Do you have any suggestion how to make simp efficiently use equality of expressions in my example instead of painfully using assoc and comm and rw and then at the end use simp?</p>",
        "id": 421595103,
        "sender_full_name": "Omar Mohsen",
        "timestamp": 1707981611
    },
    {
        "content": "<p>Oops, sorry for the misdirection</p>",
        "id": 421595202,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1707981697
    },
    {
        "content": "<p>Can you edit the post and use <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a> ? That'll make it much easier to read</p>",
        "id": 421595223,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707981714
    },
    {
        "content": "<p>We have this construction in mathlib already by the way, you don't need to rewrite it. It's just the localisation of a commutative monoid at itself</p>",
        "id": 421595463,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707981855
    },
    {
        "content": "<p><code>rw[AddCommMonoid.add_comm _ _]</code> can probably just be <code>rw [add_comm]</code></p>",
        "id": 421595662,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707981990
    },
    {
        "content": "<p><code>intro ... ; rcases</code> can be done in one tactic with <code>rintro</code></p>",
        "id": 421595736,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707982047
    },
    {
        "content": "<p>I am pleasantly surprised. I never noticed that this construction is just a localization process.</p>",
        "id": 421596092,
        "sender_full_name": "Omar Mohsen",
        "timestamp": 1707982272
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690437\">Omar Mohsen</span> has marked this topic as resolved.</p>",
        "id": 421596121,
        "sender_full_name": "Notification Bot",
        "timestamp": 1707982293
    },
    {
        "content": "<p>The transitivity proof appears to be <a href=\"https://github.com/leanprover-community/mathlib4/blob/8920fa9680289e6bbfeb8c3f8b8c9cc63d7e862f/Mathlib%2FGroupTheory%2FMonoidLocalization.lean#L173-L175\">here</a> in mathlib and it's perhaps even more messy than yours</p>",
        "id": 421596792,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707982673
    }
]