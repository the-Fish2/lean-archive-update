[
    {
        "content": "<p>Hi, I just had a quick question about this excerpt from chapter 2 of Mathematics in Lean (page 12): <br>\n<a href=\"/user_uploads/3121/9hQMQzsfb51MO76wdPK4mfzt/image.png\">image.png</a><br>\nthe comment about this theorem is \"we had to use the annotation (-0 : R) instead of 0 because without specifying R it is impossible for Lean to infer which 0 we have in mind, and by default it would be interpreted as a natural number.\"</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/9hQMQzsfb51MO76wdPK4mfzt/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/9hQMQzsfb51MO76wdPK4mfzt/image.png\"></a></div><p>I am not sure I quite understand what this means. We use 0 everywhere in other theorems without specifying which 0 we are talking about; for instance in a theorem right above: <br>\n<a href=\"/user_uploads/3121/We_2bQF0kBZbNQS9af5sM2Jy/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/We_2bQF0kBZbNQS9af5sM2Jy/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/We_2bQF0kBZbNQS9af5sM2Jy/image.png\"></a></div><p>My hunch is that in this other theorem, for instance, the type of 0 can be inferred from that of a and b; they're elements of some ring R, so Lean can identify on its own that this 0 must be the 0 from the ring, while in the first theorem, there's no way for it to make that inferrence. Is this correct?</p>",
        "id": 438027442,
        "sender_full_name": "VayusElytra",
        "timestamp": 1715365315
    },
    {
        "content": "<p>That's right, in the other example it's because Lean knows the type of the left side of the <code>=</code> sign so it therefore knows <code>0</code> on the right side also must be <code>0 : R</code>.</p>",
        "id": 438028567,
        "sender_full_name": "Julian Berman",
        "timestamp": 1715365818
    },
    {
        "content": "<p>Whereas if you just have <code>0 = 0</code> or <code>-0 = 0</code> then Lean has no information and therefore will conservatively assume that's an equality of natural numbers.</p>",
        "id": 438028646,
        "sender_full_name": "Julian Berman",
        "timestamp": 1715365865
    },
    {
        "content": "<p>Thank you! That makes complete sense.</p>",
        "id": 438187111,
        "sender_full_name": "VayusElytra",
        "timestamp": 1715522786
    },
    {
        "content": "<p>I'll write this here again since I am not sure what the etiquette is regarding opening new topics. I am slightly confused by this excerpt from Mathematics in Lean, page 12 again: </p>\n<p><a href=\"/user_uploads/3121/jr2DG0_iyoh_csdGsP5jQUdK/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/jr2DG0_iyoh_csdGsP5jQUdK/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/jr2DG0_iyoh_csdGsP5jQUdK/image.png\"></a></div><p>Q1) It seems to suggest that a - b = a + (-b) is not a definition in Lean's implementation of rings. This is very strange to me; I have only ever seen the symbol \"-\" in rings be defined by that equality. So how is it defined in Lean then? </p>\n<p>Q2) The code below \"On the real numbers, it is defined that way\" is surely meant to bring attention to the fact that the \"by\" is not necessary here, but I'm unsure why. What does by actually do, and when is it necessary?</p>",
        "id": 438187729,
        "sender_full_name": "VayusElytra",
        "timestamp": 1715523480
    },
    {
        "content": "<p>Is a group a set with a multiplication? Or is it a set with a multiplication and an inverse and an identity? There are lots of different ways to set up mathematical objects. In Lean, for reasons which are essentially not mathematical, a ring (and indeed also an additive group) by definition has a subtraction and a negation, and an axiom saying they're related in the usual way. It's \"to avoid diamonds\".</p>",
        "id": 438188061,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1715523782
    },
    {
        "content": "<p>I think one message here is that mathematicians might want to optimise for as few definitions as possible, and then make the rest from what you have, and in general in Lean something like the exact opposite is true, because you get better definitional equalities that way.</p>",
        "id": 438188166,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1715523894
    },
    {
        "content": "<p>Another message is that <code>sub_eq_add_neg</code> is a <em>theorem</em>, and as a user this should be all you care about -- whether it not is true by definition is a question for the people who are implementing rings, not something which the users need to worry about.</p>",
        "id": 438188282,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1715523974
    },
    {
        "content": "<p>To give an example of why \"is this true by definition\" is not a good mathematical question: if n is a natural number then n+0=n is true by definition but 0+n=n is not.</p>",
        "id": 438188556,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1715524246
    },
    {
        "content": "<p>I know you are asking this rhetorically, but my answer would be that a group is a set with multiplication, inverse and identity, and stripping away inverse yields a monoid. Though of course, I understand the exact details of these definitions is not particularly relevant. </p>\n<p>I think I understand what you are saying, though; there is a difference in approach between the mathematics in a textbook and their realisation in a formal proof language, since our priorities are not the same in either setting. </p>\n<p>I also understand your point about  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">sub_eq_add_neg</span>\n</code></pre></div>\n<p>but I do have to admit that I find not worrying about these kinds of details to be difficult to get used to...</p>",
        "id": 438189834,
        "sender_full_name": "VayusElytra",
        "timestamp": 1715525501
    },
    {
        "content": "<p>My point is that with just the multiplication you can add axioms (rather than data) saying \"there exists an inverse map\" as opposed to making the inverse map part of the data: the inverse map is uniquely determined by the multiplication in a group so can be thought of as a fact about the multiplication. Whether you want axioms or data is a design decision, and in some sense not a mathematical question. Yes, writing a textbook and writing a mathematics library turn out to be different things. See Heather Macbeth's recent paper <a href=\"https://arxiv.org/abs/2405.04699\">https://arxiv.org/abs/2405.04699</a> .</p>",
        "id": 438191472,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1715526985
    },
    {
        "content": "<p>Thank you, this was an enlightening read!</p>",
        "id": 438192969,
        "sender_full_name": "VayusElytra",
        "timestamp": 1715528598
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"715864\">VayusElytra</span> <a href=\"#narrow/stream/113489-new-members/topic/Mathematics.20in.20Lean.20-.20.28-0.29.20vs.200/near/438189834\">said</a>:</p>\n<blockquote>\n<p>I also understand your point about  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">sub_eq_add_neg</span>\n</code></pre></div>\n<p>but I do have to admit that I find not worrying about these kinds of details to be difficult to get used to...</p>\n</blockquote>\n<p>Maybe MIL is not clear, but you don’t have to worry about these kind of details.</p>",
        "id": 438212405,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1715548188
    },
    {
        "content": "<p>Regarding your second question, the <code>rfl</code> in the first example is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=rfl#doc\">docs#rfl</a>. It only applies for equality. In the second example <code>rfl</code> is a tactic, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parser.Tactic.tacticRfl#doc\">docs#Lean.Parser.Tactic.tacticRfl</a>, which tries multiple reflexive tactics. For example, it also tries <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Iff.rfl#doc\">docs#Iff.rfl</a></p>",
        "id": 438233368,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1715569073
    },
    {
        "content": "<p>Thank you! That makes sense.</p>",
        "id": 438351270,
        "sender_full_name": "VayusElytra",
        "timestamp": 1715603904
    },
    {
        "content": "<p>Next question in line is from page 18, when trying to prove the goal <code>min (a + c) (b + c) ≤ min a b + c</code>. <br>\nMy approach to this would be to rewrite  <code>min (a + c) (b + c)</code> as  <code>min (a + c) (b + c) - c + c</code> using  <code>rw [\\l sub_add_cancel]</code>, but in practice this fails with the following error message: <br>\n<a href=\"/user_uploads/3121/XM0FygoVKfpgCZjZIhz7KlDc/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/XM0FygoVKfpgCZjZIhz7KlDc/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/XM0FygoVKfpgCZjZIhz7KlDc/image.png\"></a></div><p>The solution works around this by using a lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">min</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">min</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sub_add_cancel</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>My question: is there a way to make my original idea work directly, without needing to establish a lemma like this? In general I have been having somewhat of a hard time with rewrites where one needs to replace an implicit +0 by + a - a; what is the correct way to go about them?</p>",
        "id": 438838039,
        "sender_full_name": "VayusElytra",
        "timestamp": 1715789062
    },
    {
        "content": "<p>If I understand correctly, <code>rw [← sub_add_cancel (min (a + c) (b + c)) c]</code> should work.</p>",
        "id": 438843013,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1715790592
    },
    {
        "content": "<p>As you've noticed, lean is better at simplifying terms than making them more complicated. I don't know what's already been explained in mil at this point, but generally I might use <code>calc</code> or <code>trans</code> to write out the complicated middle expression, and then you have two subgoals where you can simplify</p>",
        "id": 438843896,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1715790861
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"715864\">@VayusElytra</span> do you understand the error message? <code>rw [\\l sub_add_cancel]</code> means \"change something to something-x+x for some x\" so Lean's response \"which something? There are about ten in the goal\" (a, a+c, min a b, ...) is not an unreasonable response</p>",
        "id": 438967076,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1715848190
    },
    {
        "content": "<p>I do understand (I think!). I was surprised because I know that when given an expression in which multiple somethings match the pattern, the rw tactic rewrites the first one as well as all remaining somethings with the same value for a, which is why only the (0+0)s get rewritten in this example from the NNG: <br>\n<a href=\"/user_uploads/3121/oQkWXRezqosnSe9W7t8x2U1u/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/oQkWXRezqosnSe9W7t8x2U1u/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/oQkWXRezqosnSe9W7t8x2U1u/image.png\"></a></div><p>So I would've expected the <code>rw [\\l sub_add_cancel]</code> here to rewrite something (the first occurence of a real number in the expression, perhaps). Though now that I am writing this, I realise this situation might be slightly different, since <code>rw [\\l sub_add_cancel]</code> would also need to know what x to use in its rewrite. </p>\n<p>Thank you all for answering, and apologies for asking what I could've figured out on my own</p>",
        "id": 438977472,
        "sender_full_name": "VayusElytra",
        "timestamp": 1715851854
    },
    {
        "content": "<p>You're right, there seems to be a subtlety here which I've only just realised. <code>rw</code> seems to be checking specifically whether you have given it zero clues (ie you're literally asking it to rewrite a pattern represented by a bare metavariable) and bails early if so. With <code>add_zero</code> even if it can match ten times, it's having to match <code>?a + 0</code> so this check isn't triggering.</p>",
        "id": 439002506,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1715861159
    },
    {
        "content": "<p>Today a question about proof terms. <br>\nThis example is from page 27 of mathematics in Lean: <br>\n<a href=\"/user_uploads/3121/C5dsF0EExxN1BiP-1BA3NehQ/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/C5dsF0EExxN1BiP-1BA3NehQ/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/C5dsF0EExxN1BiP-1BA3NehQ/image.png\"></a></div><p>If I understand properly: on the right side, we start by applying the hypothesis <code>rsubs : r ⊆ s</code> to the hypothesis <code>xr : x ∈ r</code> which yields <code>x \\in s</code>. Then, we apply <code>ssubt : s ⊆ t</code> to that to obtain the desired result <code>x ∈ t</code>.<br>\nSo what is the lambda abstraction on the left actually doing? I remember reading elsewhere that a property P1 implying some other property P2 can be formalized by saying that there exists a function mapping (elements of type) P1 to (elements of type) P2. Is this what the function we are trying to construct is doing? </p>\n<p>I understand this question probably requires a lot of extra reading to answer properly, so please feel free to just point me in the direction of a book or paper to look into!</p>",
        "id": 439366211,
        "sender_full_name": "VayusElytra",
        "timestamp": 1716048966
    },
    {
        "content": "<p>The lambda abstraction is doing what the intro tactic does. Does it help?</p>",
        "id": 439366261,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1716049030
    },
    {
        "content": "<p><a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a> has an explanation of proposition as types (including the notion of implications as functions, which is indeed what is happening there) and also how the forall quantifier works</p>",
        "id": 439366904,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1716049682
    },
    {
        "content": "<p>Thank you so much, that is exactly what I was looking for!</p>",
        "id": 439611481,
        "sender_full_name": "VayusElytra",
        "timestamp": 1716223431
    },
    {
        "content": "<p>Was curious about this solution to the first example on page 34 today. </p>\n<p><a href=\"/user_uploads/3121/hcDcAj8ngdw2PnKharQxJZdD/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/hcDcAj8ngdw2PnKharQxJZdD/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/hcDcAj8ngdw2PnKharQxJZdD/image.png\"></a></div><p>After <code>intro hh</code> we arrive at a spot where we have two hypotheses<code>h : ∀ ε &gt; 0, x &lt; ε</code> and <code>hh : x &gt; 0</code>. From trying on my end, at this point, <code>linarith</code> and <code>linarith [h hh]</code> both fail to solve the goal, but <code>linarith [h _ hh]</code> does. My questions: </p>\n<p>1) Why does <code>linarith</code> fail to solve the goal here? In my understanding, linarith already tries to apply all available hypotheses, so we shouldn't have to specify that it should use h and hh. </p>\n<p>2) My understanding as to why <code>linarith [h hh]</code> fails is that lean tries to interpret hh as a real number, which causes a type mismatch error. Why is h looking for a parameter when it is true for all epsilon?</p>",
        "id": 441018814,
        "sender_full_name": "VayusElytra",
        "timestamp": 1716895741
    },
    {
        "content": "<p>I find it a bit jarring that we're talking about all manner of things in a thread called -(-0) vs 0. Threads are cheap; feel free to start a new one with each question!</p>\n<p>1) <code>linarith</code> doesn't solve the goal because this would be scope creep. The moment you start asking <code>linarith</code> to instantiate forall statements with clever choices, you're asking it to do something which isn't in its remit.<br>\n2) <code>h hh</code> doesn't make sense because <code>h</code> is a function which first wants to eat a number, and then a proof that it's positive, and <code>hh</code> isn't a number.</p>",
        "id": 441022230,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1716897033
    },
    {
        "content": "<p>Does <code>linarith</code> eat errors like that in its argument? If so, we should fix that</p>",
        "id": 441039969,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1716902690
    },
    {
        "content": "<p>Noted! If that is appropriate etiquette, I will make new threads for new questions in the future. <br>\nThank you for your answers, this makes complete sense.</p>",
        "id": 441107748,
        "sender_full_name": "VayusElytra",
        "timestamp": 1716927158
    }
]