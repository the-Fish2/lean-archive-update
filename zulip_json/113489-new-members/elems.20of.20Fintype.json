[
    {
        "content": "<p>Hello, i wondered if  a function exists that converts a Fintype to List of all its elements. I try to store values associated to all Fintype Values</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">toList</span> <span class=\"o\">(</span><span class=\"n\">ft</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ft</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">mapping</span><span class=\"o\">:</span> <span class=\"n\">ft</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">ft</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">Fintype.elems</span> <span class=\"n\">ft</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toList.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">mapping</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 424402302,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1709377348
    },
    {
        "content": "<p>You maybe want <code>FinEnum</code> instead of <code>Fintype</code>; the former specifies an order</p>",
        "id": 424402912,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709378030
    },
    {
        "content": "<p>correct i didnt know about FinEnum.<br>\nis there a way to auto derive FinEnum like Fintype <a href=\"http://url\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/DeriveFintype.html</a> to define a FinEnum?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Enum</span><span class=\"o\">:</span><span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"n\">B</span> <span class=\"bp\">|</span> <span class=\"n\">C</span>\n<span class=\"n\">deriving</span> <span class=\"n\">FinEnum</span>\n</code></pre></div>",
        "id": 424404690,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1709379713
    },
    {
        "content": "<p>seems like this already has been discussed  on Zulip and you suggested it alongside the derive Fintype feature <a href=\"https://github.com/leanprover-community/mathlib4/pull/3198\">Github</a><br>\nso i guess it does not exist yet in mathlib4</p>",
        "id": 424409705,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1709384525
    },
    {
        "content": "<p>There are functions like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sort#doc\">docs#Finset.sort</a> to give a <code>List</code>.</p>\n<p>The fundamental problem here is that a <code>Finset</code> is a list without any order (it's defined as a quotient type of lists-up-to-permutation), and to extract that list you have to normalize it somehow.</p>\n<p>To <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>, do you <em>need</em> a List? Or can you stick with Finset?</p>",
        "id": 424424145,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709396173
    },
    {
        "content": "<p>I want to map from a finite Type to a Network Socket. My Problem is by simply defining a function from my Type to a Socket such a function would Always create a new Socket . I want to init my Sockets once and preserve that State in a List so i can do lookups later to use them</p>",
        "id": 424425473,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1709397324
    },
    {
        "content": "<p>it sounds like order doesn't matter, only that something is a member of a collection and can be searched for, so it doesn't necessarily need to be a list... it could be a hashmap or a finmap or something</p>",
        "id": 424435483,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709405157
    },
    {
        "content": "<p>yea but somehow i would have to fill this (hash) map with a proof that all elements from my type are part of the key set.<br>\nthats how im tried it</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Socket</span><span class=\"o\">:=</span> <span class=\"n\">Unit</span>\n<span class=\"kd\">def</span> <span class=\"n\">init_socket</span> <span class=\"o\">(</span><span class=\"n\">_address</span><span class=\"o\">:</span> <span class=\"n\">Unit</span><span class=\"o\">):</span> <span class=\"n\">IO</span> <span class=\"n\">Socket</span> <span class=\"o\">:=</span> <span class=\"n\">return</span> <span class=\"o\">()</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">init_network</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">FinEnum</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">adress_of</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Unit</span><span class=\"o\">):</span> <span class=\"n\">IO</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">Socket2</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">all_elems</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">FinEnum.toList</span> <span class=\"n\">α</span>   <span class=\"c1\">-- supposed to be the list of all α</span>\n  <span class=\"k\">let</span> <span class=\"n\">init_progs</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">IO</span> <span class=\"n\">Socket2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">all_elems.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">init_socket</span> <span class=\"o\">(</span><span class=\"n\">adress_of</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n  <span class=\"c1\">-- then execute all progs</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prog</span><span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">net</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">init_network</span> <span class=\"n\">Unit</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">())</span>\n  <span class=\"c1\">-- so now i can lookup Sockets by my supplied Type α = Unit</span>\n  <span class=\"k\">let</span> <span class=\"n\">some_sock</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">net.lookup</span> <span class=\"o\">())</span> <span class=\"c1\">-- would need a proof that all α are in the list...</span>\n</code></pre></div>",
        "id": 424438268,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1709407243
    },
    {
        "content": "<p>i use alpha to be able to supply different enums for Socket/Location names. for example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Location</span>\n<span class=\"bp\">|</span> <span class=\"n\">alice</span> <span class=\"bp\">|</span> <span class=\"n\">eve</span> <span class=\"bp\">|</span> <span class=\"n\">bob</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Location2</span>\n<span class=\"bp\">|</span> <span class=\"n\">client</span> <span class=\"bp\">|</span> <span class=\"n\">server</span>\n</code></pre></div>",
        "id": 424438946,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1709407700
    },
    {
        "content": "<p>could you post a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> or is it too complex?</p>",
        "id": 424439143,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709407851
    },
    {
        "content": "<p>it should come down to this as a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, however im not sure yet wether the concept of my \"collection\" makes sense. alpha again has to be some finite type </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">collection</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">data</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">β</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n  <span class=\"n\">complete</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">data.dlookup</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isSome</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">construct_collection</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span>  <span class=\"o\">(</span><span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">β</span> <span class=\"n\">v</span><span class=\"o\">):</span> <span class=\"n\">collection</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- not sure how to get here if even possible</span>\n  <span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- so i can define</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>  <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span>  <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">collection</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">c.data.dlookup</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">c.complete</span><span class=\"o\">])</span>\n</code></pre></div>",
        "id": 424444058,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1709411861
    },
    {
        "content": "<p>maybe this is a silly suggestion but why not just use <code>f: (v:α) -&gt; β v</code> as the collection? by definition it must have one and only one \"entry\" for each member of <code>α</code></p>\n<p>is the issue that you need it to be a stateful object that can be shared and mutated?</p>",
        "id": 424444871,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709412647
    },
    {
        "content": "<p>you could use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.update#doc\">docs#Function.update</a> if you want to update an entry, maybe store the function using a state monad</p>",
        "id": 424445743,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709413452
    },
    {
        "content": "<p>yea the idea is that its a network socket gets connected, stored in the \"collection\" and later retrieved without the need of starting the connection again (so yea its stateful)</p>",
        "id": 424445931,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1709413634
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/stream/113489-new-members/topic/elems.20of.20Fintype/near/424445743\">said</a>:</p>\n<blockquote>\n<p>you could use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.update#doc\">docs#Function.update</a> if you want to update an entry, maybe store the function using a state monad</p>\n</blockquote>\n<p>sounds like it could work, ill look into that thanks!</p>",
        "id": 424446028,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1709413789
    },
    {
        "content": "<p>From a performance perspective that's pretty bad because the data gets bigger every time you update the same entry</p>",
        "id": 424446675,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709414532
    },
    {
        "content": "<p>yeah... that's a good point...</p>",
        "id": 424446712,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709414573
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"684702\">@Simon Daniel</span> Eric is right that it's not a great solution... maybe something like this would work better:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">collection</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">data</span><span class=\"o\">:</span> <span class=\"n\">Finmap</span> <span class=\"n\">β</span>\n  <span class=\"n\">complete</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">data.lookup</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isSome</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">construct_collection</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">β</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">collection</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">data</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span>\n    <span class=\"n\">Finset.univ.val.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">k</span><span class=\"o\">⟩),</span>\n    <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Multiset.nodup_keys</span><span class=\"o\">]</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Multiset.keys</span><span class=\"o\">,</span> <span class=\"n\">Finset.univ.nodup</span><span class=\"o\">]</span>\n  <span class=\"o\">⟩,</span>\n  <span class=\"n\">complete</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Finmap.lookup_isSome</span><span class=\"o\">,</span> <span class=\"n\">Finmap.mem_def</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Multiset.keys</span><span class=\"o\">]</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">collection.update</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">collection</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">newVal</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">key</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">collection</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">data</span> <span class=\"o\">:=</span> <span class=\"n\">c.data.insert</span> <span class=\"n\">key</span> <span class=\"n\">newVal</span><span class=\"o\">,</span>\n  <span class=\"n\">complete</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">key</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">c.complete</span><span class=\"o\">]</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span>  <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">collection</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">c.data.lookup</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">c.complete</span><span class=\"o\">])</span>\n</code></pre></div>\n<p>(It's all good if you don't use this... I was just bored so I decided to write the whole thing up.)</p>",
        "id": 424447596,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709415320
    },
    {
        "content": "<p>I should have mentioned that even though there's no FinEnum derive handler, you can make use of the same machinery underlying the Fintype derive handler, and write this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Location</span>\n  <span class=\"bp\">|</span> <span class=\"n\">alice</span> <span class=\"bp\">|</span> <span class=\"n\">eve</span> <span class=\"bp\">|</span> <span class=\"n\">bob</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">FinEnum</span> <span class=\"n\">Location</span> <span class=\"o\">:=</span>\n  <span class=\"n\">FinEnum.ofEquiv</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">proxy_equiv</span><span class=\"bp\">%</span> <span class=\"n\">Location</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>",
        "id": 424448256,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709415977
    },
    {
        "content": "<p>(If someone wanted to write the FinEnum handler, it shouldn't be very hard, especially if you rip out the part about enum types, but if you want you could make an efficient FinEnum instance for enum types using the constructor index.)</p>",
        "id": 424448390,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709416160
    },
    {
        "content": "<p>I think FinEnum is currently in need of an overhaul, almost all the instances go back and forth between indices and lists in an inefficient way</p>",
        "id": 424448498,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709416277
    },
    {
        "content": "<p>So I think building meta code beyond transporting along the equivalence may be a bad use of time since such a refactor might throw it all out</p>",
        "id": 424448569,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709416352
    },
    {
        "content": "<p>Ok, so you're supporting ripping out all the enum type handling code, right?</p>\n<p>I guess one upgrade to <code>proxy_equiv%</code> would be to have it detect if it's for an enum type and create an equiv to Fin, and then there doesn't need to be any special handling.</p>",
        "id": 424448596,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709416394
    },
    {
        "content": "<p>I was just experimenting making a <code>Listable</code> class that produces a List of all elements of a type, adding just enough to get this derivation of a Listable instance to work for the Location type.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Listable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">elems</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n  <span class=\"n\">nodup</span> <span class=\"o\">:</span> <span class=\"n\">elems.Nodup</span>\n  <span class=\"n\">complete</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">elems</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Listable</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">elems</span> <span class=\"o\">:=</span> <span class=\"n\">List.finRange</span> <span class=\"n\">n</span>\n  <span class=\"n\">nodup</span> <span class=\"o\">:=</span> <span class=\"n\">List.nodup_finRange</span> <span class=\"n\">n</span>\n  <span class=\"n\">complete</span> <span class=\"o\">:=</span> <span class=\"n\">List.mem_finRange</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Listable.ofEquiv</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Listable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Listable</span> <span class=\"n\">β</span> <span class=\"n\">where</span>\n  <span class=\"n\">elems</span> <span class=\"o\">:=</span> <span class=\"n\">Listable.elems.map</span> <span class=\"n\">f</span>\n  <span class=\"n\">nodup</span> <span class=\"o\">:=</span> <span class=\"n\">Listable.nodup.map</span> <span class=\"n\">f.injective</span>\n  <span class=\"n\">complete</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">x</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">List.mem_map</span><span class=\"o\">]</span>\n    <span class=\"n\">use</span> <span class=\"n\">f.symm</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">Listable.complete</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">Equiv.apply_symm_apply</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Listable</span> <span class=\"n\">Unit</span> <span class=\"n\">where</span>\n  <span class=\"n\">elems</span> <span class=\"o\">:=</span> <span class=\"o\">[()]</span>\n  <span class=\"n\">nodup</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n  <span class=\"n\">complete</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Listable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Listable</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Listable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⊕</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">elems</span> <span class=\"o\">:=</span> <span class=\"n\">Listable.elems.map</span> <span class=\"n\">Sum.inl</span> <span class=\"bp\">++</span> <span class=\"n\">Listable.elems.map</span> <span class=\"n\">Sum.inr</span>\n  <span class=\"n\">nodup</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">apply</span> <span class=\"n\">List.Nodup.append</span>\n      <span class=\"o\">(</span><span class=\"n\">Listable.nodup.map</span> <span class=\"n\">Sum.inl_injective</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Listable.nodup.map</span> <span class=\"n\">Sum.inr_injective</span><span class=\"o\">)</span>\n    <span class=\"n\">intro</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">List.mem_map</span><span class=\"o\">,</span> <span class=\"n\">forall_exists_index</span><span class=\"o\">,</span> <span class=\"n\">and_imp</span><span class=\"o\">,</span> <span class=\"n\">imp_false</span><span class=\"o\">,</span> <span class=\"n\">ne_eq</span><span class=\"o\">]</span>\n    <span class=\"n\">intros</span>\n    <span class=\"n\">subst_vars</span>\n    <span class=\"n\">simp</span>\n  <span class=\"n\">complete</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Listable.complete</span><span class=\"o\">]</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Location</span>\n  <span class=\"bp\">|</span> <span class=\"n\">alice</span> <span class=\"bp\">|</span> <span class=\"n\">eve</span> <span class=\"bp\">|</span> <span class=\"n\">bob</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Listable</span> <span class=\"n\">Location</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Listable.ofEquiv</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">proxy_equiv</span><span class=\"bp\">%</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 424449792,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709417424
    },
    {
        "content": "<p>And a couple more Listable instances for the rest of the <code>proxy_equiv%</code> system:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>instance : Listable Empty where<br>\n  elems := []<br>\n  nodup := by decide<br>\n  complete := by decide</p>\n<p>-- TODO clean up the proofs<br>\ninstance {α : Type<em>} {β : α → Type</em>} [Listable α] [∀ x, Listable (β x)] :<br>\n    Listable ((x : α) × β x) where<br>\n  elems := Listable.elems.bind fun x =&gt; <a href=\"http://Listable.elems.map\">Listable.elems.map</a> fun y =&gt; ⟨x, y⟩<br>\n  nodup := by<br>\n    rw [List.nodup_bind]<br>\n    constructor<br>\n    · intros<br>\n      exact <a href=\"http://List.Nodup.map\">List.Nodup.map</a> sigma_mk_injective Listable.nodup<br>\n    · have hnd : (Listable.elems : List α).Nodup := Listable.nodup<br>\n      generalize h : (Listable.elems : List α) = xs<br>\n      rw [h] at hnd<br>\n      clear h<br>\n      induction xs<br>\n      · simp<br>\n      next _ x xs ih =&gt;<br>\n        simp<br>\n        simp at hnd<br>\n        specialize ih hnd.2<br>\n        simp [ih]<br>\n        intros x' hx' _<br>\n        simp<br>\n        intros<br>\n        subst_vars<br>\n        simp<br>\n        rintro rfl<br>\n        simp [hx'] at hnd<br>\n  complete := by<br>\n    intro ⟨x, y⟩<br>\n    simp only [List.mem_bind, List.mem_map, Sigma.mk.inj_iff]<br>\n    use x, Listable.complete x, y, Listable.complete y</p>\n<p>instance {p : Prop} [Decidable p]: Listable (PLift p) where<br>\n  elems := if h : p then [PLift.up h] else []<br>\n  nodup := by by_cases h : p &lt;;&gt; simp [h]<br>\n  complete := by by_cases h : p &lt;;&gt; simp [h]</p>\n</div></div>",
        "id": 424450921,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709418554
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/stream/113489-new-members/topic/elems.20of.20Fintype/near/424447596\">said</a>:</p>\n<blockquote>\n<p>(It's all good if you don't use this... I was just bored so I decided to write the whole thing up.)</p>\n</blockquote>\n<p>cool, looks like what i intended originally! is there a function on Sets/Multisets that lets me run them in the (IO) Monad like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">execute_set</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"o\">:</span> <span class=\"n\">Multiset</span> <span class=\"o\">(</span><span class=\"n\">IO</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"o\">(</span><span class=\"n\">Multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">return</span> <span class=\"n\">set.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"n\">return</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>searching for moand in the Multiset docs didnt come up with something.<br>\nand thanks <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> for sharing, Ill play around with FinEnums</p>",
        "id": 424457665,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1709425091
    },
    {
        "content": "<p>I'm unsure if <code>Multiset</code> is a <code>Traversable</code>... I assume you want to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=sequence#doc\">docs#sequence</a> here</p>",
        "id": 424458025,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709425525
    },
    {
        "content": "<p>you might need a list to do that</p>",
        "id": 424458147,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709425643
    },
    {
        "content": "<p>I don't think it can be Traversable. It would have to choose an order to perform the IO actions in, and different orders of IO actions have different effects.</p>",
        "id": 424458211,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709425676
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"684702\">@Simon Daniel</span> if you want it to be <code>Traversable</code>, perhaps <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AList#doc\">docs#AList</a> would be better than <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finmap#doc\">docs#Finmap</a></p>\n<p>(or you could use <code>Finmap</code> and then convert it to a List right before executing it, assuming you have some way of sorting it)</p>",
        "id": 424459015,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709426530
    },
    {
        "content": "<p>i guess switching to FinEnum instances would add the ordering</p>",
        "id": 424459907,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1709427491
    },
    {
        "content": "<p>maybe  you can help with the AList construction from FinEnum...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">collection</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">data</span><span class=\"o\">:</span> <span class=\"n\">AList</span> <span class=\"n\">β</span>\n  <span class=\"n\">complete</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">data.lookup</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isSome</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">construct_collection</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FinEnum</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">β</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"o\">(</span><span class=\"n\">collection</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n <span class=\"n\">return</span> <span class=\"o\">{</span>\n          <span class=\"n\">data</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span>\n            <span class=\"k\">let</span> <span class=\"n\">mset</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Finset.univ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">k</span><span class=\"o\">⟩)</span>\n            <span class=\"n\">mset</span> <span class=\"c1\">-- from multiset to AList with FunEnum implied order?</span>\n            <span class=\"kd\">by</span>\n              <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Multiset.nodup_keys</span><span class=\"o\">]</span>\n              <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Multiset.keys</span><span class=\"o\">,</span> <span class=\"n\">Finset.univ.nodup</span><span class=\"o\">],</span>\n          <span class=\"o\">⟩,</span>\n          <span class=\"n\">complete</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n            <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">AList.lookup_isSome</span><span class=\"o\">,</span> <span class=\"n\">AList.mem_def</span><span class=\"o\">]</span>\n            <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Multiset.keys</span><span class=\"o\">]</span>\n        <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 424460884,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1709428638
    },
    {
        "content": "<p>you would create the <code>AList</code> data with <code>(FinEnum.toList α).map (fun k =&gt; ⟨k, f k⟩)</code></p>",
        "id": 424461734,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709429492
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">construct_collection</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FinEnum</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">β</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"o\">(</span><span class=\"n\">collection</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">pure</span> <span class=\"o\">{</span>\n  <span class=\"n\">data</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span>\n    <span class=\"o\">(</span><span class=\"n\">FinEnum.toList</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">k</span><span class=\"o\">⟩),</span>\n    <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">List.NodupKeys</span><span class=\"o\">,</span> <span class=\"n\">List.keys</span><span class=\"o\">,</span> <span class=\"n\">Function.comp</span><span class=\"o\">]</span>\n  <span class=\"o\">⟩,</span>\n  <span class=\"n\">complete</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">AList.lookup_isSome</span><span class=\"o\">,</span> <span class=\"n\">AList.mem_keys</span><span class=\"o\">,</span> <span class=\"n\">AList.keys</span><span class=\"o\">,</span> <span class=\"n\">List.keys</span><span class=\"o\">]</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 424462466,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1709430306
    },
    {
        "content": "<p>One thing that's not clear to me is whether FinEnum or its replacement should be a tuple, a list, or an array</p>",
        "id": 424582198,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709531432
    }
]