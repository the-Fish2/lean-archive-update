[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Aesop</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Algebra.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.Bialgebra</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.HopfAlgebra</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">HopfAlgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n  <span class=\"bp\">∘ₗ</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">lTensor</span> <span class=\"n\">A</span>\n  <span class=\"bp\">∘ₗ</span> <span class=\"o\">(</span><span class=\"n\">TensorProduct.assoc</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">A</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n  <span class=\"bp\">∘ₗ</span> <span class=\"n\">H.comul.rTensor</span> <span class=\"n\">A</span>\n  <span class=\"bp\">∘ₗ</span> <span class=\"n\">TensorProduct.map</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">H.antipode</span>\n  <span class=\"bp\">∘ₗ</span> <span class=\"o\">(</span><span class=\"n\">TensorProduct.assoc</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">A</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"bp\">∘ₗ</span> <span class=\"n\">H.comul.lTensor</span> <span class=\"n\">A</span>\n  <span class=\"bp\">=</span>\n  <span class=\"o\">(</span><span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n  <span class=\"bp\">∘ₗ</span> <span class=\"o\">(</span><span class=\"n\">TensorProduct.comm</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n  <span class=\"bp\">∘ₗ</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">lTensor</span> <span class=\"n\">A</span>\n  <span class=\"bp\">∘ₗ</span> <span class=\"o\">(</span><span class=\"n\">TensorProduct.assoc</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">A</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n  <span class=\"bp\">∘ₗ</span> <span class=\"n\">H.comul.rTensor</span> <span class=\"n\">A</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I think the statement's correct and the first thing I want to do is rewrite <code>H.comul.rTensor A  ∘ₗ TensorProduct.map (LinearMap.mul' R A) H.antipode</code> as <code>TensorProduct.map (H.comul ∘ₗ LinearMap.mul' R A) H.antipode</code>. Once I've done this, I'd like touse <code>mul_compr₂_comul</code> to get  <code>TensorProduct.map ((LinearMap.mul' R _) ∘ₗ (TensorProduct.map H.comul H.comul)) H.antipode</code>. However, all the bialgebra laws use  <code>LinearMap.mul</code> instead of <code>LinearMap.mul'</code> and they use the <code>compr₂</code>  variants instead of <code>TensorProduct.map</code> which might suggest that I'm writing this weirdly, is there a better way to state this?</p>\n<p>Another thing is the hopf algebra laws use <code>LinearMap.mul'</code> and <code>LinearMap.lTensor</code>/<code>LinearMap.rTensor</code>  instead of <code>LinearMap.mul</code> and <code>compr₂</code>, am I missing a way to make the two definitions work nicely together?</p>",
        "id": 426080678,
        "sender_full_name": "Sam Ezeh",
        "timestamp": 1710234224
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"699016\">@Edison Xie</span> <span class=\"user-mention\" data-user-id=\"252627\">@Jujian Zhang</span> you have both been thinking about this stuff recently</p>",
        "id": 426081719,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710234603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"601198\">Sam Ezeh</span> <a href=\"#narrow/stream/113489-new-members/topic/Proving.20a.20statement.20about.20Hopf.20Algebras/near/426080678\">said</a>:</p>\n<blockquote>\n<p>However, all the bialgebra laws use  <code>LinearMap.mul</code> instead of <code>LinearMap.mul'</code> and they use the <code>compr₂</code>  variants instead of <code>TensorProduct.map</code> which might suggest that I'm writing this weirdly, is there a better way to state this?</p>\n<p>Another thing is the hopf algebra laws use <code>LinearMap.mul'</code> and <code>LinearMap.lTensor</code>/<code>LinearMap.rTensor</code>  instead of <code>LinearMap.mul</code> and <code>compr₂</code>, am I missing a way to make the two definitions work nicely together?</p>\n</blockquote>\n<p>I think it would be very reasonable to add some more <code>Bialgebra</code> lemmas that convert the existing statements to these statements</p>",
        "id": 426083468,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710235237
    },
    {
        "content": "<p>Your first step is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">LinearMap.comp_assoc</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.rTensor</span> <span class=\"n\">A</span> <span class=\"n\">Coalgebra.comul</span><span class=\"o\">)]</span> <span class=\"c1\">-- brackets in right place</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">LinearMap.rTensor</span> <span class=\"c1\">-- is there no API for this?</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">map_comp</span><span class=\"o\">]</span> <span class=\"c1\">-- :tada</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.id_comp</span><span class=\"o\">]</span> <span class=\"c1\">-- simplify</span>\n</code></pre></div>\n<p>but I have no idea about all this compr/compl stuff. I do know that <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> was adamant that the statement of the bialgebra axiom needed to be changed from <code>comul (a * b) = comul a * comul b</code> (the original choice) to <code>(LinearMap.mul R A).compr₂ comul = (LinearMap.mul R (A ⊗[R] A)).compl₁₂ comul comul</code> but I have no understanding of why this is better, all I know is that Eric understands this stuff much better than me so I trusted him.</p>\n<p>I will also say that this question took me several minutes to even parse: the lack of a commutative diagram widget (even though it's been advertised on FRO slides for months if not years) is really painful here.</p>",
        "id": 426110009,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710245076
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Proving.20a.20statement.20about.20Hopf.20Algebras/near/426110009\">said</a>:</p>\n<blockquote>\n<p>I will also say that this question took me several minutes to even parse: the lack of a commutative diagram widget (even though it's been advertised on FRO slides for months if not years) is really painful here.</p>\n</blockquote>\n<p>What is the state of this? Are there people working on it? My motivation for working with Hopf Algebras is precisely for my graphical rewriting project where I want to build a proof of concept for string diagrams: <a href=\"https://github.com/dignissimus/Untangle\">https://github.com/dignissimus/Untangle</a></p>",
        "id": 426110653,
        "sender_full_name": "Sam Ezeh",
        "timestamp": 1710245307
    },
    {
        "content": "<p>Even when it existed, it was only for statements written categorically. There is an open PR for string diagrams in monoidal categories, but this has the same shortcoming.</p>",
        "id": 426117285,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710247695
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Proving.20a.20statement.20about.20Hopf.20Algebras/near/426081719\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"699016\">Edison Xie</span> <span class=\"user-mention silent\" data-user-id=\"252627\">Jujian Zhang</span> you have both been thinking about this stuff recently</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">tactic.skipAssignedInstances</span> <span class=\"n\">false</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">synthInstance.maxHeartbeats</span> <span class=\"mi\">50000</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">R1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R1</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">A1</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">HopfAlgebra</span> <span class=\"n\">R1</span> <span class=\"n\">A1</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R1</span> <span class=\"n\">A1</span><span class=\"o\">)</span>\n  <span class=\"bp\">∘ₗ</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R1</span> <span class=\"n\">A1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">lTensor</span> <span class=\"n\">A1</span>\n  <span class=\"bp\">∘ₗ</span> <span class=\"o\">(</span><span class=\"n\">TensorProduct.assoc</span> <span class=\"n\">R1</span> <span class=\"n\">A1</span> <span class=\"n\">A1</span> <span class=\"n\">A1</span><span class=\"o\">)</span>\n  <span class=\"bp\">∘ₗ</span> <span class=\"n\">H.comul.rTensor</span> <span class=\"n\">A1</span>\n  <span class=\"bp\">∘ₗ</span> <span class=\"n\">TensorProduct.map</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R1</span> <span class=\"n\">A1</span><span class=\"o\">)</span> <span class=\"n\">H.antipode</span>\n  <span class=\"bp\">∘ₗ</span> <span class=\"o\">(</span><span class=\"n\">TensorProduct.assoc</span> <span class=\"n\">R1</span> <span class=\"n\">A1</span> <span class=\"n\">A1</span> <span class=\"n\">A1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"bp\">∘ₗ</span> <span class=\"n\">H.comul.lTensor</span> <span class=\"n\">A1</span>\n  <span class=\"bp\">=</span>\n  <span class=\"o\">(</span><span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R1</span> <span class=\"n\">A1</span><span class=\"o\">)</span>\n  <span class=\"bp\">∘ₗ</span> <span class=\"o\">(</span><span class=\"n\">TensorProduct.comm</span> <span class=\"n\">R1</span> <span class=\"n\">A1</span> <span class=\"n\">A1</span><span class=\"o\">)</span>\n  <span class=\"bp\">∘ₗ</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R1</span> <span class=\"n\">A1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">lTensor</span> <span class=\"n\">A1</span>\n  <span class=\"bp\">∘ₗ</span> <span class=\"o\">(</span><span class=\"n\">TensorProduct.assoc</span> <span class=\"n\">R1</span> <span class=\"n\">A1</span> <span class=\"n\">A1</span> <span class=\"n\">A1</span><span class=\"o\">)</span>\n  <span class=\"bp\">∘ₗ</span> <span class=\"n\">H.comul.rTensor</span> <span class=\"n\">A1</span>\n<span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">LinearMap.comp_assoc</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.rTensor</span> <span class=\"n\">A1</span> <span class=\"n\">Coalgebra.comul</span><span class=\"o\">)]</span> <span class=\"c1\">-- brackets in right place</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">LinearMap.rTensor</span> <span class=\"c1\">-- is there no API for this?</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">TensorProduct.map_comp</span><span class=\"o\">]</span> <span class=\"c1\">-- :tada</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.id_comp</span><span class=\"o\">]</span> <span class=\"c1\">-- simplify</span>\n\n  <span class=\"n\">ext</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">TensorProduct.AlgebraTensorModule.curry_apply</span><span class=\"o\">,</span> <span class=\"n\">TensorProduct.curry_apply</span><span class=\"o\">,</span>\n    <span class=\"n\">LinearMap.coe_restrictScalars</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.coe_comp</span><span class=\"o\">,</span> <span class=\"n\">LinearEquiv.coe_coe</span><span class=\"o\">,</span> <span class=\"n\">comp_apply</span><span class=\"o\">,</span>\n    <span class=\"n\">LinearMap.lTensor_tmul</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.rTensor_tmul</span><span class=\"o\">]</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">I1</span><span class=\"o\">,</span> <span class=\"n\">x1</span><span class=\"o\">,</span> <span class=\"n\">x2</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">HopfPoints.comul_repr</span> <span class=\"n\">R1</span> <span class=\"n\">A1</span> <span class=\"n\">a</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">I2</span><span class=\"o\">,</span> <span class=\"n\">y1</span><span class=\"o\">,</span> <span class=\"n\">y2</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">HopfPoints.comul_repr</span> <span class=\"n\">R1</span> <span class=\"n\">A1</span> <span class=\"n\">b</span>\n  <span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">zetaDelta</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">zeta</span> <span class=\"o\">:=</span> <span class=\"n\">false</span> <span class=\"o\">})</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">TensorProduct.tmul_sum</span><span class=\"o\">,</span> <span class=\"n\">map_sum</span><span class=\"o\">,</span>\n    <span class=\"n\">TensorProduct.assoc_symm_tmul</span><span class=\"o\">,</span> <span class=\"n\">TensorProduct.map_tmul</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.mul'_apply</span><span class=\"o\">,</span>\n    <span class=\"n\">LinearMap.rTensor_tmul</span><span class=\"o\">,</span> <span class=\"n\">Bialgebra.comul_mul</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">TensorProduct.sum_tmul</span><span class=\"o\">,</span>\n    <span class=\"n\">TensorProduct.assoc_tmul</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.lTensor_tmul</span><span class=\"o\">,</span> <span class=\"n\">TensorProduct.comm_tmul</span><span class=\"o\">,</span>\n    <span class=\"n\">LinearMap.id_coe</span><span class=\"o\">,</span><span class=\"n\">id_eq</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.coe_comp</span><span class=\"o\">,</span> <span class=\"n\">comp_apply</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.mul'_apply</span><span class=\"o\">,</span> <span class=\"n\">Bialgebra.comul_mul</span><span class=\"o\">]</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">I11</span><span class=\"o\">,</span> <span class=\"n\">y11</span><span class=\"o\">,</span> <span class=\"n\">y12</span><span class=\"o\">,</span> <span class=\"n\">hy1</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">HopfPoints.comul_repr</span> <span class=\"n\">R1</span> <span class=\"n\">A1</span> <span class=\"o\">(</span><span class=\"n\">y1</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I attempted this but failed, but i think the general idea is using sweedler to open everything up then it should be clear using some properties of antipode :(</p>",
        "id": 426181510,
        "sender_full_name": "Edison Xie",
        "timestamp": 1710265577
    },
    {
        "content": "<p>What's the statement of <code>HopfPoints.comul_repr</code>?</p>",
        "id": 426188404,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710267915
    },
    {
        "content": "<p>I think it is saying that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>u</mi><mi>l</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>1</mn></msub><mi>i</mi><mo>⊗</mo><msub><mi>a</mi><mn>2</mn></msub><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">comul(a) = \\sum_{i \\in I}, a_1 i \\otimes a_2 i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">co</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0771em;vertical-align:-0.3271em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">I</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3271em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">i</span></span></span></span> for some inex set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> and coordinate function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">a_1, a_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></p>",
        "id": 426192842,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1710269573
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Proving.20a.20statement.20about.20Hopf.20Algebras/near/426083468\">said</a>:</p>\n<blockquote>\n<p>I think it would be very reasonable to add some more <code>Bialgebra</code> lemmas that convert the existing statements to these statements</p>\n</blockquote>\n<p>Would these be welcome?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">mul'_comp_comul</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Bialgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">_</span> <span class=\"bp\">∘ₗ</span>  <span class=\"n\">TensorProduct.map</span> <span class=\"n\">B.comul</span> <span class=\"n\">B.comul</span> <span class=\"bp\">=</span> <span class=\"n\">B.comul</span> <span class=\"bp\">∘ₗ</span> <span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span>\n  <span class=\"n\">simp</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mul'_comp_counit</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Bialgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">_</span> <span class=\"bp\">∘ₗ</span>  <span class=\"n\">TensorProduct.map</span> <span class=\"n\">B.counit</span> <span class=\"n\">B.counit</span> <span class=\"bp\">=</span> <span class=\"n\">B.counit</span> <span class=\"bp\">∘ₗ</span> <span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">_</span><span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span>\n  <span class=\"n\">simp</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">lift_map_eq_lift_compl₁₂</span>\n  <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">C</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">E</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">F</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">G</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">H</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">C</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">E</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">}</span>\n<span class=\"o\">:</span> <span class=\"n\">TensorProduct.lift</span> <span class=\"n\">f</span> <span class=\"bp\">∘ₗ</span> <span class=\"n\">TensorProduct.map</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">TensorProduct.lift</span> <span class=\"o\">(</span><span class=\"n\">f.compl₁₂</span> <span class=\"n\">g</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span>\n  <span class=\"n\">simp</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">comp_lift_eq_lift_compr₂</span>\n  <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">C</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">D</span><span class=\"o\">}</span>\n<span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">∘ₗ</span> <span class=\"n\">TensorProduct.lift</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">TensorProduct.lift</span> <span class=\"o\">(</span><span class=\"n\">f.compr₂</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 426259108,
        "sender_full_name": "Sam Ezeh",
        "timestamp": 1710305048
    },
    {
        "content": "<p>I think some of those assumptions are too strong; I doubt you need your modules to be semirings?</p>",
        "id": 426281760,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710318191
    },
    {
        "content": "<p>Otherwise they look fine</p>",
        "id": 426281784,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710318205
    }
]