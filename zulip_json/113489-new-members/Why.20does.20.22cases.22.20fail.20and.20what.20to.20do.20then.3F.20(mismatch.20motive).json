[
    {
        "content": "<p>I am confused about when \"cases\" works and what I should use when it does not. My vague understanding is that it only works when the goal is a <code>Prop</code>, but I am wondering whether there is a fundamental reason behind this restriction.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Tauto</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">splitCases</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">γ</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">],</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">γ</span> <span class=\"n\">γ_def</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">γ_def</span>\n  <span class=\"c1\">-- The goal here does not yet mention Prop.</span>\n  <span class=\"n\">cases</span> <span class=\"n\">γ_def</span> <span class=\"c1\">-- this actually restricts α,β,γ to be Prop !!</span>\n  <span class=\"bp\">·</span> <span class=\"n\">tauto</span>\n  <span class=\"bp\">·</span> <span class=\"n\">tauto</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"c1\">-- I guess this is because we do not have DecidableEq Type?</span>\n<span class=\"kd\">def</span> <span class=\"n\">splitNoCases</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">γ</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">],</span> <span class=\"n\">List</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">γ</span> <span class=\"n\">γ_def</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">γ_def</span>\n  <span class=\"c1\">-- cases γ_def -- does not work because the goal is List γ.</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"k\">then</span>\n    <span class=\"n\">subst</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">a</span>\n  <span class=\"k\">else</span>\n    <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">=</span> <span class=\"n\">β</span> <span class=\"k\">then</span>\n     <span class=\"n\">subst</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">b</span>\n   <span class=\"k\">else</span>\n     <span class=\"n\">exfalso</span><span class=\"bp\">;</span> <span class=\"n\">tauto</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">splitNoCases'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Fin</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">γ</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">],</span> <span class=\"n\">Fin</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">γ</span> <span class=\"n\">γ_def</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">γ_def</span>\n  <span class=\"c1\">-- cases γ_def -- does not work: type mismatch when assigning motive</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"k\">then</span>\n    <span class=\"n\">subst</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">a</span>\n  <span class=\"k\">else</span>\n    <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">=</span> <span class=\"n\">β</span> <span class=\"k\">then</span>\n     <span class=\"n\">subst</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">b</span>\n   <span class=\"k\">else</span>\n     <span class=\"n\">exfalso</span><span class=\"bp\">;</span> <span class=\"n\">tauto</span>\n</code></pre></div>\n<p>What are shorter and more elegant ways to do this if-then-else chaining? I also tried to use \"cases (decide ...)\" but it seems tedious with disjunctions. How do I do it if instead of [α, β] I have some arbitrary indexing type? Many thanks in advance for any help!</p>",
        "id": 424708616,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1709573251
    },
    {
        "content": "<p>If the goal isn't a <code>Prop</code> then arguably you shouldn't be in tactic mode at all! High-powered tactics like <code>simp</code> will produce horrible terms which will be very hard to work with. They're fine in proofs because proofs are erased.</p>",
        "id": 424736695,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709582198
    },
    {
        "content": "<p>Cases uses the <code>casesOn</code> associated to an inductive type, which is specialized to <code>Prop</code>. In this case, I think you're using <code>List.Mem.casesOn</code>, and you can use <code>#check</code> to verify.</p>",
        "id": 424744780,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709585405
    },
    {
        "content": "<p>Here's how I would probably write the last function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">splitNoCases'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">γ_def</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">])</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"k\">then</span>\n    <span class=\"n\">Fin.cast</span> <span class=\"n\">h.symm</span> <span class=\"n\">a</span>\n  <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">=</span> <span class=\"n\">β</span> <span class=\"k\">then</span>\n    <span class=\"n\">Fin.cast</span> <span class=\"n\">h'.symm</span> <span class=\"n\">b</span>\n  <span class=\"k\">else</span>\n    <span class=\"kd\">by</span> <span class=\"n\">exfalso</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">γ_def</span><span class=\"bp\">;</span> <span class=\"n\">tauto</span>\n</code></pre></div>",
        "id": 424748267,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709586733
    },
    {
        "content": "<p>Thanks! This also made me learn about <code>▸</code> which seems to be a general version of things like <code>Fin.cast</code>.</p>",
        "id": 424828715,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1709631261
    },
    {
        "content": "<p>It's general, and it's how <code>Fin.cast</code> itself can be implemented, but be aware that it's better to use <code>Fin.cast</code>, and to define functions such as <code>Fin.cast</code>, since you can write better simp lemmas for such functions than <code>▸</code>.</p>",
        "id": 424933352,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709663674
    }
]