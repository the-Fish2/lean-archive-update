[
    {
        "content": "<p>\"Why\" does this work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Sum'''</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Sum'''</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inr</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Sum'''</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Sum'''.inl</span>\n<span class=\"k\">#check</span> <span class=\"n\">Sum'''.inr</span>\n</code></pre></div>\n<p>Specifically why does Lean know I mean <code>Sum \\alpha \\beta</code> rather than assuming say <code>Sum \\alpha \\alpha</code> for <code>inl</code>'s type (or really blowing up, which I half expected)? Does it simply try to (unify?) the most general possible interpretation of holes?</p>",
        "id": 430612419,
        "sender_full_name": "Julian Berman",
        "timestamp": 1711985473
    },
    {
        "content": "<p>Arguments given in the left-hand side of <code>:</code> in inductive signatures are parameters, meaning that they're fixed in all recursive appeareances of the inductive type in its constructors, hence why Lean interprets the holes in the right way. If you instead put there arguments as indices, you'll see that Lean makes a more \"general\" interpretation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Sum'''</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Sum'''</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inr</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Sum'''</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Sum'''.inl</span>\n<span class=\"k\">#check</span> <span class=\"n\">Sum'''.inr</span>\n</code></pre></div>",
        "id": 430627689,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1711990325
    }
]