[
    {
        "content": "<p>Hi guys <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> </p>\n<p>I'm new to Lean and wanted to check my understanding of a few concepts I read in <em>Theorem Proving in Lean</em> &amp; played around with in VSCode.</p>\n<p>Here's my understanding of <code>#check List</code>being <code>Type u → Type u</code></p>\n<ol>\n<li><code>List</code> takes in a parameter that specifies what the type of its members will be, e.g. ℕ, and returns a term of type <code>List ℕ</code>. In the ℕ case, we could think of <code>List</code> as <code>Type 0 → Type 0</code></li>\n<li>Furthermore, we want this hold for <em>any</em> type universe (e.g. Type 1, Type 2) not just Type 0. But we want to ensure that both the input and the output aren't within different universes but rather the same universe u, hence <code>Type u → Type u</code>. For the life of me I can't think of a case in which the type of the list would be in any universe other than 0. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></li>\n</ol>",
        "id": 446324434,
        "sender_full_name": "Noah Stebbins",
        "timestamp": 1719089383
    },
    {
        "content": "<ol>\n<li>Correct</li>\n<li>That's not quite it. The underlying type theory <em>forces</em> <code>List α</code> to live in a universe at least as big as the one of <code>α</code> (think of it in terms of size. <code>List α</code> is at least as big as <code>α</code> since <code>a ↦ [a]</code> is an injection), and we make it live in the same universe out of simplicity. In fact, <code>List : Type u → Type (max u v)</code> would be perfectly allowed. A list of <code>Type</code> would have to live in <code>Type 1</code> because <code>Type : Type 1</code>.</li>\n</ol>",
        "id": 446324874,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1719089638
    }
]