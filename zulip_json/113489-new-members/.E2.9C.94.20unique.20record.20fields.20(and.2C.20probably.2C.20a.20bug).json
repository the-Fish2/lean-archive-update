[
    {
        "content": "<p>Hello! I tried to make a proof that fields of a given record are unique, and failed. Here are my two attempts (simplified):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n  <span class=\"kd\">inductive</span> <span class=\"n\">NotPresentField</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n    <span class=\"bp\">|</span> <span class=\"n\">notPresentEmpty</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">NotPresentField</span> <span class=\"n\">a</span> <span class=\"o\">[]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">notPresentCons</span>\n      <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n      <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n      <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">lst</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"n\">Term</span><span class=\"o\">))</span>\n      <span class=\"bp\">→</span> <span class=\"n\">NotPresentField</span> <span class=\"n\">a</span> <span class=\"n\">lst</span>\n      <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span>\n      <span class=\"bp\">→</span> <span class=\"n\">NotPresentField</span> <span class=\"n\">a</span> <span class=\"o\">((</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">lst</span><span class=\"o\">)</span>\n\n  <span class=\"kd\">inductive</span> <span class=\"n\">UniqueFields</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n    <span class=\"bp\">|</span> <span class=\"n\">uniqueEmpty</span> <span class=\"o\">:</span> <span class=\"n\">UniqueFields</span> <span class=\"o\">[]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">uniqueCons</span>\n      <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n      <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">lst</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"n\">Term</span><span class=\"o\">))</span>\n      <span class=\"bp\">→</span> <span class=\"n\">NotPresentField</span> <span class=\"n\">a</span> <span class=\"n\">lst</span>\n      <span class=\"bp\">→</span> <span class=\"n\">UniqueFields</span> <span class=\"n\">lst</span>\n      <span class=\"bp\">→</span> <span class=\"n\">UniqueFields</span> <span class=\"o\">((</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">lst</span><span class=\"o\">)</span>\n\n  <span class=\"kd\">inductive</span> <span class=\"n\">Term</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n    <span class=\"bp\">|</span> <span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"n\">Term</span>\n    <span class=\"bp\">|</span> <span class=\"n\">record</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">lst</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"n\">Term</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">UniqueFields</span> <span class=\"n\">lst</span> <span class=\"bp\">→</span> <span class=\"n\">Term</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>This attempt results in two errors:</p>\n<ol>\n<li>(kernel) arg <a href=\"https://github.com/leanprover-community/mathlib4/pull/1\">#1</a> of 'NotPresentField.notPresentCons' has a non positive occurrence of the datatypes being declared.</li>\n<li>unknown identifier 'Term'.</li>\n</ol>\n<p>I tried to avoid mutual recursion, hence my second attempt:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">NotPresentField</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">notPresentEmpty</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">NotPresentField</span> <span class=\"n\">a</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">notPresentCons</span>\n    <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n    <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n    <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">lst</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n    <span class=\"bp\">→</span> <span class=\"n\">NotPresentField</span> <span class=\"n\">a</span> <span class=\"n\">lst</span>\n    <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span>\n    <span class=\"bp\">→</span> <span class=\"n\">NotPresentField</span> <span class=\"n\">a</span> <span class=\"o\">((</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">lst</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">UniqueFields</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">uniqueEmpty</span> <span class=\"o\">:</span> <span class=\"n\">UniqueFields</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">uniqueCons</span>\n    <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n    <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">lst</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"n\">_</span><span class=\"o\">))</span>\n    <span class=\"bp\">→</span> <span class=\"n\">NotPresentField</span> <span class=\"n\">a</span> <span class=\"n\">lst</span>\n    <span class=\"bp\">→</span> <span class=\"n\">UniqueFields</span> <span class=\"n\">lst</span>\n    <span class=\"bp\">→</span> <span class=\"n\">UniqueFields</span> <span class=\"o\">((</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">lst</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Term</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"n\">Term</span>\n  <span class=\"c1\">-- | record : (lst : List (String × Term)) → @UniqueFields Term lst → Term</span>\n  <span class=\"bp\">|</span> <span class=\"n\">record</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">lst</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"n\">Term</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">UniqueFields</span> <span class=\"n\">lst</span> <span class=\"bp\">→</span> <span class=\"n\">Term</span>\n</code></pre></div>\n<p>This one results in (kernel) unknown constant 'Term'.</p>\n<p>Both issues seem similar to a recent bug, <a href=\"https://github.com/leanprover/lean4/issues/2628\">https://github.com/leanprover/lean4/issues/2628</a>;<br>\nHowever, the PR fixing the issue was merged on 22, November, and I am currently using leanprover/lean4:v4.5.0-rc1, which was released in December. Is it actually a bug and I should open a new issue? What are some possible workaround? Additionally, where can I find some formalizations which involve calculi with records?</p>",
        "id": 413193983,
        "sender_full_name": "Anatoliy Baskakov",
        "timestamp": 1705422809
    },
    {
        "content": "<p>It makes sense that the first case with mutual inductives fails: since you're trying to index some types by some other types defined in the mutual block, these are not simply mutual inductive types, but nested inductive-inductive types, which aren't handled by lean. The error appearing in your second example does look like a bug to me though, you should probably open an issue for it.</p>",
        "id": 413207385,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1705427027
    },
    {
        "content": "<p>The error is not a bug, although the error message is bad enough as to be considered a bug. Recursive arguments in a constructor (here <code>(lst : List (String × Term))</code>) cannot be used dependently; this would require bringing <code>UniqueFields</code> into the inductive and then it's back to being an inductive-inductive type</p>",
        "id": 413209856,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705427747
    },
    {
        "content": "<p>Here's a working version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">RecordOf</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"n\">RecordOf</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">lst</span> <span class=\"bp\">→</span> <span class=\"n\">Term</span> <span class=\"bp\">→</span> <span class=\"n\">RecordOf</span> <span class=\"n\">lst</span> <span class=\"bp\">→</span> <span class=\"n\">RecordOf</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">lst</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Term</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"n\">Term</span>\n  <span class=\"bp\">|</span> <span class=\"n\">record</span> <span class=\"o\">:</span> <span class=\"n\">RecordOf</span> <span class=\"n\">lst</span> <span class=\"bp\">→</span> <span class=\"n\">Term</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 413210630,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705428007
    },
    {
        "content": "<p>(Not sure if you wanted <code>empty</code> to be separate from <code>record</code>, since this makes there be two empties since <code>record empty</code> also exists)</p>",
        "id": 413210801,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705428056
    },
    {
        "content": "<p>Thank you for your answers! I will raise an issue regarding dependant use of arguments, then</p>",
        "id": 413214304,
        "sender_full_name": "Anatoliy Baskakov",
        "timestamp": 1705429252
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/unique.20record.20fields.20.28and.2C.20probably.2C.20a.20bug.29/near/413210630\">писал/а</a>:</p>\n<blockquote>\n<p>Here's a working version:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">RecordOf</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"n\">RecordOf</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">lst</span> <span class=\"bp\">→</span> <span class=\"n\">Term</span> <span class=\"bp\">→</span> <span class=\"n\">RecordOf</span> <span class=\"n\">lst</span> <span class=\"bp\">→</span> <span class=\"n\">RecordOf</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">lst</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Term</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"n\">Term</span>\n  <span class=\"bp\">|</span> <span class=\"n\">record</span> <span class=\"o\">:</span> <span class=\"n\">RecordOf</span> <span class=\"n\">lst</span> <span class=\"bp\">→</span> <span class=\"n\">Term</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This allows for a list with unique elements, but the desired outcome was to have list of pairs, where first elements would be unique (field names, basically), and second elements - other terms. However, if there is some other way to assign terms to each element of a unique-elemented list of Strings - that would be fine too</p>",
        "id": 413216855,
        "sender_full_name": "Anatoliy Baskakov",
        "timestamp": 1705430290
    },
    {
        "content": "<p>no, that is a list of pairs</p>",
        "id": 413218393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705430902
    },
    {
        "content": "<p>note that the <code>cons</code>  constructor has a <code>Term</code> argument</p>",
        "id": 413218435,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705430917
    },
    {
        "content": "<p>it is data carrying</p>",
        "id": 413218456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705430924
    },
    {
        "content": "<p>you could also write it as a nested inductive thusly</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">RecordOf</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"n\">RecordOf</span> <span class=\"n\">α</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">lst</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">RecordOf</span> <span class=\"n\">α</span> <span class=\"n\">lst</span> <span class=\"bp\">→</span> <span class=\"n\">RecordOf</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">lst</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Term</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"n\">Term</span>\n  <span class=\"bp\">|</span> <span class=\"n\">record</span> <span class=\"o\">:</span> <span class=\"n\">RecordOf</span> <span class=\"n\">Term</span> <span class=\"n\">lst</span> <span class=\"bp\">→</span> <span class=\"n\">Term</span>\n</code></pre></div>",
        "id": 413218787,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705431025
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">RecordOf.toList</span> <span class=\"o\">:</span> <span class=\"n\">RecordOf</span> <span class=\"n\">α</span> <span class=\"n\">lst</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">empty</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">_</span> <span class=\"n\">v</span> <span class=\"n\">ls</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">ls.toList</span>\n</code></pre></div>",
        "id": 413219431,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705431254
    },
    {
        "content": "<p>Ah, indeed, I somehow missed that. Thank you very much!</p>",
        "id": 416039236,
        "sender_full_name": "Anatoliy Baskakov",
        "timestamp": 1705501368
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"681890\">Anatoliy Baskakov</span> has marked this topic as resolved.</p>",
        "id": 417217392,
        "sender_full_name": "Notification Bot",
        "timestamp": 1705926038
    }
]