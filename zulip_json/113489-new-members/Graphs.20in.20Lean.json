[
    {
        "content": "<p>Hello,<br>\nI want to model a network by a set of Nodes (String) and Edges between Nodes (a Subset of cartesian product of Nodes).<br>\ni tried </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Network</span> <span class=\"n\">where</span>\n  <span class=\"n\">nodes</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">String</span>\n  <span class=\"n\">edges</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"bp\">×</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n  <span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">l1</span> <span class=\"n\">l2</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">),</span> <span class=\"n\">edges.contains</span> <span class=\"o\">(</span><span class=\"n\">l1</span><span class=\"o\">,</span> <span class=\"n\">l2</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">nodes.product</span> <span class=\"n\">nodes</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"o\">(</span><span class=\"n\">l1</span><span class=\"o\">,</span> <span class=\"n\">l2</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">testNet</span><span class=\"o\">:</span> <span class=\"n\">Network</span> <span class=\"o\">:=</span> <span class=\"n\">Network.mk</span> <span class=\"o\">[</span><span class=\"s2\">\"hello\"</span><span class=\"o\">,</span> <span class=\"s2\">\"alice\"</span><span class=\"o\">]</span> <span class=\"o\">[(</span><span class=\"s2\">\"alice\"</span><span class=\"o\">,</span> <span class=\"s2\">\"hello\"</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but somehow i feel like there should be a nicer approach. Is using lists and ignoring duplicates even the way to go?</p>",
        "id": 423829877,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1709130553
    },
    {
        "content": "<p>Are you looking to write efficient algorithms with this data structure? The problem of data structures to represent networks (AKA graphs) is <a href=\"https://en.wikipedia.org/wiki/Graph_(abstract_data_type)\">a well-studied one</a> in computer science</p>",
        "id": 423845213,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709134681
    },
    {
        "content": "<p>im effectively trying to write a directed graph where my nodes are a finite subset of String. Efficent algorithms are none of my concerns, i need to find (optional) paths from a to b and connected subgraphs.<br>\nBut the Lean std does not provide a datatype for sets right?  i only found <a href=\"http://url\">https://leanprover-community.github.io/mathlib4_docs/Lean/Data/SSet.html</a> which seems to be for a different purpose. Should i look into Set or FinSet of Mathlib?<br>\nor something like this with subtypes</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">string_subtype</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">String</span> <span class=\"bp\">//</span> <span class=\"o\">[</span><span class=\"s2\">\"alice\"</span><span class=\"o\">,</span> <span class=\"s2\">\"bob\"</span><span class=\"o\">,</span> <span class=\"s2\">\"eve\"</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">node</span><span class=\"o\">:</span> <span class=\"n\">string_subtype</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"s2\">\"alice\"</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 423853125,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1709136831
    },
    {
        "content": "<p>Mathlib has <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph#doc\">docs#SimpleGraph</a> for an undirected graph</p>",
        "id": 423856090,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709137601
    },
    {
        "content": "<p>It represents edges with a predicate</p>",
        "id": 423856217,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709137638
    },
    {
        "content": "<p>You can also represent edges with a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set#doc\">docs#Set</a></p>",
        "id": 423856255,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709137649
    },
    {
        "content": "<p>But predicates and <code>Set</code>s are computationally useless, so if you want to write an algorithm to find a path, you will need something else. If you just want to proof that some sequence of nodes is a path, then these approaches will work fine</p>",
        "id": 423856607,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709137748
    },
    {
        "content": "<p>could you elaborate why its useless? i guess because both represent possibly infinite Sets? <br>\nIm more used to Sets from other Programming languages that are a (finite) collection of unique items instead of a predicate on a type</p>",
        "id": 423862230,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1709139440
    },
    {
        "content": "<p>Predicates do not generate executable code by default</p>",
        "id": 423863638,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1709139872
    },
    {
        "content": "<p>There are some computations done on SimpleGraph, but the way these work is that they make use of the Fintype and Decidable typeclasses to register computations for particular SimpleGraphs.</p>\n<ul>\n<li><code>DecidableRel G.Adj</code> with <code>Fintype V</code> is essentially an adjacency matrix representation</li>\n<li><code>Fintype (G.neighborSet v)</code> for all <code>v</code> gives you an adjacency list representation</li>\n</ul>\n<p>In the Connectivity module, there are for example algorithms to compute whether a graph is connected. Horrible algorithms that you never want to evaluate, but they're technically still algorithms.</p>\n<p>You may say you're not interested in efficient algorithms, but if you want to compute anything at all, I think you'll say you want an efficient algorithm (there's a difference between efficient and optimal after all).</p>",
        "id": 423902396,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709154065
    },
    {
        "content": "<p>Using <code>Set</code> in the definition of SimpleGraph is making SimpleGraph be a sort of abstract definition of a graph, with no concrete data structure, but every data structure for a simple graph can be converted to a SimpleGraph, and they can provide classes for various computations. In Mathlib, we don't have any concrete data structures for graphs.</p>\n<p>There's an example data structure in the Königsberg bridge problem in the Archive <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Archive/Wiedijk100Theorems/Konigsberg.lean\">here</a>, where the graph is created from a list of adjacent vertex pairs.</p>",
        "id": 423903043,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709154344
    },
    {
        "content": "<p>thanks for the explanation, the example has been useful</p>",
        "id": 423990815,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1709202883
    }
]