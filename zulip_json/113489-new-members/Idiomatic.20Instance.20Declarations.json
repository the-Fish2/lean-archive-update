[
    {
        "content": "<p>In mathlib, I've noticed that instance declarations often tend to just call separately defined functions. So instead of </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">instFooString</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"n\">Foo</span> <span class=\"n\">where</span>\n    <span class=\"n\">toString</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"s2\">\"Bar\"</span>\n</code></pre></div>\n<p>I see something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Foo.toString</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"s2\">\"Bar\"</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instFooString</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"n\">Foo</span> <span class=\"n\">where</span>\n    <span class=\"n\">toString</span> <span class=\"o\">:=</span> <span class=\"n\">Foo.toString</span>\n</code></pre></div>\n<hr>\n<p>It seems like these should be roughly equivalent. Is there a pragmatic reason beyond style to prefer one over the other? My only guess is that you can save the compiler a Typeclass lookup when you write something like <code>f.toString</code> to call the function directly.</p>",
        "id": 417657328,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1706106742
    },
    {
        "content": "<p>Usually the first one is preferrable in mathlib</p>",
        "id": 417663675,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706108584
    },
    {
        "content": "<p>If you write the second one, you then need to write a lemma that says <code>Foo.toString f = toString f</code></p>",
        "id": 417663756,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706108606
    },
    {
        "content": "<blockquote>\n<p>My only guess is that you can save the compiler a Typeclass lookup when you write something like f.toString to call the function directly.</p>\n</blockquote>\n<p>This is a false economy because now you have a spelling of <code>toString</code> that there are no theorems about!</p>",
        "id": 417663862,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706108635
    },
    {
        "content": "<p>(though <code>toString</code> is a bad example; think <code>Nat.mul m n</code> vs <code>m * n</code>)</p>",
        "id": 417663955,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706108649
    },
    {
        "content": "<p>Nat.mul seems to follow the second style?</p>",
        "id": 417664614,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1706108832
    },
    {
        "content": "<p>Or like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Nat.lt</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Nat.le</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">m</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">LT</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span>\n  <span class=\"n\">lt</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.lt</span>\n</code></pre></div>\n<p>instead of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">LT</span> <span class=\"n\">Nat</span> <span class=\"n\">where</span>\n  <span class=\"n\">lt</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.le</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">m</span>\n</code></pre></div>",
        "id": 417665705,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1706109140
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"664276\">Treq</span> <a href=\"#narrow/stream/113489-new-members/topic/Idiomatic.20Instance.20Declarations/near/417664614\">said</a>:</p>\n<blockquote>\n<p>Nat.mul seems to follow the second style?</p>\n</blockquote>\n<p>Yes, Eric is saying that it doesn't have many theorems proved about it in the form Nat.mul a b, so it's awkward to work with.</p>",
        "id": 417668330,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706109913
    },
    {
        "content": "<p>Right. Okay, I follow</p>",
        "id": 417668984,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1706110102
    },
    {
        "content": "<p>There's a pragmatic reason in the generated code: the compiler usually inlines instance definitions, so having a separate definition prevents the compiler from inlining the main definition. If the definition is complicated, like a big <code>match</code> expression, this can save a lot on compilation time. I had one case that improved the compilation time by around 10x if I remember correctly.</p>",
        "id": 417670359,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706110488
    },
    {
        "content": "<p>With <code>Nat.mul</code> and the like, one reason I believe is to have a definition that the kernel can know the name of, since it contains code to accelerate the computation using a bignum library, rather than by evaluating it by the Lean definition.</p>",
        "id": 417670787,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706110611
    },
    {
        "content": "<p>I think my takeaway is this: I should expect to see both styles in wild. I should prefer the first style unless I have pragmatic reasons to move to the second.</p>",
        "id": 417672139,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1706111013
    },
    {
        "content": "<p>Another reason to use an instance that points at a definition is that at \"instance reducibility\", used by instance search, it will unfold instances but not regular definitions. So if you have a big and complicated definition then this trick will avoid it getting unfolded during instance search. This is usually a good idea once you get past the \"record containing more records\" stage.</p>",
        "id": 418397984,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706341837
    }
]