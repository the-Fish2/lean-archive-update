[
    {
        "content": "<p>I am trying to define the integers with a quotient (of pairs of naturals) instead of with an inductive type as an exercise. I would like to make a function which pattern matches inputs based on my defined constants and then proceeds recursively. For example, consider the following function on my quotient type Z: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mult2</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">mult2</span> <span class=\"n\">z</span>\n  <span class=\"bp\">|</span> <span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">-</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">mult2</span> <span class=\"n\">z</span>\n</code></pre></div>\n<p>I have already implemented addition, ofNat, etc in a sensible manner. How can I do this?</p>",
        "id": 426793718,
        "sender_full_name": "Brandon Harad",
        "timestamp": 1710524690
    },
    {
        "content": "<p>You'll have to ask someone more CS-oriented about how to get the notation working (if indeed it's even possible) but there's nothing stopping you defining <code>MyInt.pos_neg_rec</code> or whatever you want to call it, which eats a type <code>X</code>, a term <code>x0 : X</code> and two  functions Nat x X -&gt; X, and spits out a function Int -&gt; X satisfying the identities you want; you can then define functions recursively using this.</p>",
        "id": 426808506,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710530851
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">MyInt</span> <span class=\"o\">:=</span> <span class=\"n\">ℤ</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"c1\">-- we want to allow `Prop` and `Type` so we can do induction and recursion.</span>\n<span class=\"c1\">-- So we let the \"motive\" of the recursor take values in `Sort u`, because `Sort 0 = Prop`</span>\n<span class=\"c1\">-- and `Sort 1 = Type`.</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MyInt.pos_neg_rec_on</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">MyInt</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">m0</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mpos</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">M</span> <span class=\"bp\">↑</span><span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">mneg</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"bp\">-↑</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"bp\">-↑</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">MyInt</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- hard exercise!</span>\n\n<span class=\"c1\">-- specification</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">MyInt</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">m0</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mpos</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">M</span> <span class=\"bp\">↑</span><span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">mneg</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"bp\">-↑</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"bp\">-↑</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">pos_neg_rec_on_zero</span> <span class=\"o\">:</span> <span class=\"n\">MyInt.pos_neg_rec_on</span> <span class=\"n\">m0</span> <span class=\"n\">mpos</span> <span class=\"n\">mneg</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">m0</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">pos_neg_rec_on_pos</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">MyInt.pos_neg_rec_on</span> <span class=\"n\">m0</span> <span class=\"n\">mpos</span> <span class=\"n\">mneg</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">mpos</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">MyInt.pos_neg_rec_on</span> <span class=\"n\">m0</span> <span class=\"n\">mpos</span> <span class=\"n\">mneg</span> <span class=\"bp\">↑</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">pos_neg_rec_on_neg</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">MyInt.pos_neg_rec_on</span> <span class=\"n\">m0</span> <span class=\"n\">mpos</span> <span class=\"n\">mneg</span> <span class=\"o\">(</span><span class=\"bp\">-↑</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">mneg</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">MyInt.pos_neg_rec_on</span> <span class=\"n\">m0</span> <span class=\"n\">mpos</span> <span class=\"n\">mneg</span> <span class=\"o\">(</span><span class=\"bp\">-↑</span><span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 426809365,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710531198
    },
    {
        "content": "<p>There is a <code>match_pattern</code> attribute, I don't remember exactly what the restrictions and capabilities are. The top answer here looks reasonable: <a href=\"https://proofassistants.stackexchange.com/questions/2438/why-can-addition-be-used-in-pattern-matching-nats-but-not-multiplication\">https://proofassistants.stackexchange.com/questions/2438/why-can-addition-be-used-in-pattern-matching-nats-but-not-multiplication</a></p>\n<p>I don't recall them using pattern matching, but this definition of the integers is a section in Logical Verification (chapter 12) if you're interested in seeing how others did it at some point (<a href=\"https://github.com/blanchette/logical_verification_2023/tree/main\">https://github.com/blanchette/logical_verification_2023/tree/main</a>).</p>",
        "id": 426809556,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1710531274
    },
    {
        "content": "<p>I guess the way to define this in your situation is first to define an analogous function on Nat x Nat and then prove it descends (or \"lifts\", as the computer scientists call it) to Int. These things are quite tricky :-)</p>",
        "id": 426809786,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710531370
    },
    {
        "content": "<p>I don't think they make the recursor in LV though (and neither do I in my treatment <a href=\"https://gist.github.com/kbuzzard/35bf66993e99cbcd8c9edc4914c9e7fc\">here</a> ).</p>",
        "id": 426810154,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710531538
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228466\">@Chris Bailey</span> <code>match_pattern</code> won't work here -- a way to think about that attribute is that it could also be called <code>pattern_inline</code>. In matches, definitions with this attribute get inlined, and it has to be a valid pattern involving constructors of inductive types in th eend.</p>",
        "id": 426851767,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710555809
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"699800\">@Brandon Harad</span> A lot of times it's better to define something as a quotient by not using <code>Quot</code>, but instead by realizing there is a normal form. Then, you define the <code>Quot</code> API for this. The point is that quotients should be thought of in terms of their universal properties, so you don't need to literally work with <code>Quot</code> itself.</p>\n<p>This doesn't help with your <code>match</code> question (I'm not sure there's a way to do that), but I thought I'd mention it.</p>\n<p>For example, rather than a quotient on pairs, you can define a subtype on pairs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span> <span class=\"bp\">//</span> <span class=\"n\">p.1</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"n\">p.2</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>And then the constructor can be defined using normalization:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Z.mk</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"n\">Or.inr</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Z.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Z.mk_zero_snd</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Z.mk</span> <span class=\"n\">a</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"o\">⟨(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"n\">Or.inr</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Z.mk_zero_fst</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Z.mk</span> <span class=\"mi\">0</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"o\">⟨(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Z.ind</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">Z.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩,</span> <span class=\"n\">h</span> <span class=\"bp\">|</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">q</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">subst_vars</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">Z.mk_zero_fst</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">mk</span> <span class=\"mi\">0</span> <span class=\"n\">b</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">Z.mk_zero_snd</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">mk</span> <span class=\"n\">a</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Z.lift</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">a'</span> <span class=\"n\">b'</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b'</span> <span class=\"bp\">=</span> <span class=\"n\">a'</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a'</span> <span class=\"n\">b'</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"n\">f</span> <span class=\"n\">n.1.1</span> <span class=\"n\">n.1.2</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Z.mk_eq_of_ge</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≥</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Z.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"o\">⟨(</span><span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"n\">Or.inr</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">a</span> <span class=\"n\">generalizing</span> <span class=\"n\">b</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">subst_vars</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">next</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">cases</span> <span class=\"n\">b</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Z.mk_zero_snd</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Z.mk</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">omega</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Z.mk_eq_of_le</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Z.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"o\">⟨(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">b</span> <span class=\"n\">generalizing</span> <span class=\"n\">a</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">subst_vars</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">next</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">cases</span> <span class=\"n\">a</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Z.mk_zero_fst</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Z.mk</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">omega</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Z.lift_mk</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">a'</span> <span class=\"n\">b'</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b'</span> <span class=\"bp\">=</span> <span class=\"n\">a'</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a'</span> <span class=\"n\">b'</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Z.lift</span> <span class=\"n\">f</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">Z.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">Z.lift</span>\n  <span class=\"n\">obtain</span> <span class=\"n\">hab</span><span class=\"bp\">|</span><span class=\"n\">hab</span> <span class=\"o\">:=</span> <span class=\"n\">le_or_gt</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Z.mk_eq_of_le</span> <span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n    <span class=\"n\">dsimp</span>\n    <span class=\"n\">omega</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Z.mk_eq_of_ge</span> <span class=\"n\">hab.le</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n    <span class=\"n\">dsimp</span>\n    <span class=\"n\">omega</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Z.sound</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">a'</span> <span class=\"n\">b'</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b'</span> <span class=\"bp\">=</span> <span class=\"n\">a'</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Z.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">Z.mk</span> <span class=\"n\">a'</span> <span class=\"n\">b'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"n\">hab</span><span class=\"bp\">|</span><span class=\"n\">hab</span> <span class=\"o\">:=</span> <span class=\"n\">le_or_gt</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;;&gt;</span>\n  <span class=\"n\">obtain</span> <span class=\"n\">hab'</span><span class=\"bp\">|</span><span class=\"n\">hab'</span> <span class=\"o\">:=</span> <span class=\"n\">le_or_gt</span> <span class=\"n\">a'</span> <span class=\"n\">b'</span> <span class=\"bp\">&lt;;&gt;</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">Subtype.ext</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Z.mk_eq_of_le</span><span class=\"o\">,</span> <span class=\"n\">Z.mk_eq_of_ge</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"n\">hab'</span><span class=\"o\">,</span> <span class=\"n\">LT.lt.le</span><span class=\"o\">]</span>\n    <span class=\"n\">omega</span>\n</code></pre></div>\n<p>For example, here's how you could define addition using this API:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Z.add</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span>\n  <span class=\"n\">x.lift</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">y.lift</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Z.mk</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">))</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">h</span>\n    <span class=\"n\">dsimp</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Z.sound</span>\n    <span class=\"n\">omega</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">h</span>\n  <span class=\"n\">dsimp</span>\n  <span class=\"n\">congr</span><span class=\"bp\">!</span> <span class=\"mi\">3</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Z.sound</span>\n  <span class=\"n\">omega</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Z.add_mk</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Z.add</span> <span class=\"o\">(</span><span class=\"n\">Z.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Z.mk</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Z.mk</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Z.add</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 426857339,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710561174
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> did you just tag the wrong Brando(n)? (If so, note that at least a few years ago, editing your post doesn't tag the new person)</p>",
        "id": 426879630,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710584288
    },
    {
        "content": "<p>Note that the disadvantage of the subtype definition is that the API for the algebra structure on the integers becomes more fiddly to write (you're constantly having to break into cases when defining and proving). But it's a one time cost.</p>",
        "id": 426879955,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710584618
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Pattern.20matching.20on.20quotient.20types/near/426808506\">said</a>:</p>\n<blockquote>\n<p>... there's nothing stopping you defining <code>MyInt.pos_neg_rec</code> or whatever you want to call it, ...</p>\n</blockquote>\n<p>When you do this, you should tag it <code>@[elab_as_elim]</code> to make it a little easier to use</p>",
        "id": 426885871,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710590654
    },
    {
        "content": "<p>(Oops, yes, I tagged the wrong Brandon. Edited it.)</p>",
        "id": 426896692,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710600234
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> With what I wrote, now you never have to open up the definition ever again. You use the universal property of the quotient.</p>",
        "id": 426896763,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710600276
    },
    {
        "content": "<p>I extended the code in the message, and it includes this example of how to then define addition without breaking <code>Z</code> open:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Z.add</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span>\n  <span class=\"n\">x.lift</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">y.lift</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Z.mk</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">))</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">h</span>\n    <span class=\"n\">dsimp</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Z.sound</span>\n    <span class=\"n\">omega</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">h</span>\n  <span class=\"n\">dsimp</span>\n  <span class=\"n\">congr</span><span class=\"bp\">!</span> <span class=\"mi\">3</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Z.sound</span>\n  <span class=\"n\">omega</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Z.add_mk</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Z.add</span> <span class=\"o\">(</span><span class=\"n\">Z.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Z.mk</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Z.mk</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Z.add</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 426897907,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710601294
    },
    {
        "content": "<p>The theorem <code>Z.sound</code> is sort of \"responsible\" for doing the case analysis you're talking about. That's now wrapped up in a theorem though, so you never have to do it again.</p>",
        "id": 426898080,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710601444
    },
    {
        "content": "<p>Interesting implementation. I hadn't thought of that. Thank you all.</p>",
        "id": 426943233,
        "sender_full_name": "Brandon Harad",
        "timestamp": 1710633288
    },
    {
        "content": "<p>One small advantage of working with literal quotients instead of a normal form is that they allow <code>lift_mk</code> to be true by definition</p>",
        "id": 426948162,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710634609
    },
    {
        "content": "<p>Perhaps there should be something like <code>csimp</code> for associating a normal form to a quotient, as the normal form is more efficient for actual computation</p>",
        "id": 426948376,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710634667
    },
    {
        "content": "<p>Well, you could always write an identity function that normalizes the underlying term of a quotient, and then use <code>@[csimp]</code> lemmas to swap the operations out for ones that insert this normalizer.</p>\n<p>If you don't combine normalization with operations, I'm not sure where the compiler would insert normalization.</p>\n<p>Or maybe you mean it could be <code>@[csimp]</code> for quotient types themselves? Where you can tell the compiler to use another type that implements the whole interface and universal property of being a quotient?</p>",
        "id": 426954832,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710636432
    }
]