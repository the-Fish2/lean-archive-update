[
    {
        "content": "<p>Hi, I read this sentence in mathematics in Lean and am very curious what it means: \"the type class system assumes every type has only one instance of each type class\". <br>\nHow does the type class system deal with sets which can have multiple of a certain structure then?</p>",
        "id": 447831217,
        "sender_full_name": "VayusElytra",
        "timestamp": 1719595713
    },
    {
        "content": "<p>Typically the answer is that a type synonym is introduced. The idea is you \"wrap\" the type with something to create a new type. Then APIs are introduced to allow you to view elements of the type however you need. Take a look at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lex#doc\">docs#Lex</a> and stuff around it to see how it works for putting a lexicographic order on, say, a product type.</p>",
        "id": 447832813,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1719596160
    },
    {
        "content": "<p>It looks like the passage clarifies right after by giving the example that additive and multiplicative structures are implemented separately and harmonized later.</p>\n<p>I would probably have expressed the idea differently; you can declare more than one instance of a class for a given type, but only one instance is actually \"picked\" during resolution, or you specify which one you're talking about manually.</p>",
        "id": 447842355,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1719599100
    },
    {
        "content": "<p>Makes sense, thank you both. How does one specify this in practice?</p>",
        "id": 447844355,
        "sender_full_name": "VayusElytra",
        "timestamp": 1719599594
    },
    {
        "content": "<p>Anywhere an \"inst impliclt\"/typeclass parameter appears, you can choose to specify what you want instead of having Lean do it for you (either via named args or by exposing all implicits with <code>@</code>) like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">myInhabited</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">myInhabited</span><span class=\"bp\">.</span><span class=\"n\">default</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">instInhabitedNat0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">instInhabitedNat1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"c1\">-- 0</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">myInhabited</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">instInhabitedNat0</span><span class=\"o\">)</span>\n<span class=\"c1\">-- 1</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">instInhabitedNat1</span>\n</code></pre></div>\n<p>In practice with complex classes that express structure this gets very messy, which I think is part of the motivation for implementing them separately as the author describes. There are also practical issues like the operation for <code>Group</code> being a field and not a parameter, but I think that gets into stuff that the mathlib people or someone who has more intimate knowledge of those design decisions would be better able to speak to.</p>",
        "id": 447846159,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1719600180
    }
]