[
    {
        "content": "<p>Hey, everybody!  I'm Jonathan.  Nice to meet y'all.</p>\n<p>I'm new to Theorem Proving/Formal Methods and I'm actually really enjoying it.  I've been teaching myself from a few resources I found online, but primarily <em>Theorem Proving in Lean</em> and the <em>Software Foundation</em> series.  I've been doing SF in Lean because I like the language better than Coq.</p>\n<p>I was doing well with it until I got to inductively defined propositions.  I'm fundamentally not quite grokking something about them.  I get how they're supposed to work from my experience with <em>Types and Programming Languages</em> (I'm a compiler geek), but I'm struggling to actually manipulate the values in Lean to construct proofs.  Unfortunately, I don't quite understand what I don't understand so I haven't been able to ask a coherent question about it.</p>\n<p>But I think I finally found an illustrative example.  I've put it up in a <a href=\"https://gist.github.com/watersofoblivion/9646164deb5c1901413d64ba9f2a49b9\">Gist</a> with a lot of comments and some specific questions.  If I could get some feedback/help with it I would appreciate it.</p>\n<p>Thanks!</p>",
        "id": 417369496,
        "sender_full_name": "Jonathan Bryant",
        "timestamp": 1705984623
    },
    {
        "content": "<p>I think one of your questions is \"what is the lean analogue of the Coq <code>inversion</code> tactic?\" and I've heard before that the answer is <code>cases</code>.</p>",
        "id": 417381388,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705992693
    },
    {
        "content": "<p>See for example <a href=\"#narrow/stream/270676-lean4/topic/Behaviour.20of.20.60cases.60.20depends.20on.20type.20constructor.20args'.20order\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Behaviour.20of.20.60cases.60.20depends.20on.20type.20constructor.20args'.20order</a></p>",
        "id": 417381914,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705993018
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 417382204,
        "sender_full_name": "A.",
        "timestamp": 1705993175
    },
    {
        "content": "<p>Apologies, these responses purely in code probably weren't very helpful. I have deleted them and hopefully someone who knows something about the internals of Lean will come up with real explanations.</p>",
        "id": 417383489,
        "sender_full_name": "A.",
        "timestamp": 1705993866
    },
    {
        "content": "<p>Well, asking the question made it clearer for me.  After sleeping on it, for the term-style it was a one-liner:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">mp</span><span class=\"o\">:</span> <span class=\"n\">CommandEval</span> <span class=\"o\">(</span><span class=\"n\">Command.seq</span> <span class=\"bp\">.</span><span class=\"n\">skip</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span> <span class=\"bp\">→</span> <span class=\"n\">CommandEval</span> <span class=\"n\">c</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">seq</span> <span class=\"bp\">.</span><span class=\"n\">skip</span> <span class=\"n\">c</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">s₃</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">skip</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">h₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h₂</span>\n</code></pre></div>\n<p>I realized that I didn't need to show the equivalence explicitly.  By matching <code>_</code> for s1 and s2 while on <code>(.skip s)</code> for h1, it implicitly figured out the equality for me.  Once I figured that out, for the tactic style I immediately came up with exactly what <span class=\"user-mention\" data-user-id=\"111433\">@Alistair Tucker</span> suggested and it worked.</p>\n<p>I've found other cases where I fiddled with it long enough and came across similar solutions.  It's another case of once I saw it it made sense, but I couldn't actively reason towards the solution.  Maybe what I don't understand is dependent pattern matching?  Any deeper dive resources on that?</p>",
        "id": 417462887,
        "sender_full_name": "Jonathan Bryant",
        "timestamp": 1706021671
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Help.20with.20Inductively.20Defined.20Propositions/near/417381388\">said</a>:</p>\n<blockquote>\n<p>I think one of your questions is \"what is the lean analogue of the Coq <code>inversion</code> tactic?\" and I've heard before that the answer is <code>cases</code>.</p>\n</blockquote>\n<p>Maybe?  <code>cases</code> seems to be roughly analogous to <code>destruct</code> from Coq, though admittedly it may be doing more behind the scenes than I realize.  There's several places where there's not 1:1 mappings between tactics so could be the case.  So far, I've been viewing <code>cases</code> as just that: a straightforward <code>case</code> or <code>match</code> construct.  Is there some hidden depth I'm missing?</p>",
        "id": 417463996,
        "sender_full_name": "Jonathan Bryant",
        "timestamp": 1706021944
    },
    {
        "content": "<p>Another reason I think my underlying gap might be dependent pattern matching is that I never would have expected the h2 in the nested <code>cases</code> to come up with the right set of state variables, so I never would have thought to use it to get the solve.  And I still don't understand how or why it did that.</p>",
        "id": 417465587,
        "sender_full_name": "Jonathan Bryant",
        "timestamp": 1706022384
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111433\">Alistair Tucker</span> <a href=\"#narrow/stream/113489-new-members/topic/Help.20with.20Inductively.20Defined.20Propositions/near/417383489\">said</a>:</p>\n<blockquote>\n<p>Apologies, these responses purely in code probably weren't very helpful. I have deleted them and hopefully someone who knows something about the internals of Lean will help you with real explanations.</p>\n</blockquote>\n<p>No, no, no.  Code is wonderful.  I speak code way more fluently than I speak math or meta-theory.</p>",
        "id": 417465826,
        "sender_full_name": "Jonathan Bryant",
        "timestamp": 1706022455
    },
    {
        "content": "<p>Maybe I can ask a more concrete question.  I understand \"normal\" pattern matching (for example, <a href=\"http://moscova.inria.fr/~maranget/papers/ml05e-maranget.pdf\">this paper by Maranget on compiling pattern matching to decision trees</a>).  Is there something that can extend that understanding to dependent pattern matching so that I can understand what's different and how it's resolving those cross-pattern dependencies?</p>",
        "id": 417469719,
        "sender_full_name": "Jonathan Bryant",
        "timestamp": 1706023543
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"685317\">Jonathan Bryant</span> <a href=\"#narrow/stream/113489-new-members/topic/Help.20with.20Inductively.20Defined.20Propositions/near/417465826\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"111433\">Alistair Tucker</span> <a href=\"#narrow/stream/113489-new-members/topic/Help.20with.20Inductively.20Defined.20Propositions/near/417383489\">said</a>:</p>\n<blockquote>\n<p>Apologies, these responses purely in code probably weren't very helpful. I have deleted them and hopefully someone who knows something about the internals of Lean will help you with real explanations.</p>\n</blockquote>\n<p>No, no, no.  Code is wonderful.  I speak code way more fluently than I speak math or meta-theory.</p>\n</blockquote>\n<p>Note that you can still see the code if you're on a computer -- just click the word \"EDITED\" by Alistair's name to see the edit history. Note <span class=\"user-mention\" data-user-id=\"111433\">@Alistair Tucker</span> this is one of several reasons why it's a bit silly to delete your helpful code.</p>",
        "id": 417470367,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706023715
    },
    {
        "content": "<p>I thought to leave them there might give the impression that I was \"on the case\".</p>",
        "id": 417473914,
        "sender_full_name": "A.",
        "timestamp": 1706024710
    },
    {
        "content": "<p><strong>Unification.</strong>  That's what I was missing.  Specifically, Higher-Order Unification.</p>\n<p>Once I figured that out, I made <a href=\"https://github.com/watersofoblivion/learning-lean/blob/main/SoftwareFoundations/ProgrammingLanguageFoundations/Equiv.lean\">tons</a> of <a href=\"https://github.com/watersofoblivion/learning-lean/blob/main/SoftwareFoundations/ProgrammingLanguageFoundations/SmallStep.lean\">progress</a>.  It also answered a bunch of other queestions I had that I couldn't even articulate.  So I'll take the time to answer my own question here in the hope that if anyone searches and stumbles across this thread, it will help.</p>\n<p>In the original example, I was asking why I couldn't compute the \"obviously\" true <code>sorry</code> below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Command</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">skip</span><span class=\"o\">:</span> <span class=\"n\">Command</span>\n  <span class=\"c1\">-- ... Other constructors ...</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">CommandEval</span><span class=\"o\">:</span> <span class=\"n\">Command</span> <span class=\"bp\">→</span> <span class=\"n\">State</span> <span class=\"bp\">→</span> <span class=\"n\">State</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">skip</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">):</span> <span class=\"n\">CommandEval</span> <span class=\"bp\">.</span><span class=\"n\">skip</span> <span class=\"n\">s</span> <span class=\"n\">s</span>\n  <span class=\"bp\">|</span> <span class=\"n\">assign</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"n\">Arith</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">id</span><span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">e.eval</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">):</span> <span class=\"n\">CommandEval</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">assign</span> <span class=\"n\">id</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">s.update</span> <span class=\"n\">id</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">seq</span> <span class=\"o\">{</span><span class=\"n\">c₁</span> <span class=\"n\">c₂</span><span class=\"o\">:</span> <span class=\"n\">Command</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s₁</span> <span class=\"n\">s₂</span> <span class=\"n\">s₃</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"o\">:</span> <span class=\"n\">CommandEval</span> <span class=\"n\">c₁</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span><span class=\"o\">:</span> <span class=\"n\">CommandEval</span> <span class=\"n\">c₂</span> <span class=\"n\">s₂</span> <span class=\"n\">s₃</span><span class=\"o\">):</span> <span class=\"n\">CommandEval</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">seq</span> <span class=\"n\">c₁</span> <span class=\"n\">c₂</span><span class=\"o\">)</span> <span class=\"n\">s₁</span> <span class=\"n\">s₃</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ifTrue</span> <span class=\"o\">{</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">Logic</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">Command</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s₁</span> <span class=\"n\">s₂</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"o\">:</span> <span class=\"n\">c.eval</span> <span class=\"n\">s₁</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span><span class=\"o\">:</span> <span class=\"n\">CommandEval</span> <span class=\"n\">t</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span><span class=\"o\">):</span> <span class=\"n\">CommandEval</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"k\">if</span> <span class=\"n\">c</span> <span class=\"n\">t</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ifFalse</span> <span class=\"o\">{</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">Logic</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">Command</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s₁</span> <span class=\"n\">s₂</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"o\">:</span> <span class=\"n\">c.eval</span> <span class=\"n\">s₁</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span><span class=\"o\">:</span> <span class=\"n\">CommandEval</span> <span class=\"n\">f</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span><span class=\"o\">):</span> <span class=\"n\">CommandEval</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"k\">if</span> <span class=\"n\">c</span> <span class=\"n\">t</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span>\n  <span class=\"bp\">|</span> <span class=\"n\">whileTrue</span> <span class=\"o\">{</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">Logic</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">Command</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s₁</span> <span class=\"n\">s₂</span> <span class=\"n\">s₃</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"o\">:</span> <span class=\"n\">c.eval</span> <span class=\"n\">s₁</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span><span class=\"o\">:</span> <span class=\"n\">CommandEval</span> <span class=\"n\">b</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₃</span><span class=\"o\">:</span> <span class=\"n\">CommandEval</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">while</span> <span class=\"n\">c</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">s₂</span> <span class=\"n\">s₃</span><span class=\"o\">):</span> <span class=\"n\">CommandEval</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">while</span> <span class=\"n\">c</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">s₁</span> <span class=\"n\">s₃</span>\n  <span class=\"bp\">|</span> <span class=\"n\">whileFalse</span> <span class=\"o\">{</span><span class=\"n\">c</span><span class=\"o\">:</span> <span class=\"n\">Logic</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">Command</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">State</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"o\">:</span> <span class=\"n\">c.eval</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">false</span><span class=\"o\">):</span> <span class=\"n\">CommandEval</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">while</span> <span class=\"n\">c</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"n\">CommandEval</span> <span class=\"o\">(</span><span class=\"n\">Command.seq</span> <span class=\"bp\">.</span><span class=\"n\">skip</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span> <span class=\"bp\">→</span> <span class=\"n\">CommandEval</span> <span class=\"n\">c</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">seq</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span> <span class=\"n\">s₃</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₃</span><span class=\"o\">:</span> <span class=\"n\">s₁</span> <span class=\"bp\">=</span> <span class=\"n\">s₂</span> <span class=\"o\">:=</span>\n      <span class=\"gr\">sorry</span>\n    <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">h₃</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₂</span>\n      <span class=\"n\">exact</span> <span class=\"n\">h₂</span>\n</code></pre></div>\n<p>But the following <em>much simpler</em> code <em>did</em> work, as if by magic:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"n\">CommandEval</span> <span class=\"o\">(</span><span class=\"n\">Command.seq</span> <span class=\"bp\">.</span><span class=\"n\">skip</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span> <span class=\"bp\">→</span> <span class=\"n\">CommandEval</span> <span class=\"n\">c</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">seq</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">skip</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h₂</span>\n</code></pre></div>\n<p>That \"magic\" is <strong>Unification</strong>.  I'm used to thinking of unification as something that happens at the type level, as in Hindley-Milner inference.  But since Lean is dependently typed, types and terms are interchangeable.  So Lean is performing (higher-order) unification over not just the type the <em>entire expression</em>: types, terms, everything.</p>\n<p>What's happening is that when I leave the states (the <code>s₁</code>, <code>s₂</code>, and <code>s₃</code>) as holes (<code>_</code>) for the unifier to figure out and explicitly write out that the first hypothesis <code>h₁</code> is the term <code>(.skip _)</code>, itself with a hole, the unifier automatically deduces that since the type of the <code>.skip _</code> is <code>CommandEval .skip s s</code>, the holes for <code>s₁</code> and <code>s₂</code> as well as the hole for the state of the <code>.skip</code> must all be equal, which is exactly what I was trying to prove explicitly.</p>\n<p>This understanding that unification is happening everywhere also answered several other questions:</p>\n<ul>\n<li><em>Why don't I have to explicitly list all combinatorial patterns, but also not have to put wildcard <code>_</code> patterns?</em>  Because unification is being performed.  Any pattern that can't possibly unify with the result is automatically excluded.</li>\n<li><em>What's the Lean equivalent of the <code>inversion</code> tactic and why is it <code>cases</code>?</em>  Because unification.  Just like matching, the <code>cases</code> tactic (as well as the <code>induction</code> tactic) performs unification and excludes any cases that can't possibly unify.  This is precisely what Coq's <code>inversion</code> tactic is doing: using evidence to exclude unreachable possibilities.</li>\n<li><em>Why did I have to explicitly handle my <code>ifTrue</code>/<code>ifFalse</code> and <code>whileTrue</code>/<code>whileFalse</code> cases?</em>  You guessed it: unification!  When the type of the proposition is <code>CommandEval (.if ...) ...</code>, <em>either</em> of the <code>ifTrue</code> and <code>ifFalse</code> rules could unify with it, so both have to be handled, even if one is immediately contradictory.  Similar for the <code>CommandEval (.while ...) ...</code> types.</li>\n<li><em>Why, if the <code>apply</code> tactic is interactive function application, do I only have to give <strong>some</strong> of the arguments, not <strong>all</strong>?  How come which ones I specify seems to change as I work through the proof?</em>  Because you only have to supply the arguments the unifier can't come up with on its own.  If you give an argument (with <code>exact</code> or <code>assumption</code> or <code>trivial</code> or some other tactic) that happens to be dependent type, it helps the unifier unify away more arguments from the environment and it can shorten the list of arguments you need to provide.</li>\n<li><em>How do implicit arguments work?  How do I know what can be implicit?</em>  Implicit arguments are arguments that you are specifically saying the unifier <em>should</em> be able to work out on its own from the context.  Specifically, they should be arguments that are dependended on by later types, since there are no other values that those arguments could possibly be.  In the above type, all the <code>Command</code> values (as well as <code>Nat</code>, <code>String</code>, <code>Logic</code>, and <code>Arith</code>) values are implicit because they're mentioned in the non-implicit hypotheses arguments.  All of the <code>State</code> arguments could also be made implicit since they're mentioned in those non-implicit arguments as well.  (They were left explicit here for the purposes of illustrating the answer to the question.)</li>\n</ul>\n<p>This makes Lean's already impressive pattern matching facilities just that much more powerful.  In Lean, you can match on any inductive type.  And since it's the Calculus of <em>Inductive</em> Constructions, <em>everything</em> is an inductive type (which TPiL does a good job of pointing out.)  So now I'm letting my guiding mantra be \"Match. All. The. Things.\" and it's working a lot better.</p>\n<p>Thanks <span class=\"user-mention\" data-user-id=\"111433\">@Alistair Tucker</span> and <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> for your initial help.</p>",
        "id": 419374404,
        "sender_full_name": "Jonathan Bryant",
        "timestamp": 1706842450
    },
    {
        "content": "<p>But now I have a new question.  I'm trying to prove transitivity of certain relations, specifically the Transitive and the Reflexive Transitive closure of other Relations.</p>\n<p>I can do the proof using tactics (<code>section ProveTheSorry</code>), but when I try to create the induction hypothesis manually using a recursive call, it complains that I didn't prove termination and my call is not structural induction.  I'm doing a nearly identical thing <a href=\"https://github.com/watersofoblivion/learning-lean/blob/main/SoftwareFoundations/ProgrammingLanguageFoundations/SmallStep.lean#L88-L120\">here</a> (and other places), so I know the basic technique works.  And the <code>h_y</code> is a sub-term, so it would intuitively seem that this call would work.</p>\n<p>Any hints as to why Lean doesn't like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Relation</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">):</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">TClos</span> <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"n\">Relation</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">Relation</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">base</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hxy</span><span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">):</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n  <span class=\"bp\">|</span> <span class=\"n\">step</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hxy</span><span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hyz</span><span class=\"o\">:</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">):</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">z</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">RTClos</span> <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"n\">Relation</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">Relation</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}:</span> <span class=\"n\">RTClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">step</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hxy</span><span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hyz</span><span class=\"o\">:</span> <span class=\"n\">RTClos</span> <span class=\"n\">R</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">):</span> <span class=\"n\">RTClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">z</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">TClos.transitive</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"n\">Relation</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}:</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">z</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">base</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">hyz</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">step</span> <span class=\"n\">h</span> <span class=\"n\">hyz</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">step</span> <span class=\"n\">hx_</span> <span class=\"n\">h_y</span><span class=\"o\">,</span> <span class=\"n\">hyz</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"n\">ih</span><span class=\"o\">:</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">_</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">_</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n      <span class=\"c1\">-- Why does this fail to be structurally inductive?</span>\n      <span class=\"c1\">-- | hyz =&gt; TClos.transitive h_y hyz</span>\n    <span class=\"bp\">.</span><span class=\"n\">step</span> <span class=\"n\">hx_</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"n\">hyz</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">RTClos.transitive</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"n\">Relation</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}:</span> <span class=\"n\">RTClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">RTClos</span> <span class=\"n\">R</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">RTClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">z</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"n\">hyz</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">hyz</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">step</span> <span class=\"n\">hx_</span> <span class=\"n\">h_y</span><span class=\"o\">,</span> <span class=\"n\">hyz</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"n\">ih</span><span class=\"o\">:</span> <span class=\"n\">RTClos</span> <span class=\"n\">R</span> <span class=\"n\">_</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">RTClos</span> <span class=\"n\">R</span> <span class=\"n\">_</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n      <span class=\"c1\">-- Why does this fail to be structurally inductive?</span>\n      <span class=\"c1\">-- | hyz =&gt; RTClos.transitive h_y hyz</span>\n    <span class=\"bp\">.</span><span class=\"n\">step</span> <span class=\"n\">hx_</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"n\">hyz</span><span class=\"o\">)</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">ProveTheSorry</span>\n  <span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"n\">Relation</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hxy</span><span class=\"o\">:</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hyz</span><span class=\"o\">:</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">):</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">induction</span> <span class=\"n\">hxy</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">base</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">apply</span> <span class=\"n\">TClos.step</span>\n        <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">h</span>\n        <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">hyz</span>\n      <span class=\"bp\">|</span> <span class=\"n\">step</span> <span class=\"n\">hx_</span> <span class=\"n\">h_y</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">apply</span> <span class=\"n\">TClos.step</span>\n        <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">hx_</span>\n        <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">ih</span>\n          <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">hyz</span>\n\n  <span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"n\">Relation</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hxy</span><span class=\"o\">:</span> <span class=\"n\">RTClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hyz</span><span class=\"o\">:</span> <span class=\"n\">RTClos</span> <span class=\"n\">R</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">):</span> <span class=\"n\">RTClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">induction</span> <span class=\"n\">hxy</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">hyz</span>\n      <span class=\"bp\">|</span> <span class=\"n\">step</span> <span class=\"n\">hx_</span> <span class=\"n\">h_y</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">apply</span> <span class=\"n\">RTClos.step</span>\n        <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">hx_</span>\n        <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">ih</span>\n          <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">hyz</span>\n<span class=\"kd\">end</span> <span class=\"n\">ProveTheSorry</span>\n</code></pre></div>",
        "id": 419375019,
        "sender_full_name": "Jonathan Bryant",
        "timestamp": 1706842950
    },
    {
        "content": "<p>This is because lean's equation compiler does not handle inductive propositions very well, it uses a compilation strategy that was designed for recursive functions and doesn't work in the inductive proposition case. <code>induction</code> is the workaround</p>",
        "id": 419425451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706868692
    },
    {
        "content": "<p>Note that lean's equation compiler does not actually support structural induction, it uses \"bounded induction\" instead using the <code>T.brecOn</code> function which is automatically defined, but this definition fails for prop inductives</p>",
        "id": 419425651,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706868766
    },
    {
        "content": "<p>in fact this example looks almost identical to the one in <a href=\"https://github.com/leanprover/lean4/pull/1672\">lean4#1672</a></p>",
        "id": 419425860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706868837
    },
    {
        "content": "<p><span aria-label=\"smiling face with tear\" class=\"emoji emoji-1f972\" role=\"img\" title=\"smiling face with tear\">:smiling_face_with_tear:</span> How unfortunate.</p>",
        "id": 419495315,
        "sender_full_name": "Jonathan Bryant",
        "timestamp": 1706892373
    },
    {
        "content": "<p>I'm extremely new to Lean (but have a good mathematical and programming background).</p>\n<p>I'm finding this example instructive to learn from. I have a couple of questions, some very basic. I've simplified the example to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Relation</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">):</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">TClos</span> <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"n\">Relation</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Relation</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">base</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hxy</span><span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n  <span class=\"bp\">|</span> <span class=\"n\">step</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hxy</span><span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hyz</span><span class=\"o\">:</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">z</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">right_hand_step</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"n\">Relation</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">z</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">base</span> <span class=\"n\">hxy</span><span class=\"o\">,</span> <span class=\"n\">hyz</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">step</span> <span class=\"n\">hxy</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">base</span> <span class=\"n\">hyz</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">step</span> <span class=\"n\">hxw</span> <span class=\"n\">hwy</span><span class=\"o\">,</span> <span class=\"n\">hyz</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">step</span> <span class=\"n\">hxw</span> <span class=\"o\">(</span><span class=\"n\">right_hand_step</span> <span class=\"n\">hwy</span> <span class=\"n\">hyz</span><span class=\"o\">)</span>\n</code></pre></div>\n<ol>\n<li>\n<p>What's the difference between <code>theorem</code> and <code>def</code>? (I scanned the docs, but didn't find anything. Searching for \"theorem\" is quite noisy...)</p>\n</li>\n<li>\n<p>Is there an explanation of the member access <code>.</code> in <code>.base</code>? (I understand that it is inferring <code>TClos</code> on the left somehow, but is there an explanation of precisely what can be inferred this way?)</p>\n</li>\n<li>\n<p>You can see that I want <code>hxw</code> in the last line to have type <code>R x w</code> but it actually has type <code>R x y✝</code> when I hover over it. Is there a way to do this? I tried replacing <code>hxw</code> with <code>(hxw : R x w)</code> but then I got an error about <code>w</code> being unknown. Adding <code>w</code> to the implicit argument list seems undesirable (because this is 'internal' to the definition) and in any case then causes an error in the second-last line because <code>w</code> can't be inferred in that line.</p>\n</li>\n<li>\n<p>Your answer \"<code>induction</code> is the workaround\" - is this what you mean? (Lean tells me it's correct, but is it what you meant?)</p>\n</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">right_hand_step</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"n\">Relation</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hxy</span> <span class=\"o\">:</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hyz</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">induction</span> <span class=\"n\">hxy</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">base</span> <span class=\"n\">hxy</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"bp\">.</span><span class=\"n\">step</span> <span class=\"n\">hxy</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">base</span> <span class=\"n\">hyz</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">step</span> <span class=\"n\">hxw</span> <span class=\"n\">_</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"bp\">.</span><span class=\"n\">step</span> <span class=\"n\">hxw</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"n\">hyz</span><span class=\"o\">)</span>\n</code></pre></div>\n<ol start=\"5\">\n<li>Is it possible to write this definition without tactics? (My rudimentary understanding of type theory suggests that there might be a term called an 'induction principle' or 'dependent eliminator' that I could use?)</li>\n</ol>\n<p>Apologies if any of this is in the various tutorials - I have had a quick look already.</p>",
        "id": 419530809,
        "sender_full_name": "Preeyan Parmar",
        "timestamp": 1706906130
    },
    {
        "content": "<p>i'm relatively new too, so it might not be entirely accurate, but i think one of the differences between <code>def</code> and <code>theorem</code> is that with <code>def</code>, lean \"remembers\" the content of the definition, while with <code>theorem</code>, it doesn't.</p>\n<p>a simple example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Init.Prelude</span>\n<span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- works</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- doesn't work</span>\n</code></pre></div>",
        "id": 419540464,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1706910711
    },
    {
        "content": "<p>from a mathematical standpoint, it makes sense to have such \"forgetful\" definitions, because often you don't care a lot about in what way you have proven a statement (read: created an object of a type), but just that there is one. also, (i'm guessing) some proofs of statements get <em>very</em> large, to the point that it isn't efficient to store the exact proof either.</p>",
        "id": 419541685,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1706911287
    },
    {
        "content": "<p>Somehow there's no <em>point</em> storing a proof, because in Lean any two proofs of a proposition are equal by definition. The only thing which needs storing is the fact that there is some proof.</p>",
        "id": 419541932,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706911416
    },
    {
        "content": "<p>well, i imagine storing it might make it slightly more efficient if you'd like to know what axioms you used after the fact, but that's hardly a main feature of the system. so it isn't exactly like there's <em>no</em> point, but the benefits are far outweighed by the downsides</p>",
        "id": 419542291,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1706911572
    },
    {
        "content": "<p>That's 1. answered. Many thanks.</p>\n<p>I've made some progress on 5. I needed to change the signature of <code>right_hand_step</code> a bit:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">right_hand_step</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"n\">Relation</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hxy</span> <span class=\"o\">:</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">.</span><span class=\"n\">rec</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">hxy</span> <span class=\"n\">hyz</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">step</span> <span class=\"n\">hxy</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">base</span> <span class=\"n\">hyz</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">hxw</span> <span class=\"n\">_</span> <span class=\"n\">ih</span> <span class=\"n\">hyz</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">step</span> <span class=\"n\">hxw</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"n\">hyz</span><span class=\"o\">))</span>\n    <span class=\"n\">hxy</span>\n</code></pre></div>\n<p>I'm not sure why, but I can't move <code>{z : \\alpha}</code> to the left of the colon, nor <code>hxy</code> to the right of the colon, without getting errors.</p>\n<p>I can satisfy the original signature of <code>right_hand_step</code> like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">right_hand_step</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"n\">Relation</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">temp</span> <span class=\"o\">(</span><span class=\"n\">hxy</span> <span class=\"o\">:</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">.</span><span class=\"n\">rec</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">hxy</span> <span class=\"n\">_</span> <span class=\"n\">hyz</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">step</span> <span class=\"n\">hxy</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">base</span> <span class=\"n\">hyz</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">hxw</span> <span class=\"n\">_</span> <span class=\"n\">ih</span> <span class=\"n\">z</span> <span class=\"n\">hyz</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">step</span> <span class=\"n\">hxw</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"n\">z</span> <span class=\"n\">hyz</span><span class=\"o\">))</span>\n      <span class=\"n\">hxy</span>\n  <span class=\"k\">fun</span> <span class=\"n\">hxy</span> <span class=\"n\">hyz</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">temp</span> <span class=\"n\">hxy</span> <span class=\"n\">z</span> <span class=\"n\">hyz</span>\n</code></pre></div>\n<p>However, I've had to make the <code>z</code> variable explicit (I don't know why) and also I haven't found a way to do this without the <code>let</code> - I would have thought that I could just substitute the definition of <code>temp</code>.</p>",
        "id": 419552789,
        "sender_full_name": "Preeyan Parmar",
        "timestamp": 1706917016
    },
    {
        "content": "<p>Note that lean <em>does</em> store the bodies of theorems currently; otherwise <code>#print</code> on a theorem wouldn't work (nor <code>#print axioms</code> as mentioned above, although you can precalculate this)</p>",
        "id": 419555214,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706918604
    },
    {
        "content": "<p>there have been discussions about pruning them in at least some compilation modes though</p>",
        "id": 419555236,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706918627
    },
    {
        "content": "<p>Regarding question 4, you can set the intermediate variable to have name <code>w</code> like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">right_hand_step</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"n\">Relation</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">z</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">base</span> <span class=\"n\">hxy</span><span class=\"o\">,</span> <span class=\"n\">hyz</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">step</span> <span class=\"n\">hxy</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">base</span> <span class=\"n\">hyz</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">step</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"n\">hxw</span> <span class=\"n\">hwy</span><span class=\"o\">,</span> <span class=\"n\">hyz</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">step</span> <span class=\"n\">hxw</span> <span class=\"o\">(</span><span class=\"n\">right_hand_step</span> <span class=\"n\">hwy</span> <span class=\"n\">hyz</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>although this doesn't fix the issue with the recursion</p>",
        "id": 419555639,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706918870
    },
    {
        "content": "<p>regarding 5, the more usual way to write <code>T.rec</code> functions without mentioning <code>T</code> is using the <code>(e).rec</code> form, because <code>T.rec</code> <em>takes</em> an argument of type <code>T</code>, it doesn't <em>return</em> one (in general); in this case it does which is why you can use the <code>.rec</code> form but I think this comes too late to resolve the implicit argument <code>z</code>. This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">right_hand_step</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"n\">Relation</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hxy</span> <span class=\"o\">:</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">TClos</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"o\">:=</span>\n  <span class=\"n\">hxy.rec</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">hxy</span> <span class=\"n\">hyz</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">step</span> <span class=\"n\">hxy</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">base</span> <span class=\"n\">hyz</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">hxw</span> <span class=\"n\">_</span> <span class=\"n\">ih</span> <span class=\"n\">hyz</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">step</span> <span class=\"n\">hxw</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"n\">hyz</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 419555991,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706919022
    },
    {
        "content": "<p>By the way you can see how this is done in mathlib - <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Relation.TransGen.trans_left#doc\">docs#Relation.TransGen.trans_left</a> - and it uses <code>induction</code> similar to your Q4</p>",
        "id": 419556335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706919282
    },
    {
        "content": "<p>Many thanks <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> !</p>\n<ol start=\"3\">\n<li>--&gt; makes complete sense, of course the type here is just an implicit argument to <code>TClos.step</code> and it can be passed explicitly as you say</li>\n<li>Cool, makes sense.</li>\n<li>I don't understand how <code>hxy.rec</code> works because <a href=\"https://lean-lang.org/functional_programming_in_lean/getting-to-know/structures.html\">https://lean-lang.org/functional_programming_in_lean/getting-to-know/structures.html</a> says \"If TARGET has type T, the function named T.f is called\", but doesn't <code>hxy</code> have type <code>TClos R x y</code> (which evaluates to <code>Prop</code>?) and isn't the recursor named <code>TClos.rec</code> ?</li>\n</ol>",
        "id": 419644618,
        "sender_full_name": "Preeyan Parmar",
        "timestamp": 1706997013
    },
    {
        "content": "<ol start=\"5\">\n<li>So f is <code>rec</code>, TARGET is <code>hxy</code> of type T = <code>TClos</code> so <code>TClos.rec</code> is called? I don't see the mismatch</li>\n</ol>",
        "id": 419644797,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706997167
    },
    {
        "content": "<p>Why does <code>(hxy : TClos R x y)</code> not mean that the type of <code>hxy</code> is <code>TClos R x y</code> ?</p>",
        "id": 419644923,
        "sender_full_name": "Preeyan Parmar",
        "timestamp": 1706997265
    },
    {
        "content": "<p>What makes you say it isn't?</p>",
        "id": 419644965,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706997312
    },
    {
        "content": "<p>Or do you mean the arguments to <code>TClos</code> are confusing you?</p>",
        "id": 419644982,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706997329
    },
    {
        "content": "<p>I don't understand the sense in which <code>hxy</code> has type <code>TClos</code>. (For example, if I had an <code>f : TClos -&gt; Nat</code> could I form <code>f hxy</code>?)</p>\n<p>(There's a chance I'm missing something silly here...)</p>",
        "id": 419645105,
        "sender_full_name": "Preeyan Parmar",
        "timestamp": 1706997411
    },
    {
        "content": "<p>Having played around a bit, I think the bit I'm missing is something like:</p>\n<ul>\n<li>type constructors are not functions Type --&gt; Type (they are more like syntactic extensions)</li>\n<li>in particular, type constructors are not types (<code>TClos</code> is not a type)</li>\n<li>but people still call it a type for convenience (and everyone knows what is meant (except me :)))</li>\n</ul>",
        "id": 419645702,
        "sender_full_name": "Preeyan Parmar",
        "timestamp": 1706997847
    },
    {
        "content": "<p>(And I think my original question 2. is answered by <a href=\"https://lean-lang.org/functional_programming_in_lean/monads/conveniences.html#leading-dot-notation\">https://lean-lang.org/functional_programming_in_lean/monads/conveniences.html#leading-dot-notation</a>)</p>",
        "id": 419648013,
        "sender_full_name": "Preeyan Parmar",
        "timestamp": 1706999887
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306502\">@Preeyan Parmar</span> <a href=\"#narrow/stream/113489-new-members/topic/Help.20with.20Inductively.20Defined.20Propositions/near/419645105\">said</a>:</p>\n<blockquote>\n<p>I don't understand the sense in which <code>hxy</code> has type <code>TClos</code>. (For example, if I had an <code>f : TClos -&gt; Nat</code> could I form <code>f hxy</code>?)</p>\n<p>(There's a chance I'm missing something silly here...)</p>\n</blockquote>\n<p>Ruben was being imprecise to say that <code>hxy</code> has type <code>TClos</code>. It actually has type <code>TClos R x y</code>, <code>TClos</code> is not a type it is a type operator. But the rule for dot-notation resolution says that <code>hxy.foo</code> will call <code>T.foo</code> where <code>T</code> is the name of the constant symbol at the head of the application of the type of <code>hxy</code>, which in this case is <code>TClos</code>. (That is, take the type of <code>hxy</code>, throw away the arguments and look at the name of the head constant.)</p>",
        "id": 419658420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707010974
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306502\">Preeyan Parmar</span> <a href=\"#narrow/stream/113489-new-members/topic/Help.20with.20Inductively.20Defined.20Propositions/near/419645702\">said</a>:</p>\n<blockquote>\n<ul>\n<li>type constructors are not functions Type --&gt; Type (they are more like syntactic extensions)</li>\n</ul>\n</blockquote>\n<p>No, type constructors are functions <code>Type -&gt; Type</code>, or more generally functions of multiple arguments returning <code>Sort u</code> for some <code>u</code>. <code>TClos</code> has type <code>{α: Type} → Relation α → α → α → Prop</code>, where <code>Prop</code> is <code>Sort 0</code>.</p>",
        "id": 419658550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707011103
    },
    {
        "content": "<p>Your other assertions are correct: <code>TClos</code> is not a type but people use <code>TClos</code> as shorthand for <code>TClos ..</code>, i.e. the type <code>TClos R a b</code> for some <code>R, a, b</code>.</p>",
        "id": 419658667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707011242
    },
    {
        "content": "<p>Crystal clear, thanks Mario!</p>",
        "id": 419698629,
        "sender_full_name": "Preeyan Parmar",
        "timestamp": 1707053280
    }
]