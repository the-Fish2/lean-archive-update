[
    {
        "content": "<p>Hello, is it possible to define a product over a finite, noncommutative group:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"c1\">-- Fails because G is not commutative.</span>\n<span class=\"kd\">def</span> <span class=\"n\">generative_subgroup</span>  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"o\">(</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">Subgroup</span> <span class=\"o\">(</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">G'</span><span class=\"o\">),</span> <span class=\"bp\">∏</span> <span class=\"n\">g'</span> <span class=\"k\">in</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">g'</span> <span class=\"bp\">=</span> <span class=\"n\">g</span>\n</code></pre></div>\n<p>I saw that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.prod#doc\">docs#Finset.prod</a> depends on fold operations on lists, that return the same result when applied to lists that are permutation of each others (hence to necessity of commutativity). Is there a \"<code>fold</code>\" depending on the order of operations or do I have to define my own operator on <code>Finset</code>?</p>",
        "id": 426571276,
        "sender_full_name": "Gaëtan Serré",
        "timestamp": 1710431147
    },
    {
        "content": "<p>I think <code>List.prod</code> is the closest thing. To illustrate why there isn't a noncommutative product defined using <code>Finset</code>, suppose that there were:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">MyNoncommProd</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">MyNoncommProd</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">}</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">MyNoncommProd</span> <span class=\"o\">{</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Finset.pair_comm</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 426575306,
        "sender_full_name": "Richard Copley",
        "timestamp": 1710432227
    },
    {
        "content": "<p>Ok I get what you mean, thanks a lot!</p>",
        "id": 426576241,
        "sender_full_name": "Gaëtan Serré",
        "timestamp": 1710432474
    },
    {
        "content": "<p>Moreover, I think <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.prod#doc\">docs#List.prod</a> is much more adapted to what I want to do next anyway</p>",
        "id": 426576639,
        "sender_full_name": "Gaëtan Serré",
        "timestamp": 1710432578
    },
    {
        "content": "<p>That's what is usually used. See the definition of <code>ExteriorAlgebra.ιMulti</code> (in \"Mathlib.LinearAlgebra.ExteriorAlgebra.Basic\"), for example.</p>",
        "id": 426577177,
        "sender_full_name": "Richard Copley",
        "timestamp": 1710432737
    },
    {
        "content": "<p>Or more directly, <code>MultilinearMap.mkPiAlgebraFin</code> in Mathlib.LinearAlgebra.Multilinear.Basic</p>",
        "id": 426577760,
        "sender_full_name": "Richard Copley",
        "timestamp": 1710432920
    },
    {
        "content": "<p>Oh I see! Thanks a lot for the references</p>",
        "id": 426579201,
        "sender_full_name": "Gaëtan Serré",
        "timestamp": 1710433341
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.noncommProd#doc\">docs#Finset.noncommProd</a> is related, but probably not helpful here</p>",
        "id": 426588595,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710436084
    },
    {
        "content": "<p>Good to know, thanks anyway!</p>",
        "id": 426588770,
        "sender_full_name": "Gaëtan Serré",
        "timestamp": 1710436140
    }
]