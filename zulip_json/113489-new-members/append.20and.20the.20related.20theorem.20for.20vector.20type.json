[
    {
        "content": "<p>Hi! I am learning TPIL and in the chapter <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html#inductive-families\">Inductive Families</a> I am trying to formalize a theorem related to append vector:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Vector.nil</span>\n<span class=\"k\">#check</span> <span class=\"n\">Vector.cons</span> <span class=\"mi\">3</span> <span class=\"n\">Vector.nil</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Vector.recOn</span>\n<span class=\"c1\">-- Inductive_Families.Vector.recOn.{u_1, u} {α : Type u} {motive : (a : Nat) → Vector α a → Sort u_1} {a : Nat}</span>\n<span class=\"c1\">--   (t : Vector α a) (nil : motive 0 Vector.nil)</span>\n<span class=\"c1\">--   (cons : (a : α) → {n : Nat} → (a_1 : Vector α n) → motive n a_1 → motive (n + 1) (Vector.cons a a_1)) : motive a t</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">length</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n\n<span class=\"c1\">-- TODO cannot do this now</span>\n<span class=\"c1\">--      How to prove or state Vector Nat (1+0) = Vector Nat 1?</span>\n<span class=\"c1\">-- def append {α : Type u} (x : Vector α n) (y : Vector α m) : Vector α (n+m) :=</span>\n<span class=\"c1\">-- Vector.recOn (motive := fun (a : Nat) (b : Vector α a) =&gt; Vector α (a+m)) x</span>\n<span class=\"c1\">-- (y)</span>\n<span class=\"c1\">-- sorry</span>\n</code></pre></div>",
        "id": 421212554,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1707819033
    },
    {
        "content": "<p>How to define the append fun for vector plz? It seems that I stucked at showing something like proving <code>Vector Nat (1+0) = Vector Nat 1</code></p>",
        "id": 421212695,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1707819085
    },
    {
        "content": "<p>You might be looking for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=cast#doc\">docs#cast</a></p>",
        "id": 421219074,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1707821499
    },
    {
        "content": "<p>(Casting things can become very tricky, which I would say is why dependent inductive types like this are generally avoided in mathlib)</p>",
        "id": 421219373,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1707821621
    },
    {
        "content": "<p>OK maybe I just stick with the Eq example in TPIL and leave alone the vector type</p>",
        "id": 421219702,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1707821731
    },
    {
        "content": "<p>So in fact <code>Vector Nat (1+0)</code>, <code>Vector Nat 1</code>  they are not the same type? I suspect they are not?</p>",
        "id": 421220075,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1707821872
    },
    {
        "content": "<p>Now I get the def with the  following code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">InductiveFamilies</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Vector.nil</span>\n<span class=\"k\">#check</span> <span class=\"n\">Vector.cons</span> <span class=\"mi\">3</span> <span class=\"n\">Vector.nil</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Vector.recOn</span>\n<span class=\"c1\">-- Inductive_Families.Vector.recOn.{u_1, u} {α : Type u} {motive : (a : Nat) → Vector α a → Sort u_1} {a : Nat}</span>\n<span class=\"c1\">--   (t : Vector α a) (nil : motive 0 Vector.nil)</span>\n<span class=\"c1\">--   (cons : (a : α) → {n : Nat} → (a_1 : Vector α n) → motive n a_1 → motive (n + 1) (Vector.cons a a_1)) : motive a t</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">length</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">vector_eq</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"n\">Vector</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">append</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">Vector.recOn</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"n\">x</span>\n<span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a'</span> <span class=\"n\">n'</span> <span class=\"n\">x'</span> <span class=\"n\">xy'</span>\n  <span class=\"k\">let</span> <span class=\"n\">xy</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Vector.cons</span> <span class=\"n\">a'</span> <span class=\"n\">xy'</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n'</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_assoc</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_comm</span><span class=\"o\">,</span> <span class=\"n\">vector_eq</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">xy'</span> <span class=\"o\">:=</span> <span class=\"n\">cast</span> <span class=\"n\">h</span> <span class=\"n\">xy</span>\n  <span class=\"n\">exact</span> <span class=\"n\">xy'</span>\n  <span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">append₁</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">h</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">InductiveFamilies</span>\n</code></pre></div>\n<p>except the error: <code>code generator does not support recursor 'InductiveFamilies.Vector.recOn' yet, consider using 'match ... with' and/or structural recursion</code> and <code>invalid pattern, constructor or constant marked with '[match_pattern]' expected\n</code>. Why I cannot run recOn on it, and why it's also failed with pattern match?</p>",
        "id": 421234751,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1707827696
    },
    {
        "content": "<p>Honestly, that seems like a shame. At least in this case, it's not too bad. The syntax is a little weird at first, though</p>",
        "id": 421420955,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1707908459
    },
    {
        "content": "<p>If I added <code>noncomputable</code> keyword in the first def, it works but #eval fails. And for the pattern match I get it in <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html#dependent-pattern-matching\">Dependent pattern matching</a> in TPIL now <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 421421432,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1707908640
    },
    {
        "content": "<p>The trick is to remember that \"proofs\" in Lean are just producing a term of a given type anyway, so you can use the <code>:= by</code> syntax to produce terms of other types (types that are not in <code>Prop</code>) as well. So you can get started with something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kd\">def</span> <span class=\"n\">append</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">v</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">convert</span> <span class=\"n\">w</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">@</span><span class=\"n\">Vector.cons</span> <span class=\"n\">_</span> <span class=\"n\">hd</span> <span class=\"n\">k</span> <span class=\"n\">tl</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p><code>.nil</code> is easily done with <code>convert</code>, which in this case successfully realizes that the types <code>Vector α m</code> and <code>Vector α (m+0)</code> would be the same if <code>m = m + 0</code>, which you can then prove with <code>simp</code>. <code>.cons</code> is a bit harder; if you just use <code>convert</code> directly, <code>convert</code> will see that you have a term <code>Vector α (k + 1 + m)</code> and a term <code>Vector α (k + m + 1)</code>, and will blindly try and equate atoms, producing the goals <code>1 = m</code> and <code>m = 1</code> instead of <code>k + 1 + m = k + m + 1</code>; you'll have to work around that. (I can also just give you the answer -- or at least an answer -- but since you're doing the exercises anyway I thought I'd give you the option at least :p)</p>",
        "id": 421421902,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1707908815
    },
    {
        "content": "<p>...aaalso somehow I missed your last few posts ^.^;<br>\noops!</p>",
        "id": 421422186,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1707908916
    },
    {
        "content": "<p>Yeah. Now I get the def of append in pattern match form with the following snippet:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Vector.nil</span>\n<span class=\"k\">#check</span> <span class=\"n\">Vector.cons</span> <span class=\"mi\">3</span> <span class=\"n\">Vector.nil</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Vector.recOn</span>\n<span class=\"c1\">-- Inductive_Families.Vector.recOn.{u_1, u} {α : Type u} {motive : (a : Nat) → Vector α a → Sort u_1} {a : Nat}</span>\n<span class=\"c1\">--   (t : Vector α a) (nil : motive 0 Vector.nil)</span>\n<span class=\"c1\">--   (cons : (a : α) → {n : Nat} → (a_1 : Vector α n) → motive n a_1 → motive (n + 1) (Vector.cons a a_1)) : motive a t</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">length</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">vector_eq</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"n\">Vector</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n\n<span class=\"c1\">-- the noncomputable keyword is hint from</span>\n<span class=\"c1\">-- https://leanprover-community.github.io/archive/stream/270676-lean4/topic/code.20generator.20does.20not.20support.20recursor.html</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">append</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">Vector.recOn</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"n\">x</span>\n<span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a'</span> <span class=\"n\">n'</span> <span class=\"n\">x'</span> <span class=\"n\">xy'</span>\n  <span class=\"k\">let</span> <span class=\"n\">xy</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Vector.cons</span> <span class=\"n\">a'</span> <span class=\"n\">xy'</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n'</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_assoc</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_comm</span><span class=\"o\">,</span> <span class=\"n\">vector_eq</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">xy'</span> <span class=\"o\">:=</span> <span class=\"n\">cast</span> <span class=\"n\">h</span> <span class=\"n\">xy</span>\n  <span class=\"n\">exact</span> <span class=\"n\">xy'</span>\n  <span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">append</span> <span class=\"o\">(</span><span class=\"n\">Vector.cons</span> <span class=\"mi\">3</span> <span class=\"n\">Vector.nil</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Vector.cons</span> <span class=\"mi\">4</span> <span class=\"n\">Vector.nil</span><span class=\"o\">)</span>\n<span class=\"c1\">-- cannot eval, still problematic, but the following match version does work</span>\n<span class=\"c1\">-- TODO why is the recOn version problematic in eval?</span>\n<span class=\"c1\">-- #eval append (Vector.cons 3 Vector.nil) (Vector.cons 4 Vector.nil)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">append₁</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">y</span>\n<span class=\"c1\">-- it must match n, x in the same time, and the first must be n' + 1 for giving implicit</span>\n<span class=\"c1\">-- argument to the second</span>\n<span class=\"bp\">|</span> <span class=\"n\">n'</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">Vector.cons</span> <span class=\"n\">a</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"kd\">by</span>\n    <span class=\"k\">let</span> <span class=\"n\">xy</span> <span class=\"o\">:=</span> <span class=\"n\">Vector.cons</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">append₁</span> <span class=\"n\">t</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n'</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_assoc</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_comm</span><span class=\"o\">,</span> <span class=\"n\">vector_eq</span><span class=\"o\">]</span>\n    <span class=\"k\">let</span> <span class=\"n\">xy'</span> <span class=\"o\">:=</span> <span class=\"n\">cast</span> <span class=\"n\">h</span> <span class=\"n\">xy</span>\n    <span class=\"n\">exact</span> <span class=\"n\">xy'</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">append₁</span> <span class=\"o\">(</span><span class=\"n\">Vector.cons</span> <span class=\"mi\">3</span> <span class=\"n\">Vector.nil</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Vector.cons</span> <span class=\"mi\">4</span> <span class=\"n\">Vector.nil</span><span class=\"o\">)</span>\n<span class=\"c1\">-- TODO it eval to ⊢ Vector Nat (0 + 1 + (0 + 1))</span>\n<span class=\"c1\">-- how to make it to Vector Nat 2?</span>\n<span class=\"k\">#eval</span> <span class=\"n\">append₁</span> <span class=\"o\">(</span><span class=\"n\">Vector.cons</span> <span class=\"mi\">3</span> <span class=\"n\">Vector.nil</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Vector.cons</span> <span class=\"mi\">4</span> <span class=\"n\">Vector.nil</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 421422836,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1707909164
    },
    {
        "content": "<p>It just contains a minor flaws that  <code>#eval append (Vector.cons 3 Vector.nil) (Vector.cons 4 Vector.nil)</code> is of type <code>Vector Nat (0 + 1 + (0 + 1))</code> but not <code>Vector Nat 2</code></p>",
        "id": 421423036,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1707909244
    },
    {
        "content": "<p>Nice!</p>",
        "id": 421423414,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1707909401
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"560873\">Coriver Chen</span> <a href=\"#narrow/stream/113489-new-members/topic/append.20and.20the.20related.20theorem.20for.20vector.20type/near/421423036\">said</a>:</p>\n<blockquote>\n<p>It just contains a minor flasw that  <code>#eval append (Vector.cons 3 Vector.nil) (Vector.cons 4 Vector.nil)</code> is of type <code>Vector Nat (0 + 1 + (0 + 1))</code> but not <code>Vector Nat 2</code></p>\n</blockquote>\n<p>Hmmm... You could probably work around that y doing something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">append₁</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h_r</span><span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">r</span> <span class=\"o\">:=</span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>but I don't know what that'd do to the usability of the actual function...</p>",
        "id": 421423724,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1707909552
    },
    {
        "content": "<p>Yeah it’s just some kind of practice illuminating the strength of the type system I think.</p>",
        "id": 421425882,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1707910411
    }
]