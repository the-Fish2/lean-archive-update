[
    {
        "content": "<p>Hello, I wrote a function that takes a List of Int and removes the consecutive elements that sum to 0 (if the list contains 0, it removes it):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">irre</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">aux</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">acc</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">acc</span>\n    <span class=\"bp\">|</span> <span class=\"n\">hd</span><span class=\"o\">::[]</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">hd</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">acc</span> <span class=\"k\">else</span> <span class=\"n\">acc.concat</span> <span class=\"n\">hd</span>\n    <span class=\"bp\">|</span> <span class=\"n\">hd1</span><span class=\"o\">::</span><span class=\"n\">hd2</span><span class=\"o\">::</span><span class=\"n\">tl</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">if</span> <span class=\"n\">hd1</span> <span class=\"bp\">+</span> <span class=\"n\">hd2</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">aux</span> <span class=\"n\">tl</span> <span class=\"n\">acc</span>\n      <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">hd1</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">aux</span> <span class=\"o\">(</span><span class=\"n\">hd2</span><span class=\"o\">::</span><span class=\"n\">tl</span><span class=\"o\">)</span> <span class=\"n\">acc</span>\n      <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">hd2</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">aux</span> <span class=\"o\">(</span><span class=\"n\">hd1</span><span class=\"o\">::</span><span class=\"n\">tl</span><span class=\"o\">)</span> <span class=\"n\">acc</span>\n      <span class=\"k\">else</span> <span class=\"n\">aux</span> <span class=\"o\">(</span><span class=\"n\">hd2</span><span class=\"o\">::</span><span class=\"n\">tl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">acc.concat</span> <span class=\"n\">hd1</span><span class=\"o\">)</span>\n  <span class=\"n\">aux</span> <span class=\"n\">l</span> <span class=\"o\">[]</span>\n</code></pre></div>\n<p>I want to prove that my statement is true, that is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">irre</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"k\">then</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">irre</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">),</span> <span class=\"o\">((</span><span class=\"n\">irre</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">((</span><span class=\"n\">irre</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"o\">{</span><span class=\"n\">val</span><span class=\"o\">:=</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">isLt</span><span class=\"o\">:=</span><span class=\"n\">h</span><span class=\"o\">}))</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span>\n  <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">irre</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"n\">irre</span> <span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"o\">{</span><span class=\"n\">val</span><span class=\"o\">:=</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">isLt</span><span class=\"o\">:=</span><span class=\"kd\">by</span> <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">Nat.zero_lt_one</span><span class=\"o\">}</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span>\n  <span class=\"k\">else</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">split</span>\n    <span class=\"bp\">·</span> <span class=\"n\">contradiction</span>\n    <span class=\"n\">next</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n      <span class=\"n\">split</span>\n      <span class=\"bp\">·</span> <span class=\"n\">contradiction</span>\n      <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I think the statement definition is pretty heavy and that my <code>irre</code> function could be simpler. Moreover, I started an induction on <code>l</code>, the initial case is easy but the induction step will be a mess, with a lot of nested cases. Do you have any advice on how to prove this more easely?</p>",
        "id": 427229709,
        "sender_full_name": "Gaëtan Serré",
        "timestamp": 1710711695
    },
    {
        "content": "<p>it might be easier if you define the function without using a second accumulator list:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">irre</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">hd</span><span class=\"o\">::[]</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">hd</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"o\">[]</span> <span class=\"k\">else</span> <span class=\"o\">[</span><span class=\"n\">hd</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">hd1</span><span class=\"o\">::</span><span class=\"n\">hd2</span><span class=\"o\">::</span><span class=\"n\">tl</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">hd1</span> <span class=\"bp\">+</span> <span class=\"n\">hd2</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">irre</span> <span class=\"n\">tl</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">hd1</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">irre</span> <span class=\"o\">(</span><span class=\"n\">hd2</span><span class=\"o\">::</span><span class=\"n\">tl</span><span class=\"o\">)</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">hd2</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">irre</span> <span class=\"o\">(</span><span class=\"n\">hd1</span><span class=\"o\">::</span><span class=\"n\">tl</span><span class=\"o\">)</span>\n    <span class=\"k\">else</span> <span class=\"n\">hd1</span><span class=\"o\">::(</span><span class=\"n\">irre</span> <span class=\"o\">(</span><span class=\"n\">hd2</span><span class=\"o\">::</span><span class=\"n\">tl</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 427286403,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710726602
    },
    {
        "content": "<p>I'm also confused about your example proof, as it appears to be checking if the products of consecutive elements equal one, not that sums of consecutive elements equal 0</p>",
        "id": 427287416,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710726852
    },
    {
        "content": "<p>Thanks for the advice, indeed using an accumulator makes the proof more complicated</p>",
        "id": 427383599,
        "sender_full_name": "Gaëtan Serré",
        "timestamp": 1710750107
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/stream/113489-new-members/topic/Proof.20on.20recursive.20function.20of.20List.20of.20Int/near/427287416\">said</a>:</p>\n<blockquote>\n<p>I'm also confused about your example proof, as it appears to be checking if the products of consecutive elements equal one, not that sums of consecutive elements equal 0</p>\n</blockquote>\n<p>Indeed, sorry for that.. The reason is because I try to prove a generalised version of my statement for group and I forgot to change it when copy pasting the mwe. I edited it</p>",
        "id": 427384116,
        "sender_full_name": "Gaëtan Serré",
        "timestamp": 1710750210
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"635099\">@Gaëtan Serré</span> I was thinking about this more and your <code>irre</code> function doesn't really accomplish what you want it to. For example, if you run <code>irre [1, 1, -1, -1]</code> you end up with <code>[1, -1]</code> because it only eliminates the middle two entries.</p>",
        "id": 427525283,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710779093
    },
    {
        "content": "<p>Oh yes you're totally right, thanks again for noticing that. I need a way to ensure that<code>hd</code> and <code>tl.head</code> do not cancel each other when constructing <code>hd::tl</code>. I did not had time to work on the proof neither the function today, but I'll try to provide a working function soon</p>",
        "id": 427526590,
        "sender_full_name": "Gaëtan Serré",
        "timestamp": 1710779410
    },
    {
        "content": "<p>Thank you again for your help</p>",
        "id": 427526623,
        "sender_full_name": "Gaëtan Serré",
        "timestamp": 1710779419
    },
    {
        "content": "<p>I think you'll have an easier time if you separate the task of filtering out zero from the task of filtering out pairs that sum to zero. This implementation seems to work correctly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">irre_aux</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">hd</span> <span class=\"o\">::</span> <span class=\"n\">rest</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">irre_aux</span> <span class=\"n\">rest</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">hd</span><span class=\"o\">]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">hd'</span> <span class=\"o\">::</span> <span class=\"n\">rest'</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">hd</span> <span class=\"bp\">+</span> <span class=\"n\">hd'</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">rest'</span>\n    <span class=\"k\">else</span> <span class=\"n\">hd</span> <span class=\"o\">::</span> <span class=\"n\">hd'</span> <span class=\"o\">::</span> <span class=\"n\">rest'</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">irre</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">irre_aux</span> <span class=\"o\">(</span><span class=\"n\">l.filter</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 427529092,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710780078
    },
    {
        "content": "<p>I also noticed that your theorem statement only seems to check for pairs that sum to 0 in the <code>1 &lt; (irre l).length</code> case, but it doesn't say anything about the absence of 0 more generally (except in the case where length = 1)</p>",
        "id": 427530854,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710780616
    },
    {
        "content": "<p>if you don't actually care about zeroes except in the length = 1 case, then my implementation isn't correct, as it filters out all zeroes</p>\n<p>you said \"if the list contains 0, it removes it\"... did you mean \"if the list <em>only</em> contains 0, it removes it\"?</p>\n<p>if so, it would be a pretty easy change to make... just replace <code>irre_aux (l.filter (· ≠ 0))</code> with something like <code>let result := irre_aux l; if l = [0] then [] else l</code></p>",
        "id": 427531137,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710780696
    },
    {
        "content": "<p>Thank you for your implementation, that's exactly what I need!</p>",
        "id": 427596634,
        "sender_full_name": "Gaëtan Serré",
        "timestamp": 1710806477
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/stream/113489-new-members/topic/Proof.20on.20recursive.20function.20of.20List.20of.20Int/near/427531137\">said</a>:</p>\n<blockquote>\n<p>you said \"if the list contains 0, it removes it\"... did you mean \"if the list <em>only</em> contains 0, it removes it\"?</p>\n</blockquote>\n<p>I meant that any <code>0</code> should be removed from the list (as <code>l.filter (· ≠ 0)</code> does). However, you're right, the statement do not check anything about that. The reason is that it is not necessary for what follows to remove the <code>0</code>s, but it seemed to me more natural to remove it in the implementation (I hope that's makes sense)</p>",
        "id": 427596884,
        "sender_full_name": "Gaëtan Serré",
        "timestamp": 1710806626
    },
    {
        "content": "<p>Especially for recursive functions, I find it easier to put the theorem in the function signature using <code>Subtype</code> and prove it when constructing the return values. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.findX#doc\">docs#Nat.findX</a> is an example of this in Mathlib.</p>",
        "id": 428438730,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1711164205
    },
    {
        "content": "<p>That's a good idea, thank you!</p>",
        "id": 429235021,
        "sender_full_name": "Gaëtan Serré",
        "timestamp": 1711305220
    }
]