[
    {
        "content": "<p>In <em>Mathematics in Lean</em> section 5.2, there is this sentence: \"(Numerals are translated to binary representations, but we donâ€™t have to worry about the details of that now.)\"</p>\n<p>Does that mean that <code>3:Nat</code> is actually not <code>Nat.succ (Nat.succ (Nat.succ Nat.zero))</code> but something else?</p>",
        "id": 426098735,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1710240939
    },
    {
        "content": "<p><code>3</code> is equal to <code>Nat.succ (Nat.succ (Nat.succ Nat.zero))</code>, but the kernel is able to represent this expression internally in a more efficient form (a binary representation), and it also has accelerators for operations such as <code>Nat.add</code> to skip using the recursive definition and instead use a fast add of the binary representation.</p>",
        "id": 426173358,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710262862
    },
    {
        "content": "<p>I'm not 100%, but I think this curtails into the trust system too. When you're using Lean to write code instead of proofs, not everything has to go through the kernel, so some extra shortcuts are available. I understand it as wining space/time at the cost of a greater surface area for bugs. I can't find the sources for any of this at the moment though... so grain of salt</p>",
        "id": 426312937,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1710328592
    },
    {
        "content": "<p>So how does one write trusted and efficient code in Lean?</p>",
        "id": 426313525,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1710328804
    },
    {
        "content": "<p>I'm not sure if that question can be answered in the general case yet. </p>\n<p>If you want more speed, you'll need to figure out whats slowing you down on a case-by-case basis.</p>\n<p>If you want more trust, wait for more verifiers to corroborate on lean's output or even a full-blown formal verification of Lean kernel correctness (then buy trusted formally modeled hardware, etc). If I were writing a math Proof, I wouldn't worry about it. If I'm writing a pace maker where people's lives depend on correctness, maybe an older battle-tested model checker moves the needle forward a bit farther on trust? Definitely I'd do more research before making any such choice.</p>\n<p>It may have been lean 3 where you could choose to run computations in a vm or compile to byte-code where the tradeoff between the two is as expected. My search for where I was reading about this has been fruitless, I wish I could point you toward more trusted sources on this as I'm quite fresh to lean and the ecosystem myself.</p>",
        "id": 426334872,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1710334954
    },
    {
        "content": "<p>My main concerns at the moment are proofs that involve lots of computations which need to be performed very quickly. I don't think I need pacemaker-level trust but definitely something close to a formal proof.</p>",
        "id": 426337762,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1710335870
    },
    {
        "content": "<p>My advice is to just give it a go. If you find Lean isn't up to the task for your computationally heavy proof, I don't know how much more performance you could squeeze out of another theorem prover. I imagine it depends <strong>heavily</strong> on the details of your proof.</p>\n<p>If you find a specific thing really bogging you down, posting a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> here will likely get friendly experts involved who know all the performance pitfalls and how to work around them.</p>\n<p>From a compsci perspective, I've been pleasantly surprised at how well Lean performs. Avoiding monads, my Sudoku Solver is performing admirably close to my Rust implementation. That's not a comprehensive review of performance of course.</p>",
        "id": 426343338,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1710337465
    },
    {
        "content": "<p>You have a verified sudoku solver? That's amazing. Is it viewable by the public?</p>",
        "id": 426343897,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1710337629
    },
    {
        "content": "<p>Still working on it! Writing the Sudoku Solver in Lean was a breeze, verifying it has been my project to direct my learning, so it's been slow-going in the evenings. It'll be viewable by the public eventually.</p>",
        "id": 426347013,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1710338539
    },
    {
        "content": "<p>Good luck!</p>",
        "id": 426347091,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1710338562
    },
    {
        "content": "<p>I hope I can see it soon.</p>",
        "id": 426347132,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1710338576
    }
]