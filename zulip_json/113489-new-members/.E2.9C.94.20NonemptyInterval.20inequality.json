[
    {
        "content": "<p>I am trying to define intervals over <code>ℚ × ℚ</code>. For example, here is a true fact over intervals represented as products:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">t1</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ℚ</span> <span class=\"bp\">×</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">ℚ</span> <span class=\"bp\">×</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">t2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ℚ</span> <span class=\"bp\">×</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">ℚ</span> <span class=\"bp\">×</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">))</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">prod_lt</span> <span class=\"o\">:</span> <span class=\"n\">t1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">t2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LT.lt</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>However, converting these types to <code>NonemptyInterval</code> produces unexpected behavior where this comparison no longer holds.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">i1</span> <span class=\"o\">:</span> <span class=\"n\">NonemptyInterval</span> <span class=\"o\">(</span><span class=\"n\">ℚ</span> <span class=\"bp\">×</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">t1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">i2</span> <span class=\"o\">:</span> <span class=\"n\">NonemptyInterval</span> <span class=\"o\">(</span><span class=\"n\">ℚ</span> <span class=\"bp\">×</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">t2</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp_arith</span><span class=\"o\">⟩</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">intvl_lt1</span> <span class=\"o\">:</span> <span class=\"n\">i1.toProd</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i2.toProd</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"c1\">-- ok</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">intvl_lt2</span> <span class=\"o\">:</span> <span class=\"n\">i1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">LT.lt</span><span class=\"o\">]</span>       <span class=\"c1\">-- reduces to 2 ≤ 0??</span>\n</code></pre></div>\n<p>Is this a bug, or is this expected behavior? Am I misunderstanding the semantics of <code>NonemptyInterval</code>?</p>",
        "id": 433303969,
        "sender_full_name": "Will Crichton",
        "timestamp": 1713190839
    },
    {
        "content": "<p>The ordering on intervals is defined here (it should correspond to the inclusion of the corresponding intervals):<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/blob/88ce099104b4a6c8b3d803e60950709e8d0d352f/Mathlib/Order/Interval.lean#L70C1-L72C45\">https://github.com/leanprover-community/mathlib4/blob/88ce099104b4a6c8b3d803e60950709e8d0d352f/Mathlib/Order/Interval.lean#L70C1-L72C45</a></p>",
        "id": 433309207,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1713192051
    },
    {
        "content": "<p>Under those semantics, it is not true that <code>i1 &lt; i2</code>.</p>",
        "id": 433309798,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1713192176
    },
    {
        "content": "<p>Ah I see, thanks. Is it true that <code>&lt;</code> is also defined on <code>NonemptyInterval</code> via the <code>Preorder</code> instance? That seems to have a different semantics than the direct <code>LE</code> instance.</p>",
        "id": 433309989,
        "sender_full_name": "Will Crichton",
        "timestamp": 1713192225
    },
    {
        "content": "<p>Oh nevermind. I thought <code>toDualProd = toProd</code> meant the semantics were the same, but the <code>αᵒᵈ</code> typecast changes the semantics. All makes sense!</p>",
        "id": 433310884,
        "sender_full_name": "Will Crichton",
        "timestamp": 1713192433
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"625391\">Will Crichton</span> has marked this topic as resolved.</p>",
        "id": 433310905,
        "sender_full_name": "Notification Bot",
        "timestamp": 1713192438
    }
]