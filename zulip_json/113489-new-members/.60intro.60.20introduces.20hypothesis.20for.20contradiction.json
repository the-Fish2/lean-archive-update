[
    {
        "content": "<p>Hi everyone! I'm working my way through the <code>Mathematics in Lean</code> book, and one line in the example on proving irrationality of square root of 2 does not quite make sense to me.<br>\nHere's the relevant snippet.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">coprime_mn</span> <span class=\"o\">:</span> <span class=\"n\">m.Coprime</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">≠</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">sqr_eq</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">∣</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">meq</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">dvd_iff_exists_eq_mul_left.mp</span> <span class=\"n\">this</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">sqr_eq</span><span class=\"o\">,</span> <span class=\"n\">meq</span><span class=\"o\">]</span>\n    <span class=\"n\">ring</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">k</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">∣</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">∣</span> <span class=\"n\">m.gcd</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">∣</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"n\">norm_num</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n</code></pre></div>\n<p>In the very first line of the proof, <code>intro sqr_eq</code> introduces the contradictory hypothesis, namely <code>m^2 = 2* n^2</code>, from which we are supposed to deduce <code>False</code>, and obtain a proof by contradiction. I would've assumed that one would do this via the <code>contradiction</code> tactic, and not the <code>intro</code> tactic.<br>\nReading the documentation for the <code>intro</code> tactic, it says that when the goal is a <code>Prop</code> that is not of the form <code>\\forall P Q</code>, or <code>P -&gt; Q</code>, the intro tactic turns the goal into its weak head normal form, and introduces that as a subgoal.</p>\n<p>Is that what is happening here, i.e. is the whnf of a proposition of the shape <code>a \\neq b</code> the same as <code>a = b -&gt; False</code>?<br>\nOr am I misunderstanding what is happening here?</p>\n<p>Thanks!</p>",
        "id": 420152579,
        "sender_full_name": "Sayantan Khan",
        "timestamp": 1707261575
    },
    {
        "content": "<p>What documentation for <code>intro</code> are you looking at? Its documentation string says</p>\n<blockquote>\n<p>Introduces one or more hypotheses, optionally naming and/or pattern-matching them.<br>\nFor each hypothesis to be introduced, the remaining main goal's target type must<br>\nbe a let or function type.</p>\n<ul>\n<li>\n<p>intro by itself introduces one anonymous hypothesis, which can be accessed<br>\n  by e.g. assumption.</p>\n</li>\n<li>\n<p>intro x y introduces two hypotheses and names them. Individual hypotheses<br>\n  can be anonymized via _, or matched against a pattern:<br>\n  -- ... ⊢ α × β → ...<br>\n  intro (a, b)<br>\n  -- ..., a : α, b : β ⊢ ...</p>\n</li>\n<li>\n<p>Alternatively, intro can be combined with pattern matching much like fun:<br>\n  intro<br>\n  | n + 1, 0 =&gt; tac<br>\n  | ...</p>\n</li>\n</ul>\n</blockquote>\n<p>Not particularly helpful! But it doesn't mention whnf, and I think that's good, because it's not very relevant.</p>\n<ul>\n<li><code>a ≠ b</code> is notation for <code>Ne a b</code></li>\n<li><code>Ne a b</code> is defined as <code>¬(a = b)</code></li>\n<li><code>¬p</code> is notation for <code>Not p</code></li>\n<li><code>Not p</code> is defined as <code>p → False</code></li>\n</ul>\n<p>You should be able to follow this chain using your editor's \"go to definition\" function. </p>\n<p>It might be useful for you to take a break from <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a> and review some of the early parts of <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a> (chapter 3 in particular) which has a different emphasis and might fill in some gaps. I hope that's not too presumptuous.</p>",
        "id": 420155814,
        "sender_full_name": "Richard Copley",
        "timestamp": 1707263585
    },
    {
        "content": "<p>In other words, <code>a \\ne b</code> is definitionally equal to <code>a = b -&gt; False</code>, so <code>intro</code> works fine on it.</p>",
        "id": 420156460,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707264000
    },
    {
        "content": "<p>For what it's worth, <code>intro</code> does computes whnf of the goal to see a forall/implication. The whnf of <code>a \\ne b</code> is <code>a = b -&gt; False</code> by definition of <code>\\neq</code>.</p>",
        "id": 420161834,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707267161
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400544\">Richard Copley</span> <a href=\"#narrow/stream/113489-new-members/topic/.60intro.60.20introduces.20hypothesis.20for.20contradiction/near/420155814\">said</a>:</p>\n<blockquote>\n<p>What documentation for <code>intro</code> are you looking at? Its documentation string says</p>\n<blockquote>\n<p>Introduces one or more hypotheses, optionally naming and/or pattern-matching them.<br>\nFor each hypothesis to be introduced, the remaining main goal's target type must<br>\nbe a let or function type.</p>\n<ul>\n<li>\n<p>intro by itself introduces one anonymous hypothesis, which can be accessed<br>\n  by e.g. assumption.</p>\n</li>\n<li>\n<p>intro x y introduces two hypotheses and names them. Individual hypotheses<br>\n  can be anonymized via _, or matched against a pattern:<br>\n  -- ... ⊢ α × β → ...<br>\n  intro (a, b)<br>\n  -- ..., a : α, b : β ⊢ ...</p>\n</li>\n<li>\n<p>Alternatively, intro can be combined with pattern matching much like fun:<br>\n  intro<br>\n  | n + 1, 0 =&gt; tac<br>\n  | ...</p>\n</li>\n</ul>\n</blockquote>\n<p>Not particularly helpful! But it doesn't mention whnf, and I think that's good, because it's not very relevant.</p>\n<ul>\n<li><code>a ≠ b</code> is notation for <code>Ne a b</code></li>\n<li><code>Ne a b</code> is defined as <code>¬(a = b)</code></li>\n<li><code>¬p</code> is notation for <code>Not p</code></li>\n<li><code>Not p</code> is defined as <code>p → False</code></li>\n</ul>\n<p>You should be able to follow this chain using your editor's \"go to definition\" function. </p>\n<p>It might be useful for you to take a break from <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a> and review some of the early parts of <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a> (chapter 3 in particular) which has a different emphasis and might fill in some gaps. I hope that's not too presumptuous.</p>\n</blockquote>\n<p>I was looking at the <a href=\"https://leanprover.github.io/reference/tactics.html\">Lean reference manual</a>, but yes, in retrospect it seems obvious that <code>a \\neq b</code> is definitionally <code>a = b -&gt; False</code>. Thanks!</p>",
        "id": 420163664,
        "sender_full_name": "Sayantan Khan",
        "timestamp": 1707268477
    },
    {
        "content": "<p>Did you skip chapters? All this is explained way earlier in the book, in <a href=\"https://leanprover-community.github.io/mathematics_in_lean/C03_Logic.html#negation\">https://leanprover-community.github.io/mathematics_in_lean/C03_Logic.html#negation</a></p>",
        "id": 420166336,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1707270390
    }
]