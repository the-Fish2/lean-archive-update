[
    {
        "content": "<p>Sorry to be a beginner querying the wisdom of the whole thing but for me it is difficult to get started when it seems like learning the arbitrary rules of another arbitrary game. I will try to explain:</p>\n<p>I started a Lean 4 tutorial and it begins with introducing me to the successor function and I immediately hate it. Where does this function come from? On the face of it, it looks like somebody accepted a lot of people are taught how to count so they took that learning and named a function after it which goes to the next number from whichever number you are considering. It's introduced as if it's axiomatic somehow as I just have to accept it. What's worse is it then explained addition hasn't been defined and on my journey I then need to define addition in terms of the tools I have been given. So the first question is: Why? By what means am I to accept this?</p>\n<p>To me, if you are going to just airdrop a successor function in then it seems no less sensible to start by airdropping addition in as a basic function and then stating the successor function is nothing more than a specific case of addition. In much the same way in geometry you might say a square is a special case of the more general rectangle or a circle is a special case of a more general ellipse.  </p>\n<p>So, if you are going to begin with a successor function why not begin with any other function? You can define the successor function as a specific case of the more general case of addition just as easily as you can define addition in terms of the successor function. So the successor function seems to me no less arbitrary a starting point than addition.</p>\n<p>Why am I wrong?</p>",
        "id": 447411800,
        "sender_full_name": "Jay",
        "timestamp": 1719475250
    },
    {
        "content": "<p>First, I don't think that you can be wrong, since you expressed an opinion.</p>\n<p>Second, you can choose to start where you want, but frequently in maths you try to start with the least possible amount of starting data and then try to build everything else from that.</p>",
        "id": 447413210,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1719475609
    },
    {
        "content": "<p>Don't you think if that is the case then there has to be something fundamentally wrong with it? You are right, it is my opinion, and that opinion is that it needn't have been the way it is. It could have been some other way and it's plausible that within some other way is a more sensible approach to take. My point is that if I just some random bozo and I can begin with a valid criticism of how the rules of the game are defined then that undermines the whole thing. </p>\n<p>For a mathematical basis shouldn't I expect there to be a far more austere and rigorous basis for the choice of given functions than \"it's just somebody else's opinion?\".</p>",
        "id": 447415524,
        "sender_full_name": "Jay",
        "timestamp": 1719476390
    },
    {
        "content": "<blockquote>\n<p>if you are going to just airdrop a successor function in</p>\n</blockquote>\n<p>I think the key thing is that you're not \"airdrop\"ing a function, but a constructor; and the rules of constructors is that they are only equal if they have identical arguments. So you can't take <code>add</code> as a primitive constructor, because <code>add 1 2</code> and <code>add 2 1</code> would not be equal</p>",
        "id": 447416664,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1719476746
    },
    {
        "content": "<p>For me, as long as there is something that you <em>cannot</em> prove, whatever theory that you develop is meaningful.  Whether it will be interesting or not is a question of personal taste.</p>",
        "id": 447416935,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1719476799
    },
    {
        "content": "<p>You could play around with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyNotNat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNotNat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNotNat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNotNat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">MyNotNat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">MyNotNat</span>\n</code></pre></div>\n<p>to try out what happens if you start with <code>add</code> instead of <code>succ</code> as your primitive</p>",
        "id": 447417150,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1719476861
    },
    {
        "content": "<p>OK Eric, but didn't you just invalidate what I wrote by \"airdropping in\" yet another arbitrary rule which we need not accept? We know that addition is commutative because we know that adding 3 to 2 isn't any different from adding 2 to 3 because you are adding 3 and 2 so the order you do it in makes no difference. Just as surely as if you were adding kilo weights into a bag you know that if you drop 5 kilo weights into an empty bag or you walk in 5 strides one metre in length it won't make any different how you separate or group them. 5 kilo weights weigh 5 kilos whether you add 3 then 2, 4 then 1, or just drop all five in. The grouping doesn't matter. So we know without having to invent a rule outlawing it that 1 + 2 and 2 + 1 end up in the same place, don't we?</p>",
        "id": 447418883,
        "sender_full_name": "Jay",
        "timestamp": 1719477442
    },
    {
        "content": "<p>Say, as a programmer, you can define a function which adds 1 or you can define a function which adds anything from 0 to 99. One of those functions doesn't take precedence or priority or have some default special status over the other, does it?</p>",
        "id": 447419265,
        "sender_full_name": "Jay",
        "timestamp": 1719477590
    },
    {
        "content": "<p>It seems like \"the game\" in your title refers to \"mathematics\", not \"Lean\". Yes, most mathematics axioms are, in a way, \"airdropped in\" to capture some intuitive property experts \"know without having to invent a rule\". But it turns our having a \"minimal\" set of axioms that still captures all the desirable properties is nice for various reasons (e.g., maybe one of the properties you \"know without having to invent a rule\" isn't actually necessary for proving a result you want, and therefore the same proof still goes through even in more general situations where the property doesn't hold -- for example in modular arithmetic, say).</p>",
        "id": 447419596,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1719477698
    },
    {
        "content": "<p>The <code>succ</code> example is heavily inspired by <a href=\"https://en.wikipedia.org/wiki/Peano_axioms\">https://en.wikipedia.org/wiki/Peano_axioms</a>, and the introduction talks a bit about how \"deducing facts from a small set of axioms is a good idea\" took people a long time to figure out.</p>",
        "id": 447420310,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1719477935
    },
    {
        "content": "<p>I'm not sure that one can assert that we \"know\" that addition is commutative. Okay, let's say we do in this case. And even that multiplication is commutative. But what about multiplication of matrices? Where does \"knowing\" stop and proving begin?</p>",
        "id": 447420584,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719478043
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"731970\">Jay</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20were.20the.20rules.20of.20the.20game.20decided.3F/near/447411800\">said</a>:</p>\n<blockquote>\n<p>Sorry to be a beginner querying the wisdom of the whole thing but for me it is difficult to get started when it seems like learning the arbitrary rules of another arbitrary game. I will try to explain:</p>\n<p>I started a Lean 4 tutorial and it begins with introducing me to the successor function and I immediately hate it. Where does this function come from? On the face of it, it looks like somebody accepted a lot of people are taught how to count so they took that learning and named a function after it which goes to the next number from whichever number you are considering. It's introduced as if it's axiomatic somehow as I just have to accept it. What's worse is it then explained addition hasn't been defined and on my journey I then need to define addition in terms of the tools I have been given. So the first question is: Why? By what means am I to accept this?</p>\n<p>To me, if you are going to just airdrop a successor function in then it seems no less sensible to start by airdropping addition in as a basic function and then stating the successor function is nothing more than a specific case of addition. In much the same way in geometry you might say a square is a special case of the more general rectangle or a circle is a special case of a more general ellipse.  </p>\n<p>So, if you are going to begin with a successor function why not begin with any other function? You can define the successor function as a specific case of the more general case of addition just as easily as you can define addition in terms of the successor function. So the successor function seems to me no less arbitrary a starting point than addition.</p>\n<p>Why am I wrong?</p>\n</blockquote>\n<p>Lean as a system allows you to define the mathematical objects you are working on in whichever way you like. If you want to go even more basic than natural numbers you could say that the rules for declaring and working with types are in fact the primitive axioms that Lean is based upon and the mathematicians then define things using those. However most people that use Lean are (rightfully) not interested in the inner workings of the type system that underlies Lean. They  wish to build whichever mathematical object they know to on top of Lean, in the way they are used to from normal mathematics (+ things that might make them easier to work with in Lean but that's an advanced topic).</p>\n<p>The definition of natural numbers that is being presented to you here is merely one that has been popular with mathematicians for a very long time (as already linked by Mauricio above) and thus the canonical representation of natural numbers in Lean.</p>",
        "id": 447422997,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719478797
    },
    {
        "content": "<p>Mauricio, yes, I might benefit from reading the Peano axioms and their explanation. I have no doubt my issue is coming at it from the perspective of a programmer. To me all these functions, whatever they are, make no sense before you have some generalised method by which you are able to define exactly what a function does. So, even a successor function calls for an applicable system which does what the successor function does in the same way to \"add 1\" you would need to describe the program which adds 1. You can't just have it out of the blue. Even adding 1 calls for a systematic process for adding 1. For this you need to define that systematic process and even the tools you would use to define it. So, a successor doesn't sound very fundamental to me because a lot has to happen before you do it. That's why it takes a while for children to learn how to count. We program such a successor function into children's minds which we then use for counting. That to me is why a successor function is no more axiomatic than addition. Simpler to define, yes, but not more fundamental. The fundament, for me, would be in defining the tools which enable the description of what the successor function does such that the function can be applied to any integer, just as we do when we count. Say.... you shift the rightmost symbol incrementally through an ordered list of symbols and after incrementing on the final symbol '9' you then increment the symbol to the left with the same rules and then reset the symbol to its right to zero then continue. Do you see what I mean? There is a level of abstraction beneath the successor function which we need to define it.... and that lower level can be just as well used to define addition or any other function. That's what the Lamda calculus does. So for me even to get a successor function you imply a whole box of machinery you need to use to define what it does. That is why for me the successor function cannot be foundational because you must have an even more foundational set of tools to describe the function.</p>",
        "id": 447424494,
        "sender_full_name": "Jay",
        "timestamp": 1719479197
    },
    {
        "content": "<p>Yakov, yes, I actually accept that and anticipated that criticism because it was obvious as I went along that in claiming that 3 + 2 = 2 + 3 I had to describe a proof (adding that number of kilo weights to an empty bag) to illustrate Why it is true.</p>",
        "id": 447425029,
        "sender_full_name": "Jay",
        "timestamp": 1719479325
    },
    {
        "content": "<p>Mathematically you have to start somewhere, with some set of axioms. Lean's axioms are based on type theory (plus other stuff), and in particular the successor function is essentially already \"built-in in the system\" (meaning that the existence of <code>ℕ</code> is automatic). This is not the only axiomatic system that can used for mathematics: indeed mathematicians usually tend to think to set theory as the basic axiomatic system: here <code>ℕ</code> can be defined, and the successor function is also defined.</p>",
        "id": 447425247,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1719479394
    },
    {
        "content": "<p>\"The definition of natural numbers that is being presented to you here is merely one that has been popular with mathematicians for a very long time\"</p>\n<p>Sure ok, and does it allow me to open the box on the successor function to find out what's in it and how that function is defined?</p>",
        "id": 447425459,
        "sender_full_name": "Jay",
        "timestamp": 1719479452
    },
    {
        "content": "<p>The reason why Lean (and most of the proof assistants around) uses type theory is mainly because it is more convenient. But on the other hand we know that mathematically the two systems are equivalent, so we can do mathematics as we've always done.</p>",
        "id": 447425556,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1719479485
    },
    {
        "content": "<p>\"here <code>ℕ</code> can be defined, and the successor function is also defined.\"</p>\n<p>That's what I am getting at, or trying to. In Lean do I get access to how that successor function is defined and am I able to change it or define functions, like addition, too?</p>",
        "id": 447425936,
        "sender_full_name": "Jay",
        "timestamp": 1719479597
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"731970\">Jay</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20were.20the.20rules.20of.20the.20game.20decided.3F/near/447425459\">said</a>:</p>\n<blockquote>\n<p>\"The definition of natural numbers that is being presented to you here is merely one that has been popular with mathematicians for a very long time\"</p>\n<p>Sure ok, and does it allow me to open the box on the successor function to find out what's in it and how that function is defined?</p>\n</blockquote>\n<p>The successor function is defined like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n</code></pre></div>\n<p>If you want to know what this \"means\" (in the sense of how precisely inductive types internally work, obviously you can just accept this and keep going) you will have to learn the afformentioned underlying type theory of Lean as the notion of an <code>inductive</code> type is one of the core primitives of the type theory.</p>",
        "id": 447426224,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719479682
    },
    {
        "content": "<p>In practice what we are saying is: <code>ℕ</code> is a \"set\" that contains an element, that we call <code>0</code> and elements of the form <code>succ 0</code>, <code>succ (succ 0)</code> etc.</p>",
        "id": 447426627,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1719479820
    },
    {
        "content": "<p>(and we know that they're all distinct, plus other things)</p>",
        "id": 447426693,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1719479840
    },
    {
        "content": "<p>We have resources explaining the surface level behavior of inductive types in books like Theorem Proving in Lean 4 or Functional Programming in Lean 4. There is also a theory heavy explanation of them in <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> but again this explanation is usually not of help to most people.</p>\n<p>For a beginner the only recommendation I can make is to draw a border of abstraction at some point. Where you draw that border of abstraction is of course up to you but I would recommend to draw it at the surface level effects of the <code>inductive</code> command and not at it's definition in terms of type theory.</p>",
        "id": 447426736,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719479856
    },
    {
        "content": "<p>Think like this: here are all the elements of <code>ℕ</code> (here in any line is just a symbol, it doesn't mean anything):</p>\n<ul>\n<li><code>0</code></li>\n<li><code>succ 0</code></li>\n<li><code>succ (succ 0)</code></li>\n<li>succ (succ (succ 0))<br>\n...<br>\nThe successor function just take a line a gives the following.</li>\n</ul>",
        "id": 447427482,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1719480085
    },
    {
        "content": "<p>Then of course we need other axioms, for example to prove that the elements are all distinct. And Peano came up with a particularly nice and short list of axioms.</p>",
        "id": 447427884,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1719480184
    },
    {
        "content": "<p>Concerning the fact that you want to know what <code>succ</code> <em>does</em>, I think it is because you have a programmer background. Mathematically a function doesn't do anything, it's not something we can evaluate <em>in practice</em>. The identity function (very easy to evaluate) is as good the function that gives the <code>n</code>-th digit of a Chaitin's constant (that cannot be computed).</p>",
        "id": 447429063,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1719480492
    },
    {
        "content": "<p>Note that I am not saying the mathematical point of view is better, it is just different.</p>",
        "id": 447429196,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1719480529
    },
    {
        "content": "<p>I think it is different and explains some of the problem. Especially when it comes to getting off the ground with a successor function. I want to know how is it defined, how does work, why did I get that and not something else more useful,  and why, now I have it, am I being forced to use it.</p>",
        "id": 447429832,
        "sender_full_name": "Jay",
        "timestamp": 1719480729
    },
    {
        "content": "<p>The point is that you have to start <em>somewhere</em>, right?</p>",
        "id": 447430330,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1719480890
    },
    {
        "content": "<p>I mean, you could ask \"what is <code>ℕ</code>?\"</p>",
        "id": 447430367,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1719480906
    },
    {
        "content": "<p>At some point you have to stop and accept something as \"primitive\" (i.e. an axiom). Mathematicians like to choose as few axioms as possible, and Peano's axioms are very good at it. There is nothing intrinsically wrong in having axioms for the addition, but the list would be longer (commutativity, associativity, <code>0+n = n</code>, probably some version of induction).</p>",
        "id": 447430873,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1719481070
    },
    {
        "content": "<p>Note that <code>succ</code> is not \"just a function\", it's a constructor. It doesn't compute anything, rather it constructs some data. You are defining how a natural number is \"built up\", not what operations you can do on one.</p>",
        "id": 447430972,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1719481097
    },
    {
        "content": "<p>Yes, I could. Where I am starting is with a toolkit by which the /function/ of functions can be described. In computer science that would be something like the Lambda calculus in which functions, such as the successor function, can be described. So, for me, the successor function is too high a layer of abstraction to start on. By that point assumptions have been made and the mechanism which defines what it does needs to be defined.</p>",
        "id": 447430974,
        "sender_full_name": "Jay",
        "timestamp": 1719481099
    },
    {
        "content": "<p>What about 1/0 - 1/0? It is obvious that 1/0 is a number, and it is obvious that 1/0 - 1/0 should be 0, right? Or do things become less obvious when they become more complex? Is there a clearly boundary between \"less obvious but still right\" and \"less obvious and wrong\"?</p>",
        "id": 447431030,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1719481123
    },
    {
        "content": "<p>Giaco, but succ is an operation which you apply to natural numbers, isn't it? 2 = succ (succ 0)?</p>",
        "id": 447431370,
        "sender_full_name": "Jay",
        "timestamp": 1719481213
    },
    {
        "content": "<p>What is <code>2</code>?</p>",
        "id": 447431657,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1719481265
    },
    {
        "content": "<p>You are starting in a blank space, 2 doesn't exist. Rather you can define it as an alias for <code>succ (succ zero)</code></p>",
        "id": 447431689,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1719481272
    },
    {
        "content": "<p>Sure.... the digits have no meaning until you assign meaning to them. But, even without them having meaning you can still define addition in terms of an operation which acts upon a set of symbols, those symbols being the digits of the numeric base you are using. You can define the function on a set of symbols without having to assign meaning to those symbols first.</p>",
        "id": 447432254,
        "sender_full_name": "Jay",
        "timestamp": 1719481375
    },
    {
        "content": "<p>And yes, the digits don't exist until you create them too.</p>",
        "id": 447432428,
        "sender_full_name": "Jay",
        "timestamp": 1719481408
    },
    {
        "content": "<p>Sure Giacomo, but in order to have succ 0 you need a concept of what is its successor before you can have that function produce it, don't you?</p>",
        "id": 447432990,
        "sender_full_name": "Jay",
        "timestamp": 1719481523
    },
    {
        "content": "<p>Where would you start?</p>",
        "id": 447433609,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1719481641
    },
    {
        "content": "<p><code>succ</code> doesn't produce the successor, you are defining the successor of a number with <code>succ</code>. <code>succ 0</code> does not \"return\" some value, it is itself the value. You then define everything else in terms of <code>succ</code> and <code>zero</code>, not before.</p>",
        "id": 447434164,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1719481751
    },
    {
        "content": "<p>Riccardo.... you know what? I don't know. I think that question is even more fundamental than mathematics. You can easily respond with \"Well, wherever you start, why start with maths at all? Why not start with something else altogether?\". Why invent anything at all, especially given that you probably can't without making an unnecessary assumption.</p>",
        "id": 447434278,
        "sender_full_name": "Jay",
        "timestamp": 1719481777
    },
    {
        "content": "<p>Giacomo, sure, but to do that you must have some concept of its successor, mustn't you?</p>",
        "id": 447434829,
        "sender_full_name": "Jay",
        "timestamp": 1719481887
    },
    {
        "content": "<p>The point is not really <em>where to start</em>, but the fact that you need a starting point. Otherwise it is like keeping asking \"why? why? why?\" forever. You are free to choose the rules you want before playing the game, but you need rules to play a game.</p>",
        "id": 447434857,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1719481893
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"731970\">Jay</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20were.20the.20rules.20of.20the.20game.20decided.3F/near/447430974\">said</a>:</p>\n<blockquote>\n<p>Yes, I could. Where I am starting is with a toolkit by which the /function/ of functions can be described. In computer science that would be something like the Lambda calculus in which functions, such as the successor function, can be described. So, for me, the successor function is too high a layer of abstraction to start on. By that point assumptions have been made and the mechanism which defines what it does needs to be defined.</p>\n</blockquote>\n<p>If you want this read <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a>, but if you are not good with type theory yet this won't be helpful for you</p>",
        "id": 447435243,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719481973
    },
    {
        "content": "<p>For me the idea that \"the elements of each inductive set are terms of a certain form\" sounded not only weird but also very hard to define precisely...</p>",
        "id": 447435366,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1719481998
    },
    {
        "content": "<p>Its not really, by its very notion an inductive set is the least set that contains all the elements defined by its inductive rules. If you now put all of these rules into Lean and say that they are of the type that you are defining you get quite literally the least type whose elements are constructed from the inductive rules.</p>",
        "id": 447435964,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719482144
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"731970\">Jay</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20were.20the.20rules.20of.20the.20game.20decided.3F/near/447434829\">said</a>:</p>\n<blockquote>\n<p>Giacomo, sure, but to do that you must have some concept of its successor, mustn't you?</p>\n</blockquote>\n<p>Well sure in your mind you must have such a concept. But in this representation of natural numbers you are identifying a natural number as being either zero or the successor of another natural number.</p>\n<p>Note that there could be other ways to identify natural numbers (for example the <code>zero</code>/<code>succ</code> correspond to an unary representation, but you can go binary/n-ary), though you probably don't want to use e.g. addition, because then you have multiple ways to represent the same concept (<code>zero</code>? Or <code>add zero zero</code>? They are <em>definitionally</em> different but for you they are probably the same number, right?) and that complicates things a lot.</p>",
        "id": 447436137,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1719482199
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"731970\">@Jay</span>, take a look at \"A Modern Perspective on Type Theory - From its Origins until Today\", by Fairouz Kamareddine...</p>",
        "id": 447436259,
        "sender_full_name": "Eduardo Ochs",
        "timestamp": 1719482241
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20were.20the.20rules.20of.20the.20game.20decided.3F/near/447435243\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"731970\">Jay</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20were.20the.20rules.20of.20the.20game.20decided.3F/near/447430974\">said</a>:</p>\n<blockquote>\n<p>Yes, I could. Where I am starting is with a toolkit by which the /function/ of functions can be described. In computer science that would be something like the Lambda calculus in which functions, such as the successor function, can be described. So, for me, the successor function is too high a layer of abstraction to start on. By that point assumptions have been made and the mechanism which defines what it does needs to be defined.</p>\n</blockquote>\n<p>If you want this read <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a>, but if you are not good with type theory yet this won't be helpful for you</p>\n</blockquote>\n<p>I can additionally offer you the practical computer science point of view which is how these things actually look like in memory if you are working with them. But I don't think that is of much help to fix this confusion?</p>",
        "id": 447436307,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719482263
    },
    {
        "content": "<p>Another alternative viewpoint that <em>might</em> seem less arbitrary: with <code>zero</code>/<code>succ</code> you are defining a number as how many times you have <code>zero</code> wrapped in a <code>succ</code>.</p>",
        "id": 447437582,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1719482662
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"731970\">Jay</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20were.20the.20rules.20of.20the.20game.20decided.3F/near/447419265\">said</a>:</p>\n<blockquote>\n<p>Say, as a programmer, you can define a function which adds 1 or you can define a function which adds anything from 0 to 99. One of those functions doesn't take precedence or priority or have some default special status over the other, does it?</p>\n</blockquote>\n<p>This isn't the right comparison.</p>\n<p>Binary numbers:Unary numbers::Binary addition:Unary addition.</p>\n<p>The representation of a number exists on a different and more fundamental level than operations on numbers.</p>\n<p>You cannot define binary addition before defining binary numbers. And defining binary numbers does not give you addition for free, you have to make an ALU, which is quite involved. And the fact that addition in the ALU is commutative is not obvious at all, this requires formal verification.</p>\n<p>Just as all datatypes are represented as lists of 0s and 1s in memory, all datatypes are represented as trees of constructors in Lean's type theory. <code>succ</code> is just the unary number version of a bit. It is not comparable to addition. Rather it is the subject of addition.</p>\n<p>You can make the Natural Number Game using <code>BinNat</code> instead of <code>Nat</code> if it puts you more at ease. It is more efficient but harder to prove theorems about.</p>",
        "id": 447442369,
        "sender_full_name": "llllvvuu",
        "timestamp": 1719483970
    },
    {
        "content": "<p>FWIW axiomatization is a thing in Lean. This is achieved with typeclasses. For example <code>Nat</code> is a <code>Semiring</code>. Semirings are defined in terms of <code>+</code> and <code>*</code>. No <code>succ</code>, like you wanted. However, \"semiring\" does not define <code>Nat</code> (e.g. there are semirings other than <code>Nat</code>).</p>",
        "id": 447443219,
        "sender_full_name": "llllvvuu",
        "timestamp": 1719484313
    },
    {
        "content": "<p>On the topic of rule invention, axiomatization, and where natural numbers come from, if one defines a Semiring (a collection of axioms) and the axioms of a category (there are objects and morphisms between them), then one can show that the naturals are the initial object in that category.</p>",
        "id": 447446018,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719485232
    },
    {
        "content": "<p>I want to add one more complication. <span class=\"user-mention\" data-user-id=\"731970\">@Jay</span> , you linked succ with \"adding one\". But why should we call that addition? I could just as well call + taking the minimum of two numbers, and the operation * that takes two arguments a and b such that a * zero = zero * a = a and a * succ b = succ (a * b). This is also a Semiring (if our numbers have positive infinity in them too)</p>",
        "id": 447452583,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719487497
    },
    {
        "content": "<p>Giacomo, yes, I see that zero / succ is how the tutorial begins. I can see some of the descriptions too are describing /how it is/ in the environment. I think what I'm looking for is a clearer sense of /why/ that is how it is. That's one thing.</p>\n<p>On another track, I am not clear on what you gain from doing things as you describe in your example. Say, for example, /if/ you are defining 37 as 0, wrapped in nested successor functions, 37 times then don't you still need the concept of the number 37 beforehand to do it?</p>",
        "id": 447516168,
        "sender_full_name": "Jay",
        "timestamp": 1719504404
    },
    {
        "content": "<p>llllvvuu, I agree with you that you don't get addition for nothing. If anything, that is part of what I am driving it. When we look at it that way though my point is you don't get a successor function for free either. In fact, some microprocessors I have used have something like the successor function and addition in terms of Increment and Add commands. Neither of them come for free, both of them need to be defined in the silicon or the software, somehow. So, even to have a successor function on a CPU somewhere there must be something which describes its implementation. I tried to describe it in shorthand once here before.  Let's say you are doing this on binary numbers. You begin with a pointer pointing to the rightmost bit of a binary word. You invert the bit. If that bit inverts to 0 then you move the pointer one binary digit to the left and the you repeat the same process with the next bit along. If a bit does not invert to zero then the incrementation is finished. Next time you want to increment a number you do that again with the number you want to increment. See what I mean? There is nothing \"fundamental\" about a successor function. It in itself is still something you need to define in terms of other operations which describe what it means and does. </p>\n<p>Furthermore, as I also wrote earlier, because you need to do that then why start with such a limited function? You may as well start with addition too, which is exactly what most even simple microprocessors do. Slightly more complex ones have multiplication in the silicon, slightly more complex ones than that have division and more complex ones than that have floating point maths. Certainly incrementation is the simplest of those operations but I don't think that simplicity alone makes it axiomatic. And, if we are going to argue for increased simplicity as increasingly axiomatic then we would need to then accept there are simpler operations even than a successor function. In computing there are then logical operations like AND, OR and NOT which are simpler even than incrementation. So, if simplicity is what we are arguing for then a successor function is still not foundational because there are simpler operations than that. </p>\n<p>My struggle is the same as when I began: Sure, in this environment perhaps you do begin with 0 and a successor function but the operation of the successor function still needs to be defined before it can make sense just like the same is true of addition. So, why not just begin with natural numbers and basic arithmetic including incrementation? Why give me a successor function and not addition given, as I said, to my mind incrementation is just a special unique case of addition anyway. And, also, surely one which only makes sense in terms of the naturals? You can't have a successor function for reals can you but you can still define arithmetical functions like addition for reals.</p>\n<p>Again, it leaves me in the same place as when I started: I can see that I get 0 and the successor function but without understanding Why I do it seems like an arbitrary choice which could just as easily been something else. </p>\n<p>And, for me as a programmer, that \"something else\" would be something like the Lambda calculus or something rather than a set of axiomatic statements but instead rather an axiomatic set of rules or processes from which arbitrary functions can be built, which is exactly what the Lambda calculus attempts to be: A very, very simple set of operations intending to be a minimal set of operations from which such things as successor functions and addition can be built. </p>\n<p>But, I am starting to turn in circles by offering various different but equally arbitrary ways to begin. The central point for me being \"0 plus a successor function seems arbitrary. We could have started with something else. So, what can we do to find a starting point which is demonstrably Not arbitrary, or, what can we do to demonstrate what we get in this environment, with 0 + a successor function, is not arbitrary?</p>\n<p>I might add: Surely, 0 + succ is <em>simpler</em> than N + addition but... so what? It isn't as simple as the Boolean operations. It also has far less expressive power than addition.</p>\n<p>So, we can't convincingly defend 0 + succ, versus other possible starting points, against accusations of arbitrariness then why don't we start with N + addition, or the Boolean operations and some tools to apply those in building a successor function, instead?</p>\n<p>I'm making this more complicated than it needs to be by defending my case.</p>\n<p>The simplest way of putting it is: \"Why? Why this and not something else?\". What's a concrete defence for why we didn't do one of a multitude of other things we could have done instead?  And, can we define some starting point for which we can also provide an objectively agreeable defence so all reasonable people can agree there was no better way to begin and avoid accusations of false presumption where something else could have been used as well or better instead?</p>",
        "id": 447522445,
        "sender_full_name": "Jay",
        "timestamp": 1719506294
    },
    {
        "content": "<p>The simplest explanation here is, all concrete types are made by using the inductive keyword. And succ is not just a function, it is a constructor. And by the axioms of this type theory, constructors are injective, so zero is never ever equal to anything succ x, by the axioms that \"inductive\" installs.</p>",
        "id": 447527404,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719507403
    },
    {
        "content": "<p>There are various ways to define integers (Z) for example. One is to have an inductive that has a nonnegative constructor and a negative constructor, where the constructors take Nats. Or one can have an inductive that has a nullary constructor zero and a positive and negative constructors that take Nats. Or one can define integers as a quotient type of Nats under some relation.</p>",
        "id": 447528078,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719507553
    },
    {
        "content": "<p>After making each of these constructions, one can show that there are isomorphisms between them that respect what \"zero\" means and what \"one\" means and also what \"add\" means on each type.</p>",
        "id": 447528289,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719507600
    },
    {
        "content": "<p>Ok but, without wanting to cause too much frustration: Is that not mere reiteration? You are doing a good job of explaining /what/ I get in this environment, but, my fundamental question is not \"How does this Lean thing work?\", it is \"<em>Why</em> does it work this way?\".</p>",
        "id": 447528305,
        "sender_full_name": "Jay",
        "timestamp": 1719507602
    },
    {
        "content": "<p>Lean works in this inductive way because it is an explicit choice of the underlying type theory. Because this type of Calculus of Constructions creates types that make it straightforward to write proofs about the constructed objects, and gives computational rules too (what's known as a recursor).</p>",
        "id": 447528797,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719507700
    },
    {
        "content": "<p>And on top of this, the proving methodology about these objects doesn't require a huge set of laws. Rather, the kernel, which is what checks that everything is rigorously defined, is small, that is, there is a small set of laws that are thought to not be inconsistent -- that they wouldn't accept something false. This is what <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> is about</p>",
        "id": 447529277,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719507812
    },
    {
        "content": "<p>Ok cool. So..... is \"this type of calculus of constructors\" the same as, or part of \"the underlying type theory\"?</p>",
        "id": 447529353,
        "sender_full_name": "Jay",
        "timestamp": 1719507833
    },
    {
        "content": "<p>This is out of my depth, but I would say \"part of\" but foundationally.</p>",
        "id": 447529639,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719507885
    },
    {
        "content": "<p>But I want to note that this is separate from the choice of how to construct the naturals.</p>",
        "id": 447529750,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719507913
    },
    {
        "content": "<p>I would suggest that you read up on how the reals can be constructed. Not in Lean but in regular old math classes and departments. And what we care about in the reals _after_ we construct them.</p>",
        "id": 447530190,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719508002
    },
    {
        "content": "<p>Yep, that does sound like a pretty good start. Is \"this type of calculus of constructors\" a general topic I can learn as well as the example case you provide?</p>",
        "id": 447530590,
        "sender_full_name": "Jay",
        "timestamp": 1719508087
    },
    {
        "content": "<p>You could try reading about how it works in lean in <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a></p>",
        "id": 447531643,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719508325
    },
    {
        "content": "<p><a href=\"https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html\">https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html</a> and get to chapter 12</p>",
        "id": 447531676,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719508332
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"731970\">Jay</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20were.20the.20rules.20of.20the.20game.20decided.3F/near/447530590\">said</a>:</p>\n<blockquote>\n<p>Yep, that does sound like a pretty good start. Is \"this type of calculus of constructors\" a general topic I can learn as well as the example case you provide?</p>\n</blockquote>\n<p>As I've been telling you over multiple messages now, if you truly want to understand the internals of Lean's type theory you can read <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> and related academic material, resources like <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a> or the functional programming book will teach you about what you can do with this system, not how it works underneath. And again I heavily recommend to instead focus on working with the system for a while before trying to understand complicated material like <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> because it will be of highly limited use in your day to day activity.</p>",
        "id": 447533354,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719508726
    },
    {
        "content": "<p>Henrik, I think <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a> is a great place to start here. It may not answer all of Jay's questions, but I think it is a good place from which one could go to something like <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> in the future for a deep understanding.</p>",
        "id": 447535590,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1719509258
    },
    {
        "content": "<p>Yes, that's what I was trying to say with the second half of my paragraph.</p>",
        "id": 447536275,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719509476
    },
    {
        "content": "<p>Yes, thanks Henrik, and in fact I know you have have been saying that and I haven't ignored what you have said, I have started to read that <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> document and I have found it very interesting as it references other previous theorem proving systems I have encountered and it mentions the Lambda calculus which I have mentioned more than once. </p>\n<p>I haven't looked at <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a> yet but I do that next. Thank you.</p>",
        "id": 447556382,
        "sender_full_name": "Jay",
        "timestamp": 1719514332
    },
    {
        "content": "<p>This is a long thread and I might I have missed someone else expressing this point, but it's worth noting that you don't have to accept the existence of a successor function. Everything you can see you can do with it is a truth contingent on there being a successor function. The fact that no one's ever proved a contradiction using the successor function is evidence that there could be one, but just because people have built the airstrip and surrounding infrastructure doesn't mean that anything's been airdropped already :-)</p>\n<p>Sometimes I like to think about axioms as being a library interface for all of mathematics, where if you have an \"operating system\" that provides these resources, you can run this mathematics program there.</p>\n<p>(Regarding \"why not start with addition instead of the successor function\", that's something you can do, but it's technically more challenging to set up I think. The one that comes to mind is where you take all expressions involving 0, 1, and plus, then you have to come up with all the rules for what it means for two such expressions to be \"the same\", and then you have to somehow assert that they're \"the same\" by using a quotient construction. Your observation about successor as being an abstract version of counting is astute: we're saying \"what if you <em>could</em> count forever? and what if you could make use of that count an reinterpret it?\" The latter question is about being able to do recursive definitions.)</p>",
        "id": 447574820,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1719519113
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"731970\">Jay</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20were.20the.20rules.20of.20the.20game.20decided.3F/near/447522445\">said</a>:</p>\n<blockquote>\n<p>llllvvuu, I agree with you that you don't get addition for nothing. If anything, that is part of what I am driving it. When we look at it that way though my point is you don't get a successor function for free either. In fact, some microprocessors I have used have something like the successor function and addition in terms of Increment and Add commands. Neither of them come for free, both of them need to be defined in the silicon or the software, somehow. So, even to have a successor function on a CPU somewhere there must be something which describes its implementation. I tried to describe it in shorthand once here before.  Let's say you are doing this on binary numbers. You begin with a pointer pointing to the rightmost bit of a binary word. You invert the bit. If that bit inverts to 0 then you move the pointer one binary digit to the left and the you repeat the same process with the next bit along. If a bit does not invert to zero then the incrementation is finished. Next time you want to increment a number you do that again with the number you want to increment. See what I mean? There is nothing \"fundamental\" about a successor function. It in itself is still something you need to define in terms of other operations which describe what it means and does. </p>\n</blockquote>\n<p>The issue with this comparison is that successor is not a function. Would you say the number 101010 needs to be \"implemented\"? In some sense, yes (you need to create a \"bit\" in hardware) but clearly not on the same level as 101010 + 101010 needs to be implemented.</p>\n<p>Your comparison with flipping bits is not applicable because succ is not an algorithm that has an input and output. It is just the input itself (just like a bit is not a function). You presume that a unary number processor would have a <code>succ</code> and <code>add</code> ops in its assembly, and that we are unfairly privileging the <code>succ</code> op. But this premise is flawed. There would be no <code>succ</code> op.</p>\n<p>The \"function\" you're thinking of is the function \"prepend a succ to this number\". But that is not the same as \"succ\", just as \"prepend a bit to this number\" is not the same as \"bit\". What might be confusing is that both things are called <code>succ</code>, but it's important to understand this distinction.</p>\n<p>Since you are familiar with the Lambda calculus, you must be aware of Church numerals, yes? This is the same thing.</p>",
        "id": 447603978,
        "sender_full_name": "llllvvuu",
        "timestamp": 1719527472
    },
    {
        "content": "<p>Here's a janky illustration in C:</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"cp\">#include</span><span class=\"w\"> </span><span class=\"cpf\">&lt;assert.h&gt;</span>\n<span class=\"cp\">#include</span><span class=\"w\"> </span><span class=\"cpf\">&lt;stdlib.h&gt;</span>\n<span class=\"cp\">#include</span><span class=\"w\"> </span><span class=\"cpf\">&lt;stdio.h&gt;</span>\n<span class=\"cp\">#include</span><span class=\"w\"> </span><span class=\"cpf\">&lt;string.h&gt;</span>\n\n<span class=\"k\">typedef</span><span class=\"w\"> </span><span class=\"kt\">char</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"p\">;</span>\n\n<span class=\"cp\">#define zero (0)</span>\n<span class=\"cp\">#define succ (1)</span>\n\n<span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"nf\">print</span><span class=\"p\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"k\">while</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"succ \"</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"p\">}</span>\n<span class=\"w\">  </span><span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"p\">);</span>\n<span class=\"w\">  </span><span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"zero</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"nf\">add</span><span class=\"p\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">succ_y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">Nat</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">malloc</span><span class=\"p\">((</span><span class=\"n\">strlen</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"kt\">char</span><span class=\"p\">));</span>\n<span class=\"w\">    </span><span class=\"n\">memcpy</span><span class=\"p\">(</span><span class=\"n\">succ_y</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">strlen</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"kt\">char</span><span class=\"p\">));</span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">succ_y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">succ_y</span><span class=\"p\">);</span>\n<span class=\"w\">  </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"kt\">char</span><span class=\"w\"> </span><span class=\"n\">two</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">succ</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"p\">};</span>\n<span class=\"w\">  </span><span class=\"n\">print</span><span class=\"p\">(</span><span class=\"n\">two</span><span class=\"p\">);</span>\n<span class=\"w\">  </span><span class=\"kt\">char</span><span class=\"w\"> </span><span class=\"n\">three</span><span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">succ</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"p\">};</span>\n<span class=\"w\">  </span><span class=\"n\">print</span><span class=\"p\">(</span><span class=\"n\">three</span><span class=\"p\">);</span>\n<span class=\"w\">  </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">five</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">two</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">three</span><span class=\"p\">);</span>\n<span class=\"w\">  </span><span class=\"n\">print</span><span class=\"p\">(</span><span class=\"n\">five</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Note that there is no <code>succ</code> function. Rather, <code>succ</code> is a primitive value. But there needs to be an <code>add</code> function. How would it be done the other way around?</p>",
        "id": 447608591,
        "sender_full_name": "llllvvuu",
        "timestamp": 1719529350
    },
    {
        "content": "<p>OK, so I can see how in your C code succ is assigned to a primitive type, a char, not a function. With succ and zero defined as char values you can make strings of them. So that then begs thee question, \"So, what is the meaning of 'succ 0'?\". Doesn't 'succ 0' mean \"the thing that comes after 0'?</p>",
        "id": 447609955,
        "sender_full_name": "Jay",
        "timestamp": 1719530006
    },
    {
        "content": "<p>Yes, that's how we've chosen to represent it. We could have chosen represent <code>Nat</code> in a number of other ways. For example, if we were to make it a linked list of <code>uint64_t</code>, then the \"next\" pointer would be the analogue of succ. On particular it could be read as<code>succ 0x... n</code> instead of <code>succ n</code>. Actually, Lean has a type that looks like this called <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List#doc\">docs#List</a> (familiar from ML / Haskell) which is basically a linked list. Perhaps the <code>List</code> type may be less controversial to you, although it is essentially the same principle as the <code>Nat</code> type.</p>\n<p>The reason we have chosen to represent <code>Nat</code> as a string of <code>succ</code>, rather than as, say, a string of <code>uint64_t</code>s, is that it's much easier to do proofs with. We don't prioritize computational efficiency here.</p>",
        "id": 447610620,
        "sender_full_name": "llllvvuu",
        "timestamp": 1719530453
    },
    {
        "content": "<p>Note that this is no more arbitrary than choosing the represent numbers as sequence of 0 and 1. In one case (binary), we chose the representation because it is easy to represent with circuits. In another case (decimal), we chose the representation because it is easy to represent with 10 fingers. In yet another case (unary), we chose the representation because it is easy for mathematical proofs.</p>",
        "id": 447610930,
        "sender_full_name": "llllvvuu",
        "timestamp": 1719530663
    },
    {
        "content": "<p>What if I postulate a type of nonpositive integers? With two constructors, zero and pred. Then pred means the thing that comes before 0... But this type is totally isomorphic to Nat, I just changed the name of one of the constructors.</p>",
        "id": 447611214,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719530858
    },
    {
        "content": "<p>Indeed. This is similar to how <code>0x41</code> could be interpreted as <code>'A'</code>, <code>65</code>, or a number of other things.</p>",
        "id": 447611379,
        "sender_full_name": "llllvvuu",
        "timestamp": 1719530970
    },
    {
        "content": "<p>That is indeed correct, the interpretation of the values of a type is up to the reader. You could also say that <code>List Unit</code> is isomorphic to <code>Nat</code> or that the type of flat semi lattices:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">FlatTopLattice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">top</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>is isomorphic to <code>Option</code> and so on.</p>",
        "id": 447611402,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1719531000
    },
    {
        "content": "<p>Oh, I agree with the fact binary numbers are no less arbitrary. I don't think beginning with a numbering system of any kind is a good start. Any numbering system would also be arbitrary. Why a numbering system at all? What I do believe in though is beginning with a system which can be used to define such a thing and the operations which act upon it. That's why I have mentioned the Lambda Calculus because, from a computer science point of view, it's one of the purest systems we have.</p>\n<p>With a computer though I see it not as an attempt to establish something fundamental about logic or reasoning. It isn't supposed to be an idealised existential environment in which each step from the first is validated. So with a computer it's far easier for me to accept the arbitrariness of some of its constructs. With a computer all that we need to expect is a toolkit of things which you can use to make enginery which provides some useful purpose. You can use a computer to build a theorem prover, for example. You use it make a theorem prover because the theorem prover, you expect, is a far more exacting environment than that of a general-purpose computing system. You use the computer to construct algorithms and the theorem prover you use to either prove or expose the faults in an algorithm.</p>\n<p>So, the toolkit of things I expect from a theorem prover I expect to be far more exacting and more robust to scrutiny than a computer language, for example C++, which I don't think would be regarded as elegant or beautiful or ideal by most people. It does offer a long-established hotch-potch of things which have proven to be useful though, but I digress. This isn't the topic.</p>",
        "id": 447615374,
        "sender_full_name": "Jay",
        "timestamp": 1719532510
    },
    {
        "content": "<p>I think I get what you are saying, Yakov. You have a symbolism but what you name it or use it to represent is itself arbitrary. </p>\n<p>I do sometime think that even binary is a gross abstraction of what actually happens at the electronics level. The close we look at the electronics the less it looks like binary. If we were to look at a chip on the microscopic level and watch the behaviour of electronics we'd realise even the 1s and 0s we talk about are notional too. They are merely labels we have given to a, hopefully, predictable behaviour which has been filtered through many separate stages to make it appear to be the case. So, even the binary digits we assign to those behavioural effects are notional in themselves. It isn't even really binary, it's some sort of physical property of the underlying materials to which we assign those labels.</p>",
        "id": 447616299,
        "sender_full_name": "Jay",
        "timestamp": 1719532898
    },
    {
        "content": "<p>Is the Lambda Calculus not \"arbitrary\" and comparable to a numbering system? Is <code>λ</code> not \"airdropped\" to us? Alternatively, is there a better way to represent numbers in the lambda calculus than Church encoding? (which is a numbering system, and actually the same numbering system as the Peano one)</p>",
        "id": 447616824,
        "sender_full_name": "llllvvuu",
        "timestamp": 1719533248
    },
    {
        "content": "<p>Oh, yes.... but that's what I said in my previous post...... what I am getting at is perhaps what I expect as a computer person.....</p>\n<p>You have some such thing as a Turing-Complete system. That is non-arbitrary enough because it is defined as a system which can describe anything computable. What route you take to get that from it doesn't need to be ideal. It could result in the Lambda Calculus, Lisp, Haskell, C++ or any one of a load of other esoteric Turing-Complete systems. It's actually quite hard to Avoid Turing-Completeness. It isn't an especially wonderful quality. If you define a functional computer programming language with whatever you know about programming if you have some experience writing software. If such a language has loops and conditional branches it will almost certainly be Turing-complete as if by accident.</p>\n<p>My point is That level, the level at which you are describing the system you use to describe the system, doesn't need to avoid arbitrariness so long as it achieve the end-result of Turing completeness and It's easy enough for a human to use. Hence, there are dozens of different Turing complete computer programming languages. Most of them are obviously not ideal and most contain fairly arbitrary choices and most of those choices are inherited by default from previous languages on which they are based. </p>\n<p>You can then use that system to describe something like a Theorem prover but if you set out to do that then the system you describe using the general-purpose computing environment should be far more exacting. </p>\n<p>I mean, that's just a repetition of what I said previously and what I said previously is that's what you find in something like Lean:</p>\n<p>The computing platform used to describe Lean is not pure or perfect. It isn't supposed to be. It's just supposed to be useful, easy enough to use, and general purpose. </p>\n<p>There are examples of programming languages defined to meet the dual purpose of being general purpose but also of being robust enough to be usable in proofs.</p>\n<p><a href=\"https://cakeml.org/\">https://cakeml.org/</a></p>\n<p>The reason you define Lean and you don't use C++ instead is because the purpose of Lean, or a theorem prover, is far more to achieve robustness and avoid arbitrariness and arrive at something far more axiomatic and bullet-proof in nature. With the aim of being bullet-proof I think it should be fair we fire bullets at it and see what happens. Isn't that somewhat the purpose of theorem proving? </p>\n<p>That's my thesis on the matter. Lean is a robust system built out of a toolkit which is less robust and that's why you built it: Because the system you built it on isn't robust enough. The demands you have from Lean <em>should</em> be far more robust than the demands you place on the underlying system it was built from because that is its purpose. Again, I am in danger of going round in circles: You take a general-purpose system of moderate robustness (the computer and its languages) and you use that toolset to define a far more restrictive system of far greater robustness, be it Lean, Isabelle, COQ or something else.</p>",
        "id": 447619451,
        "sender_full_name": "Jay",
        "timestamp": 1719535008
    },
    {
        "content": "<p>What do you consider not robust about unary/Peano numbers / Church numerals? As far as I can tell you haven't actually managed to break it nor implement a robust alternative. Or are you aware of any theorem provers that define natural numbers not in terms of a numbering system? If so, how do you write down a number?</p>",
        "id": 447620031,
        "sender_full_name": "llllvvuu",
        "timestamp": 1719535469
    },
    {
        "content": "<p>Well, again, my outlook on that is more \"Why?\". An interrogation rather than a statement about it. It isn't immediately obvious to me what you get from that. From my point of view you shouldn't need to begin with a numbering system of any kind for the reasons we already explored: It's gong to be arbitrary. Merely the fact it is a numbering system is going to be arbitrary. Why a numbering system? Why not something else? </p>\n<p>Rather, my view is the underlying system, be it the Lambda Calculus or any thing else (C++ if you want) need not itself be axiomatic. All it needs to be is general purpose, such as C++ is. The Lambda calculus is too, but you wouldn't really want to try to write complex software with it although we have Haskell and that's probably the nearest we have got to somebody trying to do just that (with much success).</p>\n<p>Then with that set of underlying tools you are able to construct such things as numbering systems or any more (or less) restrictive scheme of working. With a compiler language written in Assembly you get a less restrictive system from a more restrictive one. With Lean you derive a More restrictive scheme from a Less restrictive one.</p>\n<p>The issue I have with Peano numbers is therefore again: Why? It isn't obvious to me what you get from that which stops you from just having the natural numbers in the first place. </p>\n<p>I feel like I am talking to people fighting my on my suggestion the successor function is just taken from basic counting. It's just accepted as \"yep, that's a basic thing. We should use it\". Within Lean one of the first things I learned is the proof \"one_eq_succ_zero\". So, by extension, I suppose \"ten_eq_succ_nine\"? So I can as yet see no important difference between the successor function and counting. Doesn't it say in lean that they are proven to be equivalent? If you can have that then why not give yourself the set of natural numbers and addition instead? Somebody may have tried to explain this before but if they did I clearly didn't understand the explanation.</p>",
        "id": 447621831,
        "sender_full_name": "Jay",
        "timestamp": 1719536306
    },
    {
        "content": "<p>Can you implement that \"something else\"?</p>\n<p>\"just having the natural numbers in the first place\" how? Can you implement it?</p>",
        "id": 447622067,
        "sender_full_name": "llllvvuu",
        "timestamp": 1719536399
    },
    {
        "content": "<blockquote>\n<p>It isn't obvious to me what you get from that which stops you from just having the natural numbers in the first place.</p>\n</blockquote>\n<p>Wait till you find out that Lean doesn't have <code>=</code> in the first place, and instead builds it from first principles (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Eq#src\">src#Eq</a>) in the same way as it builds <code>Nat</code>!</p>",
        "id": 447623458,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1719536793
    },
    {
        "content": "<blockquote>\n<p>Can you implement that \"something else\"?</p>\n</blockquote>\n<p>Well, by something else, I mean <em>anything</em> else. I mean instead of giving you natural numbers or Peano numbers or a successor function instead what you get is a system in which you can define those things... or something else instead. Anything else. Not just one specific arbitrary thing.</p>\n<blockquote>\n<p>\"just having the natural numbers in the first place\" how? Can you implement it?</p>\n</blockquote>\n<p>I think so. In the way I explained: You begin instead with a system through which you can implement it. Such as system could, for the sake of starting gambit, accept symbols and allow you to define operations which act upon those symbols. If anything that's what a basic Turing-Machine is. That way you can start by accepting the symbols typically used by numbering systems like binary or decimal are arbitrary. You can accept the operations you define which act upon those symbols, such as addition, are arbitrary. Or the choice of zero or a successor is arbitrary and you can also do none of those arbitrary things but something else (anything you like) with the underlying system instead. </p>\n<p>That way you can then say \"yes, we accept the successor function is arbitrary, but that's ok because it's useful and here's why\", just as you can with any system described using the same tools. Surely, it's an easier thing to have a system and accept the arbitrary nature of any such system defined by it? Then you can have a theorem prover or algebra of ZFC made using the same underlying system.</p>",
        "id": 447623778,
        "sender_full_name": "Jay",
        "timestamp": 1719536893
    },
    {
        "content": "<blockquote>\n<p>Wait till you find out that Lean doesn't have <code>=</code> in the first place</p>\n</blockquote>\n<p>The point is I can absolutely cope with that. That, again, is my point. The thing is your point seems only to underline my point. You don't get = and you need to define what it is from first principles? Great! I'm happy about it.</p>\n<p>So then... why did you get the successor function? (and not =?) </p>\n<p>So, I'm great with not getting = for free and my point is you shouldn't have the successor function for free either!</p>\n<p>You shouldn't get <em>anything</em> for free. You should Have to justify it.</p>",
        "id": 447624215,
        "sender_full_name": "Jay",
        "timestamp": 1719537046
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"731970\">Jay</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20were.20the.20rules.20of.20the.20game.20decided.3F/near/447624215\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Wait till you find out that Lean doesn't have <code>=</code> in the first place</p>\n</blockquote>\n<p>The point is I can absolutely cope with that. That, again, is my point. The thing is your point seems only to underline my point. You don't = but need to define what it means from first principles? Great! </p>\n<p>So... why'd you get the successor function and not =? </p>\n<p>So, I'm great with not getting = for free and my point is you shouldn't have the successor function for free either!</p>\n</blockquote>\n<p>But Lean didn't give us <code>succ</code> either. We created <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat#doc\">docs#Nat</a> the same way we created <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Eq#doc\">docs#Eq</a>. It's not \"free\" and it doesn't come with the system.</p>",
        "id": 447624515,
        "sender_full_name": "llllvvuu",
        "timestamp": 1719537131
    },
    {
        "content": "<p>Ok fine.... that's progress.</p>\n<p>So.... we didn't get it for free.... so where did we get it from and why?</p>",
        "id": 447624897,
        "sender_full_name": "Jay",
        "timestamp": 1719537308
    },
    {
        "content": "<p>If you want to play hard-mode lean, write <code>prelude</code> at the top of your file</p>",
        "id": 447624911,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1719537330
    },
    {
        "content": "<p>Then you get almost nothing; no <code>succ</code>, no <code>Eq</code>, no <code>Nat</code>, ...</p>",
        "id": 447624919,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1719537337
    },
    {
        "content": "<p>The absence of <code>prelude</code> means <code>import Init</code>, and then you get everything defined in those imported file</p>",
        "id": 447625058,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1719537420
    },
    {
        "content": "<p>Ok. I am very happy about that! But you do get <em>something</em>, right? So, what's the least you can have?</p>\n<p>In the \"You can't have any less stuff than this\" what's in it? </p>\n<p>What is the underlying thing from which you are building all these conceptual things like equality and a successor function?</p>",
        "id": 447625101,
        "sender_full_name": "Jay",
        "timestamp": 1719537472
    },
    {
        "content": "<p>You get the <code>inductive</code> keyword, which is part of the type theory</p>",
        "id": 447625302,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1719537615
    },
    {
        "content": "<p>You get a kind of souped-up lambda calculus. You can start here: <a href=\"https://www.youtube.com/playlist?list=PLNwzBl6BGLwOKBFVbvp-GFjAA_ESZ--q4\">https://www.youtube.com/playlist?list=PLNwzBl6BGLwOKBFVbvp-GFjAA_ESZ--q4</a></p>",
        "id": 447625406,
        "sender_full_name": "llllvvuu",
        "timestamp": 1719537717
    },
    {
        "content": "<p>Since you are interested in foundations, it sounds like you want to understand the Lean kernel. You can try also: <a href=\"https://ammkrn.github.io/type_checking_in_lean4/\">https://ammkrn.github.io/type_checking_in_lean4/</a> as well as <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> mentioned above. The former may be more accessible as it is more concrete and discusses code/implementation). You can see also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.expr#doc\">docs#Lean.expr</a>. And look up \"calculus of inductive constructions\". If you are looking for \"minimal\" then this is it, and if it's not minimal enough for you, then that is the thing to critique, not the init/prelude (as you are free to not use those)</p>",
        "id": 447625665,
        "sender_full_name": "llllvvuu",
        "timestamp": 1719537890
    },
    {
        "content": "<blockquote>\n<p>You get the <code>inductive</code> keyword, which is part of the type theory</p>\n</blockquote>\n<p>I am at # <code>induction</code> in the tutorial and it isn't something immediately comprehensible to me. I have applied it but I don't understand how it transformed the goal into the two goals I now have. To try not to spread out on tangents here I have asked for an explanation in the main \"new members\" channel. Please feel free to help me there if you can.</p>\n<p>Presumably the \"inductive\" keyword and <code>induction</code> are related?</p>",
        "id": 447626548,
        "sender_full_name": "Jay",
        "timestamp": 1719538410
    },
    {
        "content": "<blockquote>\n<p>You get a kind of souped-up lambda calculus. You can start here: <a href=\"https://www.youtube.com/playlist?list=PLNwzBl6BGLwOKBFVbvp-GFjAA_ESZ--q4\">https://www.youtube.com/playlist?list=PLNwzBl6BGLwOKBFVbvp-GFjAA_ESZ--q4</a></p>\n</blockquote>\n<p>That video series looks superb in fact. I will be sure to watch it. Thank you!</p>",
        "id": 447626681,
        "sender_full_name": "Jay",
        "timestamp": 1719538491
    },
    {
        "content": "<blockquote>\n<p>Since you are interested in foundations, it sounds like you want to understand the Lean kernel. You can try also: <a href=\"https://ammkrn.github.io/type_checking_in_lean4/\">https://ammkrn.github.io/type_checking_in_lean4/</a></p>\n</blockquote>\n<p>Superb! Yes! </p>\n<blockquote>\n<p>The kernel is an implementation of Lean's logic in software; a computer program with the minimum amount of machinery required to construct elements of Lean's logical language and check those elements for correctness.</p>\n</blockquote>\n<p>This (before actually reading the content) sounds exactly like the missing piece of the puzzle I have been trying to describe! The strict basis-system which can be defined in a conventional programming language and on which you can in turn start to derive the various things like zero, equality, a successor function and all those things I think you shouldn't get for nothing. If that's what the kernel does then is exactly what I am looking for! :)</p>",
        "id": 447627165,
        "sender_full_name": "Jay",
        "timestamp": 1719538792
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"731970\">Jay</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20were.20the.20rules.20of.20the.20game.20decided.3F/near/447615374\">said</a>:</p>\n<blockquote>\n<p>Oh, I agree with the fact binary numbers are no less arbitrary. I don't think beginning with a numbering system of any kind is a good start. Any numbering system would also be arbitrary. Why a numbering system at all? What I do believe in though is beginning with a system which can be used to define such a thing and the operations which act upon it. That's why I have mentioned the Lambda Calculus because, from a computer science point of view, it's one of the purest systems we have.</p>\n</blockquote>\n<p>One thing you seem not to appreciate here is that <em>this is exactly what lean already does</em>. Lean doesn't start with a numbering system, it starts with a foundation not unlike pure lambda calculus. We then <em>define</em> the natural numbers as some inductive type generated by zero and succ. They are not god-given any more than any other definition is, and we can quite easily make different definitions with different constructors.</p>",
        "id": 447627422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719538937
    },
    {
        "content": "<blockquote>\n<p>One thing you seem not to appreciate here is that <em>this is exactly what lean already does</em></p>\n</blockquote>\n<p>You are right. I did not appreciate that when I started and it's exactly why I started along this track!</p>\n<p>I don't think I can be blamed entirely as when I started the tutorial it jumps right in with the successor function. It said nothing about you are saying here. It just thrust it upon me which is why I reacted against it because it <em>should not</em> just be handed to me as it fell out of the sky or is some sort of absolute basis. That's why I started this thread.</p>",
        "id": 447627673,
        "sender_full_name": "Jay",
        "timestamp": 1719539129
    },
    {
        "content": "<p>So... if I <strong>don't</strong> get a successor function and if succ is <strong>not</strong> a foundational component of Lean and if succ is constructed from a more basic underlying system in Lean, in which a successor function does not exist, but from which one can be built, I will be far happier using Lean.</p>",
        "id": 447627862,
        "sender_full_name": "Jay",
        "timestamp": 1719539247
    },
    {
        "content": "<p>the key point to understand about inductive types is that they are basically just using expressions as a means of data representation. When you write <code>succ (succ (succ 0))</code> that's not a sequence of function applications, it's the value itself. Every value of an inductive type has a unique normal form produced by combining the constructors in every possible way</p>",
        "id": 447627971,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719539307
    },
    {
        "content": "<p>and it so happens that when you use this process with constructors <code>zero : Nat</code> and <code>succ : Nat -&gt; Nat</code> you get a \"counting system\" that seems to look a lot like natural numbers</p>",
        "id": 447628048,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719539366
    },
    {
        "content": "<p>If you do it with <code>leaf : T</code> and <code>node : T -&gt; T -&gt; T</code> you get unlabeled binary trees instead</p>",
        "id": 447628148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719539411
    },
    {
        "content": "<p>Yes, that, again, is something I have learned from this thread. I had previously thought it was a function in its own right, as it would be if you had to define what counting is.</p>\n<p>So.... I have been listening to what people here have said and I have learned something... more than one thing.... from reading the responses.</p>",
        "id": 447628150,
        "sender_full_name": "Jay",
        "timestamp": 1719539411
    },
    {
        "content": "<p>and lambda calculus is basically just playing around with trees of applications</p>",
        "id": 447628177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719539429
    },
    {
        "content": "<p>in some sense inductive types are more orthogonal than lambda calculus because the values don't just compute on their own. Encoding things in lambda calculus means you have to be careful to ensure that the data is not in a position where it will start reducing right away</p>",
        "id": 447628375,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719539525
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"731970\">Jay</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20were.20the.20rules.20of.20the.20game.20decided.3F/near/447627673\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>One thing you seem not to appreciate here is that <em>this is exactly what lean already does</em></p>\n</blockquote>\n<p>You are right. I did not appreciate that when I started and it's exactly why I started along this track!</p>\n<p>I don't think I can be blamed entirely as when I started the tutorial it jumps right in with the successor function. It said nothing about you are saying here. It just thrust it upon me which is why I reacted against it because it <em>should not</em> just be handed to me as it fell out of the sky or is some sort of absolute basis. That's why I started this thread.</p>\n</blockquote>\n<p>One thing to note is that the target audience of the Natural Number Game doesn't share your enthusiasm for type theory / foundations, and so that's why it doesn't start from CIC.</p>\n<p>I'm not sure if there is any good introductory resource that takes that approach. There are some nice cubical Agda tutorials with code exercises which start from type theory fundamentals, but I don't know if there is any such thing gamified and/or for Lean.</p>",
        "id": 447628418,
        "sender_full_name": "llllvvuu",
        "timestamp": 1719539553
    },
    {
        "content": "<p><a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a> starts with type theory</p>",
        "id": 447628455,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719539578
    },
    {
        "content": "<p>but it's not gamified</p>",
        "id": 447628476,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719539601
    },
    {
        "content": "<p>Ah yes, I think that would be perfect for you <span class=\"user-mention\" data-user-id=\"731970\">@Jay</span></p>",
        "id": 447628575,
        "sender_full_name": "llllvvuu",
        "timestamp": 1719539660
    },
    {
        "content": "<p>I am reading <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a> right now. It is a really interesting resource getting into the foundations right from the start. Thank you for sharing with me and for you patience. You have all been very helpful!</p>",
        "id": 447628884,
        "sender_full_name": "Jay",
        "timestamp": 1719539867
    },
    {
        "content": "<p>(*so far) </p>\n<p>I expect my curiosity and questions are far from at their end.</p>",
        "id": 447628957,
        "sender_full_name": "Jay",
        "timestamp": 1719539905
    },
    {
        "content": "<p>Note that lambda calculus also has an \"arbitrary\" set of reduction rules and a few \"arbitrary\" encodings for numbers. Similarly, C also has a few \"arbitrary\" data representations for numbers. We create meaning for data we want to manipulate</p>",
        "id": 447735054,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1719572676
    },
    {
        "content": "<p>If you want <em>something</em> other than zero and succ, you can try representing numbers as a sequence of symbols sampled from a finite set of symbols. If your finite set has size two, that's morally binary representation. If your finite set has size 16, that's morally hexadecimal representation.</p>\n<p>This is how you would count in binary:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Symbol</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">B</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Num</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Num</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Num</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Num</span><span class=\"bp\">.</span><span class=\"n\">nil</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Num</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"bp\">.</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">Num</span><span class=\"bp\">.</span><span class=\"n\">nil</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Num</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"bp\">.</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">Num</span><span class=\"bp\">.</span><span class=\"n\">nil</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Num</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"bp\">.</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Num</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"bp\">.</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">Num</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Num</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"bp\">.</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Num</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"bp\">.</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">Num</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Num</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"bp\">.</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Num</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"bp\">.</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">Num</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Num</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"bp\">.</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Num</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"bp\">.</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">Num</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Then you can define your arithmetic operations on top of it. Beware of pain.</p>",
        "id": 447738782,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1719573604
    },
    {
        "content": "<p>And if you want to generalize your symbol domain, you can use <code>Fin</code> to represent your symbols. <code>Fin 1</code> would give you unary representation. <code>Fin 2</code> would give you binary representation...</p>\n<p>If you're really motivated, it might be a good exercise to see where you can get. If you get to the point of proving commutativity of addition, compare your proof with the proof you'd be able to write using Lean's native <code>Nat</code> instead:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- from Init.Data.Nat.Basic</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">zero_add</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\">   </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_add</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">add_comm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\">   </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_add</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">congrArg</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_comm</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">succ_add</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">this</span>\n</code></pre></div>",
        "id": 447741256,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1719574253
    },
    {
        "content": "<p>Interestingly, note that if your symbols live in <code>Fin 1</code>, then you're basically back to Lean's <code>Nat</code></p>",
        "id": 447743010,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1719574861
    }
]