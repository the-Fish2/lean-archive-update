[
    {
        "content": "<p>Is it possible to evaluate a string as it would be evaluated in a Lean program? Something similar to String.toNat, but for an arbitrary type instead of Nat. </p>\n<p>For example, I'd like to be able to write something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span>\n<span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Foo</span>\n\n<span class=\"kd\">example</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span> <span class=\"n\">myfun</span> <span class=\"s2\">\"b 2\"</span>\n</code></pre></div>",
        "id": 425511298,
        "sender_full_name": "Noam Cohen",
        "timestamp": 1709901902
    },
    {
        "content": "<p>maybe you could use a typeclass similar to ToString and implement it for your types?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">FromString</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">fromString</span><span class=\"bp\">?</span><span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Option</span> <span class=\"n\">α</span>\n  <span class=\"n\">fromString</span><span class=\"bp\">!</span><span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">-&gt;</span>  <span class=\"n\">α</span>\n</code></pre></div>",
        "id": 425514098,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1709902840
    },
    {
        "content": "<p>Yeah, I had considered that, but I wondered if there wasn't an existing option. Something that essentially functions just like lean interprets code. Similar to python's exec.</p>",
        "id": 425684114,
        "sender_full_name": "Noam Cohen",
        "timestamp": 1709988939
    },
    {
        "content": "<p>First python's exec doesn't return a value you probably mean <code>eval</code>. Secondly yes you can get there as the Lean compiler is implemented in Lean itself and you can import all of its modules so you can build this type of behavior if you really want to. But I don't think it's generally a good idea to do stuff like this, what are you actually after here?</p>",
        "id": 425685050,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1709989723
    },
    {
        "content": "<p>I was hoping to use it to handle some simple user input without defining a dedicated parser or something like a fromString function.</p>",
        "id": 425708735,
        "sender_full_name": "Noam Cohen",
        "timestamp": 1710008625
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> Not to hijack this thread, but I'm also interested in the ability to translate between strings and proofs as it could enable a nice proof of <a href=\"https://en.wikipedia.org/wiki/Kolmogorov_complexity#Chaitin's_incompleteness_theorem\">Chaitin's incompleteness theorem</a>. Do you think such a proof would be feasible, and if so, do you have any suggestions re: where to start?</p>",
        "id": 425721898,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710021700
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"661019\">Noam Cohen</span> <a href=\"#narrow/stream/113489-new-members/topic/Evaluating.20code.20string/near/425708735\">said</a>:</p>\n<blockquote>\n<p>I was hoping to use it to handle some simple user input without defining a dedicated parser or something like a fromString function.</p>\n</blockquote>\n<p>Right for that application compiling in the Lean compiler into your application seems a little overkill to me, we do have a small parser combinator library available in the spirit of Haskell's <code>parsec</code> that ships with Lean which you can use to write small parsers.</p>",
        "id": 425722008,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1710021799
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/stream/113489-new-members/topic/Evaluating.20code.20string/near/425721898\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> Not to hijack this thread, but I'm also interested in the ability to translate between strings and proofs as it could enable a nice proof of <a href=\"https://en.wikipedia.org/wiki/Kolmogorov_complexity#Chaitin's_incompleteness_theorem\">Chaitin's incompleteness theorem</a>. Do you think such a proof would be feasible, and if so, do you have any suggestions re: where to start?</p>\n</blockquote>\n<p>Evaluating a String as a Lean piece of code is by no means a procedure that has any kind of proofs attached to it, in general almost all of the implementation of the Lean compiler itself is entirely unverified (which is okay since we need only trust the kernel for the most part).</p>",
        "id": 425722090,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1710021883
    },
    {
        "content": "<p>Ah, I see.</p>",
        "id": 425722138,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710021947
    },
    {
        "content": "<p>A term elaborator can be used to turn a string into a Lean value. <a href=\"https://live.lean-lang.org/#code=import%20Lean%0A%0Aopen%20Lean%20Elab%20Term%0A%0Aelab%20%22evaluate%25%22%20code%3Astr%20%3A%20term%20%3C%3D%20expectedType%20%3D%3E%20do%0A%20%20let%20.ok%20stx%20%3A%3D%20Parser.runParserCategory%20(%E2%86%90%20getEnv)%20%60term%20code.getString%20%7C%20%0A%20%20%20%20throwError%20s!%22Failed%20to%20parse%20%7Bcode%7D%22%0A%20%20Term.elabTerm%20stx%20expectedType%0A%0A%23eval%201%20%2B%20(evaluate%25%20%225%22)\">Here</a> is an example.</p>",
        "id": 425752018,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1710055529
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303675\">Anand Rao Tadipatri</span> <a href=\"#narrow/stream/113489-new-members/topic/Evaluating.20code.20string/near/425752018\">said</a>:</p>\n<blockquote>\n<p>A term elaborator can be used to turn a string into a Lean value. <a href=\"https://live.lean-lang.org/#code=import%20Lean%0A%0Aopen%20Lean%20Elab%20Term%0A%0Aelab%20%22evaluate%25%22%20code%3Astr%20%3A%20term%20%3C%3D%20expectedType%20%3D%3E%20do%0A%20%20let%20.ok%20stx%20%3A%3D%20Parser.runParserCategory%20(%E2%86%90%20getEnv)%20%60term%20code.getString%20%7C%20%0A%20%20%20%20throwError%20s!%22Failed%20to%20parse%20%7Bcode%7D%22%0A%20%20Term.elabTerm%20stx%20expectedType%0A%0A%23eval%201%20%2B%20(evaluate%25%20%225%22)\">Here</a> is an example.</p>\n</blockquote>\n<p>Ah, that's quite cool, but if I understand it correctly, this will only work on String literals. Or can it also be applied to a string obtained as input?</p>",
        "id": 425765273,
        "sender_full_name": "Noam Cohen",
        "timestamp": 1710069427
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113489-new-members/topic/Evaluating.20code.20string/near/425722008\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"661019\">Noam Cohen</span> <a href=\"#narrow/stream/113489-new-members/topic/Evaluating.20code.20string/near/425708735\">said</a>:</p>\n<blockquote>\n<p>I was hoping to use it to handle some simple user input without defining a dedicated parser or something like a fromString function.</p>\n</blockquote>\n<p>Right for that application compiling in the Lean compiler into your application seems a little overkill to me, we do have a small parser combinator library available in the spirit of Haskell's <code>parsec</code> that ships with Lean which you can use to write small parsers.</p>\n</blockquote>\n<p>Yeah, fair enough haha. Not being lazy it is</p>",
        "id": 425765303,
        "sender_full_name": "Noam Cohen",
        "timestamp": 1710069476
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"661019\">Noam Cohen</span> has marked this topic as resolved.</p>",
        "id": 425765349,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710069487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"661019\">Noam Cohen</span> has marked this topic as unresolved.</p>",
        "id": 425765363,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710069500
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"661019\">Noam Cohen</span> has marked this topic as resolved.</p>",
        "id": 425765374,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710069519
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"661019\">Noam Cohen</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Evaluating.20code.20string/near/425765273\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"303675\">Anand Rao Tadipatri</span> <a href=\"#narrow/stream/113489-new-members/topic/Evaluating.20code.20string/near/425752018\">said</a>:</p>\n<blockquote>\n<p>A term elaborator can be used to turn a string into a Lean value. <a href=\"https://live.lean-lang.org/#code=import%20Lean%0A%0Aopen%20Lean%20Elab%20Term%0A%0Aelab%20%22evaluate%25%22%20code%3Astr%20%3A%20term%20%3C%3D%20expectedType%20%3D%3E%20do%0A%20%20let%20.ok%20stx%20%3A%3D%20Parser.runParserCategory%20(%E2%86%90%20getEnv)%20%60term%20code.getString%20%7C%20%0A%20%20%20%20throwError%20s!%22Failed%20to%20parse%20%7Bcode%7D%22%0A%20%20Term.elabTerm%20stx%20expectedType%0A%0A%23eval%201%20%2B%20(evaluate%25%20%225%22)\">Here</a> is an example.</p>\n</blockquote>\n<p>Ah, that's quite cool, but if I understand it correctly, this will only work on String literals. Or can it also be applied to a string obtained as input?</p>\n</blockquote>\n<p>Yes, you're right -- this works only on actual string literals and not arbitrary variables of type <code>String</code>.</p>",
        "id": 425766452,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1710070676
    },
    {
        "content": "<p><a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Parsing.20a.20string\">https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming-.2F-tactics/topic/Parsing.20a.20string</a></p>\n<p>Here's another example where I recently parsed a string (which came from a text file and the is passed to the function as argument). It may looka bit convoluted but its essentially a copy of 'runParserCategory` slightly modified to the specific needs.</p>",
        "id": 426016988,
        "sender_full_name": "Jon Eugster",
        "timestamp": 1710194999
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Evaluating.20code.20string/near/425722090\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/stream/113489-new-members/topic/Evaluating.20code.20string/near/425721898\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> Not to hijack this thread, but I'm also interested in the ability to translate between strings and proofs as it could enable a nice proof of <a href=\"https://en.wikipedia.org/wiki/Kolmogorov_complexity#Chaitin's_incompleteness_theorem\">Chaitin's incompleteness theorem</a>. Do you think such a proof would be feasible, and if so, do you have any suggestions re: where to start?</p>\n</blockquote>\n<p>Evaluating a String as a Lean piece of code is by no means a procedure that has any kind of proofs attached to it, in general almost all of the implementation of the Lean compiler itself is entirely unverified (which is okay since we need only trust the kernel for the most part).</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Does Lean4Lean have any relevance here? I'm curious about the feasibility of proving Chaitin's incompleteness theorem in Lean.</p>",
        "id": 428427316,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1711153079
    },
    {
        "content": "<p>I don't think it's directly related, except in that both are doing metatheory (for different theories). It looks like you would want some basic proof theory to prove this theorem, i.e. first order logic and natural number axiomatizations (PA and extensions)</p>",
        "id": 429054940,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711174973
    },
    {
        "content": "<p>basically, the same things you would need to prove Godel's incompleteness theorem. Possibly <span class=\"user-mention\" data-user-id=\"414485\">@Palalansoukî</span> has some relevant prior work here?</p>",
        "id": 429054970,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711175019
    }
]