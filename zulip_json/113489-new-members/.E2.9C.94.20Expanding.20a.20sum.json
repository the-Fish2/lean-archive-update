[
    {
        "content": "<p>Yet another beginner random-walking his way into problems, I'm afraid!</p>\n<p>My hope is to prove that <code>sum(f(d) for d in divisors(p)) == 3*p+5</code> for my given <code>f</code> (and that syntax probably gives away where I'm coming from.)  Though I might be xying myself, I haven't been able to find the right approach to expand the lhs of the final goal, ∑ d in {1, p}, (3 * d + 1) using the definition of ∑ into (3 * 1 + 1) + (3 * p + 1).<br>\n<br>\nBecause I'd like to apply this to other situations as well, I'd like to avoid shortcuts (even if slick) which use the fact that it's just a pair of values, or take advantage of the fact we have divisors, or prime p, etc.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span> <span class=\"n\">Nat</span> <span class=\"n\">BigOperators</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span><span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n<span class=\"kd\">def</span> <span class=\"n\">f_on_div</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">∑</span> <span class=\"n\">d</span> <span class=\"k\">in</span> <span class=\"n\">Nat.divisors</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">d</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">f_on_div</span> <span class=\"mi\">0</span>\n<span class=\"k\">#eval</span> <span class=\"n\">f_on_div</span> <span class=\"mi\">10</span>\n<span class=\"k\">#eval</span> <span class=\"n\">f_on_div</span> <span class=\"mi\">7</span>\n\n<span class=\"c1\">-- direct calculation works with everything specified</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">good_theorem</span><span class=\"o\">:</span> <span class=\"n\">f_on_div</span> <span class=\"mi\">7</span> <span class=\"bp\">=</span> <span class=\"mi\">26</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n\n<span class=\"c1\">-- here I'd like to expand the sum</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">better_theorem</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">Nat.Prime</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f_on_div</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">p</span> <span class=\"bp\">+</span> <span class=\"mi\">5</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">f_on_div</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Prime.divisors</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- new goal: ∑ d in {1, p}, 3 * d + 1 = 3 * p + 5</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>In general, given <code>∑ d in s, f d</code>, with a concrete s (potentially not even a set/multiset but some other collection), how can I inline the expansion?</p>\n<p>In my head it feels something like conv / lhs / rewrite [that_sum_op].  Or am I missing something deeper?</p>",
        "id": 425789992,
        "sender_full_name": "Douglas McNeil",
        "timestamp": 1710091941
    },
    {
        "content": "<p>Hi, I'm not sure how to answer your general question, and I'm not even sure I understand it (<code>∑ d in s, f d</code> only makes sense for <code>s</code> a <code>Finset</code>, as far as I know), but in your case <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/BigOperators/Basic.html#Finset.sum_pair\">Finset.sum_pair</a> should help.</p>",
        "id": 425791566,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1710093381
    },
    {
        "content": "<p>Thanks!  For the particular case of two elements, sum_pair works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">better_theorem</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">Nat.Prime</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f_on_div</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">p</span> <span class=\"bp\">+</span> <span class=\"mi\">5</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">f_on_div</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Prime.divisors</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- new goal: ∑ d in {1, p}, 3 * d + 1 = 3 * p + 5</span>\n  <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">lhs</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Finset.sum_pair</span>\n    <span class=\"bp\">.</span> <span class=\"n\">apply</span> <span class=\"n\">Ne.symm</span>\n      <span class=\"n\">exact</span> <span class=\"n\">Nat.Prime.ne_one</span> <span class=\"n\">h</span>\n  <span class=\"n\">ring</span>\n</code></pre></div>\n<p>But I'm trying to avoid anything dependent on the number of entries, so that I can also use the same approach to handle sister problems like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">harder_theorem</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">Nat.Prime</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f_on_div</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">p</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">p</span> <span class=\"bp\">+</span><span class=\"mi\">6</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">f_on_div</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">divisors_prime_pow</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"n\">norm_num</span>\n  <span class=\"c1\">-- new goal: ∑ x in range 3, (3 * p ^ x + 1) = 3 * p ^ 2 + 3 * p + 6</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>where Finset.sum_pair doesn't apply directly.  After some more digging, it looks like the unfold/rw + simp combination might work for this new one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">harder_theorem</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">Nat.Prime</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f_on_div</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">p</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">p</span> <span class=\"bp\">+</span><span class=\"mi\">6</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">f_on_div</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">divisors_prime_pow</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"n\">norm_num</span> <span class=\"c1\">-- unneeded but pretty</span>\n  <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">lhs</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Finset.sum</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span>\n  <span class=\"n\">ring</span>\n</code></pre></div>\n<p>But the same approach fails on <code>better_theorem</code>, where the lhs map iterates over {1, p} instead of a range, which is why I'd given up on it before.</p>\n<p>It's like I've failed to specify something so that</p>\n<p><code>Multiset.sum (Multiset.map (fun x ↦ 3 * x + 1) {1, p}.val)</code></p>\n<p>can be expanded the same way it does</p>\n<p><code>Multiset.sum (Multiset.map (fun x ↦ 3 * p ^ x + 1) (range 3).val)</code></p>",
        "id": 425797407,
        "sender_full_name": "Douglas McNeil",
        "timestamp": 1710097907
    },
    {
        "content": "<p>In formalisation, sets which are made by \"here is a list of elements\" are handled differently to sets which are made by \"here is a formula for the elements\". This seems to be what you're learning.</p>",
        "id": 425798906,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710099125
    },
    {
        "content": "<p>PS I would avoid Multiset.sum unless you really need to use multisets in your work (multisets are finite sets with repeats allowed, eg {1,1,2} and {1,2,2} and {1,2} are all different multisets). The API for <code>Finset</code> (finite subsets of a type) is far better developed.</p>",
        "id": 425799127,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710099317
    },
    {
        "content": "<p>If you're summing over <code>Finset.range 3</code> then this a set defined by a formula (n&lt;3) so you'll need to use different API; in this case <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sum_range_succ#doc\">docs#Finset.sum_range_succ</a> .</p>",
        "id": 425799267,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710099438
    },
    {
        "content": "<p>And if you're summing over <code>Finset</code>s that are defined by lists of elements, then maybe <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/BigOperators/Basic.html#Finset.sum_insert\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/BigOperators/Basic.html#Finset.sum_insert</a> ? But it will ask you to prove that the element you're adding to your <code>Finset</code> is not already in it.</p>",
        "id": 425799969,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1710099977
    },
    {
        "content": "<p>If the theorem used <code>Finset.cons</code> instead of <code>insert</code> to construct the list, it comes with the uniqueness proofs already, so you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sum_cons#doc\">docs#Finset.sum_cons</a> without any additional proof obligations:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Prime.divisors'</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">pp</span> <span class=\"o\">:</span> <span class=\"n\">p.Prime</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">divisors</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">Finset.cons</span> <span class=\"mi\">1</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">pp.ne_one.symm</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">pp.divisors</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">better_theorem</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">Nat.Prime</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f_on_div</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">p</span> <span class=\"bp\">+</span> <span class=\"mi\">5</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">f_on_div</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Prime.divisors'</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">Finset.sum_cons</span><span class=\"o\">,</span> <span class=\"n\">Finset.sum_singleton</span><span class=\"o\">]</span>\n  <span class=\"n\">ring</span>\n</code></pre></div>",
        "id": 425803376,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710102670
    },
    {
        "content": "<p>Note that <code>decide</code> for natural number equalities doesn't do anything that <code>rfl</code> can't do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">good_theorem</span> <span class=\"o\">:</span> <span class=\"n\">f_on_div</span> <span class=\"mi\">7</span> <span class=\"bp\">=</span> <span class=\"mi\">26</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 425803407,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710102706
    },
    {
        "content": "<p>Multisets only came in when I applied <code>rw [Finset.sum]</code> to <code>∑ x in range 3, (3 * p ^ x + 1)</code> in order to get something that <code>simp</code> would expand for me, giving the <code>3 * p ^ 2 + 1 + (3 * p + 1 + 4)</code> that I'd hoped for.  If I can bypass them entirely I'm happy to!</p>\n<p>If I push through the use of sum_insert, not caring to be general but just trying to make the {1, p} case work following Sophie's suggestion everything works, and similarly if I follow Kyle's example.</p>\n<p>Thanks, everyone!</p>",
        "id": 425910037,
        "sender_full_name": "Douglas McNeil",
        "timestamp": 1710164086
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"341148\">Douglas McNeil</span> has marked this topic as resolved.</p>",
        "id": 425910063,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710164099
    },
    {
        "content": "<p>Don't <code>rw Finset.sum</code>! This unfolds the definition which is definitely not what you want to do -- use the API provided.</p>",
        "id": 426034362,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710205055
    },
    {
        "content": "<p>There are lemmas about Finset.sum and range. Hopefully <code>rw?</code> finds them</p>",
        "id": 426050769,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1710216294
    }
]