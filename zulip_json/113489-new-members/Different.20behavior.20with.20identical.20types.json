[
    {
        "content": "<p>I'm curious why the first and second examples behave differently, given that the types on the right hand side seem to be the same.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">r</span> <span class=\"bp\">↦</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">single</span> <span class=\"n\">i</span> <span class=\"n\">r</span>  <span class=\"c1\">-- OK</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">single</span> <span class=\"n\">i</span>            <span class=\"c1\">-- fail</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">single</span>                  <span class=\"c1\">-- OK</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n<span class=\"k\">#check</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">single</span> <span class=\"n\">i</span>             <span class=\"c1\">-- ?m.8 i → (j : ℕ) → ?m.8 j</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">r</span> <span class=\"bp\">↦</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">single</span> <span class=\"n\">i</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"c1\">-- ?m.1893 i → (j : ℕ) → ?m.1893 j</span>\n</code></pre></div>",
        "id": 410895366,
        "sender_full_name": "Paul Nelson",
        "timestamp": 1704224198
    },
    {
        "content": "<p>The reason <code>example (i : ℕ) : ℚ → (ℕ → ℚ) := Pi.single i</code> fails is that Lean 4 is failing to solve the unification problem. Giving it a hint fixes the problem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">single</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span>         <span class=\"c1\">-- now works</span>\n</code></pre></div>\n<p>Unification is generally an undecidable problem but I have this gut feeling that Lean 3 used to do a much better job of it than Lean 4 does. In particular when you look at the error message</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>type mismatch\n  Pi.single i\nhas type\n  ?m.1133 i → (j : ℕ) → ?m.1133 j : Type ?u.1130\nbut is expected to have type\n  ℚ → ℕ → ℚ : Type\n</code></pre></div>\n<p>Lean it saying \"I can't think of a function which sends <code>i</code> to <code>ℚ</code> and <code>j</code> to <code>ℚ</code>\" and to be quite frank I'm surprised that it can't muster up the idea of the function which sends everything to <code>ℚ</code>.</p>",
        "id": 410919433,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704237522
    },
    {
        "content": "<p>this makes sense (second example failing), but I'm surprised it then succeeds in the first example, despite the types all looking the same, which suggests to me that there's something more going on under the surface than just the way the types are presented via #check</p>",
        "id": 410919742,
        "sender_full_name": "Paul Nelson",
        "timestamp": 1704237738
    },
    {
        "content": "<p>to put it another way, without any type annotation, why should <code>fun r ↦ Pi.single i r</code> and <code>Pi.single i</code> ever behave differently?</p>",
        "id": 410919907,
        "sender_full_name": "Paul Nelson",
        "timestamp": 1704237866
    },
    {
        "content": "<p>If <code>Pi.single</code> were a plain function and you were supplying all, or all-but-one, of the inputs, then your instinct would be right. But <code>Pi.single</code> has all these inputs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">single.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"n\">DecidableEq</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"bp\">✝¹</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Zero</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">j</span>\n</code></pre></div>\n<p>so Lean has to figure out two universes, two inputs (<code>I</code> and <code>f</code>) by unification, and two further inputs (<code>DecidableEq I</code> and <code>(i : I) → Zero (f i)</code>) by typeclass inference. All this figuring out is going on internally in some order which I have no clue about, but what I do know is that the more explicit inputs you give Lean, the easier these problems are to solve. I'm not saying I can explain completely what's going on (indeed I cannot do this) but I am saying that this is somehow the core of the problem. If there were an algorithm which could always solve for these unknown inputs correctly then that would be the end of it, but this problem is undecidable in general so Lean resorts to heuristics and not supplying the input changes the heuristics. It is not at all uncommon to have to help Lean 4 out using this <code>(f := ...)</code> trick.</p>",
        "id": 410921008,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704238779
    },
    {
        "content": "<p>For some reason that <code>r</code> is making some heuristics apply in a different order, so Lean knows for sure that <code>f i = ℚ</code> and this pushes it into thinking that <code>f _ = ℚ</code> sufficiently early on to make everything else work, because that's the way the code was written. Without the <code>r</code> maybe Lean tries to solve <code>[inst✝¹ : (i : I) → Zero (f i)]</code> earlier (for all I know) and barfs on <code>f _</code>. People who can read the actual Lean code could tell you precisely why the failure was occurring, but I've managed to get this far just knowing the symptoms and how to fix them.</p>",
        "id": 410921306,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704238984
    }
]