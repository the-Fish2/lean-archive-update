[
    {
        "content": "<p>Coq's graph library uses a \"minor map\" representation for graph minors. A <em>minor map</em> from <code>G</code> to <code>H</code> maps every vertex in <code>H</code> to the set of vertices in <code>G</code> which are contracted into it.</p>\n<p>See pages 14–15 of <a href=\"https://hal.science/hal-02316859v2/preview/graphscoq.pdf\">https://hal.science/hal-02316859v2/preview/graphscoq.pdf</a><br>\nAnd the Coq code: <a href=\"https://github.com/coq-community/graph-theory/blob/34242fdee8c3e1edd455afd10930ded633237a03/theories/core/minor.v#L14-L26\">https://github.com/coq-community/graph-theory/blob/34242fdee8c3e1edd455afd10930ded633237a03/theories/core/minor.v#L14-L26</a></p>\n<p>I also started playing with the definitions in Lean here: <a href=\"https://gist.github.com/lambda-fairy/e1d33e968fc0f03683a81319989f7745\">https://gist.github.com/lambda-fairy/e1d33e968fc0f03683a81319989f7745</a> (It's a Gist because I'm away from my main machine right now.)</p>\n<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> how does this compare to the interval idea that you brought up a while ago?</p>\n<p>I'm interested in graph minors because I found a nice elegant five-color proof using only deletion/contraction. So we can prove this theorem with only minors and ignore the planar stuff (for now).<br>\n<a href=\"https://www.ams.org/journals/proc/1974-045-03/S0002-9939-1974-0345861-4/S0002-9939-1974-0345861-4.pdf\">https://www.ams.org/journals/proc/1974-045-03/S0002-9939-1974-0345861-4/S0002-9939-1974-0345861-4.pdf</a></p>",
        "id": 409351620,
        "sender_full_name": "Chris Wong",
        "timestamp": 1703152508
    },
    {
        "content": "<p>I've still got a few weeks in my holiday, so I'm tempted to push through and try prove five color with what I have. The actual theorem is quite short and I feel well equipped for it.</p>",
        "id": 409354737,
        "sender_full_name": "Chris Wong",
        "timestamp": 1703153516
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"294142\">Chris Wong</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Definition.20of.20minors.20using.20minor.20maps/near/409351620\">said</a>:</p>\n<blockquote>\n<p>Coq's graph library uses a \"minor map\" representation for graph minors. A <em>minor map</em> from <code>G</code> to <code>H</code> maps every vertex in <code>H</code> to the set of vertices in <code>G</code> which are contracted into it.</p>\n<p>See pages 14–15 of <a href=\"https://hal.science/hal-02316859v2/preview/graphscoq.pdf\">https://hal.science/hal-02316859v2/preview/graphscoq.pdf</a><br>\nAnd the Coq code: <a href=\"https://github.com/coq-community/graph-theory/blob/34242fdee8c3e1edd455afd10930ded633237a03/theories/core/minor.v#L14-L26\">https://github.com/coq-community/graph-theory/blob/34242fdee8c3e1edd455afd10930ded633237a03/theories/core/minor.v#L14-L26</a></p>\n<p>I also started playing with the definitions in Lean here: <a href=\"https://gist.github.com/lambda-fairy/e1d33e968fc0f03683a81319989f7745\">https://gist.github.com/lambda-fairy/e1d33e968fc0f03683a81319989f7745</a> (It's a Gist because I'm away from my main machine right now.)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> how does this compare to the interval idea that you brought up a while ago?</p>\n<p>I'm interested in graph minors because I found a nice elegant five-color proof using only deletion/contraction. So we can prove this theorem with only minors and ignore the planar stuff (for now).<br>\n<a href=\"https://www.ams.org/journals/proc/1974-045-03/S0002-9939-1974-0345861-4/S0002-9939-1974-0345861-4.pdf\">https://www.ams.org/journals/proc/1974-045-03/S0002-9939-1974-0345861-4/S0002-9939-1974-0345861-4.pdf</a></p>\n</blockquote>\n<p>IIRC, a minor of a graph must be formed by contracting edges, and not deleting vertices and edges. So over all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">x\\in G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>t</mi><mi>o</mi><mi>F</mi><mi>u</mi><mi>n</mi><mtext> </mtext><mi>x</mi><mtext> </mtext><mi mathvariant=\"normal\">∣</mi><mtext> </mtext><mi>x</mi><mo>∈</mo><mi>V</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{ toFun\\ x\\ |\\ x\\in V\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">x</span><span class=\"mspace\"> </span><span class=\"mord\">∣</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mclose\">}</span></span></span></span> must be a partition</p>",
        "id": 409357451,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1703154370
    },
    {
        "content": "<p>OTOH, this is fine if we accept wikipedia's definition and allow subgraphs as minors</p>",
        "id": 409357695,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1703154442
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span>  I think Diestel defines \"Y is a model of X\" if you can obtain X by starting from Y and repeatedly contracting edges. Is that the definition you're thinking of?</p>",
        "id": 409420725,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1703175320
    },
    {
        "content": "<p>Yeah</p>",
        "id": 409420770,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1703175337
    },
    {
        "content": "<p>But honestly the definition Chris has is better for most uses.</p>",
        "id": 409421823,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1703175655
    },
    {
        "content": "<p>I have only ever heard someone quibble about how the graph minor was constructed when doing some case analysis in a talk</p>",
        "id": 409422012,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1703175719
    },
    {
        "content": "<p>I've always heard of a minor of a graph as being the result of deleting edges, deleting vertices, and contracting edges.</p>",
        "id": 409422111,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703175743
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"294142\">@Chris Wong</span> These minor maps are a neat idea.</p>\n<p>I think it would make sense to implement these. (I'm not sure whether it should be <code>minor_map</code>, <code>minor_rmap</code>, or both. I see you implemented <code>minor_rmap</code>.)</p>\n<p>I think the interval idea I had still makes sense to have in addition to this. It gives you a type with all the minors of a graph, where <code>minor_rmap</code> gives you a relationship between two graphs. The first can give you different sorts of contraction/deletion relations, since everything is all on the same type.</p>",
        "id": 409424118,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703176368
    },
    {
        "content": "<p>One thing that would make sense is to extend <code>SimpleGraph.map</code> to non-injective maps, and then say that a contraction of a graph <code>G</code> is the <code>map</code> of it via a function with connected fibers, kind of the dual version of your <code>MinorMap</code>. I played a bit with it here <a href=\"https://github.com/vbeffara/lean/blob/main/src/graph_theory/contraction.lean\">https://github.com/vbeffara/lean/blob/main/src/graph_theory/contraction.lean</a> and <a href=\"https://github.com/vbeffara/lean/blob/main/src/graph_theory/pushforward.lean\">https://github.com/vbeffara/lean/blob/main/src/graph_theory/pushforward.lean</a> but this was in Lean 3...</p>",
        "id": 409439273,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1703181823
    },
    {
        "content": "<p>Thanks all!</p>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/252551-graph-theory/topic/Definition.20of.20minors.20using.20minor.20maps/near/409424118\">said</a>:</p>\n<blockquote>\n<p>I think it would make sense to implement these. (I'm not sure whether it should be <code>minor_map</code>, <code>minor_rmap</code>, or both. I see you implemented <code>minor_rmap</code>.)</p>\n</blockquote>\n<p>I'm not sure either. I picked <code>minor_rmap</code> because I noticed the definition of <code>minor_map</code> used the preimage a lot, whereas the <code>_rmap</code>axioms talked about the function directly. Then again, the paper says that the <code>minor_map</code> formulation is \"more convenient\", whatever that means. I think it's worth trying both and checking if that claim applies to Lean.</p>\n<blockquote>\n<p>I think the interval idea I had still makes sense to have in addition to this. It gives you a type with all the minors of a graph, where minor_rmap gives you a relationship between two graphs. The first can give you different sorts of contraction/deletion relations, since everything is all on the same type.</p>\n</blockquote>\n<p>That sounds reasonable to me. If we stick to a non-committal name like <code>MinorMap</code> then that can leave space for other representations.</p>",
        "id": 409560844,
        "sender_full_name": "Chris Wong",
        "timestamp": 1703241757
    },
    {
        "content": "<p>I think it's similar to how it's helpful having both a Subgraph type and injective graph homomorphisms.</p>",
        "id": 409622641,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703268223
    },
    {
        "content": "<p>Something to consider for minor maps: it would be good having, for example, both an analytic and a synthetic notion of \"contracting an edge\". By 'analytic' I mean that there's a predicate that says \"this minor map is the contraction of this edge\" and by 'synthetic' I mean there's a construction that gives a minor map that is the contraction of an edge. Contracting edges is a commutative operation, and you should be able to set things up so that at least you can say in an analytic way \"given a minor map that is the composition of two edge contractions, then we can factor the minor map as a composition of edge contractions in the opposite order.\"</p>\n<p>You can also state that synthetically, but rather than equalities you need to say that contracting in each order gives isomorphic minors. (And there are plenty of dependent types to wrangle.)</p>\n<p>One of the reasons for that interval idea for a <code>Minor</code> type is to be able to state these relations using equalities, without needing to carry anything between different types.</p>",
        "id": 409623809,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703268830
    },
    {
        "content": "<p>Here's what I've got so far:<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/blob/lambda-fairy/minor/Mathlib/Combinatorics/SimpleGraph/MinorMap.lean\">https://github.com/leanprover-community/mathlib4/blob/lambda-fairy/minor/Mathlib/Combinatorics/SimpleGraph/MinorMap.lean</a></p>\n<p>One thing I find interesting is that using the <code>minor_rmap</code> approach makes it easy to convert from <code>Hom</code>/<code>Embedding</code>/<code>LE</code>. If we had used <code>minor_map</code> instead, we would needed to use preimages.</p>",
        "id": 416490432,
        "sender_full_name": "Chris Wong",
        "timestamp": 1705549144
    },
    {
        "content": "<p>Also, the \"subgraph\" definition in Coq graph-theory wraps an injective hom <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 416490697,
        "sender_full_name": "Chris Wong",
        "timestamp": 1705549280
    },
    {
        "content": "<p>Hmm, now I'm formalizing contraction, and it seems to favor the opposite direction. If we model contraction as quotienting together a set of connected vertices, then <code>Quotient.mk</code> maps the vertices in the larger graph to the smaller graph. Contrast with deletion / graph homs, which map from smaller to larger.</p>",
        "id": 424556875,
        "sender_full_name": "Chris Wong",
        "timestamp": 1709511942
    }
]