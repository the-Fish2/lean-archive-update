[
    {
        "content": "<p>I just learned that <code>fact</code> doesn't mean factorial in Lean, and if <code>nat</code> is open, <code>#check fact</code> is ambiguous. Doesn't that seem unfortunate?</p>",
        "id": 196959849,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1588978626
    },
    {
        "content": "<p>It's a new design in mathlib. It's actually not a shorthand for anything but it helps us have propositions as type classes. We could put it in its own namespace to minimize this kind of surprise</p>",
        "id": 196969679,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1588992415
    },
    {
        "content": "<p>I agree that it is a bit unfortunate. <span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span> I usually write <code>n.fact</code> to get around this, and it also reads nice. Even better would be to add</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">localized</span> <span class=\"s2\">&quot;postfix `!` := nat.fact&quot;</span> <span class=\"k\">in</span> <span class=\"n\">nat</span>\n</code></pre></div>\n\n\n<p>To the <code>data/nat/fact</code> file. (Modulo trivial typos). Then we can simply write <code>n!</code> after <code>open_locale nat</code>.</p>",
        "id": 196970148,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588993257
    },
    {
        "content": "<p>We could also rename <code>nat.fact</code> to <code>nat.factorial</code></p>",
        "id": 196970163,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588993321
    },
    {
        "content": "<p>I think we should do all of those (-;</p>",
        "id": 196970347,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588993584
    },
    {
        "content": "<p>I'm fine with <code>factorial</code>, it's unambiguous. Mathematicians have this great notation <code>!</code> for it though :-) How about getting that working then nobody needs to worry about the name :-)</p>",
        "id": 196977775,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589008106
    },
    {
        "content": "<p>The lemmas still use the name.</p>",
        "id": 196979306,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1589011025
    },
    {
        "content": "<p>I think it makes sense that <code>fact</code> is the abbreviation of the word fact instead of the abbreviation of the word factorial.</p>",
        "id": 196981671,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1589015024
    },
    {
        "content": "<p>There are other reasonable synonyms for <code>fact</code>: <code>given</code> or <code>assuming</code> come to mind quickly.  But there aren't that many other names for <code>factorial</code>, and <code>n.factorial</code> is quite a bit longer than <code>n.fact</code>.  Though the postfix notation also looks nice.</p>",
        "id": 196981784,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1589015258
    },
    {
        "content": "<p>In fact, <code>fact</code> is one of those \"filler\" words that conveys little meaning here. Why not something like <code>to_typeclass</code> that says something more informative?</p>",
        "id": 196982149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589015999
    },
    {
        "content": "<p><code>[witness P]</code>?</p>",
        "id": 196986649,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1589023110
    },
    {
        "content": "<p>What's the story with global instances of <code>fact</code>? I was under the vague impression that there weren't supposed to be any, but some do exist.</p>",
        "id": 208493782,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598806361
    },
    {
        "content": "<p>My understanding was \"don't make too many\", rather than \"don't many any at all\"</p>",
        "id": 208499442,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1598814325
    },
    {
        "content": "<p>I prefer to only have local(ized) instances, but I'm also fine with the looser \"don't have many\"</p>",
        "id": 208505069,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1598822936
    },
    {
        "content": "<p>I feel like this is something we could easily regret later. I'd vote for \"none, unless they come with a detailed doc-string explaining exactly why <code>local attribute [instance]</code> won't cut it\".</p>",
        "id": 208512555,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1598836000
    },
    {
        "content": "<p>Ideally enforced by the linter! :-)</p>",
        "id": 208512564,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1598836017
    },
    {
        "content": "<p>Hi! I'm wondering why this lemma doesn't see <code>hp</code> and fails to synthesize a type class instance of <code>fact p.prime</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.field</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.char_p</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">fact</span> <span class=\"n\">p.prime</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">char_p</span> <span class=\"n\">F</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">frobenius</span> <span class=\"n\">F</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"gr\">sorry</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 275015750,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1647024225
    },
    {
        "content": "<p>Oh nevermind this seems to work.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.field</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.char_p</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"n\">p.prime</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">char_p</span> <span class=\"n\">F</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">frobenius</span> <span class=\"n\">F</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"gr\">sorry</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Why is it that naming the fact <code>hp</code> suddenly makes it fail?</p>",
        "id": 275015949,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1647024327
    },
    {
        "content": "<p>If you name an instance then it doesn't get included automatically in the local context unless the name is mentioned in the statement of the lemma. You can see just clicking before the final <code>sorry</code> that the instance is not present in the first situation and is there in the second.</p>",
        "id": 275016154,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647024429
    },
    {
        "content": "<p>(also, in your first example you didn't even have it in instance brackets!)</p>",
        "id": 275016585,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1647024658
    },
    {
        "content": "<p>The first one also is using parentheses instead of square brackets, which is another reason it fails. I keep rediscovering and forgetting the rule Kevin's mentioned, that even if it were <code>[hp : fact p.prime]</code> it wouldn't be included.</p>",
        "id": 275016590,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1647024661
    },
    {
        "content": "<p>thanks all! that makes sense.</p>",
        "id": 275016835,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1647024749
    },
    {
        "content": "<p>One thing that clarified this stuff for me is that Lean doesn't really care much about what kind of brackets you use before the colon when elaborating:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.char_p</span>\n\n<span class=\"c1\">-- works even though we use round brackets</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">fact</span> <span class=\"n\">p.prime</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">char_p</span> <span class=\"n\">F</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">frobenius</span> <span class=\"n\">F</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"gr\">sorry</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">frobenius : Π (R : Type u) [_inst_1 : comm_semiring R] (p : ℕ)</span>\n<span class=\"cm\">[_inst_3 : fact (nat.prime p)] [_inst_4 : char_p R p], R →+* R</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>My mental model a while ago was that this would fail because type class inference won't find <code>comm_semiring F</code> or <code>fact p.prime</code> -- but it finds them just fine. With a revised mental model it's easy to understand the labelling thing: I wouldn't expect <code>variable (Y : Type)</code> to be included in a lemma statement if it didn't mention <code>Y</code>, so similarly I wouldn't expect <code>variable [hp : fact p.prime]</code> to be included in a statement if it doesn't mention <code>hp</code>.</p>",
        "id": 275022431,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647026887
    },
    {
        "content": "<p>I cannot understand the behaviour of <code>Fact</code> here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span> <span class=\"bp\">-</span><span class=\"kd\">instance</span> <span class=\"o\">]</span> <span class=\"n\">instInhabitedNat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">EvenInhab</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Even</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">Inhabited</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨(</span><span class=\"bp\">@</span><span class=\"n\">Even.two_dvd</span> <span class=\"n\">ℕ</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"n\">Fact.out</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">haEv</span> <span class=\"o\">:</span> <span class=\"n\">Even</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Even</span> <span class=\"n\">b</span><span class=\"o\">)]</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">EvenInhab</span> <span class=\"n\">a</span> <span class=\"o\">⟨</span><span class=\"n\">haEv</span><span class=\"o\">⟩</span> <span class=\"c1\">-- it works</span>\n<span class=\"kn\">local</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">EvenInhab</span> <span class=\"n\">b</span> <span class=\"c1\">-- if fails, saying cannot find synthesization order for instance...</span>\n</code></pre></div>\n<p>When I compare it to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ZMod.instFieldZMod#doc\">docs#ZMod.instFieldZMod</a> it seems to me that leaving <code>[Fact (Even b)]</code> in the variables should work.</p>",
        "id": 422638020,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708527970
    },
    {
        "content": "<p>The difference with <code>ZMod</code> is that there the conclusion is parameterized by <code>b</code></p>",
        "id": 422640864,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708528753
    },
    {
        "content": "<p>Here it is just <code>ℕ</code>, so Lean cannot guess <code>b</code></p>",
        "id": 422640923,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708528768
    },
    {
        "content": "<p>Ah sure, it makes sense.</p>",
        "id": 422640972,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708528781
    },
    {
        "content": "<p>Yet I do not understand why the example with <code>a</code> works and that with <code>b </code> does not. I would argue as follows: in both cases, when lean looks for a default, it looks for a <code>Inhabited</code> instance that is activated locally, meaning that locally we have a term of the right type... and it seems to me that <code>@EvenInhab a &lt;haEv&gt;</code> and <code>EvenInhab b</code> are both terms of the right type. What am I missing?</p>",
        "id": 422645295,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708529844
    },
    {
        "content": "<p>The error is just because you mark these declarations as instances. This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">EvenInhab</span> <span class=\"n\">a</span> <span class=\"o\">⟨</span><span class=\"n\">haEv</span><span class=\"o\">⟩</span> <span class=\"c1\">-- it works</span>\n<span class=\"kd\">def</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">EvenInhab</span> <span class=\"n\">b</span> <span class=\"c1\">-- also works</span>\n</code></pre></div>",
        "id": 422647715,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1708530463
    },
    {
        "content": "<p>The problem is with making the second declaration an instance is that it has type<br>\n<code>instance [inst : Fact (Even b)] : Inhabited ℕ</code><br>\nBut Lean complains that it doesn't know what <code>b</code> is when doing type-class inference, and it refused to search for <code>Fact (Even _)</code>.</p>",
        "id": 422648020,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1708530545
    },
    {
        "content": "<p>And why is it happy with the first being an instance? Because it does not \"search\" for \"haEv\" but it finds it straight away?</p>",
        "id": 422648532,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708530669
    },
    {
        "content": "<p>I think that the first instance will never fire during type-class inference, but that Lean is not checking that part.</p>",
        "id": 422648908,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1708530761
    },
    {
        "content": "<p>That is a check that could (and should) be added to Lean core or a linter</p>",
        "id": 422649272,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1708530847
    },
    {
        "content": "<p>Ah indeed, if I try </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>\n<p>after the one without the error, it cannot find anything.</p>",
        "id": 422649696,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708530950
    },
    {
        "content": "<p>And is there a way to declare an instance locally in the sense that I want, in a certain section, to \"fix an even natural <code>a</code> and to use <code>EvenInhab a</code> as default term\" thus accessing all results that begin with <code>(X : Type) [Inhabited X]</code>? (apart of course calling them with <code>@</code>)</p>",
        "id": 422652482,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708531635
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span> <span class=\"o\">]</span> <span class=\"n\">foo</span>\n</code></pre></div>\n<p>should do the trick</p>",
        "id": 422653321,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708531808
    },
    {
        "content": "<p>No, same problem as with <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> example.</p>",
        "id": 422653918,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708531937
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">EvenInhab</span> <span class=\"n\">a</span> <span class=\"o\">⟨</span><span class=\"n\">haEv</span><span class=\"o\">⟩</span> <span class=\"c1\">-- it works</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">local</span> <span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">foo</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span> <span class=\"c1\">-- failed to synthetize</span>\n</code></pre></div>",
        "id": 422653978,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708531954
    },
    {
        "content": "<p>(I guess you suggested <code>attribute [local instance]</code> rather that <code>local attribute [instance]</code>, no?)</p>",
        "id": 422654226,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708532003
    },
    {
        "content": "<p>This was indeed my first trial, who drove me through this rabbit hole.</p>",
        "id": 422654489,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708532056
    },
    {
        "content": "<p>Yes, sorry.</p>",
        "id": 422654490,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708532056
    },
    {
        "content": "<p>Ah, I have misunderstood your question.</p>",
        "id": 422654882,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708532148
    },
    {
        "content": "<p>Then I don't get your point, what should be the fixed element of <code>N</code>?</p>",
        "id": 422654987,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708532165
    },
    {
        "content": "<p>Well, I would like that it is <code>a/2</code> in a section where I have fixed an even <code>a</code>.</p>",
        "id": 422655123,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708532196
    },
    {
        "content": "<p>It seems to me that this would be doable if the type depended on <code>a</code>, but not with a type independent of <code>a</code> like <code>N</code>.</p>",
        "id": 422655585,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708532309
    },
    {
        "content": "<p>I don't know what you want this for, but I think it's not easy.<br>\nDepending on your use case (probably teaching?), maybe the following is close enough?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">haEv</span> <span class=\"o\">:</span> <span class=\"n\">Even</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">EvenInhab</span> <span class=\"n\">a</span> <span class=\"o\">⟨</span><span class=\"n\">haEv</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>  <span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 422657196,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1708532686
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/113488-general/topic/fact/near/422657196\">said</a>:</p>\n<blockquote>\n<p>I don't know what you want this for, but I think it's not easy.<br>\nDepending on your use case (probably teaching?), maybe the following is close enough?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">haEv</span> <span class=\"o\">:</span> <span class=\"n\">Even</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">EvenInhab</span> <span class=\"n\">a</span> <span class=\"o\">⟨</span><span class=\"n\">haEv</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>  <span class=\"c1\">-- works</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Yes, I wanted to prepare a class about class instances and got stuck <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> Thanks for the catch with <code>axiom</code>!</p>",
        "id": 422657428,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708532751
    },
    {
        "content": "<p>I do not know if it is a good thing to present, but at least I learnt a lot.</p>",
        "id": 422657659,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708532798
    },
    {
        "content": "<p>Ah, nice idea! <code>axiom</code> mimics <code>parameter</code> of Lean 3!</p>",
        "id": 422657690,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708532810
    },
    {
        "content": "<p>Anyway the problem is that typeclass inference looks for classes, and it never has a way to guess the <code>a</code> you want</p>",
        "id": 422657781,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708532837
    },
    {
        "content": "<p>Just to finish on this, this seems to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha₀</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">haEv</span> <span class=\"o\">:</span> <span class=\"n\">Even</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Even</span> <span class=\"n\">b</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar_a</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨(</span><span class=\"bp\">@</span><span class=\"n\">Even.two_dvd</span> <span class=\"n\">ℕ</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"n\">haEv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span> <span class=\"o\">[(</span><span class=\"bp\">@</span><span class=\"n\">Even.two_dvd</span> <span class=\"n\">ℕ</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"n\">haEv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"o\">]⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar_b</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨(</span><span class=\"bp\">@</span><span class=\"n\">Even.two_dvd</span> <span class=\"n\">ℕ</span> <span class=\"n\">_</span> <span class=\"n\">b</span> <span class=\"n\">Fact.out</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span> <span class=\"o\">[(</span><span class=\"bp\">@</span><span class=\"n\">Even.two_dvd</span> <span class=\"n\">ℕ</span> <span class=\"n\">_</span> <span class=\"n\">b</span> <span class=\"n\">Fact.out</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"o\">,</span>\n    <span class=\"n\">hb.out</span><span class=\"o\">]⟩</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">local</span> <span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">bar_a</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span> <span class=\"c1\">-- fails</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">local</span> <span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">bar_b</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span> <span class=\"c1\">--succeeds</span>\n</code></pre></div>",
        "id": 422661287,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708533802
    },
    {
        "content": "<p>But as <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>  pointed out, the fact that class inference does not fire for <code>Fin a</code> is not catched by a linter at the time of defining the local instance <code>bar_a</code>, and that might be useful.</p>",
        "id": 422661721,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708533950
    }
]