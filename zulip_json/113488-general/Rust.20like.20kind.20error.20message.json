[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Point</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">origin</span> <span class=\"o\">:</span> <span class=\"n\">Point</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">⟩</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">error: expression</span>\n<span class=\"sd\">  origin</span>\n<span class=\"sd\">has type</span>\n<span class=\"sd\">  Point Nat</span>\n<span class=\"sd\">but instance</span>\n<span class=\"sd\">  Lean.Eval (Point Nat)</span>\n<span class=\"sd\">failed to be synthesized, this instance instructs Lean on how to display the resulting value, recall that any type implementing the `Repr` class also implements the `Lean.Eval` class</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span> <span class=\"k\">in</span>\n<span class=\"k\">#eval</span> <span class=\"n\">origin</span>\n</code></pre></div>\n<p>It seems to me that a suggestion could be made to ‘consider adding <code>deriving instance Repr for Point</code>’.</p>",
        "id": 437108291,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1714912902
    },
    {
        "content": "<p>A similar proposal could be made for all typeclasses for which deriving is defined, except Repr.</p>",
        "id": 437108376,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1714912968
    },
    {
        "content": "<p>I think this is challenging because we don't really have a way to point at \"what missing instance, if added, would make this instance synthesis work\"</p>",
        "id": 437128353,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1714921229
    },
    {
        "content": "<p>in this example, you want to suggest <code>Repr</code> instead of <code>Eval</code> because there is an instance from one to the other; also the thing being eval'd might be <code>(Point Nat × Nat)</code> in which case there is a <code>Repr</code> instance for <code>Prod</code> but it failed after the initial application because of a missing <code>Repr (Point A)</code> instance</p>",
        "id": 437128899,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1714921359
    },
    {
        "content": "<p>Maybe some mechanism for indicating that an instance is structural would help?</p>",
        "id": 437140581,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714924307
    },
    {
        "content": "<p>what do you mean?</p>",
        "id": 437140956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1714924489
    },
    {
        "content": "<p>So that if an instance for <code>Group (Prod A B)</code> fails, we can assume that the user wanted to use <code>Prod.instGroup</code> since this produces the obviously useful error message, vs <code>CommGroup.toGroup</code> which does not</p>",
        "id": 437141215,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714924658
    },
    {
        "content": "<p>Maybe just \"preferred instance\" to say that if there are multiple failing paths we should consider the ones that go through the most preferred instances</p>",
        "id": 437141597,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1714924893
    },
    {
        "content": "<p>Since in the above example we'd want to consider <code>[Repr A] : Lean.Eval A</code> as preferred even though it's not structural</p>",
        "id": 437141638,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1714924922
    },
    {
        "content": "<p>For this particular case though, I've been planning on improving the error message for <code>#eval</code> to explain a few different ways to make <code>#eval</code> work.</p>",
        "id": 437141758,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714924991
    },
    {
        "content": "<p>(I think it would be neat to have it be able to use ToExpr as well, like in some code Mario shared a while back, since then you could hover over subterms in the result and see their types. And, maybe more importantly, have it rely on the main pretty printer.)</p>",
        "id": 437141918,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714925124
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Rust.20like.20kind.20error.20message/near/437141597\">said</a>:</p>\n<blockquote>\n<p>Maybe just \"preferred instance\" to say that if there are multiple failing paths we should consider the ones that go through the most preferred instances</p>\n</blockquote>\n<p>I think the algorithm is:</p>\n<ul>\n<li>Do instance search as normal</li>\n<li>If it fails, print our all leaves of the search tree of the subtree of nodes that are reachable only by \"preferred instances\" (and omit the intermediate branches)</li>\n</ul>",
        "id": 437141925,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714925128
    },
    {
        "content": "<p>I don't think \"all leaves\" is viable, there are exponentially many in some cases</p>",
        "id": 437142012,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1714925178
    },
    {
        "content": "<p>I think it's better to have a scoring system and only show the best one</p>",
        "id": 437142039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1714925205
    },
    {
        "content": "<p>Also, I expect you would have to rerun instance search in order to gather more information, because the default search needs to avoid the bookkeeping overhead</p>",
        "id": 437142184,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1714925301
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Rust.20like.20kind.20error.20message/near/437142012\">said</a>:</p>\n<blockquote>\n<p>I don't think \"all leaves\" is viable, there are exponentially many in some cases</p>\n</blockquote>\n<p>Can you give an example?</p>",
        "id": 437142205,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714925317
    },
    {
        "content": "<p>I did not expect this issue to be challenging. Thank you for considering my views.</p>",
        "id": 437259000,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1715000918
    }
]