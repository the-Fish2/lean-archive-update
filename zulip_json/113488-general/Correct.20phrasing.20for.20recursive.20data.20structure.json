[
    {
        "content": "<p>Here's what a Pratt certificate of primality looks like (this is not quite the form that would slot into <code>LucasPrimality.lean</code>, which uses <code>ZMod</code> in a way that appears to foil <code>norm_num</code> entirely):</p>\n<div class=\"codehilite\" data-code-language=\"lean4\"><pre><span></span><code>structure PrattPrimeCertificate (n : ℕ) where\n  base: ℕ\n  h_base : (base ^ (n - 1)) % n = 1\n  sub_one_factors : List ℕ\n  all_prime : ∀ x ∈ sub_one_factors, x.Prime\n  are_factors : (n - 1) = List.foldl (fun x y =&gt; x * y) 1 sub_one_factors\n  are_cert : ∀ x ∈ sub_one_factors, (base ^ ((n - 1) / x)) % n ≠ 1\n</code></pre></div>\n<p>There are several possible options for how the \"all_prime\" field is expressed, though. Above, I've picked a pretty flexible one which doesn't have any recursion - but it's also not at all amenable to serialisation, and it's always a bit annoying to construct <code>forall</code>s. A more \"natural\" format from a programming point of view might instead have <code>sub_one_factors</code> be a list of <code>(k, multiplicity, PrattPrimeCertificate(k))</code>, and then store a proof that this is indeed a factorisation of <code>n-1</code> much as I currently do in <code>are_factors</code>. That way, we entirely separate any idea of a proof of primality away from the data. There's still a degree of freedom about whether to bundle the <code>(base ^ (n - 1) / k) % n ≠ 1</code> into that list, though: putting it into the list means <code>sub_one_factors</code> is no longer easy to serialise as data, but taking it out of the list means we have to bundle a separate proof quantifying over every factor at once.</p>\n<p>What would people's intuitions be on the \"easiest\" way to express the above (especially given that I imagine a primary use-case for Pratt certificates would be interfacing with external primality provers)? Would you bite the bullet and store recursive copies of the struct in the <code>all_prime</code> list (which I guess means you need well-foundedness proofs for any operation on a <code>PrattPrimeCertificate</code>)? Would you somehow completely unbundle all the proofs so that there's a proof-free datatype which can be freely exchanged with external provers, and then attach some kind of proof object to it? Something else I haven't considered?</p>",
        "id": 430512895,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1711924134
    },
    {
        "content": "<p>(I feel like Conor McBride would have a beautiful elegant answer that was somehow perfectly ergonomic.)</p>",
        "id": 430513016,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1711924272
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Forall#doc\">docs#List.Forall</a> unfolds to <code>And</code>s. You can construct each <code>Prime _</code> in this <code>And</code> from <code>PrattPrimeCertificate</code> without adding this requirement to the structure itself.</p>",
        "id": 430527278,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1711937541
    },
    {
        "content": "<p>We also have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.prod#doc\">docs#List.prod</a> which is defeq to the <code>List.foldl</code> you use in <code>are_factors</code></p>",
        "id": 430527373,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1711937610
    },
    {
        "content": "<p>Of course, you need a theorem</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">proof_wanted</span> <span class=\"n\">PrattPrimeCerticifate.prime</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">PrattPrimeCertificate</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n.Prime</span>\n</code></pre></div>\n<p>to construct each <code>Prime</code> in the long <code>And</code>.</p>",
        "id": 430527488,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1711937715
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"117987\">@Patrick Stevens</span>, I have a formalization of Pratt certificates which you might be interested in (warning: unpolished code): <a href=\"https://github.com/leanprover-community/mathlib4/blob/6439ce3f194a2acd309af6831d753e560c46bcf6/Mathlib/NumberTheory/LucasPrimality.lean#L74\">https://github.com/leanprover-community/mathlib4/blob/6439ce3f194a2acd309af6831d753e560c46bcf6/Mathlib/NumberTheory/LucasPrimality.lean#L74</a> I chose the following approach: the proof-carrying <code>PrattCertificate</code> only has \"one level\" of depth and just takes <code>Nat.Prime</code> arguments for the factors of <code>n-1</code>. However, there is also an <code>UnverifiedPrattCertificate</code>, which contains recursive unverified pratt certificates down to a fixed list of known primes. The unverified pratt certificate is just the data (i.e., the witnesses and the factorization), without any proofs, and this would lend itself well to serialization, though that isn't implemented.  The <code>pratt</code> tactic currently consists of two parts, the first generates an <code>UnverifiedPrattCertificate</code> and the second part turns an <code>UnverifiedPrattCertificate</code> into a <code>PrattCertificate</code>, failing if the data is not valid.</p>",
        "id": 430548937,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1711952042
    },
    {
        "content": "<p>Thanks Markus, that looks pretty good ergonomically to me! How did you choose the structure of <code>split</code> - was that just a lucky guess at something that would be easy to use, or did you have some heuristic that told you it would work well, or what?</p>",
        "id": 430577702,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1711969664
    },
    {
        "content": "<p>This decision was partly inspired by the <code>norm_num</code> implementation of exponentiation (see <a href=\"https://tqft.net/mathlib4files/Tactic/NormNum/Pow\">file#Tactic/NormNum/Pow</a>), where the computation/proof is structured as a binary tree in order to avoid deep recursion. I noticed that a similar approach could be useful to break down dealing with the prime factors of p-1 into smaller steps without having to deal with lists, and it worked out quite well.</p>",
        "id": 430578635,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1711970251
    }
]