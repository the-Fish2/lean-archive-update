[
    {
        "content": "<p>Is this expected behaviour?  Is it desired behaviour?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.DefEqTransformations</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">--unfold_let at *  -- uncomment to get an error</span>\n  <span class=\"n\">exact</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 432757494,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712857512
    },
    {
        "content": "<p>(I have been puzzled by this in a situation similar to the one above, but it behaves the same way also if you write<br>\n<code>example {a : Int} {a : Nat} : Nat := by</code>.)</p>",
        "id": 432757734,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712857595
    },
    {
        "content": "<p>To look at this from a positive perspective, you can make <del>unhygienic</del>shadowed variables usable as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold_let</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">exact</span> <span class=\"n\">a</span>  <span class=\"c1\">-- &lt;--- `a` is now a `Nat`, even though it was unhygienic at the beginning!!!</span>\n</code></pre></div>",
        "id": 432758104,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712857752
    },
    {
        "content": "<p>shadowed variables aren't actually hygienic, they are just shadowed</p>",
        "id": 432758314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712857842
    },
    {
        "content": "<p>Ah, ok, I was confused by the dagger.</p>",
        "id": 432758376,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712857871
    },
    {
        "content": "<p>what you are seeing is that <code>unfold_let</code> reorders variables sometimes</p>",
        "id": 432758418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712857897
    },
    {
        "content": "<p>I think there is an old issue pointing out that <code>cases</code> also reorders variables</p>",
        "id": 432758447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712857913
    },
    {
        "content": "<p>Ok, is there a way to avoid this?</p>",
        "id": 432758559,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712857950
    },
    {
        "content": "<p>fix the tactic?</p>",
        "id": 432758617,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712857974
    },
    {
        "content": "<p>in this case <code>unfold_let</code> shouldn't do anything, right?</p>",
        "id": 432758643,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712857984
    },
    {
        "content": "<p>there are no lets in the context</p>",
        "id": 432758655,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712857991
    },
    {
        "content": "<p>Correct, it should not do anything.  Now I do not know if in my actual example <code>unfold let</code> was doing something or not.</p>",
        "id": 432758799,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712858048
    },
    {
        "content": "<p>I am not sure what is going on, but I think that <em>something</em> along the way is stored is a <code>HashMap</code>.  If this is actually relevant, then I guess a possibility would be to record the initial position of the variables and sort the outcome using that instead?</p>",
        "id": 432760501,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712858695
    },
    {
        "content": "<p>Oh, maybe they are always just in reverse order?</p>",
        "id": 432761570,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712859121
    },
    {
        "content": "<p>Ok, it seems that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Tactic.withLocation#doc\">docs#Lean.Elab.Tactic.withLocation</a> may be the source of the issue:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>      <span class=\"c1\">-- We must traverse backwards because the given `atLocal` may use the revert/intro idiom</span>\n      <span class=\"n\">for</span> <span class=\"n\">fvarId</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"bp\">‚Üê</span> <span class=\"n\">getLCtx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getFVarIds.reverse</span> <span class=\"k\">do</span>\n</code></pre></div>",
        "id": 432763466,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712859863
    },
    {
        "content": "<p>So, my current guess is that the hypotheses are traversed in reverse order and, since they get \"touched\" (even if unmodified), they make their way back into the local context in the reverse order in which they initially appeared.</p>\n<p>However, simply reversing everything after the fact is not going to actually work, since there may be dependencies among the variables.</p>",
        "id": 432763863,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712860011
    },
    {
        "content": "<p>Maybe, doing <code>unfold_let at *; unfold_let at *</code> solves my problem!</p>",
        "id": 432766029,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712860744
    },
    {
        "content": "<p>Interesting, this is an interaction between <code>*</code> going in reverse order to play well with the revert/intro idiom (this idiom can change all the fvarids of the locals coming after the current one) and the fact that <code>unfold_let</code> always does the revert/intro idiom, even if it doesn't change anything.</p>\n<p>Two possible solutions (that are not mutually exclusive):</p>\n<ol>\n<li>Make it only change the hypothesis if the type is updated.</li>\n<li>Make it <em>not</em> reorder goals at all. It could do this by reverting everything that comes after the local variable in question, rather than just reverting the things that depend on it.</li>\n</ol>",
        "id": 432812897,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712884852
    },
    {
        "content": "<p>I implemented both in <a href=\"https://github.com/leanprover-community/mathlib4/pull/12077\">#12077</a></p>",
        "id": 432816471,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712887539
    },
    {
        "content": "<p>Wow, this is great: thanks Kyle!</p>\n<p>Btw, this is the third feature discovered in the course of the \"automated bugs\" tools that I'm working on: I consider it a good sign!</p>",
        "id": 432834458,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712901491
    },
    {
        "content": "<p>Kyle, I tested the new implementation and I approved of the changes!  I just don't feel competent enough to <code>maintainer merge</code> it.</p>",
        "id": 432848575,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712907642
    }
]