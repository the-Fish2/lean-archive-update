[
    {
        "content": "<p>I have been looking into possibilities to incorporate Sage into Lean (since I do a bit of Sage), something like <code>polyrith</code>, and I have a few questions.</p>\n<ol>\n<li>To me, <code>polyrith</code> feels more like a proof-of-concept rather than what usage of Sage should look like in Lean/Mathlib - is that correct?</li>\n<li>Related to (1.), in the long term, will adding the option to use Sage locally (when it's installed) be useful for people here, or is calling <a href=\"http://sagecell.sagemath.org\">sagecell.sagemath.org</a> fine?</li>\n<li>I'm also wondering what could be done in Sage and what should be done in Mathlib. For example, would a tactic to prove a graph is acyclic <em>via Sage</em>, by returning a cycle for example, then reconstructing the proof in Lean be interesting, or should that be implemented in Lean? Or is there no preference as long as it generates a valid proof?</li>\n</ol>",
        "id": 426638610,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710454480
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"579936\">Gareth Ma</span> <a href=\"#narrow/stream/113488-general/topic/What.20should.20Sage.20look.20like.20in.20Lean.3F/near/426638610\">said</a>:</p>\n<blockquote>\n<ol>\n<li>To me, <code>polyrith</code> feels more like a proof-of-concept rather than what usage of Sage should look like in Lean/Mathlib - is that correct?</li>\n</ol>\n</blockquote>\n<p>I failed to assign any meaning to this sentence. Could you elaborate? <code>polyrith</code> is a very successful use of Sage in Lean.</p>",
        "id": 426638964,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1710454676
    },
    {
        "content": "<p>I think ideally you want problems for which you can generate certificates. And then a tactic in Lean which can turn the certificates into a proof. This is essentially what <code>polyrith</code> does. It gets the linear combination from Sage and passes it to the <code>linear_combination</code> tactic.</p>",
        "id": 426639073,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710454715
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/What.20should.20Sage.20look.20like.20in.20Lean.3F/near/426638964\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"579936\">Gareth Ma</span> <a href=\"#narrow/stream/113488-general/topic/What.20should.20Sage.20look.20like.20in.20Lean.3F/near/426638610\">said</a>:</p>\n<blockquote>\n<ol>\n<li>To me, <code>polyrith</code> feels more like a proof-of-concept rather than what usage of Sage should look like in Lean/Mathlib - is that correct?</li>\n</ol>\n</blockquote>\n<p>I failed to assign any meaning to this sentence. Could you elaborate? <code>polyrith</code> is a very successful use of Sage in Lean.</p>\n</blockquote>\n<p>Sorry, I guess it should be linked with (2.). It currently calls the online service (from what I know), which is why I thought it seems PoC-like. Or is that an okay approach for future tactics?</p>",
        "id": 426639132,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710454745
    },
    {
        "content": "<p>(Sorry if my initial message is unclear, it's a meta-question and I don't know how to phrase it well)</p>",
        "id": 426639173,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710454763
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113488-general/topic/What.20should.20Sage.20look.20like.20in.20Lean.3F/near/426639073\">said</a>:</p>\n<blockquote>\n<p>I think ideally you want problems for which you can generate certificates. And then a tactic in Lean which can turn the certificates into a proof. This is essentially what <code>polyrith</code> does. It gets the linear combination from Sage and passes it to the <code>linear_combination</code> tactic.</p>\n</blockquote>\n<p>Yes, that's exactly what I mean. I'm looking into linear programming certificates too, and there there should be a lot more possibilities.</p>",
        "id": 426639293,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710454806
    },
    {
        "content": "<p>I think for now it's an okay approach for future tactics, as long as they are self-replacing like <code>polyrith</code>. We certainly wouldn't want a tactic that's trying to call Sage from CI.</p>",
        "id": 426639297,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710454807
    },
    {
        "content": "<p>Do you (plural) have any opinions on (3.)</p>",
        "id": 426639503,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710454918
    },
    {
        "content": "<p>Calling Sage over network is clearly a deliberate choice here. Being able to use the tactic without installing Sage is a huge benefit. So calling a local Sage would be PoC-like.</p>",
        "id": 426639676,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1710455001
    },
    {
        "content": "<p>Of course this workflow makes sense only for self-replacing tactics, but we don’t want to call Sage every time Lean checks the proof anyway.</p>",
        "id": 426639818,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1710455057
    },
    {
        "content": "<p>Hmm I was thinking the opposite. The online Sage doesn't have the optional packages installed, and also doesn't allow for e.g. clustering / parallelisation</p>",
        "id": 426639821,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710455059
    },
    {
        "content": "<p>Allowing the option to run a local custom Sage would be nice, but this is not at all the common case.</p>",
        "id": 426639906,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1710455106
    },
    {
        "content": "<p>That's an interesting perspective, and good that I asked here I guess :D I will rethink about it</p>",
        "id": 426639990,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710455154
    },
    {
        "content": "<p>Personally, I would prefer to call Sage locally if it were possible, but I realize most people aren't like me.</p>",
        "id": 426640359,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710455325
    },
    {
        "content": "<p>Thanks for the input :D I'm in the minority too I guess</p>",
        "id": 426641374,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710455856
    },
    {
        "content": "<p>Before using Lean 4 + Mathlib, I used to think Sage was a really gigantic software that one do not install without thinking about it twice.</p>",
        "id": 426642694,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1710456574
    },
    {
        "content": "<p>About running a local install for <code>polyrith</code>, I think it would make much more sense to use Singular instead of Sage (or rather, to have both options). Singular is a much smaller piece of software than Sage, and the installation is often simpler too. </p>\n<p>And in the case of the computations run for <code>polyrith</code>,  Sage uses  Singular under the hood  anyways.</p>\n<p>And yes, I think having the possibility of use the Lean tactics without relying on internet connection and external online services (that could disappear at any given moment) is kind of important.</p>",
        "id": 426645022,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1710457794
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 426645086,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710457808
    },
    {
        "content": "<p>To be clear: what I am (kind of) proposing is to give <code>polyrith</code> the option of using a local installation of Singular.</p>\n<p>And in fact, any CAS that can do Gröbner basis could work too.  It shouldn't be hard to check if any of the usual suspects is installed and try to use it.</p>",
        "id": 426645420,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1710458010
    },
    {
        "content": "<p>Yes, and I think that should be easy to fix. The <code>polyrith</code> just calls</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">out</span> <span class=\"bp\">←</span> <span class=\"n\">IO.Process.output</span> <span class=\"o\">{</span> <span class=\"n\">cmd</span> <span class=\"o\">:=</span> <span class=\"s2\">\"python3\"</span><span class=\"o\">,</span> <span class=\"n\">args</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">path.toString</span><span class=\"o\">]</span> <span class=\"bp\">++</span> <span class=\"n\">args</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>(where <code>path</code> is to a file that make a request to <a href=\"http://sagecell.sagemath.org\">sagecell.sagemath.org</a>), so we can just replace it with a singular call or whatever.</p>",
        "id": 426645846,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710458234
    },
    {
        "content": "<p>One might also want to use Sage (or any CAS) + Lean by writing a wrapper for a low level function available in Sage, <em>axiomatizing</em> its behaviour, and then writing a verified higher level algorithm in Lean.</p>\n<p>This isn't something you would do in Mathlib, as we don't want new axioms there, but nevertheless is interesting.</p>",
        "id": 426654978,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710463903
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span> and I wrote a short demo of this at <a href=\"https://github.com/aim-cyber-workshop-2023/lean-sage/blob/main/LeanSage/Demo.lean\">https://github.com/aim-cyber-workshop-2023/lean-sage/blob/main/LeanSage/Demo.lean</a></p>",
        "id": 426655007,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710463923
    },
    {
        "content": "<p>Oh my god this is so cool and exactly what I'm looking for. I'll have a closer look when I wake up, thanks!!</p>",
        "id": 426655077,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710463965
    },
    {
        "content": "<p>(Here we axiomatize the behaviour of sage's integer factorization algorithm, and then use this to implement a verified \"is x a primitive root of unity mod k\" algorithm.)</p>",
        "id": 426655093,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710463978
    },
    {
        "content": "<p>Is creating a new <code>axiom</code> just a nicer way to write a theorem but <code>sorry</code>'ing it?</p>",
        "id": 426655131,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710464017
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/What.20should.20Sage.20look.20like.20in.20Lean.3F/near/426642694\">said</a>:</p>\n<blockquote>\n<p>Sage was a really gigantic software that one do not install without thinking about it twice.</p>\n</blockquote>\n<p>(I just needed to install sage locally to test the above demo still worked: <code>brew install sage</code>, waiting about 3 minutes, and typing a password seems to have been all that was necessary.)</p>",
        "id": 426655201,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710464046
    },
    {
        "content": "<p>(Note that this demo is still ridiculously slow because we never merged <a href=\"https://github.com/leanprover-community/mathlib4/pull/8885\">#8885</a>.)</p>",
        "id": 426655266,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710464103
    },
    {
        "content": "<p>(Note <a href=\"https://github.com/leanprover-community/mathlib4/pull/8885\">#8885</a> is delegated at minimum it just needs to brought in line with master. Moving some of the stuff to a separate file would be a nice follow up)</p>",
        "id": 426655704,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1710464415
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113488-general/topic/What.20should.20Sage.20look.20like.20in.20Lean.3F/near/426655201\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/What.20should.20Sage.20look.20like.20in.20Lean.3F/near/426642694\">said</a>:</p>\n<blockquote>\n<p>Sage was a really gigantic software that one do not install without thinking about it twice.</p>\n</blockquote>\n<p>(I just needed to install sage locally to test the above demo still worked: <code>brew install sage</code>, waiting about 3 minutes, and typing a password seems to have been all that was necessary.)</p>\n</blockquote>\n<p>In my memory Sage needed more than 1Gb to download and store. Did this change recently?</p>",
        "id": 426656016,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1710464625
    },
    {
        "content": "<p><del>The source is 1.2G</del> the source + build artifacts is 1.2G, idk binary</p>",
        "id": 426656083,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710464659
    },
    {
        "content": "<p>But installation time is quick yeah, even building from source only takes ~15 minutes on my i5 laptop</p>",
        "id": 426656101,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710464681
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"579936\">@Gareth Ma</span> <a href=\"#narrow/stream/113488-general/topic/What.20should.20Sage.20look.20like.20in.20Lean.3F/near/426655131\">said</a>:</p>\n<blockquote>\n<p>Is creating a new <code>axiom</code> just a nicer way to write a theorem but <code>sorry</code>'ing it?</p>\n</blockquote>\n<p>The two are similar, but have slightly different meanings and effects on lean. A proof by <code>sorry</code> is saying \"I think this is provable, but I would rather not prove it now\", and lean will remind you that the proof is incomplete with a warning. An axiom is saying \"I assert this is true, even though lean cannot prove it\" and lean will not give any warning (but you can find use of such axioms later using the <code>#print axioms</code> command, which will also reveal uses of the <code>sorryAx</code> axiom which the <code>sorry</code> term elaborates to after giving the warning). A finished development should not have <code>sorry</code>s but it may have axioms in it.</p>",
        "id": 426656574,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710464970
    },
    {
        "content": "<p>That makes sense, thanks. I guess <code>sorry</code> is implemented as (a tactic that just uses) an axiom (the <code>sorryAx</code>) then?</p>",
        "id": 426656721,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710465064
    },
    {
        "content": "<p>In a case like this, you would want to use an <code>axiom</code> rather than <code>sorry</code>, because the theorem is genuinely not provable: calling some FFI function from Sage is an opaque function with no provable properties</p>",
        "id": 426656739,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710465082
    },
    {
        "content": "<p>yes, it's effectively <code>&lt;give warning&gt;; exact sorryAx _ false</code></p>",
        "id": 426656779,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710465110
    },
    {
        "content": "<p>So, the approach of axiomatizing the Sage behaviour means \"we will accept as an axiom that whatever the Sage call returns is correct\"?</p>\n<p>Doesn't that kind of defeat the purpose of formally verifying proofs?</p>",
        "id": 426790104,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1710523401
    },
    {
        "content": "<p>I guess that's why it's a \"demo\"</p>",
        "id": 426790184,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710523431
    },
    {
        "content": "<p>Along these lines, one of the proposals of Sage for this year's GSOC involves some form of integration with proof assistants:</p>\n<p><a href=\"https://wiki.sagemath.org/GSoC/2024\">https://wiki.sagemath.org/GSoC/2024</a></p>\n<p>I think the idea is to give a convenient interface, and also, when possible, modify some functions to return not only the final result, but also a witness of correctness that can be efficiently checked by proof assistants (in the spirit of what <code>polyrith</code> does).</p>\n<p>I think it is a nice idea, but out of my head I don't get many examples of computations that allow this kind of witnesses (of course, it deppends on where you set the bar for \"easily verified\").</p>",
        "id": 426792107,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1710524106
    },
    {
        "content": "<p>Yes, I’m applying for that :)</p>",
        "id": 426792163,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1710524130
    },
    {
        "content": "<p>I see. </p>\n<p>Here are some thoughts about possible problems that could fit in this idea:</p>\n<ul>\n<li>Factorization problems: Sage can compute the factors, and Lean can easily check that the product of the factors gives indeed the original value. Verifying that the factors are irreducible is another story.</li>\n<li>matrix factorizations (LU, Cholesky, Smith ....): Sage can compute them (the complete factorization), and Lean can verify - that the results are indeed factorizations of the original matrix, and that they satisfy the corresponding property (being triangular/diagonal/orthogonal or whatever).</li>\n<li>Finding solutions of (systems of) equations: Sage can find solutions and Lean verify them. Again, checking that no other solutions exists is another story.</li>\n<li>Same as before, for differential equations.</li>\n<li>Symbolic integrals: Sage can compute them and then Lean can verify that the derivative of the result is indeed the original expression. This one is much more tricky that it looks, because of the multiple expressions that the same function can have<br>\n (and also, I am not sure how good Lean is at computing symbolic derivatives). There is also the problem of the domains where the functions are defined.</li>\n</ul>\n<p>Anyways, it sounds like both Sage and Lean could benefit from this: Lean could have more <code>polyrith</code>-like taactics, and Sage could say \"here is the result, and Lean checked that it is correct\" for some computations (maybe even providing Lean code that can be independently checked).</p>",
        "id": 426796085,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1710525628
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116034\">@William Stein</span> just a heads-up that this discussion is happening</p>",
        "id": 426806020,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710529780
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113488-general/topic/What.20should.20Sage.20look.20like.20in.20Lean.3F/near/426654978\">said</a>:</p>\n<blockquote>\n<p>One might also want to use Sage (or any CAS) + Lean by writing a wrapper for a low level function available in Sage, <em>axiomatizing</em> its behaviour, and then writing a verified higher level algorithm in Lean.</p>\n<p>This isn't something you would do in Mathlib, as we don't want new axioms there, but nevertheless is interesting.</p>\n</blockquote>\n<p>Can't you avoid the axiom here by using <code>opaque</code>, and just proving that a function could exist that performs the low-level function?</p>",
        "id": 426809343,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710531186
    },
    {
        "content": "<p>So</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">implemented_by</span> <span class=\"n\">sagePrimeFactorsUnsafe</span><span class=\"kd\">]</span>\n<span class=\"n\">opaque</span> <span class=\"n\">sagePrimeFactorsAux</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ℕ</span> <span class=\"bp\">//</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">Nat.primeFactors</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 426809529,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710531259
    },
    {
        "content": "<p>(and use <code>lcProof</code> in the <code>unsafe</code> version to populate the subtype)</p>",
        "id": 426809603,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710531295
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461731\">Miguel Marco</span> <a href=\"#narrow/stream/113488-general/topic/What.20should.20Sage.20look.20like.20in.20Lean.3F/near/426790104\">said</a>:</p>\n<blockquote>\n<p>So, the approach of axiomatizing the Sage behaviour means \"we will accept as an axiom that whatever the Sage call returns is correct\"?</p>\n<p>Doesn't that kind of defeat the purpose of formally verifying proofs?</p>\n</blockquote>\n<p>Not at all. There are always lower levels of a system that you are trusting (i.e. for most Lean users, the Lean kernel. Other Lean users use <code>reduceBool</code> and trust the compiler too, etc.).</p>\n<p>I think it's an interesting opportunity, that I hope we pursue, whereby someone who otherwise would have developed a high level algorithm in Sage might instead develop it in Lean.</p>\n<p>They can still call a low level function in Sage that is not available in Lean, and axiomatize its behaviour. This is reasonable, because the low-level function has been used for a long time by a large Sage user base. The newly developed work is ensured to be correct by Lean.</p>",
        "id": 426828842,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710540045
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/What.20should.20Sage.20look.20like.20in.20Lean.3F/near/426809529\">said</a>:</p>\n<blockquote>\n<p>So</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">implemented_by</span> <span class=\"n\">sagePrimeFactorsUnsafe</span><span class=\"kd\">]</span>\n<span class=\"n\">opaque</span> <span class=\"n\">sagePrimeFactorsAux</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">ℕ</span> <span class=\"bp\">//</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">Nat.primeFactors</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>PRs welcome! :-)</p>",
        "id": 426828970,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710540097
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 426839359,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1710546438
    },
    {
        "content": "<p>Add checking of Wilf-Zeilberger certificates for symbolic summation to the list (regardless of where the certificate comes from).</p>",
        "id": 431662521,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1712400154
    },
    {
        "content": "<p>Would it be a good option to have a typeclass <code>TrustSAGE</code> (or many more specific ones) which have the axioms in them? Then there can still be high level algorithms in Lean but the signature makes it clear what is trusted.</p>",
        "id": 431681252,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1712416442
    },
    {
        "content": "<p>Just to update on this, my GSoC proposal was unfortunately rejected, and I don't see myself working on this if I were to choose between this and, you know, normal mathematics formalisation :D Hope the discussion is useful to any future attempts!</p>",
        "id": 436559687,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1714591792
    },
    {
        "content": "<p>I have a foggy notion that the lean infoview can display arbitrary HTML (correct me if I’m wrong), so I was wondering if anyone has given any thought to plotting stuff on it via Sage? By this I mean making some kind of light wrapper for the Sage plotting libraries and then displaying the result in the infoview. Maybe <span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span>? Presumably plotting is part of making lean a language for scientific programming</p>",
        "id": 437032607,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1714839545
    },
    {
        "content": "<p>yes, I'm sure I've seen examples of this (IIRC ProofWidgets even has an animating plot)</p>",
        "id": 437032753,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1714839702
    },
    {
        "content": "<p>At one point, I had created a light wrapper around the <code>Plotly</code> library to render plots in the infoview. The source code is available here (I can't seem to find the corresponding Zulip post): <a href=\"https://github.com/leanprover-community/ProofWidgets4/pull/15/files\">https://github.com/leanprover-community/ProofWidgets4/pull/15/files</a>.<br>\nThe ProofWidgets repository also has some examples using the <code>Recharts</code> package.</p>",
        "id": 437042386,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1714847305
    }
]