[
    {
        "content": "<p>Hi folks,</p>\n<p>Ever since I had to resort to Guarded Cubical Agda last year to type-check a denotational semantics that I wrote a paper about and thus had to prove total, I wondered if I could have pulled off the same in Lean, and in doing so would even have been able to <em>execute</em> the resulting definition as well as have a bit more proof automation at my disposal.</p>\n<p>If you are interested in the work I did and are <em>not</em> an ICFP'24 reviewer, expand the following section:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Links</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>Agda code <a href=\"https://github.com/sgraf812/abs-den/blob/5d26cc981469c6d32309ea165f72b5bb860c715b/agda/Semantics.agda#L56\">here</a>, paper preprint <a href=\"https://pp.ipd.kit.edu/~sgraf/abs-den.pdf\">here</a>).</p>\n</div></div>\n<p>What would I need in Lean to do the same? Well, I really need <a href=\"https://www.pls-lab.org/en/Guarded_recursion_(type_theory)\">guarded recursive types</a> in order to define a type like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">data</span> <span class=\"n\">D</span> <span class=\"n\">where</span>\n  <span class=\"n\">stuck</span> <span class=\"o\">:</span> <span class=\"n\">D</span>\n  <span class=\"k\">fun</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">‚ñπ</span> <span class=\"n\">D</span> <span class=\"bp\">‚Üí</span>  <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">D</span>\n  <span class=\"n\">step</span> <span class=\"o\">:</span>  <span class=\"bp\">‚ñπ</span> <span class=\"n\">D</span> <span class=\"bp\">‚Üí</span>  <span class=\"n\">D</span>\n</code></pre></div>\n<p>Note the negative occurrence of <code>D</code> in the <code>fun</code> constructor that I guard under the later modality ‚ñπ . <br>\nThis would be rejected as an inductive type or in the usual notion of coinductive type alike.<br>\nBut since the later modality guards the negative occurrence, any <code>f</code> I give to constructor <code>fun</code> must promise to guard evaluation of its argument behind a suitably lazy data constructor (such as <code>step</code>).<br>\nAs a result, the above definition of <code>D</code> exists as a guarded recursive type.<br>\nIt was quite a joy to define the semantics in this framework, because extracting a runnable interpreter from this formulation is as easy as reading ‚ñπ  as \"thunk\" and erasing <code>‚ñπ  D</code> to <code>Unit ‚Üí D</code>. (In Haskell, I can simply omit ‚ñπ.) Although this is all based on cutting edge type theory, it is so very simple to think about and use, at least compared to using domain theory to prove that my definition exists for some complicated Scott domain encoding of <code>D</code>.</p>\n<p>Proofs are a different matter though, and my experience to conduct these proofs in Guarded Cubical Agda were painful, probably not least due to my inexperience with interactive theorem proving in general and the quirks of working at the intersection of two niche features.</p>\n<hr>\n<p>So I would really like to see guarded recursive types in Lean, and have thought a bit about the technicalities to achieve that. It was pretty clear to me that extending the language accepted by the Kernel is out of the question. So I came up with the following strategy:</p>\n<ol>\n<li>Implement a useful Guarded Recursive Type Theory in the surface syntax. Which, I don't know; I guess the research dust has to settle a bit to see what sticks. I certainly lack the context to judge. But let me list a bit of starting points for a survey: Recent advances of applying guarded recursion to dependent type theory are <a href=\"https://arxiv.org/abs/1601.01586\">Guarded Dependent Type Theory</a> and <a href=\"https://pure.itu.dk/ws/portalfiles/portal/82163359/bahr17lics_paper.pdf\">The clocks are ticking! No more delays</a> (introducing \"CloTT\"). Later works introduced Guarded Cubical Agda and finally its most recent incarnation of Ticked Cubical Type Theory, used <a href=\"https://dl.acm.org/doi/10.1145/3290317\">here</a>. I'm quite out of my depth here, but the use of Cubical types is mainly to support ergonomic encoding of powerdomains, I believe. Is there potential to just stick to, e.g., Guarded Dependent Type Theory and improve it? I don't know, but I hope so.</li>\n<li>When elaborating surface syntax into a <em>core term</em>, desugar the type theory into a framework using step-indexing. Details below.</li>\n<li>When producing <em>IR</em> for code generation,  desugar <code>‚ñπ  D</code> to <code>Unit -&gt; D</code>, or <code>Thunk D</code>. </li>\n</ol>\n<p>That way, we get efficient guarded recursive types without paying a complexity toll in the Kernel. (At least that is my <em>very na√Øve</em> hope.)</p>\n<p>That said, the big wildcards are of course (1) and (2). <br>\n(1) I frankly cannot substantiate any more than I tried for lack of knowledge. <br>\nFor (2), I have an idea for how to desugar <code>‚ñπ  D</code> into more elemental inductive types.<br>\nI think an encoding based on step-indexing will do. For example, <a href=\"https://siek.blogspot.com/2023/04/type-safety-in-10-easy-4-medium-and-1.html\">Jeremy Siek encodes step-indexed logic in Agda here</a>. Here is the most relevant excerpt:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Blog</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>Our Step-indexed Logic (SIL) includes first-order logic (i.e., a logic<br>\nwith \"and\", \"or\", \"implies\", \"for all\", etc.). To distinguish its<br>\nconnectives from Agda's, we add a superscript \"o\". So \"and\" is written<br>\n<code>√ó·µí</code>, \"implies\" is written <code>‚Üí·µí</code>, and so on.  SIL also includes a<br>\nnotion of time in which there is a clock counting down. The logic is<br>\ndesigned in such a way that if a formula <code>P</code> is true at some time then<br>\n<code>P</code> stays true in the future (at lower counts). So formulas are<br>\ndownward closed.  When the clock reaches zero, every formula becomes<br>\ntrue.  Furthermore, the logic includes a \"later\" operator, written <code>‚ñ∑·µí\nP</code>, meaning that <code>P</code> is true one clock tick in the future. When we use<br>\nSIL to reason about the cast calculus, one clock tick will correspond<br>\nto one reduction step.</p>\n<p>Just as <code>Set</code> is the type of true/false formulas in Agda, <code>Set·µí</code> is<br>\nthe type of true/false formulas in SIL. It is a record that bundles<br>\nthe formula itself, represented with a function of type <code>‚Ñï ‚Üí Set</code>,<br>\nwith proofs that the formula is downward closed and true at zero.</p>\n<div class=\"codehilite\"><pre><span></span><code>record Set·µí : Set‚ÇÅ where\n  field\n    # : ‚Ñï ‚Üí Set\n    down : downClosed #\n    tz : # 0                -- tz short for true at zero\nopen Set·µí public\n</code></pre></div>\n\n<p>For example, the \"false\" proposition is false at every time except zero.</p>\n<div class=\"codehilite\"><pre><span></span><code>‚ä•·µí : Set·µí\n‚ä•·µí = record { # = Œª { zero ‚Üí ‚ä§ ; (suc k) ‚Üí ‚ä• }\n            ; down = ... ; tz = ... }\n</code></pre></div>\n\n</div></div>\n<p>The result is basically a library for defining and using guarded recursive types, but one that indexes all finite prefixes of an infinite coinductive value, rather than encoding the coinductive value first class, so it's not really suitable for execution. I guess this is also what was discussed in the following thread: <a href=\"#narrow/stream/113488-general/topic/.E2.9C.94.20Efficient.20coinduction/near/298282159\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/.E2.9C.94.20Efficient.20coinduction/near/298282159</a> and this SO: <a href=\"https://mathoverflow.net/questions/407964/coinduction-for-all/408509#408509\">https://mathoverflow.net/questions/407964/coinduction-for-all/408509#408509</a> (kudos <span class=\"user-mention\" data-user-id=\"221921\">@Marc Huisinga</span>)</p>\n<p>Perhaps (quite probably) the concrete idea I proposed isn't so easily possible. But <a href=\"https://arxiv.org/abs/2004.01709\">Ticking clocks as dependent right adjoints: Denotational semantics for clocked type theory</a> should yield such a (perhaps complicated?) desugaring; to desugar, run the denotational semantics and embed its semantic domain as ordinary core term.</p>\n<p>I pitched this idea to <span class=\"user-mention\" data-user-id=\"110789\">@Jakob von Raumer</span> who suggested I reach out to the community to see whether people have been working in this direction already.</p>",
        "id": 425112446,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1709738468
    },
    {
        "content": "<p>At risk that I may not have understood what you're trying to do in sufficient depth: It sounds like guarded recursive types can be reduced to Lean's mutually inductive types. If you can define a \"Syntax\" (in the sense of the paper linked below) for guarded recursive types, and a reduction from that syntax to the syntax of mutually inductive types, then together with a  <a href=\"https://drops.dagstuhl.de/storage/00lipics/lipics-vol167-fscd2020/LIPIcs.FSCD.2020.23/LIPIcs.FSCD.2020.23.pdf\">semantics</a> for mutually inductive types in Lean you also gain a semantics for your guarded recursive types. Maybe. I haven't fully thought it through.</p>",
        "id": 427916576,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1710937895
    },
    {
        "content": "<p>Similarly I don't understand completely what you're trying to do, but I have a question: What is a negative type <code>‚ñπ D</code>? I see that you've said it can be erased to <code>Unit ‚Üí D</code>, but this is equivalent to just identifying some element in <code>D</code>, which is just equivalent to <code>D</code> no?</p>",
        "id": 427976377,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1710954161
    },
    {
        "content": "<p>it might be equivalent, but not definitionally equal, which is precisely the difference that this is supposed to emphasise i think? i could be wrong though...</p>",
        "id": 427977628,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1710954513
    },
    {
        "content": "<blockquote>\n<p>a reduction from that syntax to the syntax of mutually inductive types</p>\n</blockquote>\n<p>Yes, that is what I hope exists. I mean, if Lean can embed step-indexed logical relations as in the linked blog post (which is likely), it should be able to embed some flavour of guarded recursive types as well, at which point it is just a matter of offering good syntactic sugar in the source language (hopefully!). </p>\n<blockquote>\n<p>What is a negative type ‚ñπ D?</p>\n</blockquote>\n<p>I didn't mean to say that <code>‚ñπ D</code> is a \"negative type\", so let me try again.<br>\nIn the recursive type equation <code>D = ‚ñπ D -&gt; D</code>, the occurrence of <code>D</code> under <code>‚ñπ </code> is negative  because it occurs to the left of an uneven number of <code>(-&gt;)</code>. More formally, each recursively defined type gives rise to a signature functor such as, in this case,  <code>F a = ‚ñπ a -&gt; a</code>, and <code>D</code> is the (guarded) fixed-point of this functor.  Inductive types do not allow such negative recursive occurrences; an inductive type such as <code>data T where MkT : (T -&gt; T) -&gt; T</code> would be forbidden because a similar type can be exploited to recover general recursion (and thus violating strong normalisation of the type theory).<br>\nCommon notions of coinductive types do not allow negative recursive occurrences either. But guarded recursive types allow negative occurrences, as long as they are <em>guarded</em>, by the later modality  <code>‚ñπ </code>. That's tremendously useful to define dynamic processes such as transition systems, reactive systems (FRP), server processes, etc..</p>\n<p>Once you have type-checked your program and proofs, it's OK to <em>execute</em> <code>‚ñπ  D</code>  as if it was <code>Thunk D</code>, ostensibly reintroducing the negative occurrence. That is because guarded recursive types guarantee that all programs that passed the type-checker must terminate when desugared this way.</p>\n<p>Have a look at <a href=\"https://bentnib.org/productive.pdf\">https://bentnib.org/productive.pdf</a> to see how guarded recursive types might be useful in programming.<br>\nMore recent guarded recursive type systems allow for more programs to be typed (in particular ones with negative occurrences, in contrast to this rather early paper). The same paradigm can be used to define efficient functional-reactive programming frameworks, as requested here: <a href=\"#narrow/stream/113488-general/topic/.E2.9C.94.20Efficient.20coinduction/near/298282159\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/.E2.9C.94.20Efficient.20coinduction/near/298282159</a>. Concretely, you could define (forgive my incorrect lean syntax)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">data</span> <span class=\"n\">SF</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"bp\">‚ñπ</span>  <span class=\"n\">SF</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">SF</span>\n\n<span class=\"n\">ones</span> <span class=\"o\">:</span> <span class=\"n\">SF</span> <span class=\"n\">Unit</span> <span class=\"n\">Nat</span>\n<span class=\"n\">ones</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ones</span><span class=\"o\">)</span>\n</code></pre></div>\n<p><code>ones</code> encodes an infinite stream of 1.<br>\nNote that <code>ones</code> would never be possible as an inductive definition, because its recursive invokation does not decrease in any of its 0 arguments.<br>\nBut guarded recursive types provide us with a nearly-general fixpoint combinator <code>fix : (‚ñπ Œ± -&gt; Œ±) -&gt; Œ±</code>, and the definition of <code>ones</code> above makes implicit use of that: the recursive occurrence of <code>ones</code> has type <code>‚ñπ (SF Unit Nat)</code>, as this fixpoint combinator requires.<br>\nObviously there are more interesting, higher-order types than this, such as my <code>D</code> from the OP.</p>",
        "id": 428007803,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1710965349
    },
    {
        "content": "<p>I don't have any concrete thoughts, but if you do embark on this journey, please think about defeq from the beginning. In DTT, it's very important that your encoding has the right definitional, not just propositional equations. This is, I believe, one reason why data type packages like Isabelle's have never caught on in DTT land, despite their conceptual advantages.</p>",
        "id": 428100440,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1711018273
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> <a href=\"#narrow/stream/113488-general/topic/Guarded.20recursive.20types.20.28by.20desugaring.3F.29/near/428007803\">said</a>:</p>\n<blockquote>\n<p>In the recursive type equation <code>D = ‚ñπ D -&gt; D</code>, the occurrence of <code>D</code> under <code>‚ñπ </code> is negative  because it occurs to the left of an uneven number of <code>(-&gt;)</code>. More formally, each recursively defined type gives rise to a signature functor such as, in this case,  <code>F a = ‚ñπ a -&gt; a</code>, and <code>D</code> is the (guarded) fixed-point of this functor.  Inductive types do not allow such negative recursive occurrences; an inductive type such as <code>data T where MkT : (T -&gt; T) -&gt; T</code> would be forbidden because a similar type can be exploited to recover general recursion (and thus violating strong normalisation of the type theory).</p>\n</blockquote>\n<p>Just a note: Lean is already not strongly normalizing, this is not the problem. The problem is that such an inductive type would be unsound: you can use it to prove <code>False</code>. So the key question is: why are guarded inductive types not unsound in the same sense? And what is <code>‚ñπ</code> anyway?</p>",
        "id": 428174445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711039699
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> <a href=\"#narrow/stream/113488-general/topic/Guarded.20recursive.20types.20.28by.20desugaring.3F.29/near/428007803\">said</a>:</p>\n<blockquote>\n<p><code>ones</code> encodes an infinite stream of 1.</p>\n</blockquote>\n<p>How do you know this? Can you prove it, and if so what would the proof look like?</p>",
        "id": 428175211,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711039950
    },
    {
        "content": "<p>What are the reasoning principles associated with <code>‚ñπ</code>?</p>",
        "id": 428175309,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711039978
    },
    {
        "content": "<blockquote>\n<p>why are guarded inductive types not unsound in the same sense?</p>\n</blockquote>\n<p>There is a constructive encoding of this type theory in terms of the topos of trees, explicitly allowing these negative occurrences. See also <a href=\"https://arxiv.org/pdf/1611.09263.pdf\">https://arxiv.org/pdf/1611.09263.pdf</a>:</p>\n<blockquote>\n<p>Guarded recursive types with negative variance. A key feature of guarded recursive types<br>\nare that they support negative occurrences of recursion variables. This is important for applications<br>\nto models of program logics [ 7].</p>\n</blockquote>\n<p>Of course, the type system <em>restricts</em> the way in which parameters of type <code>‚ñπ D</code> might be used; otherwise you would indeed be able to prove <code>False</code>.</p>\n<blockquote>\n<p>And what is ‚ñπ anyway?</p>\n</blockquote>\n<p>See any of the work I cited; the definition varies. Later works define it in terms of Clock variables; sort of <code>‚ñπ A = Nat -&gt; A</code> but properly restricted (downwards closed, etc.)</p>\n<blockquote>\n<p>How do you know this? Can you prove it, and if so what would the proof look like?</p>\n</blockquote>\n<p>I cannot prove it, for multiple reasons: It is not a well-formed program (yet?), it is not fully elaborated, I lack the formal background. But what I <em>do</em> know is: I want to write programs (and perhaps proofs) in this framework!</p>\n<blockquote>\n<p>What are the reasoning principles associated with ‚ñπ?</p>\n</blockquote>\n<p>I would have to delegate to one of the papers, such as <a href=\"https://pure.itu.dk/ws/portalfiles/portal/82163359/bahr17lics_paper.pdf\">The clocks are ticking! No more delays</a>. Or the implementation in Guarded Cubical Agda. Perhaps my use of it here is helpful as well: <a href=\"https://github.com/sgraf812/abs-den/blob/main/agda/Semantics.agda\">https://github.com/sgraf812/abs-den/blob/main/agda/Semantics.agda</a>. This is the trusted \"Prelude\" of Guarded Cubical Agda: <a href=\"https://github.com/sgraf812/abs-den/blob/main/agda/Later.agda\">https://github.com/sgraf812/abs-den/blob/main/agda/Later.agda</a>, defining the Later modality among other things.</p>",
        "id": 428179114,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1711041129
    },
    {
        "content": "<p>My impression regarding clocked stuff is that this is actually a definition by recursion, not induction</p>",
        "id": 428187923,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711044094
    },
    {
        "content": "<p>recursion has no restrictions regarding the recursive use appearing positively or anything like that, but they must occur at smaller arguments (= \"later\")</p>",
        "id": 428188111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711044154
    },
    {
        "content": "<p>However the missing thing here seems to be the base case, without which I think you are still in soundness trouble. If I define <code>P := (‚ñπ P -&gt; False)</code>, is <code>P</code> inhabited or not?</p>",
        "id": 428188297,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711044232
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> <a href=\"#narrow/stream/113488-general/topic/Guarded.20recursive.20types.20.28by.20desugaring.3F.29/near/428179114\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>How do you know this? Can you prove it, and if so what would the proof look like?</p>\n</blockquote>\n<p>I cannot prove it, for multiple reasons: It is not a well-formed program (yet?), it is not fully elaborated, I lack the formal background. But what I <em>do</em> know is: I want to write programs (and perhaps proofs) in this framework!</p>\n</blockquote>\n<p>Figuring out the answer to this question is a prerequisite for being able to define this framework, whether by a custom type checker or by a desugaring. You have to know what the desugaring is before you can write it in code</p>",
        "id": 428189026,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711044495
    },
    {
        "content": "<p>As I said, I lack much of the formal background to give an informed answer to many of your questions.<br>\nI can answer this question, however:</p>\n<blockquote>\n<p>If I define P := (‚ñπ P -&gt; False), is P inhabited or not?</p>\n</blockquote>\n<p>Your <code>P</code> is indeed a well-formed guarded recursive type. But I'm pretty confident that it is not inhabited, for if there exists <code>p : P</code>, I can do <code>p (later p) : False</code> (where <code>later : Œ± -&gt; ‚ñπ Œ±</code> is the <code>pure</code> implementation of the <code>Applicative</code> instance of <code>‚ñπ</code>).</p>\n<p>It is not so hard to give a library implementation of <code>‚ñπ</code>; Basically, any <code>Type</code> involving <code>‚ñπ</code> is mapped to <code>Type' := Nat -&gt; Type</code> with a few restrictions, as outlined in the linked <a href=\"https://siek.blogspot.com/2023/04/type-safety-in-10-easy-4-medium-and-1.html\">blog post, cf. <code>Set·µí</code></a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">downClosed</span> <span class=\"o\">:</span>  <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">t</span> <span class=\"n\">n</span>\n<span class=\"n\">bot</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">'</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">t</span> <span class=\"mi\">0</span>\n<span class=\"bp\">‚ñπ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">'</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span><span class=\"bp\">'</span>\n<span class=\"o\">(</span><span class=\"bp\">‚ñπ</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">Unit</span>\n<span class=\"o\">(</span><span class=\"bp\">‚ñπ</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">‚ñπ</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n<span class=\"n\">later</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span>  <span class=\"bp\">‚ñπ</span> <span class=\"n\">A</span>   <span class=\"c1\">-- I'm a bit doubtful this definition checks, but I hope you get the idea</span>\n<span class=\"n\">later</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">unit</span>\n<span class=\"n\">later</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>So every <code>Type'</code> (even the lifting of <code>False</code>) starts out as inhabited at step/fuel 0. Presumably that is the \"base case\" that you wondered about? The blog post compares to induction on natural numbers, observing</p>\n<blockquote>\n<p>In the world of [step-indexed logic], propositions are always true at zero, so the base case <code>P 0</code> is not necessary.</p>\n</blockquote>\n<p>To me, the point of this theory is that the step indices are completely hidden behind clock variables, and my hope is that clock variables can be erased for code generation.</p>\n<p>If you want to see how the <code>ones</code> example is elaborated in detail, I suggest you look at \"Section IV: EXAMPLE: PROGRAMMING WITH STREAMS\" of <a href=\"https://pure.itu.dk/ws/portalfiles/portal/82163359/bahr17lics_paper.pdf\">https://pure.itu.dk/ws/portalfiles/portal/82163359/bahr17lics_paper.pdf</a>, specifically the <code>const</code> function (which generalises <code>ones</code>). (Why isn't this Section 2 ...) Streams are simpler than signal functions <code>SF</code>, but I hope you can see that a similar elaboration is possible for the hypothetical Lean program <code>ones</code>.</p>",
        "id": 428281024,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1711096105
    }
]