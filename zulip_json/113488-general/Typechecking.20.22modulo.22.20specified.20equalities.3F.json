[
    {
        "content": "<p>In the following code, to prove the theorem <code>ex</code> it seems necessary to define the auxiliary theorem <code>ex_aux</code> first:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">prf</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">P</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ex_aux</span> <span class=\"o\">(</span><span class=\"n\">prf</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hab</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">prf</span>\n  <span class=\"n\">exact</span> <span class=\"n\">prf</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ex</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">ex_aux</span> <span class=\"n\">prf</span> <span class=\"n\">v</span>\n</code></pre></div>\n<p>I was wondering, does Lean have an option or tactic that takes a list of equalities (here <code>hab</code>) and henceforth simulates typechecking as if this equality was definitional (behind the scenes, injecting type casts using these equalities where necessary)? For example, the above might become something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">prf</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">P</span>\n\n<span class=\"bp\">#</span><span class=\"n\">register_eq</span> <span class=\"o\">[</span><span class=\"n\">hab</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ex</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">prf</span> <span class=\"n\">v</span> <span class=\"c1\">-- elaborates to `prf (Eq.mpr (congrArg T hab) v)`</span>\n</code></pre></div>\n<p>If not, do we have an idea of how useful such a functionality would be?</p>",
        "id": 434042044,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1713445515
    },
    {
        "content": "<p>Well, of course I take it back that the auxiliary theorem is \"necessary\" because you can always manually cast things, but I imagine that is something that could be automated if Lean is aware of what equalities it needs to use</p>",
        "id": 434044832,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1713446325
    },
    {
        "content": "<p>(Presumably this is just an over minimization, but note that you can prove <code>ex</code> with <code>by cases v</code>, i.e. your <code>T</code> type is always empty)</p>",
        "id": 434051485,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713448130
    },
    {
        "content": "<p>Oh right, thanks yeah I meant for <code>T</code> to represent an arbitrary inductive type family (just added a constructor to it)</p>",
        "id": 434052815,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1713448506
    },
    {
        "content": "<p>You don't need <code>ex_aux</code> first, this works: <code>theorem ex (v : T b) : P := prf (hab ▸ v)</code>.</p>",
        "id": 434099580,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1713452654
    },
    {
        "content": "<p>This <code>register_eq </code> functionality would be useful, but it falls quite far outside the scope of Lean. <br>\nThe most flexible version of this is extensional type theory, but in such a theory type checking is much more complicated (in particular, undecidable), which has many drawbacks. There are other proof assistants taking this approach.</p>",
        "id": 434101569,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1713452808
    },
    {
        "content": "<p>I see. What I had in mind was a kind of \"pseudo-extensionality\", where Lean would make its best effort to automatically unify types (via casting) using the equalities that it has. I'm working on something along these lines (to replace definitional proof irrelevance with propositional proof irrelevance for the purpose of translation), so I wanted to see if anything similar exists that I can steal code/ideas from, though my impression now is that there isn't.</p>",
        "id": 434125841,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1713454658
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/113488-general/topic/Typechecking.20.22modulo.22.20specified.20equalities.3F/near/434099580\">said</a>:</p>\n<blockquote>\n<p>You don't need <code>ex_aux</code> first, this works: <code>theorem ex (v : T b) : P := prf (hab ▸ v)</code>.</p>\n</blockquote>\n<p>Oh nice, I always forget about <code>subst</code>. Though I imagine in some more complex cases it may not be able to correctly infer the motive argument</p>",
        "id": 434126858,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1713454738
    },
    {
        "content": "<p>Here is a more contrived example where <code>subst</code> doesn't cut it, I think:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">U</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">ua</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"n\">a</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">ub</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"n\">b</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">huab</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">ua</span> <span class=\"n\">ub</span> <span class=\"c1\">-- would not need HEq if declared #register_eq [hab] above</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">prf</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">a</span> <span class=\"n\">ua</span> <span class=\"bp\">→</span> <span class=\"n\">P</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ex_aux</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ua</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ub</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">huab</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">ua</span> <span class=\"n\">ub</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">prf</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">a</span> <span class=\"n\">ua</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">b</span> <span class=\"n\">ub</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">subst</span> <span class=\"n\">hab</span>\n  <span class=\"n\">subst</span> <span class=\"n\">huab</span>\n  <span class=\"n\">exact</span> <span class=\"n\">prf</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ex</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">b</span> <span class=\"n\">ub</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">ex_aux</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hab</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">huab</span> <span class=\"n\">prf</span> <span class=\"n\">v</span>\n</code></pre></div>",
        "id": 434201299,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1713458855
    },
    {
        "content": "<p>Can this be solved by a variant of the ETT to ITT translation? ETT allows <em>all</em> equality assumptions to be used as definitional equalities. There are several papers detailing how to translate an ETT term (whose type happens to be a valid ITT type) to an ITT term. If this (together with a partial typechecking algorithm for ETT) gets implemented as a tactic we can invoke it and reason as if some equalities became definitional.</p>",
        "id": 434330448,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1713521445
    },
    {
        "content": "<p>In more complicated examples you can still do it without additional lemmas, using <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>'s congruence generator (he reminded me of the existence yesterday). Then it can be this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">ex</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"n\">b</span> <span class=\"n\">ub</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">prf</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">cast</span> <span class=\"n\">congr</span><span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"bp\">$</span><span class=\"n\">hab</span> <span class=\"bp\">$</span><span class=\"n\">huab</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">v</span>\n</code></pre></div>",
        "id": 434334161,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1713522822
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"404479\">Trebor Huang</span> <a href=\"#narrow/stream/113488-general/topic/Typechecking.20.22modulo.22.20specified.20equalities.3F/near/434330448\">said</a>:</p>\n<blockquote>\n<p>Can this be solved by a variant of the ETT to ITT translation? ETT allows <em>all</em> equality assumptions to be used as definitional equalities. There are several papers detailing how to translate an ETT term (whose type happens to be a valid ITT type) to an ITT term. If this (together with a partial typechecking algorithm for ETT) gets implemented as a tactic we can invoke it and reason as if some equalities became definitional.</p>\n</blockquote>\n<p>Interesting, I hadn't really conceptualized of my task as one of converting from ETT to ITT, but rather of making a generic framework for \"cast injection\" (where equalities can be derived from a number of different sources). Now that I think about it, the proof irrelevance axiom (<code>axiom prfIrrel (P Q : Prop) (h : P = Q) (p : Q) (q : P) : HEq p q</code>) can be considered just another one of the registered equalities that would be attempted when typechecking fails (with proof irrelevance disabled). So I suspect those authors may have run into similar issues, I'll have to read more into it.</p>\n<p>I guess the \"partial typechecking algorithm\" you refer to would be the algorithm used to derive the necessary equalities from their more generic forms? I think that Lean's typeclass mechanisms could help here (e.g. in deriving the <code>h</code> argument to the <code>prfIrrel</code> axiom).</p>",
        "id": 434356373,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1713531207
    }
]